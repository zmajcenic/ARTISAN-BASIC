# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		   EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000              COLL_CMD       EQU 1
  14  4000
  15  4000              BASIC_EXTENSION   EQU 1
  16  4000              DEFUSR_EXTENSION  EQU 1
  17  4000
  18  4000              CHPUT   EQU    #A2
  19  4000              CALBAS  EQU		#159
  20  4000              ERRHAND EQU    #406F
  21  4000              FRMEVL  EQU    #4C64
  22  4000              FRESTR  EQU		#67D0
  23  4000              ; FRMQNT = formula quantificator
  24  4000              ; input HL=pointer to current program expression
  25  4000              ; output HL=next address
  26  4000              ; output DE=integer datum
  27  4000              FRMQNT	EQU		#542F
  28  4000              ; GETBYT = get byte parameter
  29  4000              ; input HL=pointer to current program expression
  30  4000              ; output HL=next address
  31  4000              ; output A=E=byte read
  32  4000              GETBYT		EQU	#521C
  33  4000              CHRGTR  	   EQU   #4666
  34  4000              PTRGET		EQU 	#5EA4
  35  4000              SUBFLG		EQU	#F6A5
  36  4000              SYNCHR		EQU	#558C
  37  4000              VALTYP  	   EQU   #F663
  38  4000              DAC         EQU   #F7F6
  39  4000              USR     	   EQU   #F7F8
  40  4000              PROCNM		EQU	#FD89
  41  4000              BIOS_FILVRM EQU   #0056
  42  4000              CLIKSW		EQU	#F3DB
  43  4000
  44  4000              RAMAD0	   EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  45  4000              RAMAD1	   EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  46  4000              RAMAD2	   EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  47  4000              RAMAD3	   EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  48  4000              EXPTBL	   EQU   #FCC1
  49  4000              SCRMOD	   EQU   #FCAF ; current screen mode
  50  4000              REG1SAV     EQU   #F3E0 ; VDP(1)
  51  4000              JIFFY	      EQU   #FC9E
  52  4000              GRPPAT	   EQU   #F3CF ; SCREEN 2 sprite generator table address
  53  4000              GRPCGP		EQU	#F3CB ; SCREEN 2 pattern generator table address
  54  4000              GRPATR      EQU   #F3CD ; SCREEN 2 sprite attribute table address
  55  4000              T32PAT	   EQU   #F3C5 ; SCREEN 1 sprite generator table address
  56  4000              T32CGP      EQU   #F3C1 ; SCREEN 1 pattern ganarator table address
  57  4000              T32ATR      EQU   #F3C3 ; SCREEN 1 sprite attribute table address
  58  4000
  59  4000              ; BASIC error codes
  60  4000              ;01 NEXT without FOR
  61  4000              ;02 Syntax error
  62  4000              ;03 RETURN without GOSUB
  63  4000              ;04 Out of DATA
  64  4000              ;05 Illegal function call
  65  4000              ;06 Overflow
  66  4000              ;07 Out of memory
  67  4000              ;08 Undefined line number
  68  4000              ;09 Subscript out of range
  69  4000              ;10 Redimensioned array
  70  4000              ;11 Division by zero
  71  4000              ;12 Illegal direct
  72  4000              ;13 Type mismatch
  73  4000              ;14 Out of string space
  74  4000              ;15 String too long
  75  4000              ;16 String formula too complex
  76  4000              ;17 Can't CONTINUE
  77  4000              ;18 Undefined user function
  78  4000              ;19 Device I/O error
  79  4000              ;20 Verify error
  80  4000              ;21 No RESUME
  81  4000              ;22 RESUME without error
  82  4000              ;23 Unprintable error
  83  4000              ;24 Missing operand
  84  4000              ;25 Line buffer overflow
  85  4000              ;50 FIELD overflow
  86  4000              ;51 Internal error
  87  4000              ;52 Bad file number
  88  4000              ;53 File not found
  89  4000              ;54 File already open
  90  4000              ;55 Input past end
  91  4000              ;56 Bad file name
  92  4000              ;57 Direct statement in file
  93  4000              ;58 Sequential I/O only
  94  4000              ;59 File not OPEN
  95  4000
  96  4000
  97  4000               ; simulate cartridge with BASIC extension
  98  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  98  4004 05 6A 00 00
  98  4008 00 00 00 00
  98  400C 00 00 00 00
  99  4010
 100  4010              ; this location #4010 stores last location used by basic extension
 101  4010              ; free memory after that point
 102  4010              FREEMEMPTR:
 103  4010 E6 6A         DW EXT_END
 104  4012
 105  4012              ; this location #4012 stores extension version in DAA format
 106  4012              ; first byte is major version and second minor
 107  4012              VERSION:
 108  4012 00 81         DB #00, #81
 109  4014
 110  4014              ; this location #4014 contains a jump to entry point for DEFUSR approach
 111  4014              ; if excluded it contains 3xRET so that sound player can be at aspecific spot
 112  4014               IF (DEFUSR_EXTENSION == 1)
 113  4014 C3 16 67        JP DEFUSR_ENTRY
 114  4017               ELSE
 115  4017 ~               .3 RET
 116  4017               ENDIF
 117  4017
 118  4017              ; binary included AKG player compiled at #4017
 119  4017               IF (SOUND_CMDS == 1)
 120  4017              	INCBIN "bin/AKG.bin"
 121  4CF3              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF3              MAIN_PLAYER_START EQU 04017H
   2+ 4CF3              PLY_AKG_START EQU 04017H
   3+ 4CF3              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 04020H
   4+ 4CF3              PLY_AKG_INITSOUNDEFFECTS EQU 04020H
   5+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04024H
   6+ 4CF3              PLY_AKG_PLAYSOUNDEFFECT EQU 04024H
   7+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04025H
   8+ 4CF3              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04025H
   9+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 0404CH
  10+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 0404CH
  11+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 0405AH
  12+ 4CF3              PLY_AKG_PSES_PLAY EQU 04093H
  13+ 4CF3              PLY_AKG_PSES_READFIRSTBYTE EQU 0409CH
  14+ 4CF3              PLY_AKG_PSES_S_ENDORLOOP EQU 040B4H
  15+ 4CF3              PLY_AKG_PSES_S_LOOP EQU 040BFH
  16+ 4CF3              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C5H
  17+ 4CF3              PLY_AKG_PSES_NOTREACHED EQU 040D8H
  18+ 4CF3              PLY_AKG_PSES_HARDWAREONLY EQU 040DCH
  19+ 4CF3              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E3H
  20+ 4CF3              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F5H
  21+ 4CF3              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FFH
  22+ 4CF3              PLY_AKG_PSES_H_AFTERRETRIG EQU 04109H
  23+ 4CF3              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411DH
  24+ 4CF3              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 04122H
  25+ 4CF3              PLY_AKG_PSES_READHARDWAREPERIOD EQU 0412AH
  26+ 4CF3              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04135H
  27+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 04141H
  28+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04143H
  29+ 4CF3              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04149H
  30+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414DH
  31+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414DH
  32+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414FH
  33+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414FH
  34+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414FH
  35+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 04150H
  36+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 04151H
  37+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04155H
  38+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04155H
  39+ 4CF3              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04155H
  40+ 4CF3              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415DH
  41+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04165H
  42+ 4CF3              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04165H
  43+ 4CF3              PLY_AKG_INIT EQU 04165H
  44+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04165H
  45+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04193H
  46+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A7H
  47+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B9H
  48+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D8H
  49+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E5H
  50+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL EQU 041EBH
  51+ 4CF3              PLY_AKG_INITTABLE0 EQU 041EEH
  52+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EEH
  53+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04208H
  54+ 4CF3              PLY_AKG_INITTABLE0_END EQU 04208H
  55+ 4CF3              PLY_AKG_INITTABLE1 EQU 04208H
  56+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04208H
  57+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 0420CH
  58+ 4CF3              PLY_AKG_INITTABLE1_END EQU 0420CH
  59+ 4CF3              PLY_AKG_INITTABLEORA EQU 0420CH
  60+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 0420CH
  61+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04224H
  62+ 4CF3              PLY_AKG_INITTABLEORA_END EQU 04224H
  63+ 4CF3              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04224H
  64+ 4CF3              PLY_AKG_STOP EQU 04224H
  65+ 4CF3              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04236H
  66+ 4CF3              PLY_AKG_PLAY EQU 04236H
  67+ 4CF3              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423EH
  68+ 4CF3              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04244H
  69+ 4CF3              PLY_AKG_READLINKER EQU 04249H
  70+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04249H
  71+ 4CF3              PLY_AKG_READLINKER_PTLINKER EQU 04249H
  72+ 4CF3              PLY_AKG_READLINKER_NOLOOP EQU 04254H
  73+ 4CF3              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428DH
  74+ 4CF3              PLY_AKG_READLINE EQU 04290H
  75+ 4CF3              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 04290H
  76+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04296H
  77+ 4CF3              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04296H
  78+ 4CF3              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A3H
  79+ 4CF3              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A7H
  80+ 4CF3              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042AAH
  81+ 4CF3              PLY_AKG_SPEEDTRACK_END EQU 042ADH
  82+ 4CF3              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042ADH
  83+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B3H
  84+ 4CF3              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B3H
  85+ 4CF3              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042C0H
  86+ 4CF3              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C4H
  87+ 4CF3              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C7H
  88+ 4CF3              PLY_AKG_EVENTTRACK_END EQU 042CAH
  89+ 4CF3              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042CAH
  90+ 4CF3              PLY_AKG_CHANNEL1_READTRACK EQU 042D6H
  91+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D6H
  92+ 4CF3              PLY_AKG_CHANNEL1_PTTRACK EQU 042D6H
  93+ 4CF3              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042F1H
  94+ 4CF3              PLY_AKG_CHANNEL1_WAIT EQU 042FCH
  95+ 4CF3              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04303H
  96+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04303H
  97+ 4CF3              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04303H
  98+ 4CF3              PLY_AKG_CHANNEL1_NOTE EQU 0430CH
  99+ 4CF3              PLY_AKG_BASENOTEINDEX EQU 0430CH
 100+ 4CF3              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430EH
 101+ 4CF3              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430EH
 102+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431EH
 103+ 4CF3              PLY_AKG_INSTRUMENTSTABLE EQU 0431EH
 104+ 4CF3              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 04330H
 105+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 04340H
 106+ 4CF3              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04368H
 107+ 4CF3              PLY_AKG_CHANNEL1_READCELLEND EQU 0436BH
 108+ 4CF3              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 0436BH
 109+ 4CF3              PLY_AKG_CHANNEL2_READTRACK EQU 04377H
 110+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04377H
 111+ 4CF3              PLY_AKG_CHANNEL2_PTTRACK EQU 04377H
 112+ 4CF3              PLY_AKG_CHANNEL2_SMALLWAIT EQU 04392H
 113+ 4CF3              PLY_AKG_CHANNEL2_WAIT EQU 0439DH
 114+ 4CF3              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A4H
 115+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A4H
 116+ 4CF3              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A4H
 117+ 4CF3              PLY_AKG_CHANNEL2_NOTE EQU 043ADH
 118+ 4CF3              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043B2H
 119+ 4CF3              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043B2H
 120+ 4CF3              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D4H
 121+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E4H
 122+ 4CF3              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 0440CH
 123+ 4CF3              PLY_AKG_CHANNEL2_READCELLEND EQU 0440FH
 124+ 4CF3              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440FH
 125+ 4CF3              PLY_AKG_CHANNEL3_READTRACK EQU 0441BH
 126+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 0441BH
 127+ 4CF3              PLY_AKG_CHANNEL3_PTTRACK EQU 0441BH
 128+ 4CF3              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04436H
 129+ 4CF3              PLY_AKG_CHANNEL3_WAIT EQU 04441H
 130+ 4CF3              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04448H
 131+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04448H
 132+ 4CF3              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04448H
 133+ 4CF3              PLY_AKG_CHANNEL3_NOTE EQU 04451H
 134+ 4CF3              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04456H
 135+ 4CF3              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04456H
 136+ 4CF3              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04478H
 137+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04488H
 138+ 4CF3              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044B0H
 139+ 4CF3              PLY_AKG_CHANNEL3_READCELLEND EQU 044B3H
 140+ 4CF3              PLY_AKG_CURRENTSPEED EQU 044B3H
 141+ 4CF3              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B5H
 142+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B8H
 143+ 4CF3              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B8H
 144+ 4CF3              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044BBH
 145+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BEH
 146+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BEH
 147+ 4CF3              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044CAH
 148+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044D1H
 149+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D4H
 150+ 4CF3              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044DAH
 151+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DDH
 152+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DDH
 153+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044EBH
 154+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044F0H
 155+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044FBH
 156+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FEH
 157+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FEH
 158+ 4CF3              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 04501H
 159+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04504H
 160+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04504H
 161+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450DH
 162+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04517H
 163+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 0451AH
 164+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 0451AH
 165+ 4CF3              PLY_AKG_CHANNEL1_PITCH EQU 0451AH
 166+ 4CF3              PLY_AKG_CHANNEL1_ISPITCH EQU 0451DH
 167+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 04522H
 168+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACK EQU 04522H
 169+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04526H
 170+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04528H
 171+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 0452AH
 172+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 04531H
 173+ 4CF3              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 04532H
 174+ 4CF3              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04535H
 175+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04535H
 176+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 04551H
 177+ 4CF3              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 04551H
 178+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455EH
 179+ 4CF3              PLY_AKG_CHANNEL1_GLIDEOVER EQU 04562H
 180+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 04572H
 181+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 04572H
 182+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04573H
 183+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04574H
 184+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04576H
 185+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04576H
 186+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04576H
 187+ 4CF3              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04577H
 188+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04578H
 189+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 0457AH
 190+ 4CF3              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 0457AH
 191+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 0457AH
 192+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 0457AH
 193+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 0457AH
 194+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457DH
 195+ 4CF3              PLY_AKG_CHANNEL1_PITCH_END EQU 0457FH
 196+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04587H
 197+ 4CF3              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04587H
 198+ 4CF3              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 0458AH
 199+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458DH
 200+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458DH
 201+ 4CF3              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04599H
 202+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 045A0H
 203+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A3H
 204+ 4CF3              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A9H
 205+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045ACH
 206+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045ACH
 207+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045BAH
 208+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BFH
 209+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045CAH
 210+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CDH
 211+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CDH
 212+ 4CF3              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045D0H
 213+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D3H
 214+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D3H
 215+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045DCH
 216+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E6H
 217+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E9H
 218+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E9H
 219+ 4CF3              PLY_AKG_CHANNEL2_PITCH EQU 045E9H
 220+ 4CF3              PLY_AKG_CHANNEL2_ISPITCH EQU 045ECH
 221+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045F1H
 222+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045F1H
 223+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F5H
 224+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F7H
 225+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F9H
 226+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 04600H
 227+ 4CF3              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 04601H
 228+ 4CF3              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04604H
 229+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04604H
 230+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 04620H
 231+ 4CF3              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 04620H
 232+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462DH
 233+ 4CF3              PLY_AKG_CHANNEL2_GLIDEOVER EQU 04631H
 234+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 04641H
 235+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 04641H
 236+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 04642H
 237+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04643H
 238+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04645H
 239+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04645H
 240+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04645H
 241+ 4CF3              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04646H
 242+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04647H
 243+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04649H
 244+ 4CF3              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04649H
 245+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04649H
 246+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04649H
 247+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04649H
 248+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_END EQU 0464CH
 249+ 4CF3              PLY_AKG_CHANNEL2_PITCH_END EQU 0464EH
 250+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04656H
 251+ 4CF3              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04656H
 252+ 4CF3              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04659H
 253+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 0465CH
 254+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 0465CH
 255+ 4CF3              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04668H
 256+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466FH
 257+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 04672H
 258+ 4CF3              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04678H
 259+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 0467BH
 260+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 0467BH
 261+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04689H
 262+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468EH
 263+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04699H
 264+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 0469CH
 265+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 0469CH
 266+ 4CF3              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469FH
 267+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 046A2H
 268+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE EQU 046A2H
 269+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046ABH
 270+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B5H
 271+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B8H
 272+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B8H
 273+ 4CF3              PLY_AKG_CHANNEL3_PITCH EQU 046B8H
 274+ 4CF3              PLY_AKG_CHANNEL3_ISPITCH EQU 046BBH
 275+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046C0H
 276+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046C0H
 277+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C4H
 278+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C6H
 279+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C8H
 280+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CFH
 281+ 4CF3              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046D0H
 282+ 4CF3              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D3H
 283+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D3H
 284+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046EFH
 285+ 4CF3              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046EFH
 286+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046FCH
 287+ 4CF3              PLY_AKG_CHANNEL3_GLIDEOVER EQU 04700H
 288+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 04710H
 289+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 04710H
 290+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 04711H
 291+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 04712H
 292+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04714H
 293+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04714H
 294+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04714H
 295+ 4CF3              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04715H
 296+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04716H
 297+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04718H
 298+ 4CF3              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04718H
 299+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04718H
 300+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04718H
 301+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04718H
 302+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_END EQU 0471BH
 303+ 4CF3              PLY_AKG_CHANNEL3_PITCH_END EQU 0471DH
 304+ 4CF3              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04729H
 305+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04729H
 306+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04729H
 307+ 4CF3              PLY_AKG_CHANNEL1_TRACKNOTE EQU 0472CH
 308+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472EH
 309+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04734H
 310+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04737H
 311+ 4CF3              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04737H
 312+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 0473AH
 313+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04743H
 314+ 4CF3              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 0474BH
 315+ 4CF3              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04758H
 316+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04758H
 317+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04758H
 318+ 4CF3              PLY_AKG_CHANNEL2_TRACKNOTE EQU 0475BH
 319+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475DH
 320+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04763H
 321+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04766H
 322+ 4CF3              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04766H
 323+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04769H
 324+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 04772H
 325+ 4CF3              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 0477AH
 326+ 4CF3              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04788H
 327+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04788H
 328+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04788H
 329+ 4CF3              PLY_AKG_CHANNEL3_TRACKNOTE EQU 0478BH
 330+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478DH
 331+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04793H
 332+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04796H
 333+ 4CF3              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04796H
 334+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04799H
 335+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 047A2H
 336+ 4CF3              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047AAH
 337+ 4CF3              PLY_AKG_SENDPSGREGISTERS EQU 047B9H
 338+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047C1H
 339+ 4CF3              PLY_AKG_PSGREG01_INSTR EQU 047C1H
 340+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047D1H
 341+ 4CF3              PLY_AKG_PSGREG23_INSTR EQU 047D1H
 342+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047E2H
 343+ 4CF3              PLY_AKG_PSGREG45_INSTR EQU 047E2H
 344+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F3H
 345+ 4CF3              PLY_AKG_PSGREG6_8_INSTR EQU 047F3H
 346+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04804H
 347+ 4CF3              PLY_AKG_PSGREG9_10_INSTR EQU 04804H
 348+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04815H
 349+ 4CF3              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04815H
 350+ 4CF3              PLY_AKG_PSGREG13_OLDVALUE EQU 0482AH
 351+ 4CF3              PLY_AKG_RETRIG EQU 0482CH
 352+ 4CF3              PLY_AKG_PSGREG13_INSTR EQU 0482EH
 353+ 4CF3              PLY_AKG_PSGREG13_END EQU 0483DH
 354+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483DH
 355+ 4CF3              PLY_AKG_SAVESP EQU 0483DH
 356+ 4CF3              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 04841H
 357+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTS EQU 04849H
 358+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04856H
 359+ 4CF3              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04856H
 360+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485EH
 361+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 0486BH
 362+ 4CF3              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 0486BH
 363+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTS EQU 04873H
 364+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487EH
 365+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS EQU 0487EH
 366+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488DH
 367+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488DH
 368+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04894H
 369+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A4H
 370+ 4CF3              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A4H
 371+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048ABH
 372+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048ABH
 373+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048AEH
 374+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B7H
 375+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B7H
 376+ 4CF3              PLY_AKG_READINSTRUMENTCELL EQU 048BDH
 377+ 4CF3              PLY_AKG_NOSOFTNOHARD EQU 048CAH
 378+ 4CF3              PLY_AKG_NSNH_NONOISE EQU 048DFH
 379+ 4CF3              PLY_AKG_SOFT EQU 048E2H
 380+ 4CF3              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E9H
 381+ 4CF3              PLY_AKG_S_NOTSIMPLE EQU 048F1H
 382+ 4CF3              PLY_AKG_S_AFTERSIMPLETEST EQU 048F4H
 383+ 4CF3              PLY_AKG_HARDTOSOFT EQU 04901H
 384+ 4CF3              PLY_AKG_HS_JUMPRATIO EQU 0490CH
 385+ 4CF3              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04939H
 386+ 4CF3              PLY_AKG_ENDWITHOUTLOOP EQU 0493BH
 387+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 0493BH
 388+ 4CF3              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 0493BH
 389+ 4CF3              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04943H
 390+ 4CF3              PLY_AKG_SH_JUMPRATIO EQU 04950H
 391+ 4CF3              PLY_AKG_SH_JUMPRATIOEND EQU 04971H
 392+ 4CF3              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 04980H
 393+ 4CF3              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04986H
 394+ 4CF3              PLY_AKG_H_OR_ENDWITHLOOP EQU 049A0H
 395+ 4CF3              PLY_AKG_H_RETRIGEND EQU 049B2H
 396+ 4CF3              PLY_AKG_H_AFTERRETRIG EQU 049B3H
 397+ 4CF3              PLY_AKG_ENDWITHLOOP EQU 049C5H
 398+ 4CF3              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049CCH
 399+ 4CF3              PLY_AKG_S_OR_H_NEXTBYTE EQU 049E2H
 400+ 4CF3              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049F0H
 401+ 4CF3              PLY_AKG_S_OR_H_AFTERPITCH EQU 04A00H
 402+ 4CF3              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0EH
 403+ 4CF3              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1DH
 404+ 4CF3              PLY_AKG_SHOHS_RETRIGEND EQU 04A2CH
 405+ 4CF3              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2DH
 406+ 4CF3              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3FH
 407+ 4CF3              PLY_AKG_EFFECTTABLE EQU 04A4DH
 408+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4DH
 409+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A71H
 410+ 4CF3              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A71H
 411+ 4CF3              PLY_AKG_EFFECT_RESET EQU 04A74H
 412+ 4CF3              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A76H
 413+ 4CF3              PLY_AKG_EFFECT_VOLUME EQU 04A91H
 414+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9DH
 415+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA3H
 416+ 4CF3              PLY_AKG_ARPEGGIOSTABLE EQU 04AA3H
 417+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04ACAH
 418+ 4CF3              PLY_AKG_EFFECT_PITCHTABLE EQU 04AD1H
 419+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD7H
 420+ 4CF3              PLY_AKG_PITCHESTABLE EQU 04AD7H
 421+ 4CF3              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFEH
 422+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B05H
 423+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B16H
 424+ 4CF3              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1DH
 425+ 4CF3              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2DH
 426+ 4CF3              PLY_AKG_EFFECT_PITCHUP EQU 04B42H
 427+ 4CF3              PLY_AKG_EFFECT_PITCHSTOP EQU 04B54H
 428+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B5BH
 429+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B85H
 430+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B85H
 431+ 4CF3              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9EH
 432+ 4CF3              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9EH
 433+ 4CF3              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BB0H
 434+ 4CF3              PLY_AKG_EFFECT_LEGATO EQU 04BC6H
 435+ 4CF3              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BDAH
 436+ 4CF3              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BE2H
 437+ 4CF3              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BEAH
 438+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BF2H
 439+ 4CF3              PLY_AKG_EVENT EQU 04BF2H
 440+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF3H
 441+ 4CF3              PLY_AKG_PERIODTABLE EQU 04BF3H
 442+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF3H
 443+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF3H
 444+ 4CF3              PLY_AKG_PERIODTABLE_END EQU 04CF3H
 445+ 4CF3              PLY_AKG_END EQU 04CF3H
 446+ 4CF3              MAIN_PLAYER_END EQU 04CF3H
 447+ 4CF3              TESTEREND EQU 04CF3H
 448+ 4CF3
# file closed: ./symbol/AKG.sym
 122  4CF3               ENDIF
 123  4CF3
 124  4CF3               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
   1+ 4CF3              ORIG.HTIMI:
   2+ 4CF3 00 00 00 00  	DB 0, 0, 0, 0, 0
   2+ 4CF7 00
   3+ 4CF8               EXPORT ORIG.HTIMI
   4+ 4CF8
   5+ 4CF8              ; *******************************************************************************************************
   6+ 4CF8              ; interrupt handler when page 0 enabled
   7+ 4CF8              ; we are here only if one of the extended basic commands have paged in page 0
   8+ 4CF8              ; which means we arrived from BASIC so page 2 is already good
   9+ 4CF8              VBLANK:
  10+ 4CF8              	EXPORT VBLANK
  11+ 4CF8
  12+ 4CF8 F5               PUSH AF
  13+ 4CF9              	; is VDP originator ?
  14+ 4CF9 DB 99        	IN	A, (099H)
  15+ 4CFB A7           	AND	A
  16+ 4CFC F2 23 4D     	JP P, .EXIT
  17+ 4CFF
  18+ 4CFF               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  19+ 4CFF C5               PUSH BC
  20+ 4D00 D5               PUSH DE
  21+ 4D01 E5               PUSH HL
  22+ 4D02 08               EX AF, AF'
  23+ 4D03 D9               EXX
  24+ 4D04 F5               PUSH AF
  25+ 4D05 C5               PUSH BC
  26+ 4D06 D5               PUSH DE
  27+ 4D07 E5               PUSH HL
  28+ 4D08 DD E5            PUSH IX
  29+ 4D0A FD E5            PUSH IY
  30+ 4D0C
  31+ 4D0C               IF (SPRITE_CMDS == 1)
  32+ 4D0C CD 5D 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  33+ 4D0F               ENDIF
  34+ 4D0F
  35+ 4D0F               IF (SOUND_CMDS == 1)
  36+ 4D0F 3A 8B 5B     	LD A, (SOUND_ENABLED)
  37+ 4D12 B7           	OR A
  38+ 4D13 C4 36 42     	CALL NZ,PLY_AKG_PLAY
  39+ 4D16               ENDIF
  40+ 4D16
  41+ 4D16                  ; increase JIFFY
  42+ 4D16                  ;LD HL,(JIFFY)
  43+ 4D16                  ;INC HL
  44+ 4D16                  ;LD (JIFFY),HL
  45+ 4D16
  46+ 4D16 FD E1            POP IY
  47+ 4D18 DD E1            POP IX
  48+ 4D1A E1               POP HL
  49+ 4D1B D1               POP DE
  50+ 4D1C C1               POP BC
  51+ 4D1D F1               POP AF
  52+ 4D1E 08               EX AF, AF'
  53+ 4D1F D9               EXX
  54+ 4D20 E1               POP HL
  55+ 4D21 D1               POP DE
  56+ 4D22 C1               POP BC
  57+ 4D23               ENDIF
  58+ 4D23
  59+ 4D23              .EXIT:
  60+ 4D23 F1           	POP AF
  61+ 4D24 FB           	EI
  62+ 4D25 ED 4D        	RETI
  63+ 4D27              ; *******************************************************************************************************
  64+ 4D27
  65+ 4D27              ; *******************************************************************************************************
  66+ 4D27              ; H.TIMI function
  67+ 4D27              ; we can end up here from anywhere so page in both page 0 and 2
  68+ 4D27              MBGE_HTIMI:
  69+ 4D27               EXPORT MBGE_HTIMI
  70+ 4D27
  71+ 4D27               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  72+ 4D27
  73+ 4D27 F5           	PUSH AF
  74+ 4D28
  75+ 4D28              	; enable page 2
  76+ 4D28 3E 02            LD A, 2
  77+ 4D2A CD 35 69         CALL GET_PAGE_INFO
  78+ 4D2D C5               PUSH BC
  79+ 4D2E D5               PUSH DE
  80+ 4D2F 3A 43 F3         LD A, (RAMAD2)
  81+ 4D32 26 80            LD H, 080H
  82+ 4D34 CD 7C 69         CALL LOCAL_ENASLT
  83+ 4D37              	; enable page 0
  84+ 4D37 AF               XOR A
  85+ 4D38 CD 35 69         CALL GET_PAGE_INFO
  86+ 4D3B C5               PUSH BC
  87+ 4D3C D5               PUSH DE
  88+ 4D3D 3A 41 F3         LD A, (RAMAD0)
  89+ 4D40 26 00            LD H, 0
  90+ 4D42 CD 7C 69         CALL LOCAL_ENASLT
  91+ 4D45
  92+ 4D45               IF (SPRITE_CMDS == 1)
  93+ 4D45 CD 5D 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  94+ 4D48               ENDIF
  95+ 4D48
  96+ 4D48               IF (SOUND_CMDS == 1)
  97+ 4D48 3A 8B 5B     	LD A, (SOUND_ENABLED)
  98+ 4D4B B7           	OR A
  99+ 4D4C C4 36 42     	CALL NZ,PLY_AKG_PLAY
 100+ 4D4F               ENDIF
 101+ 4D4F
 102+ 4D4F              	; restore page 0
 103+ 4D4F D1               POP DE
 104+ 4D50 C1               POP BC
 105+ 4D51 CD 6C 69         CALL RESTORE_PAGE_INFO
 106+ 4D54              	; restore page 2
 107+ 4D54 D1               POP DE
 108+ 4D55 C1               POP BC
 109+ 4D56 CD 6C 69         CALL RESTORE_PAGE_INFO
 110+ 4D59
 111+ 4D59 F1           	POP AF
 112+ 4D5A               ENDIF
 113+ 4D5A C3 F3 4C     	JP ORIG.HTIMI
 114+ 4D5D              ; *******************************************************************************************************
 115+ 4D5D
 116+ 4D5D              ; *******************************************************************************************************
 117+ 4D5D              ; function checks if the sprite system is initialized and what screen mode we are running
 118+ 4D5D              ; also checks if some VRAM modifying command is running
 119+ 4D5D              ; when that checks out calls sprite updates and animation processing
 120+ 4D5D              ; if in an unsupported mode disables sprite handling
 121+ 4D5D              PROCESS_SPRITES_AND_ANIMATIONS:
 122+ 4D5D              	; check if initialized
 123+ 4D5D 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
 124+ 4D60 B7           	OR A
 125+ 4D61 C8           	RET Z
 126+ 4D62              	; check screen mode
 127+ 4D62 3A AF FC     	LD A, (SCRMOD)
 128+ 4D65 3D           	DEC A
 129+ 4D66 28 08        	JR Z, .L0 ; screen 1
 130+ 4D68 3D           	DEC A
 131+ 4D69 28 05            JR Z, .L0 ; screen 2
 132+ 4D6B              	; unsupported screen mode, disable
 133+ 4D6B AF               XOR A
 134+ 4D6C 32 7F 4D         LD (SPRATR_INIT_STATUS),A
 135+ 4D6F C9               RET
 136+ 4D70              .L0:
 137+ 4D70                  ; check if anyone else is working with VRAM
 138+ 4D70 3A 45 67         LD A,(VRAM_UPDATE_IN_PROGRESS)
 139+ 4D73 B7               OR A
 140+ 4D74 C0               RET NZ
 141+ 4D75
 142+ 4D75 CD 95 4D         CALL SPRATR_UPDATE
 143+ 4D78
 144+ 4D78               IF (ANIM_CMDS == 1)
 145+ 4D78 CD B6 57         CALL PROCESS_ANIMATIONS
 146+ 4D7B CD BA 59         CALL PROCESS_AUTOSGAMS
 147+ 4D7E               ENDIF
 148+ 4D7E C9               RET
 149+ 4D7F              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
 125  4D7F
 126  4D7F               IF (SPRITE_CMDS == 1)
 127  4D7F               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4D7F              ; commands and variables related to sprites
   2+ 4D7F
   3+ 4D7F              SPRATR_INIT_STATUS:
   4+ 4D7F 00            DB 0
   5+ 4D80              SPRATR_UPDATE_FLAG:
   6+ 4D80 00 00         DW 0
   7+ 4D82              SPRATR_DATA:
   8+ 4D82 00 00         DW 0
   9+ 4D84              SPRFLICKER_ENABLED:
  10+ 4D84 00            DB 0
  11+ 4D85              ; to support sprite flicker
  12+ 4D85              FLICKER:
  13+ 4D85 00            DB 0
  14+ 4D86              NUM_SPRITES_HANDLED:
  15+ 4D86 20            DB 32
  16+ 4D87
  17+ 4D87              ; to temporarily store stack pointer
  18+ 4D87              TMPSP:
  19+ 4D87 00 00         DW 0
  20+ 4D89
  21+ 4D89              ; *******************************************************************************************************
  22+ 4D89              ; helper function gets pointer to n-th entry in sprite attributes
  23+ 4D89              ; changes HL,DE
  24+ 4D89              GETnthSPRATTR:
  25+ 4D89 26 00            LD H,0
  26+ 4D8B 6F               LD L,A
  27+ 4D8C CD 31 69         CALL HLx8
  28+ 4D8F ED 5B 82 4D      LD DE,(SPRATR_DATA)
  29+ 4D93 19               ADD HL,DE
  30+ 4D94 C9               RET
  31+ 4D95              ; *******************************************************************************************************
  32+ 4D95
  33+ 4D95              ; *******************************************************************************************************
  34+ 4D95              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  35+ 4D95              ; struct {
  36+ 4D95              ; DW y
  37+ 4D95              ; DW x
  38+ 4D95              ; DW pattern (0-63)
  39+ 4D95              ; DW color
  40+ 4D95              ; } [32]
  41+ 4D95              ; will hide sprites whose location is outside of visible area
  42+ 4D95              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  43+ 4D95              ; modifies AF, AF', BC, DE, HL, IX
  44+ 4D95              SPRATR_UPDATE:
  45+ 4D95              	; check if update requested
  46+ 4D95 2A 80 4D     	LD HL, (SPRATR_UPDATE_FLAG)
  47+ 4D98 7E           	LD A, (HL)
  48+ 4D99 B7           	OR A
  49+ 4D9A C8           	RET Z
  50+ 4D9B
  51+ 4D9B DD 21 86 4D  	LD IX,NUM_SPRITES_HANDLED
  52+ 4D9F DD 46 00     	LD B, (IX) ; sprite number
  53+ 4DA2 0E 98        	LD C, #98 ; register for vdp data output
  54+ 4DA4              	; set VDP address
  55+ 4DA4 3A AF FC         LD A,(SCRMOD)
  56+ 4DA7 3D               DEC A
  57+ 4DA8 20 05            JR NZ,.L4
  58+ 4DAA 2A C3 F3         LD HL, (T32ATR)
  59+ 4DAD 18 03            JR .L5
  60+ 4DAF              .L4:
  61+ 4DAF 2A CD F3         LD HL, (GRPATR)
  62+ 4DB2              .L5:
  63+ 4DB2 3A 84 4D     	LD A, (SPRFLICKER_ENABLED)
  64+ 4DB5 B7           	OR A
  65+ 4DB6 28 03        	JR Z, .L3
  66+ 4DB8 3A 85 4D     	LD A, (FLICKER)
  67+ 4DBB              .L3:
  68+ 4DBB 5F           	LD E, A
  69+ 4DBC 08           	EX AF, AF'
  70+ 4DBD 7B           	LD A, E
  71+ 4DBE 87           	ADD A, A
  72+ 4DBF 87           	ADD A, A
  73+ 4DC0 16 00        	LD D, 0
  74+ 4DC2 5F           	LD E, A
  75+ 4DC3 19           	ADD HL, DE
  76+ 4DC4 CD 1C 69     	CALL SETWRT_LOCAL
  77+ 4DC7 ED 73 87 4D  	LD (TMPSP), SP
  78+ 4DCB ED 7B 82 4D  	LD SP, (SPRATR_DATA)
  79+ 4DCF
  80+ 4DCF              .LOOP:
  81+ 4DCF E1           	POP HL
  82+ 4DD0 24           	INC H
  83+ 4DD1 28 0D        	JR Z, .L1 ; negative number between -256 and -1
  84+ 4DD3 25           	DEC H
  85+ 4DD4 20 15        	JR NZ, .OUT3 ; sprite vertically can't be visible
  86+ 4DD6 7D           	LD A, L
  87+ 4DD7 FE C0        	CP 192
  88+ 4DD9 30 10        	JR NC, .OUT3
  89+ 4DDB 3D           	DEC A ; due to VDP rule that top of screen is -1
  90+ 4DDC 57           	LD D, A
  91+ 4DDD C3 04 4E     	JP .X
  92+ 4DE0              .L1:
  93+ 4DE0 7D           	LD A, L
  94+ 4DE1 C6 10        	ADD 16
  95+ 4DE3 FA EB 4D     	JP M, .OUT3 ; below -16
  96+ 4DE6 2D           	DEC L ; due to VDP rule that top of screen is -1
  97+ 4DE7 55           	LD D, L
  98+ 4DE8 C3 04 4E     	JP .X
  99+ 4DEB              .OUT3:
 100+ 4DEB E1           	POP HL ; skip x value
 101+ 4DEC              .OUT2:
 102+ 4DEC E1           	POP HL ; skip pattern
 103+ 4DED E1           	POP HL ; skip color
 104+ 4DEE 3E D1        	LD A, #D1
 105+ 4DF0 ED 79        	OUT (C), A ; sprite hidden
 106+ 4DF2 00          > NOP
 106+ 4DF3 00          > NOP
 106+ 4DF4 00          > NOP
 107+ 4DF5 ED 79        	OUT (C), A ; value unimportant
 108+ 4DF7 00          > NOP
 108+ 4DF8 00          > NOP
 108+ 4DF9 00          > NOP
 109+ 4DFA ED 79        	OUT (C), A ; value unimportant
 110+ 4DFC 00          > NOP
 110+ 4DFD 00          > NOP
 110+ 4DFE 00          > NOP
 111+ 4DFF ED 79        	OUT (C), A ; value unimportant
 112+ 4E01 C3 2F 4E     	JP .NEXT
 113+ 4E04              .X:
 114+ 4E04 E1           	POP HL
 115+ 4E05 24           	INC H
 116+ 4E06 28 08        	JR Z, .L2
 117+ 4E08 25           	DEC H
 118+ 4E09 20 E1        	JR NZ, .OUT2
 119+ 4E0B 1E 00        	LD E, 0 ; EC bit
 120+ 4E0D C3 19 4E     	JP .XY
 121+ 4E10              .L2:
 122+ 4E10 7D           	LD A, L
 123+ 4E11 C6 20        	ADD 32
 124+ 4E13 FA EC 4D     	JP M, .OUT2
 125+ 4E16 6F           	LD L, A
 126+ 4E17 1E 80        	LD E, #80
 127+ 4E19              .XY:
 128+ 4E19 ED 51        	OUT (C), D
 129+ 4E1B 3A E0 F3     	LD A, (REG1SAV)
 130+ 4E1E E6 02        	AND 2
 131+ 4E20 ED 69        	OUT (C), L
 132+ 4E22 E1           	POP HL ; pattern
 133+ 4E23 7D           	LD A, L
 134+ 4E24 28 02        	JR Z, .SMALLSPRITES
 135+ 4E26 87           	ADD A, A
 136+ 4E27 87           	ADD A, A ; needs to go at 4x
 137+ 4E28              .SMALLSPRITES:
 138+ 4E28 D3 98        	OUT (#98), A
 139+ 4E2A E1           	POP HL ; color
 140+ 4E2B 7D           	LD A, L
 141+ 4E2C B3           	OR E
 142+ 4E2D D3 98        	OUT (#98), A
 143+ 4E2F              .NEXT:
 144+ 4E2F 08           	EX AF, AF'
 145+ 4E30 3C           	INC A ; increase current sprite
 146+ 4E31 DD BE 00     	CP (IX) ; compare to maximum handled
 147+ 4E34 C2 54 4E     	JP NZ, .NEXT2 ; continue if not over
 148+ 4E37 AF           	XOR A ; back to zero
 149+ 4E38 08           	EX AF, AF'
 150+ 4E39 3A AF FC         LD A,(SCRMOD)
 151+ 4E3C 3D               DEC A
 152+ 4E3D 20 05            JR NZ,.L6
 153+ 4E3F 2A C3 F3         LD HL, (T32ATR)
 154+ 4E42 18 03            JR .L7
 155+ 4E44              .L6:
 156+ 4E44 2A CD F3         LD HL, (GRPATR)
 157+ 4E47              .L7:
 158+ 4E47              	; CALL SETWRT_LOCAL not allowed as SP modified
 159+ 4E47 7D           	LD	A, L
 160+ 4E48 D3 99        	OUT	(099H), A
 161+ 4E4A 7C           	LD	A, H
 162+ 4E4B E6 3F        	AND	03FH
 163+ 4E4D F6 40        	OR	040H
 164+ 4E4F D3 99        	OUT	(099H), A
 165+ 4E51 C3 55 4E     	JP .NEXT3
 166+ 4E54              .NEXT2:
 167+ 4E54 08           	EX AF, AF'
 168+ 4E55              .NEXT3:
 169+ 4E55 05           	DEC B
 170+ 4E56 C2 CF 4D     	JP NZ, .LOOP
 171+ 4E59 08           	EX AF, AF'
 172+ 4E5A 3C           	INC A ; increase flicker to start at the next one on next vblank
 173+ 4E5B DD BE 00     	CP (IX)
 174+ 4E5E 20 01        	JR NZ,.L8
 175+ 4E60 AF           	XOR A
 176+ 4E61              .L8:
 177+ 4E61 32 85 4D     	LD (FLICKER), A
 178+ 4E64
 179+ 4E64 ED 7B 87 4D  	LD SP, (TMPSP)
 180+ 4E68 2A 80 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 181+ 4E6B 36 00        	LD (HL), 0 ; zero out update flag
 182+ 4E6D C9           	RET
 183+ 4E6E              ; *******************************************************************************************************
 184+ 4E6E
 185+ 4E6E               IF (BASIC_EXTENSION == 1)
 186+ 4E6E              ; *******************************************************************************************************
 187+ 4E6E              ; function to handle CALL SPRENABLE basic extension
 188+ 4E6E              ; initializes sprites handler
 189+ 4E6E              ; _SPRENABLE ( INT[3][31] variable sprites_attributes,
 190+ 4E6E              ;			   INT variable update_variable,
 191+ 4E6E              ;			   BYTE sprite_flicker_enabled,
 192+ 4E6E              ;			   BYTE num_sprites_handled )
 193+ 4E6E              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA, SPRFLICKER_ENABLED and NUM_SPRITES_HANDLED
 194+ 4E6E              SPRENABLE:
 195+ 4E6E              	; opening (
 196+ 4E6E CD 43 6A     	CALL CHKCHAR
 197+ 4E71 28           	DB '('
 198+ 4E72              	; get address of sprite attribute table DIM SA%(3,31)
 199+ 4E72 3E 02        	LD A,2
 200+ 4E74 06 02        	LD B,2
 201+ 4E76 11 20 04     	LD DE,#0420
 202+ 4E79 CD 70 6A     	CALL GET_BASIC_ARRAY_DATA_POINTER
 203+ 4E7C ED 43 82 4D  	LD (SPRATR_DATA), BC
 204+ 4E80              	; comma
 205+ 4E80 CD 43 6A     	CALL CHKCHAR
 206+ 4E83 2C           	DB ','
 207+ 4E84              	; get address of sprite update flag
 208+ 4E84 DD 21 A4 5E  	LD IX, PTRGET
 209+ 4E88 CD 59 01     	CALL CALBAS
 210+ 4E8B ED 53 80 4D  	LD (SPRATR_UPDATE_FLAG), DE
 211+ 4E8F              	; comma
 212+ 4E8F CD 43 6A     	CALL CHKCHAR
 213+ 4E92 2C           	DB ','
 214+ 4E93              	; get flicker enabled flag
 215+ 4E93 DD 21 1C 52  	LD IX, GETBYT
 216+ 4E97 CD 59 01     	CALL CALBAS
 217+ 4E9A 32 84 4D     	LD (SPRFLICKER_ENABLED), A
 218+ 4E9D              	; comma
 219+ 4E9D CD 43 6A     	CALL CHKCHAR
 220+ 4EA0 2C           	DB ','
 221+ 4EA1              	; get number of handled sprites
 222+ 4EA1 DD 21 1C 52  	LD IX, GETBYT
 223+ 4EA5 CD 59 01     	CALL CALBAS
 224+ 4EA8 32 86 4D     	LD (NUM_SPRITES_HANDLED),A
 225+ 4EAB              	; ending )
 226+ 4EAB CD 43 6A     	CALL CHKCHAR
 227+ 4EAE 29           	DB ')'
 228+ 4EAF              .L0:
 229+ 4EAF 3E 01        	LD A, 1
 230+ 4EB1 32 7F 4D     	LD (SPRATR_INIT_STATUS), A
 231+ 4EB4 C9           	RET
 232+ 4EB5              ; *******************************************************************************************************
 233+ 4EB5               ENDIF
 234+ 4EB5
 235+ 4EB5               IF (DEFUSR_EXTENSION == 1)
 236+ 4EB5              ; same as SPRENABLE but for DEFUSR approach
 237+ 4EB5              ; input IX=pointer to input array, real data from +2
 238+ 4EB5              ; +2 = pointer to sprite attributes array data
 239+ 4EB5              ; +4 = pointer to sprite update variable
 240+ 4EB5              ; +6 = flicker flag
 241+ 4EB5              ; +8 = number of sprites to handle
 242+ 4EB5              SPRENABLE_DEFUSR:
 243+ 4EB5 DD 6E 02     	LD L,(IX+2)
 244+ 4EB8 DD 66 03     	LD H,(IX+3)
 245+ 4EBB 22 82 4D     	LD (SPRATR_DATA),HL
 246+ 4EBE DD 6E 04     	LD L,(IX+4)
 247+ 4EC1 DD 66 05     	LD H,(IX+5)
 248+ 4EC4 22 80 4D     	LD (SPRATR_UPDATE_FLAG),HL
 249+ 4EC7 DD 7E 06     	LD A,(IX+6)
 250+ 4ECA 32 84 4D     	LD (SPRFLICKER_ENABLED),A
 251+ 4ECD DD 7E 08     	LD A,(IX+8)
 252+ 4ED0 32 86 4D     	LD (NUM_SPRITES_HANDLED),A
 253+ 4ED3               IF (BASIC_EXTENSION == 1)
 254+ 4ED3 18 DA        	JR SPRENABLE.L0
 255+ 4ED5               ELSE
 256+ 4ED5 ~            	LD A, 1
 257+ 4ED5 ~            	LD (SPRATR_INIT_STATUS), A
 258+ 4ED5 ~            	RET
 259+ 4ED5               ENDIF
 260+ 4ED5               ENDIF
 261+ 4ED5
 262+ 4ED5               IF (DEFUSR_EXTENSION + BASIC_EXTENSION > 0)
 263+ 4ED5              ; *******************************************************************************************************
 264+ 4ED5              ; function to handle CALL SPRDISABLE basic extension
 265+ 4ED5              ; disables sprites handling
 266+ 4ED5              ; _SPRDISABLE
 267+ 4ED5              ; resets variable SPRATR_INIT_STATUS
 268+ 4ED5              SPRDISABLE:
 269+ 4ED5              SPRDISABLE_DEFUSR:
 270+ 4ED5 AF           	XOR A
 271+ 4ED6 32 7F 4D     	LD (SPRATR_INIT_STATUS), A
 272+ 4ED9 C9           	RET
 273+ 4EDA              ; *******************************************************************************************************
 274+ 4EDA               ENDIF
 275+ 4EDA
 276+ 4EDA              ; *******************************************************************************************************
 277+ 4EDA              ; function to handle CALL SPRSET basic extension
 278+ 4EDA              ; sets position, and optionally pattern and color of sprite
 279+ 4EDA              ; _SPRSET ( BYTE sprite_num , valid 0-31
 280+ 4EDA              ;			INT x,
 281+ 4EDA              ;			INT y,
 282+ 4EDA              ;			INT pattern, valid 0-63, otherwise ignored
 283+ 4EDA              ;			INT color, valid 0-15, otherwise ignored
 284+ 4EDA              ;SPRSET:
 285+ 4EDA              ;	LD A, (SPRATR_INIT_STATUS)
 286+ 4EDA              ;	OR A
 287+ 4EDA              ;	JR NZ, .L1
 288+ 4EDA              ;	LD E, 5 ; illegal function call
 289+ 4EDA              ;	JP THROW_ERROR
 290+ 4EDA              ;.L1:
 291+ 4EDA              ;	; opening (
 292+ 4EDA              ;	CALL CHKCHAR
 293+ 4EDA              ;	DB '('
 294+ 4EDA              ;	; get sprite number
 295+ 4EDA              ;	LD IX, GETBYT
 296+ 4EDA              ;	CALL CALBAS
 297+ 4EDA              ;	PUSH AF
 298+ 4EDA              ;	; comma
 299+ 4EDA              ;	CALL CHKCHAR
 300+ 4EDA              ;	DB ','
 301+ 4EDA              ;	; get x
 302+ 4EDA              ;	LD IX, FRMQNT
 303+ 4EDA              ;	CALL CALBAS
 304+ 4EDA              ;	PUSH DE
 305+ 4EDA              ;	; comma
 306+ 4EDA              ;	CALL CHKCHAR
 307+ 4EDA              ;	DB ','
 308+ 4EDA              ;	; get y
 309+ 4EDA              ;	LD IX, FRMQNT
 310+ 4EDA              ;	CALL CALBAS
 311+ 4EDA              ;	PUSH DE
 312+ 4EDA              ;	; comma
 313+ 4EDA              ;	CALL CHKCHAR
 314+ 4EDA              ;	DB ','
 315+ 4EDA              ;	; get pattern
 316+ 4EDA              ;	LD IX, FRMQNT
 317+ 4EDA              ;	CALL CALBAS
 318+ 4EDA              ;	PUSH DE
 319+ 4EDA              ;	; comma
 320+ 4EDA              ;	CALL CHKCHAR
 321+ 4EDA              ;	DB ','
 322+ 4EDA              ;	; get color
 323+ 4EDA              ;	LD IX, FRMQNT
 324+ 4EDA              ;	CALL CALBAS
 325+ 4EDA              ;	PUSH DE
 326+ 4EDA              ;	; ending )
 327+ 4EDA              ;	CALL CHKCHAR
 328+ 4EDA              ;	DB ')'
 329+ 4EDA              ;
 330+ 4EDA              ;   ; save position in BASIC text
 331+ 4EDA              ;	PUSH HL
 332+ 4EDA              ;	POP IX
 333+ 4EDA              ;
 334+ 4EDA              ;	POP BC ; color
 335+ 4EDA              ;	POP DE ; pattern
 336+ 4EDA              ;	EXX
 337+ 4EDA              ;	POP BC ; y
 338+ 4EDA              ;	POP DE ; x
 339+ 4EDA              ;	POP AF ; sprite number
 340+ 4EDA              ;	CP 32
 341+ 4EDA              ;	JR C, .L2
 342+ 4EDA              ;	LD E, 5 ; illegal function call
 343+ 4EDA              ;	JP THROW_ERROR
 344+ 4EDA              ;.L2:
 345+ 4EDA              ;	; find location in sprite attributes table
 346+ 4EDA              ;	PUSH DE
 347+ 4EDA              ;	CALL GETnthSPRATTR
 348+ 4EDA              ;	POP DE
 349+ 4EDA              ;	DI
 350+ 4EDA              ;	; set y
 351+ 4EDA              ;	LD (HL), C
 352+ 4EDA              ;	INC HL
 353+ 4EDA              ;	LD (HL), B
 354+ 4EDA              ;	INC HL
 355+ 4EDA              ;	; set x
 356+ 4EDA              ;	LD (HL), E
 357+ 4EDA              ;	INC HL
 358+ 4EDA              ;	LD (HL), D
 359+ 4EDA              ;	INC HL
 360+ 4EDA              ;	PUSH HL
 361+ 4EDA              ;	EXX
 362+ 4EDA              ;	POP HL
 363+ 4EDA              ;	; check if 0<=pattern<64
 364+ 4EDA              ;	LD A, D
 365+ 4EDA              ;	OR A
 366+ 4EDA              ;	JR NZ, .L3
 367+ 4EDA              ;	LD A, E
 368+ 4EDA              ;	CP 64
 369+ 4EDA              ;	JR NC, .L3
 370+ 4EDA              ;	; set pattern
 371+ 4EDA              ;	;ADD A, A
 372+ 4EDA              ;	;ADD A, A
 373+ 4EDA              ;	;ADD A, A
 374+ 4EDA              ;	LD (HL), A
 375+ 4EDA              ;	INC HL
 376+ 4EDA              ;	LD (HL), D
 377+ 4EDA              ;	INC HL
 378+ 4EDA              ;	JR .L4
 379+ 4EDA              ;.L3:
 380+ 4EDA              ;	; skip pattern
 381+ 4EDA              ;	.2 INC HL
 382+ 4EDA              ;.L4:
 383+ 4EDA              ;	; check if 0<=color<16
 384+ 4EDA              ;	LD A, B
 385+ 4EDA              ;	OR A
 386+ 4EDA              ;	JR NZ, .L5
 387+ 4EDA              ;	LD A, C
 388+ 4EDA              ;	CP 16
 389+ 4EDA              ;	JR NC, .L5
 390+ 4EDA              ;	; set color
 391+ 4EDA              ;	LD (HL), C
 392+ 4EDA              ;	INC HL
 393+ 4EDA              ;	LD (HL), B
 394+ 4EDA              ;
 395+ 4EDA              ;.L5:
 396+ 4EDA              ;	EI
 397+ 4EDA              ;	PUSH IX
 398+ 4EDA              ;	POP HL
 399+ 4EDA              ;	RET
 400+ 4EDA              ; *******************************************************************************************************
 401+ 4EDA
 402+ 4EDA              ; *******************************************************************************************************
 403+ 4EDA              ; function sets sprite location based on initial coordinates and offset provided
 404+ 4EDA              ; input A=sprite number in SPRATR_DATA , 0-31
 405+ 4EDA              ; input DE=initial x
 406+ 4EDA              ; input BC=initial y
 407+ 4EDA              ; input IY=location where delta y,x are located
 408+ 4EDA              ; modifies AF, HL, IX
 409+ 4EDA              SPRSET_DELTA_POS:
 410+ 4EDA D5           	PUSH DE
 411+ 4EDB CD 89 4D     	CALL GETnthSPRATTR
 412+ 4EDE E5           	PUSH HL
 413+ 4EDF DD E1        	POP IX
 414+ 4EE1 D1           	POP DE
 415+ 4EE2              	; IX=sprite's y location
 416+ 4EE2 FD 6E 00     	LD L, (IY)
 417+ 4EE5 FD 66 01     	LD H, (IY+1)
 418+ 4EE8 09           	ADD HL, BC
 419+ 4EE9 DD 75 00     	LD (IX), L
 420+ 4EEC DD 74 01     	LD (IX+1), H
 421+ 4EEF FD 6E 02     	LD L, (IY+2)
 422+ 4EF2 FD 66 03     	LD H, (IY+3)
 423+ 4EF5 19           	ADD HL, DE
 424+ 4EF6 DD 75 02     	LD (IX+2), L
 425+ 4EF9 DD 74 03     	LD (IX+3), H
 426+ 4EFC C9           	RET
 427+ 4EFD              ; *******************************************************************************************************
 428+ 4EFD
 429+ 4EFD              ; *******************************************************************************************************
 430+ 4EFD              ; helper function to set new locations for a set of sprites
 431+ 4EFD              ; input B=number of sprites
 432+ 4EFD              ; HL=pointer to list of sprites and offsets
 433+ 4EFD              SPR_UPDATE_LOC:
 434+ 4EFD 3E 01        	LD A,1
 435+ 4EFF 32 45 67     	LD (VRAM_UPDATE_IN_PROGRESS),A
 436+ 4F02 7E           	LD A, (HL)
 437+ 4F03 23           	INC HL
 438+ 4F04 23           	INC HL
 439+ 4F05 E5           	PUSH HL
 440+ 4F06 FD E1        	POP IY
 441+ 4F08 D9           	EXX
 442+ 4F09 CD DA 4E     	CALL SPRSET_DELTA_POS
 443+ 4F0C D9           	EXX
 444+ 4F0D 23          > INC HL
 444+ 4F0E 23          > INC HL
 444+ 4F0F 23          > INC HL
 444+ 4F10 23          > INC HL
 445+ 4F11 10 EA        	DJNZ SPR_UPDATE_LOC
 446+ 4F13 AF           	XOR A
 447+ 4F14 32 45 67     	LD (VRAM_UPDATE_IN_PROGRESS),A
 448+ 4F17 C9           	RET
 449+ 4F18              ; *******************************************************************************************************
 450+ 4F18
 451+ 4F18               IF (BASIC_EXTENSION == 1)
 452+ 4F18              ; *******************************************************************************************************
 453+ 4F18              ; function to handle CALL SPRGRPMOV basic extension
 454+ 4F18              ; sets position of a group of sprites described with
 455+ 4F18              ; { int sprite_num, int delta_y, int delta_x } [count]
 456+ 4F18              ; _SPRGRPMOV ( INT x,
 457+ 4F18              ;			   INT y,
 458+ 4F18              ;			   BYTE count,
 459+ 4F18              ;			   INT[2][count] data_ptr
 460+ 4F18              SPRGRPMOV:
 461+ 4F18 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
 462+ 4F1B B7           	OR A
 463+ 4F1C CA 63 6A     	JP Z,ILLEGAL_FUNCTION
 464+ 4F1F              	; opening (
 465+ 4F1F CD 43 6A     	CALL CHKCHAR
 466+ 4F22 28           	DB '('
 467+ 4F23              	; get x
 468+ 4F23 DD 21 2F 54  	LD IX, FRMQNT
 469+ 4F27 CD 59 01     	CALL CALBAS
 470+ 4F2A ED 53 34 67  	LD (BLIT_STRUCT),DE
 471+ 4F2E              	; comma
 472+ 4F2E CD 43 6A     	CALL CHKCHAR
 473+ 4F31 2C           	DB ','
 474+ 4F32              	; get y
 475+ 4F32 DD 21 2F 54  	LD IX, FRMQNT
 476+ 4F36 CD 59 01     	CALL CALBAS
 477+ 4F39 ED 53 36 67  	LD (BLIT_STRUCT+2),DE
 478+ 4F3D              	; comma
 479+ 4F3D CD 43 6A     	CALL CHKCHAR
 480+ 4F40 2C           	DB ','
 481+ 4F41              	; get count
 482+ 4F41 DD 21 1C 52  	LD IX, GETBYT
 483+ 4F45 CD 59 01     	CALL CALBAS
 484+ 4F48 32 38 67     	LD (BLIT_STRUCT+4),A
 485+ 4F4B              	; comma
 486+ 4F4B CD 43 6A     	CALL CHKCHAR
 487+ 4F4E 2C           	DB ','
 488+ 4F4F              	; get sprite group definition array data pointer
 489+ 4F4F 3A 38 67     	LD A,(BLIT_STRUCT+4)
 490+ 4F52 5F           	LD E,A
 491+ 4F53 16 03        	LD D,3
 492+ 4F55 3E 02        	LD A,2
 493+ 4F57 47           	LD B,A
 494+ 4F58 CD 70 6A     	CALL GET_BASIC_ARRAY_DATA_POINTER
 495+ 4F5B ED 43 39 67  	LD (BLIT_STRUCT+5),BC
 496+ 4F5F              	; ending )
 497+ 4F5F CD 43 6A     	CALL CHKCHAR
 498+ 4F62 29           	DB ')'
 499+ 4F63
 500+ 4F63 E5           	PUSH HL
 501+ 4F64
 502+ 4F64 D9               EXX
 503+ 4F65 ED 5B 34 67      LD DE,(BLIT_STRUCT) ; initial x
 504+ 4F69 ED 4B 36 67      LD BC,(BLIT_STRUCT+2) ; initial y
 505+ 4F6D D9               EXX
 506+ 4F6E 2A 39 67         LD HL,(BLIT_STRUCT+5) ; pointer to data
 507+ 4F71 3A 38 67         LD A,(BLIT_STRUCT+4) ; number of entries
 508+ 4F74 47               LD B,A
 509+ 4F75 CD FD 4E     	CALL SPR_UPDATE_LOC
 510+ 4F78
 511+ 4F78 E1           	POP HL
 512+ 4F79 C9           	RET
 513+ 4F7A              ; *******************************************************************************************************
 514+ 4F7A               ENDIF
 515+ 4F7A
 516+ 4F7A               IF (DEFUSR_EXTENSION == 1)
 517+ 4F7A              ; *******************************************************************************************************
 518+ 4F7A              ; same as SPRGRPMOV but for DEFUSR approach
 519+ 4F7A              ; input IX=pointer to input array, real data from +2
 520+ 4F7A              ; +2 = X
 521+ 4F7A              ; +4 = Y
 522+ 4F7A              ; +6 = count
 523+ 4F7A              ; +8 = data pointer
 524+ 4F7A              SPRGRPMOV_DEFUSR:
 525+ 4F7A D9               EXX
 526+ 4F7B DD 5E 02     	LD E,(IX+2)
 527+ 4F7E DD 56 03     	LD D,(IX+3) ; initial x
 528+ 4F81 DD 4E 04     	LD C,(IX+4)
 529+ 4F84 DD 46 05     	LD B,(IX+5) ; initial y
 530+ 4F87 D9               EXX
 531+ 4F88 DD 6E 08     	LD L,(IX+8)
 532+ 4F8B DD 66 09     	LD H,(IX+9) ; pointer to data
 533+ 4F8E DD 46 06         LD B,(IX+6) ; count
 534+ 4F91 C3 FD 4E         JP SPR_UPDATE_LOC
 535+ 4F94              ; *******************************************************************************************************
 536+ 4F94               ENDIF
# file closed: asm\SPRITES.asm
 128  4F94               ENDIF
 129  4F94
 130  4F94               IF (ANIM_CMDS == 1)
 131  4F94               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4F94              ; sprite animation routines
   2+ 4F94
   3+ 4F94              ; number of animation items and pointer
   4+ 4F94              ANIMITEMNUM:
   5+ 4F94 00            DB 0
   6+ 4F95              ANIMITEMPTR:
   7+ 4F95 E6 6A         DW EXT_END
   8+ 4F97              ; number of animation definitions and pointer
   9+ 4F97              ANIMDEFNUM:
  10+ 4F97 00            DB 0
  11+ 4F98              ANIMDEFPTR:
  12+ 4F98 E6 6A         DW EXT_END
  13+ 4F9A              ; number of links between sprite and animation definitions
  14+ 4F9A              ANIMSPRNUM:
  15+ 4F9A 00            DB 0
  16+ 4F9B              ANIMSPRPTR:
  17+ 4F9B E6 6A         DW EXT_END
  18+ 4F9D              ; number of automatic sprite group move and animate structures
  19+ 4F9D              AUTOSGAMNUM:
  20+ 4F9D 00            DB 0
  21+ 4F9E              AUTOSGAMPTR:
  22+ 4F9E E6 6A         DW EXT_END
  23+ 4FA0
  24+ 4FA0              ; ANIMATION ITEM
  25+ 4FA0              ; byte type = [0 - pattern and color change
  26+ 4FA0              ;              1 - pattern definition change ]
  27+ 4FA0              ; word ticks - number of ticks to hold this state
  28+ 4FA0              ; for type = 0
  29+ 4FA0              ;   byte pattern;
  30+ 4FA0              ;   byte color;
  31+ 4FA0              ; for type = 1
  32+ 4FA0              ;   work data_pointer;
  33+ 4FA0              ; total size = 5b
  34+ 4FA0
  35+ 4FA0              ; ANIMATION DEFINITION
  36+ 4FA0              ; byte number of items 1-15
  37+ 4FA0              ; byte[15] anim_item;
  38+ 4FA0              ; total size = 16b
  39+ 4FA0
  40+ 4FA0              ; SPRITE/CHAR ANIMATION
  41+ 4FA0              ; +00 byte sprite/char number;
  42+ 4FA0              ; +01 word time;
  43+ 4FA0              ; +03 byte current item;
  44+ 4FA0              ; +04 byte animation definition;
  45+ 4FA0              ; +05 byte cyclic;
  46+ 4FA0              ; +06 byte active;
  47+ 4FA0              ; +07 byte 0=sprite, 1-3 character bank
  48+ 4FA0              ; total size = 8b
  49+ 4FA0
  50+ 4FA0              ; AUTOMATIC SPRITE GROUP MOVE AND ANIMATE structure
  51+ 4FA0              ; +00 pointer to X variable
  52+ 4FA0              ; +02 pointer to Y variable
  53+ 4FA0              ; +04 minimum value
  54+ 4FA0              ; +06 maximal value
  55+ 4FA0              ; +08 delta value
  56+ 4FA0              ; +10 direction 0=horizontal, <>0 = vertical
  57+ 4FA0              ; +11 sprite group size
  58+ 4FA0              ; +12 sprite group pointer
  59+ 4FA0              ; +14 animation list size
  60+ 4FA0              ; +15 animation list pointer for negative delta values
  61+ 4FA0              ; +17 animation list pointer for positive delta values
  62+ 4FA0              ; +19 active flag
  63+ 4FA0              ; +20 ticks for movement
  64+ 4FA0              ; +22 timer
  65+ 4FA0              ; total = 24b
  66+ 4FA0
  67+ 4FA0              ; *******************************************************************************************************
  68+ 4FA0              ; helper function HL=A*5
  69+ 4FA0              ; changes HL,DE
  70+ 4FA0              Ax5:
  71+ 4FA0 26 00            LD H,0
  72+ 4FA2 6F               LD L,A
  73+ 4FA3 54               LD D,H
  74+ 4FA4 5D               LD E,L
  75+ 4FA5 29               ADD HL,HL
  76+ 4FA6 29               ADD HL,HL
  77+ 4FA7 19               ADD HL,DE
  78+ 4FA8 C9               RET
  79+ 4FA9              ; *******************************************************************************************************
  80+ 4FA9
  81+ 4FA9              ; *******************************************************************************************************
  82+ 4FA9              ; helper function gets pointer to n-th animation item
  83+ 4FA9              ; changes HL,DE
  84+ 4FA9              GETnthANIMITEM:
  85+ 4FA9 CD A0 4F         CALL Ax5
  86+ 4FAC ED 5B 95 4F      LD DE,(ANIMITEMPTR)
  87+ 4FB0 19               ADD HL,DE
  88+ 4FB1 C9               RET
  89+ 4FB2              ; *******************************************************************************************************
  90+ 4FB2
  91+ 4FB2              ; *******************************************************************************************************
  92+ 4FB2              ; helper function gets pointer to n-th entry in animation definition
  93+ 4FB2              ; changes HL,DE
  94+ 4FB2              GETnthANIMDEF:
  95+ 4FB2 26 00            LD H,0
  96+ 4FB4 6F               LD L,A
  97+ 4FB5 CD 30 69         CALL HLx16
  98+ 4FB8 ED 5B 98 4F      LD DE,(ANIMDEFPTR)
  99+ 4FBC 19               ADD HL,DE
 100+ 4FBD C9               RET
 101+ 4FBE              ; *******************************************************************************************************
 102+ 4FBE
 103+ 4FBE              ; *******************************************************************************************************
 104+ 4FBE              ; helper function gets pointer to n-th entry in sprite animation
 105+ 4FBE              ; changes HL,DE
 106+ 4FBE              GETnthSPRANIM:
 107+ 4FBE 26 00            LD H,0
 108+ 4FC0 6F               LD L,A
 109+ 4FC1 CD 31 69         CALL HLx8
 110+ 4FC4 ED 5B 9B 4F      LD DE,(ANIMSPRPTR)
 111+ 4FC8 19               ADD HL,DE
 112+ 4FC9 C9               RET
 113+ 4FCA              ; *******************************************************************************************************
 114+ 4FCA
 115+ 4FCA              ; *******************************************************************************************************
 116+ 4FCA              ; helper function gets pointer to n-th entry in autosgam table
 117+ 4FCA              ; changes HL,DE
 118+ 4FCA              GETnthAUTOSGAM:
 119+ 4FCA 26 00            LD H,0
 120+ 4FCC 6F               LD L,A
 121+ 4FCD CD 31 69         CALL HLx8
 122+ 4FD0 54               LD D,H
 123+ 4FD1 5D               LD E,L
 124+ 4FD2 29               ADD HL,HL
 125+ 4FD3 19               ADD HL,DE
 126+ 4FD4 ED 5B 9E 4F      LD DE,(AUTOSGAMPTR)
 127+ 4FD8 19               ADD HL,DE
 128+ 4FD9 C9               RET
 129+ 4FDA              ; *******************************************************************************************************
 130+ 4FDA
 131+ 4FDA               IF (DEFUSR_EXTENSION == 1)
 132+ 4FDA              ; *******************************************************************************************************
 133+ 4FDA              ; same as MAXIANIMITEMS but for DEFUSR approach
 134+ 4FDA              ; input IX=pointer to input array, real data from +2
 135+ 4FDA              ; +2 = number
 136+ 4FDA              MAXANIMITEMS_DEFUSR:
 137+ 4FDA DD 7E 02         LD A,(IX+2)
 138+ 4FDD 18 11            JR MAXANIMITEMS.COMMON
 139+ 4FDF              ; *******************************************************************************************************
 140+ 4FDF               ENDIF
 141+ 4FDF
 142+ 4FDF              ; *******************************************************************************************************
 143+ 4FDF              ; function to handle CALL MAXANIMITEMS basic extension
 144+ 4FDF              ; MAXANIMITEMS (BYTE number)
 145+ 4FDF              ; sets new number and moves memory buffers as needed
 146+ 4FDF              MAXANIMITEMS:
 147+ 4FDF               IF (BASIC_EXTENSION == 1)
 148+ 4FDF              	; opening (
 149+ 4FDF CD 43 6A     	CALL CHKCHAR
 150+ 4FE2 28           	DB '('
 151+ 4FE3              	; get value
 152+ 4FE3 DD 21 1C 52  	LD IX, GETBYT
 153+ 4FE7 CD 59 01     	CALL CALBAS
 154+ 4FEA F5               PUSH AF
 155+ 4FEB              	; ending )
 156+ 4FEB CD 43 6A     	CALL CHKCHAR
 157+ 4FEE 29           	DB ')'
 158+ 4FEF F1               POP AF
 159+ 4FF0               ENDIF
 160+ 4FF0              .COMMON: ; entry for DEFUSR part, A=number
 161+ 4FF0 F3               DI
 162+ 4FF1              	; save position
 163+ 4FF1 E5           	PUSH HL
 164+ 4FF2              .ENTRY:
 165+ 4FF2 47               LD B,A
 166+ 4FF3 3A 94 4F         LD A,(ANIMITEMNUM)
 167+ 4FF6 90               SUB B
 168+ 4FF7 28 28            JR Z, .EXIT; same value as before
 169+ 4FF9 FD 21 98 4F      LD IY,ANIMDEFPTR
 170+ 4FFD FA 24 50         JP M, .INCREASE
 171+ 5000                  ; new value is lower than previous one
 172+ 5000 CD 43 50         CALL .SIZEDIFF
 173+ 5003 CD 5E 50         CALL .DECREASE_COMMON
 174+ 5006 2A 9B 4F         LD HL,(ANIMSPRPTR)
 175+ 5009 AF               XOR A
 176+ 500A ED 42            SBC HL,BC
 177+ 500C 22 9B 4F         LD (ANIMSPRPTR),HL
 178+ 500F              .E1:
 179+ 500F 2A 9E 4F         LD HL,(AUTOSGAMPTR)
 180+ 5012 AF               XOR A
 181+ 5013 ED 42            SBC HL,BC
 182+ 5015 22 9E 4F         LD (AUTOSGAMPTR),HL
 183+ 5018              .E3:
 184+ 5018 2A 10 40         LD HL,(FREEMEMPTR)
 185+ 501B AF               XOR A
 186+ 501C ED 42            SBC HL,BC
 187+ 501E 22 10 40         LD (FREEMEMPTR),HL
 188+ 5021              .EXIT:
 189+ 5021 FB               EI
 190+ 5022 E1           	POP HL
 191+ 5023 C9           	RET
 192+ 5024              .INCREASE:
 193+ 5024 ED 44            NEG
 194+ 5026 CD 43 50         CALL .SIZEDIFF
 195+ 5029 CD 8A 50         CALL .INCREASE_COMMON
 196+ 502C 2A 9B 4F         LD HL,(ANIMSPRPTR)
 197+ 502F 09               ADD HL,BC
 198+ 5030 22 9B 4F         LD (ANIMSPRPTR),HL
 199+ 5033              .E2:
 200+ 5033 2A 9E 4F         LD HL,(AUTOSGAMPTR)
 201+ 5036 09               ADD HL,BC
 202+ 5037 22 9E 4F         LD (AUTOSGAMPTR),HL
 203+ 503A              .E4:
 204+ 503A 2A 10 40         LD HL,(FREEMEMPTR)
 205+ 503D 09               ADD HL,BC
 206+ 503E 22 10 40         LD (FREEMEMPTR),HL
 207+ 5041 18 DE            JR .EXIT
 208+ 5043              .SIZEDIFF:
 209+ 5043 CD A0 4F         CALL Ax5
 210+ 5046 78               LD A,B
 211+ 5047 32 94 4F         LD (ANIMITEMNUM),A
 212+ 504A 44               LD B,H
 213+ 504B 4D               LD C,L
 214+ 504C C9               RET ; BC=size difference in bytes
 215+ 504D              .SIZETOMOVE:
 216+ 504D D5               PUSH DE
 217+ 504E 2A 10 40         LD HL,(FREEMEMPTR)
 218+ 5051 FD 5E 00         LD E,(IY)
 219+ 5054 FD 56 01         LD D,(IY+1)
 220+ 5057 AF               XOR A
 221+ 5058 ED 52            SBC HL,DE
 222+ 505A 44               LD B,H
 223+ 505B 4D               LD C,L
 224+ 505C D1               POP DE
 225+ 505D C9               RET
 226+ 505E              .DECREASE_COMMON:
 227+ 505E FD 6E 00         LD L,(IY)
 228+ 5061 FD 66 01         LD H,(IY+1)
 229+ 5064 AF               XOR A
 230+ 5065 ED 42            SBC HL,BC
 231+ 5067 EB               EX DE,HL
 232+ 5068 C5               PUSH BC
 233+ 5069 CD 4D 50         CALL .SIZETOMOVE
 234+ 506C F3               DI
 235+ 506D 78               LD A,B
 236+ 506E B1               OR C
 237+ 506F 28 08            JR Z,.L1
 238+ 5071 FD 6E 00         LD L,(IY)
 239+ 5074 FD 66 01         LD H,(IY+1)
 240+ 5077 ED B0            LDIR
 241+ 5079              .L1:
 242+ 5079 C1               POP BC
 243+ 507A FD 6E 00         LD L,(IY)
 244+ 507D FD 66 01         LD H,(IY+1)
 245+ 5080 AF               XOR A
 246+ 5081 ED 42            SBC HL,BC
 247+ 5083 FD 75 00         LD (IY),L
 248+ 5086 FD 74 01         LD (IY+1),H
 249+ 5089 C9               RET
 250+ 508A              .INCREASE_COMMON:
 251+ 508A 2A 10 40         LD HL,(FREEMEMPTR)
 252+ 508D 2B               DEC HL
 253+ 508E AF               XOR A
 254+ 508F ED 42            SBC HL,BC
 255+ 5091 EB               EX DE,HL
 256+ 5092 C5               PUSH BC
 257+ 5093 CD 4D 50         CALL .SIZETOMOVE
 258+ 5096 F3               DI
 259+ 5097 78               LD A,B
 260+ 5098 B1               OR C
 261+ 5099 28 06            JR Z,.L2
 262+ 509B 2A 10 40         LD HL,(FREEMEMPTR)
 263+ 509E 2B               DEC HL
 264+ 509F ED B8            LDDR
 265+ 50A1              .L2:
 266+ 50A1 C1               POP BC
 267+ 50A2 FD 6E 00         LD L,(IY)
 268+ 50A5 FD 66 01         LD H,(IY+1)
 269+ 50A8 09               ADD HL,BC
 270+ 50A9 FD 75 00         LD (IY),L
 271+ 50AC FD 74 01         LD (IY+1),H
 272+ 50AF C9               RET
 273+ 50B0              ; *******************************************************************************************************
 274+ 50B0
 275+ 50B0               IF (BASIC_EXTENSION == 1)
 276+ 50B0              ; *******************************************************************************************************
 277+ 50B0              ; function to handle CALL ANIMITEMPAT basic extension
 278+ 50B0              ; ANIMITEMPAT ( BYTE id,
 279+ 50B0              ;               INT ticks >0,
 280+ 50B0              ;               BYTE pattern,
 281+ 50B0              ;               BYTE color )
 282+ 50B0              ; fills animation item data, returns an error if ID out of bounds
 283+ 50B0              ANIMITEMPAT:
 284+ 50B0                  ; opening (
 285+ 50B0 CD 43 6A     	CALL CHKCHAR
 286+ 50B3 28           	DB '('
 287+ 50B4              	; get id
 288+ 50B4 DD 21 1C 52  	LD IX, GETBYT
 289+ 50B8 CD 59 01     	CALL CALBAS
 290+ 50BB F5               PUSH AF
 291+ 50BC                  ; check if out of bounds
 292+ 50BC 3C               INC A
 293+ 50BD 4F               LD C,A
 294+ 50BE 3A 94 4F         LD A,(ANIMITEMNUM)
 295+ 50C1 B9               CP C
 296+ 50C2 DA 5B 6A         JP C,SUBSCRIPT_OUT_OF_RANGE
 297+ 50C5              	; comma
 298+ 50C5 CD 43 6A     	CALL CHKCHAR
 299+ 50C8 2C           	DB ','
 300+ 50C9              	; get ticks
 301+ 50C9 DD 21 2F 54  	LD IX, FRMQNT
 302+ 50CD CD 59 01     	CALL CALBAS
 303+ 50D0 7A               LD A,D
 304+ 50D1 B3               OR E
 305+ 50D2 CA 5F 6A         JP Z, OVERFLOW
 306+ 50D5 D5           	PUSH DE
 307+ 50D6              	; comma
 308+ 50D6 CD 43 6A     	CALL CHKCHAR
 309+ 50D9 2C           	DB ','
 310+ 50DA              	; get pattern
 311+ 50DA DD 21 1C 52  	LD IX, GETBYT
 312+ 50DE CD 59 01     	CALL CALBAS
 313+ 50E1 F5               PUSH AF
 314+ 50E2              	; comma
 315+ 50E2 CD 43 6A     	CALL CHKCHAR
 316+ 50E5 2C           	DB ','
 317+ 50E6              	; get color
 318+ 50E6 DD 21 1C 52  	LD IX, GETBYT
 319+ 50EA CD 59 01     	CALL CALBAS
 320+ 50ED F5               PUSH AF
 321+ 50EE              	; ending )
 322+ 50EE CD 43 6A     	CALL CHKCHAR
 323+ 50F1 29           	DB ')'
 324+ 50F2              .ENTRY:
 325+ 50F2 E5               PUSH HL
 326+ 50F3 DD E1            POP IX
 327+ 50F5 D9               EXX
 328+ 50F6 C1               POP BC ; color
 329+ 50F7 D1               POP DE ; pattern
 330+ 50F8 E1               POP HL ; ticks
 331+ 50F9 D9               EXX
 332+ 50FA F1               POP AF
 333+ 50FB CD A9 4F         CALL GETnthANIMITEM
 334+ 50FE E5               PUSH HL
 335+ 50FF FD E1            POP IY
 336+ 5101 D9               EXX
 337+ 5102 FD 36 00 00      LD (IY),0 ; type=0
 338+ 5106 FD 75 01         LD (IY+1),L
 339+ 5109 FD 74 02         LD (IY+2),H
 340+ 510C FD 72 03         LD (IY+3),D
 341+ 510F FD 70 04         LD (IY+4),B
 342+ 5112
 343+ 5112 DD E5            PUSH IX
 344+ 5114 E1               POP HL
 345+ 5115 C9               RET
 346+ 5116              ; *******************************************************************************************************
 347+ 5116               ENDIF
 348+ 5116
 349+ 5116               IF (DEFUSR_EXTENSION == 1)
 350+ 5116              ; *******************************************************************************************************
 351+ 5116              ; same as ANIMITEMPAT but for DEFUSR approach
 352+ 5116              ; input IX=pointer to input array, real data from +2
 353+ 5116              ; +02 = ID
 354+ 5116              ; +04 = ticks
 355+ 5116              ; +06 = pattern
 356+ 5116              ; +08 = color
 357+ 5116              ANIMITEMPAT_DEFUSR:
 358+ 5116                  ; check if out of bounds
 359+ 5116 DD 4E 02         LD C,(IX+2)
 360+ 5119 0C               INC C
 361+ 511A 3A 94 4F         LD A,(ANIMITEMNUM)
 362+ 511D B9               CP C
 363+ 511E D8               RET C ; out of bounds, prevent memory corruption
 364+ 511F 79               LD A,C
 365+ 5120 3D               DEC A
 366+ 5121 CD A9 4F         CALL GETnthANIMITEM
 367+ 5124 36 00            LD (HL),0 ; type=0
 368+ 5126 23               INC HL
 369+ 5127 DD 7E 04         LD A,(IX+4) ; ticks low
 370+ 512A 77               LD (HL),A
 371+ 512B 23               INC HL
 372+ 512C DD 7E 05         LD A,(IX+5) ; ticks high
 373+ 512F 77               LD (HL),A
 374+ 5130 23               INC HL
 375+ 5131 DD 7E 06         LD A,(IX+6) ; pattern
 376+ 5134 77               LD (HL),A
 377+ 5135 23               INC HL
 378+ 5136 DD 7E 08         LD A,(IX+8) ; color
 379+ 5139 77               LD (HL),A
 380+ 513A C9               RET
 381+ 513B              ; *******************************************************************************************************
 382+ 513B               ENDIF
 383+ 513B
 384+ 513B               IF (BASIC_EXTENSION == 1)
 385+ 513B              ; *******************************************************************************************************
 386+ 513B              ; function to handle CALL ANIMITEMPTR basic extension
 387+ 513B              ; ANIMITEMPTR ( BYTE id,
 388+ 513B              ;               INT ticks,
 389+ 513B              ;               INT pointer,
 390+ 513B              ; fills animation item data, returns an error if ID out of bounds
 391+ 513B              ANIMITEMPTR_CMD:
 392+ 513B                  ; opening (
 393+ 513B CD 43 6A     	CALL CHKCHAR
 394+ 513E 28           	DB '('
 395+ 513F              	; get id
 396+ 513F DD 21 1C 52  	LD IX, GETBYT
 397+ 5143 CD 59 01     	CALL CALBAS
 398+ 5146 F5               PUSH AF
 399+ 5147                  ; check if out of bounds
 400+ 5147 3C               INC A
 401+ 5148 4F               LD C,A
 402+ 5149 3A 94 4F         LD A,(ANIMITEMNUM)
 403+ 514C B9               CP C
 404+ 514D DA 5B 6A         JP C,SUBSCRIPT_OUT_OF_RANGE
 405+ 5150              	; comma
 406+ 5150 CD 43 6A     	CALL CHKCHAR
 407+ 5153 2C           	DB ','
 408+ 5154              	; get ticks
 409+ 5154 DD 21 2F 54  	LD IX, FRMQNT
 410+ 5158 CD 59 01     	CALL CALBAS
 411+ 515B 7A               LD A,D
 412+ 515C B3               OR E
 413+ 515D CA 5F 6A         JP Z,OVERFLOW
 414+ 5160 D5           	PUSH DE
 415+ 5161              	; comma
 416+ 5161 CD 43 6A     	CALL CHKCHAR
 417+ 5164 2C           	DB ','
 418+ 5165              	; get pointer
 419+ 5165 DD 21 2F 54  	LD IX, FRMQNT
 420+ 5169 CD 59 01     	CALL CALBAS
 421+ 516C D5           	PUSH DE
 422+ 516D              	; ending )
 423+ 516D CD 43 6A     	CALL CHKCHAR
 424+ 5170 29           	DB ')'
 425+ 5171              .ENTRY:
 426+ 5171 E5               PUSH HL
 427+ 5172 DD E1            POP IX
 428+ 5174 D9               EXX
 429+ 5175 D1               POP DE ; pointer
 430+ 5176 E1               POP HL ; ticks
 431+ 5177 D9               EXX
 432+ 5178 F1               POP AF
 433+ 5179 CD A9 4F         CALL GETnthANIMITEM
 434+ 517C E5               PUSH HL
 435+ 517D FD E1            POP IY
 436+ 517F D9               EXX
 437+ 5180 FD 36 00 01      LD (IY),1 ; type=1
 438+ 5184 FD 75 01         LD (IY+1),L
 439+ 5187 FD 74 02         LD (IY+2),H
 440+ 518A FD 73 03         LD (IY+3),E
 441+ 518D FD 72 04         LD (IY+4),D
 442+ 5190
 443+ 5190 DD E5            PUSH IX
 444+ 5192 E1               POP HL
 445+ 5193 C9               RET
 446+ 5194              ; *******************************************************************************************************
 447+ 5194               ENDIF
 448+ 5194
 449+ 5194               IF (DEFUSR_EXTENSION == 1)
 450+ 5194              ; *******************************************************************************************************
 451+ 5194              ; same as ANIMITEMPTR but for DEFUSR approach
 452+ 5194              ; input IX=pointer to input array, real data from +2
 453+ 5194              ; +02 = ID
 454+ 5194              ; +04 = ticks
 455+ 5194              ; +06 = pointer
 456+ 5194              ANIMITEMPTR_DEFUSR:
 457+ 5194                  ; check if out of bounds
 458+ 5194 DD 4E 02         LD C,(IX+2)
 459+ 5197 0C               INC C
 460+ 5198 3A 94 4F         LD A,(ANIMITEMNUM)
 461+ 519B B9               CP C
 462+ 519C D8               RET C ; out of bounds, prevent memory corruption
 463+ 519D 79               LD A,C
 464+ 519E 3D               DEC A
 465+ 519F CD A9 4F         CALL GETnthANIMITEM
 466+ 51A2 36 01            LD (HL),1 ; type=1
 467+ 51A4 23               INC HL
 468+ 51A5 DD 7E 04         LD A,(IX+4) ; ticks low
 469+ 51A8 77               LD (HL),A
 470+ 51A9 23               INC HL
 471+ 51AA DD 7E 05         LD A,(IX+5) ; ticks high
 472+ 51AD 77               LD (HL),A
 473+ 51AE 23               INC HL
 474+ 51AF DD 7E 06         LD A,(IX+6) ; pointer low
 475+ 51B2 77               LD (HL),A
 476+ 51B3 23               INC HL
 477+ 51B4 DD 7E 07         LD A,(IX+7) ; pointer high
 478+ 51B7 77               LD (HL),A
 479+ 51B8 C9               RET
 480+ 51B9              ; *******************************************************************************************************
 481+ 51B9               ENDIF
 482+ 51B9
 483+ 51B9               IF (DEFUSR_EXTENSION == 1)
 484+ 51B9              ; *******************************************************************************************************
 485+ 51B9              ; same as MAXANIMDEFS but for DEFUSR approach
 486+ 51B9              ; input IX=pointer to input array, real data from +2
 487+ 51B9              ; +2 = number
 488+ 51B9              MAXANIMDEFS_DEFUSR:
 489+ 51B9 DD 7E 02         LD A,(IX+2)
 490+ 51BC 18 11            JR MAXANIMDEFS.COMMON
 491+ 51BE              ; *******************************************************************************************************
 492+ 51BE               ENDIF
 493+ 51BE
 494+ 51BE              ; *******************************************************************************************************
 495+ 51BE              ; function to handle CALL MAXANIMDEFS basic extension
 496+ 51BE              ; MAXANIMDEFS (BYTE number)
 497+ 51BE              ; sets new number and moves memory buffers as needed
 498+ 51BE              MAXANIMDEFS:
 499+ 51BE               IF (BASIC_EXTENSION == 1)
 500+ 51BE              	; opening (
 501+ 51BE CD 43 6A     	CALL CHKCHAR
 502+ 51C1 28           	DB '('
 503+ 51C2              	; get value
 504+ 51C2 DD 21 1C 52  	LD IX, GETBYT
 505+ 51C6 CD 59 01     	CALL CALBAS
 506+ 51C9 F5               PUSH AF
 507+ 51CA              	; ending )
 508+ 51CA CD 43 6A     	CALL CHKCHAR
 509+ 51CD 29           	DB ')'
 510+ 51CE F1               POP AF
 511+ 51CF               ENDIF
 512+ 51CF              .COMMON:
 513+ 51CF F3               DI
 514+ 51D0              	; save position
 515+ 51D0 E5           	PUSH HL
 516+ 51D1              .ENTRY:
 517+ 51D1 47               LD B,A
 518+ 51D2 3A 97 4F         LD A,(ANIMDEFNUM)
 519+ 51D5 90               SUB B
 520+ 51D6 CA 21 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 521+ 51D9 FD 21 9B 4F      LD IY,ANIMSPRPTR
 522+ 51DD FA E9 51         JP M, .INCREASE
 523+ 51E0                  ; new value is lower than previous one
 524+ 51E0 CD F4 51         CALL .SIZEDIFF
 525+ 51E3 CD 5E 50         CALL MAXANIMITEMS.DECREASE_COMMON
 526+ 51E6 C3 0F 50         JP MAXANIMITEMS.E1
 527+ 51E9              .INCREASE:
 528+ 51E9 ED 44            NEG
 529+ 51EB CD F4 51         CALL .SIZEDIFF
 530+ 51EE CD 8A 50         CALL MAXANIMITEMS.INCREASE_COMMON
 531+ 51F1 C3 33 50         JP MAXANIMITEMS.E2
 532+ 51F4              .SIZEDIFF:
 533+ 51F4 26 00            LD H,0
 534+ 51F6 6F               LD L,A
 535+ 51F7 CD 30 69         CALL HLx16
 536+ 51FA 78               LD A,B
 537+ 51FB 32 97 4F         LD (ANIMDEFNUM),A
 538+ 51FE 44               LD B,H
 539+ 51FF 4D               LD C,L
 540+ 5200 C9               RET ; BC=size difference in bytes
 541+ 5201              ; *******************************************************************************************************
 542+ 5201
 543+ 5201               IF (BASIC_EXTENSION == 1)
 544+ 5201              ; *******************************************************************************************************
 545+ 5201              ; function to handle CALL ANIMDEF basic extension
 546+ 5201              ; ANIMITEMPAT ( BYTE id,
 547+ 5201              ;               BYTE size,
 548+ 5201              ;               INT[] list )
 549+ 5201              ; fills animation definition data, returns an error if out of bounds, or invalid type
 550+ 5201              ANIMDEF:
 551+ 5201                  ; opening (
 552+ 5201 CD 43 6A     	CALL CHKCHAR
 553+ 5204 28           	DB '('
 554+ 5205              	; get id
 555+ 5205 DD 21 1C 52  	LD IX, GETBYT
 556+ 5209 CD 59 01     	CALL CALBAS
 557+ 520C F5               PUSH AF
 558+ 520D                  ; check if out of bounds
 559+ 520D 3C               INC A
 560+ 520E 4F               LD C,A
 561+ 520F 3A 97 4F         LD A,(ANIMDEFNUM)
 562+ 5212 B9               CP C
 563+ 5213 DA 5B 6A         JP C,SUBSCRIPT_OUT_OF_RANGE
 564+ 5216              	; comma
 565+ 5216 CD 43 6A     	CALL CHKCHAR
 566+ 5219 2C           	DB ','
 567+ 521A              	; get size
 568+ 521A DD 21 1C 52  	LD IX, GETBYT
 569+ 521E CD 59 01     	CALL CALBAS
 570+ 5221 FE 10            CP 16
 571+ 5223 D2 5F 6A         JP NC, OVERFLOW
 572+ 5226 B7               OR A
 573+ 5227 CA 5F 6A         JP Z, OVERFLOW
 574+ 522A F5           	PUSH AF
 575+ 522B              	; comma
 576+ 522B CD 43 6A     	CALL CHKCHAR
 577+ 522E 2C           	DB ','
 578+ 522F              	; get pointer to a list of animation items in integer array format
 579+ 522F                  ; get array pointer
 580+ 522F D1               POP DE
 581+ 5230 D5               PUSH DE
 582+ 5231 3E 02            LD A,2
 583+ 5233 06 01            LD B,1
 584+ 5235 CD 70 6A         CALL GET_BASIC_ARRAY_DATA_POINTER
 585+ 5238 C5               PUSH BC
 586+ 5239              	; ending )
 587+ 5239 CD 43 6A     	CALL CHKCHAR
 588+ 523C 29           	DB ')'
 589+ 523D              .ENTRY:
 590+ 523D E5               PUSH HL
 591+ 523E DD E1            POP IX
 592+ 5240 D1               POP DE ; pointer to INT array
 593+ 5241 C1               POP BC ; B=item number
 594+ 5242 F1               POP AF ; id
 595+ 5243 D5               PUSH DE
 596+ 5244 CD B2 4F         CALL GETnthANIMDEF
 597+ 5247 D1               POP DE
 598+ 5248 70               LD (HL),B
 599+ 5249              .L1:
 600+ 5249 23               INC HL
 601+ 524A 1A               LD A,(DE)
 602+ 524B 13          > INC DE
 602+ 524C 13          > INC DE
 603+ 524D 77               LD (HL),A
 604+ 524E 10 F9            DJNZ .L1
 605+ 5250 DD E5            PUSH IX
 606+ 5252 E1               POP HL
 607+ 5253 C9               RET
 608+ 5254              ; *******************************************************************************************************
 609+ 5254               ENDIF
 610+ 5254
 611+ 5254               IF (DEFUSR_EXTENSION == 1)
 612+ 5254              ; *******************************************************************************************************
 613+ 5254              ; same as ANIMDEF but for DEFUSR approach
 614+ 5254              ; input IX=pointer to input array, real data from +2
 615+ 5254              ; +02 = ID
 616+ 5254              ; +04 = list size
 617+ 5254              ; +06 = list pointer
 618+ 5254              ANIMDEF_DEFUSR:
 619+ 5254                  ; check if out of bounds
 620+ 5254 DD 4E 02         LD C,(IX+2)
 621+ 5257 0C               INC C
 622+ 5258 3A 97 4F         LD A,(ANIMDEFNUM)
 623+ 525B B9               CP C
 624+ 525C D8               RET C ; invalid id
 625+ 525D              	; get size
 626+ 525D DD 7E 04         LD A,(IX+4)
 627+ 5260 FE 10            CP 16
 628+ 5262 D0               RET NC ; overflow
 629+ 5263 B7               OR A
 630+ 5264 C8               RET Z ; ID=0, invalid
 631+ 5265 47               LD B,A
 632+ 5266 79               LD A,C
 633+ 5267 3D               DEC A
 634+ 5268 CD B2 4F         CALL GETnthANIMDEF
 635+ 526B 70               LD (HL),B
 636+ 526C DD 5E 06         LD E,(IX+6)
 637+ 526F DD 56 07         LD D,(IX+7)
 638+ 5272              .L1:
 639+ 5272 23               INC HL
 640+ 5273 1A               LD A,(DE)
 641+ 5274 13          > INC DE
 641+ 5275 13          > INC DE
 642+ 5276 77               LD (HL),A
 643+ 5277 10 F9            DJNZ .L1
 644+ 5279 C9               RET
 645+ 527A              ; *******************************************************************************************************
 646+ 527A               ENDIF
 647+ 527A
 648+ 527A               IF (DEFUSR_EXTENSION == 1)
 649+ 527A              ; *******************************************************************************************************
 650+ 527A              ; same as MAXANIMSPRS but for DEFUSR approach
 651+ 527A              ; input IX=pointer to input array, real data from +2
 652+ 527A              ; +2 = number
 653+ 527A              MAXANIMSPRS_DEFUSR:
 654+ 527A DD 7E 02         LD A,(IX+2)
 655+ 527D 18 11            JR MAXANIMSPRS.COMMON
 656+ 527F              ; *******************************************************************************************************
 657+ 527F               ENDIF
 658+ 527F
 659+ 527F              ; *******************************************************************************************************
 660+ 527F              ; function to handle CALL MAXANIMSPRS basic extension
 661+ 527F              ; MAXANIMSPRS (BYTE number)
 662+ 527F              ; sets new number and moves memory buffers as needed
 663+ 527F              MAXANIMSPRS:
 664+ 527F               IF (BASIC_EXTENSION == 1)
 665+ 527F              	; opening (
 666+ 527F CD 43 6A     	CALL CHKCHAR
 667+ 5282 28           	DB '('
 668+ 5283              	; get value
 669+ 5283 DD 21 1C 52  	LD IX, GETBYT
 670+ 5287 CD 59 01     	CALL CALBAS
 671+ 528A F5               PUSH AF
 672+ 528B              	; ending )
 673+ 528B CD 43 6A     	CALL CHKCHAR
 674+ 528E 29           	DB ')'
 675+ 528F F1               POP AF
 676+ 5290               ENDIF
 677+ 5290              .COMMON:
 678+ 5290 F3               DI
 679+ 5291              	; save position
 680+ 5291 E5           	PUSH HL
 681+ 5292              .ENTRY:
 682+ 5292 47               LD B,A
 683+ 5293 3A 9A 4F         LD A,(ANIMSPRNUM)
 684+ 5296 90               SUB B
 685+ 5297 CA 21 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 686+ 529A FD 21 9E 4F      LD IY,AUTOSGAMPTR
 687+ 529E FA AA 52         JP M, .INCREASE
 688+ 52A1                  ; new value is lower than previous one
 689+ 52A1 CD CB 52         CALL .SIZEDIFF
 690+ 52A4 CD 5E 50         CALL MAXANIMITEMS.DECREASE_COMMON
 691+ 52A7 C3 18 50         JP MAXANIMITEMS.E3
 692+ 52AA              .INCREASE:
 693+ 52AA ED 44            NEG
 694+ 52AC F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 695+ 52AD CD CB 52         CALL .SIZEDIFF
 696+ 52B0 CD 8A 50         CALL MAXANIMITEMS.INCREASE_COMMON
 697+ 52B3 AF               XOR A
 698+ 52B4 ED 42            SBC HL,BC ; location of new stuff
 699+ 52B6 F1               POP AF
 700+ 52B7 C5               PUSH BC
 701+ 52B8 47               LD B,A
 702+ 52B9 11 08 00         LD DE,8
 703+ 52BC E5               PUSH HL
 704+ 52BD DD E1            POP IX
 705+ 52BF              .L1:
 706+ 52BF DD 36 06 00      LD (IX+6),0 ; active flag
 707+ 52C3 DD 19            ADD IX,DE
 708+ 52C5 10 F8            DJNZ .L1
 709+ 52C7 C1               POP BC
 710+ 52C8 C3 3A 50         JP MAXANIMITEMS.E4
 711+ 52CB              .SIZEDIFF:
 712+ 52CB 26 00            LD H,0
 713+ 52CD 6F               LD L,A
 714+ 52CE CD 31 69         CALL HLx8
 715+ 52D1 78               LD A,B
 716+ 52D2 32 9A 4F         LD (ANIMSPRNUM),A
 717+ 52D5 44               LD B,H
 718+ 52D6 4D               LD C,L
 719+ 52D7 C9               RET ; BC=size difference in bytes
 720+ 52D8              ; *******************************************************************************************************
 721+ 52D8
 722+ 52D8               IF (BASIC_EXTENSION == 1)
 723+ 52D8              ; *******************************************************************************************************
 724+ 52D8              ; function to handle CALL ANIMSPRITE basic extension
 725+ 52D8              ; ANIMSPRITE ( BYTE id,
 726+ 52D8              ;              BYTE sprite_number,
 727+ 52D8              ;              BYTE animation_definition_id,
 728+ 52D8              ;              BYTE cyclic_flag )
 729+ 52D8              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 730+ 52D8              ANIMSPRITE:
 731+ 52D8                  ; opening (
 732+ 52D8 CD 43 6A     	CALL CHKCHAR
 733+ 52DB 28           	DB '('
 734+ 52DC              	; get sprite animation id
 735+ 52DC DD 21 1C 52  	LD IX, GETBYT
 736+ 52E0 CD 59 01     	CALL CALBAS
 737+ 52E3 F5               PUSH AF
 738+ 52E4 3C               INC A
 739+ 52E5 4F               LD C,A
 740+ 52E6 3A 9A 4F         LD A,(ANIMSPRNUM)
 741+ 52E9 B9               CP C
 742+ 52EA DA 5B 6A         JP C,SUBSCRIPT_OUT_OF_RANGE
 743+ 52ED              	; comma
 744+ 52ED CD 43 6A     	CALL CHKCHAR
 745+ 52F0 2C           	DB ','
 746+ 52F1              	; get sprite number
 747+ 52F1 DD 21 1C 52  	LD IX, GETBYT
 748+ 52F5 CD 59 01     	CALL CALBAS
 749+ 52F8 F5               PUSH AF
 750+ 52F9                  ; check if out of bounds
 751+ 52F9 FE 20            CP 32
 752+ 52FB D2 5B 6A         JP NC, SUBSCRIPT_OUT_OF_RANGE
 753+ 52FE              	; comma
 754+ 52FE CD 43 6A     	CALL CHKCHAR
 755+ 5301 2C           	DB ','
 756+ 5302              	; get animation definition id
 757+ 5302 DD 21 1C 52  	LD IX, GETBYT
 758+ 5306 CD 59 01     	CALL CALBAS
 759+ 5309 F5               PUSH AF
 760+ 530A 3C               INC A
 761+ 530B 4F               LD C,A
 762+ 530C 3A 97 4F         LD A,(ANIMDEFNUM)
 763+ 530F B9               CP C
 764+ 5310 DA 5B 6A         JP C,SUBSCRIPT_OUT_OF_RANGE
 765+ 5313              	; comma
 766+ 5313 CD 43 6A     	CALL CHKCHAR
 767+ 5316 2C           	DB ','
 768+ 5317              	; get cyclic flag
 769+ 5317 DD 21 1C 52  	LD IX, GETBYT
 770+ 531B CD 59 01         CALL CALBAS
 771+ 531E F5           	PUSH AF
 772+ 531F              	; ending )
 773+ 531F CD 43 6A     	CALL CHKCHAR
 774+ 5322 29           	DB ')'
 775+ 5323              .ENTRY:
 776+ 5323 E5               PUSH HL
 777+ 5324 DD E1            POP IX
 778+ 5326 D9               EXX
 779+ 5327 D1               POP DE ; cyclic
 780+ 5328 C1               POP BC ; animation definition id
 781+ 5329 E1               POP HL ; sprite number
 782+ 532A D9               EXX
 783+ 532B F1               POP AF ; sprite animation id
 784+ 532C CD BE 4F         CALL GETnthSPRANIM
 785+ 532F E5               PUSH HL
 786+ 5330 FD E1            POP IY
 787+ 5332 D9               EXX
 788+ 5333 FD 74 00         LD (IY),H
 789+ 5336 FD 70 04         LD (IY+4),B
 790+ 5339 FD 72 05         LD (IY+5),D
 791+ 533C                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 792+ 533C                  ; following will do preparation for ANIMSTEP situation
 793+ 533C                  ; current item set to above limit and timer to 1
 794+ 533C                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 795+ 533C FD 36 03 FF      LD (IY+3),255
 796+ 5340 FD 36 01 01      LD (IY+1),1
 797+ 5344 FD 36 02 00      LD (IY+2),0
 798+ 5348                  ; mark as sprite animation
 799+ 5348 FD 36 07 00      LD (IY+7),0
 800+ 534C DD E5            PUSH IX
 801+ 534E E1               POP HL
 802+ 534F C9               RET
 803+ 5350              ; *******************************************************************************************************
 804+ 5350               ENDIF
 805+ 5350
 806+ 5350               IF (DEFUSR_EXTENSION == 1)
 807+ 5350              ; *******************************************************************************************************
 808+ 5350              ; same as ANIMSPRITE but for DEFUSR approach
 809+ 5350              ; input IX=pointer to input array, real data from +2
 810+ 5350              ; +02 = ID
 811+ 5350              ; +04 = sprite number
 812+ 5350              ; +06 = animation definition id
 813+ 5350              ; +08 = cyclic flag
 814+ 5350              ANIMSPRITE_DEFUSR:
 815+ 5350 DD 4E 02         LD C,(IX+2)
 816+ 5353 0C               INC C
 817+ 5354 3A 9A 4F         LD A,(ANIMSPRNUM)
 818+ 5357 B9               CP C
 819+ 5358 D8               RET C ; invalid id
 820+ 5359              	; get sprite number
 821+ 5359 DD 7E 04         LD A,(IX+4)
 822+ 535C FE 20            CP 32
 823+ 535E D0               RET NC ; invalid sprite id
 824+ 535F DD 46 06         LD B,(IX+6)
 825+ 5362 04               INC B
 826+ 5363 3A 97 4F         LD A,(ANIMDEFNUM)
 827+ 5366 B8               CP B
 828+ 5367 D8               RET C ; invalid animation definition id
 829+ 5368 79               LD A,C
 830+ 5369 3D               DEC A
 831+ 536A CD BE 4F         CALL GETnthSPRANIM
 832+ 536D E5               PUSH HL
 833+ 536E DD 7E 04         LD A,(IX+4)
 834+ 5371 77               LD (HL),A ; +0
 835+ 5372 23               INC HL
 836+ 5373 36 01            LD (HL),1 ; +1
 837+ 5375 23               INC HL
 838+ 5376 36 00            LD (HL),0 ; +2
 839+ 5378 23               INC HL
 840+ 5379 36 FF            LD (HL),255 ; +3
 841+ 537B 23               INC HL
 842+ 537C 05               DEC B
 843+ 537D 70               LD (HL),B ; +4
 844+ 537E 23               INC HL
 845+ 537F DD 7E 08         LD A,(IX+8) ; +5
 846+ 5382 77               LD (HL),A
 847+ 5383 23               INC HL
 848+ 5384 23               INC HL
 849+ 5385 36 00            LD (HL),0 ; +7
 850+ 5387 C9               RET
 851+ 5388              ; *******************************************************************************************************
 852+ 5388               ENDIF
 853+ 5388
 854+ 5388
 855+ 5388               IF (BASIC_EXTENSION == 1)
 856+ 5388              ; *******************************************************************************************************
 857+ 5388              ; function to handle CALL ANIMCHAR basic extension
 858+ 5388              ; ANIMCHAR ( BYTE id,
 859+ 5388              ;            INT character number 0-767,
 860+ 5388              ;            BYTE animation_definition_id,
 861+ 5388              ;            BYTE cyclic_flag )
 862+ 5388              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 863+ 5388              ANIMCHAR:
 864+ 5388                  ; opening (
 865+ 5388 CD 43 6A     	CALL CHKCHAR
 866+ 538B 28           	DB '('
 867+ 538C              	; get sprite animation id
 868+ 538C DD 21 1C 52  	LD IX, GETBYT
 869+ 5390 CD 59 01     	CALL CALBAS
 870+ 5393 F5               PUSH AF
 871+ 5394 3C               INC A
 872+ 5395 4F               LD C,A
 873+ 5396 3A 9A 4F         LD A,(ANIMSPRNUM)
 874+ 5399 B9               CP C
 875+ 539A DA 5B 6A         JP C,SUBSCRIPT_OUT_OF_RANGE
 876+ 539D              	; comma
 877+ 539D CD 43 6A     	CALL CHKCHAR
 878+ 53A0 2C           	DB ','
 879+ 53A1              	; get character number
 880+ 53A1 DD 21 2F 54  	LD IX, FRMQNT
 881+ 53A5 CD 59 01     	CALL CALBAS
 882+ 53A8 D5               PUSH DE
 883+ 53A9                  ; check if out of bounds
 884+ 53A9 7A               LD A,D
 885+ 53AA FE 03            CP 3
 886+ 53AC D2 5B 6A         JP NC, SUBSCRIPT_OUT_OF_RANGE
 887+ 53AF              	; comma
 888+ 53AF CD 43 6A     	CALL CHKCHAR
 889+ 53B2 2C           	DB ','
 890+ 53B3              	; get animation definition id
 891+ 53B3 DD 21 1C 52  	LD IX, GETBYT
 892+ 53B7 CD 59 01     	CALL CALBAS
 893+ 53BA F5               PUSH AF
 894+ 53BB 3C               INC A
 895+ 53BC 4F               LD C,A
 896+ 53BD 3A 97 4F         LD A,(ANIMDEFNUM)
 897+ 53C0 B9               CP C
 898+ 53C1 DA 5B 6A         JP C,SUBSCRIPT_OUT_OF_RANGE
 899+ 53C4              	; comma
 900+ 53C4 CD 43 6A     	CALL CHKCHAR
 901+ 53C7 2C           	DB ','
 902+ 53C8              	; get cyclic flag
 903+ 53C8 DD 21 1C 52  	LD IX, GETBYT
 904+ 53CC CD 59 01         CALL CALBAS
 905+ 53CF F5           	PUSH AF
 906+ 53D0              	; ending )
 907+ 53D0 CD 43 6A     	CALL CHKCHAR
 908+ 53D3 29           	DB ')'
 909+ 53D4              .ENTRY:
 910+ 53D4 E5               PUSH HL
 911+ 53D5 DD E1            POP IX
 912+ 53D7 D9               EXX
 913+ 53D8 D1               POP DE ; cyclic
 914+ 53D9 C1               POP BC ; animation definition id
 915+ 53DA E1               POP HL ; character number
 916+ 53DB D9               EXX
 917+ 53DC F1               POP AF ; sprite animation id
 918+ 53DD CD BE 4F         CALL GETnthSPRANIM
 919+ 53E0 E5               PUSH HL
 920+ 53E1 FD E1            POP IY
 921+ 53E3 D9               EXX
 922+ 53E4 FD 75 00         LD (IY),L
 923+ 53E7 24               INC H ; save character bank+1
 924+ 53E8 FD 74 07         LD (IY+7),H
 925+ 53EB FD 70 04         LD (IY+4),B
 926+ 53EE FD 72 05         LD (IY+5),D
 927+ 53F1                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 928+ 53F1                  ; following will do preparation for ANIMSTEP situation
 929+ 53F1                  ; current item set to above limit and timer to 1
 930+ 53F1                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 931+ 53F1 FD 36 03 FF      LD (IY+3),255
 932+ 53F5 FD 36 01 01      LD (IY+1),1
 933+ 53F9 FD 36 02 00      LD (IY+2),0
 934+ 53FD DD E5            PUSH IX
 935+ 53FF E1               POP HL
 936+ 5400 C9               RET
 937+ 5401              ; *******************************************************************************************************
 938+ 5401               ENDIF
 939+ 5401
 940+ 5401               IF (DEFUSR_EXTENSION == 1)
 941+ 5401              ; *******************************************************************************************************
 942+ 5401              ; same as ANIMCHAR but for DEFUSR approach
 943+ 5401              ; input IX=pointer to input array, real data from +2
 944+ 5401              ; +02 = ID
 945+ 5401              ; +04 = character number
 946+ 5401              ; +06 = animation definition id
 947+ 5401              ; +08 = cyclic flag
 948+ 5401              ANIMCHAR_DEFUSR:
 949+ 5401 DD 4E 02         LD C,(IX+2)
 950+ 5404 0C               INC C
 951+ 5405 3A 9A 4F         LD A,(ANIMSPRNUM)
 952+ 5408 B9               CP C
 953+ 5409 D8               RET C ; invalid id
 954+ 540A              	; get sprite number
 955+ 540A DD 7E 05         LD A,(IX+5)
 956+ 540D FE 03            CP 3
 957+ 540F D0               RET NC ; invalid character (>767)
 958+ 5410 DD 46 06         LD B,(IX+6)
 959+ 5413 04               INC B
 960+ 5414 3A 97 4F         LD A,(ANIMDEFNUM)
 961+ 5417 B8               CP B
 962+ 5418 D8               RET C ; invalid animation definition id
 963+ 5419 79               LD A,C
 964+ 541A 3D               DEC A
 965+ 541B CD BE 4F         CALL GETnthSPRANIM
 966+ 541E E5               PUSH HL
 967+ 541F DD 7E 04         LD A,(IX+4)
 968+ 5422 77               LD (HL),A ; +0
 969+ 5423 23               INC HL
 970+ 5424 36 01            LD (HL),1 ; +1
 971+ 5426 23               INC HL
 972+ 5427 36 00            LD (HL),0 ; +2
 973+ 5429 23               INC HL
 974+ 542A 36 FF            LD (HL),255 ; +3
 975+ 542C 23               INC HL
 976+ 542D 05               DEC B
 977+ 542E 70               LD (HL),B ; +4
 978+ 542F 23               INC HL
 979+ 5430 DD 7E 08         LD A,(IX+8) ; +5
 980+ 5433 77               LD (HL),A
 981+ 5434 23               INC HL
 982+ 5435 23               INC HL
 983+ 5436 DD 7E 05         LD A,(IX+5)
 984+ 5439 3C               INC A
 985+ 543A 77               LD (HL),A ; +7
 986+ 543B C9               RET
 987+ 543C              ; *******************************************************************************************************
 988+ 543C               ENDIF
 989+ 543C
 990+ 543C               IF (DEFUSR_EXTENSION == 1)
 991+ 543C              ; *******************************************************************************************************
 992+ 543C              ; same as MAXAUTOSGAMS but for DEFUSR approach
 993+ 543C              ; input IX=pointer to input array, real data from +2
 994+ 543C              ; +2 = number
 995+ 543C              MAXAUTOSGAMS_DEFUSR:
 996+ 543C DD 7E 02         LD A,(IX+2)
 997+ 543F 18 11            JR MAXAUTOSGAMS.COMMON
 998+ 5441              ; *******************************************************************************************************
 999+ 5441               ENDIF
1000+ 5441
1001+ 5441              ; *******************************************************************************************************
1002+ 5441              ; function to handle CALL MAXAUTOSGAMS basic extension
1003+ 5441              ; MAXAUTOSGAMS (BYTE number)
1004+ 5441              ; sets new number and moves memory buffers as needed
1005+ 5441              MAXAUTOSGAMS:
1006+ 5441               IF (BASIC_EXTENSION == 1)
1007+ 5441              	; opening (
1008+ 5441 CD 43 6A     	CALL CHKCHAR
1009+ 5444 28           	DB '('
1010+ 5445              	; get value
1011+ 5445 DD 21 1C 52  	LD IX, GETBYT
1012+ 5449 CD 59 01     	CALL CALBAS
1013+ 544C F5               PUSH AF
1014+ 544D              	; ending )
1015+ 544D CD 43 6A     	CALL CHKCHAR
1016+ 5450 29           	DB ')'
1017+ 5451 F1               POP AF
1018+ 5452               ENDIF
1019+ 5452              .COMMON:
1020+ 5452 F3               DI
1021+ 5453              	; save position
1022+ 5453 E5           	PUSH HL
1023+ 5454              .ENTRY:
1024+ 5454 47               LD B,A
1025+ 5455 3A 9D 4F         LD A,(AUTOSGAMNUM)
1026+ 5458 90               SUB B
1027+ 5459 CA 21 50         JP Z, MAXANIMITEMS.EXIT; same value as before
1028+ 545C FD 21 10 40      LD IY,FREEMEMPTR
1029+ 5460 FA 6C 54         JP M, .INCREASE
1030+ 5463                  ; new value is lower than previous one
1031+ 5463 CD 8D 54         CALL .SIZEDIFF
1032+ 5466 CD 5E 50         CALL MAXANIMITEMS.DECREASE_COMMON
1033+ 5469 C3 21 50         JP MAXANIMITEMS.EXIT
1034+ 546C              .INCREASE:
1035+ 546C ED 44            NEG
1036+ 546E F5               PUSH AF; save difference for later to set active flag to 0 of new entires
1037+ 546F CD 8D 54         CALL .SIZEDIFF
1038+ 5472 CD 8A 50         CALL MAXANIMITEMS.INCREASE_COMMON
1039+ 5475 AF               XOR A
1040+ 5476 ED 42            SBC HL,BC ; location of new stuff
1041+ 5478 F1               POP AF
1042+ 5479 C5               PUSH BC
1043+ 547A 47               LD B,A
1044+ 547B 11 18 00         LD DE,24
1045+ 547E E5               PUSH HL
1046+ 547F DD E1            POP IX
1047+ 5481              .L1:
1048+ 5481 DD 36 13 00      LD (IX+19),0 ; active flag
1049+ 5485 DD 19            ADD IX,DE
1050+ 5487 10 F8            DJNZ .L1
1051+ 5489 C1               POP BC
1052+ 548A C3 21 50         JP MAXANIMITEMS.EXIT
1053+ 548D              .SIZEDIFF:
1054+ 548D 26 00            LD H,0
1055+ 548F 6F               LD L,A
1056+ 5490 CD 31 69         CALL HLx8
1057+ 5493 54               LD D,H
1058+ 5494 5D               LD E,L
1059+ 5495 29               ADD HL,HL
1060+ 5496 19               ADD HL,DE
1061+ 5497 78               LD A,B
1062+ 5498 32 9D 4F         LD (AUTOSGAMNUM),A
1063+ 549B 44               LD B,H
1064+ 549C 4D               LD C,L
1065+ 549D C9               RET ; BC=size difference in bytes
1066+ 549E              ; *******************************************************************************************************
1067+ 549E
1068+ 549E               IF (BASIC_EXTENSION == 1)
1069+ 549E              ; *******************************************************************************************************
1070+ 549E              ; function to handle CALL AUTOSGAMDEF basic extension
1071+ 549E              ; AUTOSGAMDEF ( BYTE id,
1072+ 549E              ;               INT VARIABLE x, INT VARIABLE y,
1073+ 549E              ;               INT minimum, INT maximum, INT delta,
1074+ 549E              ;               INT direction =0 horizontal,
1075+ 549E              ;               INT ticks,
1076+ 549E              ;               BYTE sprite_group_count,
1077+ 549E              ;               INT[2][sprite_group_count] VARIABLE sprite_group,
1078+ 549E              ;               BYTE item_number,
1079+ 549E              ;               INT[] VARIABLE sprite_animations_negative_direction,
1080+ 549E              ;               INT[] VARIABLE sprite_animations_positive_direction
1081+ 549E              AUTOSGAMDEF:
1082+ 549E                  ; opening (
1083+ 549E CD 43 6A     	CALL CHKCHAR
1084+ 54A1 28           	DB '('
1085+ 54A2              	; get sprite animation id
1086+ 54A2 DD 21 1C 52  	LD IX, GETBYT
1087+ 54A6 CD 59 01     	CALL CALBAS
1088+ 54A9 F5               PUSH AF
1089+ 54AA 3C               INC A
1090+ 54AB 4F               LD C,A
1091+ 54AC 3A 9D 4F         LD A,(AUTOSGAMNUM)
1092+ 54AF B9               CP C
1093+ 54B0 DA 5B 6A         JP C,SUBSCRIPT_OUT_OF_RANGE
1094+ 54B3 F1               POP AF
1095+ 54B4 E5               PUSH HL
1096+ 54B5 CD CA 4F         CALL GETnthAUTOSGAM
1097+ 54B8 22 30 67         LD (BLIT_TMP),HL ; for later
1098+ 54BB E1               POP HL
1099+ 54BC              	; comma
1100+ 54BC CD 43 6A     	CALL CHKCHAR
1101+ 54BF 2C           	DB ','
1102+ 54C0              	; get address of the X coordinate variable
1103+ 54C0 DD 21 A4 5E  	LD IX, PTRGET
1104+ 54C4 CD 59 01     	CALL CALBAS
1105+ 54C7 DD 2A 30 67  	LD IX,(BLIT_TMP)
1106+ 54CB DD 73 00         LD (IX+0),E
1107+ 54CE DD 72 01         LD (IX+1),D
1108+ 54D1              	; comma
1109+ 54D1 CD 43 6A     	CALL CHKCHAR
1110+ 54D4 2C           	DB ','
1111+ 54D5              	; get address of the Y coordinate variable
1112+ 54D5 DD 21 A4 5E  	LD IX, PTRGET
1113+ 54D9 CD 59 01     	CALL CALBAS
1114+ 54DC DD 2A 30 67  	LD IX,(BLIT_TMP)
1115+ 54E0 DD 73 02         LD (IX+2),E
1116+ 54E3 DD 72 03         LD (IX+3),D
1117+ 54E6              	; comma
1118+ 54E6 CD 43 6A     	CALL CHKCHAR
1119+ 54E9 2C           	DB ','
1120+ 54EA              	; get minimum value
1121+ 54EA DD 21 2F 54  	LD IX, FRMQNT
1122+ 54EE CD 59 01     	CALL CALBAS
1123+ 54F1 DD 2A 30 67  	LD IX,(BLIT_TMP)
1124+ 54F5 DD 73 04         LD (IX+4),E
1125+ 54F8 DD 72 05         LD (IX+5),D
1126+ 54FB              	; comma
1127+ 54FB CD 43 6A     	CALL CHKCHAR
1128+ 54FE 2C           	DB ','
1129+ 54FF              	; get maximum value
1130+ 54FF DD 21 2F 54  	LD IX, FRMQNT
1131+ 5503 CD 59 01     	CALL CALBAS
1132+ 5506 DD 2A 30 67  	LD IX,(BLIT_TMP)
1133+ 550A DD 73 06         LD (IX+6),E
1134+ 550D DD 72 07         LD (IX+7),D
1135+ 5510              	; comma
1136+ 5510 CD 43 6A     	CALL CHKCHAR
1137+ 5513 2C           	DB ','
1138+ 5514              	; get delta value
1139+ 5514 DD 21 2F 54  	LD IX, FRMQNT
1140+ 5518 CD 59 01     	CALL CALBAS
1141+ 551B DD 2A 30 67  	LD IX,(BLIT_TMP)
1142+ 551F DD 73 08         LD (IX+8),E
1143+ 5522 DD 72 09         LD (IX+9),D
1144+ 5525              	; comma
1145+ 5525 CD 43 6A     	CALL CHKCHAR
1146+ 5528 2C           	DB ','
1147+ 5529              	; get direction value
1148+ 5529 DD 21 2F 54  	LD IX, FRMQNT
1149+ 552D CD 59 01     	CALL CALBAS
1150+ 5530 DD 2A 30 67  	LD IX,(BLIT_TMP)
1151+ 5534 DD 73 0A         LD (IX+10),E
1152+ 5537              	; comma
1153+ 5537 CD 43 6A     	CALL CHKCHAR
1154+ 553A 2C           	DB ','
1155+ 553B              	; get ticks value
1156+ 553B DD 21 2F 54  	LD IX, FRMQNT
1157+ 553F CD 59 01     	CALL CALBAS
1158+ 5542 DD 2A 30 67  	LD IX,(BLIT_TMP)
1159+ 5546 DD 73 14         LD (IX+20),E
1160+ 5549 DD 72 15         LD (IX+21),D
1161+ 554C              	; comma
1162+ 554C CD 43 6A     	CALL CHKCHAR
1163+ 554F 2C           	DB ','
1164+ 5550              	; get sprite group count
1165+ 5550 DD 21 1C 52  	LD IX, GETBYT
1166+ 5554 CD 59 01     	CALL CALBAS
1167+ 5557 B7               OR A
1168+ 5558 CA 5B 6A         JP Z,SUBSCRIPT_OUT_OF_RANGE
1169+ 555B DD 2A 30 67  	LD IX,(BLIT_TMP)
1170+ 555F DD 77 0B         LD (IX+11),A
1171+ 5562              	; comma
1172+ 5562 CD 43 6A     	CALL CHKCHAR
1173+ 5565 2C           	DB ','
1174+ 5566              	; get sprite group definition array data pointer
1175+ 5566 DD 2A 30 67  	LD IX,(BLIT_TMP)
1176+ 556A DD 5E 0B         LD E,(IX+11)
1177+ 556D 16 03        	LD D,3
1178+ 556F 3E 02        	LD A,2
1179+ 5571 47           	LD B,A
1180+ 5572 CD 70 6A     	CALL GET_BASIC_ARRAY_DATA_POINTER
1181+ 5575 DD 2A 30 67  	LD IX,(BLIT_TMP)
1182+ 5579 DD 71 0C     	LD (IX+12),C
1183+ 557C DD 70 0D         LD (IX+13),B
1184+ 557F              	; comma
1185+ 557F CD 43 6A     	CALL CHKCHAR
1186+ 5582 2C           	DB ','
1187+ 5583              	; get sprite animation array size
1188+ 5583 DD 21 1C 52  	LD IX,GETBYT
1189+ 5587 CD 59 01     	CALL CALBAS
1190+ 558A DD 2A 30 67  	LD IX,(BLIT_TMP)
1191+ 558E DD 77 0E         LD (IX+14),A
1192+ 5591 B7               OR A
1193+ 5592 CA 5B 6A         JP Z,SUBSCRIPT_OUT_OF_RANGE
1194+ 5595              	; comma
1195+ 5595 CD 43 6A     	CALL CHKCHAR
1196+ 5598 2C           	DB ','
1197+ 5599                  ; get array pointer for negative direction
1198+ 5599 DD 2A 30 67  	LD IX,(BLIT_TMP)
1199+ 559D DD 56 0E         LD D,(IX+14)
1200+ 55A0 3E 02            LD A,2
1201+ 55A2 06 01            LD B,1
1202+ 55A4 CD 70 6A         CALL GET_BASIC_ARRAY_DATA_POINTER
1203+ 55A7 DD 2A 30 67  	LD IX,(BLIT_TMP)
1204+ 55AB DD 71 0F         LD (IX+15),C
1205+ 55AE DD 70 10         LD (IX+16),B
1206+ 55B1              	; comma
1207+ 55B1 CD 43 6A     	CALL CHKCHAR
1208+ 55B4 2C           	DB ','
1209+ 55B5                  ; get array pointer for positive direction
1210+ 55B5 DD 2A 30 67  	LD IX,(BLIT_TMP)
1211+ 55B9 DD 56 0E         LD D,(IX+14)
1212+ 55BC 3E 02            LD A,2
1213+ 55BE 06 01            LD B,1
1214+ 55C0 CD 70 6A         CALL GET_BASIC_ARRAY_DATA_POINTER
1215+ 55C3 DD 2A 30 67  	LD IX,(BLIT_TMP)
1216+ 55C7 DD 71 11         LD (IX+17),C
1217+ 55CA DD 70 12         LD (IX+18),B
1218+ 55CD              	; ending )
1219+ 55CD CD 43 6A     	CALL CHKCHAR
1220+ 55D0 29           	DB ')'
1221+ 55D1 C9               RET
1222+ 55D2              ; *******************************************************************************************************
1223+ 55D2               ENDIF
1224+ 55D2
1225+ 55D2               IF (DEFUSR_EXTENSION == 1)
1226+ 55D2              ; *******************************************************************************************************
1227+ 55D2              ; same as AUTOSGAMDEF but for DEFUSR approach
1228+ 55D2              ; input IX=pointer to input array, real data from +2
1229+ 55D2              ; +02 = ID
1230+ 55D2              ; +04 = pointer to X variable
1231+ 55D2              ; +06 = pointer to Y variable
1232+ 55D2              ; +08 = minimum
1233+ 55D2              ; +10 = maximum
1234+ 55D2              ; +12 = delta
1235+ 55D2              ; +14 = direction
1236+ 55D2              ; +16 = ticks
1237+ 55D2              ; +18 = sprite group count
1238+ 55D2              ; +20 = sprite group array pointer
1239+ 55D2              ; +22 = item number
1240+ 55D2              ; +24 = sprite animations negative direction array pointer
1241+ 55D2              ; +26 = sprite animations positive direction array pointer
1242+ 55D2              AUTOSGAMDEF_DEFUSR:
1243+ 55D2 DD 4E 02         LD C,(IX+2)
1244+ 55D5 0C               INC C
1245+ 55D6 3A 9D 4F         LD A,(AUTOSGAMNUM)
1246+ 55D9 B9               CP C
1247+ 55DA D8               RET C ; invalid id
1248+ 55DB 79               LD A,C
1249+ 55DC 3D               DEC A
1250+ 55DD CD CA 4F         CALL GETnthAUTOSGAM
1251+ 55E0 E5               PUSH HL
1252+ 55E1 FD E1            POP IY
1253+ 55E3                  ; X variable
1254+ 55E3 DD 7E 04         LD A,(IX+4)
1255+ 55E6 FD 77 00         LD (IY+0),A
1256+ 55E9 DD 7E 05         LD A,(IX+5)
1257+ 55EC FD 77 01         LD (IY+1),A
1258+ 55EF              	; Y variable
1259+ 55EF DD 7E 06         LD A,(IX+6)
1260+ 55F2 FD 77 02         LD (IY+2),A
1261+ 55F5 DD 7E 07         LD A,(IX+7)
1262+ 55F8 FD 77 03         LD (IY+3),A
1263+ 55FB              	; get minimum value
1264+ 55FB DD 7E 08         LD A,(IX+8)
1265+ 55FE FD 77 04         LD (IY+4),A
1266+ 5601 DD 7E 09         LD A,(IX+9)
1267+ 5604 FD 77 05         LD (IY+5),A
1268+ 5607              	; get maximum value
1269+ 5607 DD 7E 0A         LD A,(IX+10)
1270+ 560A FD 77 06         LD (IY+6),A
1271+ 560D DD 7E 0B         LD A,(IX+11)
1272+ 5610 FD 77 07         LD (IY+7),A
1273+ 5613              	; get delta value
1274+ 5613 DD 7E 0C         LD A,(IX+12)
1275+ 5616 FD 77 08         LD (IY+8),A
1276+ 5619 DD 7E 0D         LD A,(IX+13)
1277+ 561C FD 77 09         LD (IY+9),A
1278+ 561F              	; get direction value
1279+ 561F DD 7E 0E         LD A,(IX+14)
1280+ 5622 FD 77 0A         LD (IY+10),A
1281+ 5625              	; get ticks value
1282+ 5625 DD 7E 10         LD A,(IX+16)
1283+ 5628 FD 77 14         LD (IY+20),A
1284+ 562B DD 7E 11         LD A,(IX+17)
1285+ 562E FD 77 15         LD (IY+21),A
1286+ 5631              	; get sprite group count
1287+ 5631 DD 7E 12         LD A,(IX+18)
1288+ 5634 FD 77 0B         LD (IY+11),A
1289+ 5637              	; get sprite group definition array data pointer
1290+ 5637 DD 7E 14         LD A,(IX+20)
1291+ 563A FD 77 0C         LD (IY+12),A
1292+ 563D DD 7E 15         LD A,(IX+21)
1293+ 5640 FD 77 0D         LD (IY+13),A
1294+ 5643              	; get sprite animation array size
1295+ 5643 DD 7E 16         LD A,(IX+22)
1296+ 5646 FD 77 0E         LD (IY+14),A
1297+ 5649                  ; get array pointer for negative direction
1298+ 5649 DD 7E 18         LD A,(IX+24)
1299+ 564C FD 77 0F         LD (IY+15),A
1300+ 564F DD 7E 19         LD A,(IX+25)
1301+ 5652 FD 77 10         LD (IY+16),A
1302+ 5655                  ; get array pointer for positive direction
1303+ 5655 DD 7E 1A         LD A,(IX+26)
1304+ 5658 FD 77 11         LD (IY+17),A
1305+ 565B DD 7E 1B         LD A,(IX+27)
1306+ 565E FD 77 12         LD (IY+18),A
1307+ 5661              ; *******************************************************************************************************
1308+ 5661               ENDIF
1309+ 5661
1310+ 5661               IF (BASIC_EXTENSION == 1)
1311+ 5661              ; *******************************************************************************************************
1312+ 5661              ; function to handle CALL AUTOSGAMSTART basic extension
1313+ 5661              ; AUTOSGAMSTART ( BYTE id )
1314+ 5661              AUTOSGAMSTART:
1315+ 5661 3E 01            LD A,1
1316+ 5663              .COMMON:
1317+ 5663 32 8F 56         LD (.SETVALUE+3),A
1318+ 5666                  ; opening (
1319+ 5666 CD 43 6A     	CALL CHKCHAR
1320+ 5669 28           	DB '('
1321+ 566A              	; get sprite animation id
1322+ 566A DD 21 1C 52  	LD IX, GETBYT
1323+ 566E CD 59 01     	CALL CALBAS
1324+ 5671 F5               PUSH AF
1325+ 5672 3C               INC A
1326+ 5673 4F               LD C,A
1327+ 5674 3A 9D 4F         LD A,(AUTOSGAMNUM)
1328+ 5677 B9               CP C
1329+ 5678 DA 5B 6A         JP C,SUBSCRIPT_OUT_OF_RANGE
1330+ 567B F1               POP AF
1331+ 567C E5               PUSH HL
1332+ 567D CD CA 4F         CALL GETnthAUTOSGAM
1333+ 5680 E5               PUSH HL
1334+ 5681 DD E1            POP IX
1335+ 5683 E1               POP HL
1336+ 5684 DD E5            PUSH IX
1337+ 5686              	; ending )
1338+ 5686 CD 43 6A     	CALL CHKCHAR
1339+ 5689 29           	DB ')'
1340+ 568A
1341+ 568A                  ; so syntax is fine
1342+ 568A DD E1            POP IX
1343+ 568C              .SETVALUE:
1344+ 568C DD 36 13 01      LD (IX+19),1 ; active flag
1345+ 5690                  ; set initial timer
1346+ 5690 DD 7E 14         LD A,(IX+20)
1347+ 5693 DD 77 16         LD (IX+22),A
1348+ 5696 DD 7E 15         LD A,(IX+21)
1349+ 5699 DD 77 17         LD (IX+23),A
1350+ 569C C9               RET
1351+ 569D              ; *******************************************************************************************************
1352+ 569D
1353+ 569D              ; *******************************************************************************************************
1354+ 569D              ; function to handle CALL AUTOSGAMSTOP basic extension
1355+ 569D              ; AUTOSGAMSTOP ( BYTE id )
1356+ 569D              AUTOSGAMSTOP:
1357+ 569D AF               XOR A
1358+ 569E 18 C3            JR AUTOSGAMSTART.COMMON
1359+ 56A0              ; *******************************************************************************************************
1360+ 56A0               ENDIF
1361+ 56A0
1362+ 56A0               IF (DEFUSR_EXTENSION == 1)
1363+ 56A0              ; *******************************************************************************************************
1364+ 56A0              ; function to handle CALL AUTOSGAMSTART basic extension in DEFUSR mode
1365+ 56A0              ; input IX=pointer to input array, real data from +2
1366+ 56A0              ; +2 = source address
1367+ 56A0              AUTOSGAMSTART_DEFUSR:
1368+ 56A0 3E 01            LD A,1
1369+ 56A2              .COMMON:
1370+ 56A2 32 B9 56         LD (.SETVALUE+3),A
1371+ 56A5 DD 4E 02         LD C,(IX+2)
1372+ 56A8 0C               INC C
1373+ 56A9 3A 9D 4F         LD A,(AUTOSGAMNUM)
1374+ 56AC B9               CP C
1375+ 56AD D8               RET C ; invalid id
1376+ 56AE 79               LD A,C
1377+ 56AF 3D               DEC A
1378+ 56B0 CD CA 4F         CALL GETnthAUTOSGAM
1379+ 56B3 E5               PUSH HL
1380+ 56B4 DD E1            POP IX
1381+ 56B6              .SETVALUE:
1382+ 56B6 DD 36 13 01      LD (IX+19),1 ; active flag
1383+ 56BA                  ; set initial timer
1384+ 56BA DD 7E 14         LD A,(IX+20)
1385+ 56BD DD 77 16         LD (IX+22),A
1386+ 56C0 DD 7E 15         LD A,(IX+21)
1387+ 56C3 DD 77 17         LD (IX+23),A
1388+ 56C6 C9               RET
1389+ 56C7              ; *******************************************************************************************************
1390+ 56C7
1391+ 56C7              ; *******************************************************************************************************
1392+ 56C7              ; function to handle CALL AUTOSGAMSTOP basic extension in DEFUSR mode
1393+ 56C7              ; input IX=pointer to input array, real data from +2
1394+ 56C7              ; +2 = source address
1395+ 56C7              AUTOSGAMSTOP_DEFUSR:
1396+ 56C7 AF               XOR A
1397+ 56C8 18 D8            JR AUTOSGAMSTART_DEFUSR.COMMON
1398+ 56CA              ; *******************************************************************************************************
1399+ 56CA               ENDIF
1400+ 56CA
1401+ 56CA               IF (BASIC_EXTENSION == 1)
1402+ 56CA              ; *******************************************************************************************************
1403+ 56CA              ; function to handle CALL ANIMSTEP basic extension
1404+ 56CA              ; two forms
1405+ 56CA              ; ANIMSTEP ( BYTE id )
1406+ 56CA              ; or
1407+ 56CA              ; ANIMSTEP ( BYTE item_number,
1408+ 56CA              ;            INT[] sprite_animations )
1409+ 56CA              ANIMSTEP:
1410+ 56CA 11 49 57         LD DE,ANIMSTARTSTOP_COMMON.STEP
1411+ 56CD 18 08            JR ANIMSTARTSTOP_COMMON
1412+ 56CF              ; *******************************************************************************************************
1413+ 56CF              ; *******************************************************************************************************
1414+ 56CF              ; function to handle CALL ANIMSTART basic extension
1415+ 56CF              ; two forms
1416+ 56CF              ; ANIMSTART ( BYTE id )
1417+ 56CF              ; or
1418+ 56CF              ; ANIMSTART ( BYTE item_number,
1419+ 56CF              ;             INT[] sprite_animations )
1420+ 56CF              ; sets active flag to 1
1421+ 56CF              ANIMSTART:
1422+ 56CF 11 37 57         LD DE,ANIMSTARTSTOP_COMMON.START
1423+ 56D2 18 03            JR ANIMSTARTSTOP_COMMON
1424+ 56D4              ; *******************************************************************************************************
1425+ 56D4              ; *******************************************************************************************************
1426+ 56D4              ; function to handle CALL ANIMSTOP basic extension
1427+ 56D4              ; two forms
1428+ 56D4              ; ANIMSTOP ( BYTE id )
1429+ 56D4              ; or
1430+ 56D4              ; ANIMSTOP ( BYTE item_number,
1431+ 56D4              ;            INT[] sprite_animations )
1432+ 56D4              ; sets active flag to 0
1433+ 56D4              ANIMSTOP:
1434+ 56D4 11 44 57         LD DE,ANIMSTARTSTOP_COMMON.STOP
1435+ 56D7              ; *******************************************************************************************************
1436+ 56D7              ANIMSTARTSTOP_COMMON:
1437+ 56D7 ED 53 35 57      LD (ANIMSTARTSTOP_COMMON.FN+1),DE
1438+ 56DB                  ; opening (
1439+ 56DB CD 43 6A     	CALL CHKCHAR
1440+ 56DE 28           	DB '('
1441+ 56DF              	; get sprite animation id or array size
1442+ 56DF DD 21 1C 52  	LD IX,GETBYT
1443+ 56E3 CD 59 01     	CALL CALBAS
1444+ 56E6 F5               PUSH AF
1445+ 56E7                  ; check if comma present
1446+ 56E7 CD 4D 6A         CALL GETPREVCHAR
1447+ 56EA 23               INC HL
1448+ 56EB FE 2C            CP ','
1449+ 56ED 28 0E            JR Z,.L1
1450+ 56EF FE 29            CP ')'
1451+ 56F1 C2 67 6A         JP NZ,SYNTAX_ERROR
1452+ 56F4                  ; ok so single argument variant
1453+ 56F4 F1               POP AF
1454+ 56F5 E5               PUSH HL
1455+ 56F6 F3               DI
1456+ 56F7 CD 23 57         CALL .SETVALUE
1457+ 56FA FB               EI
1458+ 56FB E1               POP HL
1459+ 56FC C9               RET
1460+ 56FD              .L1:
1461+ 56FD                  ; get array pointer
1462+ 56FD D1               POP DE
1463+ 56FE D5               PUSH DE
1464+ 56FF 3E 02            LD A,2
1465+ 5701 06 01            LD B,1
1466+ 5703 CD 70 6A         CALL GET_BASIC_ARRAY_DATA_POINTER
1467+ 5706 C5               PUSH BC
1468+ 5707              	; ending )
1469+ 5707 CD 43 6A     	CALL CHKCHAR
1470+ 570A 29           	DB ')'
1471+ 570B D1               POP DE ; array pointer
1472+ 570C C1               POP BC ; number of items
1473+ 570D 78               LD A,B
1474+ 570E B7               OR A
1475+ 570F CA 5B 6A         JP Z,SUBSCRIPT_OUT_OF_RANGE
1476+ 5712 E5               PUSH HL
1477+ 5713 F3               DI
1478+ 5714              .L2:
1479+ 5714 C5               PUSH BC
1480+ 5715 1A               LD A,(DE)
1481+ 5716 13          > INC DE
1481+ 5717 13          > INC DE
1482+ 5718 D5               PUSH DE
1483+ 5719 CD 23 57         CALL .SETVALUE
1484+ 571C D1               POP DE
1485+ 571D C1               POP BC
1486+ 571E 10 F4            DJNZ .L2
1487+ 5720 FB               EI
1488+ 5721 E1               POP HL
1489+ 5722 C9               RET
1490+ 5723
1491+ 5723              .SETVALUE:
1492+ 5723 47               LD B,A
1493+ 5724 3C               INC A
1494+ 5725 4F               LD C,A
1495+ 5726 3A 9A 4F         LD A,(ANIMSPRNUM)
1496+ 5729 B9               CP C
1497+ 572A DA 5B 6A         JP C,SUBSCRIPT_OUT_OF_RANGE
1498+ 572D 78               LD A,B
1499+ 572E CD BE 4F         CALL GETnthSPRANIM
1500+ 5731 E5               PUSH HL
1501+ 5732 DD E1            POP IX
1502+ 5734              .FN:
1503+ 5734 C3 00 00         JP 0
1504+ 5737              .START:
1505+ 5737 DD 36 06 01      LD (IX+6),1 ; active flag
1506+ 573B DD 36 03 00      LD (IX+3),0 ; current item
1507+ 573F 06 00            LD B,0 ; setup timer
1508+ 5741 C3 30 58         JP SETUP_ANIM_STEP
1509+ 5744              .STOP:
1510+ 5744 DD 36 06 00      LD (IX+6),0 ; active flag
1511+ 5748 C9               RET
1512+ 5749              .STEP:
1513+ 5749 06 00            LD B,0
1514+ 574B C3 D4 57         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1515+ 574E              ; *******************************************************************************************************
1516+ 574E               ENDIF
1517+ 574E
1518+ 574E               IF (DEFUSR_EXTENSION == 1)
1519+ 574E              ; *******************************************************************************************************
1520+ 574E              ; helper function to locate single animation and execute operation
1521+ 574E              ; needs to have jump set to a correct function
1522+ 574E              ; input A=animation item
1523+ 574E              ANIM_SETVALUE:
1524+ 574E 47               LD B,A
1525+ 574F 3C               INC A
1526+ 5750 4F               LD C,A
1527+ 5751 3A 9A 4F         LD A,(ANIMSPRNUM)
1528+ 5754 B9               CP C
1529+ 5755 D8               RET C ; out of range, so do nothing
1530+ 5756 78               LD A,B
1531+ 5757 CD BE 4F         CALL GETnthSPRANIM
1532+ 575A E5               PUSH HL
1533+ 575B DD E1            POP IX
1534+ 575D              .FN:
1535+ 575D C3 00 00         JP 0
1536+ 5760              ; *******************************************************************************************************
1537+ 5760
1538+ 5760              ; *******************************************************************************************************
1539+ 5760              ; helper function to set values of multiple animations
1540+ 5760              ; needs to have jump set to a correct function
1541+ 5760              ; input B=number of animation item
1542+ 5760              ; input DE=animation item array
1543+ 5760              ANIM_LIST_SETVALUE:
1544+ 5760 F3               DI
1545+ 5761 C5               PUSH BC
1546+ 5762 1A               LD A,(DE)
1547+ 5763 13          > INC DE
1547+ 5764 13          > INC DE
1548+ 5765 D5               PUSH DE
1549+ 5766 CD 4E 57         CALL ANIM_SETVALUE
1550+ 5769 D1               POP DE
1551+ 576A C1               POP BC
1552+ 576B 10 F3            DJNZ ANIM_LIST_SETVALUE
1553+ 576D FB               EI
1554+ 576E C9               RET
1555+ 576F              ; *******************************************************************************************************
1556+ 576F
1557+ 576F              ; *******************************************************************************************************
1558+ 576F              ; function to handle single item ANIMSTEP in DEFUSR mode
1559+ 576F              ; input IX=pointer to input array, real data from +2
1560+ 576F              ; +2 = animation id
1561+ 576F              ANIMSTEP_SINGLE_DEFUSR:
1562+ 576F 21 7A 57         LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1563+ 5772              .L1:
1564+ 5772 22 5E 57         LD (ANIM_SETVALUE.FN+1),HL
1565+ 5775 DD 7E 02         LD A,(IX+2)
1566+ 5778 18 D4            JR ANIM_SETVALUE
1567+ 577A              .STEP:
1568+ 577A 06 00            LD B,0
1569+ 577C C3 D4 57         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1570+ 577F              ; *******************************************************************************************************
1571+ 577F
1572+ 577F              ; *******************************************************************************************************
1573+ 577F              ; function to handle multi item ANIMSTEP in DEFUSR mode
1574+ 577F              ; input IX=pointer to input array, real data from +2
1575+ 577F              ; +2 = list size
1576+ 577F              ; +4 = array pointer holding items
1577+ 577F              ANIMSTEP_MULTI_DEFUSR:
1578+ 577F 21 7A 57         LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1579+ 5782              .L1:
1580+ 5782 22 5E 57         LD (ANIM_SETVALUE.FN+1),HL
1581+ 5785 DD 46 02         LD B,(IX+2)
1582+ 5788 DD 5E 04         LD E,(IX+4)
1583+ 578B DD 56 05         LD D,(IX+5)
1584+ 578E 18 D0            JR ANIM_LIST_SETVALUE
1585+ 5790              ; *******************************************************************************************************
1586+ 5790
1587+ 5790              ; *******************************************************************************************************
1588+ 5790              ; function to handle single item ANIMSTART in DEFUSR mode
1589+ 5790              ; input IX=pointer to input array, real data from +2
1590+ 5790              ; +2 = animation id
1591+ 5790              ANIMSTART_SINGLE_DEFUSR:
1592+ 5790 21 95 57         LD HL,ANIMSTART_SINGLE_DEFUSR.START
1593+ 5793 18 DD            JR ANIMSTEP_SINGLE_DEFUSR.L1
1594+ 5795              .START:
1595+ 5795 DD 36 06 01      LD (IX+6),1 ; active flag
1596+ 5799 DD 36 03 00      LD (IX+3),0 ; current item
1597+ 579D 06 00            LD B,0 ; setup timer
1598+ 579F C3 30 58         JP SETUP_ANIM_STEP
1599+ 57A2              ; *******************************************************************************************************
1600+ 57A2
1601+ 57A2              ; *******************************************************************************************************
1602+ 57A2              ; function to handle multi item ANIMSTART in DEFUSR mode
1603+ 57A2              ; input IX=pointer to input array, real data from +2
1604+ 57A2              ; +2 = list size
1605+ 57A2              ; +4 = array pointer holding items
1606+ 57A2              ANIMSTART_MULTI_DEFUSR:
1607+ 57A2 21 95 57         LD HL,ANIMSTART_SINGLE_DEFUSR.START
1608+ 57A5 18 DB            JR ANIMSTEP_MULTI_DEFUSR.L1
1609+ 57A7              ; *******************************************************************************************************
1610+ 57A7
1611+ 57A7              ; *******************************************************************************************************
1612+ 57A7              ; function to handle single item ANIMSTOP in DEFUSR mode
1613+ 57A7              ; input IX=pointer to input array, real data from +2
1614+ 57A7              ; +2 = animation id
1615+ 57A7              ANIMSTOP_SINGLE_DEFUSR:
1616+ 57A7 21 AC 57         LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1617+ 57AA 18 C6            JR ANIMSTEP_SINGLE_DEFUSR.L1
1618+ 57AC              .STOP:
1619+ 57AC DD 36 06 00      LD (IX+6),0 ; active flag
1620+ 57B0 C9               RET
1621+ 57B1              ; *******************************************************************************************************
1622+ 57B1
1623+ 57B1              ; *******************************************************************************************************
1624+ 57B1              ; function to handle multi item ANIMSTOP in DEFUSR mode
1625+ 57B1              ; input IX=pointer to input array, real data from +2
1626+ 57B1              ; +2 = list size
1627+ 57B1              ; +4 = array pointer holding items
1628+ 57B1              ANIMSTOP_MULTI_DEFUSR:
1629+ 57B1 21 AC 57         LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1630+ 57B4 18 CC            JR ANIMSTEP_MULTI_DEFUSR.L1
1631+ 57B6              ; *******************************************************************************************************
1632+ 57B6               ENDIF
1633+ 57B6
1634+ 57B6              ; *******************************************************************************************************
1635+ 57B6              ; function processes animations during vblank period
1636+ 57B6              PROCESS_ANIMATIONS:
1637+ 57B6 3A 9A 4F         LD A,(ANIMSPRNUM)
1638+ 57B9 B7               OR A
1639+ 57BA C8               RET Z; no animations defined
1640+ 57BB 47               LD B,A
1641+ 57BC DD 2A 9B 4F      LD IX,(ANIMSPRPTR)
1642+ 57C0              .L1:
1643+ 57C0 C5               PUSH BC
1644+ 57C1 06 00            LD B,0 ; normal mode, change on timer expiry only
1645+ 57C3 CD CF 57         CALL PROCESS_SINGLE_ANIMATION
1646+ 57C6 11 08 00         LD DE,8
1647+ 57C9 DD 19            ADD IX,DE
1648+ 57CB C1               POP BC
1649+ 57CC 10 F2            DJNZ .L1
1650+ 57CE C9               RET
1651+ 57CF              ; *******************************************************************************************************
1652+ 57CF
1653+ 57CF              ; *******************************************************************************************************
1654+ 57CF              ; processes single sprite animation
1655+ 57CF              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
1656+ 57CF              ; on timer expiry goes to next animation item
1657+ 57CF              ; input IX=sprite animation pointer
1658+ 57CF              ; input B=1 force mode, activate animation action regardless of expired timer
1659+ 57CF              PROCESS_SINGLE_ANIMATION:
1660+ 57CF DD 7E 06         LD A,(IX+6); active
1661+ 57D2 B7               OR A
1662+ 57D3 C8               RET Z ; inactive animation
1663+ 57D4              .INACTIVE_TOO:
1664+ 57D4 DD 6E 01         LD L,(IX+1)
1665+ 57D7 DD 66 02         LD H,(IX+2) ; HL=end time
1666+ 57DA 2B               DEC HL
1667+ 57DB DD 75 01         LD (IX+1),L
1668+ 57DE DD 74 02         LD (IX+2),H
1669+ 57E1 7D               LD A,L
1670+ 57E2 B4               OR H
1671+ 57E3 28 06            JR Z,.STEP
1672+ 57E5 05               DEC B
1673+ 57E6 04               INC B
1674+ 57E7 C8               RET Z ; not forced mode, return
1675+ 57E8 C3 30 58         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
1676+ 57EB              .STEP:
1677+ 57EB 06 00            LD B,0; setup timer
1678+ 57ED DD 34 03         INC (IX+3) ; current animation item
1679+ 57F0 C3 30 58         JP SETUP_ANIM_STEP
1680+ 57F3              ; *******************************************************************************************************
1681+ 57F3
1682+ 57F3              ; *******************************************************************************************************
1683+ 57F3              ; function will setup sprite animation after current item change
1684+ 57F3              ; input A=current animation definition
1685+ 57F3              ; input IX=pointer to sprite animation
1686+ 57F3              ; input B=1 skip timer setup
1687+ 57F3              ; output IY=pointer to animation item
1688+ 57F3              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
1689+ 57F3              ; basically sets new end time for current animation
1690+ 57F3              INIT_CURRENT_ANIMATION:
1691+ 57F3 CD B2 4F         CALL GETnthANIMDEF
1692+ 57F6 DD 7E 03         LD A,(IX+3) ; current animation item
1693+ 57F9 BE               CP (HL) ; number of animation items in the animation definition
1694+ 57FA 38 0A            JR C,.L3 ; last item not reached
1695+ 57FC                  ; last item reached
1696+ 57FC DD 7E 05         LD A,(IX+5) ; cyclic flag
1697+ 57FF B7               OR A
1698+ 5800 28 2C            JR Z,.ERROR ; non-cyclic animation
1699+ 5802                  ; cyclic animation, restart
1700+ 5802 DD 36 03 00      LD (IX+3),0; current item
1701+ 5806              .L3:
1702+ 5806                  ; HL = animation definition
1703+ 5806 23               INC HL ; skip animation definition size field
1704+ 5807 16 00            LD D,0
1705+ 5809 DD 5E 03         LD E,(IX+3); current item
1706+ 580C 19               ADD HL,DE
1707+ 580D 4E               LD C,(HL) ; current animation item
1708+ 580E 0C               INC C
1709+ 580F 3A 94 4F         LD A,(ANIMITEMNUM)
1710+ 5812 B9               CP C
1711+ 5813 38 19            JR C,.ERROR ; invalid animation item, stop animation
1712+ 5815 0D               DEC C
1713+ 5816 79               LD A,C
1714+ 5817 CD A9 4F         CALL GETnthANIMITEM
1715+ 581A E5               PUSH HL
1716+ 581B FD E1            POP IY ; IY=animation item
1717+ 581D 05               DEC B
1718+ 581E 28 0C            JR Z,.EXIT
1719+ 5820 FD 5E 01         LD E,(IY+1)
1720+ 5823 FD 56 02         LD D,(IY+2) ; duration
1721+ 5826 DD 73 01         LD (IX+1),E
1722+ 5829 DD 72 02         LD (IX+2),D
1723+ 582C              .EXIT:
1724+ 582C AF               XOR A
1725+ 582D C9               RET
1726+ 582E              .ERROR:
1727+ 582E 37               SCF
1728+ 582F C9               RET
1729+ 5830              ; *******************************************************************************************************
1730+ 5830
1731+ 5830              ; *******************************************************************************************************
1732+ 5830              ; function will display currect item and set up expiry time
1733+ 5830              ; it will also stop the animation if expired
1734+ 5830              ; sets sprite update flag if any changes in sprite data made
1735+ 5830              ; input IX=current sprite animation
1736+ 5830              ; input B=1 skip timer setup
1737+ 5830              SETUP_ANIM_STEP:
1738+ 5830 DD 4E 04         LD C,(IX+4) ; animation definition ID
1739+ 5833 0C               INC C
1740+ 5834 3A 97 4F         LD A,(ANIMDEFNUM)
1741+ 5837 B9               CP C
1742+ 5838 30 05            JR NC,.L2
1743+ 583A                  ; given animation item is outside of bounds, deactivate animation
1744+ 583A              .STOPANIM:
1745+ 583A DD 36 06 00      LD (IX+6),0
1746+ 583E C9               RET
1747+ 583F              .L2:
1748+ 583F 0D               DEC C
1749+ 5840 79               LD A,C
1750+ 5841 CD F3 57         CALL INIT_CURRENT_ANIMATION
1751+ 5844 38 F4            JR C, .STOPANIM
1752+ 5846 FD 7E 00         LD A,(IY) ; type of animation item
1753+ 5849 B7               OR A
1754+ 584A 28 44            JR Z,.L4 ; change pattern and/or color
1755+ 584C              .PAT:
1756+ 584C                  ; change pattern definition
1757+ 584C                  ; check if sprite or character
1758+ 584C DD 7E 07         LD A,(IX+7)
1759+ 584F B7               OR A
1760+ 5850 20 58            JR NZ,.CHAR
1761+ 5852 DD 7E 00         LD A,(IX) ; sprite number
1762+ 5855 CD 89 4D         CALL GETnthSPRATTR
1763+ 5858 23          > INC HL ; skip y and x
1763+ 5859 23          > INC HL
1763+ 585A 23          > INC HL
1763+ 585B 23          > INC HL
1764+ 585C 7E               LD A,(HL); current pattern
1765+ 585D 26 00            LD H,0
1766+ 585F 6F               LD L,A
1767+ 5860 3A E0 F3         LD A,(REG1SAV)
1768+ 5863 E6 02            AND 2
1769+ 5865 20 07            JR NZ,.L6
1770+ 5867                  ; 8x8 sprite
1771+ 5867 CD 31 69         CALL HLx8
1772+ 586A 06 08            LD B,8
1773+ 586C 18 05            JR .L5
1774+ 586E              .L6:
1775+ 586E CD 2F 69         CALL HLx32
1776+ 5871 06 20            LD B,32
1777+ 5873              .L5:
1778+ 5873 3A AF FC         LD A,(SCRMOD)
1779+ 5876 3D               DEC A
1780+ 5877 20 06            JR NZ,.L10
1781+ 5879 ED 5B C5 F3      LD DE,(T32PAT)
1782+ 587D 18 04            JR .L7
1783+ 587F              .L10:
1784+ 587F ED 5B CF F3      LD DE,(GRPPAT)
1785+ 5883              .L7:
1786+ 5883 19               ADD HL,DE
1787+ 5884 CD 1C 69         CALL SETWRT_LOCAL
1788+ 5887 FD 6E 03         LD L,(IY+3)
1789+ 588A FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
1790+ 588D C3 27 69         JP BBYTECOPY
1791+ 5890              .L4:
1792+ 5890                  ; change pattern and color in sprite attributes table
1793+ 5890 DD 7E 00         LD A,(IX) ; sprite number
1794+ 5893 CD 89 4D         CALL GETnthSPRATTR
1795+ 5896 23          > INC HL ; skip y and x
1795+ 5897 23          > INC HL
1795+ 5898 23          > INC HL
1795+ 5899 23          > INC HL
1796+ 589A FD 7E 03         LD A,(IY+3) ; new pattern
1797+ 589D 77               LD (HL),A
1798+ 589E 23          > INC HL
1798+ 589F 23          > INC HL
1799+ 58A0 FD 7E 04         LD A,(IY+4) ; new color
1800+ 58A3 77               LD (HL),A
1801+ 58A4 2A 80 4D         LD HL,(SPRATR_UPDATE_FLAG)
1802+ 58A7 36 01            LD (HL),1
1803+ 58A9 C9               RET
1804+ 58AA              .CHAR:
1805+ 58AA DD 6E 00         LD L,(IX)
1806+ 58AD 3D               DEC A
1807+ 58AE 67               LD H,A
1808+ 58AF CD 31 69         CALL HLx8
1809+ 58B2 3A AF FC         LD A,(SCRMOD)
1810+ 58B5 3D               DEC A
1811+ 58B6 20 06            JR NZ,.L8
1812+ 58B8 ED 5B C1 F3      LD DE,(T32CGP)
1813+ 58BC 18 04            JR .L9
1814+ 58BE              .L8:
1815+ 58BE ED 5B CB F3      LD DE,(GRPCGP)
1816+ 58C2              .L9:
1817+ 58C2 06 08            LD B,8
1818+ 58C4 18 BD            JR .L7
1819+ 58C6              ; *******************************************************************************************************
1820+ 58C6
# file closed: asm\ANIMATION.asm
 132  58C6               INCLUDE "SGAM.asm"
# file opened: asm\SGAM.asm
   1+ 58C6              ; Sprite Group Animate and Move
   2+ 58C6
   3+ 58C6              ; *******************************************************************************************************
   4+ 58C6              ; shared function to process a list of animations
   5+ 58C6              ; input B=list size
   6+ 58C6              ; input DE=list pointer
   7+ 58C6              SGAM_PROCESS_ANIM_LIST:
   8+ 58C6 21 D9 58         LD HL,.STEP
   9+ 58C9 22 35 57         LD (ANIMSTARTSTOP_COMMON.FN+1),HL
  10+ 58CC              .L1:
  11+ 58CC C5               PUSH BC
  12+ 58CD 1A               LD A,(DE)
  13+ 58CE 13          > INC DE
  13+ 58CF 13          > INC DE
  14+ 58D0 D5               PUSH DE
  15+ 58D1 CD 23 57         CALL ANIMSTARTSTOP_COMMON.SETVALUE
  16+ 58D4 D1               POP DE
  17+ 58D5 C1               POP BC
  18+ 58D6 10 F4            DJNZ .L1
  19+ 58D8 C9           	RET
  20+ 58D9              .STEP:
  21+ 58D9 06 01            LD B,1
  22+ 58DB C3 D4 57         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
  23+ 58DE              ; *******************************************************************************************************
  24+ 58DE
  25+ 58DE               IF (BASIC_EXTENSION == 1)
  26+ 58DE              ; *******************************************************************************************************
  27+ 58DE              ; function to handle CALL SGAM basic extension
  28+ 58DE              ; sets position of a group of sprites as described in SPRGRPMOV
  29+ 58DE              ; and manually animate a list of animations
  30+ 58DE              ; _SGAM ( INT x,
  31+ 58DE              ;	      INT y,
  32+ 58DE              ;		  BYTE count,
  33+ 58DE              ;		  INT[2][count] data_ptr,
  34+ 58DE              ;         BYTE item_number,
  35+ 58DE              ;         INT[] sprite_animations )
  36+ 58DE              ; will put ram in page 0 also, page 1 is already there
  37+ 58DE              SGAM:
  38+ 58DE 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
  39+ 58E1 B7           	OR A
  40+ 58E2 CA 63 6A     	JP Z,ILLEGAL_FUNCTION
  41+ 58E5              	; opening (
  42+ 58E5 CD 43 6A     	CALL CHKCHAR
  43+ 58E8 28           	DB '('
  44+ 58E9              	; get x
  45+ 58E9 DD 21 2F 54  	LD IX, FRMQNT
  46+ 58ED CD 59 01     	CALL CALBAS
  47+ 58F0 ED 53 34 67  	LD (BLIT_STRUCT),DE
  48+ 58F4              	; comma
  49+ 58F4 CD 43 6A     	CALL CHKCHAR
  50+ 58F7 2C           	DB ','
  51+ 58F8              	; get y
  52+ 58F8 DD 21 2F 54  	LD IX, FRMQNT
  53+ 58FC CD 59 01     	CALL CALBAS
  54+ 58FF ED 53 36 67  	LD (BLIT_STRUCT+2),DE
  55+ 5903              	; comma
  56+ 5903 CD 43 6A     	CALL CHKCHAR
  57+ 5906 2C           	DB ','
  58+ 5907              	; get count
  59+ 5907 DD 21 1C 52  	LD IX, GETBYT
  60+ 590B CD 59 01     	CALL CALBAS
  61+ 590E B7               OR A
  62+ 590F CA 5B 6A         JP Z,SUBSCRIPT_OUT_OF_RANGE
  63+ 5912 32 38 67     	LD (BLIT_STRUCT+4),A
  64+ 5915              	; comma
  65+ 5915 CD 43 6A     	CALL CHKCHAR
  66+ 5918 2C           	DB ','
  67+ 5919              	; get sprite group definition array data pointer
  68+ 5919 3A 38 67         LD A,(BLIT_STRUCT+4)
  69+ 591C 5F           	LD E,A
  70+ 591D 16 03        	LD D,3
  71+ 591F 3E 02        	LD A,2
  72+ 5921 47           	LD B,A
  73+ 5922 CD 70 6A     	CALL GET_BASIC_ARRAY_DATA_POINTER
  74+ 5925 ED 43 39 67  	LD (BLIT_STRUCT+5),BC
  75+ 5929              	; comma
  76+ 5929 CD 43 6A     	CALL CHKCHAR
  77+ 592C 2C           	DB ','
  78+ 592D              	; get sprite animation array size
  79+ 592D DD 21 1C 52  	LD IX,GETBYT
  80+ 5931 CD 59 01     	CALL CALBAS
  81+ 5934 32 3B 67         LD (BLIT_STRUCT+7),A
  82+ 5937 B7               OR A
  83+ 5938 CA 5B 6A         JP Z,SUBSCRIPT_OUT_OF_RANGE
  84+ 593B              	; comma
  85+ 593B CD 43 6A     	CALL CHKCHAR
  86+ 593E 2C           	DB ','
  87+ 593F                  ; get array pointer
  88+ 593F 3A 3B 67         LD A,(BLIT_STRUCT+7)
  89+ 5942 57               LD D,A
  90+ 5943 3E 02            LD A,2
  91+ 5945 06 01            LD B,1
  92+ 5947 CD 70 6A         CALL GET_BASIC_ARRAY_DATA_POINTER
  93+ 594A ED 43 3C 67      LD (BLIT_STRUCT+8),BC
  94+ 594E              	; ending )
  95+ 594E CD 43 6A     	CALL CHKCHAR
  96+ 5951 29           	DB ')'
  97+ 5952              .ENTRY:
  98+ 5952 E5               PUSH HL
  99+ 5953 F3               DI
 100+ 5954
 101+ 5954              	; enable page 0
 102+ 5954 FD 21 5B 59  	LD IY, .RET
 103+ 5958 C3 F5 69     	JP ENABLE_PAGE0
 104+ 595B              .RET:
 105+ 595B D9               EXX
 106+ 595C ED 5B 34 67      LD DE,(BLIT_STRUCT) ; initial x
 107+ 5960 ED 4B 36 67      LD BC,(BLIT_STRUCT+2) ; initial y
 108+ 5964 D9               EXX
 109+ 5965 2A 39 67         LD HL,(BLIT_STRUCT+5) ; pointer to data
 110+ 5968 3A 38 67         LD A,(BLIT_STRUCT+4) ; number of entries
 111+ 596B 47               LD B,A
 112+ 596C CD FD 4E         CALL SPR_UPDATE_LOC
 113+ 596F
 114+ 596F 3A 3B 67         LD A,(BLIT_STRUCT+7) ; anim number
 115+ 5972 47               LD B,A
 116+ 5973 ED 5B 3C 67      LD DE,(BLIT_STRUCT+8) ; anim list
 117+ 5977 CD C6 58     	CALL SGAM_PROCESS_ANIM_LIST
 118+ 597A
 119+ 597A D1               POP DE
 120+ 597B C1               POP BC
 121+ 597C CD 6C 69         CALL RESTORE_PAGE_INFO
 122+ 597F FB               EI
 123+ 5980 E1               POP HL
 124+ 5981 C9               RET
 125+ 5982              ; *******************************************************************************************************
 126+ 5982               ENDIF
 127+ 5982
 128+ 5982               IF (DEFUSR_EXTENSION == 1)
 129+ 5982              ; *******************************************************************************************************
 130+ 5982              ; same as SGAM but for DEFUSR approach
 131+ 5982              ; input IX=pointer to input array, real data from +2
 132+ 5982              ; +02 = X
 133+ 5982              ; +04 = Y
 134+ 5982              ; +06 = count
 135+ 5982              ; +08 = data pointer
 136+ 5982              ; +10 = anim number
 137+ 5982              ; +12 = sprite animations
 138+ 5982              SGAM_DEFUSR:
 139+ 5982              	; enable page 0
 140+ 5982 F3           	DI
 141+ 5983 FD 21 8A 59  	LD IY, .RET
 142+ 5987 C3 F5 69     	JP ENABLE_PAGE0
 143+ 598A              .RET:
 144+ 598A FB           	EI
 145+ 598B D9               EXX
 146+ 598C DD 5E 02     	LD E,(IX+2)
 147+ 598F DD 56 03     	LD D,(IX+3) ; initial x
 148+ 5992 DD 4E 04     	LD C,(IX+4)
 149+ 5995 DD 46 05     	LD B,(IX+5) ; initial y
 150+ 5998 D9               EXX
 151+ 5999 DD 6E 08     	LD L,(IX+8)
 152+ 599C DD 66 09     	LD H,(IX+9) ; pointer to data
 153+ 599F DD 46 06         LD B,(IX+6) ; count
 154+ 59A2 DD E5        	PUSH IX
 155+ 59A4 CD FD 4E         CALL SPR_UPDATE_LOC
 156+ 59A7 DD E1        	POP IX
 157+ 59A9 DD 46 0A         LD B,(IX+10) ; anim number
 158+ 59AC DD 5E 0C     	LD E,(IX+12)
 159+ 59AF DD 56 0D     	LD D,(IX+13)
 160+ 59B2 CD C6 58     	CALL SGAM_PROCESS_ANIM_LIST
 161+ 59B5
 162+ 59B5 D1               POP DE
 163+ 59B6 C1               POP BC
 164+ 59B7 C3 6C 69         JP RESTORE_PAGE_INFO
 165+ 59BA              ; *******************************************************************************************************
 166+ 59BA               ENDIF
 167+ 59BA
 168+ 59BA              ; *******************************************************************************************************
 169+ 59BA              ; handles automatic move and animate sprite groups during interrupt
 170+ 59BA              PROCESS_AUTOSGAMS:
 171+ 59BA 3A 9D 4F     	LD A,(AUTOSGAMNUM)
 172+ 59BD B7           	OR A
 173+ 59BE C8           	RET Z
 174+ 59BF 47           	LD B,A
 175+ 59C0 DD 2A 9E 4F  	LD IX,(AUTOSGAMPTR)
 176+ 59C4              .L1:
 177+ 59C4 C5           	PUSH BC
 178+ 59C5 DD 7E 13     	LD A,(IX+19) ; active flag
 179+ 59C8 B7           	OR A
 180+ 59C9 28 28        	JR Z,.LOOPEND
 181+ 59CB              	; active, check timer
 182+ 59CB DD 6E 16     	LD L,(IX+22)
 183+ 59CE DD 66 17     	LD H,(IX+23) ; timer
 184+ 59D1 2B           	DEC HL
 185+ 59D2 7C           	LD A,H
 186+ 59D3 B5           	OR L
 187+ 59D4 28 08        	JR Z,.L2
 188+ 59D6              	; not expired
 189+ 59D6 DD 75 16     	LD (IX+22),L
 190+ 59D9 DD 74 17     	LD (IX+23),H
 191+ 59DC 18 15        	JR .LOOPEND
 192+ 59DE              .L2:
 193+ 59DE              	; expired, process
 194+ 59DE
 195+ 59DE                  ; set initial timer
 196+ 59DE DD 7E 14         LD A,(IX+20)
 197+ 59E1 DD 77 16         LD (IX+22),A
 198+ 59E4 DD 7E 15         LD A,(IX+21)
 199+ 59E7 DD 77 17         LD (IX+23),A
 200+ 59EA
 201+ 59EA CD FC 59     	CALL .MOVE
 202+ 59ED CD 67 5A     	CALL .UPDATELOC
 203+ 59F0 CD 8C 5A     	CALL .PROCESS_ANIM_LIST
 204+ 59F3
 205+ 59F3              .LOOPEND:
 206+ 59F3 11 18 00     	LD DE,24
 207+ 59F6 DD 19        	ADD IX,DE
 208+ 59F8 C1           	POP BC
 209+ 59F9 10 C9        	DJNZ .L1
 210+ 59FB C9           	RET
 211+ 59FC
 212+ 59FC              .MOVE:
 213+ 59FC              	; process movement
 214+ 59FC DD 7E 0A     	LD A,(IX+10) ; direction
 215+ 59FF B7           	OR A
 216+ 5A00 28 08        	JR Z, .MOVE_L1
 217+ 5A02              	; vertical
 218+ 5A02 DD 6E 02     	LD L,(IX+2)
 219+ 5A05 DD 66 03     	LD H,(IX+3) ; vertical variable pointer
 220+ 5A08 18 06        	JR .MOVE_L2
 221+ 5A0A              .MOVE_L1:
 222+ 5A0A              	; horizontal
 223+ 5A0A DD 6E 00     	LD L,(IX+0)
 224+ 5A0D DD 66 01     	LD H,(IX+1) ; horizontal variable pointer
 225+ 5A10              .MOVE_L2:
 226+ 5A10 E5           	PUSH HL
 227+ 5A11 FD E1        	POP IY
 228+ 5A13 FD 6E 00     	LD L,(IY+0)
 229+ 5A16 FD 66 01     	LD H,(IY+1)
 230+ 5A19 DD 5E 08     	LD E,(IX+8)
 231+ 5A1C DD 56 09     	LD D,(IX+9) ; delta value
 232+ 5A1F 19           	ADD HL,DE
 233+ 5A20 E5           	PUSH HL
 234+ 5A21 DD 5E 04     	LD E,(IX+4)
 235+ 5A24 DD 56 05     	LD D,(IX+5) ; minimum value
 236+ 5A27 A7           	AND A
 237+ 5A28 ED 52        	SBC HL,DE
 238+ 5A2A FA 44 5A     	JP M,.MOVE_L3 ; below minimum
 239+ 5A2D E1           	POP HL
 240+ 5A2E E5           	PUSH HL
 241+ 5A2F DD 5E 06     	LD E,(IX+6)
 242+ 5A32 DD 56 07     	LD D,(IX+7) ; maximum value
 243+ 5A35 EB           	EX DE,HL
 244+ 5A36 A7           	AND A
 245+ 5A37 ED 52        	SBC HL,DE
 246+ 5A39 FA 4C 5A     	JP M,.MOVE_L4 ; above maximum
 247+ 5A3C E1           	POP HL
 248+ 5A3D              	; within bounds
 249+ 5A3D              .MOVE_L5:
 250+ 5A3D FD 75 00     	LD (IY+0),L
 251+ 5A40 FD 74 01     	LD (IY+1),H
 252+ 5A43 C9           	RET
 253+ 5A44              .MOVE_L3:
 254+ 5A44 E1           	POP HL
 255+ 5A45 CD 58 5A     	CALL .INVERSE_DELTA
 256+ 5A48 6B           	LD L,E
 257+ 5A49 62           	LD H,D
 258+ 5A4A 18 F1        	JR .MOVE_L5
 259+ 5A4C              .MOVE_L4:
 260+ 5A4C E1           	POP HL
 261+ 5A4D CD 58 5A     	CALL .INVERSE_DELTA
 262+ 5A50 DD 6E 06     	LD L,(IX+6)
 263+ 5A53 DD 66 07     	LD H,(IX+7) ; maximum
 264+ 5A56 18 E5        	JR .MOVE_L5
 265+ 5A58              .INVERSE_DELTA:
 266+ 5A58 AF           	XOR A
 267+ 5A59 DD 96 08     	SUB (IX+8)
 268+ 5A5C DD 77 08     	LD (IX+8),A
 269+ 5A5F 9F           	SBC A,A
 270+ 5A60 DD 96 09     	SUB (IX+9)
 271+ 5A63 DD 77 09     	LD (IX+9),A
 272+ 5A66 C9           	RET
 273+ 5A67
 274+ 5A67              .UPDATELOC:
 275+ 5A67 DD E5        	PUSH IX
 276+ 5A69 D9           	EXX
 277+ 5A6A DD 6E 00     	LD L,(IX+0)
 278+ 5A6D DD 66 01     	LD H,(IX+1)
 279+ 5A70 5E           	LD E,(HL)
 280+ 5A71 23           	INC HL
 281+ 5A72 56           	LD D,(HL)
 282+ 5A73 DD 6E 02     	LD L,(IX+2)
 283+ 5A76 DD 66 03     	LD H,(IX+3)
 284+ 5A79 4E           	LD C,(HL)
 285+ 5A7A 23           	INC HL
 286+ 5A7B 46           	LD B,(HL)
 287+ 5A7C D9           	EXX
 288+ 5A7D DD 6E 0C     	LD L,(IX+12)
 289+ 5A80 DD 66 0D     	LD H,(IX+13) ; pointer to sprite group data
 290+ 5A83 DD 46 0B     	LD B,(IX+11) ; sprite group size
 291+ 5A86 CD FD 4E     	CALL SPR_UPDATE_LOC
 292+ 5A89 DD E1        	POP IX
 293+ 5A8B C9           	RET
 294+ 5A8C
 295+ 5A8C              .PROCESS_ANIM_LIST:
 296+ 5A8C DD E5        	PUSH IX
 297+ 5A8E DD 46 0E         LD B,(IX+14) ; anim list size
 298+ 5A91 DD CB 09 7E  	BIT 7,(IX+9)
 299+ 5A95 28 08        	JR Z,.PROCESS_ANIM_LIST_L1
 300+ 5A97              	; negative direction
 301+ 5A97 DD 5E 0F     	LD E,(IX+15)
 302+ 5A9A DD 56 10     	LD D,(IX+16)
 303+ 5A9D 18 06        	JR .PROCESS_ANIM_LIST_L2
 304+ 5A9F              .PROCESS_ANIM_LIST_L1:
 305+ 5A9F              	; positive direction
 306+ 5A9F DD 5E 11     	LD E,(IX+17)
 307+ 5AA2 DD 56 12     	LD D,(IX+18)
 308+ 5AA5              .PROCESS_ANIM_LIST_L2:
 309+ 5AA5 CD C6 58     	CALL SGAM_PROCESS_ANIM_LIST
 310+ 5AA8 DD E1        	POP IX
 311+ 5AAA C9           	RET
 312+ 5AAB              ; *******************************************************************************************************
 313+ 5AAB
# file closed: asm\SGAM.asm
 133  5AAB               ENDIF
 134  5AAB
 135  5AAB               IF (RAM_CMDS == 1)
 136  5AAB               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
   1+ 5AAB               IF (BASIC_EXTENSION == 1)
   2+ 5AAB              ; *******************************************************************************************************
   3+ 5AAB              ; function to handle CALL MEMCPY basic extension
   4+ 5AAB              ; _MEMCPY ( INT source,
   5+ 5AAB              ;			INT destination,
   6+ 5AAB              ;			INT count,
   7+ 5AAB              ; will put ram in page 0 also, page 1 is already there
   8+ 5AAB              MEMCPY:
   9+ 5AAB              	; opening (
  10+ 5AAB CD 43 6A     	CALL CHKCHAR
  11+ 5AAE 28           	DB '('
  12+ 5AAF              	; get source address
  13+ 5AAF DD 21 2F 54  	LD IX, FRMQNT
  14+ 5AB3 CD 59 01     	CALL CALBAS
  15+ 5AB6 D5           	PUSH DE
  16+ 5AB7              	; comma
  17+ 5AB7 CD 43 6A     	CALL CHKCHAR
  18+ 5ABA 2C           	DB ','
  19+ 5ABB              	; get destination address
  20+ 5ABB DD 21 2F 54  	LD IX, FRMQNT
  21+ 5ABF CD 59 01     	CALL CALBAS
  22+ 5AC2 D5           	PUSH DE
  23+ 5AC3              	; comma
  24+ 5AC3 CD 43 6A     	CALL CHKCHAR
  25+ 5AC6 2C           	DB ','
  26+ 5AC7              	; get length
  27+ 5AC7 DD 21 2F 54  	LD IX, FRMQNT
  28+ 5ACB CD 59 01     	CALL CALBAS
  29+ 5ACE D5           	PUSH DE
  30+ 5ACF              	; ending )
  31+ 5ACF CD 43 6A     	CALL CHKCHAR
  32+ 5AD2 29           	DB ')'
  33+ 5AD3
  34+ 5AD3              	; save position
  35+ 5AD3 E5           	PUSH HL
  36+ 5AD4 DD E1        	POP IX
  37+ 5AD6
  38+ 5AD6 C1           	POP BC ; count
  39+ 5AD7 D1           	POP DE ; destination
  40+ 5AD8 E1           	POP HL ; source
  41+ 5AD9 D9           	EXX
  42+ 5ADA              	; enable page 0
  43+ 5ADA F3           	DI
  44+ 5ADB FD 21 E2 5A  	LD IY, .RET
  45+ 5ADF C3 F5 69     	JP ENABLE_PAGE0
  46+ 5AE2              .RET:
  47+ 5AE2 FB           	EI
  48+ 5AE3 D9           	EXX
  49+ 5AE4 ED B0        	LDIR
  50+ 5AE6 D1               POP DE
  51+ 5AE7 C1               POP BC
  52+ 5AE8 CD 6C 69         CALL RESTORE_PAGE_INFO
  53+ 5AEB DD E5        	PUSH IX
  54+ 5AED E1           	POP HL
  55+ 5AEE C9           	RET
  56+ 5AEF              ; *******************************************************************************************************
  57+ 5AEF               ENDIF
  58+ 5AEF
  59+ 5AEF               IF (DEFUSR_EXTENSION == 1)
  60+ 5AEF              ; *******************************************************************************************************
  61+ 5AEF              ; same as MEMCPY but for DEFUSR approach
  62+ 5AEF              ; input IX=pointer to input array, real data from +2
  63+ 5AEF              ; +2 = source address
  64+ 5AEF              ; +4 = destination address
  65+ 5AEF              ; +6 = lenght
  66+ 5AEF              MEMCPY_DEFUSR:
  67+ 5AEF              	; enable page 0
  68+ 5AEF F3           	DI
  69+ 5AF0 FD 21 F7 5A  	LD IY, .RET
  70+ 5AF4 C3 F5 69     	JP ENABLE_PAGE0
  71+ 5AF7              .RET:
  72+ 5AF7 FB           	EI
  73+ 5AF8 DD 6E 02     	LD L,(IX+2)
  74+ 5AFB DD 66 03     	LD H,(IX+3)
  75+ 5AFE DD 5E 04     	LD E,(IX+4)
  76+ 5B01 DD 56 05     	LD D,(IX+5)
  77+ 5B04 DD 4E 06     	LD C,(IX+6)
  78+ 5B07 DD 46 07     	LD B,(IX+7)
  79+ 5B0A ED B0        	LDIR
  80+ 5B0C D1               POP DE
  81+ 5B0D C1               POP BC
  82+ 5B0E C3 6C 69         JP RESTORE_PAGE_INFO
  83+ 5B11              ; *******************************************************************************************************
  84+ 5B11               ENDIF
  85+ 5B11
  86+ 5B11               IF (BASIC_EXTENSION == 1)
  87+ 5B11              ; *******************************************************************************************************
  88+ 5B11              ; function to handle CALL FILRAM basic extension
  89+ 5B11              ; FILRAM ( INT start address,
  90+ 5B11              ;		   INT count,
  91+ 5B11              ;		   BYTE value )
  92+ 5B11              ; will put ram in page 0 also, page 1 is already there
  93+ 5B11              FILRAM:
  94+ 5B11              	; opening (
  95+ 5B11 CD 43 6A     	CALL CHKCHAR
  96+ 5B14 28           	DB '('
  97+ 5B15              	; get start address
  98+ 5B15 DD 21 2F 54  	LD IX, FRMQNT
  99+ 5B19 CD 59 01     	CALL CALBAS
 100+ 5B1C D5           	PUSH DE
 101+ 5B1D              	; comma
 102+ 5B1D CD 43 6A     	CALL CHKCHAR
 103+ 5B20 2C           	DB ','
 104+ 5B21              	; get count
 105+ 5B21 DD 21 2F 54  	LD IX, FRMQNT
 106+ 5B25 CD 59 01     	CALL CALBAS
 107+ 5B28 D5           	PUSH DE
 108+ 5B29              	; comma
 109+ 5B29 CD 43 6A     	CALL CHKCHAR
 110+ 5B2C 2C           	DB ','
 111+ 5B2D              	; get value
 112+ 5B2D DD 21 1C 52  	LD IX, GETBYT
 113+ 5B31 CD 59 01     	CALL CALBAS
 114+ 5B34 F5           	PUSH AF
 115+ 5B35              	; ending )
 116+ 5B35 CD 43 6A     	CALL CHKCHAR
 117+ 5B38 29           	DB ')'
 118+ 5B39
 119+ 5B39              	; save position
 120+ 5B39 E5           	PUSH HL
 121+ 5B3A DD E1        	POP IX
 122+ 5B3C
 123+ 5B3C D1           	POP DE ; actually AF
 124+ 5B3D C1           	POP BC ; count
 125+ 5B3E E1           	POP HL ; start address
 126+ 5B3F 78           	LD A, B
 127+ 5B40 B1           	OR C
 128+ 5B41 28 13        	JR Z, .EXIT ; 0 bytes to fill, skip
 129+ 5B43 D9           	EXX
 130+ 5B44              	; enable page 0
 131+ 5B44 F3           	DI
 132+ 5B45 FD 21 4C 5B  	LD IY, .RET
 133+ 5B49 C3 F5 69     	JP ENABLE_PAGE0
 134+ 5B4C              .RET:
 135+ 5B4C FB           	EI
 136+ 5B4D D9           	EXX
 137+ 5B4E CD 7E 5B     	CALL FILVRM_FILLVALUE
 138+ 5B51 D1               POP DE
 139+ 5B52 C1               POP BC
 140+ 5B53 CD 6C 69         CALL RESTORE_PAGE_INFO
 141+ 5B56              .EXIT:
 142+ 5B56 DD E5        	PUSH IX
 143+ 5B58 E1           	POP HL
 144+ 5B59 C9           	RET
 145+ 5B5A              ; *******************************************************************************************************
 146+ 5B5A               ENDIF
 147+ 5B5A
 148+ 5B5A               IF (DEFUSR_EXTENSION == 1)
 149+ 5B5A              ; *******************************************************************************************************
 150+ 5B5A              ; same as FILVRM but for DEFUSR approach
 151+ 5B5A              ; input IX=pointer to input array, real data from +2
 152+ 5B5A              ; +2 = start address
 153+ 5B5A              ; +4 = count
 154+ 5B5A              ; +6 = value
 155+ 5B5A              FILRAM_DEFUSR:
 156+ 5B5A              	; enable page 0
 157+ 5B5A F3           	DI
 158+ 5B5B FD 21 62 5B  	LD IY, .RET
 159+ 5B5F C3 F5 69     	JP ENABLE_PAGE0
 160+ 5B62              .RET:
 161+ 5B62 FB           	EI
 162+ 5B63 DD 6E 02     	LD L,(IX+2)
 163+ 5B66 DD 66 03     	LD H,(IX+3)
 164+ 5B69 DD 4E 04     	LD C,(IX+4)
 165+ 5B6C DD 46 05     	LD B,(IX+5)
 166+ 5B6F 78           	LD A,B
 167+ 5B70 B1           	OR C
 168+ 5B71 28 06        	JR Z,.EXIT
 169+ 5B73 DD 56 06     	LD D,(IX+6)
 170+ 5B76 CD 7E 5B     	CALL FILVRM_FILLVALUE
 171+ 5B79              .EXIT:
 172+ 5B79 D1               POP DE
 173+ 5B7A C1               POP BC
 174+ 5B7B C3 6C 69         JP RESTORE_PAGE_INFO
 175+ 5B7E              ; *******************************************************************************************************
 176+ 5B7E               ENDIF
 177+ 5B7E
 178+ 5B7E              ; *******************************************************************************************************
 179+ 5B7E              ; common function to fill RAM
 180+ 5B7E              FILVRM_FILLVALUE:
 181+ 5B7E 72               LD (HL), D
 182+ 5B7F 54               LD D, H
 183+ 5B80 5D               LD E, L
 184+ 5B81 13               INC DE
 185+ 5B82 0B               DEC BC
 186+ 5B83 78           	LD A,B
 187+ 5B84 B1           	OR C
 188+ 5B85 C8           	RET Z ; if count was 1
 189+ 5B86 ED B0            LDIR
 190+ 5B88 C9               RET
 191+ 5B89              ; *******************************************************************************************************
# file closed: asm\MEMORY.asm
 137  5B89               ENDIF
 138  5B89
 139  5B89               IF (SOUND_CMDS == 1)
 140  5B89               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
   1+ 5B89              MUSIC_INIT_STATUS:
   2+ 5B89 00            DB 0
   3+ 5B8A              SFX_INIT_STATUS:
   4+ 5B8A 00            DB 0
   5+ 5B8B              SOUND_ENABLED:
   6+ 5B8B 00            DB 0
   7+ 5B8C
   8+ 5B8C               IF (BASIC_EXTENSION == 1)
   9+ 5B8C              ; *******************************************************************************************************
  10+ 5B8C              ; function to handle CALL SNDPLYINIT basic extension
  11+ 5B8C              ; initializes sound player
  12+ 5B8C              ; _SNDPLYINIT ( INT music_offset,
  13+ 5B8C              ;				INT sfx_offset, can be -1 if no SFX
  14+ 5B8C              ; will put ram in page 0 also, page 1 is already there
  15+ 5B8C              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
  16+ 5B8C              SNDPLYINIT:
  17+ 5B8C              	; opening (
  18+ 5B8C CD 43 6A     	CALL CHKCHAR
  19+ 5B8F 28           	DB '('
  20+ 5B90              	; get music address
  21+ 5B90 DD 21 2F 54  	LD IX, FRMQNT
  22+ 5B94 CD 59 01     	CALL CALBAS
  23+ 5B97 D5           	PUSH DE
  24+ 5B98              	; comma
  25+ 5B98 CD 43 6A     	CALL CHKCHAR
  26+ 5B9B 2C           	DB ','
  27+ 5B9C              	; get sfx address
  28+ 5B9C DD 21 2F 54  	LD IX, FRMQNT
  29+ 5BA0 CD 59 01     	CALL CALBAS
  30+ 5BA3 D5           	PUSH DE
  31+ 5BA4              	; ending )
  32+ 5BA4 CD 43 6A     	CALL CHKCHAR
  33+ 5BA7 29           	DB ')'
  34+ 5BA8
  35+ 5BA8                  ; save position in BASIC text
  36+ 5BA8 44           	LD B, H
  37+ 5BA9 4D           	LD C, L
  38+ 5BAA
  39+ 5BAA              	; pop LDIR parameters and store away for later
  40+ 5BAA D1           	POP DE ; sfx address
  41+ 5BAB E1           	POP HL ; music address
  42+ 5BAC C5           	PUSH BC ; basic text location
  43+ 5BAD D9           	EXX
  44+ 5BAE FD 21 B5 5B  	LD IY, .RET
  45+ 5BB2 C3 F5 69     	JP ENABLE_PAGE0
  46+ 5BB5              .RET:
  47+ 5BB5 D9           	EXX
  48+ 5BB6
  49+ 5BB6 D5           	PUSH DE
  50+ 5BB7 AF           	XOR A
  51+ 5BB8              	; HL = music location
  52+ 5BB8 CD 65 41     	CALL PLY_AKG_INIT
  53+ 5BBB 3E 01        	LD A, 1
  54+ 5BBD 32 89 5B     	LD (MUSIC_INIT_STATUS), A
  55+ 5BC0
  56+ 5BC0 E1           	POP HL ; SFX
  57+ 5BC1              	; check if SFX address -1
  58+ 5BC1 23           	INC HL
  59+ 5BC2 7D           	LD A, L
  60+ 5BC3 B4           	OR H
  61+ 5BC4 28 09        	JR Z,.L1
  62+ 5BC6 2B           	DEC HL
  63+ 5BC7 CD 20 40     	CALL PLY_AKG_INITSOUNDEFFECTS
  64+ 5BCA 3E 01        	LD A, 1
  65+ 5BCC 32 8A 5B     	LD (SFX_INIT_STATUS), A
  66+ 5BCF              .L1:
  67+ 5BCF D1               POP DE
  68+ 5BD0 C1               POP BC
  69+ 5BD1 CD 6C 69         CALL RESTORE_PAGE_INFO
  70+ 5BD4
  71+ 5BD4 E1           	POP HL
  72+ 5BD5 C9           	RET
  73+ 5BD6              ; *******************************************************************************************************
  74+ 5BD6               ENDIF
  75+ 5BD6
  76+ 5BD6               IF (DEFUSR_EXTENSION == 1)
  77+ 5BD6              ; *******************************************************************************************************
  78+ 5BD6              ; same as SNDPLYINI but for DEFUSR approach
  79+ 5BD6              ; input IX=pointer to input array, real data from +2
  80+ 5BD6              ; +2 = music address
  81+ 5BD6              ; +4 = sfx address
  82+ 5BD6              SNDPLYINI_DEFUSR:
  83+ 5BD6 FD 21 DD 5B  	LD IY, .RET
  84+ 5BDA C3 F5 69     	JP ENABLE_PAGE0
  85+ 5BDD              .RET:
  86+ 5BDD AF           	XOR A
  87+ 5BDE DD 6E 02     	LD L,(IX+2)
  88+ 5BE1 DD 66 03     	LD H,(IX+3)
  89+ 5BE4 DD E5        	PUSH IX
  90+ 5BE6 CD 65 41     	CALL PLY_AKG_INIT
  91+ 5BE9 DD E1        	POP IX
  92+ 5BEB 3E 01        	LD A, 1
  93+ 5BED 32 89 5B     	LD (MUSIC_INIT_STATUS), A
  94+ 5BF0
  95+ 5BF0 DD 6E 04     	LD L,(IX+4)
  96+ 5BF3 DD 66 05     	LD H,(IX+5)
  97+ 5BF6              	; check if SFX address -1
  98+ 5BF6 23           	INC HL
  99+ 5BF7 7D           	LD A, L
 100+ 5BF8 B4           	OR H
 101+ 5BF9 28 09        	JR Z,.L1
 102+ 5BFB 2B           	DEC HL
 103+ 5BFC CD 20 40     	CALL PLY_AKG_INITSOUNDEFFECTS
 104+ 5BFF 3E 01        	LD A, 1
 105+ 5C01 32 8A 5B     	LD (SFX_INIT_STATUS), A
 106+ 5C04              .L1:
 107+ 5C04 D1               POP DE
 108+ 5C05 C1               POP BC
 109+ 5C06 C3 6C 69         JP RESTORE_PAGE_INFO
 110+ 5C09              ; *******************************************************************************************************
 111+ 5C09               ENDIF
 112+ 5C09
 113+ 5C09              ; *******************************************************************************************************
 114+ 5C09              ; function to handle CALL SNDPLYON basic extension
 115+ 5C09              ; enables sound player
 116+ 5C09              ; _SNDPLYON
 117+ 5C09              ; sets SOUND_ENABLED variable to 1 if init call was done
 118+ 5C09              ; if not throws out of data error
 119+ 5C09              SNDPLYON_DEFUSR:
 120+ 5C09              SNDPLYON:
 121+ 5C09 3A 89 5B     	LD A, (MUSIC_INIT_STATUS)
 122+ 5C0C B7           	OR A
 123+ 5C0D 20 05        	JR NZ, .L1
 124+ 5C0F              	; player not initialized, throw error
 125+ 5C0F 1E 04        	LD E, 04 ; Out of DATA
 126+ 5C11 C3 69 6A     	JP THROW_ERROR
 127+ 5C14              .L1:
 128+ 5C14 32 8B 5B     	LD (SOUND_ENABLED), A
 129+ 5C17              	; disable key click
 130+ 5C17 AF           	XOR A
 131+ 5C18 32 DB F3     	LD (CLIKSW), A
 132+ 5C1B C9           	RET
 133+ 5C1C              ; *******************************************************************************************************
 134+ 5C1C
 135+ 5C1C              ; *******************************************************************************************************
 136+ 5C1C              ; function to handle CALL SNDPLYOFF basic extension
 137+ 5C1C              ; disables sound player
 138+ 5C1C              ; _SNDPLYOFF
 139+ 5C1C              ; sets SOUND_ENABLED variable to 0
 140+ 5C1C              ; calls AKG to stop music and SFX on all channels if initialized
 141+ 5C1C              SNDPLYOFF_DEFUSR:
 142+ 5C1C              SNDPLYOFF:
 143+ 5C1C 3A 8B 5B     	LD A, (SOUND_ENABLED)
 144+ 5C1F B7           	OR A
 145+ 5C20 C8           	RET Z ; already stopped
 146+ 5C21 AF           	XOR A
 147+ 5C22 32 8B 5B     	LD (SOUND_ENABLED), A
 148+ 5C25 E5           	PUSH HL
 149+ 5C26 CD 24 42     	CALL PLY_AKG_STOP
 150+ 5C29 3A 8A 5B     	LD A, (SFX_INIT_STATUS)
 151+ 5C2C B7           	OR A
 152+ 5C2D 28 0E        	JR Z, .EXIT ; SFX not in use
 153+ 5C2F AF           	XOR A
 154+ 5C30 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 155+ 5C33 3E 01        	LD A, 1
 156+ 5C35 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 157+ 5C38 3E 02        	LD A, 2
 158+ 5C3A CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 159+ 5C3D              .EXIT:
 160+ 5C3D E1           	POP HL
 161+ 5C3E C9           	RET
 162+ 5C3F              ; *******************************************************************************************************
 163+ 5C3F
 164+ 5C3F               IF (BASIC_EXTENSION == 1)
 165+ 5C3F              ; *******************************************************************************************************
 166+ 5C3F              ; function to handle CALL SNDSFX basic extension
 167+ 5C3F              ; plays a sound effect
 168+ 5C3F              ; _SNDSFX ( BYTE sfx_number, >0
 169+ 5C3F              ;			BYTE channel, = 0,1 or 2
 170+ 5C3F              ;			BYTE inverted_volume = 0-16, 0 being full volume
 171+ 5C3F              ; will put ram in page 0 also, page 1 is already there
 172+ 5C3F              ; if sound off throws illegal function call
 173+ 5C3F              ; if sfx not initialized, throws out of data
 174+ 5C3F              SNDSFX:
 175+ 5C3F              	; opening (
 176+ 5C3F CD 43 6A     	CALL CHKCHAR
 177+ 5C42 28           	DB '('
 178+ 5C43              	; get sfx_number
 179+ 5C43 DD 21 1C 52  	LD IX, GETBYT
 180+ 5C47 CD 59 01     	CALL CALBAS
 181+ 5C4A D5           	PUSH DE
 182+ 5C4B              	; comma
 183+ 5C4B CD 43 6A     	CALL CHKCHAR
 184+ 5C4E 2C           	DB ','
 185+ 5C4F              	; get sfx address
 186+ 5C4F DD 21 1C 52  	LD IX, GETBYT
 187+ 5C53 CD 59 01     	CALL CALBAS
 188+ 5C56 D5           	PUSH DE
 189+ 5C57              	; comma
 190+ 5C57 CD 43 6A     	CALL CHKCHAR
 191+ 5C5A 2C           	DB ','
 192+ 5C5B              	; get inverted volume
 193+ 5C5B DD 21 1C 52  	LD IX, GETBYT
 194+ 5C5F CD 59 01     	CALL CALBAS
 195+ 5C62 D5           	PUSH DE
 196+ 5C63              	; ending )
 197+ 5C63 CD 43 6A     	CALL CHKCHAR
 198+ 5C66 29           	DB ')'
 199+ 5C67
 200+ 5C67 3A 8B 5B     	LD A, (SOUND_ENABLED)
 201+ 5C6A B7           	OR A
 202+ 5C6B 20 05        	JR NZ, .L1
 203+ 5C6D              	; sound disabled, throw illegal function call
 204+ 5C6D 1E 05        	LD E, 5
 205+ 5C6F C3 69 6A     	JP THROW_ERROR
 206+ 5C72              .L1:
 207+ 5C72 3A 8A 5B     	LD A, (SFX_INIT_STATUS)
 208+ 5C75 B7           	OR A
 209+ 5C76 20 05        	JR NZ, .L2
 210+ 5C78              	; sfx data not initialized, throw out of data
 211+ 5C78 1E 04        	LD E, 4
 212+ 5C7A C3 69 6A     	JP THROW_ERROR
 213+ 5C7D              .L2:
 214+ 5C7D              	; pop  parameters and store away for later
 215+ 5C7D D1           	POP DE ; inverted volume
 216+ 5C7E 43           	LD B, E
 217+ 5C7F D1           	POP DE ; channel
 218+ 5C80 4B           	LD C, E
 219+ 5C81 D1           	POP DE
 220+ 5C82 7B           	LD A, E
 221+ 5C83 08           	EX AF, AF'
 222+ 5C84 E5           	PUSH HL ; basic text location
 223+ 5C85 D9           	EXX
 224+ 5C86 FD 21 8D 5C  	LD IY, .RET
 225+ 5C8A C3 F5 69     	JP ENABLE_PAGE0
 226+ 5C8D              .RET:
 227+ 5C8D D9           	EXX
 228+ 5C8E 08           	EX AF, AF'
 229+ 5C8F CD 24 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
 230+ 5C92
 231+ 5C92 D1               POP DE
 232+ 5C93 C1               POP BC
 233+ 5C94 CD 6C 69         CALL RESTORE_PAGE_INFO
 234+ 5C97
 235+ 5C97 E1           	POP HL
 236+ 5C98 C9           	RET
 237+ 5C99              ; *******************************************************************************************************
 238+ 5C99               ENDIF
 239+ 5C99
 240+ 5C99               IF (DEFUSR_EXTENSION == 1)
 241+ 5C99              ; *******************************************************************************************************
 242+ 5C99              ; same as SNDSFX but for DEFUSR approach
 243+ 5C99              ; input IX=pointer to input array, real data from +2
 244+ 5C99              ; +2 = SFX number
 245+ 5C99              ; +4 = channel
 246+ 5C99              ; +6 = volume
 247+ 5C99              SNDSFX_DEFUSR:
 248+ 5C99 3A 8B 5B     	LD A, (SOUND_ENABLED)
 249+ 5C9C B7           	OR A
 250+ 5C9D C8           	RET Z ; sound disabled, just exit
 251+ 5C9E 3A 8A 5B     	LD A, (SFX_INIT_STATUS)
 252+ 5CA1 B7           	OR A
 253+ 5CA2 C8           	RET Z ; sfx data not initialized, just exit
 254+ 5CA3 F3           	DI
 255+ 5CA4 FD 21 AB 5C  	LD IY, .RET
 256+ 5CA8 C3 F5 69     	JP ENABLE_PAGE0
 257+ 5CAB              .RET:
 258+ 5CAB FB           	EI
 259+ 5CAC DD 7E 02     	LD A,(IX+2) ; SFX number
 260+ 5CAF DD 4E 04     	LD C,(IX+4) ; channel
 261+ 5CB2 DD 46 06     	LD B,(IX+6) ; volume
 262+ 5CB5 CD 24 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
 263+ 5CB8 D1               POP DE
 264+ 5CB9 C1               POP BC
 265+ 5CBA C3 6C 69         JP RESTORE_PAGE_INFO
 266+ 5CBD              ; *******************************************************************************************************
 267+ 5CBD               ENDIF
# file closed: asm\SOUND.asm
 141  5CBD               ENDIF
 142  5CBD
 143  5CBD               IF (VRAM_CMDS == 1)
 144  5CBD               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
   1+ 5CBD              ; *******************************************************************************************************
   2+ 5CBD              ; function to handle CALL FILVRM basic extension
   3+ 5CBD              ; FILVRM ( INT offset,
   4+ 5CBD              ;		   INT count,
   5+ 5CBD              ;		   BYTE value,
   6+ 5CBD              ;		   BYTE wait_vsync) >0 = true
   7+ 5CBD              ; wait_vsync will issue HALT before copying
   8+ 5CBD              FILVRM:
   9+ 5CBD              	; opening (
  10+ 5CBD CD 43 6A     	CALL CHKCHAR
  11+ 5CC0 28           	DB '('
  12+ 5CC1              	; get offset address
  13+ 5CC1 DD 21 2F 54  	LD IX, FRMQNT
  14+ 5CC5 CD 59 01     	CALL CALBAS
  15+ 5CC8 D5           	PUSH DE
  16+ 5CC9              	; comma
  17+ 5CC9 CD 43 6A     	CALL CHKCHAR
  18+ 5CCC 2C           	DB ','
  19+ 5CCD              	; get count
  20+ 5CCD DD 21 2F 54  	LD IX, FRMQNT
  21+ 5CD1 CD 59 01     	CALL CALBAS
  22+ 5CD4 D5           	PUSH DE
  23+ 5CD5              	; comma
  24+ 5CD5 CD 43 6A     	CALL CHKCHAR
  25+ 5CD8 2C           	DB ','
  26+ 5CD9              	; get value
  27+ 5CD9 DD 21 1C 52  	LD IX, GETBYT
  28+ 5CDD CD 59 01     	CALL CALBAS
  29+ 5CE0 F5           	PUSH AF
  30+ 5CE1              	; comma
  31+ 5CE1 CD 43 6A     	CALL CHKCHAR
  32+ 5CE4 2C           	DB ','
  33+ 5CE5              	; get vsync wait
  34+ 5CE5 DD 21 1C 52  	LD IX, GETBYT
  35+ 5CE9 CD 59 01     	CALL CALBAS
  36+ 5CEC F5           	PUSH AF
  37+ 5CED              	; ending )
  38+ 5CED CD 43 6A     	CALL CHKCHAR
  39+ 5CF0 29           	DB ')'
  40+ 5CF1
  41+ 5CF1              	; save position
  42+ 5CF1 E5           	PUSH HL
  43+ 5CF2 DD E1        	POP IX
  44+ 5CF4
  45+ 5CF4              	; syntax ok
  46+ 5CF4              	; wait for vsync if needed
  47+ 5CF4 F1           	POP AF
  48+ 5CF5 B7           	OR A
  49+ 5CF6 28 01        	JR Z, .L1
  50+ 5CF8 76           	HALT
  51+ 5CF9
  52+ 5CF9              .L1:
  53+ 5CF9 3E 01        	LD A,1
  54+ 5CFB 32 45 67     	LD (VRAM_UPDATE_IN_PROGRESS),A
  55+ 5CFE F1               POP AF ; value
  56+ 5CFF C1               POP BC ; count
  57+ 5D00 E1               POP HL ; offset
  58+ 5D01 CD 56 00         CALL BIOS_FILVRM
  59+ 5D04 AF           	XOR A
  60+ 5D05 32 45 67     	LD (VRAM_UPDATE_IN_PROGRESS),A
  61+ 5D08
  62+ 5D08              .L3:
  63+ 5D08 DD E5        	PUSH IX
  64+ 5D0A E1           	POP HL
  65+ 5D0B C9           	RET
  66+ 5D0C              ; *******************************************************************************************************
  67+ 5D0C
  68+ 5D0C               IF (BASIC_EXTENSION == 1)
  69+ 5D0C              ; *******************************************************************************************************
  70+ 5D0C              ; function to handle CALL MEMVRM basic extension
  71+ 5D0C              ; copies from RAM to VRAM
  72+ 5D0C              ; _MEMVRM ( INT source,
  73+ 5D0C              ;			INT destination,
  74+ 5D0C              ;			INT count,
  75+ 5D0C              ;			BYTE wait_vsync) >0 = true
  76+ 5D0C              ; will put ram in page 0 also, page 1 is already there
  77+ 5D0C              ; wait_vsync will issue HALT before copying
  78+ 5D0C              MEMVRM:
  79+ 5D0C              	; opening (
  80+ 5D0C CD 43 6A     	CALL CHKCHAR
  81+ 5D0F 28           	DB '('
  82+ 5D10              	; get source address
  83+ 5D10 DD 21 2F 54  	LD IX, FRMQNT
  84+ 5D14 CD 59 01     	CALL CALBAS
  85+ 5D17 D5           	PUSH DE
  86+ 5D18              	; comma
  87+ 5D18 CD 43 6A     	CALL CHKCHAR
  88+ 5D1B 2C           	DB ','
  89+ 5D1C              	; get destination address
  90+ 5D1C DD 21 2F 54  	LD IX, FRMQNT
  91+ 5D20 CD 59 01     	CALL CALBAS
  92+ 5D23 D5           	PUSH DE
  93+ 5D24              	; comma
  94+ 5D24 CD 43 6A     	CALL CHKCHAR
  95+ 5D27 2C           	DB ','
  96+ 5D28              	; get length
  97+ 5D28 DD 21 2F 54  	LD IX, FRMQNT
  98+ 5D2C CD 59 01     	CALL CALBAS
  99+ 5D2F D5           	PUSH DE
 100+ 5D30              	; comma
 101+ 5D30 CD 43 6A     	CALL CHKCHAR
 102+ 5D33 2C           	DB ','
 103+ 5D34              	; get vsync wait
 104+ 5D34 DD 21 1C 52  	LD IX, GETBYT
 105+ 5D38 CD 59 01     	CALL CALBAS
 106+ 5D3B F5           	PUSH AF
 107+ 5D3C              	; ending )
 108+ 5D3C CD 43 6A     	CALL CHKCHAR
 109+ 5D3F 29           	DB ')'
 110+ 5D40
 111+ 5D40                  ; save position in BASIC text
 112+ 5D40 E5           	PUSH HL
 113+ 5D41 DD E1        	POP IX
 114+ 5D43
 115+ 5D43 F1           	POP AF ; wait vsync
 116+ 5D44 B7           	OR A
 117+ 5D45 28 01        	JR Z, .L1
 118+ 5D47 76           	HALT
 119+ 5D48              .L1:
 120+ 5D48 F3           	DI
 121+ 5D49              	; pop LDIR parameters and store away for later
 122+ 5D49 C1           	POP BC ; count
 123+ 5D4A D1           	POP DE ; vram destination
 124+ 5D4B E1           	POP HL ; ram source
 125+ 5D4C D9           	EXX
 126+ 5D4D FD 21 54 5D   	LD IY, .RET
 127+ 5D51 C3 F5 69     	JP ENABLE_PAGE0
 128+ 5D54              .RET:
 129+ 5D54 FB           	EI
 130+ 5D55 D9           	EXX
 131+ 5D56 CD 8C 5D     	CALL VRAM_LDIRVM
 132+ 5D59 D1               POP DE
 133+ 5D5A C1               POP BC
 134+ 5D5B CD 6C 69         CALL RESTORE_PAGE_INFO
 135+ 5D5E DD E5        	PUSH IX
 136+ 5D60 E1           	POP HL
 137+ 5D61 C9           	RET
 138+ 5D62              ; *******************************************************************************************************
 139+ 5D62               ENDIF
 140+ 5D62
 141+ 5D62               IF (DEFUSR_EXTENSION == 1)
 142+ 5D62              ; *******************************************************************************************************
 143+ 5D62              ; same as MEMVRM but for DEFUSR approach
 144+ 5D62              ; input IX=pointer to input array, real data from +2
 145+ 5D62              ; +2 = source address
 146+ 5D62              ; +4 = destination address
 147+ 5D62              ; +6 = lenght
 148+ 5D62              ; +8 = vsync wait flag
 149+ 5D62              MEMVRM_DEFUSR:
 150+ 5D62 DD 7E 08     	LD A,(IX+8)
 151+ 5D65 B7           	OR A
 152+ 5D66 28 01        	JR Z,.L0
 153+ 5D68 76           	HALT
 154+ 5D69              .L0:
 155+ 5D69              	; enable page 0
 156+ 5D69 F3           	DI
 157+ 5D6A FD 21 71 5D  	LD IY, .RET
 158+ 5D6E C3 F5 69     	JP ENABLE_PAGE0
 159+ 5D71              .RET:
 160+ 5D71 FB           	EI
 161+ 5D72 DD 6E 02     	LD L,(IX+2)
 162+ 5D75 DD 66 03     	LD H,(IX+3)
 163+ 5D78 DD 5E 04     	LD E,(IX+4)
 164+ 5D7B DD 56 05     	LD D,(IX+5)
 165+ 5D7E DD 4E 06     	LD C,(IX+6)
 166+ 5D81 DD 46 07     	LD B,(IX+7)
 167+ 5D84 CD 8C 5D     	CALL VRAM_LDIRVM
 168+ 5D87 D1               POP DE
 169+ 5D88 C1               POP BC
 170+ 5D89 C3 6C 69         JP RESTORE_PAGE_INFO
 171+ 5D8C              ; *******************************************************************************************************
 172+ 5D8C               ENDIF
 173+ 5D8C
 174+ 5D8C              ; *******************************************************************************************************
 175+ 5D8C              ; common code to copy from memory to VRAM
 176+ 5D8C              ; input HL=RAM source
 177+ 5D8C              ; input DE=VRAM destination
 178+ 5D8C              ; BC=count
 179+ 5D8C              VRAM_LDIRVM:
 180+ 5D8C 3E 01        	LD A,1
 181+ 5D8E 32 45 67     	LD (VRAM_UPDATE_IN_PROGRESS),A
 182+ 5D91 EB           	EX DE, HL
 183+ 5D92 F3           	DI
 184+ 5D93 CD 1C 69     	CALL SETWRT_LOCAL
 185+ 5D96 FB           	EI
 186+ 5D97 EB           	EX DE, HL
 187+ 5D98 78           	LD A, B
 188+ 5D99 B7           	OR A
 189+ 5D9A 28 0D        	JR Z, .L3
 190+ 5D9C C5           	PUSH BC
 191+ 5D9D 0E 98        	LD C, #98
 192+ 5D9F              .L2:
 193+ 5D9F 50           	LD D, B
 194+ 5DA0 06 00        	LD B, 0
 195+ 5DA2 CD 29 69     	CALL BBYTECOPY_NO_C
 196+ 5DA5 42           	LD B, D
 197+ 5DA6 10 F7        	DJNZ .L2
 198+ 5DA8 C1           	POP BC
 199+ 5DA9              .L3:
 200+ 5DA9 79           	LD A, C
 201+ 5DAA B7           	OR A
 202+ 5DAB 28 04        	JR Z,.L4
 203+ 5DAD 41           	LD B, C
 204+ 5DAE CD 27 69     	CALL BBYTECOPY
 205+ 5DB1              .L4:
 206+ 5DB1 AF           	XOR A
 207+ 5DB2 32 45 67     	LD (VRAM_UPDATE_IN_PROGRESS),A
 208+ 5DB5 C9           	RET
 209+ 5DB6              ; *******************************************************************************************************
 210+ 5DB6
 211+ 5DB6              ; *******************************************************************************************************
 212+ 5DB6              ; function to handle CALL VRMMEM basic extension
 213+ 5DB6              ; copies from RAM to VRAM
 214+ 5DB6              ; _VRMMEM ( INT source,
 215+ 5DB6              ;			INT destination,
 216+ 5DB6              ;			INT count
 217+ 5DB6              ; will put ram in page 0 also, page 1 is already there
 218+ 5DB6              VRMMEM:
 219+ 5DB6              	; opening (
 220+ 5DB6 CD 43 6A     	CALL CHKCHAR
 221+ 5DB9 28           	DB '('
 222+ 5DBA              	; get source address
 223+ 5DBA DD 21 2F 54  	LD IX, FRMQNT
 224+ 5DBE CD 59 01     	CALL CALBAS
 225+ 5DC1 D5           	PUSH DE
 226+ 5DC2              	; comma
 227+ 5DC2 CD 43 6A     	CALL CHKCHAR
 228+ 5DC5 2C           	DB ','
 229+ 5DC6              	; get destination address
 230+ 5DC6 DD 21 2F 54  	LD IX, FRMQNT
 231+ 5DCA CD 59 01     	CALL CALBAS
 232+ 5DCD D5           	PUSH DE
 233+ 5DCE              	; comma
 234+ 5DCE CD 43 6A     	CALL CHKCHAR
 235+ 5DD1 2C           	DB ','
 236+ 5DD2              	; get length
 237+ 5DD2 DD 21 2F 54  	LD IX, FRMQNT
 238+ 5DD6 CD 59 01     	CALL CALBAS
 239+ 5DD9 D5           	PUSH DE
 240+ 5DDA              	; ending )
 241+ 5DDA CD 43 6A     	CALL CHKCHAR
 242+ 5DDD 29           	DB ')'
 243+ 5DDE
 244+ 5DDE                  ; save position in BASIC text
 245+ 5DDE E5           	PUSH HL
 246+ 5DDF DD E1        	POP IX
 247+ 5DE1
 248+ 5DE1 C1           	POP BC ; count
 249+ 5DE2 D1           	POP DE ; destination
 250+ 5DE3 E1           	POP HL ; source
 251+ 5DE4 D9           	EXX
 252+ 5DE5 FD 21 ED 5D  	LD IY, .RET
 253+ 5DE9 F3           	DI
 254+ 5DEA C3 F5 69     	JP ENABLE_PAGE0
 255+ 5DED              .RET:
 256+ 5DED FB           	EI
 257+ 5DEE D9           	EXX
 258+ 5DEF 3E 01        	LD A,1
 259+ 5DF1 32 45 67     	LD (VRAM_UPDATE_IN_PROGRESS),A
 260+ 5DF4 CD 04 5E     	CALL .LDIRMV
 261+ 5DF7 AF           	XOR A
 262+ 5DF8 32 45 67     	LD (VRAM_UPDATE_IN_PROGRESS),A
 263+ 5DFB D1               POP DE
 264+ 5DFC C1               POP BC
 265+ 5DFD CD 6C 69         CALL RESTORE_PAGE_INFO
 266+ 5E00 DD E5        	PUSH IX
 267+ 5E02 E1           	POP HL
 268+ 5E03 C9           	RET
 269+ 5E04
 270+ 5E04              .LDIRMV:
 271+ 5E04              	; set VRAM address *exactly* as in ROM, otherwise corruption
 272+ 5E04 7D           	LD	A, L
 273+ 5E05 F3           	DI
 274+ 5E06 D3 99        	OUT	(099H), A
 275+ 5E08 7C           	LD	A, H
 276+ 5E09 E6 3F        	AND	03FH
 277+ 5E0B D3 99        	OUT	(099H), A
 278+ 5E0D FB           	EI
 279+ 5E0E              	;EX (SP), HL
 280+ 5E0E              	;EX (SP), HL
 281+ 5E0E              	;NOP
 282+ 5E0E              	;NOP
 283+ 5E0E              .L4:
 284+ 5E0E DB 98            IN A, (#98)
 285+ 5E10 12           	LD (DE), A
 286+ 5E11 13               INC DE
 287+ 5E12 0B               DEC BC
 288+ 5E13 79               LD A, C
 289+ 5E14 B0               OR B
 290+ 5E15 20 F7            JR NZ, .L4
 291+ 5E17 C9               RET
 292+ 5E18              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
 145  5E18               ENDIF
 146  5E18
 147  5E18               IF (GENCAL_CMD == 1)
 148  5E18               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
   1+ 5E18               IF (DEFUSR_EXTENSION == 1)
   2+ 5E18              ; *******************************************************************************************************
   3+ 5E18              ; same as GENCAL but for DEFUSR approach
   4+ 5E18              ; input IX=pointer to input array, real data from +2
   5+ 5E18              ; +2 = function address to call
   6+ 5E18              ; +4 = register list array pointer
   7+ 5E18              GENCAL_DEFUSR:
   8+ 5E18 DD 6E 02         LD L,(IX+2)
   9+ 5E1B DD 66 03         LD H,(IX+3)
  10+ 5E1E E5               PUSH HL
  11+ 5E1F DD 6E 04         LD L,(IX+4)
  12+ 5E22 DD 66 05         LD H,(IX+5)
  13+ 5E25 E5               PUSH HL
  14+ 5E26 18 1F            JR GENCAL.COMMON
  15+ 5E28              ; *******************************************************************************************************
  16+ 5E28               ENDIF
  17+ 5E28
  18+ 5E28              ; *******************************************************************************************************
  19+ 5E28              ; function to handle CALL GENCAL basic extension
  20+ 5E28              ; GENCAL ( INT fn_addr, = address of the function to call
  21+ 5E28              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
  22+ 5E28              ; output values of registers will also be stored at reg_list_ptr
  23+ 5E28              GENCAL:
  24+ 5E28               IF (BASIC_EXTENSION == 1)
  25+ 5E28              	; opening (
  26+ 5E28 CD 43 6A     	CALL CHKCHAR
  27+ 5E2B 28           	DB '('
  28+ 5E2C              	; get function address
  29+ 5E2C DD 21 2F 54  	LD IX, FRMQNT
  30+ 5E30 CD 59 01     	CALL CALBAS
  31+ 5E33 D5           	PUSH DE
  32+ 5E34              	; comma
  33+ 5E34 CD 43 6A     	CALL CHKCHAR
  34+ 5E37 2C           	DB ','
  35+ 5E38              	; get pointer to register list
  36+ 5E38 3E 02            LD A,2
  37+ 5E3A 06 01            LD B,1
  38+ 5E3C 11 00 05         LD DE,#0500
  39+ 5E3F CD 70 6A         CALL GET_BASIC_ARRAY_DATA_POINTER
  40+ 5E42 C5           	PUSH BC
  41+ 5E43              	; ending )
  42+ 5E43 CD 43 6A     	CALL CHKCHAR
  43+ 5E46 29           	DB ')'
  44+ 5E47               ENDIF
  45+ 5E47              .COMMON:
  46+ 5E47              	; save BASIC token position
  47+ 5E47 E5           	PUSH HL
  48+ 5E48 D9               EXX
  49+ 5E49 E1           	POP HL ; HL'=next basic token
  50+ 5E4A D9               EXX
  51+ 5E4B
  52+ 5E4B E1               POP HL ; get pointer to register values
  53+ 5E4C F3           	DI
  54+ 5E4D ED 73 34 67      LD (BLIT_STRUCT), SP
  55+ 5E51 F9               LD SP, HL
  56+ 5E52 F1               POP AF
  57+ 5E53 C1               POP BC
  58+ 5E54 D1               POP DE
  59+ 5E55 E1               POP HL
  60+ 5E56 DD E1            POP IX
  61+ 5E58 FD E1            POP IY
  62+ 5E5A D9               EXX
  63+ 5E5B ED 73 36 67      LD (BLIT_STRUCT+2), SP
  64+ 5E5F ED 7B 34 67      LD SP, (BLIT_STRUCT)
  65+ 5E63 FB               EI
  66+ 5E64 D1               POP DE ; get function to call
  67+ 5E65 E5               PUSH HL
  68+ 5E66 CD 81 5E         CALL .EXXDECALL
  69+ 5E69 F3               DI
  70+ 5E6A ED 73 34 67      LD (BLIT_STRUCT), SP
  71+ 5E6E ED 7B 36 67      LD SP, (BLIT_STRUCT+2)
  72+ 5E72 FD E5            PUSH IY
  73+ 5E74 DD E5            PUSH IX
  74+ 5E76 E5               PUSH HL
  75+ 5E77 D5               PUSH DE
  76+ 5E78 C5               PUSH BC
  77+ 5E79 F5               PUSH AF
  78+ 5E7A ED 7B 34 67      LD SP, (BLIT_STRUCT)
  79+ 5E7E FB               EI
  80+ 5E7F E1               POP HL
  81+ 5E80 C9           	RET
  82+ 5E81
  83+ 5E81              .EXXDECALL:
  84+ 5E81 D5               PUSH DE
  85+ 5E82 D9               EXX
  86+ 5E83 C9               RET
  87+ 5E84              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
 149  5E84               ENDIF
 150  5E84
 151  5E84               IF (BOX_CMDS == 1)
 152  5E84               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
   1+ 5E84              ; *******************************************************************************************************
   2+ 5E84              ; generic function to implement rectangle data copy
   3+ 5E84              ; should be modified to call appropriate function for memory or vram
   4+ 5E84              ; input IX=pointer to following structure
   5+ 5E84              ; +00 source data pointer
   6+ 5E84              ; +02 num bytes in a row
   7+ 5E84              ; +04 number of rows
   8+ 5E84              ; +06 source add-to value till next row
   9+ 5E84              ; +08 destination address
  10+ 5E84              ; +10 destination add-to value till next row
  11+ 5E84              ; modifies AF, BC, DE, HL
  12+ 5E84              RECTANGLE_COPY:
  13+ 5E84 DD 6E 00     	LD L, (IX+0)
  14+ 5E87 DD 66 01     	LD H, (IX+1) ; source address
  15+ 5E8A DD 5E 08     	LD E, (IX+8)
  16+ 5E8D DD 56 09     	LD D, (IX+9) ; destination
  17+ 5E90 DD 46 04     	LD B, (IX+4) ; row number
  18+ 5E93              .L1:
  19+ 5E93 C5           	PUSH BC
  20+ 5E94 E5           		PUSH HL
  21+ 5E95 D5           			PUSH DE
  22+ 5E96 DD 4E 02     				LD C, (IX+2)
  23+ 5E99 DD 46 03     				LD B, (IX+3) ; num bytes in a row
  24+ 5E9C              .CALL1:
  25+ 5E9C CD 00 00     				CALL 0 ; set destination address from DE
  26+ 5E9F              .CALL2:
  27+ 5E9F CD 00 00     				CALL 0 ; copy data fn
  28+ 5EA2 E1           			POP HL
  29+ 5EA3 DD 4E 0A     			LD C, (IX+10)
  30+ 5EA6 DD 46 0B     			LD B, (IX+11) ; destination add-to
  31+ 5EA9 09           			ADD HL, BC
  32+ 5EAA EB           			EX DE, HL
  33+ 5EAB E1           		POP HL
  34+ 5EAC DD 4E 06     		LD C, (IX+6)
  35+ 5EAF DD 46 07     		LD B, (IX+7) ; src add-to
  36+ 5EB2 09           		ADD HL, BC
  37+ 5EB3 C1           	POP BC
  38+ 5EB4 10 DD        	DJNZ .L1
  39+ 5EB6 C9           	RET
  40+ 5EB7              ; *******************************************************************************************************
  41+ 5EB7
  42+ 5EB7               IF (BASIC_EXTENSION == 1)
  43+ 5EB7              ; *******************************************************************************************************
  44+ 5EB7              ; function to handle CALL BOXMEMCPY basic extension
  45+ 5EB7              ; copies data with window like boundaries within ram
  46+ 5EB7              ; BOXMEMCPY ( INT source data pointer,
  47+ 5EB7              ;			  INT source number of bytes in a row,
  48+ 5EB7              ;			  INT number of rows,
  49+ 5EB7              ;			  INT source add-to value till next row,
  50+ 5EB7              ; 			  INT destination pointer,
  51+ 5EB7              ;			  INT destination add-to value till next row )
  52+ 5EB7              ; request_data_ptr described in RECTANGLE_COPY
  53+ 5EB7              ; will put ram in page 0 also, page 1 is already there
  54+ 5EB7              BOXMEMCPY:
  55+ 5EB7 11 CE 5E     	LD DE,BOXMEMCPY_COMMON
  56+ 5EBA ED 53 47 5F  	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
  57+ 5EBE C3 E1 5E     	JP BOX_EXTENSION_PARAMS_COMMON
  58+ 5EC1               ENDIF
  59+ 5EC1
  60+ 5EC1               IF (DEFUSR_EXTENSION == 1)
  61+ 5EC1              ; *******************************************************************************************************
  62+ 5EC1              ; same as BOXMEMCPY but for DEFUSR approach
  63+ 5EC1              ; input IX=pointer to input array, real data from +2
  64+ 5EC1              ; +02 = source data pointer
  65+ 5EC1              ; +04 = source number of bytes in a row
  66+ 5EC1              ; +06 = number of rows
  67+ 5EC1              ; +08 = source add-to value till next row
  68+ 5EC1              ; +10 = destination pointer
  69+ 5EC1              ; +12 = destination add-to value till next row
  70+ 5EC1              BOXMEMCPY_DEFUSR:
  71+ 5EC1 21 CE 5E     	LD HL,BOXMEMCPY_COMMON
  72+ 5EC4 22 47 5F     	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
  73+ 5EC7 DD 23        	INC IX
  74+ 5EC9 DD 23        	INC IX
  75+ 5ECB C3 43 5F     	JP BOXCOMMON_DEFUSR
  76+ 5ECE               ENDIF
  77+ 5ECE
  78+ 5ECE              BOXMEMCPY_COMMON:
  79+ 5ECE FB           	EI
  80+ 5ECF              	; set RAM functions to call
  81+ 5ECF 21 00 00     	LD HL, 0
  82+ 5ED2 22 9C 5E     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
  83+ 5ED5 22 9E 5E     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
  84+ 5ED8 21 ED B0     	LD HL, #B0ED ; LDIR
  85+ 5EDB 22 A0 5E     	LD (RECTANGLE_COPY.CALL1+4), HL
  86+ 5EDE C3 4C 5F     	JP BOXCOMMON_DEFUSR.CALL
  87+ 5EE1              ; *******************************************************************************************************
  88+ 5EE1
  89+ 5EE1               IF (BASIC_EXTENSION == 1)
  90+ 5EE1              ; *******************************************************************************************************
  91+ 5EE1              ; common parts of BOX commands to load parameters
  92+ 5EE1              BOX_EXTENSION_PARAMS_COMMON:
  93+ 5EE1              	; opening (
  94+ 5EE1 CD 43 6A     	CALL CHKCHAR
  95+ 5EE4 28           	DB '('
  96+ 5EE5              	; get source data pointer
  97+ 5EE5 DD 21 2F 54  	LD IX, FRMQNT
  98+ 5EE9 CD 59 01     	CALL CALBAS
  99+ 5EEC ED 53 34 67  	LD (BLIT_STRUCT+0), DE
 100+ 5EF0              	; comma
 101+ 5EF0 CD 43 6A     	CALL CHKCHAR
 102+ 5EF3 2C           	DB ','
 103+ 5EF4              	; source number of bytes in a row
 104+ 5EF4 DD 21 2F 54  	LD IX, FRMQNT
 105+ 5EF8 CD 59 01     	CALL CALBAS
 106+ 5EFB ED 53 36 67  	LD (BLIT_STRUCT+2), DE
 107+ 5EFF              	; comma
 108+ 5EFF CD 43 6A     	CALL CHKCHAR
 109+ 5F02 2C           	DB ','
 110+ 5F03              	; number of rows
 111+ 5F03 DD 21 2F 54  	LD IX, FRMQNT
 112+ 5F07 CD 59 01     	CALL CALBAS
 113+ 5F0A ED 53 38 67  	LD (BLIT_STRUCT+4), DE
 114+ 5F0E              	; comma
 115+ 5F0E CD 43 6A     	CALL CHKCHAR
 116+ 5F11 2C           	DB ','
 117+ 5F12              	; source add-to value till next row
 118+ 5F12 DD 21 2F 54  	LD IX, FRMQNT
 119+ 5F16 CD 59 01     	CALL CALBAS
 120+ 5F19 ED 53 3A 67  	LD (BLIT_STRUCT+6), DE
 121+ 5F1D              	; comma
 122+ 5F1D CD 43 6A     	CALL CHKCHAR
 123+ 5F20 2C           	DB ','
 124+ 5F21              	; destination pointer
 125+ 5F21 DD 21 2F 54  	LD IX, FRMQNT
 126+ 5F25 CD 59 01     	CALL CALBAS
 127+ 5F28 ED 53 3C 67  	LD (BLIT_STRUCT+8), DE
 128+ 5F2C              	; comma
 129+ 5F2C CD 43 6A     	CALL CHKCHAR
 130+ 5F2F 2C           	DB ','
 131+ 5F30              	; destination add-to value till next row
 132+ 5F30 DD 21 2F 54  	LD IX, FRMQNT
 133+ 5F34 CD 59 01     	CALL CALBAS
 134+ 5F37 ED 53 3E 67  	LD (BLIT_STRUCT+10), DE
 135+ 5F3B              	; ending )
 136+ 5F3B CD 43 6A     	CALL CHKCHAR
 137+ 5F3E 29           	DB ')'
 138+ 5F3F DD 21 34 67  	LD IX,BLIT_STRUCT
 139+ 5F43               ENDIF
 140+ 5F43              BOXCOMMON_DEFUSR:
 141+ 5F43 E5           	PUSH HL ; save position in BASIC buffer
 142+ 5F44 F3           	DI
 143+ 5F45              .ADDR:
 144+ 5F45 FD 21 00 00  	LD IY, 0 ; modified by code
 145+ 5F49 C3 F5 69     	JP ENABLE_PAGE0
 146+ 5F4C              .CALL:
 147+ 5F4C CD 84 5E     	CALL RECTANGLE_COPY
 148+ 5F4F AF           	XOR A
 149+ 5F50 32 45 67     	LD (VRAM_UPDATE_IN_PROGRESS),A
 150+ 5F53
 151+ 5F53 D1               POP DE
 152+ 5F54 C1               POP BC
 153+ 5F55 CD 6C 69         CALL RESTORE_PAGE_INFO
 154+ 5F58
 155+ 5F58 E1           	POP HL
 156+ 5F59 C9           	RET
 157+ 5F5A              ; *******************************************************************************************************
 158+ 5F5A
 159+ 5F5A               IF (BASIC_EXTENSION == 1)
 160+ 5F5A              ; *******************************************************************************************************
 161+ 5F5A              ; function to handle CALL BOXMEMVRM basic extension
 162+ 5F5A              ; copies data with window like boundaries from ram to Vram
 163+ 5F5A              ; BOXMEMVRM ( INT source data pointer,
 164+ 5F5A              ;			  INT source number of bytes in a row,
 165+ 5F5A              ;			  INT number of rows,
 166+ 5F5A              ;			  INT source add-to value till next row,
 167+ 5F5A              ; 			  INT destination pointer,
 168+ 5F5A              ;			  INT destination add-to value till next row )
 169+ 5F5A              ; request_data_ptr described in RECTANGLE_COPY
 170+ 5F5A              ; will put ram in page 0 also, page 1 is already there
 171+ 5F5A              BOXMEMVRM:
 172+ 5F5A 11 71 5F     	LD DE,BOXMEMVRM_COMMON
 173+ 5F5D ED 53 47 5F  	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
 174+ 5F61 C3 E1 5E     	JP BOX_EXTENSION_PARAMS_COMMON
 175+ 5F64               ENDIF
 176+ 5F64
 177+ 5F64               IF (DEFUSR_EXTENSION == 1)
 178+ 5F64              ; *******************************************************************************************************
 179+ 5F64              ; same as BOXMEMVRM but for DEFUSR approach
 180+ 5F64              ; input IX=pointer to input array, real data from +2
 181+ 5F64              ; +02 = source data pointer
 182+ 5F64              ; +04 = source number of bytes in a row
 183+ 5F64              ; +06 = number of rows
 184+ 5F64              ; +08 = source add-to value till next row
 185+ 5F64              ; +10 = destination pointer
 186+ 5F64              ; +12 = destination add-to value till next row
 187+ 5F64              BOXMEMVRM_DEFUSR:
 188+ 5F64 21 71 5F     	LD HL,BOXMEMVRM_COMMON
 189+ 5F67 22 47 5F     	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
 190+ 5F6A DD 23        	INC IX
 191+ 5F6C DD 23        	INC IX
 192+ 5F6E C3 43 5F     	JP BOXCOMMON_DEFUSR
 193+ 5F71               ENDIF
 194+ 5F71
 195+ 5F71              BOXMEMVRM_COMMON:
 196+ 5F71 FB           	EI
 197+ 5F72              	; set RAM functions to call
 198+ 5F72 21 8C 5F     	LD HL, .SETDEST
 199+ 5F75 22 9D 5E     	LD (RECTANGLE_COPY.CALL1+1), HL
 200+ 5F78 21 94 5F     	LD HL, .COPYDATA
 201+ 5F7B 22 A0 5E     	LD (RECTANGLE_COPY.CALL2+1), HL
 202+ 5F7E 3E CD        	LD A, #CD ; CALL
 203+ 5F80 32 9C 5E     	LD (RECTANGLE_COPY.CALL1), A
 204+ 5F83 32 9F 5E     	LD (RECTANGLE_COPY.CALL2), A
 205+ 5F86              	;LD A,1
 206+ 5F86 32 45 67     	LD (VRAM_UPDATE_IN_PROGRESS),A
 207+ 5F89 C3 4C 5F     	JP BOXCOMMON_DEFUSR.CALL
 208+ 5F8C              .SETDEST:
 209+ 5F8C EB           	EX DE, HL
 210+ 5F8D F3           	DI
 211+ 5F8E CD 1C 69     	CALL SETWRT_LOCAL
 212+ 5F91 FB           	EI
 213+ 5F92 EB           	EX DE, HL
 214+ 5F93 C9           	RET
 215+ 5F94              .COPYDATA:
 216+ 5F94 41           	LD B, C
 217+ 5F95 C3 27 69     	JP BBYTECOPY
 218+ 5F98              ; *******************************************************************************************************
# file closed: asm\BOX.asm
 153  5F98               ENDIF
 154  5F98
 155  5F98               IF (BLIT_CMDS == 1)
 156  5F98               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
   1+ 5F98              ; *******************************************************************************************************
   2+ 5F98              ; function rotates mask and data of several characters and applies to background data
   3+ 5F98              ; this handles x-shift from 0 to 4
   4+ 5F98              ; contains self-modifying code that is set-up from external function
   5+ 5F98              ; input HL=pointer to mask data
   6+ 5F98              ; input HL'=pointer to character data
   7+ 5F98              ; input DE=output buffer containing background data
   8+ 5F98              ; input BC=DE+8
   9+ 5F98              ; input A=number of characters to process
  10+ 5F98              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  11+ 5F98              SHIFT04:
  12+ 5F98 08           	EX AF, AF'
  13+ 5F99 7E           	LD A, (HL) ; get mask
  14+ 5F9A D9           	EXX
  15+ 5F9B 57           	LD D, A
  16+ 5F9C 1E FF        	LD E, #FF
  17+ 5F9E 37           	SCF
  18+ 5F9F              .M1:
  19+ 5F9F 18 FE        	JR .M1 ; this is self-modifying part
  20+ 5FA1 CB 1A        	RR D
  21+ 5FA3 CB 1B        	RR E
  22+ 5FA5 CB 1A        	RR D
  23+ 5FA7 CB 1B        	RR E
  24+ 5FA9 CB 1A        	RR D
  25+ 5FAB CB 1B        	RR E
  26+ 5FAD CB 1A        	RR D
  27+ 5FAF CB 1B        	RR E
  28+ 5FB1
  29+ 5FB1 46           	LD B, (HL) ; get data
  30+ 5FB2 0E 00        	LD C, 0
  31+ 5FB4              .M2:
  32+ 5FB4 18 FE        	JR .M2 ; also self-modifying part
  33+ 5FB6 CB 38        	SRL B
  34+ 5FB8 CB 19        	RR C
  35+ 5FBA CB 38        	SRL B
  36+ 5FBC CB 19        	RR C
  37+ 5FBE CB 38        	SRL B
  38+ 5FC0 CB 19        	RR C
  39+ 5FC2 CB 38        	SRL B
  40+ 5FC4 CB 19        	RR C
  41+ 5FC6
  42+ 5FC6 D9           	EXX
  43+ 5FC7 1A           	LD A, (DE) ; background
  44+ 5FC8 D9           	EXX
  45+ 5FC9 A2           	AND D
  46+ 5FCA B0           	OR B
  47+ 5FCB D9           	EXX
  48+ 5FCC 12           	LD (DE), A
  49+ 5FCD
  50+ 5FCD 0A           	LD A, (BC)
  51+ 5FCE D9           	EXX
  52+ 5FCF A3           	AND E
  53+ 5FD0 B1           	OR C
  54+ 5FD1 23           	INC HL
  55+ 5FD2 D9           	EXX
  56+ 5FD3 02           	LD (BC), A
  57+ 5FD4
  58+ 5FD4 23           	INC HL
  59+ 5FD5 13           	INC DE
  60+ 5FD6 03           	INC BC
  61+ 5FD7
  62+ 5FD7 08           	EX AF, AF'
  63+ 5FD8 3D           	DEC A
  64+ 5FD9 C2 98 5F     	JP NZ, SHIFT04
  65+ 5FDC C9           	RET
  66+ 5FDD              ; *******************************************************************************************************
  67+ 5FDD
  68+ 5FDD              ; *******************************************************************************************************
  69+ 5FDD              ; function rotates mask and data of several characters and applies to background data
  70+ 5FDD              ; this handles x-shift from 5 to 8
  71+ 5FDD              ; contains self-modifying code that is set-up from external function
  72+ 5FDD              ; input HL=pointer to mask data
  73+ 5FDD              ; input HL'=pointer to character data
  74+ 5FDD              ; input DE=output buffer containing background data
  75+ 5FDD              ; input BC=DE+8
  76+ 5FDD              ; input A=number of characters to process
  77+ 5FDD              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  78+ 5FDD              SHIFT58:
  79+ 5FDD 08           	EX AF, AF'
  80+ 5FDE 7E           	LD A, (HL) ; get mask
  81+ 5FDF D9           	EXX
  82+ 5FE0 57           	LD D, A
  83+ 5FE1 1E FF        	LD E, #FF
  84+ 5FE3 37           	SCF
  85+ 5FE4              .M1:
  86+ 5FE4 18 FE        	JR .M1 ; this is self-modifying part
  87+ 5FE6 CB 12        	RL D
  88+ 5FE8 CB 13        	RL E
  89+ 5FEA CB 12        	RL D
  90+ 5FEC CB 13        	RL E
  91+ 5FEE CB 12        	RL D
  92+ 5FF0 CB 13        	RL E
  93+ 5FF2
  94+ 5FF2 46           	LD B, (HL)
  95+ 5FF3 0E 00        	LD C, 0
  96+ 5FF5              .M2:
  97+ 5FF5 18 FE        	JR .M2 ; also self-modifying part
  98+ 5FF7 CB 20        	SLA B
  99+ 5FF9 CB 11        	RL C
 100+ 5FFB CB 20        	SLA B
 101+ 5FFD CB 11        	RL C
 102+ 5FFF CB 20        	SLA B
 103+ 6001 CB 11        	RL C
 104+ 6003
 105+ 6003 D9           	EXX
 106+ 6004 1A           	LD A, (DE) ; background
 107+ 6005 D9           	EXX
 108+ 6006 A3           	AND E
 109+ 6007 B1           	OR C
 110+ 6008 D9           	EXX
 111+ 6009 12           	LD (DE), A
 112+ 600A
 113+ 600A 0A           	LD A, (BC)
 114+ 600B D9           	EXX
 115+ 600C A2           	AND D
 116+ 600D B0           	OR B
 117+ 600E 23           	INC HL
 118+ 600F D9           	EXX
 119+ 6010 02           	LD (BC), A
 120+ 6011
 121+ 6011 23           	INC HL
 122+ 6012 13           	INC DE
 123+ 6013 03           	INC BC
 124+ 6014
 125+ 6014 08           	EX AF, AF'
 126+ 6015 3D           	DEC A
 127+ 6016 C2 DD 5F     	JP NZ, SHIFT58
 128+ 6019 C9           	RET
 129+ 601A              ; *******************************************************************************************************
 130+ 601A
 131+ 601A              ; *******************************************************************************************************
 132+ 601A              ; routine that shifts one row of characters
 133+ 601A              ; contains self-modifying code that is set-up from external function
 134+ 601A              ; input HL=pointer to mask data
 135+ 601A              ; input HL'=pointer to character data
 136+ 601A              ; input DE=output buffer containing background data
 137+ 601A              ; input A=number of characters to process
 138+ 601A              ; input IX=pointer to structure describing input data
 139+ 601A              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 140+ 601A              SHIFT_ROW:
 141+ 601A F5           	PUSH AF
 142+ 601B ED 53 30 67  		LD (BLIT_TMP1), DE
 143+ 601F E5           		PUSH HL
 144+ 6020 CD 63 60     			CALL .ADDYSHIFT
 145+ 6023 E1           		POP HL
 146+ 6024 ED 53 32 67  		LD (BLIT_TMP2), DE ; DE+vertical shift
 147+ 6028              .L1:
 148+ 6028 3E 08        		LD A, 8
 149+ 602A DD 96 02     		SUB (IX+2) ; y shift
 150+ 602D              .CALL1:
 151+ 602D CD 00 00     		CALL 0
 152+ 6030 DD 7E 02     		LD A, (IX+2); y shift
 153+ 6033 B7           		OR A
 154+ 6034 28 26        		JR Z, .DONE
 155+ 6036 ED 5B 30 67  		LD DE, (BLIT_TMP1)
 156+ 603A E5           		PUSH HL
 157+ 603B CD 71 60     			CALL .DETONEXTROW
 158+ 603E E1           		POP HL
 159+ 603F              .CALL2:
 160+ 603F CD 00 00     		CALL 0
 161+ 6042 ED 5B 30 67  		LD DE, (BLIT_TMP1)
 162+ 6046 E5           		PUSH HL
 163+ 6047 CD 6B 60     			CALL .ADD8
 164+ 604A E1           		POP HL
 165+ 604B ED 53 30 67  		LD (BLIT_TMP1), DE
 166+ 604F ED 5B 32 67  		LD DE, (BLIT_TMP2)
 167+ 6053 E5           		PUSH HL
 168+ 6054 CD 6B 60     			CALL .ADD8
 169+ 6057 E1           		POP HL
 170+ 6058 ED 53 32 67  		LD (BLIT_TMP2), DE ; DE+vertical shift
 171+ 605C              .DONE:
 172+ 605C F1           	POP AF
 173+ 605D 3D           	DEC A
 174+ 605E C8           	RET Z
 175+ 605F F5           	PUSH AF
 176+ 6060 C3 28 60     	JP .L1
 177+ 6063              .ADDYSHIFT:
 178+ 6063 EB           	EX DE, HL
 179+ 6064 16 00        	LD D, 0
 180+ 6066 DD 5E 02     	LD E, (IX+2); y shift
 181+ 6069 18 0C        	JR .MOVDEBC
 182+ 606B              .ADD8:
 183+ 606B 21 08 00     	LD HL, 8
 184+ 606E C3 77 60     	JP .MOVDEBC
 185+ 6071              .DETONEXTROW:
 186+ 6071 DD 6E 06     	LD L, (IX+6)
 187+ 6074 DD 66 07     	LD H, (IX+7) ; bkg add to value
 188+ 6077              .MOVDEBC:
 189+ 6077 19           	ADD HL, DE
 190+ 6078 54           	LD D, H
 191+ 6079 5D           	LD E, L
 192+ 607A 01 08 00     	LD BC, 8
 193+ 607D 09           	ADD HL, BC
 194+ 607E 44           	LD B, H
 195+ 607F 4D           	LD C, L
 196+ 6080 C9           	RET
 197+ 6081              ; *******************************************************************************************************
 198+ 6081
 199+ 6081              ; *******************************************************************************************************
 200+ 6081              ; function rotates mask and character data and applies it to background
 201+ 6081              ; input IX=pointer to structure describing input data
 202+ 6081              ; +0  DW horizontal shift count 0-7 (low byte used)
 203+ 6081              ; +2  DW vertical shift count 0-7 (low byte used)
 204+ 6081              ; +4  DW background data start;
 205+ 6081              ; +6  DW background add to value to next row of background data
 206+ 6081              ; +8  DW mask data start;
 207+ 6081              ; +10  DW character data start;
 208+ 6081              ; +12 DW character&mask add to value to next row of data
 209+ 6081              ; +14 DW columns (low byte used)
 210+ 6081              ; +16 DW rows (low byte used)
 211+ 6081              SHIFT_MERGE_CHARACTER:
 212+ 6081 DD 7E 00     	LD A, (IX) ; shift
 213+ 6084 FE 05        	CP 5
 214+ 6086 38 25        	JR C, .RIGHT
 215+ 6088              	; shifts 5-7, use rotate towards left 1-3
 216+ 6088 21 DD 5F     	LD HL, SHIFT58
 217+ 608B 22 2E 60     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 218+ 608E 22 40 60     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 219+ 6091 D6 05        	SUB 5
 220+ 6093 28 0D        	JR Z, .L1
 221+ 6095 87           	ADD A, A
 222+ 6096 87           	ADD A, A
 223+ 6097 67           	LD H, A
 224+ 6098 2E 18        	LD L, #18 ; JR opcode
 225+ 609A 22 E4 5F     	LD (SHIFT58.M1), HL
 226+ 609D 22 F5 5F     	LD (SHIFT58.M2), HL
 227+ 60A0 18 32        	JR .DO
 228+ 60A2              .L1:
 229+ 60A2 21 00 00     	LD HL, 0 ; 2xNOP opcode
 230+ 60A5 22 E4 5F     	LD (SHIFT58.M1), HL
 231+ 60A8 22 F5 5F     	LD (SHIFT58.M2), HL
 232+ 60AB 18 27        	JR .DO
 233+ 60AD              .RIGHT:
 234+ 60AD              	; shifts 0-4, rotate towards right
 235+ 60AD 21 98 5F     	LD HL, SHIFT04
 236+ 60B0 22 2E 60     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 237+ 60B3 22 40 60     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 238+ 60B6 FE 04        	CP 4
 239+ 60B8 28 11        	JR Z, .R1
 240+ 60BA D6 04        	SUB 4
 241+ 60BC ED 44        	NEG
 242+ 60BE 87           	ADD A, A
 243+ 60BF 87           	ADD A, A
 244+ 60C0 67           	LD H, A
 245+ 60C1 2E 18        	LD L, #18 ; JR opcode
 246+ 60C3 22 9F 5F     	LD (SHIFT04.M1), HL
 247+ 60C6 22 B4 5F     	LD (SHIFT04.M2), HL
 248+ 60C9 18 09        	JR .DO
 249+ 60CB              .R1:
 250+ 60CB 21 00 00     	LD HL, 0 ; 2xNOP opcode
 251+ 60CE 22 9F 5F     	LD (SHIFT04.M1), HL
 252+ 60D1 22 B4 5F     	LD (SHIFT04.M2), HL
 253+ 60D4              .DO:
 254+ 60D4 DD 46 10     	LD B, (IX+16) ; rows
 255+ 60D7 DD 6E 08     	LD L, (IX+8)
 256+ 60DA DD 66 09     	LD H, (IX+9) ; mask data
 257+ 60DD DD 5E 04     	LD E, (IX+4)
 258+ 60E0 DD 56 05     	LD D, (IX+5) ; background data
 259+ 60E3 D9           	EXX
 260+ 60E4 DD 6E 0A     	LD L, (IX+10)
 261+ 60E7 DD 66 0B     	LD H, (IX+11) ; character data
 262+ 60EA D9           	EXX
 263+ 60EB              .LOOP:
 264+ 60EB C5           	PUSH BC
 265+ 60EC E5           		PUSH HL
 266+ 60ED D5           			PUSH DE
 267+ 60EE D9           				EXX
 268+ 60EF E5           				PUSH HL
 269+ 60F0 D9           					EXX
 270+ 60F1 DD 7E 0E     					LD A, (IX+14) ; columns
 271+ 60F4              .CALL:
 272+ 60F4 CD 1A 60     					CALL SHIFT_ROW
 273+ 60F7 E1           				POP HL
 274+ 60F8 DD 5E 0C     				LD E, (IX+12)
 275+ 60FB DD 56 0D     				LD D, (IX+13) ; char data to next row
 276+ 60FE 19           				ADD HL, DE
 277+ 60FF D9           				EXX
 278+ 6100 E1           			POP HL
 279+ 6101 DD 5E 06     			LD E, (IX+6)
 280+ 6104 DD 56 07     			LD D, (IX+7) ; background to next row
 281+ 6107 19           			ADD HL, DE
 282+ 6108 EB           			EX DE, HL
 283+ 6109 E1           		POP HL
 284+ 610A DD 4E 0C     		LD C, (IX+12)
 285+ 610D DD 46 0D     		LD B, (IX+13) ; char data to next row
 286+ 6110 09           		ADD HL, BC
 287+ 6111 C1           	POP BC
 288+ 6112 10 D7        	DJNZ .LOOP
 289+ 6114 C9           	RET
 290+ 6115              ; *******************************************************************************************************
 291+ 6115
 292+ 6115              ; *******************************************************************************************************
 293+ 6115              ; helper function DE \ 8
 294+ 6115              DEdiv8:
 295+ 6115 7B           	LD A,E
 296+ 6116 CB 2A        	SRA D
 297+ 6118 CB 1F            RR  A
 298+ 611A CB 2A            SRA D
 299+ 611C CB 1F            RR  A
 300+ 611E CB 2A            SRA D
 301+ 6120 CB 1F            RR  A
 302+ 6122 C9           	RET
 303+ 6123              ; *******************************************************************************************************
 304+ 6123
 305+ 6123               IF (DEFUSR_EXTENSION == 1)
 306+ 6123              ; *******************************************************************************************************
 307+ 6123              ; function to handle BLIT basic extension through DEFUSR call in RAW format
 308+ 6123              ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 309+ 6123              ; +2  DW horizontal shift count 0-7 (low byte used)
 310+ 6123              ; +4  DW vertical shift count 0-7 (low byte used)
 311+ 6123              ; +6  DW background data start;
 312+ 6123              ; +8  DW background add to value to next row of background data
 313+ 6123              ; +10  DW mask data start;
 314+ 6123              ; +12  DW character data start;
 315+ 6123              ; +14 DW character&mask add to value to next row of data
 316+ 6123              ; +16 DW columns (low byte used)
 317+ 6123              ; +18 DW rows (low byte used)
 318+ 6123              ; will put ram in page 0 also, page 1 is already there
 319+ 6123              ;BLIT_DEFUSR:
 320+ 6123              ;	DI
 321+ 6123              ;	LD IY, .RET
 322+ 6123              ;	JP ENABLE_PAGE0
 323+ 6123              ;.RET:
 324+ 6123              ;	EI
 325+ 6123              ;	INC IX
 326+ 6123              ;	INC IX
 327+ 6123              ;	CALL SHIFT_MERGE_CHARACTER
 328+ 6123              ;
 329+ 6123              ;   POP DE
 330+ 6123              ;    POP BC
 331+ 6123              ;    JP RESTORE_PAGE_INFO
 332+ 6123              ; *******************************************************************************************************
 333+ 6123
 334+ 6123              ; *******************************************************************************************************
 335+ 6123              ; function to handle CALL BLIT basic extension in DEFUSR form
 336+ 6123              ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 337+ 6123              ; +02 x
 338+ 6123              ; +04 y
 339+ 6123              ; +06 char_data_pointer
 340+ 6123              ; +08 mask_data_pointer
 341+ 6123              ; +10 width
 342+ 6123              ; +12 height
 343+ 6123              ; +14 background_pointer
 344+ 6123              ; +16 background_width
 345+ 6123              ; BLIT ( INT x,
 346+ 6123              ;		 INT y,
 347+ 6123              ;		 INT char_data_pointer,
 348+ 6123              ;		 INT mask_data_pointer,
 349+ 6123              ;		 INT width (in characters),
 350+ 6123              ;		 INT height (in characters),
 351+ 6123              ;		 INT background_pointer (top left),
 352+ 6123              ;		 INT background_width (in characters),
 353+ 6123              BLIT_DEFUSR:
 354+ 6123 DD 5E 02     	LD E,(IX+2)
 355+ 6126 DD 56 03     	LD D,(IX+3)
 356+ 6129 7B           	LD A,E
 357+ 612A E6 07        	AND 7
 358+ 612C 32 34 67     	LD (BLIT_STRUCT+0),A
 359+ 612F CD 15 61     	CALL DEdiv8
 360+ 6132 32 30 67     	LD (BLIT_TMP+0),A
 361+ 6135 DD 5E 04     	LD E,(IX+4)
 362+ 6138 DD 56 05     	LD D,(IX+5)
 363+ 613B 7B           	LD A,E
 364+ 613C E6 07        	AND 7
 365+ 613E 32 36 67     	LD (BLIT_STRUCT+2),A
 366+ 6141 CD 15 61     	CALL DEdiv8
 367+ 6144 32 31 67     	LD (BLIT_TMP+1),A
 368+ 6147 DD 6E 06     	LD L,(IX+6)
 369+ 614A DD 66 07     	LD H,(IX+7)
 370+ 614D 22 3E 67     	LD (BLIT_STRUCT+10),HL
 371+ 6150 DD 6E 08     	LD L,(IX+8)
 372+ 6153 DD 66 09     	LD H,(IX+9)
 373+ 6156 22 3C 67     	LD (BLIT_STRUCT+8),HL
 374+ 6159 DD 7E 0A     	LD A,(IX+10)
 375+ 615C 32 42 67     	LD (BLIT_STRUCT+14),A
 376+ 615F DD 7E 0C     	LD A,(IX+12)
 377+ 6162 32 44 67     	LD (BLIT_STRUCT+16),A
 378+ 6165 DD 6E 0E     	LD L,(IX+14)
 379+ 6168 DD 66 0F     	LD H,(IX+15)
 380+ 616B 22 38 67     	LD (BLIT_STRUCT+4),HL
 381+ 616E              	;LD A,(IX+16)
 382+ 616E              	;LD (BLIT_TMP+2),A
 383+ 616E
 384+ 616E              	; calculate char&mask add to value
 385+ 616E 26 00        	LD H,0
 386+ 6170 3A 42 67     	LD A,(BLIT_STRUCT+14)
 387+ 6173 6F           	LD L,A
 388+ 6174 CD 31 69     	CALL HLx8
 389+ 6177 22 40 67     	LD (BLIT_STRUCT+12),HL
 390+ 617A              	; calculate background add to value
 391+ 617A 26 00        	LD H,0
 392+ 617C DD 6E 10     	LD L,(IX+16)
 393+ 617F CD 31 69     	CALL HLx8
 394+ 6182 22 3A 67     	LD (BLIT_STRUCT+6),HL
 395+ 6185              	; calculate pointer to background location
 396+ 6185 21 00 00     	LD HL,0
 397+ 6188 3A 31 67     	LD A,(BLIT_TMP+1)
 398+ 618B B7           	OR A
 399+ 618C 28 08        	JR Z, .L1
 400+ 618E 47           	LD B,A
 401+ 618F ED 5B 3A 67  	LD DE,(BLIT_STRUCT+6)
 402+ 6193              .L0:
 403+ 6193 19           	ADD HL, DE
 404+ 6194 10 FD        	DJNZ .L0
 405+ 6196              .L1:
 406+ 6196 EB           	EX DE,HL
 407+ 6197 26 00        	LD H,0
 408+ 6199 3A 30 67     	LD A,(BLIT_TMP+0)
 409+ 619C 6F           	LD L,A
 410+ 619D CD 31 69     	CALL HLx8
 411+ 61A0 19           	ADD HL,DE
 412+ 61A1 ED 5B 38 67  	LD DE,(BLIT_STRUCT+4)
 413+ 61A5 19           	ADD HL,DE
 414+ 61A6 22 38 67     	LD (BLIT_STRUCT+4),HL
 415+ 61A9
 416+ 61A9 F3           	DI
 417+ 61AA FD 21 B1 61  	LD IY, .RET
 418+ 61AE C3 F5 69     	JP ENABLE_PAGE0
 419+ 61B1              .RET:
 420+ 61B1 FB           	EI
 421+ 61B2 DD 21 34 67  	LD IX, BLIT_STRUCT
 422+ 61B6 CD 81 60     	CALL SHIFT_MERGE_CHARACTER
 423+ 61B9
 424+ 61B9 D1               POP DE
 425+ 61BA C1               POP BC
 426+ 61BB C3 6C 69         JP RESTORE_PAGE_INFO
 427+ 61BE              ; *******************************************************************************************************
 428+ 61BE               ENDIF
 429+ 61BE
 430+ 61BE               IF (BASIC_EXTENSION == 1)
 431+ 61BE              ; *******************************************************************************************************
 432+ 61BE              ; function to handle CALL BLIT basic extension
 433+ 61BE              ; rotates 1-bit character drawing horizontally with mask and character data and
 434+ 61BE              ; fuses with background data and applies vertical shift too
 435+ 61BE              ; in form without pointers
 436+ 61BE              ; BLIT ( INT x,
 437+ 61BE              ;		 INT y,
 438+ 61BE              ;		 INT char_data_pointer,
 439+ 61BE              ;		 INT mask_data_pointer,
 440+ 61BE              ;		 INT width (in characters),
 441+ 61BE              ;		 INT height (in characters),
 442+ 61BE              ;		 INT background_pointer (top left),
 443+ 61BE              ;		 INT background_width (in characters),
 444+ 61BE              ; will put ram in page 0 also, page 1 is already there
 445+ 61BE              BLIT:
 446+ 61BE              	; opening (
 447+ 61BE CD 43 6A     	CALL CHKCHAR
 448+ 61C1 28           	DB '('
 449+ 61C2              	; get x coordinate
 450+ 61C2 DD 21 2F 54  	LD IX, FRMQNT
 451+ 61C6 CD 59 01     	CALL CALBAS
 452+ 61C9 7B           	LD A, E
 453+ 61CA E6 07        	AND 7
 454+ 61CC 32 34 67     	LD (BLIT_STRUCT+0), A
 455+ 61CF CD 15 61     	CALL DEdiv8
 456+ 61D2 32 30 67     	LD (BLIT_TMP+0),A
 457+ 61D5              	; comma
 458+ 61D5 CD 43 6A     	CALL CHKCHAR
 459+ 61D8 2C           	DB ','
 460+ 61D9              	; get y coordinate
 461+ 61D9 DD 21 2F 54  	LD IX, FRMQNT
 462+ 61DD CD 59 01     	CALL CALBAS
 463+ 61E0 7B           	LD A, E
 464+ 61E1 E6 07        	AND 7
 465+ 61E3 32 36 67     	LD (BLIT_STRUCT+2), A
 466+ 61E6 CD 15 61     	CALL DEdiv8
 467+ 61E9 32 31 67     	LD (BLIT_TMP+1),A
 468+ 61EC              	; comma
 469+ 61EC CD 43 6A     	CALL CHKCHAR
 470+ 61EF 2C           	DB ','
 471+ 61F0              	; get char data pointer
 472+ 61F0 DD 21 2F 54  	LD IX, FRMQNT
 473+ 61F4 CD 59 01     	CALL CALBAS
 474+ 61F7 ED 53 3E 67  	LD (BLIT_STRUCT+10), DE
 475+ 61FB              	; comma
 476+ 61FB CD 43 6A     	CALL CHKCHAR
 477+ 61FE 2C           	DB ','
 478+ 61FF              	; get mask data pointer
 479+ 61FF DD 21 2F 54  	LD IX, FRMQNT
 480+ 6203 CD 59 01     	CALL CALBAS
 481+ 6206 ED 53 3C 67  	LD (BLIT_STRUCT+8), DE
 482+ 620A              	; comma
 483+ 620A CD 43 6A     	CALL CHKCHAR
 484+ 620D 2C           	DB ','
 485+ 620E              	; get width
 486+ 620E DD 21 2F 54  	LD IX, FRMQNT
 487+ 6212 CD 59 01     	CALL CALBAS
 488+ 6215 7B           	LD A, E
 489+ 6216 32 42 67     	LD (BLIT_STRUCT+14), A
 490+ 6219              	; comma
 491+ 6219 CD 43 6A     	CALL CHKCHAR
 492+ 621C 2C           	DB ','
 493+ 621D              	; get height
 494+ 621D DD 21 2F 54  	LD IX, FRMQNT
 495+ 6221 CD 59 01     	CALL CALBAS
 496+ 6224 7B           	LD A, E
 497+ 6225 32 44 67     	LD (BLIT_STRUCT+16), A
 498+ 6228              	; comma
 499+ 6228 CD 43 6A     	CALL CHKCHAR
 500+ 622B 2C           	DB ','
 501+ 622C              	; get background pointer
 502+ 622C DD 21 2F 54  	LD IX, FRMQNT
 503+ 6230 CD 59 01     	CALL CALBAS
 504+ 6233 ED 53 38 67  	LD (BLIT_STRUCT+4), DE
 505+ 6237              	; comma
 506+ 6237 CD 43 6A     	CALL CHKCHAR
 507+ 623A 2C           	DB ','
 508+ 623B              	; get background width
 509+ 623B DD 21 2F 54  	LD IX, FRMQNT
 510+ 623F CD 59 01     	CALL CALBAS
 511+ 6242 7B           	LD A, E
 512+ 6243 32 32 67     	LD (BLIT_TMP+2), A
 513+ 6246              	; ending )
 514+ 6246 CD 43 6A     	CALL CHKCHAR
 515+ 6249 29           	DB ')'
 516+ 624A
 517+ 624A E5           	PUSH HL ; save position in BASIC buffer
 518+ 624B
 519+ 624B              	; calculate char&mask add to value
 520+ 624B 26 00        	LD H, 0
 521+ 624D 3A 42 67     	LD A, (BLIT_STRUCT+14)
 522+ 6250 6F           	LD L, A
 523+ 6251 CD 31 69     	CALL HLx8
 524+ 6254 22 40 67     	LD (BLIT_STRUCT+12), HL
 525+ 6257              	; calculate background add to value
 526+ 6257 26 00        	LD H, 0
 527+ 6259 3A 32 67     	LD A, (BLIT_TMP+2)
 528+ 625C 6F           	LD L, A
 529+ 625D CD 31 69     	CALL HLx8
 530+ 6260 22 3A 67     	LD (BLIT_STRUCT+6), HL
 531+ 6263              	; calculate pointer to background location
 532+ 6263 21 00 00     	LD HL, 0
 533+ 6266 3A 31 67     	LD A,(BLIT_TMP+1)
 534+ 6269 B7           	OR A
 535+ 626A 28 08        	JR Z, .L1
 536+ 626C 47           	LD B,A
 537+ 626D ED 5B 3A 67  	LD DE,(BLIT_STRUCT+6)
 538+ 6271              .L0:
 539+ 6271 19           	ADD HL, DE
 540+ 6272 10 FD        	DJNZ .L0
 541+ 6274              .L1:
 542+ 6274 EB           	EX DE,HL
 543+ 6275 26 00        	LD H,0
 544+ 6277 3A 30 67     	LD A,(BLIT_TMP+0)
 545+ 627A 6F           	LD L,A
 546+ 627B CD 31 69     	CALL HLx8
 547+ 627E 19           	ADD HL,DE
 548+ 627F ED 5B 38 67  	LD DE,(BLIT_STRUCT+4)
 549+ 6283 19           	ADD HL,DE
 550+ 6284 22 38 67     	LD (BLIT_STRUCT+4),HL
 551+ 6287
 552+ 6287 F3           	DI
 553+ 6288 FD 21 8F 62  	LD IY, .RET
 554+ 628C C3 F5 69     	JP ENABLE_PAGE0
 555+ 628F              .RET:
 556+ 628F FB           	EI
 557+ 6290 DD 21 34 67  	LD IX, BLIT_STRUCT
 558+ 6294 CD 81 60     	CALL SHIFT_MERGE_CHARACTER
 559+ 6297
 560+ 6297 D1               POP DE
 561+ 6298 C1               POP BC
 562+ 6299 CD 6C 69         CALL RESTORE_PAGE_INFO
 563+ 629C
 564+ 629C E1           	POP HL
 565+ 629D C9           	RET
 566+ 629E              ; *******************************************************************************************************
 567+ 629E               ENDIF
# file closed: asm\BLIT.asm
 157  629E               ENDIF
 158  629E
 159  629E               IF (TILE_CMDS == 1)
 160  629E               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
   1+ 629E              ; *******************************************************************************************************
   2+ 629E              ; generic function to implement tiling
   3+ 629E              ; should be modified to call appropriate function for memory or vram
   4+ 629E              ; input IX=pointer to following structure
   5+ 629E              ; +00 tile_data_ptr
   6+ 629E              ; +02 tile_rows
   7+ 629E              ; +04 tile_columns
   8+ 629E              ; +06 destination_address
   9+ 629E              ; +08 dest_to_next_row_add_to_value
  10+ 629E              ; +10 num_horizontal_tiles
  11+ 629E              ; +12 num_vertical_tiles
  12+ 629E              ; modifies AF, BC, DE, HL
  13+ 629E              TILE:
  14+ 629E DD 6E 06     	LD L, (IX+6)
  15+ 62A1 DD 66 07     	LD H, (IX+7) ; destination address
  16+ 62A4 22 30 67     	LD (TILETMP1), HL
  17+ 62A7 DD 46 0C     	LD B, (IX+12) ; vertical tile number
  18+ 62AA              .L1:
  19+ 62AA C5           	PUSH BC
  20+ 62AB DD 6E 00     		LD L, (IX+0)
  21+ 62AE DD 66 01     		LD H, (IX+1) ; tile address
  22+ 62B1 22 32 67     		LD (TILETMP2), HL
  23+ 62B4 DD 46 02     		LD B, (IX+2) ; tile rows
  24+ 62B7              .L2:
  25+ 62B7 C5           		PUSH BC
  26+ 62B8 CD 00 00     .CALL1:		CALL 0
  27+ 62BB DD 46 0A     			LD B, (IX+10) ; horizontal tile num
  28+ 62BE              .L3:
  29+ 62BE C5           			PUSH BC
  30+ 62BF 2A 32 67     				LD HL, (TILETMP2)
  31+ 62C2 DD 46 04     				LD B, (IX+4) ; tile columns
  32+ 62C5              .L4:
  33+ 62C5 C5           				PUSH BC
  34+ 62C6              .CALL2:
  35+ 62C6 CD 00 00     					CALL 0
  36+ 62C9 C1           				POP BC
  37+ 62CA 10 F9        				DJNZ .L4
  38+ 62CC C1           			POP BC
  39+ 62CD 10 EF        			DJNZ .L3
  40+ 62CF 22 32 67     			LD (TILETMP2), HL
  41+ 62D2 2A 30 67     			LD HL, (TILETMP1)
  42+ 62D5 DD 5E 08     			LD E, (IX+8)
  43+ 62D8 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
  44+ 62DB 19           			ADD HL, DE
  45+ 62DC 22 30 67     			LD (TILETMP1), HL
  46+ 62DF C1           		POP BC
  47+ 62E0 10 D5        		DJNZ .L2
  48+ 62E2 C1           	POP BC
  49+ 62E3 10 C5        	DJNZ .L1
  50+ 62E5 C9           	RET
  51+ 62E6              ; *******************************************************************************************************
  52+ 62E6
  53+ 62E6               IF (DEFUSR_EXTENSION == 1)
  54+ 62E6              ; *******************************************************************************************************
  55+ 62E6              ; same as TILERAM but for DEFUSR approach
  56+ 62E6              ; input IX=pointer to input array, real data from +2
  57+ 62E6              ; +02 = tile data pointer
  58+ 62E6              ; +04 = tile columns
  59+ 62E6              ; +06 = tile rows
  60+ 62E6              ; +08 = destination pointer
  61+ 62E6              ; +10 = destination columns
  62+ 62E6              ; +12 = destination rows
  63+ 62E6              ; +14 = destination begin column
  64+ 62E6              ; +16 = destination begin row
  65+ 62E6              ; +18 = number of tiles horizontally
  66+ 62E6              ; +20 = number of tiles vertically
  67+ 62E6              ; *******************************************************************************************************
  68+ 62E6              TILERAM_DEFUSR:
  69+ 62E6              	; tile data pointer
  70+ 62E6 DD 6E 02     	LD L,(IX+2)
  71+ 62E9 DD 66 03     	LD H,(IX+3)
  72+ 62EC 22 34 67     	LD (BLIT_STRUCT+0),HL
  73+ 62EF              	; tile columns
  74+ 62EF DD 6E 04     	LD L,(IX+4)
  75+ 62F2 DD 66 05     	LD H,(IX+5)
  76+ 62F5 22 38 67     	LD (BLIT_STRUCT+4),HL
  77+ 62F8              	; tile rows
  78+ 62F8 DD 6E 06     	LD L,(IX+6)
  79+ 62FB DD 66 07     	LD H,(IX+7)
  80+ 62FE 22 36 67     	LD (BLIT_STRUCT+2),HL
  81+ 6301              	; destintion pointer
  82+ 6301 DD 6E 08     	LD L,(IX+8)
  83+ 6304 DD 66 09     	LD H,(IX+9)
  84+ 6307 22 3A 67     	LD (BLIT_STRUCT+6),HL
  85+ 630A              	; destination columns
  86+ 630A DD 7E 0A     	LD A,(IX+10)
  87+ 630D 32 30 67     	LD (BLIT_TMP+0),A
  88+ 6310              	; destination rows
  89+ 6310 DD 7E 0C     	LD A,(IX+12)
  90+ 6313 32 31 67     	LD (BLIT_TMP+1),A
  91+ 6316              	; destination begin column
  92+ 6316 DD 7E 0E     	LD A,(IX+14)
  93+ 6319 32 32 67     	LD (BLIT_TMP+2),A
  94+ 631C              	; destination begin row
  95+ 631C DD 7E 10     	LD A,(IX+16)
  96+ 631F 32 33 67     	LD (BLIT_TMP+3),A
  97+ 6322              	; number of tiles horizontally
  98+ 6322 DD 6E 12     	LD L,(IX+18)
  99+ 6325 DD 66 13     	LD H,(IX+19)
 100+ 6328 22 3E 67     	LD (BLIT_STRUCT+10),HL
 101+ 632B              	; number of tiles vertically
 102+ 632B DD 6E 14     	LD L,(IX+20)
 103+ 632E DD 66 15     	LD H,(IX+21)
 104+ 6331 22 40 67     	LD (BLIT_STRUCT+12),HL
 105+ 6334               IF (BASIC_EXTENSION == 1) ; otherwise we just continue with code below
 106+ 6334 C3 D1 63     	JP TILERAM.COMMON
 107+ 6337               ENDIF
 108+ 6337               ENDIF
 109+ 6337
 110+ 6337              ; *******************************************************************************************************
 111+ 6337              ; function to handle CALL TILERAM basic extension
 112+ 6337              ; fills memory with tiles
 113+ 6337              ; TILERAM ( INT tile_data_pointer,
 114+ 6337              ;			INT tile_columns,
 115+ 6337              ;			INT tile_rows,
 116+ 6337              ;			INT destination_pointer,
 117+ 6337              ;			INT destination_columns,
 118+ 6337              ;			INT destination_rows,
 119+ 6337              ;			INT destination_begin_column,
 120+ 6337              ;			INT destination_begin_row,
 121+ 6337              ;			INT number_of_tiles_horizontally,
 122+ 6337              ;			INT	number_of_tiles_vertically )
 123+ 6337              ; will put ram in page 0 also, page 1 is already there
 124+ 6337              TILERAM:
 125+ 6337               IF (BASIC_EXTENSION == 1)
 126+ 6337              	; opening (
 127+ 6337 CD 43 6A     	CALL CHKCHAR
 128+ 633A 28           	DB '('
 129+ 633B              	; get tile data pointer coordinate
 130+ 633B DD 21 2F 54  	LD IX, FRMQNT
 131+ 633F CD 59 01     	CALL CALBAS
 132+ 6342 ED 53 34 67  	LD (BLIT_STRUCT+0), DE
 133+ 6346              	; comma
 134+ 6346 CD 43 6A     	CALL CHKCHAR
 135+ 6349 2C           	DB ','
 136+ 634A              	; get tile columns
 137+ 634A DD 21 2F 54  	LD IX, FRMQNT
 138+ 634E CD 59 01     	CALL CALBAS
 139+ 6351 ED 53 38 67  	LD (BLIT_STRUCT+4), DE
 140+ 6355              	; comma
 141+ 6355 CD 43 6A     	CALL CHKCHAR
 142+ 6358 2C           	DB ','
 143+ 6359              	; get tile columns
 144+ 6359 DD 21 2F 54  	LD IX, FRMQNT
 145+ 635D CD 59 01     	CALL CALBAS
 146+ 6360 ED 53 36 67  	LD (BLIT_STRUCT+2), DE
 147+ 6364              	; comma
 148+ 6364 CD 43 6A     	CALL CHKCHAR
 149+ 6367 2C           	DB ','
 150+ 6368              	; get destintion pointer
 151+ 6368 DD 21 2F 54  	LD IX, FRMQNT
 152+ 636C CD 59 01     	CALL CALBAS
 153+ 636F ED 53 3A 67  	LD (BLIT_STRUCT+6), DE
 154+ 6373              	; comma
 155+ 6373 CD 43 6A     	CALL CHKCHAR
 156+ 6376 2C           	DB ','
 157+ 6377              	; get destination columns
 158+ 6377 DD 21 2F 54  	LD IX, FRMQNT
 159+ 637B CD 59 01     	CALL CALBAS
 160+ 637E 7B           	LD A, E
 161+ 637F 32 30 67     	LD (BLIT_TMP+0), A
 162+ 6382              	; comma
 163+ 6382 CD 43 6A     	CALL CHKCHAR
 164+ 6385 2C           	DB ','
 165+ 6386              	; get destination rows
 166+ 6386 DD 21 2F 54  	LD IX, FRMQNT
 167+ 638A CD 59 01     	CALL CALBAS
 168+ 638D 7B           	LD A, E
 169+ 638E 32 31 67     	LD (BLIT_TMP+1), A
 170+ 6391              	; comma
 171+ 6391 CD 43 6A     	CALL CHKCHAR
 172+ 6394 2C           	DB ','
 173+ 6395              	; get destination begin column
 174+ 6395 DD 21 2F 54  	LD IX, FRMQNT
 175+ 6399 CD 59 01     	CALL CALBAS
 176+ 639C 7B           	LD A, E
 177+ 639D 32 32 67     	LD (BLIT_TMP+2), A
 178+ 63A0              	; comma
 179+ 63A0 CD 43 6A     	CALL CHKCHAR
 180+ 63A3 2C           	DB ','
 181+ 63A4              	; get destination begin row
 182+ 63A4 DD 21 2F 54  	LD IX, FRMQNT
 183+ 63A8 CD 59 01     	CALL CALBAS
 184+ 63AB 7B           	LD A, E
 185+ 63AC 32 33 67     	LD (BLIT_TMP+3), A
 186+ 63AF              	; comma
 187+ 63AF CD 43 6A     	CALL CHKCHAR
 188+ 63B2 2C           	DB ','
 189+ 63B3              	; get number of tiles horizontally
 190+ 63B3 DD 21 2F 54  	LD IX, FRMQNT
 191+ 63B7 CD 59 01     	CALL CALBAS
 192+ 63BA ED 53 3E 67  	LD (BLIT_STRUCT+10), DE
 193+ 63BE              	; comma
 194+ 63BE CD 43 6A     	CALL CHKCHAR
 195+ 63C1 2C           	DB ','
 196+ 63C2              	; get number of tiles vertically
 197+ 63C2 DD 21 2F 54  	LD IX, FRMQNT
 198+ 63C6 CD 59 01     	CALL CALBAS
 199+ 63C9 ED 53 40 67  	LD (BLIT_STRUCT+12), DE
 200+ 63CD              	; ending )
 201+ 63CD CD 43 6A     	CALL CHKCHAR
 202+ 63D0 29           	DB ')'
 203+ 63D1               ENDIF
 204+ 63D1              .COMMON:
 205+ 63D1 E5           	PUSH HL ; save position in BASIC buffer
 206+ 63D2
 207+ 63D2              	; calculate destination add to value
 208+ 63D2 26 00        	LD H, 0
 209+ 63D4 3A 30 67     	LD A, (BLIT_TMP+0)
 210+ 63D7 6F           	LD L, A
 211+ 63D8 CD 31 69     	CALL HLx8
 212+ 63DB 22 3C 67     	LD (BLIT_STRUCT+8), HL
 213+ 63DE              	; calculate pointer to background location
 214+ 63DE 21 00 00     	LD HL, 0
 215+ 63E1 3A 33 67     	LD A,(BLIT_TMP+3)
 216+ 63E4 B7           	OR A
 217+ 63E5 28 08        	JR Z, .L1
 218+ 63E7 47           	LD B,A
 219+ 63E8 ED 5B 3C 67  	LD DE,(BLIT_STRUCT+8)
 220+ 63EC              .L0:
 221+ 63EC 19           	ADD HL, DE
 222+ 63ED 10 FD        	DJNZ .L0
 223+ 63EF              .L1:
 224+ 63EF EB           	EX DE,HL
 225+ 63F0 26 00        	LD H,0
 226+ 63F2 3A 32 67     	LD A,(BLIT_TMP+2)
 227+ 63F5 6F           	LD L,A
 228+ 63F6 CD 31 69     	CALL HLx8
 229+ 63F9 19           	ADD HL,DE
 230+ 63FA ED 5B 3A 67  	LD DE,(BLIT_STRUCT+6)
 231+ 63FE 19           	ADD HL,DE
 232+ 63FF 22 3A 67     	LD (BLIT_STRUCT+6),HL
 233+ 6402 F3           	DI
 234+ 6403 FD 21 0A 64  	LD IY, .RET
 235+ 6407 C3 F5 69     	JP ENABLE_PAGE0
 236+ 640A              .RET:
 237+ 640A FB           	EI
 238+ 640B              	; set RAM functions to call
 239+ 640B 21 25 64     	LD HL, .TILECOPY
 240+ 640E 22 C7 62     	LD (TILE.CALL2+1), HL
 241+ 6411 21 36 64     	LD HL, .SETDESTROW
 242+ 6414 22 B9 62     	LD (TILE.CALL1+1), HL
 243+ 6417 DD 21 34 67  	LD IX,BLIT_STRUCT
 244+ 641B CD 9E 62     	CALL TILE
 245+ 641E
 246+ 641E D1               POP DE
 247+ 641F C1               POP BC
 248+ 6420 CD 6C 69         CALL RESTORE_PAGE_INFO
 249+ 6423
 250+ 6423 E1           	POP HL
 251+ 6424 C9           	RET
 252+ 6425              .TILECOPY:
 253+ 6425 ED A0       > LDI
 253+ 6427 ED A0       > LDI
 253+ 6429 ED A0       > LDI
 253+ 642B ED A0       > LDI
 253+ 642D ED A0       > LDI
 253+ 642F ED A0       > LDI
 253+ 6431 ED A0       > LDI
 253+ 6433 ED A0       > LDI
 254+ 6435 C9           	RET
 255+ 6436              .SETDESTROW:
 256+ 6436 ED 5B 30 67  	LD DE, (TILETMP1)
 257+ 643A C9           	RET
 258+ 643B              ; *******************************************************************************************************
 259+ 643B
 260+ 643B              ; *******************************************************************************************************
 261+ 643B              ; function to handle CALL TILEVRM basic extension
 262+ 643B              ; fills vram with tiles
 263+ 643B              ; TILEVRM ( INT tile_data_pointer,
 264+ 643B              ;			INT tile_columns,
 265+ 643B              ;			INT tile_rows,
 266+ 643B              ;			INT destination_begin_column,
 267+ 643B              ;			INT destination_begin_row,
 268+ 643B              ;			INT number_of_tiles_horizontally,
 269+ 643B              ;			INT	number_of_tiles_vertically )
 270+ 643B              ; will put ram in page 0 also, page 1 is already there
 271+ 643B              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
 272+ 643B              TILEVRM:
 273+ 643B               IF (BASIC_EXTENSION == 1)
 274+ 643B              	; opening (
 275+ 643B CD 43 6A     	CALL CHKCHAR
 276+ 643E 28           	DB '('
 277+ 643F              	; get tile data pointer coordinate
 278+ 643F DD 21 2F 54  	LD IX, FRMQNT
 279+ 6443 CD 59 01     	CALL CALBAS
 280+ 6446 ED 53 34 67  	LD (BLIT_STRUCT+0), DE
 281+ 644A              	; comma
 282+ 644A CD 43 6A     	CALL CHKCHAR
 283+ 644D 2C           	DB ','
 284+ 644E              	; get tile columns
 285+ 644E DD 21 2F 54  	LD IX, FRMQNT
 286+ 6452 CD 59 01     	CALL CALBAS
 287+ 6455 ED 53 38 67  	LD (BLIT_STRUCT+4), DE
 288+ 6459              	; comma
 289+ 6459 CD 43 6A     	CALL CHKCHAR
 290+ 645C 2C           	DB ','
 291+ 645D              	; get tile columns
 292+ 645D DD 21 2F 54  	LD IX, FRMQNT
 293+ 6461 CD 59 01     	CALL CALBAS
 294+ 6464 ED 53 36 67  	LD (BLIT_STRUCT+2), DE
 295+ 6468              	; comma
 296+ 6468 CD 43 6A     	CALL CHKCHAR
 297+ 646B 2C           	DB ','
 298+ 646C              	; get destination begin column
 299+ 646C DD 21 2F 54  	LD IX, FRMQNT
 300+ 6470 CD 59 01     	CALL CALBAS
 301+ 6473 7B           	LD A, E
 302+ 6474 32 32 67     	LD (BLIT_TMP+2), A
 303+ 6477              	; comma
 304+ 6477 CD 43 6A     	CALL CHKCHAR
 305+ 647A 2C           	DB ','
 306+ 647B              	; get destination begin row
 307+ 647B DD 21 2F 54  	LD IX, FRMQNT
 308+ 647F CD 59 01     	CALL CALBAS
 309+ 6482 7B           	LD A, E
 310+ 6483 32 33 67     	LD (BLIT_TMP+3), A
 311+ 6486              	; comma
 312+ 6486 CD 43 6A     	CALL CHKCHAR
 313+ 6489 2C           	DB ','
 314+ 648A              	; get number of tiles horizontally
 315+ 648A DD 21 2F 54  	LD IX, FRMQNT
 316+ 648E CD 59 01     	CALL CALBAS
 317+ 6491 ED 53 3E 67  	LD (BLIT_STRUCT+10), DE
 318+ 6495              	; comma
 319+ 6495 CD 43 6A     	CALL CHKCHAR
 320+ 6498 2C           	DB ','
 321+ 6499              	; get number of tiles vertically
 322+ 6499 DD 21 2F 54  	LD IX, FRMQNT
 323+ 649D CD 59 01     	CALL CALBAS
 324+ 64A0 ED 53 40 67  	LD (BLIT_STRUCT+12), DE
 325+ 64A4              	; ending )
 326+ 64A4 CD 43 6A     	CALL CHKCHAR
 327+ 64A7 29           	DB ')'
 328+ 64A8               ENDIF
 329+ 64A8
 330+ 64A8              .COMMON:
 331+ 64A8 E5           	PUSH HL ; save position in BASIC buffer
 332+ 64A9
 333+ 64A9              	; calculate destination add to value
 334+ 64A9 21 00 01     	LD HL, 256
 335+ 64AC 22 3C 67     	LD (BLIT_STRUCT+8), HL
 336+ 64AF              	; calculate pointer to background location
 337+ 64AF 3A 33 67     	LD A,(BLIT_TMP+3)
 338+ 64B2 67           	LD H,A
 339+ 64B3 2E 00        	LD L,0
 340+ 64B5 EB           	EX DE,HL
 341+ 64B6 26 00        	LD H,0
 342+ 64B8 3A 32 67     	LD A,(BLIT_TMP+2)
 343+ 64BB 6F           	LD L,A
 344+ 64BC CD 31 69     	CALL HLx8
 345+ 64BF 19           	ADD HL,DE
 346+ 64C0 ED 5B CB F3  	LD DE,(GRPCGP)
 347+ 64C4 19           	ADD HL,DE
 348+ 64C5 22 3A 67     	LD (BLIT_STRUCT+6),HL
 349+ 64C8 F3           	DI
 350+ 64C9 FD 21 D0 64  	LD IY, .RET
 351+ 64CD C3 F5 69     	JP ENABLE_PAGE0
 352+ 64D0              .RET:
 353+ 64D0 FB           	EI
 354+ 64D1              	; set RAM functions to call
 355+ 64D1 21 EB 64     	LD HL, .TILECOPY
 356+ 64D4 22 C7 62     	LD (TILE.CALL2+1), HL
 357+ 64D7 21 F1 64     	LD HL, .SETDESTROW
 358+ 64DA 22 B9 62     	LD (TILE.CALL1+1), HL
 359+ 64DD DD 21 34 67  	LD IX,BLIT_STRUCT
 360+ 64E1 CD 9E 62     	CALL TILE
 361+ 64E4
 362+ 64E4 D1               POP DE
 363+ 64E5 C1               POP BC
 364+ 64E6 CD 6C 69         CALL RESTORE_PAGE_INFO
 365+ 64E9
 366+ 64E9 E1           	POP HL
 367+ 64EA C9           	RET
 368+ 64EB              .TILECOPY:
 369+ 64EB 01 98 08     	LD BC, #0898
 370+ 64EE C3 29 69     	JP BBYTECOPY_NO_C
 371+ 64F1              .SETDESTROW:
 372+ 64F1 2A 30 67     	LD HL, (TILETMP1)
 373+ 64F4 F3           	DI
 374+ 64F5 CD 1C 69     	CALL SETWRT_LOCAL
 375+ 64F8 FB           	EI
 376+ 64F9 C9           	RET
 377+ 64FA              ; *******************************************************************************************************
 378+ 64FA
# file closed: asm\TILE.asm
 161  64FA               ENDIF
 162  64FA
 163  64FA               IF (COLL_CMD == 1)
 164  64FA               INCLUDE "COLLISION.asm"
# file opened: asm\COLLISION.asm
   1+ 64FA              ; generic collision checking routines
   2+ 64FA              ; in BASIC we use rectangle structure array DIM R%(7,n) of the format
   3+ 64FA              ; R%(0,n) is active flag, <>0 active / 0 skipped in checks
   4+ 64FA              ; R%(1,n) is either upper left x coordinate or sprite id (0-31) depending on R(7,n)
   5+ 64FA              ; R%(2,n) is either upper left y coordinate or unused depending on R(7,n)
   6+ 64FA              ; R%(3,n) x offset where rectangle begins
   7+ 64FA              ; R%(4,n) y offset where rectangle begins
   8+ 64FA              ; R%(5,n) is width
   9+ 64FA              ; R%(6,n) is height
  10+ 64FA              ; R%(7,0) is type, 0=generic where R%(1,0) contains x coordinate
  11+ 64FA              ;                  <>0 sprite where R%(1,0) contains sprite id
  12+ 64FA              ; for type sprite, upper left coordinates are taken from sprite attribute array
  13+ 64FA
  14+ 64FA              ; ************************************************************************************************
  15+ 64FA              ; quick test if HL<=DE<=HL+BC
  16+ 64FA              ; input BC=width, DE=x, HL=min
  17+ 64FA              ; if not true flag C set
  18+ 64FA              ; modifies AF
  19+ 64FA              GENERIC_INNER_CHECK:
  20+ 64FA E5               PUSH HL
  21+ 64FB D5               PUSH DE
  22+ 64FC EB               EX DE,HL
  23+ 64FD A7               AND A
  24+ 64FE ED 52            SBC HL, DE
  25+ 6500 FA 0E 65         JP M, .GENERIC_INNER_CHECK_NOT
  26+ 6503 A7               AND A
  27+ 6504 ED 42            SBC HL, BC
  28+ 6506 28 03            JR Z, .L2
  29+ 6508 F2 0E 65         JP P, .GENERIC_INNER_CHECK_NOT
  30+ 650B              .L2:
  31+ 650B A7               AND A
  32+ 650C 18 01            JR .EXIT
  33+ 650E              .GENERIC_INNER_CHECK_NOT:
  34+ 650E 37               SCF
  35+ 650F              .EXIT:
  36+ 650F D1               POP DE
  37+ 6510 E1               POP HL
  38+ 6511 C9               RET
  39+ 6512              ; ************************************************************************************************
  40+ 6512
  41+ 6512              ; ************************************************************************************************
  42+ 6512              ; function to check if rectangles are overlapping
  43+ 6512              ; input IX=IY=pointer to struct
  44+ 6512              ;  +00 active flag
  45+ 6512              ;  +02 x coordinate
  46+ 6512              ;  +04 y coordinate
  47+ 6512              ;  +06 x offset where rectangle begins
  48+ 6512              ;  +08 y offset where rectangle begins
  49+ 6512              ;  +10 width
  50+ 6512              ;  +12 height
  51+ 6512              ; where IY is used to read +2 and +4, and IX to read +6, +8, +10 and +12
  52+ 6512              ; this is a hack to allow location being taken from sprite attributes table
  53+ 6512              ; input BLIT_STRUCT data
  54+ 6512              ;  +00 x coordinate
  55+ 6512              ;  +02 y coordinate
  56+ 6512              ;  +04 width
  57+ 6512              ;  +06 height
  58+ 6512              ; returns CF=1 if not overlapping, CF=0 if overlapping
  59+ 6512              RECTANGLE_OVERLAP_CHECK:
  60+ 6512                  ; first check which rectangle is higher
  61+ 6512 DD 6E 0C         LD L,(IX+12)
  62+ 6515 DD 66 0D         LD H,(IX+13)
  63+ 6518 ED 5B 3A 67      LD DE,(BLIT_STRUCT+6)
  64+ 651C A7               AND A
  65+ 651D ED 52            SBC HL,DE
  66+ 651F FD 6E 04         LD L,(IY+4)
  67+ 6522 FD 66 05         LD H,(IY+5)
  68+ 6525 DD 5E 08         LD E,(IX+8)
  69+ 6528 DD 56 09         LD D,(IX+9)
  70+ 652B FA 4B 65         JP M,.L1
  71+ 652E                  ; equally high or IX defined one higher
  72+ 652E                  ; check upper boundary
  73+ 652E 19               ADD HL,DE
  74+ 652F ED 5B 36 67      LD DE,(BLIT_STRUCT+2)
  75+ 6533 DD 4E 0C         LD C,(IX+12)
  76+ 6536 DD 46 0D         LD B,(IX+13)
  77+ 6539 CD FA 64         CALL GENERIC_INNER_CHECK
  78+ 653C 30 29            JR NC,.INSIDE
  79+ 653E                  ; check lower boundary
  80+ 653E E5               PUSH HL
  81+ 653F 2A 3A 67         LD HL,(BLIT_STRUCT+6)
  82+ 6542 19               ADD HL,DE
  83+ 6543 EB               EX DE,HL
  84+ 6544 E1               POP HL
  85+ 6545 CD FA 64         CALL GENERIC_INNER_CHECK
  86+ 6548 30 1D            JR NC,.INSIDE
  87+ 654A C9               RET ; not overlapping
  88+ 654B              .L1:
  89+ 654B                  ; rectangle defined in BLIT_STRUCT is higher
  90+ 654B 19               ADD HL,DE
  91+ 654C EB               EX DE,HL
  92+ 654D 2A 36 67         LD HL,(BLIT_STRUCT+2)
  93+ 6550 ED 4B 3A 67      LD BC,(BLIT_STRUCT+6)
  94+ 6554 CD FA 64         CALL GENERIC_INNER_CHECK
  95+ 6557 30 0E            JR NC,.INSIDE
  96+ 6559 E5               PUSH HL
  97+ 655A DD 6E 0C         LD L,(IX+12)
  98+ 655D DD 66 0D         LD H,(IX+13)
  99+ 6560 19               ADD HL,DE
 100+ 6561 EB               EX DE,HL
 101+ 6562 E1               POP HL
 102+ 6563 CD FA 64         CALL GENERIC_INNER_CHECK
 103+ 6566 D8               RET C
 104+ 6567              .INSIDE:
 105+ 6567                  ; check x coordinate
 106+ 6567                  ; first check which rectangle is wider
 107+ 6567 DD 6E 0A         LD L,(IX+10)
 108+ 656A DD 66 0B         LD H,(IX+11)
 109+ 656D ED 5B 38 67      LD DE,(BLIT_STRUCT+4)
 110+ 6571 A7               AND A
 111+ 6572 ED 52            SBC HL,DE
 112+ 6574 FD 6E 02         LD L,(IY+2)
 113+ 6577 FD 66 03         LD H,(IY+3)
 114+ 657A DD 5E 06         LD E,(IX+6)
 115+ 657D DD 56 07         LD D,(IX+7)
 116+ 6580 FA 9C 65         JP M,.L2
 117+ 6583                  ; equally wide or IX defined one wider
 118+ 6583                  ; check left boundary
 119+ 6583 19               ADD HL,DE
 120+ 6584 ED 5B 34 67      LD DE,(BLIT_STRUCT+0)
 121+ 6588 DD 4E 0A         LD C,(IX+10)
 122+ 658B DD 46 0B         LD B,(IX+11)
 123+ 658E CD FA 64         CALL GENERIC_INNER_CHECK
 124+ 6591 D0               RET NC ; overlap
 125+ 6592                  ; check right boundary
 126+ 6592 E5               PUSH HL
 127+ 6593 2A 38 67         LD HL,(BLIT_STRUCT+4)
 128+ 6596 19               ADD HL,DE
 129+ 6597 EB               EX DE,HL
 130+ 6598 E1               POP HL
 131+ 6599 C3 FA 64         JP GENERIC_INNER_CHECK ; CF and result set by fn call
 132+ 659C              .L2:
 133+ 659C                  ; rectangle defined in BLIT_STRUCT is higher
 134+ 659C 19               ADD HL,DE
 135+ 659D EB               EX DE,HL
 136+ 659E 2A 34 67         LD HL,(BLIT_STRUCT+0)
 137+ 65A1 ED 4B 38 67      LD BC,(BLIT_STRUCT+4)
 138+ 65A5 CD FA 64         CALL GENERIC_INNER_CHECK
 139+ 65A8 D0               RET NC ; overlap
 140+ 65A9 E5               PUSH HL
 141+ 65AA DD 6E 0A         LD L,(IX+10)
 142+ 65AD DD 66 0B         LD H,(IX+11)
 143+ 65B0 19               ADD HL,DE
 144+ 65B1 EB               EX DE,HL
 145+ 65B2 E1               POP HL
 146+ 65B3 C3 FA 64         JP GENERIC_INNER_CHECK
 147+ 65B6              ; ************************************************************************************************
 148+ 65B6
 149+ 65B6              ; ************************************************************************************************
 150+ 65B6              ; function tries to find rectangle overlap and returns an index if found
 151+ 65B6              ; input BLIT_STRUCT data
 152+ 65B6              ;  +00 x coordinate
 153+ 65B6              ;  +02 y coordinate
 154+ 65B6              ;  +04 width
 155+ 65B6              ;  +06 height
 156+ 65B6              ;  +08 number of items in a list, described under RECTANGLE_OVERLAP_CHECK
 157+ 65B6              ;  +09 pointer to first element of R%(7,n)
 158+ 65B6              ;  +11 pointer to INT result variable
 159+ 65B6              ; returns CF=1 if not overlapping
 160+ 65B6              ; returns A=list index and CF=0 if overlapping
 161+ 65B6              FIND_OVERLAP:
 162+ 65B6 3A 3C 67         LD A,(BLIT_STRUCT+8)
 163+ 65B9 47               LD B,A
 164+ 65BA DD 2A 3D 67      LD IX,(BLIT_STRUCT+9)
 165+ 65BE              .L1:
 166+ 65BE C5               PUSH BC
 167+ 65BF                  ; check active flag
 168+ 65BF DD 7E 00         LD A,(IX)
 169+ 65C2 DD B6 01         OR (IX+1)
 170+ 65C5 28 18            JR Z,.NEXT
 171+ 65C7                  ; check type
 172+ 65C7 DD 7E 0E         LD A,(IX+14)
 173+ 65CA DD B6 0F         OR (IX+15)
 174+ 65CD 20 1A            JR NZ,.L2
 175+ 65CF DD E5            PUSH IX
 176+ 65D1 FD E1            POP IY
 177+ 65D3              .L3:
 178+ 65D3 CD 12 65         CALL RECTANGLE_OVERLAP_CHECK
 179+ 65D6 38 07            JR C,.NEXT
 180+ 65D8                  ; found
 181+ 65D8 C1               POP BC
 182+ 65D9 3A 3C 67         LD A,(BLIT_STRUCT+8)
 183+ 65DC 90               SUB B
 184+ 65DD A7               AND A
 185+ 65DE C9               RET
 186+ 65DF              .NEXT:
 187+ 65DF 11 10 00         LD DE,16
 188+ 65E2 DD 19            ADD IX,DE
 189+ 65E4 C1               POP BC
 190+ 65E5 10 D7            DJNZ .L1
 191+ 65E7 37               SCF
 192+ 65E8 C9               RET
 193+ 65E9              .L2:
 194+ 65E9                  ; sprite, need to build a temporary data struct since x and y values are inversed
 195+ 65E9                  ; at BLIT_STRUCT+13
 196+ 65E9 DD 7E 02         LD A,(IX+2) ; sprite ID
 197+ 65EC CD 89 4D         CALL GETnthSPRATTR
 198+ 65EF FD 21 3F 67      LD IY,BLIT_STRUCT+11
 199+ 65F3 7E               LD A,(HL)
 200+ 65F4 FD 77 04         LD (IY+4),A
 201+ 65F7 23               INC HL
 202+ 65F8 7E               LD A,(HL)
 203+ 65F9 FD 77 05         LD (IY+5),A
 204+ 65FC 23               INC HL
 205+ 65FD 7E               LD A,(HL)
 206+ 65FE FD 77 02         LD (IY+2),A
 207+ 6601 23               INC HL
 208+ 6602 7E               LD A,(HL)
 209+ 6603 FD 77 03         LD (IY+3),A
 210+ 6606 18 CB            JR .L3
 211+ 6608              ; ************************************************************************************************
 212+ 6608
 213+ 6608               IF (BASIC_EXTENSION == 1)
 214+ 6608              ; ************************************************************************************************
 215+ 6608              ; function to handle CALL COLL basic extension
 216+ 6608              ; checks for collision between player and other rectangles
 217+ 6608              ; COLL ( INT result variable,
 218+ 6608              ;	     INT player x value,
 219+ 6608              ;	     INT player y value,
 220+ 6608              ;	     INT player width,
 221+ 6608              ;	     INT player height,
 222+ 6608              ;	     INT number of items in a list,
 223+ 6608              ;		 INT[6][n] rectangle struct )
 224+ 6608              ; will fill result variable with index or -1 if no collision
 225+ 6608              ; rectangle struct described under RECTANGLE_OVERLAP_CHECK
 226+ 6608              COLL:
 227+ 6608              	; opening (
 228+ 6608 CD 43 6A     	CALL CHKCHAR
 229+ 660B 28           	DB '('
 230+ 660C              	; get address of result variable
 231+ 660C DD 21 A4 5E  	LD IX, PTRGET
 232+ 6610 CD 59 01     	CALL CALBAS
 233+ 6613 ED 53 3F 67  	LD (BLIT_STRUCT+11),DE
 234+ 6617              	; comma
 235+ 6617 CD 43 6A     	CALL CHKCHAR
 236+ 661A 2C           	DB ','
 237+ 661B              	; get x
 238+ 661B DD 21 2F 54  	LD IX, FRMQNT
 239+ 661F CD 59 01     	CALL CALBAS
 240+ 6622 ED 53 34 67  	LD (BLIT_STRUCT+0),DE
 241+ 6626              	; comma
 242+ 6626 CD 43 6A     	CALL CHKCHAR
 243+ 6629 2C           	DB ','
 244+ 662A              	; get y
 245+ 662A DD 21 2F 54  	LD IX, FRMQNT
 246+ 662E CD 59 01     	CALL CALBAS
 247+ 6631 ED 53 36 67  	LD (BLIT_STRUCT+2),DE
 248+ 6635              	; comma
 249+ 6635 CD 43 6A     	CALL CHKCHAR
 250+ 6638 2C           	DB ','
 251+ 6639              	; get width
 252+ 6639 DD 21 2F 54  	LD IX, FRMQNT
 253+ 663D CD 59 01     	CALL CALBAS
 254+ 6640 ED 53 38 67  	LD (BLIT_STRUCT+4),DE
 255+ 6644              	; comma
 256+ 6644 CD 43 6A     	CALL CHKCHAR
 257+ 6647 2C           	DB ','
 258+ 6648              	; get height
 259+ 6648 DD 21 2F 54  	LD IX, FRMQNT
 260+ 664C CD 59 01     	CALL CALBAS
 261+ 664F ED 53 3A 67  	LD (BLIT_STRUCT+6),DE
 262+ 6653              	; comma
 263+ 6653 CD 43 6A     	CALL CHKCHAR
 264+ 6656 2C           	DB ','
 265+ 6657              	; get number of items in a list
 266+ 6657 DD 21 1C 52  	LD IX, GETBYT
 267+ 665B CD 59 01     	CALL CALBAS
 268+ 665E 32 3C 67     	LD (BLIT_STRUCT+8),A
 269+ 6661              	; comma
 270+ 6661 CD 43 6A     	CALL CHKCHAR
 271+ 6664 2C           	DB ','
 272+ 6665              	; get address of rectangle structure array DIM R%(7,n)
 273+ 6665 3A 3C 67     	LD A,(BLIT_STRUCT+8)
 274+ 6668 5F               LD E,A
 275+ 6669 3E 02            LD A,2
 276+ 666B 47           	LD B,A
 277+ 666C 16 07        	LD D,7
 278+ 666E CD 70 6A     	CALL GET_BASIC_ARRAY_DATA_POINTER
 279+ 6671 ED 43 3D 67  	LD (BLIT_STRUCT+9),BC
 280+ 6675              	; ending )
 281+ 6675 CD 43 6A     	CALL CHKCHAR
 282+ 6678 29           	DB ')'
 283+ 6679
 284+ 6679 E5               PUSH HL
 285+ 667A CD B6 65         CALL FIND_OVERLAP
 286+ 667D 2A 3F 67         LD HL,(BLIT_STRUCT+11)
 287+ 6680 38 06            JR C,.NOTFOUND
 288+ 6682 77               LD (HL),A
 289+ 6683 23               INC HL
 290+ 6684 36 00            LD (HL),0
 291+ 6686 E1               POP HL
 292+ 6687 C9               RET
 293+ 6688              .NOTFOUND:
 294+ 6688 36 FF            LD (HL),#FF
 295+ 668A 23               INC HL
 296+ 668B 36 FF            LD (HL),#FF
 297+ 668D E1               POP HL
 298+ 668E C9               RET
 299+ 668F              ; ************************************************************************************************
 300+ 668F               ENDIF
 301+ 668F
 302+ 668F               IF (DEFUSR_EXTENSION == 1)
 303+ 668F              ; *******************************************************************************************************
 304+ 668F              ; same as COLL but for DEFUSR approach
 305+ 668F              ; input IX=pointer to input array, real data from +2
 306+ 668F              ; +02 = pointer to result variable
 307+ 668F              ; +04 = player X
 308+ 668F              ; +06 = player Y
 309+ 668F              ; +08 = player width
 310+ 668F              ; +10 = player height
 311+ 668F              ; +12 = number of list items
 312+ 668F              ; +14 = pointer to list of collidable objects
 313+ 668F              COLL_DEFUSR:
 314+ 668F DD E5            PUSH IX
 315+ 6691 E1               POP HL
 316+ 6692 23          > INC HL ; skip over to player x
 316+ 6693 23          > INC HL
 316+ 6694 23          > INC HL
 316+ 6695 23          > INC HL
 317+ 6696 11 34 67         LD DE,BLIT_STRUCT
 318+ 6699 01 09 00         LD BC,9
 319+ 669C ED B0            LDIR ; copy over x,y,w,h,list item number
 320+ 669E DD 7E 0E         LD A,(IX+14)
 321+ 66A1 32 3D 67         LD (BLIT_STRUCT+9),A
 322+ 66A4 DD 7E 0F         LD A,(IX+15)
 323+ 66A7 32 3E 67         LD (BLIT_STRUCT+10),A ; address to collidable objects array
 324+ 66AA DD 7E 02         LD A,(IX+2)
 325+ 66AD 32 3F 67         LD (BLIT_STRUCT+11),A
 326+ 66B0 DD 7E 03         LD A,(IX+3)
 327+ 66B3 32 40 67         LD (BLIT_STRUCT+12),A ; address to results variable
 328+ 66B6 DD E5            PUSH IX
 329+ 66B8 CD B6 65         CALL FIND_OVERLAP
 330+ 66BB DD E1            POP IX
 331+ 66BD DD 6E 02         LD L,(IX+2)
 332+ 66C0 DD 66 03         LD H,(IX+3)
 333+ 66C3 38 05            JR C,.NOTFOUND
 334+ 66C5 77               LD (HL),A
 335+ 66C6 23               INC HL
 336+ 66C7 36 00            LD (HL),0
 337+ 66C9 C9               RET
 338+ 66CA              .NOTFOUND:
 339+ 66CA 36 FF            LD (HL),#FF
 340+ 66CC 23               INC HL
 341+ 66CD 36 FF            LD (HL),#FF
 342+ 66CF C9               RET
 343+ 66D0              ; *******************************************************************************************************
 344+ 66D0               ENDIF
 345+ 66D0
# file closed: asm\COLLISION.asm
 165  66D0               ENDIF
 166  66D0
 167  66D0               IF (DEFUSR_EXTENSION == 1)
 168  66D0               INCLUDE "DEFUSR.asm"
# file opened: asm\DEFUSR.asm
   1+ 66D0              ; entry function that handles call using CALLF
   2+ 66D0              ; pointer to data structure is expected at DAC+2
   3+ 66D0              ; first entry must be function id followed by function specific parameters
   4+ 66D0
   5+ 66D0              DEFUSR_TABLE_ENTRIES    EQU 35
   6+ 66D0
   7+ 66D0              DEFUSR_JUMP_TABLE:
   8+ 66D0               IF (SPRITE_CMDS == 1)
   9+ 66D0 B5 4E         DW SPRENABLE_DEFUSR        ; 0
  10+ 66D2               ELSE
  11+ 66D2 ~             DW NOACTION_DEFUSR
  12+ 66D2               ENDIF
  13+ 66D2
  14+ 66D2               IF (SPRITE_CMDS == 1)
  15+ 66D2 D5 4E         DW SPRDISABLE_DEFUSR        ; 1
  16+ 66D4               ELSE
  17+ 66D4 ~             DW NOACTION_DEFUSR
  18+ 66D4               ENDIF
  19+ 66D4
  20+ 66D4               IF (RAM_CMDS == 1)
  21+ 66D4 EF 5A         DW MEMCPY_DEFUSR           ; 2
  22+ 66D6               ELSE
  23+ 66D6 ~             DW NOACTION_DEFUSR
  24+ 66D6               ENDIF
  25+ 66D6
  26+ 66D6               IF (VRAM_CMDS == 1)        ; 3
  27+ 66D6 62 5D         DW MEMVRM_DEFUSR
  28+ 66D8               ELSE
  29+ 66D8 ~             DW NOACTION_DEFUSR
  30+ 66D8               ENDIF
  31+ 66D8
  32+ 66D8               IF (BLIT_CMDS == 1)        ; 4
  33+ 66D8 23 61         DW BLIT_DEFUSR
  34+ 66DA               ELSE
  35+ 66DA ~             DW NOACTION_DEFUSR
  36+ 66DA               ENDIF
  37+ 66DA
  38+ 66DA               IF (ANIM_CMDS == 1)        ; 5
  39+ 66DA 82 59         DW SGAM_DEFUSR
  40+ 66DC               ELSE
  41+ 66DC ~             DW NOACTION_DEFUSR
  42+ 66DC               ENDIF
  43+ 66DC
  44+ 66DC               IF (SPRITE_CMDS == 1)
  45+ 66DC 7A 4F         DW SPRGRPMOV_DEFUSR        ; 6
  46+ 66DE               ELSE
  47+ 66DE ~             DW NOACTION_DEFUSR
  48+ 66DE               ENDIF
  49+ 66DE
  50+ 66DE               IF (COLL_CMD == 1)
  51+ 66DE 8F 66         DW COLL_DEFUSR             ; 7
  52+ 66E0               ELSE
  53+ 66E0 ~             DW NOACTION_DEFUSR
  54+ 66E0               ENDIF
  55+ 66E0
  56+ 66E0               IF (SOUND_CMDS == 1)
  57+ 66E0 99 5C         DW SNDSFX_DEFUSR             ; 8
  58+ 66E2               ELSE
  59+ 66E2 ~             DW NOACTION_DEFUSR
  60+ 66E2               ENDIF
  61+ 66E2
  62+ 66E2               IF (ANIM_CMDS == 1)
  63+ 66E2 6F 57         DW ANIMSTEP_SINGLE_DEFUSR      ; 9
  64+ 66E4 7F 57         DW ANIMSTEP_MULTI_DEFUSR       ; 10
  65+ 66E6 90 57         DW ANIMSTART_SINGLE_DEFUSR     ; 11
  66+ 66E8 A2 57         DW ANIMSTART_MULTI_DEFUSR      ; 12
  67+ 66EA A7 57         DW ANIMSTOP_SINGLE_DEFUSR      ; 13
  68+ 66EC B1 57         DW ANIMSTOP_MULTI_DEFUSR       ; 14
  69+ 66EE               ELSE
  70+ 66EE ~             DW NOACTION_DEFUSR
  71+ 66EE ~             DW NOACTION_DEFUSR
  72+ 66EE ~             DW NOACTION_DEFUSR
  73+ 66EE ~             DW NOACTION_DEFUSR
  74+ 66EE ~             DW NOACTION_DEFUSR
  75+ 66EE ~             DW NOACTION_DEFUSR
  76+ 66EE               ENDIF
  77+ 66EE
  78+ 66EE               IF (BOX_CMDS == 1)
  79+ 66EE C1 5E         DW BOXMEMCPY_DEFUSR            ; 15
  80+ 66F0 64 5F         DW BOXMEMVRM_DEFUSR            ; 16
  81+ 66F2               ELSE
  82+ 66F2 ~             DW NOACTION_DEFUSR
  83+ 66F2 ~             DW NOACTION_DEFUSR
  84+ 66F2               ENDIF
  85+ 66F2
  86+ 66F2               IF (ANIM_CMDS == 1)
  87+ 66F2 DA 4F         DW MAXANIMITEMS_DEFUSR         ; 17
  88+ 66F4 B9 51         DW MAXANIMDEFS_DEFUSR          ; 18
  89+ 66F6 7A 52         DW MAXANIMSPRS_DEFUSR          ; 19
  90+ 66F8 3C 54         DW MAXAUTOSGAMS_DEFUSR         ; 20
  91+ 66FA 16 51         DW ANIMITEMPAT_DEFUSR          ; 21
  92+ 66FC 94 51         DW ANIMITEMPTR_DEFUSR          ; 22
  93+ 66FE 54 52         DW ANIMDEF_DEFUSR              ; 23
  94+ 6700 50 53         DW ANIMSPRITE_DEFUSR           ; 24
  95+ 6702 01 54         DW ANIMCHAR_DEFUSR             ; 25
  96+ 6704 D2 55         DW AUTOSGAMDEF_DEFUSR          ; 26
  97+ 6706 A0 56         DW AUTOSGAMSTART_DEFUSR        ; 27
  98+ 6708 C7 56         DW AUTOSGAMSTOP_DEFUSR         ; 28
  99+ 670A               ELSE
 100+ 670A ~             DW NOACTION_DEFUSR
 101+ 670A ~             DW NOACTION_DEFUSR
 102+ 670A ~             DW NOACTION_DEFUSR
 103+ 670A ~             DW NOACTION_DEFUSR
 104+ 670A ~             DW NOACTION_DEFUSR
 105+ 670A ~             DW NOACTION_DEFUSR
 106+ 670A ~             DW NOACTION_DEFUSR
 107+ 670A ~             DW NOACTION_DEFUSR
 108+ 670A ~             DW NOACTION_DEFUSR
 109+ 670A ~             DW NOACTION_DEFUSR
 110+ 670A ~             DW NOACTION_DEFUSR
 111+ 670A ~             DW NOACTION_DEFUSR
 112+ 670A               ENDIF
 113+ 670A
 114+ 670A               IF (GENCAL_CMD == 1)
 115+ 670A 18 5E         DW GENCAL_DEFUSR               ; 29
 116+ 670C               ELSE
 117+ 670C ~             DW NOACTION_DEFUSR
 118+ 670C               ENDIF
 119+ 670C
 120+ 670C               IF (RAM_CMDS == 1)
 121+ 670C 5A 5B         DW FILRAM_DEFUSR               ; 30
 122+ 670E               ELSE
 123+ 670E ~             DW NOACTION_DEFUSR
 124+ 670E               ENDIF
 125+ 670E
 126+ 670E               IF (SOUND_CMDS == 1)
 127+ 670E D6 5B         DW SNDPLYINI_DEFUSR            ; 31
 128+ 6710 09 5C         DW SNDPLYON_DEFUSR             ; 32
 129+ 6712 1C 5C         DW SNDPLYOFF_DEFUSR            ; 33
 130+ 6714               ELSE
 131+ 6714 ~             DW NOACTION_DEFUSR
 132+ 6714 ~             DW NOACTION_DEFUSR
 133+ 6714 ~             DW NOACTION_DEFUSR
 134+ 6714               ENDIF
 135+ 6714
 136+ 6714               IF (TILE_CMDS == 1)
 137+ 6714 E6 62         DW TILERAM_DEFUSR              ; 34
 138+ 6716               ELSE
 139+ 6716 ~             DW NOACTION_DEFUSR
 140+ 6716               ENDIF
 141+ 6716
 142+ 6716              DEFUSR_ENTRY:
 143+ 6716 FB               EI
 144+ 6717 DD 2A F8 F7      LD IX,(DAC+2)
 145+ 671B DD 7E 00         LD A,(IX)
 146+ 671E FE 23            CP DEFUSR_TABLE_ENTRIES
 147+ 6720 D0               RET NC ; return if an undefined function requested
 148+ 6721 26 00            LD H,0
 149+ 6723 6F               LD L,A
 150+ 6724 29               ADD HL,HL
 151+ 6725 11 D0 66         LD DE,DEFUSR_JUMP_TABLE
 152+ 6728 19               ADD HL,DE
 153+ 6729 EB               EX DE,HL
 154+ 672A 1A               LD A,(DE)
 155+ 672B 6F               LD L,A
 156+ 672C 13               INC DE
 157+ 672D 1A               LD A,(DE)
 158+ 672E 67               LD H,A
 159+ 672F E9               JP (HL) ; call function with IX=pointer to data array
 160+ 6730
# file closed: asm\DEFUSR.asm
 169  6730               ENDIF
 170  6730
 171  6730              ; temp variables for BLIT, TILE functions
 172  6730               IF (BLIT_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS + COLL_CMD > 0)
 173  6730              BLIT_TMP:
 174  6730              TILETMP1:
 175  6730              BLIT_TMP1:
 176  6730 00 00         DW 0
 177  6732              TILETMP2:
 178  6732              BLIT_TMP2:
 179  6732 00 00         DW 0
 180  6734              BLIT_STRUCT:
 181  6734 00 00 00...   DS 17
 182  6738               ENDIF
 183  6745
 184  6745               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 185  6745              VRAM_UPDATE_IN_PROGRESS:
 186  6745 00            DB 0
 187  6746               ENDIF
 188  6746
 189  6746              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 190  6746              ; per starting letter, if no commands with this letter, NULL value
 191  6746              CMDS:
 192  6746 84 68        	DW CMDS_A ; always present due to ARTINFO
 193  6748               IF (BLIT_CMDS + BOX_CMDS > 0) && (BASIC_EXTENSION == 1)
 194  6748 47 68            DW CMDS_B ; B
 195  674A               ELSE
 196  674A ~            	DW 0
 197  674A               ENDIF
 198  674A               IF (COLL_CMD == 1) && (BASIC_EXTENSION == 1)
 199  674A 7C 68        	DW CMDS_C ;
 200  674C               ELSE
 201  674C ~                DW 0 ; C
 202  674C               ENDIF
 203  674C 00 00            DW 0 ; D
 204  674E 00 00            DW 0 ; E
 205  6750               IF (VRAM_CMDS + RAM_CMDS > 0) && (BASIC_EXTENSION == 1)
 206  6750 C7 67            DW CMDS_F; F
 207  6752               ELSE
 208  6752 ~            	DW 0
 209  6752               ENDIF
 210  6752               IF (GENCAL_CMD > 0) && (BASIC_EXTENSION == 1)
 211  6752 DA 67            DW CMDS_G; G
 212  6754               ELSE
 213  6754 ~            	DW 0
 214  6754               ENDIF
 215  6754 00 00            DW 0 ; H
 216  6756 00 00            DW 0 ; I
 217  6758 00 00            DW 0 ; J
 218  675A 00 00            DW 0 ; K
 219  675C 00 00            DW 0 ; L
 220  675E               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0) && (BASIC_EXTENSION == 1)
 221  675E 7A 67            DW CMDS_M ; M
 222  6760               ELSE
 223  6760 ~            	DW 0
 224  6760               ENDIF
 225  6760 00 00            DW 0 ; N
 226  6762 00 00            DW 0 ; O
 227  6764 00 00            DW 0 ; P
 228  6766 00 00            DW 0 ; Q
 229  6768 00 00            DW 0 ; R
 230  676A               IF (SOUND_CMDS + SPRITE_CMDS > 0) && (BASIC_EXTENSION == 1)
 231  676A EE 67            DW CMDS_S ; S
 232  676C               ELSE
 233  676C ~            	DW 0
 234  676C               ENDIF
 235  676C               IF (TILE_CMDS > 0) && (BASIC_EXTENSION == 1)
 236  676C 67 68            DW CMDS_T ; T
 237  676E               ELSE
 238  676E ~            	DW 0
 239  676E               ENDIF
 240  676E 00 00            DW 0 ; U
 241  6770               IF (VRAM_CMDS > 0) && (BASIC_EXTENSION == 1)
 242  6770 E4 67            DW CMDS_V ; V
 243  6772               ELSE
 244  6772 ~            	DW 0
 245  6772               ENDIF
 246  6772 00 00            DW 0 ; W
 247  6774 00 00            DW 0 ; X
 248  6776 00 00            DW 0 ; Y
 249  6778 00 00            DW 0 ; Z
 250  677A
 251  677A               IF (BASIC_EXTENSION == 1)
 252  677A              CMDS_M:
 253  677A               IF (VRAM_CMDS == 1)
 254  677A 4D 45 4D 56      DB "MEMVRM", 0
 254  677E 52 4D 00
 255  6781 0C 5D            DW MEMVRM
 256  6783               ENDIF
 257  6783               IF (RAM_CMDS == 1)
 258  6783 4D 45 4D 43  	DB "MEMCPY", 0
 258  6787 50 59 00
 259  678A AB 5A        	DW MEMCPY
 260  678C               ENDIF
 261  678C               IF (ANIM_CMDS == 1)
 262  678C 4D 41 58 41  	DB "MAXANIMITEMS",0
 262  6790 4E 49 4D 49
 262  6794 54 45 4D 53
 262  6798 00
 263  6799 DF 4F        	DW MAXANIMITEMS
 264  679B 4D 41 58 41  	DB "MAXANIMDEFS",0
 264  679F 4E 49 4D 44
 264  67A3 45 46 53 00
 265  67A7 BE 51        	DW MAXANIMDEFS
 266  67A9 4D 41 58 41  	DB "MAXANIMSPRS",0
 266  67AD 4E 49 4D 53
 266  67B1 50 52 53 00
 267  67B5 7F 52        	DW MAXANIMSPRS
 268  67B7 4D 41 58 41     DB "MAXAUTOSGAMS",0
 268  67BB 55 54 4F 53
 268  67BF 47 41 4D 53
 268  67C3 00
 269  67C4 41 54           DW MAXAUTOSGAMS
 270  67C6               ENDIF
 271  67C6               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 272  67C6 00           	DB 0
 273  67C7               ENDIF
 274  67C7              CMDS_F:
 275  67C7               IF (VRAM_CMDS == 1)
 276  67C7 46 49 4C 56      DB "FILVRM", 0
 276  67CB 52 4D 00
 277  67CE BD 5C            DW FILVRM
 278  67D0               ENDIF
 279  67D0               IF (RAM_CMDS == 1)
 280  67D0 46 49 4C 52      DB "FILRAM", 0
 280  67D4 41 4D 00
 281  67D7 11 5B            DW FILRAM
 282  67D9               ENDIF
 283  67D9               IF (VRAM_CMDS + RAM_CMDS > 0)
 284  67D9 00               DB 0
 285  67DA               ENDIF
 286  67DA              CMDS_G:
 287  67DA               IF (GENCAL_CMD == 1)
 288  67DA 47 45 4E 43      DB "GENCAL", 0
 288  67DE 41 4C 00
 289  67E1 28 5E            DW GENCAL
 290  67E3               ENDIF
 291  67E3               IF (GENCAL_CMD > 0)
 292  67E3 00           	DB	0
 293  67E4               ENDIF
 294  67E4              CMDS_V:
 295  67E4               IF (VRAM_CMDS == 1)
 296  67E4 56 52 4D 4D  	DB "VRMMEM", 0
 296  67E8 45 4D 00
 297  67EB B6 5D        	DW VRMMEM
 298  67ED               ENDIF
 299  67ED               IF (VRAM_CMDS > 0)
 300  67ED 00           	DB 0
 301  67EE               ENDIF
 302  67EE              CMDS_S:
 303  67EE               IF (SPRITE_CMDS + ANIM_CMDS > 0)
 304  67EE 53 47 41 4D      DB "SGAM",0
 304  67F2 00
 305  67F3 DE 58            DW SGAM
 306  67F5               ENDIF
 307  67F5               IF (SPRITE_CMDS == 1)
 308  67F5 53 50 52 47  	DB "SPRGRPMOV", 0
 308  67F9 52 50 4D 4F
 308  67FD 56 00
 309  67FF 18 4F        	DW SPRGRPMOV
 310  6801               ENDIF
 311  6801               IF (SOUND_CMDS == 1)
 312  6801 53 4E 44 53  	DB "SNDSFX", 0
 312  6805 46 58 00
 313  6808 3F 5C        	DW SNDSFX
 314  680A 53 4E 44 50  	DB "SNDPLYON", 0
 314  680E 4C 59 4F 4E
 314  6812 00
 315  6813 09 5C        	DW SNDPLYON
 316  6815 53 4E 44 50  	DB "SNDPLYOFF", 0
 316  6819 4C 59 4F 46
 316  681D 46 00
 317  681F 1C 5C        	DW SNDPLYOFF
 318  6821 53 4E 44 50  	DB "SNDPLYINI", 0
 318  6825 4C 59 49 4E
 318  6829 49 00
 319  682B 8C 5B        	DW SNDPLYINIT
 320  682D               ENDIF
 321  682D               IF (SPRITE_CMDS == 1)
 322  682D 53 50 52 45  	DB "SPRENABLE", 0
 322  6831 4E 41 42 4C
 322  6835 45 00
 323  6837 6E 4E        	DW SPRENABLE
 324  6839 53 50 52 44  	DB "SPRDISABLE", 0
 324  683D 49 53 41 42
 324  6841 4C 45 00
 325  6844 D5 4E        	DW SPRDISABLE
 326  6846               ENDIF
 327  6846               IF (SOUND_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 328  6846 00           	DB 0
 329  6847               ENDIF
 330  6847              CMDS_B:
 331  6847               IF (BLIT_CMDS == 1)
 332  6847 42 4C 49 54  	DB "BLIT", 0
 332  684B 00
 333  684C BE 61        	DW BLIT
 334  684E               ENDIF
 335  684E               IF (BOX_CMDS == 1)
 336  684E 42 4F 58 4D  	DB "BOXMEMCPY", 0
 336  6852 45 4D 43 50
 336  6856 59 00
 337  6858 B7 5E        	DW BOXMEMCPY
 338  685A 42 4F 58 4D  	DB "BOXMEMVRM", 0
 338  685E 45 4D 56 52
 338  6862 4D 00
 339  6864 5A 5F        	DW BOXMEMVRM
 340  6866               ENDIF
 341  6866               IF (BLIT_CMDS + BOX_CMDS > 0)
 342  6866 00           	DB 0
 343  6867               ENDIF
 344  6867              CMDS_T:
 345  6867               IF (TILE_CMDS == 1)
 346  6867 54 49 4C 45  	DB "TILERAM", 0
 346  686B 52 41 4D 00
 347  686F 37 63        	DW TILERAM
 348  6871 54 49 4C 45  	DB "TILEVRM", 0
 348  6875 56 52 4D 00
 349  6879 3B 64        	DW TILEVRM
 350  687B               ENDIF
 351  687B               IF (TILE_CMDS > 0)
 352  687B 00           	DB 0
 353  687C               ENDIF
 354  687C              CMDS_C:
 355  687C               IF (COLL_CMD == 1)
 356  687C 43 4F 4C 4C      DB "COLL", 0
 356  6880 00
 357  6881 08 66            DW COLL
 358  6883               ENDIF
 359  6883               IF (COLL_CMD > 0)
 360  6883 00           	DB	0
 361  6884               ENDIF
 362  6884              CMDS_A:
 363  6884               IF (ANIM_CMDS == 1)
 364  6884 41 4E 49 4D     DB "ANIMSTEP",0
 364  6888 53 54 45 50
 364  688C 00
 365  688D CA 56           DW ANIMSTEP
 366  688F 41 4E 49 4D  	DB "ANIMSTART",0
 366  6893 53 54 41 52
 366  6897 54 00
 367  6899 CF 56        	DW ANIMSTART
 368  689B 41 4E 49 4D  	DB "ANIMSTOP",0
 368  689F 53 54 4F 50
 368  68A3 00
 369  68A4 D4 56        	DW ANIMSTOP
 370  68A6 41 4E 49 4D  	DB "ANIMITEMPAT",0
 370  68AA 49 54 45 4D
 370  68AE 50 41 54 00
 371  68B2 B0 50        	DW ANIMITEMPAT
 372  68B4 41 4E 49 4D  	DB "ANIMITEMPTR",0
 372  68B8 49 54 45 4D
 372  68BC 50 54 52 00
 373  68C0 3B 51        	DW ANIMITEMPTR_CMD
 374  68C2 41 4E 49 4D  	DB "ANIMDEF",0
 374  68C6 44 45 46 00
 375  68CA 01 52        	DW ANIMDEF
 376  68CC 41 4E 49 4D  	DB "ANIMSPRITE",0
 376  68D0 53 50 52 49
 376  68D4 54 45 00
 377  68D7 D8 52        	DW ANIMSPRITE
 378  68D9 41 4E 49 4D     DB "ANIMCHAR",0
 378  68DD 43 48 41 52
 378  68E1 00
 379  68E2 88 53           DW ANIMCHAR
 380  68E4 41 55 54 4F     DB "AUTOSGAMDEF",0
 380  68E8 53 47 41 4D
 380  68EC 44 45 46 00
 381  68F0 9E 54           DW AUTOSGAMDEF
 382  68F2 41 55 54 4F     DB "AUTOSGAMSTART",0
 382  68F6 53 47 41 4D
 382  68FA 53 54 41 52
 382  68FE 54 00
 383  6900 61 56           DW AUTOSGAMSTART
 384  6902 41 55 54 4F     DB "AUTOSGAMSTOP",0
 384  6906 53 47 41 4D
 384  690A 53 54 4F 50
 384  690E 00
 385  690F 9D 56           DW AUTOSGAMSTOP
 386  6911               ENDIF
 387  6911 41 52 54 49     DB "ARTINFO",0
 387  6915 4E 46 4F 00
 388  6919 A5 6A           DW ARTINFO
 389  691B 00           	DB 0
 390  691C               ELSE
 391  691C ~            CMDS_A:
 392  691C ~             DB "ARTINFO",0
 393  691C ~             DW ARTINFO
 394  691C ~             DB 0
 395  691C               ENDIF
 396  691C
 397  691C
 398  691C               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 399  691C              ; ****************************************************************************************************
 400  691C              ; function sets VRAM address
 401  691C              ; input HL=address
 402  691C              ; modifies AF
 403  691C              SETWRT_LOCAL:
 404  691C 7D           	LD	A,L
 405  691D D3 99        	OUT (099H),A
 406  691F 7C           	LD	A,H
 407  6920 E6 3F        	AND 03FH
 408  6922 F6 40        	OR	040H
 409  6924 D3 99        	OUT (099H),A
 410  6926 C9           	RET
 411  6927              ; ****************************************************************************************************
 412  6927               ENDIF
 413  6927
 414  6927               IF (VRAM_CMDS + TILE_CMDS > 0)
 415  6927              ; ****************************************************************************************************
 416  6927              ; function copies data from RAM to VRAM
 417  6927              ; input HL=address in RAM
 418  6927              ; input B=count
 419  6927              ; modifies AF, BC, HL
 420  6927              BBYTECOPY:
 421  6927 0E 98        	LD C,#98
 422  6929              BBYTECOPY_NO_C:
 423  6929 ED A3        	OUTI
 424  692B C2 29 69     	JP	NZ, BBYTECOPY_NO_C
 425  692E C9           	RET
 426  692F              ; ****************************************************************************************************
 427  692F               ENDIF
 428  692F
 429  692F              ; ****************************************************************************************************
 430  692F              ; function multiplies HL by 32
 431  692F              HLx32:
 432  692F 29           	ADD HL,HL
 433  6930              ; ****************************************************************************************************
 434  6930              ; function multiplies HL by 16
 435  6930              HLx16:
 436  6930 29           	ADD HL,HL
 437  6931              ; ****************************************************************************************************
 438  6931              ; function multiplies HL by 8
 439  6931              HLx8:
 440  6931 29          > ADD HL, HL
 440  6932 29          > ADD HL, HL
 440  6933 29          > ADD HL, HL
 441  6934 C9           	RET
 442  6935              ; ****************************************************************************************************
 443  6935
 444  6935              ; ****************************************************************************************************
 445  6935              ; function gets slot and subslot data for specific page
 446  6935              ; input A=page (0, 1 or 2)
 447  6935              ; output B = 0A8H register value
 448  6935              ; output D = 0 is no subslots, 1 if yes
 449  6935              ; output C = 0A8H value when page 3 slot equals to requested page slot
 450  6935              ; output E = subslot value if present
 451  6935              ; modifies AF, BC, DE, HL
 452  6935              GET_PAGE_INFO:
 453  6935 6F               LD L, A
 454  6936 C6 C1            ADD A, low (EXPTBL)
 455  6938 32 42 69         LD (GET_PAGE_INFO_L1+1), A
 456  693B DB A8            IN A, (0A8H)
 457  693D 47               LD B, A
 458  693E E6 3F            AND 03FH
 459  6940 4F               LD C, A
 460  6941              GET_PAGE_INFO_L1:
 461  6941 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 462  6944 E6 80            AND 080H
 463  6946 28 1B            JR Z, GET_PAGE_INFO_L2
 464  6948                  ; expanded
 465  6948 2D               DEC L
 466  6949 FA 68 69         JP M, GET_PAGE_INFO_L3
 467  694C 2D               DEC L
 468  694D FA 66 69         JP M, GET_PAGE_INFO_L4
 469  6950                  ; page 2
 470  6950 07               RLCA
 471  6951 07               RLCA
 472  6952              GET_PAGE_INFO_L5:
 473  6952 E6 C0            AND 0C0H
 474  6954 B1               OR C
 475  6955 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 476  6957 4F               LD C, A
 477  6958 3A FF FF         LD A, (0FFFFH)
 478  695B 2F               CPL
 479  695C 5F               LD E, A
 480  695D 16 01            LD D, 1
 481  695F 78               LD A, B ; return stack
 482  6960 D3 A8            OUT (0A8H), A
 483  6962 C9               RET
 484  6963              GET_PAGE_INFO_L2:
 485  6963                  ; not expanded
 486  6963 16 00            LD D, 0
 487  6965 C9               RET
 488  6966              GET_PAGE_INFO_L4:
 489  6966                  ; page 1
 490  6966 0F               RRCA
 491  6967 0F               RRCA
 492  6968              GET_PAGE_INFO_L3:
 493  6968                  ; page 0
 494  6968 0F               RRCA
 495  6969 0F               RRCA
 496  696A 18 E6            JR GET_PAGE_INFO_L5
 497  696C              ; ****************************************************************************************************
 498  696C
 499  696C              ; ****************************************************************************************************
 500  696C              ; function returns original slot and subslot info
 501  696C              ; input B = 0A8H register value
 502  696C              ; input D = 0 is no subslots, 1 if yes
 503  696C              ; input C = 0A8H value when page 3 slot equals to requested page slot
 504  696C              ; input E = subslot value if present
 505  696C              ; modifies AF, disables interrupts
 506  696C              RESTORE_PAGE_INFO:
 507  696C 7A              LD A, D
 508  696D B7              OR A
 509  696E 28 08           JR Z, RESTORE_PAGE_INFO_L1
 510  6970 79              LD A, C
 511  6971 F3           	DI
 512  6972 D3 A8           OUT (0A8H), A
 513  6974 7B              LD A, E
 514  6975 32 FF FF        LD (0FFFFH), A
 515  6978              RESTORE_PAGE_INFO_L1:
 516  6978 78              LD A, B
 517  6979 D3 A8           OUT (0A8H), A
 518  697B              NOACTION_DEFUSR: ; just a safe RET for use when DEFUSR table has an empty entry
 519  697B C9              RET
 520  697C              ; ****************************************************************************************************
 521  697C
 522  697C              ; *******************************************************************************************************
 523  697C              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 524  697C              ; INPUT:  A = SLOT ID: EXXXSSPP
 525  697C              ; E = EXPANDED FLAG
 526  697C              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 527  697C              ; PP = PRIMARY SLOT NUMBER
 528  697C              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 529  697C              ; CHANGES: AF, BC, DE
 530  697C
 531  697C              LOCAL_ENASLT:
 532  697C CD 9C 69         CALL L0353
 533  697F FA 89 69         JP M, L0340
 534  6982 DB A8            IN A, (0A8H)
 535  6984 A1               AND C
 536  6985 B0               OR B
 537  6986 D3 A8            OUT (0A8H), A
 538  6988 C9               RET
 539  6989              L0340:
 540  6989 E5               PUSH HL
 541  698A CD C1 69         CALL L0378
 542  698D 4F               LD C, A
 543  698E 06 00            LD B, 0
 544  6990 7D               LD A, L
 545  6991 A4               AND H
 546  6992 B2               OR D
 547  6993 21 C5 FC         LD HL, 0FCC5H
 548  6996 09               ADD HL, BC
 549  6997 77               LD (HL), A
 550  6998 E1               POP HL
 551  6999 79               LD A, C
 552  699A 18 E0            JR LOCAL_ENASLT
 553  699C              L0353:
 554  699C F3               DI
 555  699D F5               PUSH AF
 556  699E 7C               LD A, H
 557  699F 07               RLCA
 558  69A0 07               RLCA
 559  69A1 E6 03            AND 3
 560  69A3 5F               LD E, A
 561  69A4 3E C0            LD A, 0C0H
 562  69A6              L035D:
 563  69A6 07               RLCA
 564  69A7 07               RLCA
 565  69A8 1D               DEC E
 566  69A9 F2 A6 69         JP P, L035D
 567  69AC 5F               LD E, A
 568  69AD 2F               CPL
 569  69AE 4F               LD C, A
 570  69AF F1               POP AF
 571  69B0 F5               PUSH AF
 572  69B1 E6 03            AND 3
 573  69B3 3C               INC A
 574  69B4 47               LD B, A
 575  69B5 3E AB            LD A, 0ABH
 576  69B7              L036E:
 577  69B7 C6 55            ADD A, 055H
 578  69B9 10 FC            DJNZ L036E
 579  69BB 57               LD D, A
 580  69BC A3               AND E
 581  69BD 47               LD B, A
 582  69BE F1               POP AF
 583  69BF A7               AND A
 584  69C0 C9               RET
 585  69C1              L0378:
 586  69C1 F5               PUSH AF
 587  69C2 7A               LD A, D
 588  69C3 E6 C0            AND 0C0H
 589  69C5 4F               LD C, A
 590  69C6 F1               POP AF
 591  69C7 F5               PUSH AF
 592  69C8 57               LD D, A
 593  69C9 DB A8            IN A, (0A8H)
 594  69CB 47               LD B, A
 595  69CC E6 3F            AND 03FH
 596  69CE B1               OR C
 597  69CF D3 A8            OUT (0A8H), A
 598  69D1 7A               LD A, D
 599  69D2 0F               RRCA
 600  69D3 0F               RRCA
 601  69D4 E6 03            AND 3
 602  69D6 57               LD D, A
 603  69D7 3E AB            LD A, 0ABH
 604  69D9              L0390:
 605  69D9 C6 55            ADD A, 055H
 606  69DB 15               DEC D
 607  69DC F2 D9 69         JP P, L0390
 608  69DF A3               AND E
 609  69E0 57               LD D, A
 610  69E1 7B               LD A, E
 611  69E2 2F               CPL
 612  69E3 67               LD H, A
 613  69E4 3A FF FF         LD A, (0FFFFH)
 614  69E7 2F               CPL
 615  69E8 6F               LD L, A
 616  69E9 A4               AND H
 617  69EA B2               OR D
 618  69EB 32 FF FF         LD (0FFFFH), A
 619  69EE 78               LD A, B
 620  69EF D3 A8            OUT (0A8H), A
 621  69F1 F1               POP AF
 622  69F2 E6 03            AND 3
 623  69F4 C9               RET
 624  69F5              ; *******************************************************************************************************
 625  69F5
 626  69F5              ; *******************************************************************************************************
 627  69F5              ; some common code to activate page 0 and place values needed to restore original page on stack
 628  69F5              ; input IY=return address
 629  69F5              ENABLE_PAGE0:
 630  69F5 AF              XOR A
 631  69F6 CD 35 69        CALL GET_PAGE_INFO
 632  69F9 C5              PUSH BC
 633  69FA D5              PUSH DE
 634  69FB 3A 41 F3        LD A, (RAMAD0)
 635  69FE 26 00           LD H, 0
 636  6A00 CD 7C 69        CALL LOCAL_ENASLT
 637  6A03 FD E9        	JP (IY)
 638  6A05              ; *******************************************************************************************************
 639  6A05
 640  6A05              ; General BASIC CALL-instruction handler
 641  6A05              CALLHAND:
 642  6A05 FB              EI
 643  6A06 E5           	PUSH HL
 644  6A07 21 46 67     	LD	HL, CMDS ; pointer table based on starting letter
 645  6A0A 3A 89 FD        LD A, (PROCNM)
 646  6A0D D6 41           SUB 'A'
 647  6A0F 87              ADD A, A
 648  6A10 16 00           LD D, 0
 649  6A12 5F              LD E, A
 650  6A13 19              ADD HL, DE
 651  6A14 5E              LD E, (HL)
 652  6A15 23              INC HL
 653  6A16 56              LD D, (HL)
 654  6A17 7A              LD A, D
 655  6A18 B3              OR E
 656  6A19 28 23           JR Z, .CMDNOTRECOGNIZED
 657  6A1B EB              EX DE, HL
 658  6A1C              .CHKCMD:
 659  6A1C 11 89 FD     	LD	DE, PROCNM
 660  6A1F              .LOOP:
 661  6A1F 1A              LD	A,(DE)
 662  6A20 BE           	CP	(HL)
 663  6A21 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 664  6A23 13           	INC	DE
 665  6A24 23           	INC	HL
 666  6A25 A7           	AND	A
 667  6A26 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 668  6A28 5E           	LD	E,(HL)
 669  6A29 23           	INC	HL
 670  6A2A 56           	LD	D,(HL)
 671  6A2B E1           	POP	HL		; routine address
 672  6A2C CD 4D 6A     	CALL	GETPREVCHAR
 673  6A2F CD 41 6A     	CALL	.CALLDE		; Call routine
 674  6A32 A7           	AND	A
 675  6A33 C9           	RET
 676  6A34
 677  6A34              .TONEXTCMD:
 678  6A34 0E FF        	LD	C,0FFH
 679  6A36 AF           	XOR	A
 680  6A37 ED B1        	CPIR			; Skip to end of instruction name
 681  6A39 23           	INC	HL
 682  6A3A 23           	INC	HL		; Skip address
 683  6A3B BE           	CP	(HL)
 684  6A3C 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 685  6A3E              .CMDNOTRECOGNIZED:
 686  6A3E E1           	POP	HL
 687  6A3F 37              SCF
 688  6A40 C9           	RET
 689  6A41
 690  6A41              .CALLDE:
 691  6A41 D5           	PUSH	DE
 692  6A42 C9           	RET
 693  6A43
 694  6A43              ;---------------------------
 695  6A43
 696  6A43              ;GETSTRPNT:
 697  6A43              ; OUT:
 698  6A43              ; HL = String Address
 699  6A43              ; B  = Lenght
 700  6A43              ;        LD      HL,(USR)
 701  6A43              ;        LD      B,(HL)
 702  6A43              ;        INC     HL
 703  6A43              ;        LD      E,(HL)
 704  6A43              ;        INC     HL
 705  6A43              ;        LD      D,(HL)
 706  6A43              ;        EX      DE,HL
 707  6A43              ;        RET
 708  6A43
 709  6A43              ;EVALTXTPARAM:
 710  6A43              ;	CALL	CHKCHAR
 711  6A43              ;	DEFB	"("             ; Check for (
 712  6A43              ;	LD	IX,FRMEVL
 713  6A43              ;	CALL	CALBAS		; Evaluate expression
 714  6A43              ;       LD      A,(VALTYP)
 715  6A43              ;        CP      3               ; Text type?
 716  6A43              ;        JP      NZ,TYPE_MISMATCH
 717  6A43              ;        PUSH	HL
 718  6A43              ;        LD	IX,FRESTR         ; Free the temporary string
 719  6A43              ;        CALL	CALBAS
 720  6A43              ;        POP	HL
 721  6A43              ;	CALL	CHKCHAR
 722  6A43              ;	DEFB	")"             ; Check for )
 723  6A43              ;        RET
 724  6A43
 725  6A43
 726  6A43              CHKCHAR:
 727  6A43 CD 4D 6A     	CALL	GETPREVCHAR	; Get previous basic char
 728  6A46 E3           	EX	(SP),HL
 729  6A47 BE           	CP	(HL) 	        ; Check if good char
 730  6A48 20 1D        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 731  6A4A 23           	INC	HL
 732  6A4B E3           	EX	(SP),HL
 733  6A4C 23           	INC	HL		; Get next basic char
 734  6A4D
 735  6A4D              GETPREVCHAR:
 736  6A4D 2B           	DEC HL
 737  6A4E DD 21 66 46  	LD	IX,CHRGTR
 738  6A52 CD 59 01     	CALL CALBAS
 739  6A55 FB              EI
 740  6A56 C9              RET
 741  6A57
 742  6A57
 743  6A57              TYPE_MISMATCH:
 744  6A57 1E 0D            LD E, 13 ; Type mismatch
 745  6A59 18 0E            JR THROW_ERROR
 746  6A5B              SUBSCRIPT_OUT_OF_RANGE:
 747  6A5B 1E 09            LD E,9 ; subscript out of range
 748  6A5D 18 0A        	JR THROW_ERROR
 749  6A5F              OVERFLOW:
 750  6A5F 1E 06        	LD E,6
 751  6A61 18 06        	JR THROW_ERROR
 752  6A63              ILLEGAL_FUNCTION:
 753  6A63 1E 05            LD E, 5 ; illegal function call
 754  6A65 18 02            JR THROW_ERROR
 755  6A67              SYNTAX_ERROR:
 756  6A67 1E 02            LD E, 2 ; Syntax error
 757  6A69              THROW_ERROR:
 758  6A69 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 759  6A6D C3 59 01     	JP	CALBAS
 760  6A70
 761  6A70              ;---------------------------
 762  6A70
 763  6A70               IF (BASIC_EXTENSION == 1)
 764  6A70              ; *******************************************************************************************************
 765  6A70              ; helper function to get pointer to BASIC array data
 766  6A70              ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
 767  6A70              ; input B=dimensions (1 or 2)
 768  6A70              ; input D=minimal first dimension
 769  6A70              ; input E=minimal second dimension, if applicable
 770  6A70              ; returns BC=pointer to first data element
 771  6A70              ; throws BASIC error if invalid type
 772  6A70              GET_BASIC_ARRAY_DATA_POINTER:
 773  6A70 D5           	PUSH DE
 774  6A71 C5           	PUSH BC
 775  6A72 F5           	PUSH AF
 776  6A73 3E 01           LD A,1
 777  6A75 32 A5 F6        LD (SUBFLG),A ; search for arrays only
 778  6A78 DD 21 A4 5E  	LD IX, PTRGET
 779  6A7C CD 59 01     	CALL CALBAS
 780  6A7F AF              XOR A
 781  6A80 32 A5 F6        LD (SUBFLG),A ; if not reset will cause syntax errors
 782  6A83 3A 63 F6     	LD A,(VALTYP)
 783  6A86 D1           	POP DE ; required type
 784  6A87 BA           	CP D
 785  6A88 C2 57 6A     	JP NZ,TYPE_MISMATCH
 786  6A8B 0A           	LD A,(BC)
 787  6A8C 03           	INC BC
 788  6A8D D1           	POP DE ; required number of dimensions
 789  6A8E BA           	CP D
 790  6A8F C2 57 6A     	JP NZ,TYPE_MISMATCH
 791  6A92 D1           	POP DE ; required minimal array dimensions
 792  6A93 3D           	DEC A
 793  6A94 28 07        	JR Z,.ONE_DIMENSION
 794  6A96              	; 2-dimension array
 795  6A96 0A           	LD A,(BC)
 796  6A97 03          > INC BC
 796  6A98 03          > INC BC
 797  6A99 BB           	CP E
 798  6A9A DA 5B 6A     	JP C,SUBSCRIPT_OUT_OF_RANGE
 799  6A9D              .ONE_DIMENSION:
 800  6A9D 0A           	LD A,(BC)
 801  6A9E 03          > INC BC
 801  6A9F 03          > INC BC
 802  6AA0 BA           	CP D
 803  6AA1 DA 5B 6A     	JP C,SUBSCRIPT_OUT_OF_RANGE
 804  6AA4 C9           	RET
 805  6AA5              ; *******************************************************************************************************
 806  6AA5               ENDIF
 807  6AA5
 808  6AA5              ; *******************************************************************************************************
 809  6AA5              ; function to handle CALL ARTINFO basic extension
 810  6AA5              ; returns info about the extension
 811  6AA5              ; _ARTINFO ( INT variable version,
 812  6AA5              ;			    INT variable build_flags,
 813  6AA5              ;			    INT variable free_memory_ptr )
 814  6AA5              ; this function is always available and can be used to test if the extension is active
 815  6AA5              ARTINFO:
 816  6AA5              	; opening (
 817  6AA5 CD 43 6A     	CALL CHKCHAR
 818  6AA8 28           	DB '('
 819  6AA9              	; get address of version variable
 820  6AA9 DD 21 A4 5E  	LD IX, PTRGET
 821  6AAD CD 59 01     	CALL CALBAS
 822  6AB0 3A 12 40     	LD A,(VERSION)
 823  6AB3 12              LD (DE),A
 824  6AB4 13              INC DE
 825  6AB5 3A 13 40        LD A,(VERSION+1)
 826  6AB8 12              LD (DE),A
 827  6AB9              	; comma
 828  6AB9 CD 43 6A     	CALL CHKCHAR
 829  6ABC 2C           	DB ','
 830  6ABD              	; get address of build flags variable
 831  6ABD DD 21 A4 5E  	LD IX, PTRGET
 832  6AC1 CD 59 01     	CALL CALBAS
 833  6AC4 E5              PUSH HL
 834  6AC5 21 FF 0F        LD HL,SOUND_CMDS+2*RAM_CMDS+4*VRAM_CMDS+8*BLIT_CMDS+16*SPRITE_CMDS+32*GENCAL_CMD+64*TILE_CMDS+128*BOX_CMDS+256*ANIM_CMDS+512*COLL_CMD+1024*BASIC_EXTENSION+2048*DEFUSR_EXTENSION
 835  6AC8 EB              EX DE,HL
 836  6AC9 73              LD (HL),E
 837  6ACA 23              INC HL
 838  6ACB 72              LD (HL),D
 839  6ACC E1              POP HL
 840  6ACD              	; comma
 841  6ACD CD 43 6A     	CALL CHKCHAR
 842  6AD0 2C           	DB ','
 843  6AD1              	; get address of free memory variable
 844  6AD1 DD 21 A4 5E  	LD IX, PTRGET
 845  6AD5 CD 59 01     	CALL CALBAS
 846  6AD8 3A 10 40     	LD A,(FREEMEMPTR)
 847  6ADB 12              LD (DE),A
 848  6ADC 13              INC DE
 849  6ADD 3A 11 40        LD A,(FREEMEMPTR+1)
 850  6AE0 12              LD (DE),A
 851  6AE1              	; ending )
 852  6AE1 CD 43 6A     	CALL CHKCHAR
 853  6AE4 29           	DB ')'
 854  6AE5 C9           	RET
 855  6AE6              ; *******************************************************************************************************
 856  6AE6
 857  6AE6              EXT_END:
 858  6AE6
# file closed: asm\main.asm
