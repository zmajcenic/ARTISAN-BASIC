# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		   EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000              COLL_CMD       EQU 1
  14  4000
  15  4000              BASIC_EXTENSION   EQU 1
  16  4000              DEFUSR_EXTENSION  EQU 1
  17  4000
  18  4000               DEFINE CMDS_WITH_PARAMETERS
  19  4000
  20  4000              CHPUT   EQU    #A2
  21  4000              CALBAS  EQU		#159
  22  4000              ERRHAND EQU    #406F
  23  4000              FRMEVL  EQU    #4C64
  24  4000              FRESTR  EQU		#67D0
  25  4000              ; FRMQNT = formula quantificator
  26  4000              ; input HL=pointer to current program expression
  27  4000              ; output HL=next address
  28  4000              ; output DE=integer datum
  29  4000              FRMQNT	EQU		#542F
  30  4000              ; GETBYT = get byte parameter
  31  4000              ; input HL=pointer to current program expression
  32  4000              ; output HL=next address
  33  4000              ; output A=E=byte read
  34  4000              GETBYT		EQU	#521C
  35  4000              CHRGTR  	   EQU   #4666
  36  4000              PTRGET		EQU 	#5EA4
  37  4000              SUBFLG		EQU	#F6A5
  38  4000              SYNCHR		EQU	#558C
  39  4000              VALTYP  	   EQU   #F663
  40  4000              DAC         EQU   #F7F6
  41  4000              USR     	   EQU   #F7F8
  42  4000              PROCNM		EQU	#FD89
  43  4000              BIOS_FILVRM EQU   #0056
  44  4000              CLIKSW		EQU	#F3DB
  45  4000
  46  4000              RAMAD0	   EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  47  4000              RAMAD1	   EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  48  4000              RAMAD2	   EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  49  4000              RAMAD3	   EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  50  4000              EXPTBL	   EQU   #FCC1
  51  4000              SCRMOD	   EQU   #FCAF ; current screen mode
  52  4000              REG1SAV     EQU   #F3E0 ; VDP(1)
  53  4000              JIFFY	      EQU   #FC9E
  54  4000              GRPPAT	   EQU   #F3CF ; SCREEN 2 sprite generator table address
  55  4000              GRPCGP		EQU	#F3CB ; SCREEN 2 pattern generator table address
  56  4000              GRPATR      EQU   #F3CD ; SCREEN 2 sprite attribute table address
  57  4000              T32PAT	   EQU   #F3C5 ; SCREEN 1 sprite generator table address
  58  4000              T32CGP      EQU   #F3C1 ; SCREEN 1 pattern ganarator table address
  59  4000              T32ATR      EQU   #F3C3 ; SCREEN 1 sprite attribute table address
  60  4000
  61  4000              ; BASIC error codes
  62  4000              ;01 NEXT without FOR
  63  4000              ;02 Syntax error
  64  4000              ;03 RETURN without GOSUB
  65  4000              ;04 Out of DATA
  66  4000              ;05 Illegal function call
  67  4000              ;06 Overflow
  68  4000              ;07 Out of memory
  69  4000              ;08 Undefined line number
  70  4000              ;09 Subscript out of range
  71  4000              ;10 Redimensioned array
  72  4000              ;11 Division by zero
  73  4000              ;12 Illegal direct
  74  4000              ;13 Type mismatch
  75  4000              ;14 Out of string space
  76  4000              ;15 String too long
  77  4000              ;16 String formula too complex
  78  4000              ;17 Can't CONTINUE
  79  4000              ;18 Undefined user function
  80  4000              ;19 Device I/O error
  81  4000              ;20 Verify error
  82  4000              ;21 No RESUME
  83  4000              ;22 RESUME without error
  84  4000              ;23 Unprintable error
  85  4000              ;24 Missing operand
  86  4000              ;25 Line buffer overflow
  87  4000              ;50 FIELD overflow
  88  4000              ;51 Internal error
  89  4000              ;52 Bad file number
  90  4000              ;53 File not found
  91  4000              ;54 File already open
  92  4000              ;55 Input past end
  93  4000              ;56 Bad file name
  94  4000              ;57 Direct statement in file
  95  4000              ;58 Sequential I/O only
  96  4000              ;59 File not OPEN
  97  4000
  98  4000
  99  4000               ; simulate cartridge with BASIC extension
 100  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
 100  4004 9F 67 00 00
 100  4008 00 00 00 00
 100  400C 00 00 00 00
 101  4010
 102  4010              ; this location #4010 stores last location used by basic extension
 103  4010              ; free memory after that point
 104  4010              FREEMEMPTR:
 105  4010 80 68         DW EXT_END
 106  4012
 107  4012              ; this location #4012 stores extension version in DAA format
 108  4012              ; first byte is major version and second minor
 109  4012              VERSION:
 110  4012 00 81         DB #00, #81
 111  4014
 112  4014              ; this location #4014 contains a jump to entry point for DEFUSR approach
 113  4014              ; if excluded it contains 3xRET so that sound player can be at aspecific spot
 114  4014               IF (DEFUSR_EXTENSION == 1)
 115  4014 C3 B0 64        JP DEFUSR_ENTRY
 116  4017               ELSE
 117  4017 ~               .3 RET
 118  4017               ENDIF
 119  4017
 120  4017              ; binary included AKG player compiled at #4017
 121  4017               IF (SOUND_CMDS == 1)
 122  4017              	INCBIN "bin/AKG.bin"
 123  4CF3              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF3              MAIN_PLAYER_START EQU 04017H
   2+ 4CF3              PLY_AKG_START EQU 04017H
   3+ 4CF3              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 04020H
   4+ 4CF3              PLY_AKG_INITSOUNDEFFECTS EQU 04020H
   5+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04024H
   6+ 4CF3              PLY_AKG_PLAYSOUNDEFFECT EQU 04024H
   7+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04025H
   8+ 4CF3              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04025H
   9+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 0404CH
  10+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 0404CH
  11+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 0405AH
  12+ 4CF3              PLY_AKG_PSES_PLAY EQU 04093H
  13+ 4CF3              PLY_AKG_PSES_READFIRSTBYTE EQU 0409CH
  14+ 4CF3              PLY_AKG_PSES_S_ENDORLOOP EQU 040B4H
  15+ 4CF3              PLY_AKG_PSES_S_LOOP EQU 040BFH
  16+ 4CF3              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C5H
  17+ 4CF3              PLY_AKG_PSES_NOTREACHED EQU 040D8H
  18+ 4CF3              PLY_AKG_PSES_HARDWAREONLY EQU 040DCH
  19+ 4CF3              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E3H
  20+ 4CF3              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F5H
  21+ 4CF3              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FFH
  22+ 4CF3              PLY_AKG_PSES_H_AFTERRETRIG EQU 04109H
  23+ 4CF3              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411DH
  24+ 4CF3              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 04122H
  25+ 4CF3              PLY_AKG_PSES_READHARDWAREPERIOD EQU 0412AH
  26+ 4CF3              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04135H
  27+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 04141H
  28+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04143H
  29+ 4CF3              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04149H
  30+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414DH
  31+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414DH
  32+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414FH
  33+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414FH
  34+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414FH
  35+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 04150H
  36+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 04151H
  37+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04155H
  38+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04155H
  39+ 4CF3              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04155H
  40+ 4CF3              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415DH
  41+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04165H
  42+ 4CF3              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04165H
  43+ 4CF3              PLY_AKG_INIT EQU 04165H
  44+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04165H
  45+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04193H
  46+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A7H
  47+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B9H
  48+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D8H
  49+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E5H
  50+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL EQU 041EBH
  51+ 4CF3              PLY_AKG_INITTABLE0 EQU 041EEH
  52+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EEH
  53+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04208H
  54+ 4CF3              PLY_AKG_INITTABLE0_END EQU 04208H
  55+ 4CF3              PLY_AKG_INITTABLE1 EQU 04208H
  56+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04208H
  57+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 0420CH
  58+ 4CF3              PLY_AKG_INITTABLE1_END EQU 0420CH
  59+ 4CF3              PLY_AKG_INITTABLEORA EQU 0420CH
  60+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 0420CH
  61+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04224H
  62+ 4CF3              PLY_AKG_INITTABLEORA_END EQU 04224H
  63+ 4CF3              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04224H
  64+ 4CF3              PLY_AKG_STOP EQU 04224H
  65+ 4CF3              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04236H
  66+ 4CF3              PLY_AKG_PLAY EQU 04236H
  67+ 4CF3              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423EH
  68+ 4CF3              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04244H
  69+ 4CF3              PLY_AKG_READLINKER EQU 04249H
  70+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04249H
  71+ 4CF3              PLY_AKG_READLINKER_PTLINKER EQU 04249H
  72+ 4CF3              PLY_AKG_READLINKER_NOLOOP EQU 04254H
  73+ 4CF3              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428DH
  74+ 4CF3              PLY_AKG_READLINE EQU 04290H
  75+ 4CF3              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 04290H
  76+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04296H
  77+ 4CF3              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04296H
  78+ 4CF3              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A3H
  79+ 4CF3              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A7H
  80+ 4CF3              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042AAH
  81+ 4CF3              PLY_AKG_SPEEDTRACK_END EQU 042ADH
  82+ 4CF3              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042ADH
  83+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B3H
  84+ 4CF3              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B3H
  85+ 4CF3              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042C0H
  86+ 4CF3              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C4H
  87+ 4CF3              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C7H
  88+ 4CF3              PLY_AKG_EVENTTRACK_END EQU 042CAH
  89+ 4CF3              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042CAH
  90+ 4CF3              PLY_AKG_CHANNEL1_READTRACK EQU 042D6H
  91+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D6H
  92+ 4CF3              PLY_AKG_CHANNEL1_PTTRACK EQU 042D6H
  93+ 4CF3              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042F1H
  94+ 4CF3              PLY_AKG_CHANNEL1_WAIT EQU 042FCH
  95+ 4CF3              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04303H
  96+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04303H
  97+ 4CF3              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04303H
  98+ 4CF3              PLY_AKG_CHANNEL1_NOTE EQU 0430CH
  99+ 4CF3              PLY_AKG_BASENOTEINDEX EQU 0430CH
 100+ 4CF3              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430EH
 101+ 4CF3              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430EH
 102+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431EH
 103+ 4CF3              PLY_AKG_INSTRUMENTSTABLE EQU 0431EH
 104+ 4CF3              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 04330H
 105+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 04340H
 106+ 4CF3              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04368H
 107+ 4CF3              PLY_AKG_CHANNEL1_READCELLEND EQU 0436BH
 108+ 4CF3              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 0436BH
 109+ 4CF3              PLY_AKG_CHANNEL2_READTRACK EQU 04377H
 110+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04377H
 111+ 4CF3              PLY_AKG_CHANNEL2_PTTRACK EQU 04377H
 112+ 4CF3              PLY_AKG_CHANNEL2_SMALLWAIT EQU 04392H
 113+ 4CF3              PLY_AKG_CHANNEL2_WAIT EQU 0439DH
 114+ 4CF3              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A4H
 115+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A4H
 116+ 4CF3              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A4H
 117+ 4CF3              PLY_AKG_CHANNEL2_NOTE EQU 043ADH
 118+ 4CF3              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043B2H
 119+ 4CF3              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043B2H
 120+ 4CF3              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D4H
 121+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E4H
 122+ 4CF3              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 0440CH
 123+ 4CF3              PLY_AKG_CHANNEL2_READCELLEND EQU 0440FH
 124+ 4CF3              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440FH
 125+ 4CF3              PLY_AKG_CHANNEL3_READTRACK EQU 0441BH
 126+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 0441BH
 127+ 4CF3              PLY_AKG_CHANNEL3_PTTRACK EQU 0441BH
 128+ 4CF3              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04436H
 129+ 4CF3              PLY_AKG_CHANNEL3_WAIT EQU 04441H
 130+ 4CF3              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04448H
 131+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04448H
 132+ 4CF3              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04448H
 133+ 4CF3              PLY_AKG_CHANNEL3_NOTE EQU 04451H
 134+ 4CF3              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04456H
 135+ 4CF3              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04456H
 136+ 4CF3              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04478H
 137+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04488H
 138+ 4CF3              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044B0H
 139+ 4CF3              PLY_AKG_CHANNEL3_READCELLEND EQU 044B3H
 140+ 4CF3              PLY_AKG_CURRENTSPEED EQU 044B3H
 141+ 4CF3              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B5H
 142+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B8H
 143+ 4CF3              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B8H
 144+ 4CF3              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044BBH
 145+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BEH
 146+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BEH
 147+ 4CF3              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044CAH
 148+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044D1H
 149+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D4H
 150+ 4CF3              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044DAH
 151+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DDH
 152+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DDH
 153+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044EBH
 154+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044F0H
 155+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044FBH
 156+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FEH
 157+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FEH
 158+ 4CF3              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 04501H
 159+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04504H
 160+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04504H
 161+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450DH
 162+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04517H
 163+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 0451AH
 164+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 0451AH
 165+ 4CF3              PLY_AKG_CHANNEL1_PITCH EQU 0451AH
 166+ 4CF3              PLY_AKG_CHANNEL1_ISPITCH EQU 0451DH
 167+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 04522H
 168+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACK EQU 04522H
 169+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04526H
 170+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04528H
 171+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 0452AH
 172+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 04531H
 173+ 4CF3              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 04532H
 174+ 4CF3              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04535H
 175+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04535H
 176+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 04551H
 177+ 4CF3              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 04551H
 178+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455EH
 179+ 4CF3              PLY_AKG_CHANNEL1_GLIDEOVER EQU 04562H
 180+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 04572H
 181+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 04572H
 182+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04573H
 183+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04574H
 184+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04576H
 185+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04576H
 186+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04576H
 187+ 4CF3              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04577H
 188+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04578H
 189+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 0457AH
 190+ 4CF3              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 0457AH
 191+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 0457AH
 192+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 0457AH
 193+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 0457AH
 194+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457DH
 195+ 4CF3              PLY_AKG_CHANNEL1_PITCH_END EQU 0457FH
 196+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04587H
 197+ 4CF3              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04587H
 198+ 4CF3              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 0458AH
 199+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458DH
 200+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458DH
 201+ 4CF3              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04599H
 202+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 045A0H
 203+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A3H
 204+ 4CF3              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A9H
 205+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045ACH
 206+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045ACH
 207+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045BAH
 208+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BFH
 209+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045CAH
 210+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CDH
 211+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CDH
 212+ 4CF3              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045D0H
 213+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D3H
 214+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D3H
 215+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045DCH
 216+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E6H
 217+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E9H
 218+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E9H
 219+ 4CF3              PLY_AKG_CHANNEL2_PITCH EQU 045E9H
 220+ 4CF3              PLY_AKG_CHANNEL2_ISPITCH EQU 045ECH
 221+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045F1H
 222+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045F1H
 223+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F5H
 224+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F7H
 225+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F9H
 226+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 04600H
 227+ 4CF3              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 04601H
 228+ 4CF3              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04604H
 229+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04604H
 230+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 04620H
 231+ 4CF3              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 04620H
 232+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462DH
 233+ 4CF3              PLY_AKG_CHANNEL2_GLIDEOVER EQU 04631H
 234+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 04641H
 235+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 04641H
 236+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 04642H
 237+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04643H
 238+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04645H
 239+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04645H
 240+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04645H
 241+ 4CF3              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04646H
 242+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04647H
 243+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04649H
 244+ 4CF3              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04649H
 245+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04649H
 246+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04649H
 247+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04649H
 248+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_END EQU 0464CH
 249+ 4CF3              PLY_AKG_CHANNEL2_PITCH_END EQU 0464EH
 250+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04656H
 251+ 4CF3              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04656H
 252+ 4CF3              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04659H
 253+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 0465CH
 254+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 0465CH
 255+ 4CF3              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04668H
 256+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466FH
 257+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 04672H
 258+ 4CF3              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04678H
 259+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 0467BH
 260+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 0467BH
 261+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04689H
 262+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468EH
 263+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04699H
 264+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 0469CH
 265+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 0469CH
 266+ 4CF3              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469FH
 267+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 046A2H
 268+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE EQU 046A2H
 269+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046ABH
 270+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B5H
 271+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B8H
 272+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B8H
 273+ 4CF3              PLY_AKG_CHANNEL3_PITCH EQU 046B8H
 274+ 4CF3              PLY_AKG_CHANNEL3_ISPITCH EQU 046BBH
 275+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046C0H
 276+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046C0H
 277+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C4H
 278+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C6H
 279+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C8H
 280+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CFH
 281+ 4CF3              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046D0H
 282+ 4CF3              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D3H
 283+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D3H
 284+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046EFH
 285+ 4CF3              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046EFH
 286+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046FCH
 287+ 4CF3              PLY_AKG_CHANNEL3_GLIDEOVER EQU 04700H
 288+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 04710H
 289+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 04710H
 290+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 04711H
 291+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 04712H
 292+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04714H
 293+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04714H
 294+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04714H
 295+ 4CF3              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04715H
 296+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04716H
 297+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04718H
 298+ 4CF3              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04718H
 299+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04718H
 300+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04718H
 301+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04718H
 302+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_END EQU 0471BH
 303+ 4CF3              PLY_AKG_CHANNEL3_PITCH_END EQU 0471DH
 304+ 4CF3              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04729H
 305+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04729H
 306+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04729H
 307+ 4CF3              PLY_AKG_CHANNEL1_TRACKNOTE EQU 0472CH
 308+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472EH
 309+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04734H
 310+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04737H
 311+ 4CF3              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04737H
 312+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 0473AH
 313+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04743H
 314+ 4CF3              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 0474BH
 315+ 4CF3              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04758H
 316+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04758H
 317+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04758H
 318+ 4CF3              PLY_AKG_CHANNEL2_TRACKNOTE EQU 0475BH
 319+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475DH
 320+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04763H
 321+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04766H
 322+ 4CF3              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04766H
 323+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04769H
 324+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 04772H
 325+ 4CF3              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 0477AH
 326+ 4CF3              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04788H
 327+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04788H
 328+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04788H
 329+ 4CF3              PLY_AKG_CHANNEL3_TRACKNOTE EQU 0478BH
 330+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478DH
 331+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04793H
 332+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04796H
 333+ 4CF3              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04796H
 334+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04799H
 335+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 047A2H
 336+ 4CF3              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047AAH
 337+ 4CF3              PLY_AKG_SENDPSGREGISTERS EQU 047B9H
 338+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047C1H
 339+ 4CF3              PLY_AKG_PSGREG01_INSTR EQU 047C1H
 340+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047D1H
 341+ 4CF3              PLY_AKG_PSGREG23_INSTR EQU 047D1H
 342+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047E2H
 343+ 4CF3              PLY_AKG_PSGREG45_INSTR EQU 047E2H
 344+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F3H
 345+ 4CF3              PLY_AKG_PSGREG6_8_INSTR EQU 047F3H
 346+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04804H
 347+ 4CF3              PLY_AKG_PSGREG9_10_INSTR EQU 04804H
 348+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04815H
 349+ 4CF3              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04815H
 350+ 4CF3              PLY_AKG_PSGREG13_OLDVALUE EQU 0482AH
 351+ 4CF3              PLY_AKG_RETRIG EQU 0482CH
 352+ 4CF3              PLY_AKG_PSGREG13_INSTR EQU 0482EH
 353+ 4CF3              PLY_AKG_PSGREG13_END EQU 0483DH
 354+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483DH
 355+ 4CF3              PLY_AKG_SAVESP EQU 0483DH
 356+ 4CF3              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 04841H
 357+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTS EQU 04849H
 358+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04856H
 359+ 4CF3              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04856H
 360+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485EH
 361+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 0486BH
 362+ 4CF3              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 0486BH
 363+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTS EQU 04873H
 364+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487EH
 365+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS EQU 0487EH
 366+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488DH
 367+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488DH
 368+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04894H
 369+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A4H
 370+ 4CF3              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A4H
 371+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048ABH
 372+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048ABH
 373+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048AEH
 374+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B7H
 375+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B7H
 376+ 4CF3              PLY_AKG_READINSTRUMENTCELL EQU 048BDH
 377+ 4CF3              PLY_AKG_NOSOFTNOHARD EQU 048CAH
 378+ 4CF3              PLY_AKG_NSNH_NONOISE EQU 048DFH
 379+ 4CF3              PLY_AKG_SOFT EQU 048E2H
 380+ 4CF3              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E9H
 381+ 4CF3              PLY_AKG_S_NOTSIMPLE EQU 048F1H
 382+ 4CF3              PLY_AKG_S_AFTERSIMPLETEST EQU 048F4H
 383+ 4CF3              PLY_AKG_HARDTOSOFT EQU 04901H
 384+ 4CF3              PLY_AKG_HS_JUMPRATIO EQU 0490CH
 385+ 4CF3              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04939H
 386+ 4CF3              PLY_AKG_ENDWITHOUTLOOP EQU 0493BH
 387+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 0493BH
 388+ 4CF3              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 0493BH
 389+ 4CF3              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04943H
 390+ 4CF3              PLY_AKG_SH_JUMPRATIO EQU 04950H
 391+ 4CF3              PLY_AKG_SH_JUMPRATIOEND EQU 04971H
 392+ 4CF3              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 04980H
 393+ 4CF3              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04986H
 394+ 4CF3              PLY_AKG_H_OR_ENDWITHLOOP EQU 049A0H
 395+ 4CF3              PLY_AKG_H_RETRIGEND EQU 049B2H
 396+ 4CF3              PLY_AKG_H_AFTERRETRIG EQU 049B3H
 397+ 4CF3              PLY_AKG_ENDWITHLOOP EQU 049C5H
 398+ 4CF3              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049CCH
 399+ 4CF3              PLY_AKG_S_OR_H_NEXTBYTE EQU 049E2H
 400+ 4CF3              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049F0H
 401+ 4CF3              PLY_AKG_S_OR_H_AFTERPITCH EQU 04A00H
 402+ 4CF3              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0EH
 403+ 4CF3              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1DH
 404+ 4CF3              PLY_AKG_SHOHS_RETRIGEND EQU 04A2CH
 405+ 4CF3              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2DH
 406+ 4CF3              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3FH
 407+ 4CF3              PLY_AKG_EFFECTTABLE EQU 04A4DH
 408+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4DH
 409+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A71H
 410+ 4CF3              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A71H
 411+ 4CF3              PLY_AKG_EFFECT_RESET EQU 04A74H
 412+ 4CF3              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A76H
 413+ 4CF3              PLY_AKG_EFFECT_VOLUME EQU 04A91H
 414+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9DH
 415+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA3H
 416+ 4CF3              PLY_AKG_ARPEGGIOSTABLE EQU 04AA3H
 417+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04ACAH
 418+ 4CF3              PLY_AKG_EFFECT_PITCHTABLE EQU 04AD1H
 419+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD7H
 420+ 4CF3              PLY_AKG_PITCHESTABLE EQU 04AD7H
 421+ 4CF3              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFEH
 422+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B05H
 423+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B16H
 424+ 4CF3              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1DH
 425+ 4CF3              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2DH
 426+ 4CF3              PLY_AKG_EFFECT_PITCHUP EQU 04B42H
 427+ 4CF3              PLY_AKG_EFFECT_PITCHSTOP EQU 04B54H
 428+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B5BH
 429+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B85H
 430+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B85H
 431+ 4CF3              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9EH
 432+ 4CF3              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9EH
 433+ 4CF3              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BB0H
 434+ 4CF3              PLY_AKG_EFFECT_LEGATO EQU 04BC6H
 435+ 4CF3              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BDAH
 436+ 4CF3              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BE2H
 437+ 4CF3              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BEAH
 438+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BF2H
 439+ 4CF3              PLY_AKG_EVENT EQU 04BF2H
 440+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF3H
 441+ 4CF3              PLY_AKG_PERIODTABLE EQU 04BF3H
 442+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF3H
 443+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF3H
 444+ 4CF3              PLY_AKG_PERIODTABLE_END EQU 04CF3H
 445+ 4CF3              PLY_AKG_END EQU 04CF3H
 446+ 4CF3              MAIN_PLAYER_END EQU 04CF3H
 447+ 4CF3              TESTEREND EQU 04CF3H
 448+ 4CF3
# file closed: ./symbol/AKG.sym
 124  4CF3               ENDIF
 125  4CF3
 126  4CF3               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
   1+ 4CF3              ORIG.HTIMI:
   2+ 4CF3 00 00 00 00  	DB 0, 0, 0, 0, 0
   2+ 4CF7 00
   3+ 4CF8               EXPORT ORIG.HTIMI
   4+ 4CF8
   5+ 4CF8              ; *******************************************************************************************************
   6+ 4CF8              ; interrupt handler when page 0 enabled
   7+ 4CF8              ; we are here only if one of the extended basic commands have paged in page 0
   8+ 4CF8              ; which means we arrived from BASIC so page 2 is already good
   9+ 4CF8              VBLANK:
  10+ 4CF8              	EXPORT VBLANK
  11+ 4CF8
  12+ 4CF8 F5               PUSH AF
  13+ 4CF9              	; is VDP originator ?
  14+ 4CF9 DB 99        	IN	A, (099H)
  15+ 4CFB A7           	AND	A
  16+ 4CFC F2 23 4D     	JP P, .EXIT
  17+ 4CFF
  18+ 4CFF               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  19+ 4CFF C5               PUSH BC
  20+ 4D00 D5               PUSH DE
  21+ 4D01 E5               PUSH HL
  22+ 4D02 08               EX AF, AF'
  23+ 4D03 D9               EXX
  24+ 4D04 F5               PUSH AF
  25+ 4D05 C5               PUSH BC
  26+ 4D06 D5               PUSH DE
  27+ 4D07 E5               PUSH HL
  28+ 4D08 DD E5            PUSH IX
  29+ 4D0A FD E5            PUSH IY
  30+ 4D0C
  31+ 4D0C               IF (SPRITE_CMDS == 1)
  32+ 4D0C CD 5D 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  33+ 4D0F               ENDIF
  34+ 4D0F
  35+ 4D0F               IF (SOUND_CMDS == 1)
  36+ 4D0F 3A D5 59     	LD A, (SOUND_ENABLED)
  37+ 4D12 B7           	OR A
  38+ 4D13 C4 36 42     	CALL NZ,PLY_AKG_PLAY
  39+ 4D16               ENDIF
  40+ 4D16
  41+ 4D16                  ; increase JIFFY
  42+ 4D16                  ;LD HL,(JIFFY)
  43+ 4D16                  ;INC HL
  44+ 4D16                  ;LD (JIFFY),HL
  45+ 4D16
  46+ 4D16 FD E1            POP IY
  47+ 4D18 DD E1            POP IX
  48+ 4D1A E1               POP HL
  49+ 4D1B D1               POP DE
  50+ 4D1C C1               POP BC
  51+ 4D1D F1               POP AF
  52+ 4D1E 08               EX AF, AF'
  53+ 4D1F D9               EXX
  54+ 4D20 E1               POP HL
  55+ 4D21 D1               POP DE
  56+ 4D22 C1               POP BC
  57+ 4D23               ENDIF
  58+ 4D23
  59+ 4D23              .EXIT:
  60+ 4D23 F1           	POP AF
  61+ 4D24 FB           	EI
  62+ 4D25 ED 4D        	RETI
  63+ 4D27              ; *******************************************************************************************************
  64+ 4D27
  65+ 4D27              ; *******************************************************************************************************
  66+ 4D27              ; H.TIMI function
  67+ 4D27              ; we can end up here from anywhere so page in both page 0 and 2
  68+ 4D27              MBGE_HTIMI:
  69+ 4D27               EXPORT MBGE_HTIMI
  70+ 4D27
  71+ 4D27               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  72+ 4D27
  73+ 4D27 F5           	PUSH AF
  74+ 4D28
  75+ 4D28              	; enable page 2
  76+ 4D28 3E 02            LD A, 2
  77+ 4D2A CD CF 66         CALL GET_PAGE_INFO
  78+ 4D2D C5               PUSH BC
  79+ 4D2E D5               PUSH DE
  80+ 4D2F 3A 43 F3         LD A, (RAMAD2)
  81+ 4D32 26 80            LD H, 080H
  82+ 4D34 CD 16 67         CALL LOCAL_ENASLT
  83+ 4D37              	; enable page 0
  84+ 4D37 AF               XOR A
  85+ 4D38 CD CF 66         CALL GET_PAGE_INFO
  86+ 4D3B C5               PUSH BC
  87+ 4D3C D5               PUSH DE
  88+ 4D3D 3A 41 F3         LD A, (RAMAD0)
  89+ 4D40 26 00            LD H, 0
  90+ 4D42 CD 16 67         CALL LOCAL_ENASLT
  91+ 4D45
  92+ 4D45               IF (SPRITE_CMDS == 1)
  93+ 4D45 CD 5D 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  94+ 4D48               ENDIF
  95+ 4D48
  96+ 4D48               IF (SOUND_CMDS == 1)
  97+ 4D48 3A D5 59     	LD A, (SOUND_ENABLED)
  98+ 4D4B B7           	OR A
  99+ 4D4C C4 36 42     	CALL NZ,PLY_AKG_PLAY
 100+ 4D4F               ENDIF
 101+ 4D4F
 102+ 4D4F              	; restore page 0
 103+ 4D4F D1               POP DE
 104+ 4D50 C1               POP BC
 105+ 4D51 CD 06 67         CALL RESTORE_PAGE_INFO
 106+ 4D54              	; restore page 2
 107+ 4D54 D1               POP DE
 108+ 4D55 C1               POP BC
 109+ 4D56 CD 06 67         CALL RESTORE_PAGE_INFO
 110+ 4D59
 111+ 4D59 F1           	POP AF
 112+ 4D5A               ENDIF
 113+ 4D5A C3 F3 4C     	JP ORIG.HTIMI
 114+ 4D5D              ; *******************************************************************************************************
 115+ 4D5D
 116+ 4D5D              ; *******************************************************************************************************
 117+ 4D5D              ; function checks if the sprite system is initialized and what screen mode we are running
 118+ 4D5D              ; also checks if some VRAM modifying command is running
 119+ 4D5D              ; when that checks out calls sprite updates and animation processing
 120+ 4D5D              ; if in an unsupported mode disables sprite handling
 121+ 4D5D              PROCESS_SPRITES_AND_ANIMATIONS:
 122+ 4D5D              	; check if initialized
 123+ 4D5D 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
 124+ 4D60 B7           	OR A
 125+ 4D61 C8           	RET Z
 126+ 4D62              	; check screen mode
 127+ 4D62 3A AF FC     	LD A, (SCRMOD)
 128+ 4D65 3D           	DEC A
 129+ 4D66 28 08        	JR Z, .L0 ; screen 1
 130+ 4D68 3D           	DEC A
 131+ 4D69 28 05            JR Z, .L0 ; screen 2
 132+ 4D6B              	; unsupported screen mode, disable
 133+ 4D6B AF               XOR A
 134+ 4D6C 32 7F 4D         LD (SPRATR_INIT_STATUS),A
 135+ 4D6F C9               RET
 136+ 4D70              .L0:
 137+ 4D70                  ; check if anyone else is working with VRAM
 138+ 4D70 3A DF 64         LD A,(VRAM_UPDATE_IN_PROGRESS)
 139+ 4D73 B7               OR A
 140+ 4D74 C0               RET NZ
 141+ 4D75
 142+ 4D75 CD 95 4D         CALL SPRATR_UPDATE
 143+ 4D78
 144+ 4D78               IF (ANIM_CMDS == 1)
 145+ 4D78 CD 1D 56         CALL PROCESS_ANIMATIONS
 146+ 4D7B CD 21 58         CALL PROCESS_AUTOSGAMS
 147+ 4D7E               ENDIF
 148+ 4D7E C9               RET
 149+ 4D7F              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
 127  4D7F
 128  4D7F               IF (SPRITE_CMDS == 1)
 129  4D7F               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4D7F              ; commands and variables related to sprites
   2+ 4D7F
   3+ 4D7F              SPRATR_INIT_STATUS:
   4+ 4D7F 00            DB 0
   5+ 4D80              SPRATR_UPDATE_FLAG:
   6+ 4D80 00 00         DW 0
   7+ 4D82              SPRATR_DATA:
   8+ 4D82 00 00         DW 0
   9+ 4D84              SPRFLICKER_ENABLED:
  10+ 4D84 00            DB 0
  11+ 4D85              ; to support sprite flicker
  12+ 4D85              FLICKER:
  13+ 4D85 00            DB 0
  14+ 4D86              NUM_SPRITES_HANDLED:
  15+ 4D86 20            DB 32
  16+ 4D87
  17+ 4D87              ; to temporarily store stack pointer
  18+ 4D87              TMPSP:
  19+ 4D87 00 00         DW 0
  20+ 4D89
  21+ 4D89              ; *******************************************************************************************************
  22+ 4D89              ; helper function gets pointer to n-th entry in sprite attributes
  23+ 4D89              ; changes HL,DE
  24+ 4D89              GETnthSPRATTR:
  25+ 4D89 26 00            LD H,0
  26+ 4D8B 6F               LD L,A
  27+ 4D8C CD CB 66         CALL HLx8
  28+ 4D8F ED 5B 82 4D      LD DE,(SPRATR_DATA)
  29+ 4D93 19               ADD HL,DE
  30+ 4D94 C9               RET
  31+ 4D95              ; *******************************************************************************************************
  32+ 4D95
  33+ 4D95              ; *******************************************************************************************************
  34+ 4D95              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  35+ 4D95              ; struct {
  36+ 4D95              ; DW y
  37+ 4D95              ; DW x
  38+ 4D95              ; DW pattern (0-63)
  39+ 4D95              ; DW color
  40+ 4D95              ; } [32]
  41+ 4D95              ; will hide sprites whose location is outside of visible area
  42+ 4D95              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  43+ 4D95              ; modifies AF, AF', BC, DE, HL, IX
  44+ 4D95              SPRATR_UPDATE:
  45+ 4D95              	; check if update requested
  46+ 4D95 2A 80 4D     	LD HL, (SPRATR_UPDATE_FLAG)
  47+ 4D98 7E           	LD A, (HL)
  48+ 4D99 B7           	OR A
  49+ 4D9A C8           	RET Z
  50+ 4D9B
  51+ 4D9B DD 21 86 4D  	LD IX,NUM_SPRITES_HANDLED
  52+ 4D9F DD 46 00     	LD B, (IX) ; sprite number
  53+ 4DA2 0E 98        	LD C, #98 ; register for vdp data output
  54+ 4DA4              	; set VDP address
  55+ 4DA4 3A AF FC         LD A,(SCRMOD)
  56+ 4DA7 3D               DEC A
  57+ 4DA8 20 05            JR NZ,.L4
  58+ 4DAA 2A C3 F3         LD HL, (T32ATR)
  59+ 4DAD 18 03            JR .L5
  60+ 4DAF              .L4:
  61+ 4DAF 2A CD F3         LD HL, (GRPATR)
  62+ 4DB2              .L5:
  63+ 4DB2 3A 84 4D     	LD A, (SPRFLICKER_ENABLED)
  64+ 4DB5 B7           	OR A
  65+ 4DB6 28 03        	JR Z, .L3
  66+ 4DB8 3A 85 4D     	LD A, (FLICKER)
  67+ 4DBB              .L3:
  68+ 4DBB 5F           	LD E, A
  69+ 4DBC 08           	EX AF, AF'
  70+ 4DBD 7B           	LD A, E
  71+ 4DBE 87           	ADD A, A
  72+ 4DBF 87           	ADD A, A
  73+ 4DC0 16 00        	LD D, 0
  74+ 4DC2 5F           	LD E, A
  75+ 4DC3 19           	ADD HL, DE
  76+ 4DC4 CD B6 66     	CALL SETWRT_LOCAL
  77+ 4DC7 ED 73 87 4D  	LD (TMPSP), SP
  78+ 4DCB ED 7B 82 4D  	LD SP, (SPRATR_DATA)
  79+ 4DCF
  80+ 4DCF              .LOOP:
  81+ 4DCF E1           	POP HL
  82+ 4DD0 24           	INC H
  83+ 4DD1 28 0D        	JR Z, .L1 ; negative number between -256 and -1
  84+ 4DD3 25           	DEC H
  85+ 4DD4 20 15        	JR NZ, .OUT3 ; sprite vertically can't be visible
  86+ 4DD6 7D           	LD A, L
  87+ 4DD7 FE C0        	CP 192
  88+ 4DD9 30 10        	JR NC, .OUT3
  89+ 4DDB 3D           	DEC A ; due to VDP rule that top of screen is -1
  90+ 4DDC 57           	LD D, A
  91+ 4DDD C3 04 4E     	JP .X
  92+ 4DE0              .L1:
  93+ 4DE0 7D           	LD A, L
  94+ 4DE1 C6 10        	ADD 16
  95+ 4DE3 FA EB 4D     	JP M, .OUT3 ; below -16
  96+ 4DE6 2D           	DEC L ; due to VDP rule that top of screen is -1
  97+ 4DE7 55           	LD D, L
  98+ 4DE8 C3 04 4E     	JP .X
  99+ 4DEB              .OUT3:
 100+ 4DEB E1           	POP HL ; skip x value
 101+ 4DEC              .OUT2:
 102+ 4DEC E1           	POP HL ; skip pattern
 103+ 4DED E1           	POP HL ; skip color
 104+ 4DEE 3E D1        	LD A, #D1
 105+ 4DF0 ED 79        	OUT (C), A ; sprite hidden
 106+ 4DF2 00          > NOP
 106+ 4DF3 00          > NOP
 106+ 4DF4 00          > NOP
 107+ 4DF5 ED 79        	OUT (C), A ; value unimportant
 108+ 4DF7 00          > NOP
 108+ 4DF8 00          > NOP
 108+ 4DF9 00          > NOP
 109+ 4DFA ED 79        	OUT (C), A ; value unimportant
 110+ 4DFC 00          > NOP
 110+ 4DFD 00          > NOP
 110+ 4DFE 00          > NOP
 111+ 4DFF ED 79        	OUT (C), A ; value unimportant
 112+ 4E01 C3 2F 4E     	JP .NEXT
 113+ 4E04              .X:
 114+ 4E04 E1           	POP HL
 115+ 4E05 24           	INC H
 116+ 4E06 28 08        	JR Z, .L2
 117+ 4E08 25           	DEC H
 118+ 4E09 20 E1        	JR NZ, .OUT2
 119+ 4E0B 1E 00        	LD E, 0 ; EC bit
 120+ 4E0D C3 19 4E     	JP .XY
 121+ 4E10              .L2:
 122+ 4E10 7D           	LD A, L
 123+ 4E11 C6 20        	ADD 32
 124+ 4E13 FA EC 4D     	JP M, .OUT2
 125+ 4E16 6F           	LD L, A
 126+ 4E17 1E 80        	LD E, #80
 127+ 4E19              .XY:
 128+ 4E19 ED 51        	OUT (C), D
 129+ 4E1B 3A E0 F3     	LD A, (REG1SAV)
 130+ 4E1E E6 02        	AND 2
 131+ 4E20 ED 69        	OUT (C), L
 132+ 4E22 E1           	POP HL ; pattern
 133+ 4E23 7D           	LD A, L
 134+ 4E24 28 02        	JR Z, .SMALLSPRITES
 135+ 4E26 87           	ADD A, A
 136+ 4E27 87           	ADD A, A ; needs to go at 4x
 137+ 4E28              .SMALLSPRITES:
 138+ 4E28 D3 98        	OUT (#98), A
 139+ 4E2A E1           	POP HL ; color
 140+ 4E2B 7D           	LD A, L
 141+ 4E2C B3           	OR E
 142+ 4E2D D3 98        	OUT (#98), A
 143+ 4E2F              .NEXT:
 144+ 4E2F 08           	EX AF, AF'
 145+ 4E30 3C           	INC A ; increase current sprite
 146+ 4E31 DD BE 00     	CP (IX) ; compare to maximum handled
 147+ 4E34 C2 54 4E     	JP NZ, .NEXT2 ; continue if not over
 148+ 4E37 AF           	XOR A ; back to zero
 149+ 4E38 08           	EX AF, AF'
 150+ 4E39 3A AF FC         LD A,(SCRMOD)
 151+ 4E3C 3D               DEC A
 152+ 4E3D 20 05            JR NZ,.L6
 153+ 4E3F 2A C3 F3         LD HL, (T32ATR)
 154+ 4E42 18 03            JR .L7
 155+ 4E44              .L6:
 156+ 4E44 2A CD F3         LD HL, (GRPATR)
 157+ 4E47              .L7:
 158+ 4E47              	; CALL SETWRT_LOCAL not allowed as SP modified
 159+ 4E47 7D           	LD	A, L
 160+ 4E48 D3 99        	OUT	(099H), A
 161+ 4E4A 7C           	LD	A, H
 162+ 4E4B E6 3F        	AND	03FH
 163+ 4E4D F6 40        	OR	040H
 164+ 4E4F D3 99        	OUT	(099H), A
 165+ 4E51 C3 55 4E     	JP .NEXT3
 166+ 4E54              .NEXT2:
 167+ 4E54 08           	EX AF, AF'
 168+ 4E55              .NEXT3:
 169+ 4E55 05           	DEC B
 170+ 4E56 C2 CF 4D     	JP NZ, .LOOP
 171+ 4E59 08           	EX AF, AF'
 172+ 4E5A 3C           	INC A ; increase flicker to start at the next one on next vblank
 173+ 4E5B DD BE 00     	CP (IX)
 174+ 4E5E 20 01        	JR NZ,.L8
 175+ 4E60 AF           	XOR A
 176+ 4E61              .L8:
 177+ 4E61 32 85 4D     	LD (FLICKER), A
 178+ 4E64
 179+ 4E64 ED 7B 87 4D  	LD SP, (TMPSP)
 180+ 4E68 2A 80 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 181+ 4E6B 36 00        	LD (HL), 0 ; zero out update flag
 182+ 4E6D C9           	RET
 183+ 4E6E              ; *******************************************************************************************************
 184+ 4E6E
 185+ 4E6E               IF (BASIC_EXTENSION == 1)
 186+ 4E6E              ; *******************************************************************************************************
 187+ 4E6E              ; function to handle CALL SPRENABLE basic extension
 188+ 4E6E              ; initializes sprites handler
 189+ 4E6E              ; _SPRENABLE ( INT[3][31] variable sprites_attributes,
 190+ 4E6E              ;			   INT variable update_variable,
 191+ 4E6E              ;			   BYTE sprite_flicker_enabled,
 192+ 4E6E              ;			   BYTE num_sprites_handled )
 193+ 4E6E              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA, SPRFLICKER_ENABLED and NUM_SPRITES_HANDLED
 194+ 4E6E              SPRENABLE:
 195+ 4E6E              	; opening (
 196+ 4E6E CD DD 67     	CALL CHKCHAR
 197+ 4E71 28           	DB '('
 198+ 4E72              	; get address of sprite attribute table DIM SA%(3,31)
 199+ 4E72 3E 02        	LD A,2
 200+ 4E74 06 02        	LD B,2
 201+ 4E76 11 20 04     	LD DE,#0420
 202+ 4E79 CD 0A 68     	CALL GET_BASIC_ARRAY_DATA_POINTER
 203+ 4E7C ED 43 82 4D  	LD (SPRATR_DATA), BC
 204+ 4E80              	; comma
 205+ 4E80 CD DD 67     	CALL CHKCHAR
 206+ 4E83 2C           	DB ','
 207+ 4E84              	; get address of sprite update flag
 208+ 4E84 DD 21 A4 5E  	LD IX, PTRGET
 209+ 4E88 CD 59 01     	CALL CALBAS
 210+ 4E8B ED 53 80 4D  	LD (SPRATR_UPDATE_FLAG), DE
 211+ 4E8F              	; comma
 212+ 4E8F CD DD 67     	CALL CHKCHAR
 213+ 4E92 2C           	DB ','
 214+ 4E93              	; get flicker enabled flag
 215+ 4E93 DD 21 1C 52  	LD IX, GETBYT
 216+ 4E97 CD 59 01     	CALL CALBAS
 217+ 4E9A 32 84 4D     	LD (SPRFLICKER_ENABLED), A
 218+ 4E9D              	; comma
 219+ 4E9D CD DD 67     	CALL CHKCHAR
 220+ 4EA0 2C           	DB ','
 221+ 4EA1              	; get number of handled sprites
 222+ 4EA1 DD 21 1C 52  	LD IX, GETBYT
 223+ 4EA5 CD 59 01     	CALL CALBAS
 224+ 4EA8 32 86 4D     	LD (NUM_SPRITES_HANDLED),A
 225+ 4EAB              	; ending )
 226+ 4EAB CD DD 67     	CALL CHKCHAR
 227+ 4EAE 29           	DB ')'
 228+ 4EAF              .L0:
 229+ 4EAF 3E 01        	LD A, 1
 230+ 4EB1 32 7F 4D     	LD (SPRATR_INIT_STATUS), A
 231+ 4EB4 C9           	RET
 232+ 4EB5              ; *******************************************************************************************************
 233+ 4EB5               ENDIF
 234+ 4EB5
 235+ 4EB5               IF (DEFUSR_EXTENSION == 1)
 236+ 4EB5              ; same as SPRENABLE but for DEFUSR approach
 237+ 4EB5              ; input IX=pointer to input array, real data from +2
 238+ 4EB5              ; +2 = pointer to sprite attributes array data
 239+ 4EB5              ; +4 = pointer to sprite update variable
 240+ 4EB5              ; +6 = flicker flag
 241+ 4EB5              ; +8 = number of sprites to handle
 242+ 4EB5              SPRENABLE_DEFUSR:
 243+ 4EB5 DD 6E 02     	LD L,(IX+2)
 244+ 4EB8 DD 66 03     	LD H,(IX+3)
 245+ 4EBB 22 82 4D     	LD (SPRATR_DATA),HL
 246+ 4EBE DD 6E 04     	LD L,(IX+4)
 247+ 4EC1 DD 66 05     	LD H,(IX+5)
 248+ 4EC4 22 80 4D     	LD (SPRATR_UPDATE_FLAG),HL
 249+ 4EC7 DD 7E 06     	LD A,(IX+6)
 250+ 4ECA 32 84 4D     	LD (SPRFLICKER_ENABLED),A
 251+ 4ECD DD 7E 08     	LD A,(IX+8)
 252+ 4ED0 32 86 4D     	LD (NUM_SPRITES_HANDLED),A
 253+ 4ED3               IF (BASIC_EXTENSION == 1)
 254+ 4ED3 18 DA        	JR SPRENABLE.L0
 255+ 4ED5               ELSE
 256+ 4ED5 ~            	LD A, 1
 257+ 4ED5 ~            	LD (SPRATR_INIT_STATUS), A
 258+ 4ED5 ~            	RET
 259+ 4ED5               ENDIF
 260+ 4ED5               ENDIF
 261+ 4ED5
 262+ 4ED5               IF (DEFUSR_EXTENSION + BASIC_EXTENSION > 0)
 263+ 4ED5              ; *******************************************************************************************************
 264+ 4ED5              ; function to handle CALL SPRDISABLE basic extension
 265+ 4ED5              ; disables sprites handling
 266+ 4ED5              ; _SPRDISABLE
 267+ 4ED5              ; resets variable SPRATR_INIT_STATUS
 268+ 4ED5              SPRDISABLE:
 269+ 4ED5              SPRDISABLE_DEFUSR:
 270+ 4ED5 AF           	XOR A
 271+ 4ED6 32 7F 4D     	LD (SPRATR_INIT_STATUS), A
 272+ 4ED9 C9           	RET
 273+ 4EDA              ; *******************************************************************************************************
 274+ 4EDA               ENDIF
 275+ 4EDA
 276+ 4EDA              ; *******************************************************************************************************
 277+ 4EDA              ; function to handle CALL SPRSET basic extension
 278+ 4EDA              ; sets position, and optionally pattern and color of sprite
 279+ 4EDA              ; _SPRSET ( BYTE sprite_num , valid 0-31
 280+ 4EDA              ;			INT x,
 281+ 4EDA              ;			INT y,
 282+ 4EDA              ;			INT pattern, valid 0-63, otherwise ignored
 283+ 4EDA              ;			INT color, valid 0-15, otherwise ignored
 284+ 4EDA              ;SPRSET:
 285+ 4EDA              ;	LD A, (SPRATR_INIT_STATUS)
 286+ 4EDA              ;	OR A
 287+ 4EDA              ;	JR NZ, .L1
 288+ 4EDA              ;	LD E, 5 ; illegal function call
 289+ 4EDA              ;	JP THROW_ERROR
 290+ 4EDA              ;.L1:
 291+ 4EDA              ;	; opening (
 292+ 4EDA              ;	CALL CHKCHAR
 293+ 4EDA              ;	DB '('
 294+ 4EDA              ;	; get sprite number
 295+ 4EDA              ;	LD IX, GETBYT
 296+ 4EDA              ;	CALL CALBAS
 297+ 4EDA              ;	PUSH AF
 298+ 4EDA              ;	; comma
 299+ 4EDA              ;	CALL CHKCHAR
 300+ 4EDA              ;	DB ','
 301+ 4EDA              ;	; get x
 302+ 4EDA              ;	LD IX, FRMQNT
 303+ 4EDA              ;	CALL CALBAS
 304+ 4EDA              ;	PUSH DE
 305+ 4EDA              ;	; comma
 306+ 4EDA              ;	CALL CHKCHAR
 307+ 4EDA              ;	DB ','
 308+ 4EDA              ;	; get y
 309+ 4EDA              ;	LD IX, FRMQNT
 310+ 4EDA              ;	CALL CALBAS
 311+ 4EDA              ;	PUSH DE
 312+ 4EDA              ;	; comma
 313+ 4EDA              ;	CALL CHKCHAR
 314+ 4EDA              ;	DB ','
 315+ 4EDA              ;	; get pattern
 316+ 4EDA              ;	LD IX, FRMQNT
 317+ 4EDA              ;	CALL CALBAS
 318+ 4EDA              ;	PUSH DE
 319+ 4EDA              ;	; comma
 320+ 4EDA              ;	CALL CHKCHAR
 321+ 4EDA              ;	DB ','
 322+ 4EDA              ;	; get color
 323+ 4EDA              ;	LD IX, FRMQNT
 324+ 4EDA              ;	CALL CALBAS
 325+ 4EDA              ;	PUSH DE
 326+ 4EDA              ;	; ending )
 327+ 4EDA              ;	CALL CHKCHAR
 328+ 4EDA              ;	DB ')'
 329+ 4EDA              ;
 330+ 4EDA              ;   ; save position in BASIC text
 331+ 4EDA              ;	PUSH HL
 332+ 4EDA              ;	POP IX
 333+ 4EDA              ;
 334+ 4EDA              ;	POP BC ; color
 335+ 4EDA              ;	POP DE ; pattern
 336+ 4EDA              ;	EXX
 337+ 4EDA              ;	POP BC ; y
 338+ 4EDA              ;	POP DE ; x
 339+ 4EDA              ;	POP AF ; sprite number
 340+ 4EDA              ;	CP 32
 341+ 4EDA              ;	JR C, .L2
 342+ 4EDA              ;	LD E, 5 ; illegal function call
 343+ 4EDA              ;	JP THROW_ERROR
 344+ 4EDA              ;.L2:
 345+ 4EDA              ;	; find location in sprite attributes table
 346+ 4EDA              ;	PUSH DE
 347+ 4EDA              ;	CALL GETnthSPRATTR
 348+ 4EDA              ;	POP DE
 349+ 4EDA              ;	DI
 350+ 4EDA              ;	; set y
 351+ 4EDA              ;	LD (HL), C
 352+ 4EDA              ;	INC HL
 353+ 4EDA              ;	LD (HL), B
 354+ 4EDA              ;	INC HL
 355+ 4EDA              ;	; set x
 356+ 4EDA              ;	LD (HL), E
 357+ 4EDA              ;	INC HL
 358+ 4EDA              ;	LD (HL), D
 359+ 4EDA              ;	INC HL
 360+ 4EDA              ;	PUSH HL
 361+ 4EDA              ;	EXX
 362+ 4EDA              ;	POP HL
 363+ 4EDA              ;	; check if 0<=pattern<64
 364+ 4EDA              ;	LD A, D
 365+ 4EDA              ;	OR A
 366+ 4EDA              ;	JR NZ, .L3
 367+ 4EDA              ;	LD A, E
 368+ 4EDA              ;	CP 64
 369+ 4EDA              ;	JR NC, .L3
 370+ 4EDA              ;	; set pattern
 371+ 4EDA              ;	;ADD A, A
 372+ 4EDA              ;	;ADD A, A
 373+ 4EDA              ;	;ADD A, A
 374+ 4EDA              ;	LD (HL), A
 375+ 4EDA              ;	INC HL
 376+ 4EDA              ;	LD (HL), D
 377+ 4EDA              ;	INC HL
 378+ 4EDA              ;	JR .L4
 379+ 4EDA              ;.L3:
 380+ 4EDA              ;	; skip pattern
 381+ 4EDA              ;	.2 INC HL
 382+ 4EDA              ;.L4:
 383+ 4EDA              ;	; check if 0<=color<16
 384+ 4EDA              ;	LD A, B
 385+ 4EDA              ;	OR A
 386+ 4EDA              ;	JR NZ, .L5
 387+ 4EDA              ;	LD A, C
 388+ 4EDA              ;	CP 16
 389+ 4EDA              ;	JR NC, .L5
 390+ 4EDA              ;	; set color
 391+ 4EDA              ;	LD (HL), C
 392+ 4EDA              ;	INC HL
 393+ 4EDA              ;	LD (HL), B
 394+ 4EDA              ;
 395+ 4EDA              ;.L5:
 396+ 4EDA              ;	EI
 397+ 4EDA              ;	PUSH IX
 398+ 4EDA              ;	POP HL
 399+ 4EDA              ;	RET
 400+ 4EDA              ; *******************************************************************************************************
 401+ 4EDA
 402+ 4EDA              ; *******************************************************************************************************
 403+ 4EDA              ; function sets sprite location based on initial coordinates and offset provided
 404+ 4EDA              ; input A=sprite number in SPRATR_DATA , 0-31
 405+ 4EDA              ; input DE=initial x
 406+ 4EDA              ; input BC=initial y
 407+ 4EDA              ; input IY=location where delta y,x are located
 408+ 4EDA              ; modifies AF, HL, IX
 409+ 4EDA              SPRSET_DELTA_POS:
 410+ 4EDA D5           	PUSH DE
 411+ 4EDB CD 89 4D     	CALL GETnthSPRATTR
 412+ 4EDE E5           	PUSH HL
 413+ 4EDF DD E1        	POP IX
 414+ 4EE1 D1           	POP DE
 415+ 4EE2              	; IX=sprite's y location
 416+ 4EE2 FD 6E 00     	LD L, (IY)
 417+ 4EE5 FD 66 01     	LD H, (IY+1)
 418+ 4EE8 09           	ADD HL, BC
 419+ 4EE9 DD 75 00     	LD (IX), L
 420+ 4EEC DD 74 01     	LD (IX+1), H
 421+ 4EEF FD 6E 02     	LD L, (IY+2)
 422+ 4EF2 FD 66 03     	LD H, (IY+3)
 423+ 4EF5 19           	ADD HL, DE
 424+ 4EF6 DD 75 02     	LD (IX+2), L
 425+ 4EF9 DD 74 03     	LD (IX+3), H
 426+ 4EFC C9           	RET
 427+ 4EFD              ; *******************************************************************************************************
 428+ 4EFD
 429+ 4EFD              ; *******************************************************************************************************
 430+ 4EFD              ; helper function to set new locations for a set of sprites
 431+ 4EFD              ; input B=number of sprites
 432+ 4EFD              ; HL=pointer to list of sprites and offsets
 433+ 4EFD              SPR_UPDATE_LOC:
 434+ 4EFD 3E 01        	LD A,1
 435+ 4EFF 32 DF 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 436+ 4F02 7E           	LD A, (HL)
 437+ 4F03 23           	INC HL
 438+ 4F04 23           	INC HL
 439+ 4F05 E5           	PUSH HL
 440+ 4F06 FD E1        	POP IY
 441+ 4F08 D9           	EXX
 442+ 4F09 CD DA 4E     	CALL SPRSET_DELTA_POS
 443+ 4F0C D9           	EXX
 444+ 4F0D 23          > INC HL
 444+ 4F0E 23          > INC HL
 444+ 4F0F 23          > INC HL
 444+ 4F10 23          > INC HL
 445+ 4F11 10 EA        	DJNZ SPR_UPDATE_LOC
 446+ 4F13 AF           	XOR A
 447+ 4F14 32 DF 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 448+ 4F17 C9           	RET
 449+ 4F18              ; *******************************************************************************************************
 450+ 4F18
 451+ 4F18               IF (BASIC_EXTENSION == 1)
 452+ 4F18              ; *******************************************************************************************************
 453+ 4F18              ; function to handle CALL SPRGRPMOV basic extension
 454+ 4F18              ; sets position of a group of sprites described with
 455+ 4F18              ; { int sprite_num, int delta_y, int delta_x } [count]
 456+ 4F18              ; _SPRGRPMOV ( INT x,
 457+ 4F18              ;			   INT y,
 458+ 4F18              ;			   BYTE count,
 459+ 4F18              ;			   INT[2][count] data_ptr
 460+ 4F18              SPRGRPMOV:
 461+ 4F18 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
 462+ 4F1B B7           	OR A
 463+ 4F1C CA FD 67     	JP Z,ILLEGAL_FUNCTION
 464+ 4F1F              	; opening (
 465+ 4F1F CD DD 67     	CALL CHKCHAR
 466+ 4F22 28           	DB '('
 467+ 4F23              	; get x
 468+ 4F23 DD 21 2F 54  	LD IX, FRMQNT
 469+ 4F27 CD 59 01     	CALL CALBAS
 470+ 4F2A ED 53 CE 64  	LD (BLIT_STRUCT),DE
 471+ 4F2E              	; comma
 472+ 4F2E CD DD 67     	CALL CHKCHAR
 473+ 4F31 2C           	DB ','
 474+ 4F32              	; get y
 475+ 4F32 DD 21 2F 54  	LD IX, FRMQNT
 476+ 4F36 CD 59 01     	CALL CALBAS
 477+ 4F39 ED 53 D0 64  	LD (BLIT_STRUCT+2),DE
 478+ 4F3D              	; comma
 479+ 4F3D CD DD 67     	CALL CHKCHAR
 480+ 4F40 2C           	DB ','
 481+ 4F41              	; get count
 482+ 4F41 DD 21 1C 52  	LD IX, GETBYT
 483+ 4F45 CD 59 01     	CALL CALBAS
 484+ 4F48 32 D2 64     	LD (BLIT_STRUCT+4),A
 485+ 4F4B              	; comma
 486+ 4F4B CD DD 67     	CALL CHKCHAR
 487+ 4F4E 2C           	DB ','
 488+ 4F4F              	; get sprite group definition array data pointer
 489+ 4F4F 3A D2 64     	LD A,(BLIT_STRUCT+4)
 490+ 4F52 5F           	LD E,A
 491+ 4F53 16 03        	LD D,3
 492+ 4F55 3E 02        	LD A,2
 493+ 4F57 47           	LD B,A
 494+ 4F58 CD 0A 68     	CALL GET_BASIC_ARRAY_DATA_POINTER
 495+ 4F5B ED 43 D3 64  	LD (BLIT_STRUCT+5),BC
 496+ 4F5F              	; ending )
 497+ 4F5F CD DD 67     	CALL CHKCHAR
 498+ 4F62 29           	DB ')'
 499+ 4F63
 500+ 4F63 E5           	PUSH HL
 501+ 4F64
 502+ 4F64 D9               EXX
 503+ 4F65 ED 5B CE 64      LD DE,(BLIT_STRUCT) ; initial x
 504+ 4F69 ED 4B D0 64      LD BC,(BLIT_STRUCT+2) ; initial y
 505+ 4F6D D9               EXX
 506+ 4F6E 2A D3 64         LD HL,(BLIT_STRUCT+5) ; pointer to data
 507+ 4F71 3A D2 64         LD A,(BLIT_STRUCT+4) ; number of entries
 508+ 4F74 47               LD B,A
 509+ 4F75 CD FD 4E     	CALL SPR_UPDATE_LOC
 510+ 4F78
 511+ 4F78 E1           	POP HL
 512+ 4F79 C9           	RET
 513+ 4F7A              ; *******************************************************************************************************
 514+ 4F7A               ENDIF
 515+ 4F7A
 516+ 4F7A               IF (DEFUSR_EXTENSION == 1)
 517+ 4F7A              ; *******************************************************************************************************
 518+ 4F7A              ; same as SPRGRPMOV but for DEFUSR approach
 519+ 4F7A              ; input IX=pointer to input array, real data from +2
 520+ 4F7A              ; +2 = X
 521+ 4F7A              ; +4 = Y
 522+ 4F7A              ; +6 = count
 523+ 4F7A              ; +8 = data pointer
 524+ 4F7A              SPRGRPMOV_DEFUSR:
 525+ 4F7A D9               EXX
 526+ 4F7B DD 5E 02     	LD E,(IX+2)
 527+ 4F7E DD 56 03     	LD D,(IX+3) ; initial x
 528+ 4F81 DD 4E 04     	LD C,(IX+4)
 529+ 4F84 DD 46 05     	LD B,(IX+5) ; initial y
 530+ 4F87 D9               EXX
 531+ 4F88 DD 6E 08     	LD L,(IX+8)
 532+ 4F8B DD 66 09     	LD H,(IX+9) ; pointer to data
 533+ 4F8E DD 46 06         LD B,(IX+6) ; count
 534+ 4F91 C3 FD 4E         JP SPR_UPDATE_LOC
 535+ 4F94              ; *******************************************************************************************************
 536+ 4F94               ENDIF
# file closed: asm\SPRITES.asm
 130  4F94               ENDIF
 131  4F94
 132  4F94               IF (ANIM_CMDS == 1)
 133  4F94               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4F94              ; sprite animation routines
   2+ 4F94
   3+ 4F94              ; number of animation items and pointer
   4+ 4F94              ANIMITEMNUM:
   5+ 4F94 00            DB 0
   6+ 4F95              ANIMITEMPTR:
   7+ 4F95 80 68         DW EXT_END
   8+ 4F97              ; number of animation definitions and pointer
   9+ 4F97              ANIMDEFNUM:
  10+ 4F97 00            DB 0
  11+ 4F98              ANIMDEFPTR:
  12+ 4F98 80 68         DW EXT_END
  13+ 4F9A              ; number of links between sprite and animation definitions
  14+ 4F9A              ANIMSPRNUM:
  15+ 4F9A 00            DB 0
  16+ 4F9B              ANIMSPRPTR:
  17+ 4F9B 80 68         DW EXT_END
  18+ 4F9D              ; number of automatic sprite group move and animate structures
  19+ 4F9D              AUTOSGAMNUM:
  20+ 4F9D 00            DB 0
  21+ 4F9E              AUTOSGAMPTR:
  22+ 4F9E 80 68         DW EXT_END
  23+ 4FA0
  24+ 4FA0              ; ANIMATION ITEM
  25+ 4FA0              ; byte type = [0 - pattern and color change
  26+ 4FA0              ;              1 - pattern definition change ]
  27+ 4FA0              ; word ticks - number of ticks to hold this state
  28+ 4FA0              ; for type = 0
  29+ 4FA0              ;   byte pattern;
  30+ 4FA0              ;   byte color;
  31+ 4FA0              ; for type = 1
  32+ 4FA0              ;   work data_pointer;
  33+ 4FA0              ; total size = 5b
  34+ 4FA0
  35+ 4FA0              ; ANIMATION DEFINITION
  36+ 4FA0              ; byte number of items 1-15
  37+ 4FA0              ; byte[15] anim_item;
  38+ 4FA0              ; total size = 16b
  39+ 4FA0
  40+ 4FA0              ; SPRITE/CHAR ANIMATION
  41+ 4FA0              ; +00 byte sprite/char number;
  42+ 4FA0              ; +01 word time;
  43+ 4FA0              ; +03 byte current item;
  44+ 4FA0              ; +04 byte animation definition;
  45+ 4FA0              ; +05 byte cyclic;
  46+ 4FA0              ; +06 byte active;
  47+ 4FA0              ; +07 byte 0=sprite, 1-3 character bank
  48+ 4FA0              ; total size = 8b
  49+ 4FA0
  50+ 4FA0              ; AUTOMATIC SPRITE GROUP MOVE AND ANIMATE structure
  51+ 4FA0              ; +00 pointer to X variable
  52+ 4FA0              ; +02 pointer to Y variable
  53+ 4FA0              ; +04 minimum value
  54+ 4FA0              ; +06 maximal value
  55+ 4FA0              ; +08 delta value
  56+ 4FA0              ; +10 direction 0=horizontal, <>0 = vertical
  57+ 4FA0              ; +11 sprite group size
  58+ 4FA0              ; +12 sprite group pointer
  59+ 4FA0              ; +14 animation list size
  60+ 4FA0              ; +15 animation list pointer for negative delta values
  61+ 4FA0              ; +17 animation list pointer for positive delta values
  62+ 4FA0              ; +19 active flag
  63+ 4FA0              ; +20 ticks for movement
  64+ 4FA0              ; +22 timer
  65+ 4FA0              ; total = 24b
  66+ 4FA0
  67+ 4FA0              ; *******************************************************************************************************
  68+ 4FA0              ; helper function HL=A*5
  69+ 4FA0              ; changes HL,DE
  70+ 4FA0              Ax5:
  71+ 4FA0 26 00            LD H,0
  72+ 4FA2 6F               LD L,A
  73+ 4FA3 54               LD D,H
  74+ 4FA4 5D               LD E,L
  75+ 4FA5 29               ADD HL,HL
  76+ 4FA6 29               ADD HL,HL
  77+ 4FA7 19               ADD HL,DE
  78+ 4FA8 C9               RET
  79+ 4FA9              ; *******************************************************************************************************
  80+ 4FA9
  81+ 4FA9              ; *******************************************************************************************************
  82+ 4FA9              ; helper function gets pointer to n-th animation item
  83+ 4FA9              ; changes HL,DE
  84+ 4FA9              GETnthANIMITEM:
  85+ 4FA9 CD A0 4F         CALL Ax5
  86+ 4FAC ED 5B 95 4F      LD DE,(ANIMITEMPTR)
  87+ 4FB0 19               ADD HL,DE
  88+ 4FB1 C9               RET
  89+ 4FB2              ; *******************************************************************************************************
  90+ 4FB2
  91+ 4FB2              ; *******************************************************************************************************
  92+ 4FB2              ; helper function gets pointer to n-th entry in animation definition
  93+ 4FB2              ; changes HL,DE
  94+ 4FB2              GETnthANIMDEF:
  95+ 4FB2 26 00            LD H,0
  96+ 4FB4 6F               LD L,A
  97+ 4FB5 CD CA 66         CALL HLx16
  98+ 4FB8 ED 5B 98 4F      LD DE,(ANIMDEFPTR)
  99+ 4FBC 19               ADD HL,DE
 100+ 4FBD C9               RET
 101+ 4FBE              ; *******************************************************************************************************
 102+ 4FBE
 103+ 4FBE              ; *******************************************************************************************************
 104+ 4FBE              ; helper function gets pointer to n-th entry in sprite animation
 105+ 4FBE              ; changes HL,DE
 106+ 4FBE              GETnthSPRANIM:
 107+ 4FBE 26 00            LD H,0
 108+ 4FC0 6F               LD L,A
 109+ 4FC1 CD CB 66         CALL HLx8
 110+ 4FC4 ED 5B 9B 4F      LD DE,(ANIMSPRPTR)
 111+ 4FC8 19               ADD HL,DE
 112+ 4FC9 C9               RET
 113+ 4FCA              ; *******************************************************************************************************
 114+ 4FCA
 115+ 4FCA              ; *******************************************************************************************************
 116+ 4FCA              ; helper function gets pointer to n-th entry in autosgam table
 117+ 4FCA              ; changes HL,DE
 118+ 4FCA              GETnthAUTOSGAM:
 119+ 4FCA 26 00            LD H,0
 120+ 4FCC 6F               LD L,A
 121+ 4FCD CD CB 66         CALL HLx8
 122+ 4FD0 54               LD D,H
 123+ 4FD1 5D               LD E,L
 124+ 4FD2 29               ADD HL,HL
 125+ 4FD3 19               ADD HL,DE
 126+ 4FD4 ED 5B 9E 4F      LD DE,(AUTOSGAMPTR)
 127+ 4FD8 19               ADD HL,DE
 128+ 4FD9 C9               RET
 129+ 4FDA              ; *******************************************************************************************************
 130+ 4FDA
 131+ 4FDA               IF (DEFUSR_EXTENSION == 1)
 132+ 4FDA              ; *******************************************************************************************************
 133+ 4FDA              ; same as MAXIANIMITEMS but for DEFUSR approach
 134+ 4FDA              ; input IX=pointer to input array, real data from +2
 135+ 4FDA              ; +2 = number
 136+ 4FDA              MAXANIMITEMS_DEFUSR:
 137+ 4FDA DD 7E 02         LD A,(IX+2)
 138+ 4FDD 18 11            JR MAXANIMITEMS.COMMON
 139+ 4FDF              ; *******************************************************************************************************
 140+ 4FDF               ENDIF
 141+ 4FDF
 142+ 4FDF              ; *******************************************************************************************************
 143+ 4FDF              ; function to handle CALL MAXANIMITEMS basic extension
 144+ 4FDF              ; MAXANIMITEMS (BYTE number)
 145+ 4FDF              ; sets new number and moves memory buffers as needed
 146+ 4FDF              MAXANIMITEMS:
 147+ 4FDF               IF (BASIC_EXTENSION == 1)
 148+ 4FDF              	; opening (
 149+ 4FDF CD DD 67     	CALL CHKCHAR
 150+ 4FE2 28           	DB '('
 151+ 4FE3              	; get value
 152+ 4FE3 DD 21 1C 52  	LD IX, GETBYT
 153+ 4FE7 CD 59 01     	CALL CALBAS
 154+ 4FEA F5               PUSH AF
 155+ 4FEB              	; ending )
 156+ 4FEB CD DD 67     	CALL CHKCHAR
 157+ 4FEE 29           	DB ')'
 158+ 4FEF F1               POP AF
 159+ 4FF0               ENDIF
 160+ 4FF0              .COMMON: ; entry for DEFUSR part, A=number
 161+ 4FF0 F3               DI
 162+ 4FF1              	; save position
 163+ 4FF1 E5           	PUSH HL
 164+ 4FF2              .ENTRY:
 165+ 4FF2 47               LD B,A
 166+ 4FF3 3A 94 4F         LD A,(ANIMITEMNUM)
 167+ 4FF6 90               SUB B
 168+ 4FF7 28 28            JR Z, .EXIT; same value as before
 169+ 4FF9 FD 21 98 4F      LD IY,ANIMDEFPTR
 170+ 4FFD FA 24 50         JP M, .INCREASE
 171+ 5000                  ; new value is lower than previous one
 172+ 5000 CD 43 50         CALL .SIZEDIFF
 173+ 5003 CD 5E 50         CALL .DECREASE_COMMON
 174+ 5006 2A 9B 4F         LD HL,(ANIMSPRPTR)
 175+ 5009 AF               XOR A
 176+ 500A ED 42            SBC HL,BC
 177+ 500C 22 9B 4F         LD (ANIMSPRPTR),HL
 178+ 500F              .E1:
 179+ 500F 2A 9E 4F         LD HL,(AUTOSGAMPTR)
 180+ 5012 AF               XOR A
 181+ 5013 ED 42            SBC HL,BC
 182+ 5015 22 9E 4F         LD (AUTOSGAMPTR),HL
 183+ 5018              .E3:
 184+ 5018 2A 10 40         LD HL,(FREEMEMPTR)
 185+ 501B AF               XOR A
 186+ 501C ED 42            SBC HL,BC
 187+ 501E 22 10 40         LD (FREEMEMPTR),HL
 188+ 5021              .EXIT:
 189+ 5021 FB               EI
 190+ 5022 E1           	POP HL
 191+ 5023 C9           	RET
 192+ 5024              .INCREASE:
 193+ 5024 ED 44            NEG
 194+ 5026 CD 43 50         CALL .SIZEDIFF
 195+ 5029 CD 8A 50         CALL .INCREASE_COMMON
 196+ 502C 2A 9B 4F         LD HL,(ANIMSPRPTR)
 197+ 502F 09               ADD HL,BC
 198+ 5030 22 9B 4F         LD (ANIMSPRPTR),HL
 199+ 5033              .E2:
 200+ 5033 2A 9E 4F         LD HL,(AUTOSGAMPTR)
 201+ 5036 09               ADD HL,BC
 202+ 5037 22 9E 4F         LD (AUTOSGAMPTR),HL
 203+ 503A              .E4:
 204+ 503A 2A 10 40         LD HL,(FREEMEMPTR)
 205+ 503D 09               ADD HL,BC
 206+ 503E 22 10 40         LD (FREEMEMPTR),HL
 207+ 5041 18 DE            JR .EXIT
 208+ 5043              .SIZEDIFF:
 209+ 5043 CD A0 4F         CALL Ax5
 210+ 5046 78               LD A,B
 211+ 5047 32 94 4F         LD (ANIMITEMNUM),A
 212+ 504A 44               LD B,H
 213+ 504B 4D               LD C,L
 214+ 504C C9               RET ; BC=size difference in bytes
 215+ 504D              .SIZETOMOVE:
 216+ 504D D5               PUSH DE
 217+ 504E 2A 10 40         LD HL,(FREEMEMPTR)
 218+ 5051 FD 5E 00         LD E,(IY)
 219+ 5054 FD 56 01         LD D,(IY+1)
 220+ 5057 AF               XOR A
 221+ 5058 ED 52            SBC HL,DE
 222+ 505A 44               LD B,H
 223+ 505B 4D               LD C,L
 224+ 505C D1               POP DE
 225+ 505D C9               RET
 226+ 505E              .DECREASE_COMMON:
 227+ 505E FD 6E 00         LD L,(IY)
 228+ 5061 FD 66 01         LD H,(IY+1)
 229+ 5064 AF               XOR A
 230+ 5065 ED 42            SBC HL,BC
 231+ 5067 EB               EX DE,HL
 232+ 5068 C5               PUSH BC
 233+ 5069 CD 4D 50         CALL .SIZETOMOVE
 234+ 506C F3               DI
 235+ 506D 78               LD A,B
 236+ 506E B1               OR C
 237+ 506F 28 08            JR Z,.L1
 238+ 5071 FD 6E 00         LD L,(IY)
 239+ 5074 FD 66 01         LD H,(IY+1)
 240+ 5077 ED B0            LDIR
 241+ 5079              .L1:
 242+ 5079 C1               POP BC
 243+ 507A FD 6E 00         LD L,(IY)
 244+ 507D FD 66 01         LD H,(IY+1)
 245+ 5080 AF               XOR A
 246+ 5081 ED 42            SBC HL,BC
 247+ 5083 FD 75 00         LD (IY),L
 248+ 5086 FD 74 01         LD (IY+1),H
 249+ 5089 C9               RET
 250+ 508A              .INCREASE_COMMON:
 251+ 508A 2A 10 40         LD HL,(FREEMEMPTR)
 252+ 508D 2B               DEC HL
 253+ 508E AF               XOR A
 254+ 508F ED 42            SBC HL,BC
 255+ 5091 EB               EX DE,HL
 256+ 5092 C5               PUSH BC
 257+ 5093 CD 4D 50         CALL .SIZETOMOVE
 258+ 5096 F3               DI
 259+ 5097 78               LD A,B
 260+ 5098 B1               OR C
 261+ 5099 28 06            JR Z,.L2
 262+ 509B 2A 10 40         LD HL,(FREEMEMPTR)
 263+ 509E 2B               DEC HL
 264+ 509F ED B8            LDDR
 265+ 50A1              .L2:
 266+ 50A1 C1               POP BC
 267+ 50A2 FD 6E 00         LD L,(IY)
 268+ 50A5 FD 66 01         LD H,(IY+1)
 269+ 50A8 09               ADD HL,BC
 270+ 50A9 FD 75 00         LD (IY),L
 271+ 50AC FD 74 01         LD (IY+1),H
 272+ 50AF C9               RET
 273+ 50B0              ; *******************************************************************************************************
 274+ 50B0
 275+ 50B0              ; *******************************************************************************************************
 276+ 50B0              ; function to handle CALL ANIMITEMPAT basic extension
 277+ 50B0              ; ANIMITEMPAT ( BYTE id,
 278+ 50B0              ;               INT ticks >0,
 279+ 50B0              ;               BYTE pattern,
 280+ 50B0              ;               BYTE color )
 281+ 50B0              ; fills animation item data, returns an error if ID out of bounds
 282+ 50B0              ANIMITEMPAT:
 283+ 50B0                  ; opening (
 284+ 50B0 CD DD 67     	CALL CHKCHAR
 285+ 50B3 28           	DB '('
 286+ 50B4              	; get id
 287+ 50B4 DD 21 1C 52  	LD IX, GETBYT
 288+ 50B8 CD 59 01     	CALL CALBAS
 289+ 50BB F5               PUSH AF
 290+ 50BC                  ; check if out of bounds
 291+ 50BC 3C               INC A
 292+ 50BD 4F               LD C,A
 293+ 50BE 3A 94 4F         LD A,(ANIMITEMNUM)
 294+ 50C1 B9               CP C
 295+ 50C2 DA F5 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 296+ 50C5              	; comma
 297+ 50C5 CD DD 67     	CALL CHKCHAR
 298+ 50C8 2C           	DB ','
 299+ 50C9              	; get ticks
 300+ 50C9 DD 21 2F 54  	LD IX, FRMQNT
 301+ 50CD CD 59 01     	CALL CALBAS
 302+ 50D0 7A               LD A,D
 303+ 50D1 B3               OR E
 304+ 50D2 CA F9 67         JP Z, OVERFLOW
 305+ 50D5 D5           	PUSH DE
 306+ 50D6              	; comma
 307+ 50D6 CD DD 67     	CALL CHKCHAR
 308+ 50D9 2C           	DB ','
 309+ 50DA              	; get pattern
 310+ 50DA DD 21 1C 52  	LD IX, GETBYT
 311+ 50DE CD 59 01     	CALL CALBAS
 312+ 50E1 F5               PUSH AF
 313+ 50E2              	; comma
 314+ 50E2 CD DD 67     	CALL CHKCHAR
 315+ 50E5 2C           	DB ','
 316+ 50E6              	; get color
 317+ 50E6 DD 21 1C 52  	LD IX, GETBYT
 318+ 50EA CD 59 01     	CALL CALBAS
 319+ 50ED F5               PUSH AF
 320+ 50EE              	; ending )
 321+ 50EE CD DD 67     	CALL CHKCHAR
 322+ 50F1 29           	DB ')'
 323+ 50F2              .ENTRY:
 324+ 50F2 E5               PUSH HL
 325+ 50F3 DD E1            POP IX
 326+ 50F5 D9               EXX
 327+ 50F6 C1               POP BC ; color
 328+ 50F7 D1               POP DE ; pattern
 329+ 50F8 E1               POP HL ; ticks
 330+ 50F9 D9               EXX
 331+ 50FA F1               POP AF
 332+ 50FB CD A9 4F         CALL GETnthANIMITEM
 333+ 50FE E5               PUSH HL
 334+ 50FF FD E1            POP IY
 335+ 5101 D9               EXX
 336+ 5102 FD 36 00 00      LD (IY),0 ; type=0
 337+ 5106 FD 75 01         LD (IY+1),L
 338+ 5109 FD 74 02         LD (IY+2),H
 339+ 510C FD 72 03         LD (IY+3),D
 340+ 510F FD 70 04         LD (IY+4),B
 341+ 5112
 342+ 5112 DD E5            PUSH IX
 343+ 5114 E1               POP HL
 344+ 5115 C9               RET
 345+ 5116              ; *******************************************************************************************************
 346+ 5116
 347+ 5116              ; *******************************************************************************************************
 348+ 5116              ; function to handle CALL ANIMITEMPTR basic extension
 349+ 5116              ; ANIMITEMPTR ( BYTE id,
 350+ 5116              ;               INT ticks,
 351+ 5116              ;               INT pointer,
 352+ 5116              ; fills animation item data, returns an error if ID out of bounds
 353+ 5116              ANIMITEMPTR_CMD:
 354+ 5116                  ; opening (
 355+ 5116 CD DD 67     	CALL CHKCHAR
 356+ 5119 28           	DB '('
 357+ 511A              	; get id
 358+ 511A DD 21 1C 52  	LD IX, GETBYT
 359+ 511E CD 59 01     	CALL CALBAS
 360+ 5121 F5               PUSH AF
 361+ 5122                  ; check if out of bounds
 362+ 5122 3C               INC A
 363+ 5123 4F               LD C,A
 364+ 5124 3A 94 4F         LD A,(ANIMITEMNUM)
 365+ 5127 B9               CP C
 366+ 5128 DA F5 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 367+ 512B              	; comma
 368+ 512B CD DD 67     	CALL CHKCHAR
 369+ 512E 2C           	DB ','
 370+ 512F              	; get ticks
 371+ 512F DD 21 2F 54  	LD IX, FRMQNT
 372+ 5133 CD 59 01     	CALL CALBAS
 373+ 5136 7A               LD A,D
 374+ 5137 B3               OR E
 375+ 5138 CA F9 67         JP Z,OVERFLOW
 376+ 513B D5           	PUSH DE
 377+ 513C              	; comma
 378+ 513C CD DD 67     	CALL CHKCHAR
 379+ 513F 2C           	DB ','
 380+ 5140              	; get pointer
 381+ 5140 DD 21 2F 54  	LD IX, FRMQNT
 382+ 5144 CD 59 01     	CALL CALBAS
 383+ 5147 D5           	PUSH DE
 384+ 5148              	; ending )
 385+ 5148 CD DD 67     	CALL CHKCHAR
 386+ 514B 29           	DB ')'
 387+ 514C              .ENTRY:
 388+ 514C E5               PUSH HL
 389+ 514D DD E1            POP IX
 390+ 514F D9               EXX
 391+ 5150 D1               POP DE ; pointer
 392+ 5151 E1               POP HL ; ticks
 393+ 5152 D9               EXX
 394+ 5153 F1               POP AF
 395+ 5154 CD A9 4F         CALL GETnthANIMITEM
 396+ 5157 E5               PUSH HL
 397+ 5158 FD E1            POP IY
 398+ 515A D9               EXX
 399+ 515B FD 36 00 01      LD (IY),1 ; type=1
 400+ 515F FD 75 01         LD (IY+1),L
 401+ 5162 FD 74 02         LD (IY+2),H
 402+ 5165 FD 73 03         LD (IY+3),E
 403+ 5168 FD 72 04         LD (IY+4),D
 404+ 516B
 405+ 516B DD E5            PUSH IX
 406+ 516D E1               POP HL
 407+ 516E C9               RET
 408+ 516F              ; *******************************************************************************************************
 409+ 516F
 410+ 516F               IF (DEFUSR_EXTENSION == 1)
 411+ 516F              ; *******************************************************************************************************
 412+ 516F              ; same as MAXANIMDEFS but for DEFUSR approach
 413+ 516F              ; input IX=pointer to input array, real data from +2
 414+ 516F              ; +2 = number
 415+ 516F              MAXANIMDEFS_DEFUSR:
 416+ 516F DD 7E 02         LD A,(IX+2)
 417+ 5172 18 11            JR MAXANIMDEFS.COMMON
 418+ 5174              ; *******************************************************************************************************
 419+ 5174               ENDIF
 420+ 5174
 421+ 5174              ; *******************************************************************************************************
 422+ 5174              ; function to handle CALL MAXANIMDEFS basic extension
 423+ 5174              ; MAXANIMDEFS (BYTE number)
 424+ 5174              ; sets new number and moves memory buffers as needed
 425+ 5174              MAXANIMDEFS:
 426+ 5174               IF (BASIC_EXTENSION == 1)
 427+ 5174              	; opening (
 428+ 5174 CD DD 67     	CALL CHKCHAR
 429+ 5177 28           	DB '('
 430+ 5178              	; get value
 431+ 5178 DD 21 1C 52  	LD IX, GETBYT
 432+ 517C CD 59 01     	CALL CALBAS
 433+ 517F F5               PUSH AF
 434+ 5180              	; ending )
 435+ 5180 CD DD 67     	CALL CHKCHAR
 436+ 5183 29           	DB ')'
 437+ 5184 F1               POP AF
 438+ 5185               ENDIF
 439+ 5185              .COMMON:
 440+ 5185 F3               DI
 441+ 5186              	; save position
 442+ 5186 E5           	PUSH HL
 443+ 5187              .ENTRY:
 444+ 5187 47               LD B,A
 445+ 5188 3A 97 4F         LD A,(ANIMDEFNUM)
 446+ 518B 90               SUB B
 447+ 518C CA 21 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 448+ 518F FD 21 9B 4F      LD IY,ANIMSPRPTR
 449+ 5193 FA 9F 51         JP M, .INCREASE
 450+ 5196                  ; new value is lower than previous one
 451+ 5196 CD AA 51         CALL .SIZEDIFF
 452+ 5199 CD 5E 50         CALL MAXANIMITEMS.DECREASE_COMMON
 453+ 519C C3 0F 50         JP MAXANIMITEMS.E1
 454+ 519F              .INCREASE:
 455+ 519F ED 44            NEG
 456+ 51A1 CD AA 51         CALL .SIZEDIFF
 457+ 51A4 CD 8A 50         CALL MAXANIMITEMS.INCREASE_COMMON
 458+ 51A7 C3 33 50         JP MAXANIMITEMS.E2
 459+ 51AA              .SIZEDIFF:
 460+ 51AA 26 00            LD H,0
 461+ 51AC 6F               LD L,A
 462+ 51AD CD CA 66         CALL HLx16
 463+ 51B0 78               LD A,B
 464+ 51B1 32 97 4F         LD (ANIMDEFNUM),A
 465+ 51B4 44               LD B,H
 466+ 51B5 4D               LD C,L
 467+ 51B6 C9               RET ; BC=size difference in bytes
 468+ 51B7              ; *******************************************************************************************************
 469+ 51B7
 470+ 51B7              ; *******************************************************************************************************
 471+ 51B7              ; function to handle CALL ANIMDEF basic extension
 472+ 51B7              ; ANIMITEMPAT ( BYTE id,
 473+ 51B7              ;               BYTE size,
 474+ 51B7              ;               INT[] list )
 475+ 51B7              ; fills animation definition data, returns an error if out of bounds, or invalid type
 476+ 51B7              ANIMDEF:
 477+ 51B7                  ; opening (
 478+ 51B7 CD DD 67     	CALL CHKCHAR
 479+ 51BA 28           	DB '('
 480+ 51BB              	; get id
 481+ 51BB DD 21 1C 52  	LD IX, GETBYT
 482+ 51BF CD 59 01     	CALL CALBAS
 483+ 51C2 F5               PUSH AF
 484+ 51C3                  ; check if out of bounds
 485+ 51C3 3C               INC A
 486+ 51C4 4F               LD C,A
 487+ 51C5 3A 97 4F         LD A,(ANIMDEFNUM)
 488+ 51C8 B9               CP C
 489+ 51C9 DA F5 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 490+ 51CC              	; comma
 491+ 51CC CD DD 67     	CALL CHKCHAR
 492+ 51CF 2C           	DB ','
 493+ 51D0              	; get size
 494+ 51D0 DD 21 1C 52  	LD IX, GETBYT
 495+ 51D4 CD 59 01     	CALL CALBAS
 496+ 51D7 FE 10            CP 16
 497+ 51D9 D2 F9 67         JP NC, OVERFLOW
 498+ 51DC B7               OR A
 499+ 51DD CA F9 67         JP Z, OVERFLOW
 500+ 51E0 F5           	PUSH AF
 501+ 51E1              	; comma
 502+ 51E1 CD DD 67     	CALL CHKCHAR
 503+ 51E4 2C           	DB ','
 504+ 51E5              	; get pointer to a list of animation items in integer array format
 505+ 51E5                  ; get array pointer
 506+ 51E5 D1               POP DE
 507+ 51E6 D5               PUSH DE
 508+ 51E7 3E 02            LD A,2
 509+ 51E9 06 01            LD B,1
 510+ 51EB CD 0A 68         CALL GET_BASIC_ARRAY_DATA_POINTER
 511+ 51EE C5               PUSH BC
 512+ 51EF              	; ending )
 513+ 51EF CD DD 67     	CALL CHKCHAR
 514+ 51F2 29           	DB ')'
 515+ 51F3              .ENTRY:
 516+ 51F3 E5               PUSH HL
 517+ 51F4 DD E1            POP IX
 518+ 51F6 D1               POP DE ; pointer to INT array
 519+ 51F7 C1               POP BC ; B=item number
 520+ 51F8 F1               POP AF ; id
 521+ 51F9 D5               PUSH DE
 522+ 51FA CD B2 4F         CALL GETnthANIMDEF
 523+ 51FD D1               POP DE
 524+ 51FE 70               LD (HL),B
 525+ 51FF              .L1:
 526+ 51FF 23               INC HL
 527+ 5200 1A               LD A,(DE)
 528+ 5201 13          > INC DE
 528+ 5202 13          > INC DE
 529+ 5203 77               LD (HL),A
 530+ 5204 10 F9            DJNZ .L1
 531+ 5206 DD E5            PUSH IX
 532+ 5208 E1               POP HL
 533+ 5209 C9               RET
 534+ 520A              ; *******************************************************************************************************
 535+ 520A
 536+ 520A               IF (DEFUSR_EXTENSION == 1)
 537+ 520A              ; *******************************************************************************************************
 538+ 520A              ; same as MAXANIMSPRS but for DEFUSR approach
 539+ 520A              ; input IX=pointer to input array, real data from +2
 540+ 520A              ; +2 = number
 541+ 520A              MAXANIMSPRS_DEFUSR:
 542+ 520A DD 7E 02         LD A,(IX+2)
 543+ 520D 18 11            JR MAXANIMSPRS.COMMON
 544+ 520F              ; *******************************************************************************************************
 545+ 520F               ENDIF
 546+ 520F
 547+ 520F              ; *******************************************************************************************************
 548+ 520F              ; function to handle CALL MAXANIMSPRS basic extension
 549+ 520F              ; MAXANIMSPRS (BYTE number)
 550+ 520F              ; sets new number and moves memory buffers as needed
 551+ 520F              MAXANIMSPRS:
 552+ 520F               IF (BASIC_EXTENSION == 1)
 553+ 520F              	; opening (
 554+ 520F CD DD 67     	CALL CHKCHAR
 555+ 5212 28           	DB '('
 556+ 5213              	; get value
 557+ 5213 DD 21 1C 52  	LD IX, GETBYT
 558+ 5217 CD 59 01     	CALL CALBAS
 559+ 521A F5               PUSH AF
 560+ 521B              	; ending )
 561+ 521B CD DD 67     	CALL CHKCHAR
 562+ 521E 29           	DB ')'
 563+ 521F F1               POP AF
 564+ 5220               ENDIF
 565+ 5220              .COMMON:
 566+ 5220 F3               DI
 567+ 5221              	; save position
 568+ 5221 E5           	PUSH HL
 569+ 5222              .ENTRY:
 570+ 5222 47               LD B,A
 571+ 5223 3A 9A 4F         LD A,(ANIMSPRNUM)
 572+ 5226 90               SUB B
 573+ 5227 CA 21 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 574+ 522A FD 21 9E 4F      LD IY,AUTOSGAMPTR
 575+ 522E FA 3A 52         JP M, .INCREASE
 576+ 5231                  ; new value is lower than previous one
 577+ 5231 CD 5B 52         CALL .SIZEDIFF
 578+ 5234 CD 5E 50         CALL MAXANIMITEMS.DECREASE_COMMON
 579+ 5237 C3 18 50         JP MAXANIMITEMS.E3
 580+ 523A              .INCREASE:
 581+ 523A ED 44            NEG
 582+ 523C F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 583+ 523D CD 5B 52         CALL .SIZEDIFF
 584+ 5240 CD 8A 50         CALL MAXANIMITEMS.INCREASE_COMMON
 585+ 5243 AF               XOR A
 586+ 5244 ED 42            SBC HL,BC ; location of new stuff
 587+ 5246 F1               POP AF
 588+ 5247 C5               PUSH BC
 589+ 5248 47               LD B,A
 590+ 5249 11 08 00         LD DE,8
 591+ 524C E5               PUSH HL
 592+ 524D DD E1            POP IX
 593+ 524F              .L1:
 594+ 524F DD 36 06 00      LD (IX+6),0 ; active flag
 595+ 5253 DD 19            ADD IX,DE
 596+ 5255 10 F8            DJNZ .L1
 597+ 5257 C1               POP BC
 598+ 5258 C3 3A 50         JP MAXANIMITEMS.E4
 599+ 525B              .SIZEDIFF:
 600+ 525B 26 00            LD H,0
 601+ 525D 6F               LD L,A
 602+ 525E CD CB 66         CALL HLx8
 603+ 5261 78               LD A,B
 604+ 5262 32 9A 4F         LD (ANIMSPRNUM),A
 605+ 5265 44               LD B,H
 606+ 5266 4D               LD C,L
 607+ 5267 C9               RET ; BC=size difference in bytes
 608+ 5268              ; *******************************************************************************************************
 609+ 5268
 610+ 5268              ; *******************************************************************************************************
 611+ 5268              ; function to handle CALL ANIMSPRITE basic extension
 612+ 5268              ; ANIMSPRITE ( BYTE id,
 613+ 5268              ;              BYTE sprite_number,
 614+ 5268              ;              BYTE animation_definition_id,
 615+ 5268              ;              BYTE cyclic_flag )
 616+ 5268              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 617+ 5268              ANIMSPRITE:
 618+ 5268                  ; opening (
 619+ 5268 CD DD 67     	CALL CHKCHAR
 620+ 526B 28           	DB '('
 621+ 526C              	; get sprite animation id
 622+ 526C DD 21 1C 52  	LD IX, GETBYT
 623+ 5270 CD 59 01     	CALL CALBAS
 624+ 5273 F5               PUSH AF
 625+ 5274 3C               INC A
 626+ 5275 4F               LD C,A
 627+ 5276 3A 9A 4F         LD A,(ANIMSPRNUM)
 628+ 5279 B9               CP C
 629+ 527A DA F5 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 630+ 527D              	; comma
 631+ 527D CD DD 67     	CALL CHKCHAR
 632+ 5280 2C           	DB ','
 633+ 5281              	; get sprite number
 634+ 5281 DD 21 1C 52  	LD IX, GETBYT
 635+ 5285 CD 59 01     	CALL CALBAS
 636+ 5288 F5               PUSH AF
 637+ 5289                  ; check if out of bounds
 638+ 5289 FE 20            CP 32
 639+ 528B D2 F5 67         JP NC, SUBSCRIPT_OUT_OF_RANGE
 640+ 528E              	; comma
 641+ 528E CD DD 67     	CALL CHKCHAR
 642+ 5291 2C           	DB ','
 643+ 5292              	; get animation definition id
 644+ 5292 DD 21 1C 52  	LD IX, GETBYT
 645+ 5296 CD 59 01     	CALL CALBAS
 646+ 5299 F5               PUSH AF
 647+ 529A 3C               INC A
 648+ 529B 4F               LD C,A
 649+ 529C 3A 97 4F         LD A,(ANIMDEFNUM)
 650+ 529F B9               CP C
 651+ 52A0 DA F5 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 652+ 52A3              	; comma
 653+ 52A3 CD DD 67     	CALL CHKCHAR
 654+ 52A6 2C           	DB ','
 655+ 52A7              	; get cyclic flag
 656+ 52A7 DD 21 1C 52  	LD IX, GETBYT
 657+ 52AB CD 59 01         CALL CALBAS
 658+ 52AE F5           	PUSH AF
 659+ 52AF              	; ending )
 660+ 52AF CD DD 67     	CALL CHKCHAR
 661+ 52B2 29           	DB ')'
 662+ 52B3              .ENTRY:
 663+ 52B3 E5               PUSH HL
 664+ 52B4 DD E1            POP IX
 665+ 52B6 D9               EXX
 666+ 52B7 D1               POP DE ; cyclic
 667+ 52B8 C1               POP BC ; animation definition id
 668+ 52B9 E1               POP HL ; sprite number
 669+ 52BA D9               EXX
 670+ 52BB F1               POP AF ; sprite animation id
 671+ 52BC CD BE 4F         CALL GETnthSPRANIM
 672+ 52BF E5               PUSH HL
 673+ 52C0 FD E1            POP IY
 674+ 52C2 D9               EXX
 675+ 52C3 FD 74 00         LD (IY),H
 676+ 52C6 FD 70 04         LD (IY+4),B
 677+ 52C9 FD 72 05         LD (IY+5),D
 678+ 52CC                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 679+ 52CC                  ; following will do preparation for ANIMSTEP situation
 680+ 52CC                  ; current item set to above limit and timer to 1
 681+ 52CC                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 682+ 52CC FD 36 03 FF      LD (IY+3),255
 683+ 52D0 FD 36 01 01      LD (IY+1),1
 684+ 52D4 FD 36 02 00      LD (IY+2),0
 685+ 52D8                  ; mark as sprite animation
 686+ 52D8 FD 36 07 00      LD (IY+7),0
 687+ 52DC DD E5            PUSH IX
 688+ 52DE E1               POP HL
 689+ 52DF C9               RET
 690+ 52E0              ; *******************************************************************************************************
 691+ 52E0
 692+ 52E0              ; *******************************************************************************************************
 693+ 52E0              ; function to handle CALL ANIMCHAR basic extension
 694+ 52E0              ; ANIMCHAR ( BYTE id,
 695+ 52E0              ;            INT character number 0-767,
 696+ 52E0              ;            BYTE animation_definition_id,
 697+ 52E0              ;            BYTE cyclic_flag )
 698+ 52E0              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 699+ 52E0              ANIMCHAR:
 700+ 52E0                  ; opening (
 701+ 52E0 CD DD 67     	CALL CHKCHAR
 702+ 52E3 28           	DB '('
 703+ 52E4              	; get sprite animation id
 704+ 52E4 DD 21 1C 52  	LD IX, GETBYT
 705+ 52E8 CD 59 01     	CALL CALBAS
 706+ 52EB F5               PUSH AF
 707+ 52EC 3C               INC A
 708+ 52ED 4F               LD C,A
 709+ 52EE 3A 9A 4F         LD A,(ANIMSPRNUM)
 710+ 52F1 B9               CP C
 711+ 52F2 DA F5 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 712+ 52F5              	; comma
 713+ 52F5 CD DD 67     	CALL CHKCHAR
 714+ 52F8 2C           	DB ','
 715+ 52F9              	; get character number
 716+ 52F9 DD 21 2F 54  	LD IX, FRMQNT
 717+ 52FD CD 59 01     	CALL CALBAS
 718+ 5300 D5               PUSH DE
 719+ 5301                  ; check if out of bounds
 720+ 5301 7A               LD A,D
 721+ 5302 FE 03            CP 3
 722+ 5304 D2 F5 67         JP NC, SUBSCRIPT_OUT_OF_RANGE
 723+ 5307              	; comma
 724+ 5307 CD DD 67     	CALL CHKCHAR
 725+ 530A 2C           	DB ','
 726+ 530B              	; get animation definition id
 727+ 530B DD 21 1C 52  	LD IX, GETBYT
 728+ 530F CD 59 01     	CALL CALBAS
 729+ 5312 F5               PUSH AF
 730+ 5313 3C               INC A
 731+ 5314 4F               LD C,A
 732+ 5315 3A 97 4F         LD A,(ANIMDEFNUM)
 733+ 5318 B9               CP C
 734+ 5319 DA F5 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 735+ 531C              	; comma
 736+ 531C CD DD 67     	CALL CHKCHAR
 737+ 531F 2C           	DB ','
 738+ 5320              	; get cyclic flag
 739+ 5320 DD 21 1C 52  	LD IX, GETBYT
 740+ 5324 CD 59 01         CALL CALBAS
 741+ 5327 F5           	PUSH AF
 742+ 5328              	; ending )
 743+ 5328 CD DD 67     	CALL CHKCHAR
 744+ 532B 29           	DB ')'
 745+ 532C              .ENTRY:
 746+ 532C E5               PUSH HL
 747+ 532D DD E1            POP IX
 748+ 532F D9               EXX
 749+ 5330 D1               POP DE ; cyclic
 750+ 5331 C1               POP BC ; animation definition id
 751+ 5332 E1               POP HL ; character number
 752+ 5333 D9               EXX
 753+ 5334 F1               POP AF ; sprite animation id
 754+ 5335 CD BE 4F         CALL GETnthSPRANIM
 755+ 5338 E5               PUSH HL
 756+ 5339 FD E1            POP IY
 757+ 533B D9               EXX
 758+ 533C FD 75 00         LD (IY),L
 759+ 533F 24               INC H ; save character bank+1
 760+ 5340 FD 74 07         LD (IY+7),H
 761+ 5343 FD 70 04         LD (IY+4),B
 762+ 5346 FD 72 05         LD (IY+5),D
 763+ 5349                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 764+ 5349                  ; following will do preparation for ANIMSTEP situation
 765+ 5349                  ; current item set to above limit and timer to 1
 766+ 5349                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 767+ 5349 FD 36 03 FF      LD (IY+3),255
 768+ 534D FD 36 01 01      LD (IY+1),1
 769+ 5351 FD 36 02 00      LD (IY+2),0
 770+ 5355 DD E5            PUSH IX
 771+ 5357 E1               POP HL
 772+ 5358 C9               RET
 773+ 5359              ; *******************************************************************************************************
 774+ 5359
 775+ 5359               IF (DEFUSR_EXTENSION == 1)
 776+ 5359              ; *******************************************************************************************************
 777+ 5359              ; same as MAXAUTOSGAMS but for DEFUSR approach
 778+ 5359              ; input IX=pointer to input array, real data from +2
 779+ 5359              ; +2 = number
 780+ 5359              MAXAUTOSGAMS_DEFUSR:
 781+ 5359 DD 7E 02         LD A,(IX+2)
 782+ 535C 18 11            JR MAXAUTOSGAMS.COMMON
 783+ 535E              ; *******************************************************************************************************
 784+ 535E               ENDIF
 785+ 535E
 786+ 535E              ; *******************************************************************************************************
 787+ 535E              ; function to handle CALL MAXAUTOSGAMS basic extension
 788+ 535E              ; MAXAUTOSGAMS (BYTE number)
 789+ 535E              ; sets new number and moves memory buffers as needed
 790+ 535E              MAXAUTOSGAMS:
 791+ 535E               IF (BASIC_EXTENSION == 1)
 792+ 535E              	; opening (
 793+ 535E CD DD 67     	CALL CHKCHAR
 794+ 5361 28           	DB '('
 795+ 5362              	; get value
 796+ 5362 DD 21 1C 52  	LD IX, GETBYT
 797+ 5366 CD 59 01     	CALL CALBAS
 798+ 5369 F5               PUSH AF
 799+ 536A              	; ending )
 800+ 536A CD DD 67     	CALL CHKCHAR
 801+ 536D 29           	DB ')'
 802+ 536E F1               POP AF
 803+ 536F               ENDIF
 804+ 536F              .COMMON:
 805+ 536F F3               DI
 806+ 5370              	; save position
 807+ 5370 E5           	PUSH HL
 808+ 5371              .ENTRY:
 809+ 5371 47               LD B,A
 810+ 5372 3A 9D 4F         LD A,(AUTOSGAMNUM)
 811+ 5375 90               SUB B
 812+ 5376 CA 21 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 813+ 5379 FD 21 10 40      LD IY,FREEMEMPTR
 814+ 537D FA 89 53         JP M, .INCREASE
 815+ 5380                  ; new value is lower than previous one
 816+ 5380 CD AA 53         CALL .SIZEDIFF
 817+ 5383 CD 5E 50         CALL MAXANIMITEMS.DECREASE_COMMON
 818+ 5386 C3 21 50         JP MAXANIMITEMS.EXIT
 819+ 5389              .INCREASE:
 820+ 5389 ED 44            NEG
 821+ 538B F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 822+ 538C CD AA 53         CALL .SIZEDIFF
 823+ 538F CD 8A 50         CALL MAXANIMITEMS.INCREASE_COMMON
 824+ 5392 AF               XOR A
 825+ 5393 ED 42            SBC HL,BC ; location of new stuff
 826+ 5395 F1               POP AF
 827+ 5396 C5               PUSH BC
 828+ 5397 47               LD B,A
 829+ 5398 11 18 00         LD DE,24
 830+ 539B E5               PUSH HL
 831+ 539C DD E1            POP IX
 832+ 539E              .L1:
 833+ 539E DD 36 13 00      LD (IX+19),0 ; active flag
 834+ 53A2 DD 19            ADD IX,DE
 835+ 53A4 10 F8            DJNZ .L1
 836+ 53A6 C1               POP BC
 837+ 53A7 C3 21 50         JP MAXANIMITEMS.EXIT
 838+ 53AA              .SIZEDIFF:
 839+ 53AA 26 00            LD H,0
 840+ 53AC 6F               LD L,A
 841+ 53AD CD CB 66         CALL HLx8
 842+ 53B0 54               LD D,H
 843+ 53B1 5D               LD E,L
 844+ 53B2 29               ADD HL,HL
 845+ 53B3 19               ADD HL,DE
 846+ 53B4 78               LD A,B
 847+ 53B5 32 9D 4F         LD (AUTOSGAMNUM),A
 848+ 53B8 44               LD B,H
 849+ 53B9 4D               LD C,L
 850+ 53BA C9               RET ; BC=size difference in bytes
 851+ 53BB              ; *******************************************************************************************************
 852+ 53BB
 853+ 53BB              ; *******************************************************************************************************
 854+ 53BB              ; function to handle CALL AUTOSGAMDEF basic extension
 855+ 53BB              ; AUTOSGAMDEF ( BYTE id,
 856+ 53BB              ;               INT VARIABLE x, INT VARIABLE y,
 857+ 53BB              ;               INT minimum, INT maximum, INT delta,
 858+ 53BB              ;               INT direction =0 horizontal,
 859+ 53BB              ;               INT ticks,
 860+ 53BB              ;               BYTE sprite_group_count,
 861+ 53BB              ;               INT[2][sprite_group_count] VARIABLE sprite_group,
 862+ 53BB              ;               BYTE item_number,
 863+ 53BB              ;               INT[] VARIABLE sprite_animations_negative_direction,
 864+ 53BB              ;               INT[] VARIABLE sprite_animations_positive_direction
 865+ 53BB              AUTOSGAMDEF:
 866+ 53BB                  ; opening (
 867+ 53BB CD DD 67     	CALL CHKCHAR
 868+ 53BE 28           	DB '('
 869+ 53BF              	; get sprite animation id
 870+ 53BF DD 21 1C 52  	LD IX, GETBYT
 871+ 53C3 CD 59 01     	CALL CALBAS
 872+ 53C6 F5               PUSH AF
 873+ 53C7 3C               INC A
 874+ 53C8 4F               LD C,A
 875+ 53C9 3A 9D 4F         LD A,(AUTOSGAMNUM)
 876+ 53CC B9               CP C
 877+ 53CD DA F5 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 878+ 53D0 F1               POP AF
 879+ 53D1 E5               PUSH HL
 880+ 53D2 CD CA 4F         CALL GETnthAUTOSGAM
 881+ 53D5 22 CA 64         LD (BLIT_TMP),HL ; for later
 882+ 53D8 E1               POP HL
 883+ 53D9              	; comma
 884+ 53D9 CD DD 67     	CALL CHKCHAR
 885+ 53DC 2C           	DB ','
 886+ 53DD              	; get address of the X coordinate variable
 887+ 53DD DD 21 A4 5E  	LD IX, PTRGET
 888+ 53E1 CD 59 01     	CALL CALBAS
 889+ 53E4 DD 2A CA 64  	LD IX,(BLIT_TMP)
 890+ 53E8 DD 73 00         LD (IX+0),E
 891+ 53EB DD 72 01         LD (IX+1),D
 892+ 53EE              	; comma
 893+ 53EE CD DD 67     	CALL CHKCHAR
 894+ 53F1 2C           	DB ','
 895+ 53F2              	; get address of the Y coordinate variable
 896+ 53F2 DD 21 A4 5E  	LD IX, PTRGET
 897+ 53F6 CD 59 01     	CALL CALBAS
 898+ 53F9 DD 2A CA 64  	LD IX,(BLIT_TMP)
 899+ 53FD DD 73 02         LD (IX+2),E
 900+ 5400 DD 72 03         LD (IX+3),D
 901+ 5403              	; comma
 902+ 5403 CD DD 67     	CALL CHKCHAR
 903+ 5406 2C           	DB ','
 904+ 5407              	; get minimum value
 905+ 5407 DD 21 2F 54  	LD IX, FRMQNT
 906+ 540B CD 59 01     	CALL CALBAS
 907+ 540E DD 2A CA 64  	LD IX,(BLIT_TMP)
 908+ 5412 DD 73 04         LD (IX+4),E
 909+ 5415 DD 72 05         LD (IX+5),D
 910+ 5418              	; comma
 911+ 5418 CD DD 67     	CALL CHKCHAR
 912+ 541B 2C           	DB ','
 913+ 541C              	; get maximum value
 914+ 541C DD 21 2F 54  	LD IX, FRMQNT
 915+ 5420 CD 59 01     	CALL CALBAS
 916+ 5423 DD 2A CA 64  	LD IX,(BLIT_TMP)
 917+ 5427 DD 73 06         LD (IX+6),E
 918+ 542A DD 72 07         LD (IX+7),D
 919+ 542D              	; comma
 920+ 542D CD DD 67     	CALL CHKCHAR
 921+ 5430 2C           	DB ','
 922+ 5431              	; get delta value
 923+ 5431 DD 21 2F 54  	LD IX, FRMQNT
 924+ 5435 CD 59 01     	CALL CALBAS
 925+ 5438 DD 2A CA 64  	LD IX,(BLIT_TMP)
 926+ 543C DD 73 08         LD (IX+8),E
 927+ 543F DD 72 09         LD (IX+9),D
 928+ 5442              	; comma
 929+ 5442 CD DD 67     	CALL CHKCHAR
 930+ 5445 2C           	DB ','
 931+ 5446              	; get direction value
 932+ 5446 DD 21 2F 54  	LD IX, FRMQNT
 933+ 544A CD 59 01     	CALL CALBAS
 934+ 544D DD 2A CA 64  	LD IX,(BLIT_TMP)
 935+ 5451 DD 73 0A         LD (IX+10),E
 936+ 5454 DD 72 0B         LD (IX+11),D
 937+ 5457              	; comma
 938+ 5457 CD DD 67     	CALL CHKCHAR
 939+ 545A 2C           	DB ','
 940+ 545B              	; get ticks value
 941+ 545B DD 21 2F 54  	LD IX, FRMQNT
 942+ 545F CD 59 01     	CALL CALBAS
 943+ 5462 DD 2A CA 64  	LD IX,(BLIT_TMP)
 944+ 5466 DD 73 14         LD (IX+20),E
 945+ 5469 DD 72 15         LD (IX+21),D
 946+ 546C              	; comma
 947+ 546C CD DD 67     	CALL CHKCHAR
 948+ 546F 2C           	DB ','
 949+ 5470              	; get sprite group count
 950+ 5470 DD 21 1C 52  	LD IX, GETBYT
 951+ 5474 CD 59 01     	CALL CALBAS
 952+ 5477 B7               OR A
 953+ 5478 CA F5 67         JP Z,SUBSCRIPT_OUT_OF_RANGE
 954+ 547B DD 2A CA 64  	LD IX,(BLIT_TMP)
 955+ 547F DD 77 0B         LD (IX+11),A
 956+ 5482              	; comma
 957+ 5482 CD DD 67     	CALL CHKCHAR
 958+ 5485 2C           	DB ','
 959+ 5486              	; get sprite group definition array data pointer
 960+ 5486 DD 2A CA 64  	LD IX,(BLIT_TMP)
 961+ 548A DD 5E 0B         LD E,(IX+11)
 962+ 548D 16 03        	LD D,3
 963+ 548F 3E 02        	LD A,2
 964+ 5491 47           	LD B,A
 965+ 5492 CD 0A 68     	CALL GET_BASIC_ARRAY_DATA_POINTER
 966+ 5495 DD 2A CA 64  	LD IX,(BLIT_TMP)
 967+ 5499 DD 71 0C     	LD (IX+12),C
 968+ 549C DD 70 0D         LD (IX+13),B
 969+ 549F              	; comma
 970+ 549F CD DD 67     	CALL CHKCHAR
 971+ 54A2 2C           	DB ','
 972+ 54A3              	; get sprite animation array size
 973+ 54A3 DD 21 1C 52  	LD IX,GETBYT
 974+ 54A7 CD 59 01     	CALL CALBAS
 975+ 54AA DD 2A CA 64  	LD IX,(BLIT_TMP)
 976+ 54AE DD 77 0E         LD (IX+14),A
 977+ 54B1 B7               OR A
 978+ 54B2 CA F5 67         JP Z,SUBSCRIPT_OUT_OF_RANGE
 979+ 54B5              	; comma
 980+ 54B5 CD DD 67     	CALL CHKCHAR
 981+ 54B8 2C           	DB ','
 982+ 54B9                  ; get array pointer for negative direction
 983+ 54B9 DD 2A CA 64  	LD IX,(BLIT_TMP)
 984+ 54BD DD 56 0E         LD D,(IX+14)
 985+ 54C0 3E 02            LD A,2
 986+ 54C2 06 01            LD B,1
 987+ 54C4 CD 0A 68         CALL GET_BASIC_ARRAY_DATA_POINTER
 988+ 54C7 DD 2A CA 64  	LD IX,(BLIT_TMP)
 989+ 54CB DD 71 0F         LD (IX+15),C
 990+ 54CE DD 70 10         LD (IX+16),B
 991+ 54D1              	; comma
 992+ 54D1 CD DD 67     	CALL CHKCHAR
 993+ 54D4 2C           	DB ','
 994+ 54D5                  ; get array pointer for positive direction
 995+ 54D5 DD 2A CA 64  	LD IX,(BLIT_TMP)
 996+ 54D9 DD 56 0E         LD D,(IX+14)
 997+ 54DC 3E 02            LD A,2
 998+ 54DE 06 01            LD B,1
 999+ 54E0 CD 0A 68         CALL GET_BASIC_ARRAY_DATA_POINTER
1000+ 54E3 DD 2A CA 64  	LD IX,(BLIT_TMP)
1001+ 54E7 DD 71 11         LD (IX+17),C
1002+ 54EA DD 70 12         LD (IX+18),B
1003+ 54ED              	; ending )
1004+ 54ED CD DD 67     	CALL CHKCHAR
1005+ 54F0 29           	DB ')'
1006+ 54F1 C9               RET
1007+ 54F2              ; *******************************************************************************************************
1008+ 54F2
1009+ 54F2              ; *******************************************************************************************************
1010+ 54F2              ; function to handle CALL AUTOSGAMSTART basic extension
1011+ 54F2              ; AUTOSGAMSTART ( BYTE id )
1012+ 54F2              AUTOSGAMSTART:
1013+ 54F2 3E 01            LD A,1
1014+ 54F4              .COMMON:
1015+ 54F4 32 20 55         LD (.SETVALUE+3),A
1016+ 54F7                  ; opening (
1017+ 54F7 CD DD 67     	CALL CHKCHAR
1018+ 54FA 28           	DB '('
1019+ 54FB              	; get sprite animation id
1020+ 54FB DD 21 1C 52  	LD IX, GETBYT
1021+ 54FF CD 59 01     	CALL CALBAS
1022+ 5502 F5               PUSH AF
1023+ 5503 3C               INC A
1024+ 5504 4F               LD C,A
1025+ 5505 3A 9D 4F         LD A,(AUTOSGAMNUM)
1026+ 5508 B9               CP C
1027+ 5509 DA F5 67         JP C,SUBSCRIPT_OUT_OF_RANGE
1028+ 550C F1               POP AF
1029+ 550D E5               PUSH HL
1030+ 550E CD CA 4F         CALL GETnthAUTOSGAM
1031+ 5511 E5               PUSH HL
1032+ 5512 DD E1            POP IX
1033+ 5514 E1               POP HL
1034+ 5515 DD E5            PUSH IX
1035+ 5517              	; ending )
1036+ 5517 CD DD 67     	CALL CHKCHAR
1037+ 551A 29           	DB ')'
1038+ 551B
1039+ 551B                  ; so syntax is fine
1040+ 551B DD E1            POP IX
1041+ 551D              .SETVALUE:
1042+ 551D DD 36 13 01      LD (IX+19),1 ; active flag
1043+ 5521                  ; set initial timer
1044+ 5521 DD 7E 14         LD A,(IX+20)
1045+ 5524 DD 77 16         LD (IX+22),A
1046+ 5527 DD 7E 15         LD A,(IX+21)
1047+ 552A DD 77 17         LD (IX+23),A
1048+ 552D C9               RET
1049+ 552E              ; *******************************************************************************************************
1050+ 552E
1051+ 552E              ; *******************************************************************************************************
1052+ 552E              ; function to handle CALL AUTOSGAMSTOP basic extension
1053+ 552E              ; AUTOSGAMSTOP ( BYTE id )
1054+ 552E              AUTOSGAMSTOP:
1055+ 552E AF               XOR A
1056+ 552F 18 C3            JR AUTOSGAMSTART.COMMON
1057+ 5531              ; *******************************************************************************************************
1058+ 5531
1059+ 5531               IF (BASIC_EXTENSION == 1)
1060+ 5531              ; *******************************************************************************************************
1061+ 5531              ; function to handle CALL ANIMSTEP basic extension
1062+ 5531              ; two forms
1063+ 5531              ; ANIMSTEP ( BYTE id )
1064+ 5531              ; or
1065+ 5531              ; ANIMSTEP ( BYTE item_number,
1066+ 5531              ;            INT[] sprite_animations )
1067+ 5531              ANIMSTEP:
1068+ 5531 11 B0 55         LD DE,ANIMSTARTSTOP_COMMON.STEP
1069+ 5534 18 08            JR ANIMSTARTSTOP_COMMON
1070+ 5536              ; *******************************************************************************************************
1071+ 5536              ; *******************************************************************************************************
1072+ 5536              ; function to handle CALL ANIMSTART basic extension
1073+ 5536              ; two forms
1074+ 5536              ; ANIMSTART ( BYTE id )
1075+ 5536              ; or
1076+ 5536              ; ANIMSTART ( BYTE item_number,
1077+ 5536              ;             INT[] sprite_animations )
1078+ 5536              ; sets active flag to 1
1079+ 5536              ANIMSTART:
1080+ 5536 11 9E 55         LD DE,ANIMSTARTSTOP_COMMON.START
1081+ 5539 18 03            JR ANIMSTARTSTOP_COMMON
1082+ 553B              ; *******************************************************************************************************
1083+ 553B              ; *******************************************************************************************************
1084+ 553B              ; function to handle CALL ANIMSTOP basic extension
1085+ 553B              ; two forms
1086+ 553B              ; ANIMSTOP ( BYTE id )
1087+ 553B              ; or
1088+ 553B              ; ANIMSTOP ( BYTE item_number,
1089+ 553B              ;            INT[] sprite_animations )
1090+ 553B              ; sets active flag to 0
1091+ 553B              ANIMSTOP:
1092+ 553B 11 AB 55         LD DE,ANIMSTARTSTOP_COMMON.STOP
1093+ 553E              ; *******************************************************************************************************
1094+ 553E              ANIMSTARTSTOP_COMMON:
1095+ 553E ED 53 9C 55      LD (ANIMSTARTSTOP_COMMON.FN+1),DE
1096+ 5542                  ; opening (
1097+ 5542 CD DD 67     	CALL CHKCHAR
1098+ 5545 28           	DB '('
1099+ 5546              	; get sprite animation id or array size
1100+ 5546 DD 21 1C 52  	LD IX,GETBYT
1101+ 554A CD 59 01     	CALL CALBAS
1102+ 554D F5               PUSH AF
1103+ 554E                  ; check if comma present
1104+ 554E CD E7 67         CALL GETPREVCHAR
1105+ 5551 23               INC HL
1106+ 5552 FE 2C            CP ','
1107+ 5554 28 0E            JR Z,.L1
1108+ 5556 FE 29            CP ')'
1109+ 5558 C2 01 68         JP NZ,SYNTAX_ERROR
1110+ 555B                  ; ok so single argument variant
1111+ 555B F1               POP AF
1112+ 555C E5               PUSH HL
1113+ 555D F3               DI
1114+ 555E CD 8A 55         CALL .SETVALUE
1115+ 5561 FB               EI
1116+ 5562 E1               POP HL
1117+ 5563 C9               RET
1118+ 5564              .L1:
1119+ 5564                  ; get array pointer
1120+ 5564 D1               POP DE
1121+ 5565 D5               PUSH DE
1122+ 5566 3E 02            LD A,2
1123+ 5568 06 01            LD B,1
1124+ 556A CD 0A 68         CALL GET_BASIC_ARRAY_DATA_POINTER
1125+ 556D C5               PUSH BC
1126+ 556E              	; ending )
1127+ 556E CD DD 67     	CALL CHKCHAR
1128+ 5571 29           	DB ')'
1129+ 5572 D1               POP DE ; array pointer
1130+ 5573 C1               POP BC ; number of items
1131+ 5574 78               LD A,B
1132+ 5575 B7               OR A
1133+ 5576 CA F5 67         JP Z,SUBSCRIPT_OUT_OF_RANGE
1134+ 5579 E5               PUSH HL
1135+ 557A F3               DI
1136+ 557B              .L2:
1137+ 557B C5               PUSH BC
1138+ 557C 1A               LD A,(DE)
1139+ 557D 13          > INC DE
1139+ 557E 13          > INC DE
1140+ 557F D5               PUSH DE
1141+ 5580 CD 8A 55         CALL .SETVALUE
1142+ 5583 D1               POP DE
1143+ 5584 C1               POP BC
1144+ 5585 10 F4            DJNZ .L2
1145+ 5587 FB               EI
1146+ 5588 E1               POP HL
1147+ 5589 C9               RET
1148+ 558A
1149+ 558A              .SETVALUE:
1150+ 558A 47               LD B,A
1151+ 558B 3C               INC A
1152+ 558C 4F               LD C,A
1153+ 558D 3A 9A 4F         LD A,(ANIMSPRNUM)
1154+ 5590 B9               CP C
1155+ 5591 DA F5 67         JP C,SUBSCRIPT_OUT_OF_RANGE
1156+ 5594 78               LD A,B
1157+ 5595 CD BE 4F         CALL GETnthSPRANIM
1158+ 5598 E5               PUSH HL
1159+ 5599 DD E1            POP IX
1160+ 559B              .FN:
1161+ 559B C3 00 00         JP 0
1162+ 559E              .START:
1163+ 559E DD 36 06 01      LD (IX+6),1 ; active flag
1164+ 55A2 DD 36 03 00      LD (IX+3),0 ; current item
1165+ 55A6 06 00            LD B,0 ; setup timer
1166+ 55A8 C3 97 56         JP SETUP_ANIM_STEP
1167+ 55AB              .STOP:
1168+ 55AB DD 36 06 00      LD (IX+6),0 ; active flag
1169+ 55AF C9               RET
1170+ 55B0              .STEP:
1171+ 55B0 06 00            LD B,0
1172+ 55B2 C3 3B 56         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1173+ 55B5              ; *******************************************************************************************************
1174+ 55B5               ENDIF
1175+ 55B5
1176+ 55B5               IF (DEFUSR_EXTENSION == 1)
1177+ 55B5              ; *******************************************************************************************************
1178+ 55B5              ; helper function to locate single animation and execute operation
1179+ 55B5              ; needs to have jump set to a correct function
1180+ 55B5              ; input A=animation item
1181+ 55B5              ANIM_SETVALUE:
1182+ 55B5 47               LD B,A
1183+ 55B6 3C               INC A
1184+ 55B7 4F               LD C,A
1185+ 55B8 3A 9A 4F         LD A,(ANIMSPRNUM)
1186+ 55BB B9               CP C
1187+ 55BC D8               RET C ; out of range, so do nothing
1188+ 55BD 78               LD A,B
1189+ 55BE CD BE 4F         CALL GETnthSPRANIM
1190+ 55C1 E5               PUSH HL
1191+ 55C2 DD E1            POP IX
1192+ 55C4              .FN:
1193+ 55C4 C3 00 00         JP 0
1194+ 55C7              ; *******************************************************************************************************
1195+ 55C7
1196+ 55C7              ; *******************************************************************************************************
1197+ 55C7              ; helper function to set values of multiple animations
1198+ 55C7              ; needs to have jump set to a correct function
1199+ 55C7              ; input B=number of animation item
1200+ 55C7              ; input DE=animation item array
1201+ 55C7              ANIM_LIST_SETVALUE:
1202+ 55C7 F3               DI
1203+ 55C8 C5               PUSH BC
1204+ 55C9 1A               LD A,(DE)
1205+ 55CA 13          > INC DE
1205+ 55CB 13          > INC DE
1206+ 55CC D5               PUSH DE
1207+ 55CD CD B5 55         CALL ANIM_SETVALUE
1208+ 55D0 D1               POP DE
1209+ 55D1 C1               POP BC
1210+ 55D2 10 F3            DJNZ ANIM_LIST_SETVALUE
1211+ 55D4 FB               EI
1212+ 55D5 C9               RET
1213+ 55D6              ; *******************************************************************************************************
1214+ 55D6
1215+ 55D6              ; *******************************************************************************************************
1216+ 55D6              ; function to handle single item ANIMSTEP in DEFUSR mode
1217+ 55D6              ; input IX=pointer to input array, real data from +2
1218+ 55D6              ; +2 = animation id
1219+ 55D6              ANIMSTEP_SINGLE_DEFUSR:
1220+ 55D6 21 E1 55         LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1221+ 55D9              .L1:
1222+ 55D9 22 C5 55         LD (ANIM_SETVALUE.FN+1),HL
1223+ 55DC DD 7E 02         LD A,(IX+2)
1224+ 55DF 18 D4            JR ANIM_SETVALUE
1225+ 55E1              .STEP:
1226+ 55E1 06 00            LD B,0
1227+ 55E3 C3 3B 56         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1228+ 55E6              ; *******************************************************************************************************
1229+ 55E6
1230+ 55E6              ; *******************************************************************************************************
1231+ 55E6              ; function to handle multi item ANIMSTEP in DEFUSR mode
1232+ 55E6              ; input IX=pointer to input array, real data from +2
1233+ 55E6              ; +2 = list size
1234+ 55E6              ; +4 = array pointer holding items
1235+ 55E6              ANIMSTEP_MULTI_DEFUSR:
1236+ 55E6 21 E1 55         LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1237+ 55E9              .L1:
1238+ 55E9 22 C5 55         LD (ANIM_SETVALUE.FN+1),HL
1239+ 55EC DD 46 02         LD B,(IX+2)
1240+ 55EF DD 5E 04         LD E,(IX+4)
1241+ 55F2 DD 56 05         LD D,(IX+5)
1242+ 55F5 18 D0            JR ANIM_LIST_SETVALUE
1243+ 55F7              ; *******************************************************************************************************
1244+ 55F7
1245+ 55F7              ; *******************************************************************************************************
1246+ 55F7              ; function to handle single item ANIMSTART in DEFUSR mode
1247+ 55F7              ; input IX=pointer to input array, real data from +2
1248+ 55F7              ; +2 = animation id
1249+ 55F7              ANIMSTART_SINGLE_DEFUSR:
1250+ 55F7 21 FC 55         LD HL,ANIMSTART_SINGLE_DEFUSR.START
1251+ 55FA 18 DD            JR ANIMSTEP_SINGLE_DEFUSR.L1
1252+ 55FC              .START:
1253+ 55FC DD 36 06 01      LD (IX+6),1 ; active flag
1254+ 5600 DD 36 03 00      LD (IX+3),0 ; current item
1255+ 5604 06 00            LD B,0 ; setup timer
1256+ 5606 C3 97 56         JP SETUP_ANIM_STEP
1257+ 5609              ; *******************************************************************************************************
1258+ 5609
1259+ 5609              ; *******************************************************************************************************
1260+ 5609              ; function to handle multi item ANIMSTART in DEFUSR mode
1261+ 5609              ; input IX=pointer to input array, real data from +2
1262+ 5609              ; +2 = list size
1263+ 5609              ; +4 = array pointer holding items
1264+ 5609              ANIMSTART_MULTI_DEFUSR:
1265+ 5609 21 FC 55         LD HL,ANIMSTART_SINGLE_DEFUSR.START
1266+ 560C 18 DB            JR ANIMSTEP_MULTI_DEFUSR.L1
1267+ 560E              ; *******************************************************************************************************
1268+ 560E
1269+ 560E              ; *******************************************************************************************************
1270+ 560E              ; function to handle single item ANIMSTOP in DEFUSR mode
1271+ 560E              ; input IX=pointer to input array, real data from +2
1272+ 560E              ; +2 = animation id
1273+ 560E              ANIMSTOP_SINGLE_DEFUSR:
1274+ 560E 21 13 56         LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1275+ 5611 18 C6            JR ANIMSTEP_SINGLE_DEFUSR.L1
1276+ 5613              .STOP:
1277+ 5613 DD 36 06 00      LD (IX+6),0 ; active flag
1278+ 5617 C9               RET
1279+ 5618              ; *******************************************************************************************************
1280+ 5618
1281+ 5618              ; *******************************************************************************************************
1282+ 5618              ; function to handle multi item ANIMSTOP in DEFUSR mode
1283+ 5618              ; input IX=pointer to input array, real data from +2
1284+ 5618              ; +2 = list size
1285+ 5618              ; +4 = array pointer holding items
1286+ 5618              ANIMSTOP_MULTI_DEFUSR:
1287+ 5618 21 13 56         LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1288+ 561B 18 CC            JR ANIMSTEP_MULTI_DEFUSR.L1
1289+ 561D              ; *******************************************************************************************************
1290+ 561D               ENDIF
1291+ 561D
1292+ 561D              ; *******************************************************************************************************
1293+ 561D              ; function processes animations during vblank period
1294+ 561D              PROCESS_ANIMATIONS:
1295+ 561D 3A 9A 4F         LD A,(ANIMSPRNUM)
1296+ 5620 B7               OR A
1297+ 5621 C8               RET Z; no animations defined
1298+ 5622 47               LD B,A
1299+ 5623 DD 2A 9B 4F      LD IX,(ANIMSPRPTR)
1300+ 5627              .L1:
1301+ 5627 C5               PUSH BC
1302+ 5628 06 00            LD B,0 ; normal mode, change on timer expiry only
1303+ 562A CD 36 56         CALL PROCESS_SINGLE_ANIMATION
1304+ 562D 11 08 00         LD DE,8
1305+ 5630 DD 19            ADD IX,DE
1306+ 5632 C1               POP BC
1307+ 5633 10 F2            DJNZ .L1
1308+ 5635 C9               RET
1309+ 5636              ; *******************************************************************************************************
1310+ 5636
1311+ 5636              ; *******************************************************************************************************
1312+ 5636              ; processes single sprite animation
1313+ 5636              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
1314+ 5636              ; on timer expiry goes to next animation item
1315+ 5636              ; input IX=sprite animation pointer
1316+ 5636              ; input B=1 force mode, activate animation action regardless of expired timer
1317+ 5636              PROCESS_SINGLE_ANIMATION:
1318+ 5636 DD 7E 06         LD A,(IX+6); active
1319+ 5639 B7               OR A
1320+ 563A C8               RET Z ; inactive animation
1321+ 563B              .INACTIVE_TOO:
1322+ 563B DD 6E 01         LD L,(IX+1)
1323+ 563E DD 66 02         LD H,(IX+2) ; HL=end time
1324+ 5641 2B               DEC HL
1325+ 5642 DD 75 01         LD (IX+1),L
1326+ 5645 DD 74 02         LD (IX+2),H
1327+ 5648 7D               LD A,L
1328+ 5649 B4               OR H
1329+ 564A 28 06            JR Z,.STEP
1330+ 564C 05               DEC B
1331+ 564D 04               INC B
1332+ 564E C8               RET Z ; not forced mode, return
1333+ 564F C3 97 56         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
1334+ 5652              .STEP:
1335+ 5652 06 00            LD B,0; setup timer
1336+ 5654 DD 34 03         INC (IX+3) ; current animation item
1337+ 5657 C3 97 56         JP SETUP_ANIM_STEP
1338+ 565A              ; *******************************************************************************************************
1339+ 565A
1340+ 565A              ; *******************************************************************************************************
1341+ 565A              ; function will setup sprite animation after current item change
1342+ 565A              ; input A=current animation definition
1343+ 565A              ; input IX=pointer to sprite animation
1344+ 565A              ; input B=1 skip timer setup
1345+ 565A              ; output IY=pointer to animation item
1346+ 565A              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
1347+ 565A              ; basically sets new end time for current animation
1348+ 565A              INIT_CURRENT_ANIMATION:
1349+ 565A CD B2 4F         CALL GETnthANIMDEF
1350+ 565D DD 7E 03         LD A,(IX+3) ; current animation item
1351+ 5660 BE               CP (HL) ; number of animation items in the animation definition
1352+ 5661 38 0A            JR C,.L3 ; last item not reached
1353+ 5663                  ; last item reached
1354+ 5663 DD 7E 05         LD A,(IX+5) ; cyclic flag
1355+ 5666 B7               OR A
1356+ 5667 28 2C            JR Z,.ERROR ; non-cyclic animation
1357+ 5669                  ; cyclic animation, restart
1358+ 5669 DD 36 03 00      LD (IX+3),0; current item
1359+ 566D              .L3:
1360+ 566D                  ; HL = animation definition
1361+ 566D 23               INC HL ; skip animation definition size field
1362+ 566E 16 00            LD D,0
1363+ 5670 DD 5E 03         LD E,(IX+3); current item
1364+ 5673 19               ADD HL,DE
1365+ 5674 4E               LD C,(HL) ; current animation item
1366+ 5675 0C               INC C
1367+ 5676 3A 94 4F         LD A,(ANIMITEMNUM)
1368+ 5679 B9               CP C
1369+ 567A 38 19            JR C,.ERROR ; invalid animation item, stop animation
1370+ 567C 0D               DEC C
1371+ 567D 79               LD A,C
1372+ 567E CD A9 4F         CALL GETnthANIMITEM
1373+ 5681 E5               PUSH HL
1374+ 5682 FD E1            POP IY ; IY=animation item
1375+ 5684 05               DEC B
1376+ 5685 28 0C            JR Z,.EXIT
1377+ 5687 FD 5E 01         LD E,(IY+1)
1378+ 568A FD 56 02         LD D,(IY+2) ; duration
1379+ 568D DD 73 01         LD (IX+1),E
1380+ 5690 DD 72 02         LD (IX+2),D
1381+ 5693              .EXIT:
1382+ 5693 AF               XOR A
1383+ 5694 C9               RET
1384+ 5695              .ERROR:
1385+ 5695 37               SCF
1386+ 5696 C9               RET
1387+ 5697              ; *******************************************************************************************************
1388+ 5697
1389+ 5697              ; *******************************************************************************************************
1390+ 5697              ; function will display currect item and set up expiry time
1391+ 5697              ; it will also stop the animation if expired
1392+ 5697              ; sets sprite update flag if any changes in sprite data made
1393+ 5697              ; input IX=current sprite animation
1394+ 5697              ; input B=1 skip timer setup
1395+ 5697              SETUP_ANIM_STEP:
1396+ 5697 DD 4E 04         LD C,(IX+4) ; animation definition ID
1397+ 569A 0C               INC C
1398+ 569B 3A 97 4F         LD A,(ANIMDEFNUM)
1399+ 569E B9               CP C
1400+ 569F 30 05            JR NC,.L2
1401+ 56A1                  ; given animation item is outside of bounds, deactivate animation
1402+ 56A1              .STOPANIM:
1403+ 56A1 DD 36 06 00      LD (IX+6),0
1404+ 56A5 C9               RET
1405+ 56A6              .L2:
1406+ 56A6 0D               DEC C
1407+ 56A7 79               LD A,C
1408+ 56A8 CD 5A 56         CALL INIT_CURRENT_ANIMATION
1409+ 56AB 38 F4            JR C, .STOPANIM
1410+ 56AD FD 7E 00         LD A,(IY) ; type of animation item
1411+ 56B0 B7               OR A
1412+ 56B1 28 44            JR Z,.L4 ; change pattern and/or color
1413+ 56B3              .PAT:
1414+ 56B3                  ; change pattern definition
1415+ 56B3                  ; check if sprite or character
1416+ 56B3 DD 7E 07         LD A,(IX+7)
1417+ 56B6 B7               OR A
1418+ 56B7 20 58            JR NZ,.CHAR
1419+ 56B9 DD 7E 00         LD A,(IX) ; sprite number
1420+ 56BC CD 89 4D         CALL GETnthSPRATTR
1421+ 56BF 23          > INC HL ; skip y and x
1421+ 56C0 23          > INC HL
1421+ 56C1 23          > INC HL
1421+ 56C2 23          > INC HL
1422+ 56C3 7E               LD A,(HL); current pattern
1423+ 56C4 26 00            LD H,0
1424+ 56C6 6F               LD L,A
1425+ 56C7 3A E0 F3         LD A,(REG1SAV)
1426+ 56CA E6 02            AND 2
1427+ 56CC 20 07            JR NZ,.L6
1428+ 56CE                  ; 8x8 sprite
1429+ 56CE CD CB 66         CALL HLx8
1430+ 56D1 06 08            LD B,8
1431+ 56D3 18 05            JR .L5
1432+ 56D5              .L6:
1433+ 56D5 CD C9 66         CALL HLx32
1434+ 56D8 06 20            LD B,32
1435+ 56DA              .L5:
1436+ 56DA 3A AF FC         LD A,(SCRMOD)
1437+ 56DD 3D               DEC A
1438+ 56DE 20 06            JR NZ,.L10
1439+ 56E0 ED 5B C5 F3      LD DE,(T32PAT)
1440+ 56E4 18 04            JR .L7
1441+ 56E6              .L10:
1442+ 56E6 ED 5B CF F3      LD DE,(GRPPAT)
1443+ 56EA              .L7:
1444+ 56EA 19               ADD HL,DE
1445+ 56EB CD B6 66         CALL SETWRT_LOCAL
1446+ 56EE FD 6E 03         LD L,(IY+3)
1447+ 56F1 FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
1448+ 56F4 C3 C1 66         JP BBYTECOPY
1449+ 56F7              .L4:
1450+ 56F7                  ; change pattern and color in sprite attributes table
1451+ 56F7 DD 7E 00         LD A,(IX) ; sprite number
1452+ 56FA CD 89 4D         CALL GETnthSPRATTR
1453+ 56FD 23          > INC HL ; skip y and x
1453+ 56FE 23          > INC HL
1453+ 56FF 23          > INC HL
1453+ 5700 23          > INC HL
1454+ 5701 FD 7E 03         LD A,(IY+3) ; new pattern
1455+ 5704 77               LD (HL),A
1456+ 5705 23          > INC HL
1456+ 5706 23          > INC HL
1457+ 5707 FD 7E 04         LD A,(IY+4) ; new color
1458+ 570A 77               LD (HL),A
1459+ 570B 2A 80 4D         LD HL,(SPRATR_UPDATE_FLAG)
1460+ 570E 36 01            LD (HL),1
1461+ 5710 C9               RET
1462+ 5711              .CHAR:
1463+ 5711 DD 6E 00         LD L,(IX)
1464+ 5714 3D               DEC A
1465+ 5715 67               LD H,A
1466+ 5716 CD CB 66         CALL HLx8
1467+ 5719 3A AF FC         LD A,(SCRMOD)
1468+ 571C 3D               DEC A
1469+ 571D 20 06            JR NZ,.L8
1470+ 571F ED 5B C1 F3      LD DE,(T32CGP)
1471+ 5723 18 04            JR .L9
1472+ 5725              .L8:
1473+ 5725 ED 5B CB F3      LD DE,(GRPCGP)
1474+ 5729              .L9:
1475+ 5729 06 08            LD B,8
1476+ 572B 18 BD            JR .L7
1477+ 572D              ; *******************************************************************************************************
1478+ 572D
# file closed: asm\ANIMATION.asm
 134  572D               INCLUDE "SGAM.asm"
# file opened: asm\SGAM.asm
   1+ 572D              ; Sprite Group Animate and Move
   2+ 572D
   3+ 572D              ; *******************************************************************************************************
   4+ 572D              ; shared function to process a list of animations
   5+ 572D              ; input B=list size
   6+ 572D              ; input DE=list pointer
   7+ 572D              SGAM_PROCESS_ANIM_LIST:
   8+ 572D 21 40 57         LD HL,.STEP
   9+ 5730 22 9C 55         LD (ANIMSTARTSTOP_COMMON.FN+1),HL
  10+ 5733              .L1:
  11+ 5733 C5               PUSH BC
  12+ 5734 1A               LD A,(DE)
  13+ 5735 13          > INC DE
  13+ 5736 13          > INC DE
  14+ 5737 D5               PUSH DE
  15+ 5738 CD 8A 55         CALL ANIMSTARTSTOP_COMMON.SETVALUE
  16+ 573B D1               POP DE
  17+ 573C C1               POP BC
  18+ 573D 10 F4            DJNZ .L1
  19+ 573F C9           	RET
  20+ 5740              .STEP:
  21+ 5740 06 01            LD B,1
  22+ 5742 C3 3B 56         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
  23+ 5745              ; *******************************************************************************************************
  24+ 5745
  25+ 5745               IF (BASIC_EXTENSION == 1)
  26+ 5745              ; *******************************************************************************************************
  27+ 5745              ; function to handle CALL SGAM basic extension
  28+ 5745              ; sets position of a group of sprites as described in SPRGRPMOV
  29+ 5745              ; and manually animate a list of animations
  30+ 5745              ; _SGAM ( INT x,
  31+ 5745              ;	      INT y,
  32+ 5745              ;		  BYTE count,
  33+ 5745              ;		  INT[2][count] data_ptr,
  34+ 5745              ;         BYTE item_number,
  35+ 5745              ;         INT[] sprite_animations )
  36+ 5745              ; will put ram in page 0 also, page 1 is already there
  37+ 5745              SGAM:
  38+ 5745 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
  39+ 5748 B7           	OR A
  40+ 5749 CA FD 67     	JP Z,ILLEGAL_FUNCTION
  41+ 574C              	; opening (
  42+ 574C CD DD 67     	CALL CHKCHAR
  43+ 574F 28           	DB '('
  44+ 5750              	; get x
  45+ 5750 DD 21 2F 54  	LD IX, FRMQNT
  46+ 5754 CD 59 01     	CALL CALBAS
  47+ 5757 ED 53 CE 64  	LD (BLIT_STRUCT),DE
  48+ 575B              	; comma
  49+ 575B CD DD 67     	CALL CHKCHAR
  50+ 575E 2C           	DB ','
  51+ 575F              	; get y
  52+ 575F DD 21 2F 54  	LD IX, FRMQNT
  53+ 5763 CD 59 01     	CALL CALBAS
  54+ 5766 ED 53 D0 64  	LD (BLIT_STRUCT+2),DE
  55+ 576A              	; comma
  56+ 576A CD DD 67     	CALL CHKCHAR
  57+ 576D 2C           	DB ','
  58+ 576E              	; get count
  59+ 576E DD 21 1C 52  	LD IX, GETBYT
  60+ 5772 CD 59 01     	CALL CALBAS
  61+ 5775 B7               OR A
  62+ 5776 CA F5 67         JP Z,SUBSCRIPT_OUT_OF_RANGE
  63+ 5779 32 D2 64     	LD (BLIT_STRUCT+4),A
  64+ 577C              	; comma
  65+ 577C CD DD 67     	CALL CHKCHAR
  66+ 577F 2C           	DB ','
  67+ 5780              	; get sprite group definition array data pointer
  68+ 5780 3A D2 64         LD A,(BLIT_STRUCT+4)
  69+ 5783 5F           	LD E,A
  70+ 5784 16 03        	LD D,3
  71+ 5786 3E 02        	LD A,2
  72+ 5788 47           	LD B,A
  73+ 5789 CD 0A 68     	CALL GET_BASIC_ARRAY_DATA_POINTER
  74+ 578C ED 43 D3 64  	LD (BLIT_STRUCT+5),BC
  75+ 5790              	; comma
  76+ 5790 CD DD 67     	CALL CHKCHAR
  77+ 5793 2C           	DB ','
  78+ 5794              	; get sprite animation array size
  79+ 5794 DD 21 1C 52  	LD IX,GETBYT
  80+ 5798 CD 59 01     	CALL CALBAS
  81+ 579B 32 D5 64         LD (BLIT_STRUCT+7),A
  82+ 579E B7               OR A
  83+ 579F CA F5 67         JP Z,SUBSCRIPT_OUT_OF_RANGE
  84+ 57A2              	; comma
  85+ 57A2 CD DD 67     	CALL CHKCHAR
  86+ 57A5 2C           	DB ','
  87+ 57A6                  ; get array pointer
  88+ 57A6 3A D5 64         LD A,(BLIT_STRUCT+7)
  89+ 57A9 57               LD D,A
  90+ 57AA 3E 02            LD A,2
  91+ 57AC 06 01            LD B,1
  92+ 57AE CD 0A 68         CALL GET_BASIC_ARRAY_DATA_POINTER
  93+ 57B1 ED 43 D6 64      LD (BLIT_STRUCT+8),BC
  94+ 57B5              	; ending )
  95+ 57B5 CD DD 67     	CALL CHKCHAR
  96+ 57B8 29           	DB ')'
  97+ 57B9              .ENTRY:
  98+ 57B9 E5               PUSH HL
  99+ 57BA F3               DI
 100+ 57BB
 101+ 57BB              	; enable page 0
 102+ 57BB FD 21 C2 57  	LD IY, .RET
 103+ 57BF C3 8F 67     	JP ENABLE_PAGE0
 104+ 57C2              .RET:
 105+ 57C2 D9               EXX
 106+ 57C3 ED 5B CE 64      LD DE,(BLIT_STRUCT) ; initial x
 107+ 57C7 ED 4B D0 64      LD BC,(BLIT_STRUCT+2) ; initial y
 108+ 57CB D9               EXX
 109+ 57CC 2A D3 64         LD HL,(BLIT_STRUCT+5) ; pointer to data
 110+ 57CF 3A D2 64         LD A,(BLIT_STRUCT+4) ; number of entries
 111+ 57D2 47               LD B,A
 112+ 57D3 CD FD 4E         CALL SPR_UPDATE_LOC
 113+ 57D6
 114+ 57D6 3A D5 64         LD A,(BLIT_STRUCT+7) ; anim number
 115+ 57D9 47               LD B,A
 116+ 57DA ED 5B D6 64      LD DE,(BLIT_STRUCT+8) ; anim list
 117+ 57DE CD 2D 57     	CALL SGAM_PROCESS_ANIM_LIST
 118+ 57E1
 119+ 57E1 D1               POP DE
 120+ 57E2 C1               POP BC
 121+ 57E3 CD 06 67         CALL RESTORE_PAGE_INFO
 122+ 57E6 FB               EI
 123+ 57E7 E1               POP HL
 124+ 57E8 C9               RET
 125+ 57E9              ; *******************************************************************************************************
 126+ 57E9               ENDIF
 127+ 57E9
 128+ 57E9               IF (DEFUSR_EXTENSION == 1)
 129+ 57E9              ; *******************************************************************************************************
 130+ 57E9              ; same as SGAM but for DEFUSR approach
 131+ 57E9              ; input IX=pointer to input array, real data from +2
 132+ 57E9              ; +02 = X
 133+ 57E9              ; +04 = Y
 134+ 57E9              ; +06 = count
 135+ 57E9              ; +08 = data pointer
 136+ 57E9              ; +10 = anim number
 137+ 57E9              ; +12 = sprite animations
 138+ 57E9              SGAM_DEFUSR:
 139+ 57E9              	; enable page 0
 140+ 57E9 F3           	DI
 141+ 57EA FD 21 F1 57  	LD IY, .RET
 142+ 57EE C3 8F 67     	JP ENABLE_PAGE0
 143+ 57F1              .RET:
 144+ 57F1 FB           	EI
 145+ 57F2 D9               EXX
 146+ 57F3 DD 5E 02     	LD E,(IX+2)
 147+ 57F6 DD 56 03     	LD D,(IX+3) ; initial x
 148+ 57F9 DD 4E 04     	LD C,(IX+4)
 149+ 57FC DD 46 05     	LD B,(IX+5) ; initial y
 150+ 57FF D9               EXX
 151+ 5800 DD 6E 08     	LD L,(IX+8)
 152+ 5803 DD 66 09     	LD H,(IX+9) ; pointer to data
 153+ 5806 DD 46 06         LD B,(IX+6) ; count
 154+ 5809 DD E5        	PUSH IX
 155+ 580B CD FD 4E         CALL SPR_UPDATE_LOC
 156+ 580E DD E1        	POP IX
 157+ 5810 DD 46 0A         LD B,(IX+10) ; anim number
 158+ 5813 DD 5E 0C     	LD E,(IX+12)
 159+ 5816 DD 56 0D     	LD D,(IX+13)
 160+ 5819 CD 2D 57     	CALL SGAM_PROCESS_ANIM_LIST
 161+ 581C
 162+ 581C D1               POP DE
 163+ 581D C1               POP BC
 164+ 581E C3 06 67         JP RESTORE_PAGE_INFO
 165+ 5821              ; *******************************************************************************************************
 166+ 5821               ENDIF
 167+ 5821
 168+ 5821              ; *******************************************************************************************************
 169+ 5821              ; handles automatic move and animate sprite groups during interrupt
 170+ 5821              PROCESS_AUTOSGAMS:
 171+ 5821 3A 9D 4F     	LD A,(AUTOSGAMNUM)
 172+ 5824 B7           	OR A
 173+ 5825 C8           	RET Z
 174+ 5826 47           	LD B,A
 175+ 5827 DD 2A 9E 4F  	LD IX,(AUTOSGAMPTR)
 176+ 582B              .L1:
 177+ 582B C5           	PUSH BC
 178+ 582C DD 7E 13     	LD A,(IX+19) ; active flag
 179+ 582F B7           	OR A
 180+ 5830 28 28        	JR Z,.LOOPEND
 181+ 5832              	; active, check timer
 182+ 5832 DD 6E 16     	LD L,(IX+22)
 183+ 5835 DD 66 17     	LD H,(IX+23) ; timer
 184+ 5838 2B           	DEC HL
 185+ 5839 7C           	LD A,H
 186+ 583A B5           	OR L
 187+ 583B 28 08        	JR Z,.L2
 188+ 583D              	; not expired
 189+ 583D DD 75 16     	LD (IX+22),L
 190+ 5840 DD 74 17     	LD (IX+23),H
 191+ 5843 18 15        	JR .LOOPEND
 192+ 5845              .L2:
 193+ 5845              	; expired, process
 194+ 5845
 195+ 5845                  ; set initial timer
 196+ 5845 DD 7E 14         LD A,(IX+20)
 197+ 5848 DD 77 16         LD (IX+22),A
 198+ 584B DD 7E 15         LD A,(IX+21)
 199+ 584E DD 77 17         LD (IX+23),A
 200+ 5851
 201+ 5851 CD 63 58     	CALL .MOVE
 202+ 5854 CD CE 58     	CALL .UPDATELOC
 203+ 5857 CD F3 58     	CALL .PROCESS_ANIM_LIST
 204+ 585A
 205+ 585A              .LOOPEND:
 206+ 585A 11 18 00     	LD DE,24
 207+ 585D DD 19        	ADD IX,DE
 208+ 585F C1           	POP BC
 209+ 5860 10 C9        	DJNZ .L1
 210+ 5862 C9           	RET
 211+ 5863
 212+ 5863              .MOVE:
 213+ 5863              	; process movement
 214+ 5863 DD 7E 0A     	LD A,(IX+10) ; direction
 215+ 5866 B7           	OR A
 216+ 5867 28 08        	JR Z, .MOVE_L1
 217+ 5869              	; vertical
 218+ 5869 DD 6E 02     	LD L,(IX+2)
 219+ 586C DD 66 03     	LD H,(IX+3) ; vertical variable pointer
 220+ 586F 18 06        	JR .MOVE_L2
 221+ 5871              .MOVE_L1:
 222+ 5871              	; horizontal
 223+ 5871 DD 6E 00     	LD L,(IX+0)
 224+ 5874 DD 66 01     	LD H,(IX+1) ; horizontal variable pointer
 225+ 5877              .MOVE_L2:
 226+ 5877 E5           	PUSH HL
 227+ 5878 FD E1        	POP IY
 228+ 587A FD 6E 00     	LD L,(IY+0)
 229+ 587D FD 66 01     	LD H,(IY+1)
 230+ 5880 DD 5E 08     	LD E,(IX+8)
 231+ 5883 DD 56 09     	LD D,(IX+9) ; delta value
 232+ 5886 19           	ADD HL,DE
 233+ 5887 E5           	PUSH HL
 234+ 5888 DD 5E 04     	LD E,(IX+4)
 235+ 588B DD 56 05     	LD D,(IX+5) ; minimum value
 236+ 588E A7           	AND A
 237+ 588F ED 52        	SBC HL,DE
 238+ 5891 FA AB 58     	JP M,.MOVE_L3 ; below minimum
 239+ 5894 E1           	POP HL
 240+ 5895 E5           	PUSH HL
 241+ 5896 DD 5E 06     	LD E,(IX+6)
 242+ 5899 DD 56 07     	LD D,(IX+7) ; maximum value
 243+ 589C EB           	EX DE,HL
 244+ 589D A7           	AND A
 245+ 589E ED 52        	SBC HL,DE
 246+ 58A0 FA B3 58     	JP M,.MOVE_L4 ; above maximum
 247+ 58A3 E1           	POP HL
 248+ 58A4              	; within bounds
 249+ 58A4              .MOVE_L5:
 250+ 58A4 FD 75 00     	LD (IY+0),L
 251+ 58A7 FD 74 01     	LD (IY+1),H
 252+ 58AA C9           	RET
 253+ 58AB              .MOVE_L3:
 254+ 58AB E1           	POP HL
 255+ 58AC CD BF 58     	CALL .INVERSE_DELTA
 256+ 58AF 6B           	LD L,E
 257+ 58B0 62           	LD H,D
 258+ 58B1 18 F1        	JR .MOVE_L5
 259+ 58B3              .MOVE_L4:
 260+ 58B3 E1           	POP HL
 261+ 58B4 CD BF 58     	CALL .INVERSE_DELTA
 262+ 58B7 DD 6E 06     	LD L,(IX+6)
 263+ 58BA DD 66 07     	LD H,(IX+7) ; maximum
 264+ 58BD 18 E5        	JR .MOVE_L5
 265+ 58BF              .INVERSE_DELTA:
 266+ 58BF AF           	XOR A
 267+ 58C0 DD 96 08     	SUB (IX+8)
 268+ 58C3 DD 77 08     	LD (IX+8),A
 269+ 58C6 9F           	SBC A,A
 270+ 58C7 DD 96 09     	SUB (IX+9)
 271+ 58CA DD 77 09     	LD (IX+9),A
 272+ 58CD C9           	RET
 273+ 58CE
 274+ 58CE              .UPDATELOC:
 275+ 58CE DD E5        	PUSH IX
 276+ 58D0 D9           	EXX
 277+ 58D1 DD 6E 00     	LD L,(IX+0)
 278+ 58D4 DD 66 01     	LD H,(IX+1)
 279+ 58D7 5E           	LD E,(HL)
 280+ 58D8 23           	INC HL
 281+ 58D9 56           	LD D,(HL)
 282+ 58DA DD 6E 02     	LD L,(IX+2)
 283+ 58DD DD 66 03     	LD H,(IX+3)
 284+ 58E0 4E           	LD C,(HL)
 285+ 58E1 23           	INC HL
 286+ 58E2 46           	LD B,(HL)
 287+ 58E3 D9           	EXX
 288+ 58E4 DD 6E 0C     	LD L,(IX+12)
 289+ 58E7 DD 66 0D     	LD H,(IX+13) ; pointer to sprite group data
 290+ 58EA DD 46 0B     	LD B,(IX+11) ; sprite group size
 291+ 58ED CD FD 4E     	CALL SPR_UPDATE_LOC
 292+ 58F0 DD E1        	POP IX
 293+ 58F2 C9           	RET
 294+ 58F3
 295+ 58F3              .PROCESS_ANIM_LIST:
 296+ 58F3 DD E5        	PUSH IX
 297+ 58F5 DD 46 0E         LD B,(IX+14) ; anim list size
 298+ 58F8 DD CB 09 7E  	BIT 7,(IX+9)
 299+ 58FC 28 08        	JR Z,.PROCESS_ANIM_LIST_L1
 300+ 58FE              	; negative direction
 301+ 58FE DD 5E 0F     	LD E,(IX+15)
 302+ 5901 DD 56 10     	LD D,(IX+16)
 303+ 5904 18 06        	JR .PROCESS_ANIM_LIST_L2
 304+ 5906              .PROCESS_ANIM_LIST_L1:
 305+ 5906              	; positive direction
 306+ 5906 DD 5E 11     	LD E,(IX+17)
 307+ 5909 DD 56 12     	LD D,(IX+18)
 308+ 590C              .PROCESS_ANIM_LIST_L2:
 309+ 590C CD 2D 57     	CALL SGAM_PROCESS_ANIM_LIST
 310+ 590F DD E1        	POP IX
 311+ 5911 C9           	RET
 312+ 5912              ; *******************************************************************************************************
 313+ 5912
# file closed: asm\SGAM.asm
 135  5912               ENDIF
 136  5912
 137  5912               IF (RAM_CMDS == 1)
 138  5912               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
   1+ 5912               IF (BASIC_EXTENSION == 1)
   2+ 5912              ; *******************************************************************************************************
   3+ 5912              ; function to handle CALL MEMCPY basic extension
   4+ 5912              ; _MEMCPY ( INT source,
   5+ 5912              ;			INT destination,
   6+ 5912              ;			INT count,
   7+ 5912              ; will put ram in page 0 also, page 1 is already there
   8+ 5912              MEMCPY:
   9+ 5912              	; opening (
  10+ 5912 CD DD 67     	CALL CHKCHAR
  11+ 5915 28           	DB '('
  12+ 5916              	; get source address
  13+ 5916 DD 21 2F 54  	LD IX, FRMQNT
  14+ 591A CD 59 01     	CALL CALBAS
  15+ 591D D5           	PUSH DE
  16+ 591E              	; comma
  17+ 591E CD DD 67     	CALL CHKCHAR
  18+ 5921 2C           	DB ','
  19+ 5922              	; get destination address
  20+ 5922 DD 21 2F 54  	LD IX, FRMQNT
  21+ 5926 CD 59 01     	CALL CALBAS
  22+ 5929 D5           	PUSH DE
  23+ 592A              	; comma
  24+ 592A CD DD 67     	CALL CHKCHAR
  25+ 592D 2C           	DB ','
  26+ 592E              	; get length
  27+ 592E DD 21 2F 54  	LD IX, FRMQNT
  28+ 5932 CD 59 01     	CALL CALBAS
  29+ 5935 D5           	PUSH DE
  30+ 5936              	; ending )
  31+ 5936 CD DD 67     	CALL CHKCHAR
  32+ 5939 29           	DB ')'
  33+ 593A
  34+ 593A              	; save position
  35+ 593A E5           	PUSH HL
  36+ 593B DD E1        	POP IX
  37+ 593D
  38+ 593D C1           	POP BC ; count
  39+ 593E D1           	POP DE ; destination
  40+ 593F E1           	POP HL ; source
  41+ 5940 D9           	EXX
  42+ 5941              	; enable page 0
  43+ 5941 F3           	DI
  44+ 5942 FD 21 49 59  	LD IY, .RET
  45+ 5946 C3 8F 67     	JP ENABLE_PAGE0
  46+ 5949              .RET:
  47+ 5949 FB           	EI
  48+ 594A D9           	EXX
  49+ 594B ED B0        	LDIR
  50+ 594D D1               POP DE
  51+ 594E C1               POP BC
  52+ 594F CD 06 67         CALL RESTORE_PAGE_INFO
  53+ 5952 DD E5        	PUSH IX
  54+ 5954 E1           	POP HL
  55+ 5955 C9           	RET
  56+ 5956              ; *******************************************************************************************************
  57+ 5956               ENDIF
  58+ 5956
  59+ 5956               IF (DEFUSR_EXTENSION == 1)
  60+ 5956              ; *******************************************************************************************************
  61+ 5956              ; same as MEMCPY but for DEFUSR approach
  62+ 5956              ; input IX=pointer to input array, real data from +2
  63+ 5956              ; +2 = source address
  64+ 5956              ; +4 = destination address
  65+ 5956              ; +6 = lenght
  66+ 5956              MEMCPY_DEFUSR:
  67+ 5956              	; enable page 0
  68+ 5956 F3           	DI
  69+ 5957 FD 21 5E 59  	LD IY, .RET
  70+ 595B C3 8F 67     	JP ENABLE_PAGE0
  71+ 595E              .RET:
  72+ 595E FB           	EI
  73+ 595F DD 6E 02     	LD L,(IX+2)
  74+ 5962 DD 66 03     	LD H,(IX+3)
  75+ 5965 DD 5E 04     	LD E,(IX+4)
  76+ 5968 DD 56 05     	LD D,(IX+5)
  77+ 596B DD 4E 06     	LD C,(IX+6)
  78+ 596E DD 46 07     	LD B,(IX+7)
  79+ 5971 ED B0        	LDIR
  80+ 5973 D1               POP DE
  81+ 5974 C1               POP BC
  82+ 5975 C3 06 67         JP RESTORE_PAGE_INFO
  83+ 5978              ; *******************************************************************************************************
  84+ 5978               ENDIF
  85+ 5978
  86+ 5978              ; *******************************************************************************************************
  87+ 5978              ; function to handle CALL FILRAM basic extension
  88+ 5978              ; FILRAM ( INT start address,
  89+ 5978              ;		   INT count,
  90+ 5978              ;		   BYTE value )
  91+ 5978              ; will put ram in page 0 also, page 1 is already there
  92+ 5978              FILRAM:
  93+ 5978              	; opening (
  94+ 5978 CD DD 67     	CALL CHKCHAR
  95+ 597B 28           	DB '('
  96+ 597C              	; get start address
  97+ 597C DD 21 2F 54  	LD IX, FRMQNT
  98+ 5980 CD 59 01     	CALL CALBAS
  99+ 5983 D5           	PUSH DE
 100+ 5984              	; comma
 101+ 5984 CD DD 67     	CALL CHKCHAR
 102+ 5987 2C           	DB ','
 103+ 5988              	; get count
 104+ 5988 DD 21 2F 54  	LD IX, FRMQNT
 105+ 598C CD 59 01     	CALL CALBAS
 106+ 598F D5           	PUSH DE
 107+ 5990              	; comma
 108+ 5990 CD DD 67     	CALL CHKCHAR
 109+ 5993 2C           	DB ','
 110+ 5994              	; get value
 111+ 5994 DD 21 1C 52  	LD IX, GETBYT
 112+ 5998 CD 59 01     	CALL CALBAS
 113+ 599B F5           	PUSH AF
 114+ 599C              	; ending )
 115+ 599C CD DD 67     	CALL CHKCHAR
 116+ 599F 29           	DB ')'
 117+ 59A0
 118+ 59A0              	; save position
 119+ 59A0 E5           	PUSH HL
 120+ 59A1 DD E1        	POP IX
 121+ 59A3
 122+ 59A3 D1           	POP DE ; actually AF
 123+ 59A4 C1           	POP BC ; count
 124+ 59A5 E1           	POP HL ; start address
 125+ 59A6 78           	LD A, B
 126+ 59A7 B7           	OR A
 127+ 59A8 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 128+ 59AA B1           	OR C
 129+ 59AB 28 1A        	JR Z, .EXIT ; 0 bytes to fill, skip
 130+ 59AD 79           	LD A, C
 131+ 59AE 3D           	DEC A
 132+ 59AF 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 133+ 59B1              	; one byte to fill
 134+ 59B1 72           	LD (HL), D
 135+ 59B2 18 13        	JR .EXIT
 136+ 59B4              .L1:
 137+ 59B4 D9           	EXX
 138+ 59B5              	; enable page 0
 139+ 59B5 F3           	DI
 140+ 59B6 FD 21 BD 59  	LD IY, .RET
 141+ 59BA C3 8F 67     	JP ENABLE_PAGE0
 142+ 59BD              .RET:
 143+ 59BD FB           	EI
 144+ 59BE D9           	EXX
 145+ 59BF CD CB 59     	CALL .FILLVALUE
 146+ 59C2 D1               POP DE
 147+ 59C3 C1               POP BC
 148+ 59C4 CD 06 67         CALL RESTORE_PAGE_INFO
 149+ 59C7              .EXIT:
 150+ 59C7 DD E5        	PUSH IX
 151+ 59C9 E1           	POP HL
 152+ 59CA C9           	RET
 153+ 59CB
 154+ 59CB              .FILLVALUE:
 155+ 59CB 72               LD (HL), D
 156+ 59CC 54               LD D, H
 157+ 59CD 5D               LD E, L
 158+ 59CE 13               INC DE
 159+ 59CF 0B               DEC BC
 160+ 59D0 ED B0            LDIR
 161+ 59D2 C9               RET
 162+ 59D3              ; *******************************************************************************************************
 163+ 59D3
# file closed: asm\MEMORY.asm
 139  59D3               ENDIF
 140  59D3
 141  59D3               IF (SOUND_CMDS == 1)
 142  59D3               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
   1+ 59D3              MUSIC_INIT_STATUS:
   2+ 59D3 00            DB 0
   3+ 59D4              SFX_INIT_STATUS:
   4+ 59D4 00            DB 0
   5+ 59D5              SOUND_ENABLED:
   6+ 59D5 00            DB 0
   7+ 59D6
   8+ 59D6              ; *******************************************************************************************************
   9+ 59D6              ; function to handle CALL SNDPLYINIT basic extension
  10+ 59D6              ; initializes sound player
  11+ 59D6              ; _SNDPLYINIT ( INT music_offset,
  12+ 59D6              ;				INT sfx_offset, can be -1 if no SFX
  13+ 59D6              ; will put ram in page 0 also, page 1 is already there
  14+ 59D6              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
  15+ 59D6              SNDPLYINIT:
  16+ 59D6              	; opening (
  17+ 59D6 CD DD 67     	CALL CHKCHAR
  18+ 59D9 28           	DB '('
  19+ 59DA              	; get music address
  20+ 59DA DD 21 2F 54  	LD IX, FRMQNT
  21+ 59DE CD 59 01     	CALL CALBAS
  22+ 59E1 D5           	PUSH DE
  23+ 59E2              	; comma
  24+ 59E2 CD DD 67     	CALL CHKCHAR
  25+ 59E5 2C           	DB ','
  26+ 59E6              	; get sfx address
  27+ 59E6 DD 21 2F 54  	LD IX, FRMQNT
  28+ 59EA CD 59 01     	CALL CALBAS
  29+ 59ED D5           	PUSH DE
  30+ 59EE              	; ending )
  31+ 59EE CD DD 67     	CALL CHKCHAR
  32+ 59F1 29           	DB ')'
  33+ 59F2
  34+ 59F2                  ; save position in BASIC text
  35+ 59F2 44           	LD B, H
  36+ 59F3 4D           	LD C, L
  37+ 59F4
  38+ 59F4              	; pop LDIR parameters and store away for later
  39+ 59F4 D1           	POP DE ; sfx address
  40+ 59F5 E1           	POP HL ; music address
  41+ 59F6 C5           	PUSH BC ; basic text location
  42+ 59F7 D9           	EXX
  43+ 59F8 FD 21 FF 59  	LD IY, .RET
  44+ 59FC C3 8F 67     	JP ENABLE_PAGE0
  45+ 59FF              .RET:
  46+ 59FF D9           	EXX
  47+ 5A00
  48+ 5A00 D5           	PUSH DE
  49+ 5A01 AF           	XOR A
  50+ 5A02              	; HL = music location
  51+ 5A02 CD 65 41     	CALL PLY_AKG_INIT
  52+ 5A05 3E 01        	LD A, 1
  53+ 5A07 32 D3 59     	LD (MUSIC_INIT_STATUS), A
  54+ 5A0A
  55+ 5A0A E1           	POP HL ; SFX
  56+ 5A0B              	; check if SFX address -1
  57+ 5A0B 23           	INC HL
  58+ 5A0C 7D           	LD A, L
  59+ 5A0D B4           	OR H
  60+ 5A0E 28 09        	JR Z,.L1
  61+ 5A10 2B           	DEC HL
  62+ 5A11 CD 20 40     	CALL PLY_AKG_INITSOUNDEFFECTS
  63+ 5A14 3E 01        	LD A, 1
  64+ 5A16 32 D4 59     	LD (SFX_INIT_STATUS), A
  65+ 5A19              .L1:
  66+ 5A19 D1               POP DE
  67+ 5A1A C1               POP BC
  68+ 5A1B CD 06 67         CALL RESTORE_PAGE_INFO
  69+ 5A1E
  70+ 5A1E E1           	POP HL
  71+ 5A1F C9           	RET
  72+ 5A20              ; *******************************************************************************************************
  73+ 5A20
  74+ 5A20              ; *******************************************************************************************************
  75+ 5A20              ; function to handle CALL SNDPLYON basic extension
  76+ 5A20              ; enables sound player
  77+ 5A20              ; _SNDPLYON
  78+ 5A20              ; sets SOUND_ENABLED variable to 1 if init call was done
  79+ 5A20              ; if not throws out of data error
  80+ 5A20              SNDPLYON:
  81+ 5A20 3A D3 59     	LD A, (MUSIC_INIT_STATUS)
  82+ 5A23 B7           	OR A
  83+ 5A24 20 05        	JR NZ, .L1
  84+ 5A26              	; player not initialized, throw error
  85+ 5A26 1E 04        	LD E, 04 ; Out of DATA
  86+ 5A28 C3 03 68     	JP THROW_ERROR
  87+ 5A2B              .L1:
  88+ 5A2B 32 D5 59     	LD (SOUND_ENABLED), A
  89+ 5A2E              	; disable key click
  90+ 5A2E AF           	XOR A
  91+ 5A2F 32 DB F3     	LD (CLIKSW), A
  92+ 5A32 C9           	RET
  93+ 5A33              ; *******************************************************************************************************
  94+ 5A33
  95+ 5A33              ; *******************************************************************************************************
  96+ 5A33              ; function to handle CALL SNDPLYOFF basic extension
  97+ 5A33              ; disables sound player
  98+ 5A33              ; _SNDPLYOFF
  99+ 5A33              ; sets SOUND_ENABLED variable to 0
 100+ 5A33              ; calls AKG to stop music and SFX on all channels if initialized
 101+ 5A33              SNDPLYOFF:
 102+ 5A33 3A D5 59     	LD A, (SOUND_ENABLED)
 103+ 5A36 B7           	OR A
 104+ 5A37 C8           	RET Z ; already stopped
 105+ 5A38 AF           	XOR A
 106+ 5A39 32 D5 59     	LD (SOUND_ENABLED), A
 107+ 5A3C E5           	PUSH HL
 108+ 5A3D CD 24 42     	CALL PLY_AKG_STOP
 109+ 5A40 3A D4 59     	LD A, (SFX_INIT_STATUS)
 110+ 5A43 B7           	OR A
 111+ 5A44 28 0E        	JR Z, .EXIT ; SFX not in use
 112+ 5A46 AF           	XOR A
 113+ 5A47 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 114+ 5A4A 3E 01        	LD A, 1
 115+ 5A4C CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 116+ 5A4F 3E 02        	LD A, 2
 117+ 5A51 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 118+ 5A54              .EXIT:
 119+ 5A54 E1           	POP HL
 120+ 5A55 C9           	RET
 121+ 5A56              ; *******************************************************************************************************
 122+ 5A56
 123+ 5A56               IF (BASIC_EXTENSION == 1)
 124+ 5A56              ; *******************************************************************************************************
 125+ 5A56              ; function to handle CALL SNDSFX basic extension
 126+ 5A56              ; plays a sound effect
 127+ 5A56              ; _SNDSFX ( BYTE sfx_number, >0
 128+ 5A56              ;			BYTE channel, = 0,1 or 2
 129+ 5A56              ;			BYTE inverted_volume = 0-16, 0 being full volume
 130+ 5A56              ; will put ram in page 0 also, page 1 is already there
 131+ 5A56              ; if sound off throws illegal function call
 132+ 5A56              ; if sfx not initialized, throws out of data
 133+ 5A56              SNDSFX:
 134+ 5A56              	; opening (
 135+ 5A56 CD DD 67     	CALL CHKCHAR
 136+ 5A59 28           	DB '('
 137+ 5A5A              	; get sfx_number
 138+ 5A5A DD 21 1C 52  	LD IX, GETBYT
 139+ 5A5E CD 59 01     	CALL CALBAS
 140+ 5A61 D5           	PUSH DE
 141+ 5A62              	; comma
 142+ 5A62 CD DD 67     	CALL CHKCHAR
 143+ 5A65 2C           	DB ','
 144+ 5A66              	; get sfx address
 145+ 5A66 DD 21 1C 52  	LD IX, GETBYT
 146+ 5A6A CD 59 01     	CALL CALBAS
 147+ 5A6D D5           	PUSH DE
 148+ 5A6E              	; comma
 149+ 5A6E CD DD 67     	CALL CHKCHAR
 150+ 5A71 2C           	DB ','
 151+ 5A72              	; get inverted volume
 152+ 5A72 DD 21 1C 52  	LD IX, GETBYT
 153+ 5A76 CD 59 01     	CALL CALBAS
 154+ 5A79 D5           	PUSH DE
 155+ 5A7A              	; ending )
 156+ 5A7A CD DD 67     	CALL CHKCHAR
 157+ 5A7D 29           	DB ')'
 158+ 5A7E
 159+ 5A7E 3A D5 59     	LD A, (SOUND_ENABLED)
 160+ 5A81 B7           	OR A
 161+ 5A82 20 05        	JR NZ, .L1
 162+ 5A84              	; sound disabled, throw illegal function call
 163+ 5A84 1E 05        	LD E, 5
 164+ 5A86 C3 03 68     	JP THROW_ERROR
 165+ 5A89              .L1:
 166+ 5A89 3A D4 59     	LD A, (SFX_INIT_STATUS)
 167+ 5A8C B7           	OR A
 168+ 5A8D 20 05        	JR NZ, .L2
 169+ 5A8F              	; sfx data not initialized, throw out of data
 170+ 5A8F 1E 04        	LD E, 4
 171+ 5A91 C3 03 68     	JP THROW_ERROR
 172+ 5A94              .L2:
 173+ 5A94              	; pop  parameters and store away for later
 174+ 5A94 D1           	POP DE ; inverted volume
 175+ 5A95 43           	LD B, E
 176+ 5A96 D1           	POP DE ; channel
 177+ 5A97 4B           	LD C, E
 178+ 5A98 D1           	POP DE
 179+ 5A99 7B           	LD A, E
 180+ 5A9A 08           	EX AF, AF'
 181+ 5A9B E5           	PUSH HL ; basic text location
 182+ 5A9C D9           	EXX
 183+ 5A9D FD 21 A4 5A  	LD IY, .RET
 184+ 5AA1 C3 8F 67     	JP ENABLE_PAGE0
 185+ 5AA4              .RET:
 186+ 5AA4 D9           	EXX
 187+ 5AA5 08           	EX AF, AF'
 188+ 5AA6 CD 24 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
 189+ 5AA9
 190+ 5AA9 D1               POP DE
 191+ 5AAA C1               POP BC
 192+ 5AAB CD 06 67         CALL RESTORE_PAGE_INFO
 193+ 5AAE
 194+ 5AAE E1           	POP HL
 195+ 5AAF C9           	RET
 196+ 5AB0              ; *******************************************************************************************************
 197+ 5AB0               ENDIF
 198+ 5AB0
 199+ 5AB0               IF (DEFUSR_EXTENSION == 1)
 200+ 5AB0              ; *******************************************************************************************************
 201+ 5AB0              ; same as SNDSFX but for DEFUSR approach
 202+ 5AB0              ; input IX=pointer to input array, real data from +2
 203+ 5AB0              ; +2 = SFX number
 204+ 5AB0              ; +4 = channel
 205+ 5AB0              ; +6 = volume
 206+ 5AB0              SNDSFX_DEFUSR:
 207+ 5AB0 3A D5 59     	LD A, (SOUND_ENABLED)
 208+ 5AB3 B7           	OR A
 209+ 5AB4 C8           	RET Z ; sound disabled, just exit
 210+ 5AB5 3A D4 59     	LD A, (SFX_INIT_STATUS)
 211+ 5AB8 B7           	OR A
 212+ 5AB9 C8           	RET Z ; sfx data not initialized, just exit
 213+ 5ABA F3           	DI
 214+ 5ABB FD 21 C2 5A  	LD IY, .RET
 215+ 5ABF C3 8F 67     	JP ENABLE_PAGE0
 216+ 5AC2              .RET:
 217+ 5AC2 FB           	EI
 218+ 5AC3 DD 7E 02     	LD A,(IX+2) ; SFX number
 219+ 5AC6 DD 4E 04     	LD C,(IX+4) ; channel
 220+ 5AC9 DD 46 06     	LD B,(IX+6) ; volume
 221+ 5ACC CD 24 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
 222+ 5ACF D1               POP DE
 223+ 5AD0 C1               POP BC
 224+ 5AD1 C3 06 67         JP RESTORE_PAGE_INFO
 225+ 5AD4              ; *******************************************************************************************************
 226+ 5AD4               ENDIF
# file closed: asm\SOUND.asm
 143  5AD4               ENDIF
 144  5AD4
 145  5AD4               IF (VRAM_CMDS == 1)
 146  5AD4               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
   1+ 5AD4              ; *******************************************************************************************************
   2+ 5AD4              ; function to handle CALL FILVRM basic extension
   3+ 5AD4              ; FILVRM ( INT offset,
   4+ 5AD4              ;		   INT count,
   5+ 5AD4              ;		   BYTE value,
   6+ 5AD4              ;		   BYTE wait_vsync) >0 = true
   7+ 5AD4              ; wait_vsync will issue HALT before copying
   8+ 5AD4              FILVRM:
   9+ 5AD4              	; opening (
  10+ 5AD4 CD DD 67     	CALL CHKCHAR
  11+ 5AD7 28           	DB '('
  12+ 5AD8              	; get offset address
  13+ 5AD8 DD 21 2F 54  	LD IX, FRMQNT
  14+ 5ADC CD 59 01     	CALL CALBAS
  15+ 5ADF D5           	PUSH DE
  16+ 5AE0              	; comma
  17+ 5AE0 CD DD 67     	CALL CHKCHAR
  18+ 5AE3 2C           	DB ','
  19+ 5AE4              	; get count
  20+ 5AE4 DD 21 2F 54  	LD IX, FRMQNT
  21+ 5AE8 CD 59 01     	CALL CALBAS
  22+ 5AEB D5           	PUSH DE
  23+ 5AEC              	; comma
  24+ 5AEC CD DD 67     	CALL CHKCHAR
  25+ 5AEF 2C           	DB ','
  26+ 5AF0              	; get value
  27+ 5AF0 DD 21 1C 52  	LD IX, GETBYT
  28+ 5AF4 CD 59 01     	CALL CALBAS
  29+ 5AF7 F5           	PUSH AF
  30+ 5AF8              	; comma
  31+ 5AF8 CD DD 67     	CALL CHKCHAR
  32+ 5AFB 2C           	DB ','
  33+ 5AFC              	; get vsync wait
  34+ 5AFC DD 21 1C 52  	LD IX, GETBYT
  35+ 5B00 CD 59 01     	CALL CALBAS
  36+ 5B03 F5           	PUSH AF
  37+ 5B04              	; ending )
  38+ 5B04 CD DD 67     	CALL CHKCHAR
  39+ 5B07 29           	DB ')'
  40+ 5B08
  41+ 5B08              	; save position
  42+ 5B08 E5           	PUSH HL
  43+ 5B09 DD E1        	POP IX
  44+ 5B0B
  45+ 5B0B              	; syntax ok
  46+ 5B0B              	; wait for vsync if needed
  47+ 5B0B F1           	POP AF
  48+ 5B0C B7           	OR A
  49+ 5B0D 28 01        	JR Z, .L1
  50+ 5B0F 76           	HALT
  51+ 5B10
  52+ 5B10              .L1:
  53+ 5B10 3E 01        	LD A,1
  54+ 5B12 32 DF 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
  55+ 5B15 F1               POP AF ; value
  56+ 5B16 C1               POP BC ; count
  57+ 5B17 E1               POP HL ; offset
  58+ 5B18 CD 56 00         CALL BIOS_FILVRM
  59+ 5B1B AF           	XOR A
  60+ 5B1C 32 DF 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
  61+ 5B1F
  62+ 5B1F              .L3:
  63+ 5B1F DD E5        	PUSH IX
  64+ 5B21 E1           	POP HL
  65+ 5B22 C9           	RET
  66+ 5B23              ; *******************************************************************************************************
  67+ 5B23
  68+ 5B23               IF (BASIC_EXTENSION == 1)
  69+ 5B23              ; *******************************************************************************************************
  70+ 5B23              ; function to handle CALL MEMVRM basic extension
  71+ 5B23              ; copies from RAM to VRAM
  72+ 5B23              ; _MEMVRM ( INT source,
  73+ 5B23              ;			INT destination,
  74+ 5B23              ;			INT count,
  75+ 5B23              ;			BYTE wait_vsync) >0 = true
  76+ 5B23              ; will put ram in page 0 also, page 1 is already there
  77+ 5B23              ; wait_vsync will issue HALT before copying
  78+ 5B23              MEMVRM:
  79+ 5B23              	; opening (
  80+ 5B23 CD DD 67     	CALL CHKCHAR
  81+ 5B26 28           	DB '('
  82+ 5B27              	; get source address
  83+ 5B27 DD 21 2F 54  	LD IX, FRMQNT
  84+ 5B2B CD 59 01     	CALL CALBAS
  85+ 5B2E D5           	PUSH DE
  86+ 5B2F              	; comma
  87+ 5B2F CD DD 67     	CALL CHKCHAR
  88+ 5B32 2C           	DB ','
  89+ 5B33              	; get destination address
  90+ 5B33 DD 21 2F 54  	LD IX, FRMQNT
  91+ 5B37 CD 59 01     	CALL CALBAS
  92+ 5B3A D5           	PUSH DE
  93+ 5B3B              	; comma
  94+ 5B3B CD DD 67     	CALL CHKCHAR
  95+ 5B3E 2C           	DB ','
  96+ 5B3F              	; get length
  97+ 5B3F DD 21 2F 54  	LD IX, FRMQNT
  98+ 5B43 CD 59 01     	CALL CALBAS
  99+ 5B46 D5           	PUSH DE
 100+ 5B47              	; comma
 101+ 5B47 CD DD 67     	CALL CHKCHAR
 102+ 5B4A 2C           	DB ','
 103+ 5B4B              	; get vsync wait
 104+ 5B4B DD 21 1C 52  	LD IX, GETBYT
 105+ 5B4F CD 59 01     	CALL CALBAS
 106+ 5B52 F5           	PUSH AF
 107+ 5B53              	; ending )
 108+ 5B53 CD DD 67     	CALL CHKCHAR
 109+ 5B56 29           	DB ')'
 110+ 5B57
 111+ 5B57                  ; save position in BASIC text
 112+ 5B57 E5           	PUSH HL
 113+ 5B58 DD E1        	POP IX
 114+ 5B5A
 115+ 5B5A F1           	POP AF ; wait vsync
 116+ 5B5B B7           	OR A
 117+ 5B5C 28 01        	JR Z, .L1
 118+ 5B5E 76           	HALT
 119+ 5B5F              .L1:
 120+ 5B5F F3           	DI
 121+ 5B60              	; pop LDIR parameters and store away for later
 122+ 5B60 C1           	POP BC ; count
 123+ 5B61 D1           	POP DE ; vram destination
 124+ 5B62 E1           	POP HL ; ram source
 125+ 5B63 D9           	EXX
 126+ 5B64 FD 21 6B 5B   	LD IY, .RET
 127+ 5B68 C3 8F 67     	JP ENABLE_PAGE0
 128+ 5B6B              .RET:
 129+ 5B6B FB           	EI
 130+ 5B6C D9           	EXX
 131+ 5B6D CD A3 5B     	CALL VRAM_LDIRVM
 132+ 5B70 D1               POP DE
 133+ 5B71 C1               POP BC
 134+ 5B72 CD 06 67         CALL RESTORE_PAGE_INFO
 135+ 5B75 DD E5        	PUSH IX
 136+ 5B77 E1           	POP HL
 137+ 5B78 C9           	RET
 138+ 5B79              ; *******************************************************************************************************
 139+ 5B79               ENDIF
 140+ 5B79
 141+ 5B79               IF (DEFUSR_EXTENSION == 1)
 142+ 5B79              ; *******************************************************************************************************
 143+ 5B79              ; same as MEMVRM but for DEFUSR approach
 144+ 5B79              ; input IX=pointer to input array, real data from +2
 145+ 5B79              ; +2 = source address
 146+ 5B79              ; +4 = destination address
 147+ 5B79              ; +6 = lenght
 148+ 5B79              ; +8 = vsync wait flag
 149+ 5B79              MEMVRM_DEFUSR:
 150+ 5B79 DD 7E 08     	LD A,(IX+8)
 151+ 5B7C B7           	OR A
 152+ 5B7D 28 01        	JR Z,.L0
 153+ 5B7F 76           	HALT
 154+ 5B80              .L0:
 155+ 5B80              	; enable page 0
 156+ 5B80 F3           	DI
 157+ 5B81 FD 21 88 5B  	LD IY, .RET
 158+ 5B85 C3 8F 67     	JP ENABLE_PAGE0
 159+ 5B88              .RET:
 160+ 5B88 FB           	EI
 161+ 5B89 DD 6E 02     	LD L,(IX+2)
 162+ 5B8C DD 66 03     	LD H,(IX+3)
 163+ 5B8F DD 5E 04     	LD E,(IX+4)
 164+ 5B92 DD 56 05     	LD D,(IX+5)
 165+ 5B95 DD 4E 06     	LD C,(IX+6)
 166+ 5B98 DD 46 07     	LD B,(IX+7)
 167+ 5B9B CD A3 5B     	CALL VRAM_LDIRVM
 168+ 5B9E D1               POP DE
 169+ 5B9F C1               POP BC
 170+ 5BA0 C3 06 67         JP RESTORE_PAGE_INFO
 171+ 5BA3              ; *******************************************************************************************************
 172+ 5BA3               ENDIF
 173+ 5BA3
 174+ 5BA3               IF (BASIC_EXTENSION + DEFUSR_EXTENSION > 0)
 175+ 5BA3              ; *******************************************************************************************************
 176+ 5BA3              ; common code to copy from memory to VRAM
 177+ 5BA3              ; input HL=RAM source
 178+ 5BA3              ; input DE=VRAM destination
 179+ 5BA3              ; BC=count
 180+ 5BA3              VRAM_LDIRVM:
 181+ 5BA3 3E 01        	LD A,1
 182+ 5BA5 32 DF 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 183+ 5BA8 EB           	EX DE, HL
 184+ 5BA9 F3           	DI
 185+ 5BAA CD B6 66     	CALL SETWRT_LOCAL
 186+ 5BAD FB           	EI
 187+ 5BAE EB           	EX DE, HL
 188+ 5BAF 78           	LD A, B
 189+ 5BB0 B7           	OR A
 190+ 5BB1 28 0D        	JR Z, .L3
 191+ 5BB3 C5           	PUSH BC
 192+ 5BB4 0E 98        	LD C, #98
 193+ 5BB6              .L2:
 194+ 5BB6 50           	LD D, B
 195+ 5BB7 06 00        	LD B, 0
 196+ 5BB9 CD C3 66     	CALL BBYTECOPY_NO_C
 197+ 5BBC 42           	LD B, D
 198+ 5BBD 10 F7        	DJNZ .L2
 199+ 5BBF C1           	POP BC
 200+ 5BC0              .L3:
 201+ 5BC0 79           	LD A, C
 202+ 5BC1 B7           	OR A
 203+ 5BC2 28 04        	JR Z,.L4
 204+ 5BC4 41           	LD B, C
 205+ 5BC5 CD C1 66     	CALL BBYTECOPY
 206+ 5BC8              .L4:
 207+ 5BC8 AF           	XOR A
 208+ 5BC9 32 DF 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 209+ 5BCC C9           	RET
 210+ 5BCD              ; *******************************************************************************************************
 211+ 5BCD               ENDIF
 212+ 5BCD
 213+ 5BCD              ; *******************************************************************************************************
 214+ 5BCD              ; function to handle CALL VRMMEM basic extension
 215+ 5BCD              ; copies from RAM to VRAM
 216+ 5BCD              ; _VRMMEM ( INT source,
 217+ 5BCD              ;			INT destination,
 218+ 5BCD              ;			INT count
 219+ 5BCD              ; will put ram in page 0 also, page 1 is already there
 220+ 5BCD              VRMMEM:
 221+ 5BCD              	; opening (
 222+ 5BCD CD DD 67     	CALL CHKCHAR
 223+ 5BD0 28           	DB '('
 224+ 5BD1              	; get source address
 225+ 5BD1 DD 21 2F 54  	LD IX, FRMQNT
 226+ 5BD5 CD 59 01     	CALL CALBAS
 227+ 5BD8 D5           	PUSH DE
 228+ 5BD9              	; comma
 229+ 5BD9 CD DD 67     	CALL CHKCHAR
 230+ 5BDC 2C           	DB ','
 231+ 5BDD              	; get destination address
 232+ 5BDD DD 21 2F 54  	LD IX, FRMQNT
 233+ 5BE1 CD 59 01     	CALL CALBAS
 234+ 5BE4 D5           	PUSH DE
 235+ 5BE5              	; comma
 236+ 5BE5 CD DD 67     	CALL CHKCHAR
 237+ 5BE8 2C           	DB ','
 238+ 5BE9              	; get length
 239+ 5BE9 DD 21 2F 54  	LD IX, FRMQNT
 240+ 5BED CD 59 01     	CALL CALBAS
 241+ 5BF0 D5           	PUSH DE
 242+ 5BF1              	; ending )
 243+ 5BF1 CD DD 67     	CALL CHKCHAR
 244+ 5BF4 29           	DB ')'
 245+ 5BF5
 246+ 5BF5                  ; save position in BASIC text
 247+ 5BF5 E5           	PUSH HL
 248+ 5BF6 DD E1        	POP IX
 249+ 5BF8
 250+ 5BF8 C1           	POP BC ; count
 251+ 5BF9 D1           	POP DE ; destination
 252+ 5BFA E1           	POP HL ; source
 253+ 5BFB D9           	EXX
 254+ 5BFC FD 21 04 5C  	LD IY, .RET
 255+ 5C00 F3           	DI
 256+ 5C01 C3 8F 67     	JP ENABLE_PAGE0
 257+ 5C04              .RET:
 258+ 5C04 FB           	EI
 259+ 5C05 D9           	EXX
 260+ 5C06 3E 01        	LD A,1
 261+ 5C08 32 DF 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 262+ 5C0B CD 1B 5C     	CALL .LDIRMV
 263+ 5C0E AF           	XOR A
 264+ 5C0F 32 DF 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 265+ 5C12 D1               POP DE
 266+ 5C13 C1               POP BC
 267+ 5C14 CD 06 67         CALL RESTORE_PAGE_INFO
 268+ 5C17 DD E5        	PUSH IX
 269+ 5C19 E1           	POP HL
 270+ 5C1A C9           	RET
 271+ 5C1B
 272+ 5C1B              .LDIRMV:
 273+ 5C1B              	; set VRAM address *exactly* as in ROM, otherwise corruption
 274+ 5C1B 7D           	LD	A, L
 275+ 5C1C F3           	DI
 276+ 5C1D D3 99        	OUT	(099H), A
 277+ 5C1F 7C           	LD	A, H
 278+ 5C20 E6 3F        	AND	03FH
 279+ 5C22 D3 99        	OUT	(099H), A
 280+ 5C24 FB           	EI
 281+ 5C25              	;EX (SP), HL
 282+ 5C25              	;EX (SP), HL
 283+ 5C25              	;NOP
 284+ 5C25              	;NOP
 285+ 5C25              .L4:
 286+ 5C25 DB 98            IN A, (#98)
 287+ 5C27 12           	LD (DE), A
 288+ 5C28 13               INC DE
 289+ 5C29 0B               DEC BC
 290+ 5C2A 79               LD A, C
 291+ 5C2B B0               OR B
 292+ 5C2C 20 F7            JR NZ, .L4
 293+ 5C2E C9               RET
 294+ 5C2F              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
 147  5C2F               ENDIF
 148  5C2F
 149  5C2F               IF (GENCAL_CMD == 1)
 150  5C2F               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
   1+ 5C2F              ; *******************************************************************************************************
   2+ 5C2F              ; function to handle CALL GENCAL basic extension
   3+ 5C2F              ; GENCAL ( INT fn_addr, = address of the function to call
   4+ 5C2F              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
   5+ 5C2F              ; output values of registers will also be stored at reg_list_ptr
   6+ 5C2F              GENCAL:
   7+ 5C2F              	; opening (
   8+ 5C2F CD DD 67     	CALL CHKCHAR
   9+ 5C32 28           	DB '('
  10+ 5C33              	; get function address
  11+ 5C33 DD 21 2F 54  	LD IX, FRMQNT
  12+ 5C37 CD 59 01     	CALL CALBAS
  13+ 5C3A D5           	PUSH DE
  14+ 5C3B              	; comma
  15+ 5C3B CD DD 67     	CALL CHKCHAR
  16+ 5C3E 2C           	DB ','
  17+ 5C3F              	; get pointer to register list
  18+ 5C3F 3E 02            LD A,2
  19+ 5C41 06 01            LD B,1
  20+ 5C43 11 00 05         LD DE,#0500
  21+ 5C46 CD 0A 68         CALL GET_BASIC_ARRAY_DATA_POINTER
  22+ 5C49 C5           	PUSH BC
  23+ 5C4A              	; ending )
  24+ 5C4A CD DD 67     	CALL CHKCHAR
  25+ 5C4D 29           	DB ')'
  26+ 5C4E
  27+ 5C4E              	; save BASIC token position
  28+ 5C4E E5           	PUSH HL
  29+ 5C4F D9               EXX
  30+ 5C50 E1           	POP HL ; HL'=next basic token
  31+ 5C51 D9               EXX
  32+ 5C52
  33+ 5C52 E1               POP HL ; get pointer to register values
  34+ 5C53 F3           	DI
  35+ 5C54 ED 73 CE 64      LD (BLIT_STRUCT), SP
  36+ 5C58 F9               LD SP, HL
  37+ 5C59 F1               POP AF
  38+ 5C5A C1               POP BC
  39+ 5C5B D1               POP DE
  40+ 5C5C E1               POP HL
  41+ 5C5D DD E1            POP IX
  42+ 5C5F FD E1            POP IY
  43+ 5C61 D9               EXX
  44+ 5C62 ED 73 D0 64      LD (BLIT_STRUCT+2), SP
  45+ 5C66 ED 7B CE 64      LD SP, (BLIT_STRUCT)
  46+ 5C6A FB               EI
  47+ 5C6B D1               POP DE ; get function to call
  48+ 5C6C E5               PUSH HL
  49+ 5C6D CD 88 5C         CALL .EXXDECALL
  50+ 5C70 F3               DI
  51+ 5C71 ED 73 CE 64      LD (BLIT_STRUCT), SP
  52+ 5C75 ED 7B D0 64      LD SP, (BLIT_STRUCT+2)
  53+ 5C79 FD E5            PUSH IY
  54+ 5C7B DD E5            PUSH IX
  55+ 5C7D E5               PUSH HL
  56+ 5C7E D5               PUSH DE
  57+ 5C7F C5               PUSH BC
  58+ 5C80 F5               PUSH AF
  59+ 5C81 ED 7B CE 64      LD SP, (BLIT_STRUCT)
  60+ 5C85 FB               EI
  61+ 5C86 E1               POP HL
  62+ 5C87 C9           	RET
  63+ 5C88
  64+ 5C88              .EXXDECALL:
  65+ 5C88 D5               PUSH DE
  66+ 5C89 D9               EXX
  67+ 5C8A C9               RET
  68+ 5C8B              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
 151  5C8B               ENDIF
 152  5C8B
 153  5C8B               IF (BOX_CMDS == 1)
 154  5C8B               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
   1+ 5C8B              ; *******************************************************************************************************
   2+ 5C8B              ; generic function to implement rectangle data copy
   3+ 5C8B              ; should be modified to call appropriate function for memory or vram
   4+ 5C8B              ; input IX=pointer to following structure
   5+ 5C8B              ; +00 source data pointer
   6+ 5C8B              ; +02 num bytes in a row
   7+ 5C8B              ; +04 number of rows
   8+ 5C8B              ; +06 source add-to value till next row
   9+ 5C8B              ; +08 destination address
  10+ 5C8B              ; +10 destination add-to value till next row
  11+ 5C8B              ; modifies AF, BC, DE, HL
  12+ 5C8B              RECTANGLE_COPY:
  13+ 5C8B DD 6E 00     	LD L, (IX+0)
  14+ 5C8E DD 66 01     	LD H, (IX+1) ; source address
  15+ 5C91 DD 5E 08     	LD E, (IX+8)
  16+ 5C94 DD 56 09     	LD D, (IX+9) ; destination
  17+ 5C97 DD 46 04     	LD B, (IX+4) ; row number
  18+ 5C9A              .L1:
  19+ 5C9A C5           	PUSH BC
  20+ 5C9B E5           		PUSH HL
  21+ 5C9C D5           			PUSH DE
  22+ 5C9D DD 4E 02     				LD C, (IX+2)
  23+ 5CA0 DD 46 03     				LD B, (IX+3) ; num bytes in a row
  24+ 5CA3              .CALL1:
  25+ 5CA3 CD 00 00     				CALL 0 ; set destination address from DE
  26+ 5CA6              .CALL2:
  27+ 5CA6 CD 00 00     				CALL 0 ; copy data fn
  28+ 5CA9 E1           			POP HL
  29+ 5CAA DD 4E 0A     			LD C, (IX+10)
  30+ 5CAD DD 46 0B     			LD B, (IX+11) ; destination add-to
  31+ 5CB0 09           			ADD HL, BC
  32+ 5CB1 EB           			EX DE, HL
  33+ 5CB2 E1           		POP HL
  34+ 5CB3 DD 4E 06     		LD C, (IX+6)
  35+ 5CB6 DD 46 07     		LD B, (IX+7) ; src add-to
  36+ 5CB9 09           		ADD HL, BC
  37+ 5CBA C1           	POP BC
  38+ 5CBB 10 DD        	DJNZ .L1
  39+ 5CBD C9           	RET
  40+ 5CBE              ; *******************************************************************************************************
  41+ 5CBE
  42+ 5CBE               IF (BASIC_EXTENSION == 1)
  43+ 5CBE              ; *******************************************************************************************************
  44+ 5CBE              ; function to handle CALL BOXMEMCPY basic extension
  45+ 5CBE              ; copies data with window like boundaries within ram
  46+ 5CBE              ; BOXMEMCPY ( INT source data pointer,
  47+ 5CBE              ;			  INT source number of bytes in a row,
  48+ 5CBE              ;			  INT number of rows,
  49+ 5CBE              ;			  INT source add-to value till next row,
  50+ 5CBE              ; 			  INT destination pointer,
  51+ 5CBE              ;			  INT destination add-to value till next row )
  52+ 5CBE              ; request_data_ptr described in RECTANGLE_COPY
  53+ 5CBE              ; will put ram in page 0 also, page 1 is already there
  54+ 5CBE              BOXMEMCPY:
  55+ 5CBE 11 D5 5C     	LD DE,BOXMEMCPY_COMMON
  56+ 5CC1 ED 53 4E 5D  	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
  57+ 5CC5 C3 E8 5C     	JP BOX_EXTENSION_PARAMS_COMMON
  58+ 5CC8               ENDIF
  59+ 5CC8
  60+ 5CC8               IF (DEFUSR_EXTENSION == 1)
  61+ 5CC8              ; *******************************************************************************************************
  62+ 5CC8              ; same as BOXMEMCPY but for DEFUSR approach
  63+ 5CC8              ; input IX=pointer to input array, real data from +2
  64+ 5CC8              ; +02 = source data pointer
  65+ 5CC8              ; +04 = source number of bytes in a row
  66+ 5CC8              ; +06 = number of rows
  67+ 5CC8              ; +08 = source add-to value till next row
  68+ 5CC8              ; +10 = destination pointer
  69+ 5CC8              ; +12 = destination add-to value till next row
  70+ 5CC8              BOXMEMCPY_DEFUSR:
  71+ 5CC8 21 D5 5C     	LD HL,BOXMEMCPY_COMMON
  72+ 5CCB 22 4E 5D     	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
  73+ 5CCE DD 23        	INC IX
  74+ 5CD0 DD 23        	INC IX
  75+ 5CD2 C3 4A 5D     	JP BOXCOMMON_DEFUSR
  76+ 5CD5               ENDIF
  77+ 5CD5
  78+ 5CD5              BOXMEMCPY_COMMON:
  79+ 5CD5 FB           	EI
  80+ 5CD6              	; set RAM functions to call
  81+ 5CD6 21 00 00     	LD HL, 0
  82+ 5CD9 22 A3 5C     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
  83+ 5CDC 22 A5 5C     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
  84+ 5CDF 21 ED B0     	LD HL, #B0ED ; LDIR
  85+ 5CE2 22 A7 5C     	LD (RECTANGLE_COPY.CALL1+4), HL
  86+ 5CE5 C3 53 5D     	JP BOXCOMMON_DEFUSR.CALL
  87+ 5CE8              ; *******************************************************************************************************
  88+ 5CE8
  89+ 5CE8               IF (BASIC_EXTENSION == 1)
  90+ 5CE8              ; *******************************************************************************************************
  91+ 5CE8              ; common parts of BOX commands to load parameters
  92+ 5CE8              BOX_EXTENSION_PARAMS_COMMON:
  93+ 5CE8              	; opening (
  94+ 5CE8 CD DD 67     	CALL CHKCHAR
  95+ 5CEB 28           	DB '('
  96+ 5CEC              	; get source data pointer
  97+ 5CEC DD 21 2F 54  	LD IX, FRMQNT
  98+ 5CF0 CD 59 01     	CALL CALBAS
  99+ 5CF3 ED 53 CE 64  	LD (BLIT_STRUCT+0), DE
 100+ 5CF7              	; comma
 101+ 5CF7 CD DD 67     	CALL CHKCHAR
 102+ 5CFA 2C           	DB ','
 103+ 5CFB              	; source number of bytes in a row
 104+ 5CFB DD 21 2F 54  	LD IX, FRMQNT
 105+ 5CFF CD 59 01     	CALL CALBAS
 106+ 5D02 ED 53 D0 64  	LD (BLIT_STRUCT+2), DE
 107+ 5D06              	; comma
 108+ 5D06 CD DD 67     	CALL CHKCHAR
 109+ 5D09 2C           	DB ','
 110+ 5D0A              	; number of rows
 111+ 5D0A DD 21 2F 54  	LD IX, FRMQNT
 112+ 5D0E CD 59 01     	CALL CALBAS
 113+ 5D11 ED 53 D2 64  	LD (BLIT_STRUCT+4), DE
 114+ 5D15              	; comma
 115+ 5D15 CD DD 67     	CALL CHKCHAR
 116+ 5D18 2C           	DB ','
 117+ 5D19              	; source add-to value till next row
 118+ 5D19 DD 21 2F 54  	LD IX, FRMQNT
 119+ 5D1D CD 59 01     	CALL CALBAS
 120+ 5D20 ED 53 D4 64  	LD (BLIT_STRUCT+6), DE
 121+ 5D24              	; comma
 122+ 5D24 CD DD 67     	CALL CHKCHAR
 123+ 5D27 2C           	DB ','
 124+ 5D28              	; destination pointer
 125+ 5D28 DD 21 2F 54  	LD IX, FRMQNT
 126+ 5D2C CD 59 01     	CALL CALBAS
 127+ 5D2F ED 53 D6 64  	LD (BLIT_STRUCT+8), DE
 128+ 5D33              	; comma
 129+ 5D33 CD DD 67     	CALL CHKCHAR
 130+ 5D36 2C           	DB ','
 131+ 5D37              	; destination add-to value till next row
 132+ 5D37 DD 21 2F 54  	LD IX, FRMQNT
 133+ 5D3B CD 59 01     	CALL CALBAS
 134+ 5D3E ED 53 D8 64  	LD (BLIT_STRUCT+10), DE
 135+ 5D42              	; ending )
 136+ 5D42 CD DD 67     	CALL CHKCHAR
 137+ 5D45 29           	DB ')'
 138+ 5D46 DD 21 CE 64  	LD IX,BLIT_STRUCT
 139+ 5D4A               ENDIF
 140+ 5D4A              BOXCOMMON_DEFUSR:
 141+ 5D4A E5           	PUSH HL ; save position in BASIC buffer
 142+ 5D4B F3           	DI
 143+ 5D4C              .ADDR:
 144+ 5D4C FD 21 00 00  	LD IY, 0 ; modified by code
 145+ 5D50 C3 8F 67     	JP ENABLE_PAGE0
 146+ 5D53              .CALL:
 147+ 5D53 CD 8B 5C     	CALL RECTANGLE_COPY
 148+ 5D56 AF           	XOR A
 149+ 5D57 32 DF 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 150+ 5D5A
 151+ 5D5A D1               POP DE
 152+ 5D5B C1               POP BC
 153+ 5D5C CD 06 67         CALL RESTORE_PAGE_INFO
 154+ 5D5F
 155+ 5D5F E1           	POP HL
 156+ 5D60 C9           	RET
 157+ 5D61              ; *******************************************************************************************************
 158+ 5D61
 159+ 5D61               IF (BASIC_EXTENSION == 1)
 160+ 5D61              ; *******************************************************************************************************
 161+ 5D61              ; function to handle CALL BOXMEMVRM basic extension
 162+ 5D61              ; copies data with window like boundaries from ram to Vram
 163+ 5D61              ; BOXMEMVRM ( INT source data pointer,
 164+ 5D61              ;			  INT source number of bytes in a row,
 165+ 5D61              ;			  INT number of rows,
 166+ 5D61              ;			  INT source add-to value till next row,
 167+ 5D61              ; 			  INT destination pointer,
 168+ 5D61              ;			  INT destination add-to value till next row )
 169+ 5D61              ; request_data_ptr described in RECTANGLE_COPY
 170+ 5D61              ; will put ram in page 0 also, page 1 is already there
 171+ 5D61              BOXMEMVRM:
 172+ 5D61 11 78 5D     	LD DE,BOXMEMVRM_COMMON
 173+ 5D64 ED 53 4E 5D  	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
 174+ 5D68 C3 E8 5C     	JP BOX_EXTENSION_PARAMS_COMMON
 175+ 5D6B               ENDIF
 176+ 5D6B
 177+ 5D6B               IF (DEFUSR_EXTENSION == 1)
 178+ 5D6B              ; *******************************************************************************************************
 179+ 5D6B              ; same as BOXMEMVRM but for DEFUSR approach
 180+ 5D6B              ; input IX=pointer to input array, real data from +2
 181+ 5D6B              ; +02 = source data pointer
 182+ 5D6B              ; +04 = source number of bytes in a row
 183+ 5D6B              ; +06 = number of rows
 184+ 5D6B              ; +08 = source add-to value till next row
 185+ 5D6B              ; +10 = destination pointer
 186+ 5D6B              ; +12 = destination add-to value till next row
 187+ 5D6B              BOXMEMVRM_DEFUSR:
 188+ 5D6B 21 78 5D     	LD HL,BOXMEMVRM_COMMON
 189+ 5D6E 22 4E 5D     	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
 190+ 5D71 DD 23        	INC IX
 191+ 5D73 DD 23        	INC IX
 192+ 5D75 C3 4A 5D     	JP BOXCOMMON_DEFUSR
 193+ 5D78               ENDIF
 194+ 5D78
 195+ 5D78              BOXMEMVRM_COMMON:
 196+ 5D78 FB           	EI
 197+ 5D79              	; set RAM functions to call
 198+ 5D79 21 93 5D     	LD HL, .SETDEST
 199+ 5D7C 22 A4 5C     	LD (RECTANGLE_COPY.CALL1+1), HL
 200+ 5D7F 21 9B 5D     	LD HL, .COPYDATA
 201+ 5D82 22 A7 5C     	LD (RECTANGLE_COPY.CALL2+1), HL
 202+ 5D85 3E CD        	LD A, #CD ; CALL
 203+ 5D87 32 A3 5C     	LD (RECTANGLE_COPY.CALL1), A
 204+ 5D8A 32 A6 5C     	LD (RECTANGLE_COPY.CALL2), A
 205+ 5D8D              	;LD A,1
 206+ 5D8D 32 DF 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 207+ 5D90 C3 53 5D     	JP BOXCOMMON_DEFUSR.CALL
 208+ 5D93              .SETDEST:
 209+ 5D93 EB           	EX DE, HL
 210+ 5D94 F3           	DI
 211+ 5D95 CD B6 66     	CALL SETWRT_LOCAL
 212+ 5D98 FB           	EI
 213+ 5D99 EB           	EX DE, HL
 214+ 5D9A C9           	RET
 215+ 5D9B              .COPYDATA:
 216+ 5D9B 41           	LD B, C
 217+ 5D9C C3 C1 66     	JP BBYTECOPY
 218+ 5D9F              ; *******************************************************************************************************
# file closed: asm\BOX.asm
 155  5D9F               ENDIF
 156  5D9F
 157  5D9F               IF (BLIT_CMDS == 1)
 158  5D9F               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
   1+ 5D9F              ; *******************************************************************************************************
   2+ 5D9F              ; function rotates mask and data of several characters and applies to background data
   3+ 5D9F              ; this handles x-shift from 0 to 4
   4+ 5D9F              ; contains self-modifying code that is set-up from external function
   5+ 5D9F              ; input HL=pointer to mask data
   6+ 5D9F              ; input HL'=pointer to character data
   7+ 5D9F              ; input DE=output buffer containing background data
   8+ 5D9F              ; input BC=DE+8
   9+ 5D9F              ; input A=number of characters to process
  10+ 5D9F              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  11+ 5D9F              SHIFT04:
  12+ 5D9F 08           	EX AF, AF'
  13+ 5DA0 7E           	LD A, (HL) ; get mask
  14+ 5DA1 D9           	EXX
  15+ 5DA2 57           	LD D, A
  16+ 5DA3 1E FF        	LD E, #FF
  17+ 5DA5 37           	SCF
  18+ 5DA6              .M1:
  19+ 5DA6 18 FE        	JR .M1 ; this is self-modifying part
  20+ 5DA8 CB 1A        	RR D
  21+ 5DAA CB 1B        	RR E
  22+ 5DAC CB 1A        	RR D
  23+ 5DAE CB 1B        	RR E
  24+ 5DB0 CB 1A        	RR D
  25+ 5DB2 CB 1B        	RR E
  26+ 5DB4 CB 1A        	RR D
  27+ 5DB6 CB 1B        	RR E
  28+ 5DB8
  29+ 5DB8 46           	LD B, (HL) ; get data
  30+ 5DB9 0E 00        	LD C, 0
  31+ 5DBB              .M2:
  32+ 5DBB 18 FE        	JR .M2 ; also self-modifying part
  33+ 5DBD CB 38        	SRL B
  34+ 5DBF CB 19        	RR C
  35+ 5DC1 CB 38        	SRL B
  36+ 5DC3 CB 19        	RR C
  37+ 5DC5 CB 38        	SRL B
  38+ 5DC7 CB 19        	RR C
  39+ 5DC9 CB 38        	SRL B
  40+ 5DCB CB 19        	RR C
  41+ 5DCD
  42+ 5DCD D9           	EXX
  43+ 5DCE 1A           	LD A, (DE) ; background
  44+ 5DCF D9           	EXX
  45+ 5DD0 A2           	AND D
  46+ 5DD1 B0           	OR B
  47+ 5DD2 D9           	EXX
  48+ 5DD3 12           	LD (DE), A
  49+ 5DD4
  50+ 5DD4 0A           	LD A, (BC)
  51+ 5DD5 D9           	EXX
  52+ 5DD6 A3           	AND E
  53+ 5DD7 B1           	OR C
  54+ 5DD8 23           	INC HL
  55+ 5DD9 D9           	EXX
  56+ 5DDA 02           	LD (BC), A
  57+ 5DDB
  58+ 5DDB 23           	INC HL
  59+ 5DDC 13           	INC DE
  60+ 5DDD 03           	INC BC
  61+ 5DDE
  62+ 5DDE 08           	EX AF, AF'
  63+ 5DDF 3D           	DEC A
  64+ 5DE0 C2 9F 5D     	JP NZ, SHIFT04
  65+ 5DE3 C9           	RET
  66+ 5DE4              ; *******************************************************************************************************
  67+ 5DE4
  68+ 5DE4              ; *******************************************************************************************************
  69+ 5DE4              ; function rotates mask and data of several characters and applies to background data
  70+ 5DE4              ; this handles x-shift from 5 to 8
  71+ 5DE4              ; contains self-modifying code that is set-up from external function
  72+ 5DE4              ; input HL=pointer to mask data
  73+ 5DE4              ; input HL'=pointer to character data
  74+ 5DE4              ; input DE=output buffer containing background data
  75+ 5DE4              ; input BC=DE+8
  76+ 5DE4              ; input A=number of characters to process
  77+ 5DE4              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  78+ 5DE4              SHIFT58:
  79+ 5DE4 08           	EX AF, AF'
  80+ 5DE5 7E           	LD A, (HL) ; get mask
  81+ 5DE6 D9           	EXX
  82+ 5DE7 57           	LD D, A
  83+ 5DE8 1E FF        	LD E, #FF
  84+ 5DEA 37           	SCF
  85+ 5DEB              .M1:
  86+ 5DEB 18 FE        	JR .M1 ; this is self-modifying part
  87+ 5DED CB 12        	RL D
  88+ 5DEF CB 13        	RL E
  89+ 5DF1 CB 12        	RL D
  90+ 5DF3 CB 13        	RL E
  91+ 5DF5 CB 12        	RL D
  92+ 5DF7 CB 13        	RL E
  93+ 5DF9
  94+ 5DF9 46           	LD B, (HL)
  95+ 5DFA 0E 00        	LD C, 0
  96+ 5DFC              .M2:
  97+ 5DFC 18 FE        	JR .M2 ; also self-modifying part
  98+ 5DFE CB 20        	SLA B
  99+ 5E00 CB 11        	RL C
 100+ 5E02 CB 20        	SLA B
 101+ 5E04 CB 11        	RL C
 102+ 5E06 CB 20        	SLA B
 103+ 5E08 CB 11        	RL C
 104+ 5E0A
 105+ 5E0A D9           	EXX
 106+ 5E0B 1A           	LD A, (DE) ; background
 107+ 5E0C D9           	EXX
 108+ 5E0D A3           	AND E
 109+ 5E0E B1           	OR C
 110+ 5E0F D9           	EXX
 111+ 5E10 12           	LD (DE), A
 112+ 5E11
 113+ 5E11 0A           	LD A, (BC)
 114+ 5E12 D9           	EXX
 115+ 5E13 A2           	AND D
 116+ 5E14 B0           	OR B
 117+ 5E15 23           	INC HL
 118+ 5E16 D9           	EXX
 119+ 5E17 02           	LD (BC), A
 120+ 5E18
 121+ 5E18 23           	INC HL
 122+ 5E19 13           	INC DE
 123+ 5E1A 03           	INC BC
 124+ 5E1B
 125+ 5E1B 08           	EX AF, AF'
 126+ 5E1C 3D           	DEC A
 127+ 5E1D C2 E4 5D     	JP NZ, SHIFT58
 128+ 5E20 C9           	RET
 129+ 5E21              ; *******************************************************************************************************
 130+ 5E21
 131+ 5E21              ; *******************************************************************************************************
 132+ 5E21              ; routine that shifts one row of characters
 133+ 5E21              ; contains self-modifying code that is set-up from external function
 134+ 5E21              ; input HL=pointer to mask data
 135+ 5E21              ; input HL'=pointer to character data
 136+ 5E21              ; input DE=output buffer containing background data
 137+ 5E21              ; input A=number of characters to process
 138+ 5E21              ; input IX=pointer to structure describing input data
 139+ 5E21              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 140+ 5E21              SHIFT_ROW:
 141+ 5E21 F5           	PUSH AF
 142+ 5E22 ED 53 CA 64  		LD (BLIT_TMP1), DE
 143+ 5E26 E5           		PUSH HL
 144+ 5E27 CD 6A 5E     			CALL .ADDYSHIFT
 145+ 5E2A E1           		POP HL
 146+ 5E2B ED 53 CC 64  		LD (BLIT_TMP2), DE ; DE+vertical shift
 147+ 5E2F              .L1:
 148+ 5E2F 3E 08        		LD A, 8
 149+ 5E31 DD 96 02     		SUB (IX+2) ; y shift
 150+ 5E34              .CALL1:
 151+ 5E34 CD 00 00     		CALL 0
 152+ 5E37 DD 7E 02     		LD A, (IX+2); y shift
 153+ 5E3A B7           		OR A
 154+ 5E3B 28 26        		JR Z, .DONE
 155+ 5E3D ED 5B CA 64  		LD DE, (BLIT_TMP1)
 156+ 5E41 E5           		PUSH HL
 157+ 5E42 CD 78 5E     			CALL .DETONEXTROW
 158+ 5E45 E1           		POP HL
 159+ 5E46              .CALL2:
 160+ 5E46 CD 00 00     		CALL 0
 161+ 5E49 ED 5B CA 64  		LD DE, (BLIT_TMP1)
 162+ 5E4D E5           		PUSH HL
 163+ 5E4E CD 72 5E     			CALL .ADD8
 164+ 5E51 E1           		POP HL
 165+ 5E52 ED 53 CA 64  		LD (BLIT_TMP1), DE
 166+ 5E56 ED 5B CC 64  		LD DE, (BLIT_TMP2)
 167+ 5E5A E5           		PUSH HL
 168+ 5E5B CD 72 5E     			CALL .ADD8
 169+ 5E5E E1           		POP HL
 170+ 5E5F ED 53 CC 64  		LD (BLIT_TMP2), DE ; DE+vertical shift
 171+ 5E63              .DONE:
 172+ 5E63 F1           	POP AF
 173+ 5E64 3D           	DEC A
 174+ 5E65 C8           	RET Z
 175+ 5E66 F5           	PUSH AF
 176+ 5E67 C3 2F 5E     	JP .L1
 177+ 5E6A              .ADDYSHIFT:
 178+ 5E6A EB           	EX DE, HL
 179+ 5E6B 16 00        	LD D, 0
 180+ 5E6D DD 5E 02     	LD E, (IX+2); y shift
 181+ 5E70 18 0C        	JR .MOVDEBC
 182+ 5E72              .ADD8:
 183+ 5E72 21 08 00     	LD HL, 8
 184+ 5E75 C3 7E 5E     	JP .MOVDEBC
 185+ 5E78              .DETONEXTROW:
 186+ 5E78 DD 6E 06     	LD L, (IX+6)
 187+ 5E7B DD 66 07     	LD H, (IX+7) ; bkg add to value
 188+ 5E7E              .MOVDEBC:
 189+ 5E7E 19           	ADD HL, DE
 190+ 5E7F 54           	LD D, H
 191+ 5E80 5D           	LD E, L
 192+ 5E81 01 08 00     	LD BC, 8
 193+ 5E84 09           	ADD HL, BC
 194+ 5E85 44           	LD B, H
 195+ 5E86 4D           	LD C, L
 196+ 5E87 C9           	RET
 197+ 5E88              ; *******************************************************************************************************
 198+ 5E88
 199+ 5E88              ; *******************************************************************************************************
 200+ 5E88              ; function rotates mask and character data and applies it to background
 201+ 5E88              ; input IX=pointer to structure describing input data
 202+ 5E88              ; +0  DW horizontal shift count 0-7 (low byte used)
 203+ 5E88              ; +2  DW vertical shift count 0-7 (low byte used)
 204+ 5E88              ; +4  DW background data start;
 205+ 5E88              ; +6  DW background add to value to next row of background data
 206+ 5E88              ; +8  DW mask data start;
 207+ 5E88              ; +10  DW character data start;
 208+ 5E88              ; +12 DW character&mask add to value to next row of data
 209+ 5E88              ; +14 DW columns (low byte used)
 210+ 5E88              ; +16 DW rows (low byte used)
 211+ 5E88              SHIFT_MERGE_CHARACTER:
 212+ 5E88 DD 7E 00     	LD A, (IX) ; shift
 213+ 5E8B FE 05        	CP 5
 214+ 5E8D 38 25        	JR C, .RIGHT
 215+ 5E8F              	; shifts 5-7, use rotate towards left 1-3
 216+ 5E8F 21 E4 5D     	LD HL, SHIFT58
 217+ 5E92 22 35 5E     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 218+ 5E95 22 47 5E     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 219+ 5E98 D6 05        	SUB 5
 220+ 5E9A 28 0D        	JR Z, .L1
 221+ 5E9C 87           	ADD A, A
 222+ 5E9D 87           	ADD A, A
 223+ 5E9E 67           	LD H, A
 224+ 5E9F 2E 18        	LD L, #18 ; JR opcode
 225+ 5EA1 22 EB 5D     	LD (SHIFT58.M1), HL
 226+ 5EA4 22 FC 5D     	LD (SHIFT58.M2), HL
 227+ 5EA7 18 32        	JR .DO
 228+ 5EA9              .L1:
 229+ 5EA9 21 00 00     	LD HL, 0 ; 2xNOP opcode
 230+ 5EAC 22 EB 5D     	LD (SHIFT58.M1), HL
 231+ 5EAF 22 FC 5D     	LD (SHIFT58.M2), HL
 232+ 5EB2 18 27        	JR .DO
 233+ 5EB4              .RIGHT:
 234+ 5EB4              	; shifts 0-4, rotate towards right
 235+ 5EB4 21 9F 5D     	LD HL, SHIFT04
 236+ 5EB7 22 35 5E     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 237+ 5EBA 22 47 5E     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 238+ 5EBD FE 04        	CP 4
 239+ 5EBF 28 11        	JR Z, .R1
 240+ 5EC1 D6 04        	SUB 4
 241+ 5EC3 ED 44        	NEG
 242+ 5EC5 87           	ADD A, A
 243+ 5EC6 87           	ADD A, A
 244+ 5EC7 67           	LD H, A
 245+ 5EC8 2E 18        	LD L, #18 ; JR opcode
 246+ 5ECA 22 A6 5D     	LD (SHIFT04.M1), HL
 247+ 5ECD 22 BB 5D     	LD (SHIFT04.M2), HL
 248+ 5ED0 18 09        	JR .DO
 249+ 5ED2              .R1:
 250+ 5ED2 21 00 00     	LD HL, 0 ; 2xNOP opcode
 251+ 5ED5 22 A6 5D     	LD (SHIFT04.M1), HL
 252+ 5ED8 22 BB 5D     	LD (SHIFT04.M2), HL
 253+ 5EDB              .DO:
 254+ 5EDB DD 46 10     	LD B, (IX+16) ; rows
 255+ 5EDE DD 6E 08     	LD L, (IX+8)
 256+ 5EE1 DD 66 09     	LD H, (IX+9) ; mask data
 257+ 5EE4 DD 5E 04     	LD E, (IX+4)
 258+ 5EE7 DD 56 05     	LD D, (IX+5) ; background data
 259+ 5EEA D9           	EXX
 260+ 5EEB DD 6E 0A     	LD L, (IX+10)
 261+ 5EEE DD 66 0B     	LD H, (IX+11) ; character data
 262+ 5EF1 D9           	EXX
 263+ 5EF2              .LOOP:
 264+ 5EF2 C5           	PUSH BC
 265+ 5EF3 E5           		PUSH HL
 266+ 5EF4 D5           			PUSH DE
 267+ 5EF5 D9           				EXX
 268+ 5EF6 E5           				PUSH HL
 269+ 5EF7 D9           					EXX
 270+ 5EF8 DD 7E 0E     					LD A, (IX+14) ; columns
 271+ 5EFB              .CALL:
 272+ 5EFB CD 21 5E     					CALL SHIFT_ROW
 273+ 5EFE E1           				POP HL
 274+ 5EFF DD 5E 0C     				LD E, (IX+12)
 275+ 5F02 DD 56 0D     				LD D, (IX+13) ; char data to next row
 276+ 5F05 19           				ADD HL, DE
 277+ 5F06 D9           				EXX
 278+ 5F07 E1           			POP HL
 279+ 5F08 DD 5E 06     			LD E, (IX+6)
 280+ 5F0B DD 56 07     			LD D, (IX+7) ; background to next row
 281+ 5F0E 19           			ADD HL, DE
 282+ 5F0F EB           			EX DE, HL
 283+ 5F10 E1           		POP HL
 284+ 5F11 DD 4E 0C     		LD C, (IX+12)
 285+ 5F14 DD 46 0D     		LD B, (IX+13) ; char data to next row
 286+ 5F17 09           		ADD HL, BC
 287+ 5F18 C1           	POP BC
 288+ 5F19 10 D7        	DJNZ .LOOP
 289+ 5F1B C9           	RET
 290+ 5F1C              ; *******************************************************************************************************
 291+ 5F1C
 292+ 5F1C              ; *******************************************************************************************************
 293+ 5F1C              ; helper function DE \ 8
 294+ 5F1C              DEdiv8:
 295+ 5F1C 7B           	LD A,E
 296+ 5F1D CB 2A        	SRA D
 297+ 5F1F CB 1F            RR  A
 298+ 5F21 CB 2A            SRA D
 299+ 5F23 CB 1F            RR  A
 300+ 5F25 CB 2A            SRA D
 301+ 5F27 CB 1F            RR  A
 302+ 5F29 C9           	RET
 303+ 5F2A              ; *******************************************************************************************************
 304+ 5F2A
 305+ 5F2A               IF (DEFUSR_EXTENSION == 1)
 306+ 5F2A              ; *******************************************************************************************************
 307+ 5F2A              ; function to handle BLIT basic extension through DEFUSR call in RAW format
 308+ 5F2A              ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 309+ 5F2A              ; +2  DW horizontal shift count 0-7 (low byte used)
 310+ 5F2A              ; +4  DW vertical shift count 0-7 (low byte used)
 311+ 5F2A              ; +6  DW background data start;
 312+ 5F2A              ; +8  DW background add to value to next row of background data
 313+ 5F2A              ; +10  DW mask data start;
 314+ 5F2A              ; +12  DW character data start;
 315+ 5F2A              ; +14 DW character&mask add to value to next row of data
 316+ 5F2A              ; +16 DW columns (low byte used)
 317+ 5F2A              ; +18 DW rows (low byte used)
 318+ 5F2A              ; will put ram in page 0 also, page 1 is already there
 319+ 5F2A              ;BLIT_DEFUSR:
 320+ 5F2A              ;	DI
 321+ 5F2A              ;	LD IY, .RET
 322+ 5F2A              ;	JP ENABLE_PAGE0
 323+ 5F2A              ;.RET:
 324+ 5F2A              ;	EI
 325+ 5F2A              ;	INC IX
 326+ 5F2A              ;	INC IX
 327+ 5F2A              ;	CALL SHIFT_MERGE_CHARACTER
 328+ 5F2A              ;
 329+ 5F2A              ;   POP DE
 330+ 5F2A              ;    POP BC
 331+ 5F2A              ;    JP RESTORE_PAGE_INFO
 332+ 5F2A              ; *******************************************************************************************************
 333+ 5F2A
 334+ 5F2A              ; *******************************************************************************************************
 335+ 5F2A              ; function to handle CALL BLIT basic extension in DEFUSR form
 336+ 5F2A              ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 337+ 5F2A              ; +02 x
 338+ 5F2A              ; +04 y
 339+ 5F2A              ; +06 char_data_pointer
 340+ 5F2A              ; +08 mask_data_pointer
 341+ 5F2A              ; +10 width
 342+ 5F2A              ; +12 height
 343+ 5F2A              ; +14 background_pointer
 344+ 5F2A              ; +16 background_width
 345+ 5F2A              ; BLIT ( INT x,
 346+ 5F2A              ;		 INT y,
 347+ 5F2A              ;		 INT char_data_pointer,
 348+ 5F2A              ;		 INT mask_data_pointer,
 349+ 5F2A              ;		 INT width (in characters),
 350+ 5F2A              ;		 INT height (in characters),
 351+ 5F2A              ;		 INT background_pointer (top left),
 352+ 5F2A              ;		 INT background_width (in characters),
 353+ 5F2A              BLIT_DEFUSR:
 354+ 5F2A DD 5E 02     	LD E,(IX+2)
 355+ 5F2D DD 56 03     	LD D,(IX+3)
 356+ 5F30 7B           	LD A,E
 357+ 5F31 E6 07        	AND 7
 358+ 5F33 32 CE 64     	LD (BLIT_STRUCT+0),A
 359+ 5F36 CD 1C 5F     	CALL DEdiv8
 360+ 5F39 32 CA 64     	LD (BLIT_TMP+0),A
 361+ 5F3C DD 5E 04     	LD E,(IX+4)
 362+ 5F3F DD 56 05     	LD D,(IX+5)
 363+ 5F42 7B           	LD A,E
 364+ 5F43 E6 07        	AND 7
 365+ 5F45 32 D0 64     	LD (BLIT_STRUCT+2),A
 366+ 5F48 CD 1C 5F     	CALL DEdiv8
 367+ 5F4B 32 CB 64     	LD (BLIT_TMP+1),A
 368+ 5F4E DD 6E 06     	LD L,(IX+6)
 369+ 5F51 DD 66 07     	LD H,(IX+7)
 370+ 5F54 22 D8 64     	LD (BLIT_STRUCT+10),HL
 371+ 5F57 DD 6E 08     	LD L,(IX+8)
 372+ 5F5A DD 66 09     	LD H,(IX+9)
 373+ 5F5D 22 D6 64     	LD (BLIT_STRUCT+8),HL
 374+ 5F60 DD 7E 0A     	LD A,(IX+10)
 375+ 5F63 32 DC 64     	LD (BLIT_STRUCT+14),A
 376+ 5F66 DD 7E 0C     	LD A,(IX+12)
 377+ 5F69 32 DE 64     	LD (BLIT_STRUCT+16),A
 378+ 5F6C DD 6E 0E     	LD L,(IX+14)
 379+ 5F6F DD 66 0F     	LD H,(IX+15)
 380+ 5F72 22 D2 64     	LD (BLIT_STRUCT+4),HL
 381+ 5F75              	;LD A,(IX+16)
 382+ 5F75              	;LD (BLIT_TMP+2),A
 383+ 5F75
 384+ 5F75              	; calculate char&mask add to value
 385+ 5F75 26 00        	LD H,0
 386+ 5F77 3A DC 64     	LD A,(BLIT_STRUCT+14)
 387+ 5F7A 6F           	LD L,A
 388+ 5F7B CD CB 66     	CALL HLx8
 389+ 5F7E 22 DA 64     	LD (BLIT_STRUCT+12),HL
 390+ 5F81              	; calculate background add to value
 391+ 5F81 26 00        	LD H,0
 392+ 5F83 DD 6E 10     	LD L,(IX+16)
 393+ 5F86 CD CB 66     	CALL HLx8
 394+ 5F89 22 D4 64     	LD (BLIT_STRUCT+6),HL
 395+ 5F8C              	; calculate pointer to background location
 396+ 5F8C 21 00 00     	LD HL,0
 397+ 5F8F 3A CB 64     	LD A,(BLIT_TMP+1)
 398+ 5F92 B7           	OR A
 399+ 5F93 28 08        	JR Z, .L1
 400+ 5F95 47           	LD B,A
 401+ 5F96 ED 5B D4 64  	LD DE,(BLIT_STRUCT+6)
 402+ 5F9A              .L0:
 403+ 5F9A 19           	ADD HL, DE
 404+ 5F9B 10 FD        	DJNZ .L0
 405+ 5F9D              .L1:
 406+ 5F9D EB           	EX DE,HL
 407+ 5F9E 26 00        	LD H,0
 408+ 5FA0 3A CA 64     	LD A,(BLIT_TMP+0)
 409+ 5FA3 6F           	LD L,A
 410+ 5FA4 CD CB 66     	CALL HLx8
 411+ 5FA7 19           	ADD HL,DE
 412+ 5FA8 ED 5B D2 64  	LD DE,(BLIT_STRUCT+4)
 413+ 5FAC 19           	ADD HL,DE
 414+ 5FAD 22 D2 64     	LD (BLIT_STRUCT+4),HL
 415+ 5FB0
 416+ 5FB0 F3           	DI
 417+ 5FB1 FD 21 B8 5F  	LD IY, .RET
 418+ 5FB5 C3 8F 67     	JP ENABLE_PAGE0
 419+ 5FB8              .RET:
 420+ 5FB8 FB           	EI
 421+ 5FB9 DD 21 CE 64  	LD IX, BLIT_STRUCT
 422+ 5FBD CD 88 5E     	CALL SHIFT_MERGE_CHARACTER
 423+ 5FC0
 424+ 5FC0 D1               POP DE
 425+ 5FC1 C1               POP BC
 426+ 5FC2 C3 06 67         JP RESTORE_PAGE_INFO
 427+ 5FC5              ; *******************************************************************************************************
 428+ 5FC5               ENDIF
 429+ 5FC5
 430+ 5FC5               IF (BASIC_EXTENSION == 1)
 431+ 5FC5              ; *******************************************************************************************************
 432+ 5FC5              ; function to handle CALL BLIT basic extension
 433+ 5FC5              ; rotates 1-bit character drawing horizontally with mask and character data and
 434+ 5FC5              ; fuses with background data and applies vertical shift too
 435+ 5FC5              ; in form without pointers
 436+ 5FC5              ; BLIT ( INT x,
 437+ 5FC5              ;		 INT y,
 438+ 5FC5              ;		 INT char_data_pointer,
 439+ 5FC5              ;		 INT mask_data_pointer,
 440+ 5FC5              ;		 INT width (in characters),
 441+ 5FC5              ;		 INT height (in characters),
 442+ 5FC5              ;		 INT background_pointer (top left),
 443+ 5FC5              ;		 INT background_width (in characters),
 444+ 5FC5              ; will put ram in page 0 also, page 1 is already there
 445+ 5FC5              BLIT:
 446+ 5FC5              	; opening (
 447+ 5FC5 CD DD 67     	CALL CHKCHAR
 448+ 5FC8 28           	DB '('
 449+ 5FC9              	; get x coordinate
 450+ 5FC9 DD 21 2F 54  	LD IX, FRMQNT
 451+ 5FCD CD 59 01     	CALL CALBAS
 452+ 5FD0 7B           	LD A, E
 453+ 5FD1 E6 07        	AND 7
 454+ 5FD3 32 CE 64     	LD (BLIT_STRUCT+0), A
 455+ 5FD6 CD 1C 5F     	CALL DEdiv8
 456+ 5FD9 32 CA 64     	LD (BLIT_TMP+0),A
 457+ 5FDC              	; comma
 458+ 5FDC CD DD 67     	CALL CHKCHAR
 459+ 5FDF 2C           	DB ','
 460+ 5FE0              	; get y coordinate
 461+ 5FE0 DD 21 2F 54  	LD IX, FRMQNT
 462+ 5FE4 CD 59 01     	CALL CALBAS
 463+ 5FE7 7B           	LD A, E
 464+ 5FE8 E6 07        	AND 7
 465+ 5FEA 32 D0 64     	LD (BLIT_STRUCT+2), A
 466+ 5FED CD 1C 5F     	CALL DEdiv8
 467+ 5FF0 32 CB 64     	LD (BLIT_TMP+1),A
 468+ 5FF3              	; comma
 469+ 5FF3 CD DD 67     	CALL CHKCHAR
 470+ 5FF6 2C           	DB ','
 471+ 5FF7              	; get char data pointer
 472+ 5FF7 DD 21 2F 54  	LD IX, FRMQNT
 473+ 5FFB CD 59 01     	CALL CALBAS
 474+ 5FFE ED 53 D8 64  	LD (BLIT_STRUCT+10), DE
 475+ 6002              	; comma
 476+ 6002 CD DD 67     	CALL CHKCHAR
 477+ 6005 2C           	DB ','
 478+ 6006              	; get mask data pointer
 479+ 6006 DD 21 2F 54  	LD IX, FRMQNT
 480+ 600A CD 59 01     	CALL CALBAS
 481+ 600D ED 53 D6 64  	LD (BLIT_STRUCT+8), DE
 482+ 6011              	; comma
 483+ 6011 CD DD 67     	CALL CHKCHAR
 484+ 6014 2C           	DB ','
 485+ 6015              	; get width
 486+ 6015 DD 21 2F 54  	LD IX, FRMQNT
 487+ 6019 CD 59 01     	CALL CALBAS
 488+ 601C 7B           	LD A, E
 489+ 601D 32 DC 64     	LD (BLIT_STRUCT+14), A
 490+ 6020              	; comma
 491+ 6020 CD DD 67     	CALL CHKCHAR
 492+ 6023 2C           	DB ','
 493+ 6024              	; get height
 494+ 6024 DD 21 2F 54  	LD IX, FRMQNT
 495+ 6028 CD 59 01     	CALL CALBAS
 496+ 602B 7B           	LD A, E
 497+ 602C 32 DE 64     	LD (BLIT_STRUCT+16), A
 498+ 602F              	; comma
 499+ 602F CD DD 67     	CALL CHKCHAR
 500+ 6032 2C           	DB ','
 501+ 6033              	; get background pointer
 502+ 6033 DD 21 2F 54  	LD IX, FRMQNT
 503+ 6037 CD 59 01     	CALL CALBAS
 504+ 603A ED 53 D2 64  	LD (BLIT_STRUCT+4), DE
 505+ 603E              	; comma
 506+ 603E CD DD 67     	CALL CHKCHAR
 507+ 6041 2C           	DB ','
 508+ 6042              	; get background width
 509+ 6042 DD 21 2F 54  	LD IX, FRMQNT
 510+ 6046 CD 59 01     	CALL CALBAS
 511+ 6049 7B           	LD A, E
 512+ 604A 32 CC 64     	LD (BLIT_TMP+2), A
 513+ 604D              	; ending )
 514+ 604D CD DD 67     	CALL CHKCHAR
 515+ 6050 29           	DB ')'
 516+ 6051
 517+ 6051 E5           	PUSH HL ; save position in BASIC buffer
 518+ 6052
 519+ 6052              	; calculate char&mask add to value
 520+ 6052 26 00        	LD H, 0
 521+ 6054 3A DC 64     	LD A, (BLIT_STRUCT+14)
 522+ 6057 6F           	LD L, A
 523+ 6058 CD CB 66     	CALL HLx8
 524+ 605B 22 DA 64     	LD (BLIT_STRUCT+12), HL
 525+ 605E              	; calculate background add to value
 526+ 605E 26 00        	LD H, 0
 527+ 6060 3A CC 64     	LD A, (BLIT_TMP+2)
 528+ 6063 6F           	LD L, A
 529+ 6064 CD CB 66     	CALL HLx8
 530+ 6067 22 D4 64     	LD (BLIT_STRUCT+6), HL
 531+ 606A              	; calculate pointer to background location
 532+ 606A 21 00 00     	LD HL, 0
 533+ 606D 3A CB 64     	LD A,(BLIT_TMP+1)
 534+ 6070 B7           	OR A
 535+ 6071 28 08        	JR Z, .L1
 536+ 6073 47           	LD B,A
 537+ 6074 ED 5B D4 64  	LD DE,(BLIT_STRUCT+6)
 538+ 6078              .L0:
 539+ 6078 19           	ADD HL, DE
 540+ 6079 10 FD        	DJNZ .L0
 541+ 607B              .L1:
 542+ 607B EB           	EX DE,HL
 543+ 607C 26 00        	LD H,0
 544+ 607E 3A CA 64     	LD A,(BLIT_TMP+0)
 545+ 6081 6F           	LD L,A
 546+ 6082 CD CB 66     	CALL HLx8
 547+ 6085 19           	ADD HL,DE
 548+ 6086 ED 5B D2 64  	LD DE,(BLIT_STRUCT+4)
 549+ 608A 19           	ADD HL,DE
 550+ 608B 22 D2 64     	LD (BLIT_STRUCT+4),HL
 551+ 608E
 552+ 608E F3           	DI
 553+ 608F FD 21 96 60  	LD IY, .RET
 554+ 6093 C3 8F 67     	JP ENABLE_PAGE0
 555+ 6096              .RET:
 556+ 6096 FB           	EI
 557+ 6097 DD 21 CE 64  	LD IX, BLIT_STRUCT
 558+ 609B CD 88 5E     	CALL SHIFT_MERGE_CHARACTER
 559+ 609E
 560+ 609E D1               POP DE
 561+ 609F C1               POP BC
 562+ 60A0 CD 06 67         CALL RESTORE_PAGE_INFO
 563+ 60A3
 564+ 60A3 E1           	POP HL
 565+ 60A4 C9           	RET
 566+ 60A5              ; *******************************************************************************************************
 567+ 60A5               ENDIF
# file closed: asm\BLIT.asm
 159  60A5               ENDIF
 160  60A5
 161  60A5               IF (TILE_CMDS == 1)
 162  60A5               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
   1+ 60A5              ; *******************************************************************************************************
   2+ 60A5              ; generic function to implement tiling
   3+ 60A5              ; should be modified to call appropriate function for memory or vram
   4+ 60A5              ; input IX=pointer to following structure
   5+ 60A5              ; +00 tile_data_ptr
   6+ 60A5              ; +02 tile_rows
   7+ 60A5              ; +04 tile_columns
   8+ 60A5              ; +06 destination_address
   9+ 60A5              ; +08 dest_to_next_row_add_to_value
  10+ 60A5              ; +10 num_horizontal_tiles
  11+ 60A5              ; +12 num_vertical_tiles
  12+ 60A5              ; modifies AF, BC, DE, HL
  13+ 60A5              TILE:
  14+ 60A5 DD 6E 06     	LD L, (IX+6)
  15+ 60A8 DD 66 07     	LD H, (IX+7) ; destination address
  16+ 60AB 22 CA 64     	LD (TILETMP1), HL
  17+ 60AE DD 46 0C     	LD B, (IX+12) ; vertical tile number
  18+ 60B1              .L1:
  19+ 60B1 C5           	PUSH BC
  20+ 60B2 DD 6E 00     		LD L, (IX+0)
  21+ 60B5 DD 66 01     		LD H, (IX+1) ; tile address
  22+ 60B8 22 CC 64     		LD (TILETMP2), HL
  23+ 60BB DD 46 02     		LD B, (IX+2) ; tile rows
  24+ 60BE              .L2:
  25+ 60BE C5           		PUSH BC
  26+ 60BF CD 00 00     .CALL1:		CALL 0
  27+ 60C2 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
  28+ 60C5              .L3:
  29+ 60C5 C5           			PUSH BC
  30+ 60C6 2A CC 64     				LD HL, (TILETMP2)
  31+ 60C9 DD 46 04     				LD B, (IX+4) ; tile columns
  32+ 60CC              .L4:
  33+ 60CC C5           				PUSH BC
  34+ 60CD              .CALL2:
  35+ 60CD CD 00 00     					CALL 0
  36+ 60D0 C1           				POP BC
  37+ 60D1 10 F9        				DJNZ .L4
  38+ 60D3 C1           			POP BC
  39+ 60D4 10 EF        			DJNZ .L3
  40+ 60D6 22 CC 64     			LD (TILETMP2), HL
  41+ 60D9 2A CA 64     			LD HL, (TILETMP1)
  42+ 60DC DD 5E 08     			LD E, (IX+8)
  43+ 60DF DD 56 09     			LD D, (IX+9) ; add to value for dest next row
  44+ 60E2 19           			ADD HL, DE
  45+ 60E3 22 CA 64     			LD (TILETMP1), HL
  46+ 60E6 C1           		POP BC
  47+ 60E7 10 D5        		DJNZ .L2
  48+ 60E9 C1           	POP BC
  49+ 60EA 10 C5        	DJNZ .L1
  50+ 60EC C9           	RET
  51+ 60ED              ; *******************************************************************************************************
  52+ 60ED
  53+ 60ED               IFNDEF CMDS_WITH_PARAMETERS
  54+ 60ED ~            ; *******************************************************************************************************
  55+ 60ED ~            ; function to handle CALL TILERAM basic extension
  56+ 60ED ~            ; fills memory with tiles
  57+ 60ED ~            ; TILERAM ( INT request_data_ptr )
  58+ 60ED ~            ; request_data_ptr described in TILE
  59+ 60ED ~            ; will put ram in page 0 also, page 1 is already there
  60+ 60ED ~            TILERAM:
  61+ 60ED ~            	; opening (
  62+ 60ED ~            	CALL CHKCHAR
  63+ 60ED ~            	DB '('
  64+ 60ED ~            	; get pointer to request struct
  65+ 60ED ~            	LD IX, FRMQNT
  66+ 60ED ~            	CALL CALBAS
  67+ 60ED ~            	PUSH DE
  68+ 60ED ~            	; ending )
  69+ 60ED ~            	CALL CHKCHAR
  70+ 60ED ~            	DB ')'
  71+ 60ED ~
  72+ 60ED ~            	POP IX ; pointer to request struct
  73+ 60ED ~
  74+ 60ED ~            	PUSH HL ; save position in BASIC buffer
  75+ 60ED ~            	DI
  76+ 60ED ~            	LD IY, .RET
  77+ 60ED ~            	JP ENABLE_PAGE0
  78+ 60ED ~            .RET:
  79+ 60ED ~            	EI
  80+ 60ED ~            	; set RAM functions to call
  81+ 60ED ~            	LD HL, .TILECOPY
  82+ 60ED ~            	LD (TILE.CALL2+1), HL
  83+ 60ED ~            	LD HL, .SETDESTROW
  84+ 60ED ~            	LD (TILE.CALL1+1), HL
  85+ 60ED ~            	LD A,1
  86+ 60ED ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  87+ 60ED ~            	CALL TILE
  88+ 60ED ~            	XOR A
  89+ 60ED ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  90+ 60ED ~
  91+ 60ED ~                POP DE
  92+ 60ED ~                POP BC
  93+ 60ED ~                CALL RESTORE_PAGE_INFO
  94+ 60ED ~
  95+ 60ED ~            	POP HL
  96+ 60ED ~            	RET
  97+ 60ED ~            .TILECOPY:
  98+ 60ED ~            	.8 LDI
  99+ 60ED ~            	RET
 100+ 60ED ~            .SETDESTROW:
 101+ 60ED ~            	LD DE, (TILETMP1)
 102+ 60ED ~            	RET
 103+ 60ED ~            ; *******************************************************************************************************
 104+ 60ED               ENDIF
 105+ 60ED
 106+ 60ED               IFDEF CMDS_WITH_PARAMETERS
 107+ 60ED              ; *******************************************************************************************************
 108+ 60ED              ; function to handle CALL TILERAM basic extension
 109+ 60ED              ; fills memory with tiles
 110+ 60ED              ; TILERAM ( INT tile_data_pointer,
 111+ 60ED              ;			INT tile_columns,
 112+ 60ED              ;			INT tile_rows,
 113+ 60ED              ;			INT destination_pointer,
 114+ 60ED              ;			INT destination_columns,
 115+ 60ED              ;			INT destination_rows,
 116+ 60ED              ;			INT destination_begin_column,
 117+ 60ED              ;			INT destination_begin_row,
 118+ 60ED              ;			INT number_of_tiles_horizontally,
 119+ 60ED              ;			INT	number_of_tiles_vertically )
 120+ 60ED              ; will put ram in page 0 also, page 1 is already there
 121+ 60ED              TILERAM:
 122+ 60ED              	; opening (
 123+ 60ED CD DD 67     	CALL CHKCHAR
 124+ 60F0 28           	DB '('
 125+ 60F1              	; get tile data pointer coordinate
 126+ 60F1 DD 21 2F 54  	LD IX, FRMQNT
 127+ 60F5 CD 59 01     	CALL CALBAS
 128+ 60F8 ED 53 CE 64  	LD (BLIT_STRUCT+0), DE
 129+ 60FC              	; comma
 130+ 60FC CD DD 67     	CALL CHKCHAR
 131+ 60FF 2C           	DB ','
 132+ 6100              	; get tile columns
 133+ 6100 DD 21 2F 54  	LD IX, FRMQNT
 134+ 6104 CD 59 01     	CALL CALBAS
 135+ 6107 ED 53 D2 64  	LD (BLIT_STRUCT+4), DE
 136+ 610B              	; comma
 137+ 610B CD DD 67     	CALL CHKCHAR
 138+ 610E 2C           	DB ','
 139+ 610F              	; get tile columns
 140+ 610F DD 21 2F 54  	LD IX, FRMQNT
 141+ 6113 CD 59 01     	CALL CALBAS
 142+ 6116 ED 53 D0 64  	LD (BLIT_STRUCT+2), DE
 143+ 611A              	; comma
 144+ 611A CD DD 67     	CALL CHKCHAR
 145+ 611D 2C           	DB ','
 146+ 611E              	; get destintion pointer
 147+ 611E DD 21 2F 54  	LD IX, FRMQNT
 148+ 6122 CD 59 01     	CALL CALBAS
 149+ 6125 ED 53 D4 64  	LD (BLIT_STRUCT+6), DE
 150+ 6129              	; comma
 151+ 6129 CD DD 67     	CALL CHKCHAR
 152+ 612C 2C           	DB ','
 153+ 612D              	; get destination columns
 154+ 612D DD 21 2F 54  	LD IX, FRMQNT
 155+ 6131 CD 59 01     	CALL CALBAS
 156+ 6134 7B           	LD A, E
 157+ 6135 32 CA 64     	LD (BLIT_TMP+0), A
 158+ 6138              	; comma
 159+ 6138 CD DD 67     	CALL CHKCHAR
 160+ 613B 2C           	DB ','
 161+ 613C              	; get destination rows
 162+ 613C DD 21 2F 54  	LD IX, FRMQNT
 163+ 6140 CD 59 01     	CALL CALBAS
 164+ 6143 7B           	LD A, E
 165+ 6144 32 CB 64     	LD (BLIT_TMP+1), A
 166+ 6147              	; comma
 167+ 6147 CD DD 67     	CALL CHKCHAR
 168+ 614A 2C           	DB ','
 169+ 614B              	; get destination begin column
 170+ 614B DD 21 2F 54  	LD IX, FRMQNT
 171+ 614F CD 59 01     	CALL CALBAS
 172+ 6152 7B           	LD A, E
 173+ 6153 32 CC 64     	LD (BLIT_TMP+2), A
 174+ 6156              	; comma
 175+ 6156 CD DD 67     	CALL CHKCHAR
 176+ 6159 2C           	DB ','
 177+ 615A              	; get destination begin row
 178+ 615A DD 21 2F 54  	LD IX, FRMQNT
 179+ 615E CD 59 01     	CALL CALBAS
 180+ 6161 7B           	LD A, E
 181+ 6162 32 CD 64     	LD (BLIT_TMP+3), A
 182+ 6165              	; comma
 183+ 6165 CD DD 67     	CALL CHKCHAR
 184+ 6168 2C           	DB ','
 185+ 6169              	; get number of tiles horizontally
 186+ 6169 DD 21 2F 54  	LD IX, FRMQNT
 187+ 616D CD 59 01     	CALL CALBAS
 188+ 6170 ED 53 D8 64  	LD (BLIT_STRUCT+10), DE
 189+ 6174              	; comma
 190+ 6174 CD DD 67     	CALL CHKCHAR
 191+ 6177 2C           	DB ','
 192+ 6178              	; get number of tiles vertically
 193+ 6178 DD 21 2F 54  	LD IX, FRMQNT
 194+ 617C CD 59 01     	CALL CALBAS
 195+ 617F ED 53 DA 64  	LD (BLIT_STRUCT+12), DE
 196+ 6183              	; ending )
 197+ 6183 CD DD 67     	CALL CHKCHAR
 198+ 6186 29           	DB ')'
 199+ 6187
 200+ 6187 E5           	PUSH HL ; save position in BASIC buffer
 201+ 6188
 202+ 6188              	; calculate destination add to value
 203+ 6188 26 00        	LD H, 0
 204+ 618A 3A CA 64     	LD A, (BLIT_TMP+0)
 205+ 618D 6F           	LD L, A
 206+ 618E CD CB 66     	CALL HLx8
 207+ 6191 22 D6 64     	LD (BLIT_STRUCT+8), HL
 208+ 6194              	; calculate pointer to background location
 209+ 6194 21 00 00     	LD HL, 0
 210+ 6197 3A CD 64     	LD A,(BLIT_TMP+3)
 211+ 619A B7           	OR A
 212+ 619B 28 08        	JR Z, .L1
 213+ 619D 47           	LD B,A
 214+ 619E ED 5B D6 64  	LD DE,(BLIT_STRUCT+8)
 215+ 61A2              .L0:
 216+ 61A2 19           	ADD HL, DE
 217+ 61A3 10 FD        	DJNZ .L0
 218+ 61A5              .L1:
 219+ 61A5 EB           	EX DE,HL
 220+ 61A6 26 00        	LD H,0
 221+ 61A8 3A CC 64     	LD A,(BLIT_TMP+2)
 222+ 61AB 6F           	LD L,A
 223+ 61AC CD CB 66     	CALL HLx8
 224+ 61AF 19           	ADD HL,DE
 225+ 61B0 ED 5B D4 64  	LD DE,(BLIT_STRUCT+6)
 226+ 61B4 19           	ADD HL,DE
 227+ 61B5 22 D4 64     	LD (BLIT_STRUCT+6),HL
 228+ 61B8 F3           	DI
 229+ 61B9 FD 21 C0 61  	LD IY, .RET
 230+ 61BD C3 8F 67     	JP ENABLE_PAGE0
 231+ 61C0              .RET:
 232+ 61C0 FB           	EI
 233+ 61C1              	; set RAM functions to call
 234+ 61C1 21 DB 61     	LD HL, .TILECOPY
 235+ 61C4 22 CE 60     	LD (TILE.CALL2+1), HL
 236+ 61C7 21 EC 61     	LD HL, .SETDESTROW
 237+ 61CA 22 C0 60     	LD (TILE.CALL1+1), HL
 238+ 61CD DD 21 CE 64  	LD IX,BLIT_STRUCT
 239+ 61D1 CD A5 60     	CALL TILE
 240+ 61D4
 241+ 61D4 D1               POP DE
 242+ 61D5 C1               POP BC
 243+ 61D6 CD 06 67         CALL RESTORE_PAGE_INFO
 244+ 61D9
 245+ 61D9 E1           	POP HL
 246+ 61DA C9           	RET
 247+ 61DB              .TILECOPY:
 248+ 61DB ED A0       > LDI
 248+ 61DD ED A0       > LDI
 248+ 61DF ED A0       > LDI
 248+ 61E1 ED A0       > LDI
 248+ 61E3 ED A0       > LDI
 248+ 61E5 ED A0       > LDI
 248+ 61E7 ED A0       > LDI
 248+ 61E9 ED A0       > LDI
 249+ 61EB C9           	RET
 250+ 61EC              .SETDESTROW:
 251+ 61EC ED 5B CA 64  	LD DE, (TILETMP1)
 252+ 61F0 C9           	RET
 253+ 61F1              ; *******************************************************************************************************
 254+ 61F1               ENDIF
 255+ 61F1
 256+ 61F1               IFDEF CMDS_WITH_PARAMETERS
 257+ 61F1              ; *******************************************************************************************************
 258+ 61F1              ; function to handle CALL TILEVRM basic extension
 259+ 61F1              ; fills vram with tiles
 260+ 61F1              ; TILEVRM ( INT tile_data_pointer,
 261+ 61F1              ;			INT tile_columns,
 262+ 61F1              ;			INT tile_rows,
 263+ 61F1              ;			INT destination_begin_column,
 264+ 61F1              ;			INT destination_begin_row,
 265+ 61F1              ;			INT number_of_tiles_horizontally,
 266+ 61F1              ;			INT	number_of_tiles_vertically )
 267+ 61F1              ; will put ram in page 0 also, page 1 is already there
 268+ 61F1              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
 269+ 61F1              TILEVRM:
 270+ 61F1              	; opening (
 271+ 61F1 CD DD 67     	CALL CHKCHAR
 272+ 61F4 28           	DB '('
 273+ 61F5              	; get tile data pointer coordinate
 274+ 61F5 DD 21 2F 54  	LD IX, FRMQNT
 275+ 61F9 CD 59 01     	CALL CALBAS
 276+ 61FC ED 53 CE 64  	LD (BLIT_STRUCT+0), DE
 277+ 6200              	; comma
 278+ 6200 CD DD 67     	CALL CHKCHAR
 279+ 6203 2C           	DB ','
 280+ 6204              	; get tile columns
 281+ 6204 DD 21 2F 54  	LD IX, FRMQNT
 282+ 6208 CD 59 01     	CALL CALBAS
 283+ 620B ED 53 D2 64  	LD (BLIT_STRUCT+4), DE
 284+ 620F              	; comma
 285+ 620F CD DD 67     	CALL CHKCHAR
 286+ 6212 2C           	DB ','
 287+ 6213              	; get tile columns
 288+ 6213 DD 21 2F 54  	LD IX, FRMQNT
 289+ 6217 CD 59 01     	CALL CALBAS
 290+ 621A ED 53 D0 64  	LD (BLIT_STRUCT+2), DE
 291+ 621E              	; comma
 292+ 621E CD DD 67     	CALL CHKCHAR
 293+ 6221 2C           	DB ','
 294+ 6222              	; get destination begin column
 295+ 6222 DD 21 2F 54  	LD IX, FRMQNT
 296+ 6226 CD 59 01     	CALL CALBAS
 297+ 6229 7B           	LD A, E
 298+ 622A 32 CC 64     	LD (BLIT_TMP+2), A
 299+ 622D              	; comma
 300+ 622D CD DD 67     	CALL CHKCHAR
 301+ 6230 2C           	DB ','
 302+ 6231              	; get destination begin row
 303+ 6231 DD 21 2F 54  	LD IX, FRMQNT
 304+ 6235 CD 59 01     	CALL CALBAS
 305+ 6238 7B           	LD A, E
 306+ 6239 32 CD 64     	LD (BLIT_TMP+3), A
 307+ 623C              	; comma
 308+ 623C CD DD 67     	CALL CHKCHAR
 309+ 623F 2C           	DB ','
 310+ 6240              	; get number of tiles horizontally
 311+ 6240 DD 21 2F 54  	LD IX, FRMQNT
 312+ 6244 CD 59 01     	CALL CALBAS
 313+ 6247 ED 53 D8 64  	LD (BLIT_STRUCT+10), DE
 314+ 624B              	; comma
 315+ 624B CD DD 67     	CALL CHKCHAR
 316+ 624E 2C           	DB ','
 317+ 624F              	; get number of tiles vertically
 318+ 624F DD 21 2F 54  	LD IX, FRMQNT
 319+ 6253 CD 59 01     	CALL CALBAS
 320+ 6256 ED 53 DA 64  	LD (BLIT_STRUCT+12), DE
 321+ 625A              	; ending )
 322+ 625A CD DD 67     	CALL CHKCHAR
 323+ 625D 29           	DB ')'
 324+ 625E
 325+ 625E E5           	PUSH HL ; save position in BASIC buffer
 326+ 625F
 327+ 625F              	; calculate destination add to value
 328+ 625F 21 00 01     	LD HL, 256
 329+ 6262 22 D6 64     	LD (BLIT_STRUCT+8), HL
 330+ 6265              	; calculate pointer to background location
 331+ 6265 3A CD 64     	LD A,(BLIT_TMP+3)
 332+ 6268 67           	LD H,A
 333+ 6269 2E 00        	LD L,0
 334+ 626B EB           	EX DE,HL
 335+ 626C 26 00        	LD H,0
 336+ 626E 3A CC 64     	LD A,(BLIT_TMP+2)
 337+ 6271 6F           	LD L,A
 338+ 6272 CD CB 66     	CALL HLx8
 339+ 6275 19           	ADD HL,DE
 340+ 6276 ED 5B CB F3  	LD DE,(GRPCGP)
 341+ 627A 19           	ADD HL,DE
 342+ 627B 22 D4 64     	LD (BLIT_STRUCT+6),HL
 343+ 627E F3           	DI
 344+ 627F FD 21 86 62  	LD IY, .RET
 345+ 6283 C3 8F 67     	JP ENABLE_PAGE0
 346+ 6286              .RET:
 347+ 6286 FB           	EI
 348+ 6287              	; set RAM functions to call
 349+ 6287 21 A1 62     	LD HL, .TILECOPY
 350+ 628A 22 CE 60     	LD (TILE.CALL2+1), HL
 351+ 628D 21 A7 62     	LD HL, .SETDESTROW
 352+ 6290 22 C0 60     	LD (TILE.CALL1+1), HL
 353+ 6293 DD 21 CE 64  	LD IX,BLIT_STRUCT
 354+ 6297 CD A5 60     	CALL TILE
 355+ 629A
 356+ 629A D1               POP DE
 357+ 629B C1               POP BC
 358+ 629C CD 06 67         CALL RESTORE_PAGE_INFO
 359+ 629F
 360+ 629F E1           	POP HL
 361+ 62A0 C9           	RET
 362+ 62A1              .TILECOPY:
 363+ 62A1 01 98 08     	LD BC, #0898
 364+ 62A4 C3 C3 66     	JP BBYTECOPY_NO_C
 365+ 62A7              .SETDESTROW:
 366+ 62A7 2A CA 64     	LD HL, (TILETMP1)
 367+ 62AA F3           	DI
 368+ 62AB CD B6 66     	CALL SETWRT_LOCAL
 369+ 62AE FB           	EI
 370+ 62AF C9           	RET
 371+ 62B0              ; *******************************************************************************************************
 372+ 62B0               ENDIF
 373+ 62B0
 374+ 62B0               IFNDEF CMDS_WITH_PARAMETERS
 375+ 62B0 ~            ; *******************************************************************************************************
 376+ 62B0 ~            ; function to handle CALL TILEVRM basic extension
 377+ 62B0 ~            ; fills vram with tiles
 378+ 62B0 ~            ; TILEVRM ( INT request_data_ptr )
 379+ 62B0 ~            ; request_data_ptr described in TILE
 380+ 62B0 ~            ; will put ram in page 0 also, page 1 is already there
 381+ 62B0 ~            TILEVRM:
 382+ 62B0 ~            	; opening (
 383+ 62B0 ~            	CALL CHKCHAR
 384+ 62B0 ~            	DB '('
 385+ 62B0 ~            	; get pointer to request struct
 386+ 62B0 ~            	LD IX, FRMQNT
 387+ 62B0 ~            	CALL CALBAS
 388+ 62B0 ~            	PUSH DE
 389+ 62B0 ~            	; ending )
 390+ 62B0 ~            	CALL CHKCHAR
 391+ 62B0 ~            	DB ')'
 392+ 62B0 ~
 393+ 62B0 ~            	POP IX ; pointer to request struct
 394+ 62B0 ~
 395+ 62B0 ~            	PUSH HL ; save position in BASIC buffer
 396+ 62B0 ~            	DI
 397+ 62B0 ~            	LD IY, .RET
 398+ 62B0 ~            	JP ENABLE_PAGE0
 399+ 62B0 ~            .RET:
 400+ 62B0 ~            	EI
 401+ 62B0 ~            	; set RAM functions to call
 402+ 62B0 ~            	LD HL, .TILECOPY
 403+ 62B0 ~            	LD (TILE.CALL2+1), HL
 404+ 62B0 ~            	LD HL, .SETDESTROW
 405+ 62B0 ~            	LD (TILE.CALL1+1), HL
 406+ 62B0 ~            	CALL TILE
 407+ 62B0 ~
 408+ 62B0 ~                POP DE
 409+ 62B0 ~                POP BC
 410+ 62B0 ~                CALL RESTORE_PAGE_INFO
 411+ 62B0 ~
 412+ 62B0 ~            	POP HL
 413+ 62B0 ~            	RET
 414+ 62B0 ~            .TILECOPY:
 415+ 62B0 ~            	LD BC, #0898
 416+ 62B0 ~            	JP BBYTECOPY_NO_C
 417+ 62B0 ~            .SETDESTROW:
 418+ 62B0 ~            	LD HL, (TILETMP1)
 419+ 62B0 ~            	DI
 420+ 62B0 ~            	CALL SETWRT_LOCAL
 421+ 62B0 ~            	EI
 422+ 62B0 ~            	RET
 423+ 62B0 ~            ; *******************************************************************************************************
 424+ 62B0               ENDIF
# file closed: asm\TILE.asm
 163  62B0               ENDIF
 164  62B0
 165  62B0               IF (COLL_CMD == 1)
 166  62B0               INCLUDE "COLLISION.asm"
# file opened: asm\COLLISION.asm
   1+ 62B0              ; generic collision checking routines
   2+ 62B0              ; in BASIC we use rectangle structure array DIM R%(7,n) of the format
   3+ 62B0              ; R%(0,n) is active flag, <>0 active / 0 skipped in checks
   4+ 62B0              ; R%(1,n) is either upper left x coordinate or sprite id (0-31) depending on R(7,n)
   5+ 62B0              ; R%(2,n) is either upper left y coordinate or unused depending on R(7,n)
   6+ 62B0              ; R%(3,n) x offset where rectangle begins
   7+ 62B0              ; R%(4,n) y offset where rectangle begins
   8+ 62B0              ; R%(5,n) is width
   9+ 62B0              ; R%(6,n) is height
  10+ 62B0              ; R%(7,0) is type, 0=generic where R%(1,0) contains x coordinate
  11+ 62B0              ;                  <>0 sprite where R%(1,0) contains sprite id
  12+ 62B0              ; for type sprite, upper left coordinates are taken from sprite attribute array
  13+ 62B0
  14+ 62B0              ; ************************************************************************************************
  15+ 62B0              ; quick test if HL<=DE<=HL+BC
  16+ 62B0              ; input BC=width, DE=x, HL=min
  17+ 62B0              ; if not true flag C set
  18+ 62B0              ; modifies AF
  19+ 62B0              GENERIC_INNER_CHECK:
  20+ 62B0 E5               PUSH HL
  21+ 62B1 D5               PUSH DE
  22+ 62B2 EB               EX DE,HL
  23+ 62B3 A7               AND A
  24+ 62B4 ED 52            SBC HL, DE
  25+ 62B6 FA C4 62         JP M, .GENERIC_INNER_CHECK_NOT
  26+ 62B9 A7               AND A
  27+ 62BA ED 42            SBC HL, BC
  28+ 62BC 28 03            JR Z, .L2
  29+ 62BE F2 C4 62         JP P, .GENERIC_INNER_CHECK_NOT
  30+ 62C1              .L2:
  31+ 62C1 A7               AND A
  32+ 62C2 18 01            JR .EXIT
  33+ 62C4              .GENERIC_INNER_CHECK_NOT:
  34+ 62C4 37               SCF
  35+ 62C5              .EXIT:
  36+ 62C5 D1               POP DE
  37+ 62C6 E1               POP HL
  38+ 62C7 C9               RET
  39+ 62C8              ; ************************************************************************************************
  40+ 62C8
  41+ 62C8              ; ************************************************************************************************
  42+ 62C8              ; function to check if rectangles are overlapping
  43+ 62C8              ; input IX=IY=pointer to struct
  44+ 62C8              ;  +00 active flag
  45+ 62C8              ;  +02 x coordinate
  46+ 62C8              ;  +04 y coordinate
  47+ 62C8              ;  +06 x offset where rectangle begins
  48+ 62C8              ;  +08 y offset where rectangle begins
  49+ 62C8              ;  +10 width
  50+ 62C8              ;  +12 height
  51+ 62C8              ; where IY is used to read +2 and +4, and IX to read +6, +8, +10 and +12
  52+ 62C8              ; this is a hack to allow location being taken from sprite attributes table
  53+ 62C8              ; input BLIT_STRUCT data
  54+ 62C8              ;  +00 x coordinate
  55+ 62C8              ;  +02 y coordinate
  56+ 62C8              ;  +04 width
  57+ 62C8              ;  +06 height
  58+ 62C8              ; returns CF=1 if not overlapping, CF=0 if overlapping
  59+ 62C8              RECTANGLE_OVERLAP_CHECK:
  60+ 62C8                  ; first check which rectangle is higher
  61+ 62C8 DD 6E 0C         LD L,(IX+12)
  62+ 62CB DD 66 0D         LD H,(IX+13)
  63+ 62CE ED 5B D4 64      LD DE,(BLIT_STRUCT+6)
  64+ 62D2 A7               AND A
  65+ 62D3 ED 52            SBC HL,DE
  66+ 62D5 FD 6E 04         LD L,(IY+4)
  67+ 62D8 FD 66 05         LD H,(IY+5)
  68+ 62DB DD 5E 08         LD E,(IX+8)
  69+ 62DE DD 56 09         LD D,(IX+9)
  70+ 62E1 FA 01 63         JP M,.L1
  71+ 62E4                  ; equally high or IX defined one higher
  72+ 62E4                  ; check upper boundary
  73+ 62E4 19               ADD HL,DE
  74+ 62E5 ED 5B D0 64      LD DE,(BLIT_STRUCT+2)
  75+ 62E9 DD 4E 0C         LD C,(IX+12)
  76+ 62EC DD 46 0D         LD B,(IX+13)
  77+ 62EF CD B0 62         CALL GENERIC_INNER_CHECK
  78+ 62F2 30 29            JR NC,.INSIDE
  79+ 62F4                  ; check lower boundary
  80+ 62F4 E5               PUSH HL
  81+ 62F5 2A D4 64         LD HL,(BLIT_STRUCT+6)
  82+ 62F8 19               ADD HL,DE
  83+ 62F9 EB               EX DE,HL
  84+ 62FA E1               POP HL
  85+ 62FB CD B0 62         CALL GENERIC_INNER_CHECK
  86+ 62FE 30 1D            JR NC,.INSIDE
  87+ 6300 C9               RET ; not overlapping
  88+ 6301              .L1:
  89+ 6301                  ; rectangle defined in BLIT_STRUCT is higher
  90+ 6301 19               ADD HL,DE
  91+ 6302 EB               EX DE,HL
  92+ 6303 2A D0 64         LD HL,(BLIT_STRUCT+2)
  93+ 6306 ED 4B D4 64      LD BC,(BLIT_STRUCT+6)
  94+ 630A CD B0 62         CALL GENERIC_INNER_CHECK
  95+ 630D 30 0E            JR NC,.INSIDE
  96+ 630F E5               PUSH HL
  97+ 6310 DD 6E 0C         LD L,(IX+12)
  98+ 6313 DD 66 0D         LD H,(IX+13)
  99+ 6316 19               ADD HL,DE
 100+ 6317 EB               EX DE,HL
 101+ 6318 E1               POP HL
 102+ 6319 CD B0 62         CALL GENERIC_INNER_CHECK
 103+ 631C D8               RET C
 104+ 631D              .INSIDE:
 105+ 631D                  ; check x coordinate
 106+ 631D                  ; first check which rectangle is wider
 107+ 631D DD 6E 0A         LD L,(IX+10)
 108+ 6320 DD 66 0B         LD H,(IX+11)
 109+ 6323 ED 5B D2 64      LD DE,(BLIT_STRUCT+4)
 110+ 6327 A7               AND A
 111+ 6328 ED 52            SBC HL,DE
 112+ 632A FD 6E 02         LD L,(IY+2)
 113+ 632D FD 66 03         LD H,(IY+3)
 114+ 6330 DD 5E 06         LD E,(IX+6)
 115+ 6333 DD 56 07         LD D,(IX+7)
 116+ 6336 FA 52 63         JP M,.L2
 117+ 6339                  ; equally wide or IX defined one wider
 118+ 6339                  ; check left boundary
 119+ 6339 19               ADD HL,DE
 120+ 633A ED 5B CE 64      LD DE,(BLIT_STRUCT+0)
 121+ 633E DD 4E 0A         LD C,(IX+10)
 122+ 6341 DD 46 0B         LD B,(IX+11)
 123+ 6344 CD B0 62         CALL GENERIC_INNER_CHECK
 124+ 6347 D0               RET NC ; overlap
 125+ 6348                  ; check right boundary
 126+ 6348 E5               PUSH HL
 127+ 6349 2A D2 64         LD HL,(BLIT_STRUCT+4)
 128+ 634C 19               ADD HL,DE
 129+ 634D EB               EX DE,HL
 130+ 634E E1               POP HL
 131+ 634F C3 B0 62         JP GENERIC_INNER_CHECK ; CF and result set by fn call
 132+ 6352              .L2:
 133+ 6352                  ; rectangle defined in BLIT_STRUCT is higher
 134+ 6352 19               ADD HL,DE
 135+ 6353 EB               EX DE,HL
 136+ 6354 2A CE 64         LD HL,(BLIT_STRUCT+0)
 137+ 6357 ED 4B D2 64      LD BC,(BLIT_STRUCT+4)
 138+ 635B CD B0 62         CALL GENERIC_INNER_CHECK
 139+ 635E D0               RET NC ; overlap
 140+ 635F E5               PUSH HL
 141+ 6360 DD 6E 0A         LD L,(IX+10)
 142+ 6363 DD 66 0B         LD H,(IX+11)
 143+ 6366 19               ADD HL,DE
 144+ 6367 EB               EX DE,HL
 145+ 6368 E1               POP HL
 146+ 6369 C3 B0 62         JP GENERIC_INNER_CHECK
 147+ 636C              ; ************************************************************************************************
 148+ 636C
 149+ 636C              ; ************************************************************************************************
 150+ 636C              ; function tries to find rectangle overlap and returns an index if found
 151+ 636C              ; input BLIT_STRUCT data
 152+ 636C              ;  +00 x coordinate
 153+ 636C              ;  +02 y coordinate
 154+ 636C              ;  +04 width
 155+ 636C              ;  +06 height
 156+ 636C              ;  +08 number of items in a list, described under RECTANGLE_OVERLAP_CHECK
 157+ 636C              ;  +09 pointer to first element of R%(7,n)
 158+ 636C              ;  +11 pointer to INT result variable
 159+ 636C              ; returns CF=1 if not overlapping
 160+ 636C              ; returns A=list index and CF=0 if overlapping
 161+ 636C              FIND_OVERLAP:
 162+ 636C 3A D6 64         LD A,(BLIT_STRUCT+8)
 163+ 636F 47               LD B,A
 164+ 6370 DD 2A D7 64      LD IX,(BLIT_STRUCT+9)
 165+ 6374              .L1:
 166+ 6374 C5               PUSH BC
 167+ 6375                  ; check active flag
 168+ 6375 DD 7E 00         LD A,(IX)
 169+ 6378 DD B6 01         OR (IX+1)
 170+ 637B 28 18            JR Z,.NEXT
 171+ 637D                  ; check type
 172+ 637D DD 7E 0E         LD A,(IX+14)
 173+ 6380 DD B6 0F         OR (IX+15)
 174+ 6383 20 1A            JR NZ,.L2
 175+ 6385 DD E5            PUSH IX
 176+ 6387 FD E1            POP IY
 177+ 6389              .L3:
 178+ 6389 CD C8 62         CALL RECTANGLE_OVERLAP_CHECK
 179+ 638C 38 07            JR C,.NEXT
 180+ 638E                  ; found
 181+ 638E C1               POP BC
 182+ 638F 3A D6 64         LD A,(BLIT_STRUCT+8)
 183+ 6392 90               SUB B
 184+ 6393 A7               AND A
 185+ 6394 C9               RET
 186+ 6395              .NEXT:
 187+ 6395 11 10 00         LD DE,16
 188+ 6398 DD 19            ADD IX,DE
 189+ 639A C1               POP BC
 190+ 639B 10 D7            DJNZ .L1
 191+ 639D 37               SCF
 192+ 639E C9               RET
 193+ 639F              .L2:
 194+ 639F                  ; sprite, need to build a temporary data struct since x and y values are inversed
 195+ 639F                  ; at BLIT_STRUCT+13
 196+ 639F DD 7E 02         LD A,(IX+2) ; sprite ID
 197+ 63A2 CD 89 4D         CALL GETnthSPRATTR
 198+ 63A5 FD 21 D9 64      LD IY,BLIT_STRUCT+11
 199+ 63A9 7E               LD A,(HL)
 200+ 63AA FD 77 04         LD (IY+4),A
 201+ 63AD 23               INC HL
 202+ 63AE 7E               LD A,(HL)
 203+ 63AF FD 77 05         LD (IY+5),A
 204+ 63B2 23               INC HL
 205+ 63B3 7E               LD A,(HL)
 206+ 63B4 FD 77 02         LD (IY+2),A
 207+ 63B7 23               INC HL
 208+ 63B8 7E               LD A,(HL)
 209+ 63B9 FD 77 03         LD (IY+3),A
 210+ 63BC 18 CB            JR .L3
 211+ 63BE              ; ************************************************************************************************
 212+ 63BE
 213+ 63BE               IF (BASIC_EXTENSION == 1)
 214+ 63BE              ; ************************************************************************************************
 215+ 63BE              ; function to handle CALL COLL basic extension
 216+ 63BE              ; checks for collision between player and other rectangles
 217+ 63BE              ; COLL ( INT result variable,
 218+ 63BE              ;	     INT player x value,
 219+ 63BE              ;	     INT player y value,
 220+ 63BE              ;	     INT player width,
 221+ 63BE              ;	     INT player height,
 222+ 63BE              ;	     INT number of items in a list,
 223+ 63BE              ;		 INT[6][n] rectangle struct )
 224+ 63BE              ; will fill result variable with index or -1 if no collision
 225+ 63BE              ; rectangle struct described under RECTANGLE_OVERLAP_CHECK
 226+ 63BE              COLL:
 227+ 63BE              	; opening (
 228+ 63BE CD DD 67     	CALL CHKCHAR
 229+ 63C1 28           	DB '('
 230+ 63C2              	; get address of result variable
 231+ 63C2 DD 21 A4 5E  	LD IX, PTRGET
 232+ 63C6 CD 59 01     	CALL CALBAS
 233+ 63C9 ED 53 D9 64  	LD (BLIT_STRUCT+11),DE
 234+ 63CD              	; comma
 235+ 63CD CD DD 67     	CALL CHKCHAR
 236+ 63D0 2C           	DB ','
 237+ 63D1              	; get x
 238+ 63D1 DD 21 2F 54  	LD IX, FRMQNT
 239+ 63D5 CD 59 01     	CALL CALBAS
 240+ 63D8 ED 53 CE 64  	LD (BLIT_STRUCT+0),DE
 241+ 63DC              	; comma
 242+ 63DC CD DD 67     	CALL CHKCHAR
 243+ 63DF 2C           	DB ','
 244+ 63E0              	; get y
 245+ 63E0 DD 21 2F 54  	LD IX, FRMQNT
 246+ 63E4 CD 59 01     	CALL CALBAS
 247+ 63E7 ED 53 D0 64  	LD (BLIT_STRUCT+2),DE
 248+ 63EB              	; comma
 249+ 63EB CD DD 67     	CALL CHKCHAR
 250+ 63EE 2C           	DB ','
 251+ 63EF              	; get width
 252+ 63EF DD 21 2F 54  	LD IX, FRMQNT
 253+ 63F3 CD 59 01     	CALL CALBAS
 254+ 63F6 ED 53 D2 64  	LD (BLIT_STRUCT+4),DE
 255+ 63FA              	; comma
 256+ 63FA CD DD 67     	CALL CHKCHAR
 257+ 63FD 2C           	DB ','
 258+ 63FE              	; get height
 259+ 63FE DD 21 2F 54  	LD IX, FRMQNT
 260+ 6402 CD 59 01     	CALL CALBAS
 261+ 6405 ED 53 D4 64  	LD (BLIT_STRUCT+6),DE
 262+ 6409              	; comma
 263+ 6409 CD DD 67     	CALL CHKCHAR
 264+ 640C 2C           	DB ','
 265+ 640D              	; get number of items in a list
 266+ 640D DD 21 1C 52  	LD IX, GETBYT
 267+ 6411 CD 59 01     	CALL CALBAS
 268+ 6414 32 D6 64     	LD (BLIT_STRUCT+8),A
 269+ 6417              	; comma
 270+ 6417 CD DD 67     	CALL CHKCHAR
 271+ 641A 2C           	DB ','
 272+ 641B              	; get address of rectangle structure array DIM R%(7,n)
 273+ 641B 3A D6 64     	LD A,(BLIT_STRUCT+8)
 274+ 641E 5F               LD E,A
 275+ 641F 3E 02            LD A,2
 276+ 6421 47           	LD B,A
 277+ 6422 16 07        	LD D,7
 278+ 6424 CD 0A 68     	CALL GET_BASIC_ARRAY_DATA_POINTER
 279+ 6427 ED 43 D7 64  	LD (BLIT_STRUCT+9),BC
 280+ 642B              	; ending )
 281+ 642B CD DD 67     	CALL CHKCHAR
 282+ 642E 29           	DB ')'
 283+ 642F
 284+ 642F E5               PUSH HL
 285+ 6430 CD 6C 63         CALL FIND_OVERLAP
 286+ 6433 2A D9 64         LD HL,(BLIT_STRUCT+11)
 287+ 6436 38 06            JR C,.NOTFOUND
 288+ 6438 77               LD (HL),A
 289+ 6439 23               INC HL
 290+ 643A 36 00            LD (HL),0
 291+ 643C E1               POP HL
 292+ 643D C9               RET
 293+ 643E              .NOTFOUND:
 294+ 643E 36 FF            LD (HL),#FF
 295+ 6440 23               INC HL
 296+ 6441 36 FF            LD (HL),#FF
 297+ 6443 E1               POP HL
 298+ 6444 C9               RET
 299+ 6445              ; ************************************************************************************************
 300+ 6445               ENDIF
 301+ 6445
 302+ 6445               IF (DEFUSR_EXTENSION == 1)
 303+ 6445              ; *******************************************************************************************************
 304+ 6445              ; same as COLL but for DEFUSR approach
 305+ 6445              ; input IX=pointer to input array, real data from +2
 306+ 6445              ; +02 = pointer to result variable
 307+ 6445              ; +04 = player X
 308+ 6445              ; +06 = player Y
 309+ 6445              ; +08 = player width
 310+ 6445              ; +10 = player height
 311+ 6445              ; +12 = number of list items
 312+ 6445              ; +14 = pointer to list of collidable objects
 313+ 6445              COLL_DEFUSR:
 314+ 6445 DD E5            PUSH IX
 315+ 6447 E1               POP HL
 316+ 6448 23          > INC HL ; skip over to player x
 316+ 6449 23          > INC HL
 316+ 644A 23          > INC HL
 316+ 644B 23          > INC HL
 317+ 644C 11 CE 64         LD DE,BLIT_STRUCT
 318+ 644F 01 09 00         LD BC,9
 319+ 6452 ED B0            LDIR ; copy over x,y,w,h,list item number
 320+ 6454 DD 7E 0E         LD A,(IX+14)
 321+ 6457 32 D7 64         LD (BLIT_STRUCT+9),A
 322+ 645A DD 7E 0F         LD A,(IX+15)
 323+ 645D 32 D8 64         LD (BLIT_STRUCT+10),A ; address to collidable objects array
 324+ 6460 DD 7E 02         LD A,(IX+2)
 325+ 6463 32 D9 64         LD (BLIT_STRUCT+11),A
 326+ 6466 DD 7E 03         LD A,(IX+3)
 327+ 6469 32 DA 64         LD (BLIT_STRUCT+12),A ; address to results variable
 328+ 646C DD E5            PUSH IX
 329+ 646E CD 6C 63         CALL FIND_OVERLAP
 330+ 6471 DD E1            POP IX
 331+ 6473 DD 6E 02         LD L,(IX+2)
 332+ 6476 DD 66 03         LD H,(IX+3)
 333+ 6479 38 05            JR C,.NOTFOUND
 334+ 647B 77               LD (HL),A
 335+ 647C 23               INC HL
 336+ 647D 36 00            LD (HL),0
 337+ 647F C9               RET
 338+ 6480              .NOTFOUND:
 339+ 6480 36 FF            LD (HL),#FF
 340+ 6482 23               INC HL
 341+ 6483 36 FF            LD (HL),#FF
 342+ 6485 C9               RET
 343+ 6486              ; *******************************************************************************************************
 344+ 6486               ENDIF
 345+ 6486
# file closed: asm\COLLISION.asm
 167  6486               ENDIF
 168  6486
 169  6486               IF (DEFUSR_EXTENSION == 1)
 170  6486               INCLUDE "DEFUSR.asm"
# file opened: asm\DEFUSR.asm
   1+ 6486              ; entry function that handles call using CALLF
   2+ 6486              ; pointer to data structure is expected at DAC+2
   3+ 6486              ; first entry must be function id followed by function specific parameters
   4+ 6486
   5+ 6486              DEFUSR_TABLE_ENTRIES    EQU 21
   6+ 6486
   7+ 6486              DEFUSR_JUMP_TABLE:
   8+ 6486               IF (SPRITE_CMDS == 1)
   9+ 6486 B5 4E         DW SPRENABLE_DEFUSR        ; 0
  10+ 6488               ELSE
  11+ 6488 ~             DW NOACTION_DEFUSR
  12+ 6488               ENDIF
  13+ 6488
  14+ 6488               IF (SPRITE_CMDS == 1)
  15+ 6488 D5 4E         DW SPRDISABLE_DEFUSR        ; 1
  16+ 648A               ELSE
  17+ 648A ~             DW NOACTION_DEFUSR
  18+ 648A               ENDIF
  19+ 648A
  20+ 648A               IF (RAM_CMDS == 1)
  21+ 648A 56 59         DW MEMCPY_DEFUSR           ; 2
  22+ 648C               ELSE
  23+ 648C ~             DW NOACTION_DEFUSR
  24+ 648C               ENDIF
  25+ 648C
  26+ 648C               IF (VRAM_CMDS == 1)        ; 3
  27+ 648C 79 5B         DW MEMVRM_DEFUSR
  28+ 648E               ELSE
  29+ 648E ~             DW NOACTION_DEFUSR
  30+ 648E               ENDIF
  31+ 648E
  32+ 648E               IF (BLIT_CMDS == 1)        ; 4
  33+ 648E 2A 5F         DW BLIT_DEFUSR
  34+ 6490               ELSE
  35+ 6490 ~             DW NOACTION_DEFUSR
  36+ 6490               ENDIF
  37+ 6490
  38+ 6490               IF (ANIM_CMDS == 1)        ; 5
  39+ 6490 E9 57         DW SGAM_DEFUSR
  40+ 6492               ELSE
  41+ 6492 ~             DW NOACTION_DEFUSR
  42+ 6492               ENDIF
  43+ 6492
  44+ 6492               IF (SPRITE_CMDS == 1)
  45+ 6492 7A 4F         DW SPRGRPMOV_DEFUSR        ; 6
  46+ 6494               ELSE
  47+ 6494 ~             DW NOACTION_DEFUSR
  48+ 6494               ENDIF
  49+ 6494
  50+ 6494               IF (COLL_CMD == 1)
  51+ 6494 45 64         DW COLL_DEFUSR             ; 7
  52+ 6496               ELSE
  53+ 6496 ~             DW NOACTION_DEFUSR
  54+ 6496               ENDIF
  55+ 6496
  56+ 6496               IF (SOUND_CMDS == 1)
  57+ 6496 B0 5A         DW SNDSFX_DEFUSR             ; 8
  58+ 6498               ELSE
  59+ 6498 ~             DW NOACTION_DEFUSR
  60+ 6498               ENDIF
  61+ 6498
  62+ 6498               IF (ANIM_CMDS == 1)
  63+ 6498 D6 55         DW ANIMSTEP_SINGLE_DEFUSR      ; 9
  64+ 649A E6 55         DW ANIMSTEP_MULTI_DEFUSR       ; 10
  65+ 649C F7 55         DW ANIMSTART_SINGLE_DEFUSR     ; 11
  66+ 649E 09 56         DW ANIMSTART_MULTI_DEFUSR      ; 12
  67+ 64A0 0E 56         DW ANIMSTOP_SINGLE_DEFUSR      ; 13
  68+ 64A2 18 56         DW ANIMSTOP_MULTI_DEFUSR       ; 14
  69+ 64A4               ELSE
  70+ 64A4 ~             DW NOACTION_DEFUSR
  71+ 64A4 ~             DW NOACTION_DEFUSR
  72+ 64A4 ~             DW NOACTION_DEFUSR
  73+ 64A4 ~             DW NOACTION_DEFUSR
  74+ 64A4 ~             DW NOACTION_DEFUSR
  75+ 64A4 ~             DW NOACTION_DEFUSR
  76+ 64A4               ENDIF
  77+ 64A4
  78+ 64A4               IF (BOX_CMDS == 1)
  79+ 64A4 C8 5C         DW BOXMEMCPY_DEFUSR            ; 15
  80+ 64A6 6B 5D         DW BOXMEMVRM_DEFUSR            ; 16
  81+ 64A8               ELSE
  82+ 64A8 ~             DW NOACTION_DEFUSR
  83+ 64A8 ~             DW NOACTION_DEFUSR
  84+ 64A8               ENDIF
  85+ 64A8
  86+ 64A8               IF (ANIM_CMDS == 1)
  87+ 64A8 DA 4F         DW MAXANIMITEMS_DEFUSR         ; 17
  88+ 64AA 6F 51         DW MAXANIMDEFS_DEFUSR          ; 18
  89+ 64AC 0A 52         DW MAXANIMSPRS_DEFUSR          ; 19
  90+ 64AE 59 53         DW MAXAUTOSGAMS_DEFUSR         ; 20
  91+ 64B0               ELSE
  92+ 64B0 ~             DW NOACTION_DEFUSR
  93+ 64B0 ~             DW NOACTION_DEFUSR
  94+ 64B0 ~             DW NOACTION_DEFUSR
  95+ 64B0 ~             DW NOACTION_DEFUSR
  96+ 64B0               ENDIF
  97+ 64B0
  98+ 64B0              DEFUSR_ENTRY:
  99+ 64B0 FB               EI
 100+ 64B1 DD 2A F8 F7      LD IX,(DAC+2)
 101+ 64B5 DD 7E 00         LD A,(IX)
 102+ 64B8 FE 15            CP DEFUSR_TABLE_ENTRIES
 103+ 64BA D0               RET NC ; return if an undefined function requested
 104+ 64BB 26 00            LD H,0
 105+ 64BD 6F               LD L,A
 106+ 64BE 29               ADD HL,HL
 107+ 64BF 11 86 64         LD DE,DEFUSR_JUMP_TABLE
 108+ 64C2 19               ADD HL,DE
 109+ 64C3 EB               EX DE,HL
 110+ 64C4 1A               LD A,(DE)
 111+ 64C5 6F               LD L,A
 112+ 64C6 13               INC DE
 113+ 64C7 1A               LD A,(DE)
 114+ 64C8 67               LD H,A
 115+ 64C9 E9               JP (HL) ; call function with IX=pointer to data array
 116+ 64CA
# file closed: asm\DEFUSR.asm
 171  64CA               ENDIF
 172  64CA
 173  64CA              ; temp variables for BLIT, TILE functions
 174  64CA               IF (BLIT_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS + COLL_CMD > 0)
 175  64CA              BLIT_TMP:
 176  64CA              TILETMP1:
 177  64CA              BLIT_TMP1:
 178  64CA 00 00         DW 0
 179  64CC              TILETMP2:
 180  64CC              BLIT_TMP2:
 181  64CC 00 00         DW 0
 182  64CE                IFDEF CMDS_WITH_PARAMETERS
 183  64CE              BLIT_STRUCT:
 184  64CE 00 00 00...   DS 17
 185  64D2                ENDIF
 186  64D2               ENDIF
 187  64DF
 188  64DF               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 189  64DF              VRAM_UPDATE_IN_PROGRESS:
 190  64DF 00            DB 0
 191  64E0               ENDIF
 192  64E0
 193  64E0              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 194  64E0              ; per starting letter, if no commands with this letter, NULL value
 195  64E0              CMDS:
 196  64E0 1E 66        	DW CMDS_A ; always present due to ARTINFO
 197  64E2               IF (BLIT_CMDS + BOX_CMDS > 0) && (BASIC_EXTENSION == 1)
 198  64E2 E1 65            DW CMDS_B ; B
 199  64E4               ELSE
 200  64E4 ~            	DW 0
 201  64E4               ENDIF
 202  64E4               IF (COLL_CMD == 1) && (BASIC_EXTENSION == 1)
 203  64E4 16 66        	DW CMDS_C ;
 204  64E6               ELSE
 205  64E6 ~                DW 0 ; C
 206  64E6               ENDIF
 207  64E6 00 00            DW 0 ; D
 208  64E8 00 00            DW 0 ; E
 209  64EA               IF (VRAM_CMDS + RAM_CMDS > 0) && (BASIC_EXTENSION == 1)
 210  64EA 61 65            DW CMDS_F; F
 211  64EC               ELSE
 212  64EC ~            	DW 0
 213  64EC               ENDIF
 214  64EC               IF (GENCAL_CMD > 0) && (BASIC_EXTENSION == 1)
 215  64EC 74 65            DW CMDS_G; G
 216  64EE               ELSE
 217  64EE ~            	DW 0
 218  64EE               ENDIF
 219  64EE 00 00            DW 0 ; H
 220  64F0 00 00            DW 0 ; I
 221  64F2 00 00            DW 0 ; J
 222  64F4 00 00            DW 0 ; K
 223  64F6 00 00            DW 0 ; L
 224  64F8               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0) && (BASIC_EXTENSION == 1)
 225  64F8 14 65            DW CMDS_M ; M
 226  64FA               ELSE
 227  64FA ~            	DW 0
 228  64FA               ENDIF
 229  64FA 00 00            DW 0 ; N
 230  64FC 00 00            DW 0 ; O
 231  64FE 00 00            DW 0 ; P
 232  6500 00 00            DW 0 ; Q
 233  6502 00 00            DW 0 ; R
 234  6504               IF (SOUND_CMDS + SPRITE_CMDS > 0) && (BASIC_EXTENSION == 1)
 235  6504 88 65            DW CMDS_S ; S
 236  6506               ELSE
 237  6506 ~            	DW 0
 238  6506               ENDIF
 239  6506               IF (TILE_CMDS > 0) && (BASIC_EXTENSION == 1)
 240  6506 01 66            DW CMDS_T ; T
 241  6508               ELSE
 242  6508 ~            	DW 0
 243  6508               ENDIF
 244  6508 00 00            DW 0 ; U
 245  650A               IF (VRAM_CMDS > 0) && (BASIC_EXTENSION == 1)
 246  650A 7E 65            DW CMDS_V ; V
 247  650C               ELSE
 248  650C ~            	DW 0
 249  650C               ENDIF
 250  650C 00 00            DW 0 ; W
 251  650E 00 00            DW 0 ; X
 252  6510 00 00            DW 0 ; Y
 253  6512 00 00            DW 0 ; Z
 254  6514
 255  6514               IF (BASIC_EXTENSION == 1)
 256  6514              CMDS_M:
 257  6514               IF (VRAM_CMDS == 1)
 258  6514 4D 45 4D 56      DB "MEMVRM", 0
 258  6518 52 4D 00
 259  651B 23 5B            DW MEMVRM
 260  651D               ENDIF
 261  651D               IF (RAM_CMDS == 1)
 262  651D 4D 45 4D 43  	DB "MEMCPY", 0
 262  6521 50 59 00
 263  6524 12 59        	DW MEMCPY
 264  6526               ENDIF
 265  6526               IF (ANIM_CMDS == 1)
 266  6526 4D 41 58 41  	DB "MAXANIMITEMS",0
 266  652A 4E 49 4D 49
 266  652E 54 45 4D 53
 266  6532 00
 267  6533 DF 4F        	DW MAXANIMITEMS
 268  6535 4D 41 58 41  	DB "MAXANIMDEFS",0
 268  6539 4E 49 4D 44
 268  653D 45 46 53 00
 269  6541 74 51        	DW MAXANIMDEFS
 270  6543 4D 41 58 41  	DB "MAXANIMSPRS",0
 270  6547 4E 49 4D 53
 270  654B 50 52 53 00
 271  654F 0F 52        	DW MAXANIMSPRS
 272  6551 4D 41 58 41     DB "MAXAUTOSGAMS",0
 272  6555 55 54 4F 53
 272  6559 47 41 4D 53
 272  655D 00
 273  655E 5E 53           DW MAXAUTOSGAMS
 274  6560               ENDIF
 275  6560               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 276  6560 00           	DB 0
 277  6561               ENDIF
 278  6561              CMDS_F:
 279  6561               IF (VRAM_CMDS == 1)
 280  6561 46 49 4C 56      DB "FILVRM", 0
 280  6565 52 4D 00
 281  6568 D4 5A            DW FILVRM
 282  656A               ENDIF
 283  656A               IF (RAM_CMDS == 1)
 284  656A 46 49 4C 52      DB "FILRAM", 0
 284  656E 41 4D 00
 285  6571 78 59            DW FILRAM
 286  6573               ENDIF
 287  6573               IF (VRAM_CMDS + RAM_CMDS > 0)
 288  6573 00               DB 0
 289  6574               ENDIF
 290  6574              CMDS_G:
 291  6574               IF (GENCAL_CMD == 1)
 292  6574 47 45 4E 43      DB "GENCAL", 0
 292  6578 41 4C 00
 293  657B 2F 5C            DW GENCAL
 294  657D               ENDIF
 295  657D               IF (GENCAL_CMD > 0)
 296  657D 00           	DB	0
 297  657E               ENDIF
 298  657E              CMDS_V:
 299  657E               IF (VRAM_CMDS == 1)
 300  657E 56 52 4D 4D  	DB "VRMMEM", 0
 300  6582 45 4D 00
 301  6585 CD 5B        	DW VRMMEM
 302  6587               ENDIF
 303  6587               IF (VRAM_CMDS > 0)
 304  6587 00           	DB 0
 305  6588               ENDIF
 306  6588              CMDS_S:
 307  6588               IF (SPRITE_CMDS + ANIM_CMDS > 0)
 308  6588 53 47 41 4D      DB "SGAM",0
 308  658C 00
 309  658D 45 57            DW SGAM
 310  658F               ENDIF
 311  658F               IF (SPRITE_CMDS == 1)
 312  658F 53 50 52 47  	DB "SPRGRPMOV", 0
 312  6593 52 50 4D 4F
 312  6597 56 00
 313  6599 18 4F        	DW SPRGRPMOV
 314  659B               ENDIF
 315  659B               IF (SOUND_CMDS == 1)
 316  659B 53 4E 44 53  	DB "SNDSFX", 0
 316  659F 46 58 00
 317  65A2 56 5A        	DW SNDSFX
 318  65A4 53 4E 44 50  	DB "SNDPLYON", 0
 318  65A8 4C 59 4F 4E
 318  65AC 00
 319  65AD 20 5A        	DW SNDPLYON
 320  65AF 53 4E 44 50  	DB "SNDPLYOFF", 0
 320  65B3 4C 59 4F 46
 320  65B7 46 00
 321  65B9 33 5A        	DW SNDPLYOFF
 322  65BB 53 4E 44 50  	DB "SNDPLYINI", 0
 322  65BF 4C 59 49 4E
 322  65C3 49 00
 323  65C5 D6 59        	DW SNDPLYINIT
 324  65C7               ENDIF
 325  65C7               IF (SPRITE_CMDS == 1)
 326  65C7 53 50 52 45  	DB "SPRENABLE", 0
 326  65CB 4E 41 42 4C
 326  65CF 45 00
 327  65D1 6E 4E        	DW SPRENABLE
 328  65D3 53 50 52 44  	DB "SPRDISABLE", 0
 328  65D7 49 53 41 42
 328  65DB 4C 45 00
 329  65DE D5 4E        	DW SPRDISABLE
 330  65E0               ENDIF
 331  65E0               IF (SOUND_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 332  65E0 00           	DB 0
 333  65E1               ENDIF
 334  65E1              CMDS_B:
 335  65E1               IF (BLIT_CMDS == 1)
 336  65E1 42 4C 49 54  	DB "BLIT", 0
 336  65E5 00
 337  65E6 C5 5F        	DW BLIT
 338  65E8               ENDIF
 339  65E8               IF (BOX_CMDS == 1)
 340  65E8 42 4F 58 4D  	DB "BOXMEMCPY", 0
 340  65EC 45 4D 43 50
 340  65F0 59 00
 341  65F2 BE 5C        	DW BOXMEMCPY
 342  65F4 42 4F 58 4D  	DB "BOXMEMVRM", 0
 342  65F8 45 4D 56 52
 342  65FC 4D 00
 343  65FE 61 5D        	DW BOXMEMVRM
 344  6600               ENDIF
 345  6600               IF (BLIT_CMDS + BOX_CMDS > 0)
 346  6600 00           	DB 0
 347  6601               ENDIF
 348  6601              CMDS_T:
 349  6601               IF (TILE_CMDS == 1)
 350  6601 54 49 4C 45  	DB "TILERAM", 0
 350  6605 52 41 4D 00
 351  6609 ED 60        	DW TILERAM
 352  660B 54 49 4C 45  	DB "TILEVRM", 0
 352  660F 56 52 4D 00
 353  6613 F1 61        	DW TILEVRM
 354  6615               ENDIF
 355  6615               IF (TILE_CMDS > 0)
 356  6615 00           	DB 0
 357  6616               ENDIF
 358  6616              CMDS_C:
 359  6616               IF (COLL_CMD == 1)
 360  6616 43 4F 4C 4C      DB "COLL", 0
 360  661A 00
 361  661B BE 63            DW COLL
 362  661D               ENDIF
 363  661D               IF (COLL_CMD > 0)
 364  661D 00           	DB	0
 365  661E               ENDIF
 366  661E              CMDS_A:
 367  661E               IF (ANIM_CMDS == 1)
 368  661E 41 4E 49 4D     DB "ANIMSTEP",0
 368  6622 53 54 45 50
 368  6626 00
 369  6627 31 55           DW ANIMSTEP
 370  6629 41 4E 49 4D  	DB "ANIMSTART",0
 370  662D 53 54 41 52
 370  6631 54 00
 371  6633 36 55        	DW ANIMSTART
 372  6635 41 4E 49 4D  	DB "ANIMSTOP",0
 372  6639 53 54 4F 50
 372  663D 00
 373  663E 3B 55        	DW ANIMSTOP
 374  6640 41 4E 49 4D  	DB "ANIMITEMPAT",0
 374  6644 49 54 45 4D
 374  6648 50 41 54 00
 375  664C B0 50        	DW ANIMITEMPAT
 376  664E 41 4E 49 4D  	DB "ANIMITEMPTR",0
 376  6652 49 54 45 4D
 376  6656 50 54 52 00
 377  665A 16 51        	DW ANIMITEMPTR_CMD
 378  665C 41 4E 49 4D  	DB "ANIMDEF",0
 378  6660 44 45 46 00
 379  6664 B7 51        	DW ANIMDEF
 380  6666 41 4E 49 4D  	DB "ANIMSPRITE",0
 380  666A 53 50 52 49
 380  666E 54 45 00
 381  6671 68 52        	DW ANIMSPRITE
 382  6673 41 4E 49 4D     DB "ANIMCHAR",0
 382  6677 43 48 41 52
 382  667B 00
 383  667C E0 52           DW ANIMCHAR
 384  667E 41 55 54 4F     DB "AUTOSGAMDEF",0
 384  6682 53 47 41 4D
 384  6686 44 45 46 00
 385  668A BB 53           DW AUTOSGAMDEF
 386  668C 41 55 54 4F     DB "AUTOSGAMSTART",0
 386  6690 53 47 41 4D
 386  6694 53 54 41 52
 386  6698 54 00
 387  669A F2 54           DW AUTOSGAMSTART
 388  669C 41 55 54 4F     DB "AUTOSGAMSTOP",0
 388  66A0 53 47 41 4D
 388  66A4 53 54 4F 50
 388  66A8 00
 389  66A9 2E 55           DW AUTOSGAMSTOP
 390  66AB               ENDIF
 391  66AB 41 52 54 49     DB "ARTINFO",0
 391  66AF 4E 46 4F 00
 392  66B3 3F 68           DW ARTINFO
 393  66B5 00           	DB 0
 394  66B6               ELSE
 395  66B6 ~            CMDS_A:
 396  66B6 ~             DB "ARTINFO",0
 397  66B6 ~             DW ARTINFO
 398  66B6 ~             DB 0
 399  66B6               ENDIF
 400  66B6
 401  66B6
 402  66B6               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 403  66B6              ; ****************************************************************************************************
 404  66B6              ; function sets VRAM address
 405  66B6              ; input HL=address
 406  66B6              ; modifies AF
 407  66B6              SETWRT_LOCAL:
 408  66B6 7D           	LD	A, L
 409  66B7 D3 99        	OUT	(099H), A
 410  66B9 7C           	LD	A, H
 411  66BA E6 3F        	AND	03FH
 412  66BC F6 40        	OR	040H
 413  66BE D3 99        	OUT	(099H), A
 414  66C0 C9           	RET
 415  66C1              ; ****************************************************************************************************
 416  66C1               ENDIF
 417  66C1
 418  66C1               IF (VRAM_CMDS + TILE_CMDS > 0)
 419  66C1              ; ****************************************************************************************************
 420  66C1              ; function copies data from RAM to VRAM
 421  66C1              ; input HL=address in RAM
 422  66C1              ; input B=count
 423  66C1              ; modifies AF, BC, HL
 424  66C1              BBYTECOPY:
 425  66C1 0E 98        	LD C,#98
 426  66C3              BBYTECOPY_NO_C:
 427  66C3 ED A3        	OUTI
 428  66C5 C2 C3 66     	JP	NZ, BBYTECOPY_NO_C
 429  66C8 C9           	RET
 430  66C9              ; ****************************************************************************************************
 431  66C9               ENDIF
 432  66C9
 433  66C9              ; ****************************************************************************************************
 434  66C9              ; function multiplies HL by 32
 435  66C9              HLx32:
 436  66C9 29           	ADD HL,HL
 437  66CA              ; ****************************************************************************************************
 438  66CA              ; function multiplies HL by 16
 439  66CA              HLx16:
 440  66CA 29           	ADD HL,HL
 441  66CB              ; ****************************************************************************************************
 442  66CB              ; function multiplies HL by 8
 443  66CB              HLx8:
 444  66CB 29          > ADD HL, HL
 444  66CC 29          > ADD HL, HL
 444  66CD 29          > ADD HL, HL
 445  66CE C9           	RET
 446  66CF              ; ****************************************************************************************************
 447  66CF
 448  66CF              ; ****************************************************************************************************
 449  66CF              ; function gets slot and subslot data for specific page
 450  66CF              ; input A=page (0, 1 or 2)
 451  66CF              ; output B = 0A8H register value
 452  66CF              ; output D = 0 is no subslots, 1 if yes
 453  66CF              ; output C = 0A8H value when page 3 slot equals to requested page slot
 454  66CF              ; output E = subslot value if present
 455  66CF              ; modifies AF, BC, DE, HL
 456  66CF              GET_PAGE_INFO:
 457  66CF 6F               LD L, A
 458  66D0 C6 C1            ADD A, low (EXPTBL)
 459  66D2 32 DC 66         LD (GET_PAGE_INFO_L1+1), A
 460  66D5 DB A8            IN A, (0A8H)
 461  66D7 47               LD B, A
 462  66D8 E6 3F            AND 03FH
 463  66DA 4F               LD C, A
 464  66DB              GET_PAGE_INFO_L1:
 465  66DB 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 466  66DE E6 80            AND 080H
 467  66E0 28 1B            JR Z, GET_PAGE_INFO_L2
 468  66E2                  ; expanded
 469  66E2 2D               DEC L
 470  66E3 FA 02 67         JP M, GET_PAGE_INFO_L3
 471  66E6 2D               DEC L
 472  66E7 FA 00 67         JP M, GET_PAGE_INFO_L4
 473  66EA                  ; page 2
 474  66EA 07               RLCA
 475  66EB 07               RLCA
 476  66EC              GET_PAGE_INFO_L5:
 477  66EC E6 C0            AND 0C0H
 478  66EE B1               OR C
 479  66EF D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 480  66F1 4F               LD C, A
 481  66F2 3A FF FF         LD A, (0FFFFH)
 482  66F5 2F               CPL
 483  66F6 5F               LD E, A
 484  66F7 16 01            LD D, 1
 485  66F9 78               LD A, B ; return stack
 486  66FA D3 A8            OUT (0A8H), A
 487  66FC C9               RET
 488  66FD              GET_PAGE_INFO_L2:
 489  66FD                  ; not expanded
 490  66FD 16 00            LD D, 0
 491  66FF C9               RET
 492  6700              GET_PAGE_INFO_L4:
 493  6700                  ; page 1
 494  6700 0F               RRCA
 495  6701 0F               RRCA
 496  6702              GET_PAGE_INFO_L3:
 497  6702                  ; page 0
 498  6702 0F               RRCA
 499  6703 0F               RRCA
 500  6704 18 E6            JR GET_PAGE_INFO_L5
 501  6706              ; ****************************************************************************************************
 502  6706
 503  6706              ; ****************************************************************************************************
 504  6706              ; function returns original slot and subslot info
 505  6706              ; input B = 0A8H register value
 506  6706              ; input D = 0 is no subslots, 1 if yes
 507  6706              ; input C = 0A8H value when page 3 slot equals to requested page slot
 508  6706              ; input E = subslot value if present
 509  6706              ; modifies AF, disables interrupts
 510  6706              RESTORE_PAGE_INFO:
 511  6706 7A              LD A, D
 512  6707 B7              OR A
 513  6708 28 08           JR Z, RESTORE_PAGE_INFO_L1
 514  670A 79              LD A, C
 515  670B F3           	DI
 516  670C D3 A8           OUT (0A8H), A
 517  670E 7B              LD A, E
 518  670F 32 FF FF        LD (0FFFFH), A
 519  6712              RESTORE_PAGE_INFO_L1:
 520  6712 78              LD A, B
 521  6713 D3 A8           OUT (0A8H), A
 522  6715              NOACTION_DEFUSR: ; just a safe RET for use when DEFUSR table has an empty entry
 523  6715 C9              RET
 524  6716              ; ****************************************************************************************************
 525  6716
 526  6716              ; *******************************************************************************************************
 527  6716              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 528  6716              ; INPUT:  A = SLOT ID: EXXXSSPP
 529  6716              ; E = EXPANDED FLAG
 530  6716              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 531  6716              ; PP = PRIMARY SLOT NUMBER
 532  6716              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 533  6716              ; CHANGES: AF, BC, DE
 534  6716
 535  6716              LOCAL_ENASLT:
 536  6716 CD 36 67         CALL L0353
 537  6719 FA 23 67         JP M, L0340
 538  671C DB A8            IN A, (0A8H)
 539  671E A1               AND C
 540  671F B0               OR B
 541  6720 D3 A8            OUT (0A8H), A
 542  6722 C9               RET
 543  6723              L0340:
 544  6723 E5               PUSH HL
 545  6724 CD 5B 67         CALL L0378
 546  6727 4F               LD C, A
 547  6728 06 00            LD B, 0
 548  672A 7D               LD A, L
 549  672B A4               AND H
 550  672C B2               OR D
 551  672D 21 C5 FC         LD HL, 0FCC5H
 552  6730 09               ADD HL, BC
 553  6731 77               LD (HL), A
 554  6732 E1               POP HL
 555  6733 79               LD A, C
 556  6734 18 E0            JR LOCAL_ENASLT
 557  6736              L0353:
 558  6736 F3               DI
 559  6737 F5               PUSH AF
 560  6738 7C               LD A, H
 561  6739 07               RLCA
 562  673A 07               RLCA
 563  673B E6 03            AND 3
 564  673D 5F               LD E, A
 565  673E 3E C0            LD A, 0C0H
 566  6740              L035D:
 567  6740 07               RLCA
 568  6741 07               RLCA
 569  6742 1D               DEC E
 570  6743 F2 40 67         JP P, L035D
 571  6746 5F               LD E, A
 572  6747 2F               CPL
 573  6748 4F               LD C, A
 574  6749 F1               POP AF
 575  674A F5               PUSH AF
 576  674B E6 03            AND 3
 577  674D 3C               INC A
 578  674E 47               LD B, A
 579  674F 3E AB            LD A, 0ABH
 580  6751              L036E:
 581  6751 C6 55            ADD A, 055H
 582  6753 10 FC            DJNZ L036E
 583  6755 57               LD D, A
 584  6756 A3               AND E
 585  6757 47               LD B, A
 586  6758 F1               POP AF
 587  6759 A7               AND A
 588  675A C9               RET
 589  675B              L0378:
 590  675B F5               PUSH AF
 591  675C 7A               LD A, D
 592  675D E6 C0            AND 0C0H
 593  675F 4F               LD C, A
 594  6760 F1               POP AF
 595  6761 F5               PUSH AF
 596  6762 57               LD D, A
 597  6763 DB A8            IN A, (0A8H)
 598  6765 47               LD B, A
 599  6766 E6 3F            AND 03FH
 600  6768 B1               OR C
 601  6769 D3 A8            OUT (0A8H), A
 602  676B 7A               LD A, D
 603  676C 0F               RRCA
 604  676D 0F               RRCA
 605  676E E6 03            AND 3
 606  6770 57               LD D, A
 607  6771 3E AB            LD A, 0ABH
 608  6773              L0390:
 609  6773 C6 55            ADD A, 055H
 610  6775 15               DEC D
 611  6776 F2 73 67         JP P, L0390
 612  6779 A3               AND E
 613  677A 57               LD D, A
 614  677B 7B               LD A, E
 615  677C 2F               CPL
 616  677D 67               LD H, A
 617  677E 3A FF FF         LD A, (0FFFFH)
 618  6781 2F               CPL
 619  6782 6F               LD L, A
 620  6783 A4               AND H
 621  6784 B2               OR D
 622  6785 32 FF FF         LD (0FFFFH), A
 623  6788 78               LD A, B
 624  6789 D3 A8            OUT (0A8H), A
 625  678B F1               POP AF
 626  678C E6 03            AND 3
 627  678E C9               RET
 628  678F              ; *******************************************************************************************************
 629  678F
 630  678F              ; *******************************************************************************************************
 631  678F              ; some common code to activate page 0 and place values needed to restore original page on stack
 632  678F              ; input IY=return address
 633  678F              ENABLE_PAGE0:
 634  678F AF              XOR A
 635  6790 CD CF 66        CALL GET_PAGE_INFO
 636  6793 C5              PUSH BC
 637  6794 D5              PUSH DE
 638  6795 3A 41 F3        LD A, (RAMAD0)
 639  6798 26 00           LD H, 0
 640  679A CD 16 67        CALL LOCAL_ENASLT
 641  679D FD E9        	JP (IY)
 642  679F              ; *******************************************************************************************************
 643  679F
 644  679F              ; General BASIC CALL-instruction handler
 645  679F              CALLHAND:
 646  679F FB              EI
 647  67A0 E5           	PUSH HL
 648  67A1 21 E0 64     	LD	HL, CMDS ; pointer table based on starting letter
 649  67A4 3A 89 FD        LD A, (PROCNM)
 650  67A7 D6 41           SUB 'A'
 651  67A9 87              ADD A, A
 652  67AA 16 00           LD D, 0
 653  67AC 5F              LD E, A
 654  67AD 19              ADD HL, DE
 655  67AE 5E              LD E, (HL)
 656  67AF 23              INC HL
 657  67B0 56              LD D, (HL)
 658  67B1 7A              LD A, D
 659  67B2 B3              OR E
 660  67B3 28 23           JR Z, .CMDNOTRECOGNIZED
 661  67B5 EB              EX DE, HL
 662  67B6              .CHKCMD:
 663  67B6 11 89 FD     	LD	DE, PROCNM
 664  67B9              .LOOP:
 665  67B9 1A              LD	A,(DE)
 666  67BA BE           	CP	(HL)
 667  67BB 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 668  67BD 13           	INC	DE
 669  67BE 23           	INC	HL
 670  67BF A7           	AND	A
 671  67C0 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 672  67C2 5E           	LD	E,(HL)
 673  67C3 23           	INC	HL
 674  67C4 56           	LD	D,(HL)
 675  67C5 E1           	POP	HL		; routine address
 676  67C6 CD E7 67     	CALL	GETPREVCHAR
 677  67C9 CD DB 67     	CALL	.CALLDE		; Call routine
 678  67CC A7           	AND	A
 679  67CD C9           	RET
 680  67CE
 681  67CE              .TONEXTCMD:
 682  67CE 0E FF        	LD	C,0FFH
 683  67D0 AF           	XOR	A
 684  67D1 ED B1        	CPIR			; Skip to end of instruction name
 685  67D3 23           	INC	HL
 686  67D4 23           	INC	HL		; Skip address
 687  67D5 BE           	CP	(HL)
 688  67D6 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 689  67D8              .CMDNOTRECOGNIZED:
 690  67D8 E1           	POP	HL
 691  67D9 37              SCF
 692  67DA C9           	RET
 693  67DB
 694  67DB              .CALLDE:
 695  67DB D5           	PUSH	DE
 696  67DC C9           	RET
 697  67DD
 698  67DD              ;---------------------------
 699  67DD
 700  67DD              ;GETSTRPNT:
 701  67DD              ; OUT:
 702  67DD              ; HL = String Address
 703  67DD              ; B  = Lenght
 704  67DD              ;        LD      HL,(USR)
 705  67DD              ;        LD      B,(HL)
 706  67DD              ;        INC     HL
 707  67DD              ;        LD      E,(HL)
 708  67DD              ;        INC     HL
 709  67DD              ;        LD      D,(HL)
 710  67DD              ;        EX      DE,HL
 711  67DD              ;        RET
 712  67DD
 713  67DD              ;EVALTXTPARAM:
 714  67DD              ;	CALL	CHKCHAR
 715  67DD              ;	DEFB	"("             ; Check for (
 716  67DD              ;	LD	IX,FRMEVL
 717  67DD              ;	CALL	CALBAS		; Evaluate expression
 718  67DD              ;       LD      A,(VALTYP)
 719  67DD              ;        CP      3               ; Text type?
 720  67DD              ;        JP      NZ,TYPE_MISMATCH
 721  67DD              ;        PUSH	HL
 722  67DD              ;        LD	IX,FRESTR         ; Free the temporary string
 723  67DD              ;        CALL	CALBAS
 724  67DD              ;        POP	HL
 725  67DD              ;	CALL	CHKCHAR
 726  67DD              ;	DEFB	")"             ; Check for )
 727  67DD              ;        RET
 728  67DD
 729  67DD
 730  67DD              CHKCHAR:
 731  67DD CD E7 67     	CALL	GETPREVCHAR	; Get previous basic char
 732  67E0 E3           	EX	(SP),HL
 733  67E1 BE           	CP	(HL) 	        ; Check if good char
 734  67E2 20 1D        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 735  67E4 23           	INC	HL
 736  67E5 E3           	EX	(SP),HL
 737  67E6 23           	INC	HL		; Get next basic char
 738  67E7
 739  67E7              GETPREVCHAR:
 740  67E7 2B           	DEC HL
 741  67E8 DD 21 66 46  	LD	IX,CHRGTR
 742  67EC CD 59 01     	CALL CALBAS
 743  67EF FB              EI
 744  67F0 C9              RET
 745  67F1
 746  67F1
 747  67F1              TYPE_MISMATCH:
 748  67F1 1E 0D            LD E, 13 ; Type mismatch
 749  67F3 18 0E            JR THROW_ERROR
 750  67F5              SUBSCRIPT_OUT_OF_RANGE:
 751  67F5 1E 09            LD E,9 ; subscript out of range
 752  67F7 18 0A        	JR THROW_ERROR
 753  67F9              OVERFLOW:
 754  67F9 1E 06        	LD E,6
 755  67FB 18 06        	JR THROW_ERROR
 756  67FD              ILLEGAL_FUNCTION:
 757  67FD 1E 05            LD E, 5 ; illegal function call
 758  67FF 18 02            JR THROW_ERROR
 759  6801              SYNTAX_ERROR:
 760  6801 1E 02            LD E, 2 ; Syntax error
 761  6803              THROW_ERROR:
 762  6803 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 763  6807 C3 59 01     	JP	CALBAS
 764  680A
 765  680A              ;---------------------------
 766  680A
 767  680A              ; *******************************************************************************************************
 768  680A              ; helper function to get pointer to BASIC array data
 769  680A              ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
 770  680A              ; input B=dimensions (1 or 2)
 771  680A              ; input D=minimal first dimension
 772  680A              ; input E=minimal second dimension, if applicable
 773  680A              ; returns BC=pointer to first data element
 774  680A              ; throws BASIC error if invalid type
 775  680A              GET_BASIC_ARRAY_DATA_POINTER:
 776  680A D5           	PUSH DE
 777  680B C5           	PUSH BC
 778  680C F5           	PUSH AF
 779  680D 3E 01           LD A,1
 780  680F 32 A5 F6        LD (SUBFLG),A ; search for arrays only
 781  6812 DD 21 A4 5E  	LD IX, PTRGET
 782  6816 CD 59 01     	CALL CALBAS
 783  6819 AF              XOR A
 784  681A 32 A5 F6        LD (SUBFLG),A ; if not reset will cause syntax errors
 785  681D 3A 63 F6     	LD A,(VALTYP)
 786  6820 D1           	POP DE ; required type
 787  6821 BA           	CP D
 788  6822 C2 F1 67     	JP NZ,TYPE_MISMATCH
 789  6825 0A           	LD A,(BC)
 790  6826 03           	INC BC
 791  6827 D1           	POP DE ; required number of dimensions
 792  6828 BA           	CP D
 793  6829 C2 F1 67     	JP NZ,TYPE_MISMATCH
 794  682C D1           	POP DE ; required minimal array dimensions
 795  682D 3D           	DEC A
 796  682E 28 07        	JR Z,.ONE_DIMENSION
 797  6830              	; 2-dimension array
 798  6830 0A           	LD A,(BC)
 799  6831 03          > INC BC
 799  6832 03          > INC BC
 800  6833 BB           	CP E
 801  6834 DA F5 67     	JP C,SUBSCRIPT_OUT_OF_RANGE
 802  6837              .ONE_DIMENSION:
 803  6837 0A           	LD A,(BC)
 804  6838 03          > INC BC
 804  6839 03          > INC BC
 805  683A BA           	CP D
 806  683B DA F5 67     	JP C,SUBSCRIPT_OUT_OF_RANGE
 807  683E C9           	RET
 808  683F              ; *******************************************************************************************************
 809  683F
 810  683F              ; *******************************************************************************************************
 811  683F              ; function to handle CALL ARTINFO basic extension
 812  683F              ; returns info about the extension
 813  683F              ; _ARTINFO ( INT variable version,
 814  683F              ;			    INT variable build_flags,
 815  683F              ;			    INT variable free_memory_ptr )
 816  683F              ; this function is always available and can be used to test if the extension is active
 817  683F              ARTINFO:
 818  683F              	; opening (
 819  683F CD DD 67     	CALL CHKCHAR
 820  6842 28           	DB '('
 821  6843              	; get address of version variable
 822  6843 DD 21 A4 5E  	LD IX, PTRGET
 823  6847 CD 59 01     	CALL CALBAS
 824  684A 3A 12 40     	LD A,(VERSION)
 825  684D 12              LD (DE),A
 826  684E 13              INC DE
 827  684F 3A 13 40        LD A,(VERSION+1)
 828  6852 12              LD (DE),A
 829  6853              	; comma
 830  6853 CD DD 67     	CALL CHKCHAR
 831  6856 2C           	DB ','
 832  6857              	; get address of build flags variable
 833  6857 DD 21 A4 5E  	LD IX, PTRGET
 834  685B CD 59 01     	CALL CALBAS
 835  685E E5              PUSH HL
 836  685F 21 FF 0F        LD HL,SOUND_CMDS+2*RAM_CMDS+4*VRAM_CMDS+8*BLIT_CMDS+16*SPRITE_CMDS+32*GENCAL_CMD+64*TILE_CMDS+128*BOX_CMDS+256*ANIM_CMDS+512*COLL_CMD+1024*BASIC_EXTENSION+2048*DEFUSR_EXTENSION
 837  6862 EB              EX DE,HL
 838  6863 73              LD (HL),E
 839  6864 23              INC HL
 840  6865 72              LD (HL),D
 841  6866 E1              POP HL
 842  6867              	; comma
 843  6867 CD DD 67     	CALL CHKCHAR
 844  686A 2C           	DB ','
 845  686B              	; get address of free memory variable
 846  686B DD 21 A4 5E  	LD IX, PTRGET
 847  686F CD 59 01     	CALL CALBAS
 848  6872 3A 10 40     	LD A,(FREEMEMPTR)
 849  6875 12              LD (DE),A
 850  6876 13              INC DE
 851  6877 3A 11 40        LD A,(FREEMEMPTR+1)
 852  687A 12              LD (DE),A
 853  687B              	; ending )
 854  687B CD DD 67     	CALL CHKCHAR
 855  687E 29           	DB ')'
 856  687F C9           	RET
 857  6880              ; *******************************************************************************************************
 858  6880
 859  6880              EXT_END:
 860  6880
# file closed: asm\main.asm
