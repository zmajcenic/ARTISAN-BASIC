# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		   EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000              COLL_CMD       EQU 1
  14  4000
  15  4000              BASIC_EXTENSION   EQU 1
  16  4000              DEFUSR_EXTENSION  EQU 1
  17  4000
  18  4000               DEFINE CMDS_WITH_PARAMETERS
  19  4000
  20  4000              CHPUT   EQU    #A2
  21  4000              CALBAS  EQU		#159
  22  4000              ERRHAND EQU    #406F
  23  4000              FRMEVL  EQU    #4C64
  24  4000              FRESTR  EQU		#67D0
  25  4000              ; FRMQNT = formula quantificator
  26  4000              ; input HL=pointer to current program expression
  27  4000              ; output HL=next address
  28  4000              ; output DE=integer datum
  29  4000              FRMQNT	EQU		#542F
  30  4000              ; GETBYT = get byte parameter
  31  4000              ; input HL=pointer to current program expression
  32  4000              ; output HL=next address
  33  4000              ; output A=E=byte read
  34  4000              GETBYT		EQU	#521C
  35  4000              CHRGTR  	   EQU   #4666
  36  4000              PTRGET		EQU 	#5EA4
  37  4000              SUBFLG		EQU	#F6A5
  38  4000              SYNCHR		EQU	#558C
  39  4000              VALTYP  	   EQU   #F663
  40  4000              DAC         EQU   #F7F6
  41  4000              USR     	   EQU   #F7F8
  42  4000              PROCNM		EQU	#FD89
  43  4000              BIOS_FILVRM EQU   #0056
  44  4000              CLIKSW		EQU	#F3DB
  45  4000
  46  4000              RAMAD0	   EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  47  4000              RAMAD1	   EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  48  4000              RAMAD2	   EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  49  4000              RAMAD3	   EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  50  4000              EXPTBL	   EQU   #FCC1
  51  4000              SCRMOD	   EQU   #FCAF ; current screen mode
  52  4000              REG1SAV     EQU   #F3E0 ; VDP(1)
  53  4000              JIFFY	      EQU   #FC9E
  54  4000              GRPPAT	   EQU   #F3CF ; SCREEN 2 sprite generator table address
  55  4000              GRPCGP		EQU	#F3CB ; SCREEN 2 pattern generator table address
  56  4000              GRPATR      EQU   #F3CD ; SCREEN 2 sprite attribute table address
  57  4000              T32PAT	   EQU   #F3C5 ; SCREEN 1 sprite generator table address
  58  4000              T32CGP      EQU   #F3C1 ; SCREEN 1 pattern ganarator table address
  59  4000              T32ATR      EQU   #F3C3 ; SCREEN 1 sprite attribute table address
  60  4000
  61  4000              ; BASIC error codes
  62  4000              ;01 NEXT without FOR
  63  4000              ;02 Syntax error
  64  4000              ;03 RETURN without GOSUB
  65  4000              ;04 Out of DATA
  66  4000              ;05 Illegal function call
  67  4000              ;06 Overflow
  68  4000              ;07 Out of memory
  69  4000              ;08 Undefined line number
  70  4000              ;09 Subscript out of range
  71  4000              ;10 Redimensioned array
  72  4000              ;11 Division by zero
  73  4000              ;12 Illegal direct
  74  4000              ;13 Type mismatch
  75  4000              ;14 Out of string space
  76  4000              ;15 String too long
  77  4000              ;16 String formula too complex
  78  4000              ;17 Can't CONTINUE
  79  4000              ;18 Undefined user function
  80  4000              ;19 Device I/O error
  81  4000              ;20 Verify error
  82  4000              ;21 No RESUME
  83  4000              ;22 RESUME without error
  84  4000              ;23 Unprintable error
  85  4000              ;24 Missing operand
  86  4000              ;25 Line buffer overflow
  87  4000              ;50 FIELD overflow
  88  4000              ;51 Internal error
  89  4000              ;52 Bad file number
  90  4000              ;53 File not found
  91  4000              ;54 File already open
  92  4000              ;55 Input past end
  93  4000              ;56 Bad file name
  94  4000              ;57 Direct statement in file
  95  4000              ;58 Sequential I/O only
  96  4000              ;59 File not OPEN
  97  4000
  98  4000
  99  4000               ; simulate cartridge with BASIC extension
 100  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
 100  4004 8C 65 00 00
 100  4008 00 00 00 00
 100  400C 00 00 00 00
 101  4010
 102  4010              ; this location #4010 stores last location used by basic extension
 103  4010              ; free memory after that point
 104  4010              FREEMEMPTR:
 105  4010 2C 66         DW EXT_END
 106  4012
 107  4012              ; this location #4012 stores extension version in DAA format
 108  4012              ; first byte is major version and second minor
 109  4012              VERSION:
 110  4012 00 81         DB #00, #81
 111  4014
 112  4014              ; this location #4014 contains a jump to entry point for DEFUSR approach
 113  4014              ; if excluded it contains 3xRET so that sound player can be at aspecific spot
 114  4014               IF (DEFUSR_EXTENSION == 1)
 115  4014 C3 A7 62        JP DEFUSR_ENTRY
 116  4017               ELSE
 117  4017 ~               .3 RET
 118  4017               ENDIF
 119  4017
 120  4017              ; binary included AKG player compiled at #4017
 121  4017               IF (SOUND_CMDS == 1)
 122  4017              	INCBIN "bin/AKG.bin"
 123  4CF3              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF3              MAIN_PLAYER_START EQU 04017H
   2+ 4CF3              PLY_AKG_START EQU 04017H
   3+ 4CF3              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 04020H
   4+ 4CF3              PLY_AKG_INITSOUNDEFFECTS EQU 04020H
   5+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04024H
   6+ 4CF3              PLY_AKG_PLAYSOUNDEFFECT EQU 04024H
   7+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04025H
   8+ 4CF3              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04025H
   9+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 0404CH
  10+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 0404CH
  11+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 0405AH
  12+ 4CF3              PLY_AKG_PSES_PLAY EQU 04093H
  13+ 4CF3              PLY_AKG_PSES_READFIRSTBYTE EQU 0409CH
  14+ 4CF3              PLY_AKG_PSES_S_ENDORLOOP EQU 040B4H
  15+ 4CF3              PLY_AKG_PSES_S_LOOP EQU 040BFH
  16+ 4CF3              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C5H
  17+ 4CF3              PLY_AKG_PSES_NOTREACHED EQU 040D8H
  18+ 4CF3              PLY_AKG_PSES_HARDWAREONLY EQU 040DCH
  19+ 4CF3              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E3H
  20+ 4CF3              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F5H
  21+ 4CF3              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FFH
  22+ 4CF3              PLY_AKG_PSES_H_AFTERRETRIG EQU 04109H
  23+ 4CF3              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411DH
  24+ 4CF3              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 04122H
  25+ 4CF3              PLY_AKG_PSES_READHARDWAREPERIOD EQU 0412AH
  26+ 4CF3              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04135H
  27+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 04141H
  28+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04143H
  29+ 4CF3              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04149H
  30+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414DH
  31+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414DH
  32+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414FH
  33+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414FH
  34+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414FH
  35+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 04150H
  36+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 04151H
  37+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04155H
  38+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04155H
  39+ 4CF3              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04155H
  40+ 4CF3              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415DH
  41+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04165H
  42+ 4CF3              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04165H
  43+ 4CF3              PLY_AKG_INIT EQU 04165H
  44+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04165H
  45+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04193H
  46+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A7H
  47+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B9H
  48+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D8H
  49+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E5H
  50+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL EQU 041EBH
  51+ 4CF3              PLY_AKG_INITTABLE0 EQU 041EEH
  52+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EEH
  53+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04208H
  54+ 4CF3              PLY_AKG_INITTABLE0_END EQU 04208H
  55+ 4CF3              PLY_AKG_INITTABLE1 EQU 04208H
  56+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04208H
  57+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 0420CH
  58+ 4CF3              PLY_AKG_INITTABLE1_END EQU 0420CH
  59+ 4CF3              PLY_AKG_INITTABLEORA EQU 0420CH
  60+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 0420CH
  61+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04224H
  62+ 4CF3              PLY_AKG_INITTABLEORA_END EQU 04224H
  63+ 4CF3              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04224H
  64+ 4CF3              PLY_AKG_STOP EQU 04224H
  65+ 4CF3              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04236H
  66+ 4CF3              PLY_AKG_PLAY EQU 04236H
  67+ 4CF3              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423EH
  68+ 4CF3              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04244H
  69+ 4CF3              PLY_AKG_READLINKER EQU 04249H
  70+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04249H
  71+ 4CF3              PLY_AKG_READLINKER_PTLINKER EQU 04249H
  72+ 4CF3              PLY_AKG_READLINKER_NOLOOP EQU 04254H
  73+ 4CF3              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428DH
  74+ 4CF3              PLY_AKG_READLINE EQU 04290H
  75+ 4CF3              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 04290H
  76+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04296H
  77+ 4CF3              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04296H
  78+ 4CF3              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A3H
  79+ 4CF3              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A7H
  80+ 4CF3              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042AAH
  81+ 4CF3              PLY_AKG_SPEEDTRACK_END EQU 042ADH
  82+ 4CF3              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042ADH
  83+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B3H
  84+ 4CF3              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B3H
  85+ 4CF3              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042C0H
  86+ 4CF3              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C4H
  87+ 4CF3              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C7H
  88+ 4CF3              PLY_AKG_EVENTTRACK_END EQU 042CAH
  89+ 4CF3              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042CAH
  90+ 4CF3              PLY_AKG_CHANNEL1_READTRACK EQU 042D6H
  91+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D6H
  92+ 4CF3              PLY_AKG_CHANNEL1_PTTRACK EQU 042D6H
  93+ 4CF3              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042F1H
  94+ 4CF3              PLY_AKG_CHANNEL1_WAIT EQU 042FCH
  95+ 4CF3              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04303H
  96+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04303H
  97+ 4CF3              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04303H
  98+ 4CF3              PLY_AKG_CHANNEL1_NOTE EQU 0430CH
  99+ 4CF3              PLY_AKG_BASENOTEINDEX EQU 0430CH
 100+ 4CF3              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430EH
 101+ 4CF3              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430EH
 102+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431EH
 103+ 4CF3              PLY_AKG_INSTRUMENTSTABLE EQU 0431EH
 104+ 4CF3              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 04330H
 105+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 04340H
 106+ 4CF3              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04368H
 107+ 4CF3              PLY_AKG_CHANNEL1_READCELLEND EQU 0436BH
 108+ 4CF3              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 0436BH
 109+ 4CF3              PLY_AKG_CHANNEL2_READTRACK EQU 04377H
 110+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04377H
 111+ 4CF3              PLY_AKG_CHANNEL2_PTTRACK EQU 04377H
 112+ 4CF3              PLY_AKG_CHANNEL2_SMALLWAIT EQU 04392H
 113+ 4CF3              PLY_AKG_CHANNEL2_WAIT EQU 0439DH
 114+ 4CF3              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A4H
 115+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A4H
 116+ 4CF3              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A4H
 117+ 4CF3              PLY_AKG_CHANNEL2_NOTE EQU 043ADH
 118+ 4CF3              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043B2H
 119+ 4CF3              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043B2H
 120+ 4CF3              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D4H
 121+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E4H
 122+ 4CF3              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 0440CH
 123+ 4CF3              PLY_AKG_CHANNEL2_READCELLEND EQU 0440FH
 124+ 4CF3              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440FH
 125+ 4CF3              PLY_AKG_CHANNEL3_READTRACK EQU 0441BH
 126+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 0441BH
 127+ 4CF3              PLY_AKG_CHANNEL3_PTTRACK EQU 0441BH
 128+ 4CF3              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04436H
 129+ 4CF3              PLY_AKG_CHANNEL3_WAIT EQU 04441H
 130+ 4CF3              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04448H
 131+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04448H
 132+ 4CF3              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04448H
 133+ 4CF3              PLY_AKG_CHANNEL3_NOTE EQU 04451H
 134+ 4CF3              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04456H
 135+ 4CF3              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04456H
 136+ 4CF3              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04478H
 137+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04488H
 138+ 4CF3              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044B0H
 139+ 4CF3              PLY_AKG_CHANNEL3_READCELLEND EQU 044B3H
 140+ 4CF3              PLY_AKG_CURRENTSPEED EQU 044B3H
 141+ 4CF3              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B5H
 142+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B8H
 143+ 4CF3              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B8H
 144+ 4CF3              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044BBH
 145+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BEH
 146+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BEH
 147+ 4CF3              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044CAH
 148+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044D1H
 149+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D4H
 150+ 4CF3              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044DAH
 151+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DDH
 152+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DDH
 153+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044EBH
 154+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044F0H
 155+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044FBH
 156+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FEH
 157+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FEH
 158+ 4CF3              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 04501H
 159+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04504H
 160+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04504H
 161+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450DH
 162+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04517H
 163+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 0451AH
 164+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 0451AH
 165+ 4CF3              PLY_AKG_CHANNEL1_PITCH EQU 0451AH
 166+ 4CF3              PLY_AKG_CHANNEL1_ISPITCH EQU 0451DH
 167+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 04522H
 168+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACK EQU 04522H
 169+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04526H
 170+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04528H
 171+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 0452AH
 172+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 04531H
 173+ 4CF3              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 04532H
 174+ 4CF3              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04535H
 175+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04535H
 176+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 04551H
 177+ 4CF3              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 04551H
 178+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455EH
 179+ 4CF3              PLY_AKG_CHANNEL1_GLIDEOVER EQU 04562H
 180+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 04572H
 181+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 04572H
 182+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04573H
 183+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04574H
 184+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04576H
 185+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04576H
 186+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04576H
 187+ 4CF3              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04577H
 188+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04578H
 189+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 0457AH
 190+ 4CF3              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 0457AH
 191+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 0457AH
 192+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 0457AH
 193+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 0457AH
 194+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457DH
 195+ 4CF3              PLY_AKG_CHANNEL1_PITCH_END EQU 0457FH
 196+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04587H
 197+ 4CF3              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04587H
 198+ 4CF3              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 0458AH
 199+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458DH
 200+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458DH
 201+ 4CF3              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04599H
 202+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 045A0H
 203+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A3H
 204+ 4CF3              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A9H
 205+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045ACH
 206+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045ACH
 207+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045BAH
 208+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BFH
 209+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045CAH
 210+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CDH
 211+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CDH
 212+ 4CF3              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045D0H
 213+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D3H
 214+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D3H
 215+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045DCH
 216+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E6H
 217+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E9H
 218+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E9H
 219+ 4CF3              PLY_AKG_CHANNEL2_PITCH EQU 045E9H
 220+ 4CF3              PLY_AKG_CHANNEL2_ISPITCH EQU 045ECH
 221+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045F1H
 222+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045F1H
 223+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F5H
 224+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F7H
 225+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F9H
 226+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 04600H
 227+ 4CF3              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 04601H
 228+ 4CF3              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04604H
 229+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04604H
 230+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 04620H
 231+ 4CF3              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 04620H
 232+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462DH
 233+ 4CF3              PLY_AKG_CHANNEL2_GLIDEOVER EQU 04631H
 234+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 04641H
 235+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 04641H
 236+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 04642H
 237+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04643H
 238+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04645H
 239+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04645H
 240+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04645H
 241+ 4CF3              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04646H
 242+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04647H
 243+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04649H
 244+ 4CF3              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04649H
 245+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04649H
 246+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04649H
 247+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04649H
 248+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_END EQU 0464CH
 249+ 4CF3              PLY_AKG_CHANNEL2_PITCH_END EQU 0464EH
 250+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04656H
 251+ 4CF3              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04656H
 252+ 4CF3              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04659H
 253+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 0465CH
 254+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 0465CH
 255+ 4CF3              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04668H
 256+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466FH
 257+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 04672H
 258+ 4CF3              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04678H
 259+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 0467BH
 260+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 0467BH
 261+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04689H
 262+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468EH
 263+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04699H
 264+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 0469CH
 265+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 0469CH
 266+ 4CF3              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469FH
 267+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 046A2H
 268+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE EQU 046A2H
 269+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046ABH
 270+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B5H
 271+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B8H
 272+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B8H
 273+ 4CF3              PLY_AKG_CHANNEL3_PITCH EQU 046B8H
 274+ 4CF3              PLY_AKG_CHANNEL3_ISPITCH EQU 046BBH
 275+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046C0H
 276+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046C0H
 277+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C4H
 278+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C6H
 279+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C8H
 280+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CFH
 281+ 4CF3              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046D0H
 282+ 4CF3              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D3H
 283+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D3H
 284+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046EFH
 285+ 4CF3              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046EFH
 286+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046FCH
 287+ 4CF3              PLY_AKG_CHANNEL3_GLIDEOVER EQU 04700H
 288+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 04710H
 289+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 04710H
 290+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 04711H
 291+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 04712H
 292+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04714H
 293+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04714H
 294+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04714H
 295+ 4CF3              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04715H
 296+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04716H
 297+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04718H
 298+ 4CF3              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04718H
 299+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04718H
 300+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04718H
 301+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04718H
 302+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_END EQU 0471BH
 303+ 4CF3              PLY_AKG_CHANNEL3_PITCH_END EQU 0471DH
 304+ 4CF3              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04729H
 305+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04729H
 306+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04729H
 307+ 4CF3              PLY_AKG_CHANNEL1_TRACKNOTE EQU 0472CH
 308+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472EH
 309+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04734H
 310+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04737H
 311+ 4CF3              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04737H
 312+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 0473AH
 313+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04743H
 314+ 4CF3              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 0474BH
 315+ 4CF3              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04758H
 316+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04758H
 317+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04758H
 318+ 4CF3              PLY_AKG_CHANNEL2_TRACKNOTE EQU 0475BH
 319+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475DH
 320+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04763H
 321+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04766H
 322+ 4CF3              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04766H
 323+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04769H
 324+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 04772H
 325+ 4CF3              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 0477AH
 326+ 4CF3              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04788H
 327+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04788H
 328+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04788H
 329+ 4CF3              PLY_AKG_CHANNEL3_TRACKNOTE EQU 0478BH
 330+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478DH
 331+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04793H
 332+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04796H
 333+ 4CF3              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04796H
 334+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04799H
 335+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 047A2H
 336+ 4CF3              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047AAH
 337+ 4CF3              PLY_AKG_SENDPSGREGISTERS EQU 047B9H
 338+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047C1H
 339+ 4CF3              PLY_AKG_PSGREG01_INSTR EQU 047C1H
 340+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047D1H
 341+ 4CF3              PLY_AKG_PSGREG23_INSTR EQU 047D1H
 342+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047E2H
 343+ 4CF3              PLY_AKG_PSGREG45_INSTR EQU 047E2H
 344+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F3H
 345+ 4CF3              PLY_AKG_PSGREG6_8_INSTR EQU 047F3H
 346+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04804H
 347+ 4CF3              PLY_AKG_PSGREG9_10_INSTR EQU 04804H
 348+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04815H
 349+ 4CF3              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04815H
 350+ 4CF3              PLY_AKG_PSGREG13_OLDVALUE EQU 0482AH
 351+ 4CF3              PLY_AKG_RETRIG EQU 0482CH
 352+ 4CF3              PLY_AKG_PSGREG13_INSTR EQU 0482EH
 353+ 4CF3              PLY_AKG_PSGREG13_END EQU 0483DH
 354+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483DH
 355+ 4CF3              PLY_AKG_SAVESP EQU 0483DH
 356+ 4CF3              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 04841H
 357+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTS EQU 04849H
 358+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04856H
 359+ 4CF3              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04856H
 360+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485EH
 361+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 0486BH
 362+ 4CF3              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 0486BH
 363+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTS EQU 04873H
 364+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487EH
 365+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS EQU 0487EH
 366+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488DH
 367+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488DH
 368+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04894H
 369+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A4H
 370+ 4CF3              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A4H
 371+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048ABH
 372+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048ABH
 373+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048AEH
 374+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B7H
 375+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B7H
 376+ 4CF3              PLY_AKG_READINSTRUMENTCELL EQU 048BDH
 377+ 4CF3              PLY_AKG_NOSOFTNOHARD EQU 048CAH
 378+ 4CF3              PLY_AKG_NSNH_NONOISE EQU 048DFH
 379+ 4CF3              PLY_AKG_SOFT EQU 048E2H
 380+ 4CF3              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E9H
 381+ 4CF3              PLY_AKG_S_NOTSIMPLE EQU 048F1H
 382+ 4CF3              PLY_AKG_S_AFTERSIMPLETEST EQU 048F4H
 383+ 4CF3              PLY_AKG_HARDTOSOFT EQU 04901H
 384+ 4CF3              PLY_AKG_HS_JUMPRATIO EQU 0490CH
 385+ 4CF3              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04939H
 386+ 4CF3              PLY_AKG_ENDWITHOUTLOOP EQU 0493BH
 387+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 0493BH
 388+ 4CF3              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 0493BH
 389+ 4CF3              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04943H
 390+ 4CF3              PLY_AKG_SH_JUMPRATIO EQU 04950H
 391+ 4CF3              PLY_AKG_SH_JUMPRATIOEND EQU 04971H
 392+ 4CF3              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 04980H
 393+ 4CF3              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04986H
 394+ 4CF3              PLY_AKG_H_OR_ENDWITHLOOP EQU 049A0H
 395+ 4CF3              PLY_AKG_H_RETRIGEND EQU 049B2H
 396+ 4CF3              PLY_AKG_H_AFTERRETRIG EQU 049B3H
 397+ 4CF3              PLY_AKG_ENDWITHLOOP EQU 049C5H
 398+ 4CF3              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049CCH
 399+ 4CF3              PLY_AKG_S_OR_H_NEXTBYTE EQU 049E2H
 400+ 4CF3              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049F0H
 401+ 4CF3              PLY_AKG_S_OR_H_AFTERPITCH EQU 04A00H
 402+ 4CF3              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0EH
 403+ 4CF3              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1DH
 404+ 4CF3              PLY_AKG_SHOHS_RETRIGEND EQU 04A2CH
 405+ 4CF3              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2DH
 406+ 4CF3              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3FH
 407+ 4CF3              PLY_AKG_EFFECTTABLE EQU 04A4DH
 408+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4DH
 409+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A71H
 410+ 4CF3              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A71H
 411+ 4CF3              PLY_AKG_EFFECT_RESET EQU 04A74H
 412+ 4CF3              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A76H
 413+ 4CF3              PLY_AKG_EFFECT_VOLUME EQU 04A91H
 414+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9DH
 415+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA3H
 416+ 4CF3              PLY_AKG_ARPEGGIOSTABLE EQU 04AA3H
 417+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04ACAH
 418+ 4CF3              PLY_AKG_EFFECT_PITCHTABLE EQU 04AD1H
 419+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD7H
 420+ 4CF3              PLY_AKG_PITCHESTABLE EQU 04AD7H
 421+ 4CF3              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFEH
 422+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B05H
 423+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B16H
 424+ 4CF3              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1DH
 425+ 4CF3              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2DH
 426+ 4CF3              PLY_AKG_EFFECT_PITCHUP EQU 04B42H
 427+ 4CF3              PLY_AKG_EFFECT_PITCHSTOP EQU 04B54H
 428+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B5BH
 429+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B85H
 430+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B85H
 431+ 4CF3              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9EH
 432+ 4CF3              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9EH
 433+ 4CF3              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BB0H
 434+ 4CF3              PLY_AKG_EFFECT_LEGATO EQU 04BC6H
 435+ 4CF3              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BDAH
 436+ 4CF3              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BE2H
 437+ 4CF3              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BEAH
 438+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BF2H
 439+ 4CF3              PLY_AKG_EVENT EQU 04BF2H
 440+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF3H
 441+ 4CF3              PLY_AKG_PERIODTABLE EQU 04BF3H
 442+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF3H
 443+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF3H
 444+ 4CF3              PLY_AKG_PERIODTABLE_END EQU 04CF3H
 445+ 4CF3              PLY_AKG_END EQU 04CF3H
 446+ 4CF3              MAIN_PLAYER_END EQU 04CF3H
 447+ 4CF3              TESTEREND EQU 04CF3H
 448+ 4CF3
# file closed: ./symbol/AKG.sym
 124  4CF3               ENDIF
 125  4CF3
 126  4CF3               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
   1+ 4CF3              ORIG.HTIMI:
   2+ 4CF3 00 00 00 00  	DB 0, 0, 0, 0, 0
   2+ 4CF7 00
   3+ 4CF8               EXPORT ORIG.HTIMI
   4+ 4CF8
   5+ 4CF8              ; *******************************************************************************************************
   6+ 4CF8              ; interrupt handler when page 0 enabled
   7+ 4CF8              ; we are here only if one of the extended basic commands have paged in page 0
   8+ 4CF8              ; which means we arrived from BASIC so page 2 is already good
   9+ 4CF8              VBLANK:
  10+ 4CF8              	EXPORT VBLANK
  11+ 4CF8
  12+ 4CF8 F5               PUSH AF
  13+ 4CF9              	; is VDP originator ?
  14+ 4CF9 DB 99        	IN	A, (099H)
  15+ 4CFB A7           	AND	A
  16+ 4CFC F2 23 4D     	JP P, .EXIT
  17+ 4CFF
  18+ 4CFF               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  19+ 4CFF C5               PUSH BC
  20+ 4D00 D5               PUSH DE
  21+ 4D01 E5               PUSH HL
  22+ 4D02 08               EX AF, AF'
  23+ 4D03 D9               EXX
  24+ 4D04 F5               PUSH AF
  25+ 4D05 C5               PUSH BC
  26+ 4D06 D5               PUSH DE
  27+ 4D07 E5               PUSH HL
  28+ 4D08 DD E5            PUSH IX
  29+ 4D0A FD E5            PUSH IY
  30+ 4D0C
  31+ 4D0C               IF (SPRITE_CMDS == 1)
  32+ 4D0C CD 5D 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  33+ 4D0F               ENDIF
  34+ 4D0F
  35+ 4D0F               IF (SOUND_CMDS == 1)
  36+ 4D0F 3A 09 59     	LD A, (SOUND_ENABLED)
  37+ 4D12 B7           	OR A
  38+ 4D13 C4 36 42     	CALL NZ,PLY_AKG_PLAY
  39+ 4D16               ENDIF
  40+ 4D16
  41+ 4D16                  ; increase JIFFY
  42+ 4D16                  ;LD HL,(JIFFY)
  43+ 4D16                  ;INC HL
  44+ 4D16                  ;LD (JIFFY),HL
  45+ 4D16
  46+ 4D16 FD E1            POP IY
  47+ 4D18 DD E1            POP IX
  48+ 4D1A E1               POP HL
  49+ 4D1B D1               POP DE
  50+ 4D1C C1               POP BC
  51+ 4D1D F1               POP AF
  52+ 4D1E 08               EX AF, AF'
  53+ 4D1F D9               EXX
  54+ 4D20 E1               POP HL
  55+ 4D21 D1               POP DE
  56+ 4D22 C1               POP BC
  57+ 4D23               ENDIF
  58+ 4D23
  59+ 4D23              .EXIT:
  60+ 4D23 F1           	POP AF
  61+ 4D24 FB           	EI
  62+ 4D25 ED 4D        	RETI
  63+ 4D27              ; *******************************************************************************************************
  64+ 4D27
  65+ 4D27              ; *******************************************************************************************************
  66+ 4D27              ; H.TIMI function
  67+ 4D27              ; we can end up here from anywhere so page in both page 0 and 2
  68+ 4D27              MBGE_HTIMI:
  69+ 4D27               EXPORT MBGE_HTIMI
  70+ 4D27
  71+ 4D27               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  72+ 4D27
  73+ 4D27 F5           	PUSH AF
  74+ 4D28
  75+ 4D28              	; enable page 2
  76+ 4D28 3E 02            LD A, 2
  77+ 4D2A CD BC 64         CALL GET_PAGE_INFO
  78+ 4D2D C5               PUSH BC
  79+ 4D2E D5               PUSH DE
  80+ 4D2F 3A 43 F3         LD A, (RAMAD2)
  81+ 4D32 26 80            LD H, 080H
  82+ 4D34 CD 03 65         CALL LOCAL_ENASLT
  83+ 4D37              	; enable page 0
  84+ 4D37 AF               XOR A
  85+ 4D38 CD BC 64         CALL GET_PAGE_INFO
  86+ 4D3B C5               PUSH BC
  87+ 4D3C D5               PUSH DE
  88+ 4D3D 3A 41 F3         LD A, (RAMAD0)
  89+ 4D40 26 00            LD H, 0
  90+ 4D42 CD 03 65         CALL LOCAL_ENASLT
  91+ 4D45
  92+ 4D45               IF (SPRITE_CMDS == 1)
  93+ 4D45 CD 5D 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  94+ 4D48               ENDIF
  95+ 4D48
  96+ 4D48               IF (SOUND_CMDS == 1)
  97+ 4D48 3A 09 59     	LD A, (SOUND_ENABLED)
  98+ 4D4B B7           	OR A
  99+ 4D4C C4 36 42     	CALL NZ,PLY_AKG_PLAY
 100+ 4D4F               ENDIF
 101+ 4D4F
 102+ 4D4F              	; restore page 0
 103+ 4D4F D1               POP DE
 104+ 4D50 C1               POP BC
 105+ 4D51 CD F3 64         CALL RESTORE_PAGE_INFO
 106+ 4D54              	; restore page 2
 107+ 4D54 D1               POP DE
 108+ 4D55 C1               POP BC
 109+ 4D56 CD F3 64         CALL RESTORE_PAGE_INFO
 110+ 4D59
 111+ 4D59 F1           	POP AF
 112+ 4D5A               ENDIF
 113+ 4D5A C3 F3 4C     	JP ORIG.HTIMI
 114+ 4D5D              ; *******************************************************************************************************
 115+ 4D5D
 116+ 4D5D              ; *******************************************************************************************************
 117+ 4D5D              ; function checks if the sprite system is initialized and what screen mode we are running
 118+ 4D5D              ; also checks if some VRAM modifying command is running
 119+ 4D5D              ; when that checks out calls sprite updates and animation processing
 120+ 4D5D              ; if in an unsupported mode disables sprite handling
 121+ 4D5D              PROCESS_SPRITES_AND_ANIMATIONS:
 122+ 4D5D              	; check if initialized
 123+ 4D5D 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
 124+ 4D60 B7           	OR A
 125+ 4D61 C8           	RET Z
 126+ 4D62              	; check screen mode
 127+ 4D62 3A AF FC     	LD A, (SCRMOD)
 128+ 4D65 3D           	DEC A
 129+ 4D66 28 08        	JR Z, .L0 ; screen 1
 130+ 4D68 3D           	DEC A
 131+ 4D69 28 05            JR Z, .L0 ; screen 2
 132+ 4D6B              	; unsupported screen mode, disable
 133+ 4D6B AF               XOR A
 134+ 4D6C 32 7F 4D         LD (SPRATR_INIT_STATUS),A
 135+ 4D6F C9               RET
 136+ 4D70              .L0:
 137+ 4D70                  ; check if anyone else is working with VRAM
 138+ 4D70 3A D6 62         LD A,(VRAM_UPDATE_IN_PROGRESS)
 139+ 4D73 B7               OR A
 140+ 4D74 C0               RET NZ
 141+ 4D75
 142+ 4D75 CD 95 4D         CALL SPRATR_UPDATE
 143+ 4D78
 144+ 4D78               IF (ANIM_CMDS == 1)
 145+ 4D78 CD 89 55         CALL PROCESS_ANIMATIONS
 146+ 4D7B CD 55 57         CALL PROCESS_AUTOSGAMS
 147+ 4D7E               ENDIF
 148+ 4D7E C9               RET
 149+ 4D7F              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
 127  4D7F
 128  4D7F               IF (SPRITE_CMDS == 1)
 129  4D7F               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4D7F              ; commands and variables related to sprites
   2+ 4D7F
   3+ 4D7F              SPRATR_INIT_STATUS:
   4+ 4D7F 00            DB 0
   5+ 4D80              SPRATR_UPDATE_FLAG:
   6+ 4D80 00 00         DW 0
   7+ 4D82              SPRATR_DATA:
   8+ 4D82 00 00         DW 0
   9+ 4D84              SPRFLICKER_ENABLED:
  10+ 4D84 00            DB 0
  11+ 4D85              ; to support sprite flicker
  12+ 4D85              FLICKER:
  13+ 4D85 00            DB 0
  14+ 4D86              NUM_SPRITES_HANDLED:
  15+ 4D86 20            DB 32
  16+ 4D87
  17+ 4D87              ; to temporarily store stack pointer
  18+ 4D87              TMPSP:
  19+ 4D87 00 00         DW 0
  20+ 4D89
  21+ 4D89              ; *******************************************************************************************************
  22+ 4D89              ; helper function gets pointer to n-th entry in sprite attributes
  23+ 4D89              ; changes HL,DE
  24+ 4D89              GETnthSPRATTR:
  25+ 4D89 26 00            LD H,0
  26+ 4D8B 6F               LD L,A
  27+ 4D8C CD B8 64         CALL HLx8
  28+ 4D8F ED 5B 82 4D      LD DE,(SPRATR_DATA)
  29+ 4D93 19               ADD HL,DE
  30+ 4D94 C9               RET
  31+ 4D95              ; *******************************************************************************************************
  32+ 4D95
  33+ 4D95              ; *******************************************************************************************************
  34+ 4D95              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  35+ 4D95              ; struct {
  36+ 4D95              ; DW y
  37+ 4D95              ; DW x
  38+ 4D95              ; DW pattern (0-63)
  39+ 4D95              ; DW color
  40+ 4D95              ; } [32]
  41+ 4D95              ; will hide sprites whose location is outside of visible area
  42+ 4D95              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  43+ 4D95              ; modifies AF, AF', BC, DE, HL, IX
  44+ 4D95              SPRATR_UPDATE:
  45+ 4D95              	; check if update requested
  46+ 4D95 2A 80 4D     	LD HL, (SPRATR_UPDATE_FLAG)
  47+ 4D98 7E           	LD A, (HL)
  48+ 4D99 B7           	OR A
  49+ 4D9A C8           	RET Z
  50+ 4D9B
  51+ 4D9B DD 21 86 4D  	LD IX,NUM_SPRITES_HANDLED
  52+ 4D9F DD 46 00     	LD B, (IX) ; sprite number
  53+ 4DA2 0E 98        	LD C, #98 ; register for vdp data output
  54+ 4DA4              	; set VDP address
  55+ 4DA4 3A AF FC         LD A,(SCRMOD)
  56+ 4DA7 3D               DEC A
  57+ 4DA8 20 05            JR NZ,.L4
  58+ 4DAA 2A C3 F3         LD HL, (T32ATR)
  59+ 4DAD 18 03            JR .L5
  60+ 4DAF              .L4:
  61+ 4DAF 2A CD F3         LD HL, (GRPATR)
  62+ 4DB2              .L5:
  63+ 4DB2 3A 84 4D     	LD A, (SPRFLICKER_ENABLED)
  64+ 4DB5 B7           	OR A
  65+ 4DB6 28 03        	JR Z, .L3
  66+ 4DB8 3A 85 4D     	LD A, (FLICKER)
  67+ 4DBB              .L3:
  68+ 4DBB 5F           	LD E, A
  69+ 4DBC 08           	EX AF, AF'
  70+ 4DBD 7B           	LD A, E
  71+ 4DBE 87           	ADD A, A
  72+ 4DBF 87           	ADD A, A
  73+ 4DC0 16 00        	LD D, 0
  74+ 4DC2 5F           	LD E, A
  75+ 4DC3 19           	ADD HL, DE
  76+ 4DC4 CD A3 64     	CALL SETWRT_LOCAL
  77+ 4DC7 ED 73 87 4D  	LD (TMPSP), SP
  78+ 4DCB ED 7B 82 4D  	LD SP, (SPRATR_DATA)
  79+ 4DCF
  80+ 4DCF              .LOOP:
  81+ 4DCF E1           	POP HL
  82+ 4DD0 24           	INC H
  83+ 4DD1 28 0D        	JR Z, .L1 ; negative number between -256 and -1
  84+ 4DD3 25           	DEC H
  85+ 4DD4 20 15        	JR NZ, .OUT3 ; sprite vertically can't be visible
  86+ 4DD6 7D           	LD A, L
  87+ 4DD7 FE C0        	CP 192
  88+ 4DD9 30 10        	JR NC, .OUT3
  89+ 4DDB 3D           	DEC A ; due to VDP rule that top of screen is -1
  90+ 4DDC 57           	LD D, A
  91+ 4DDD C3 04 4E     	JP .X
  92+ 4DE0              .L1:
  93+ 4DE0 7D           	LD A, L
  94+ 4DE1 C6 10        	ADD 16
  95+ 4DE3 FA EB 4D     	JP M, .OUT3 ; below -16
  96+ 4DE6 2D           	DEC L ; due to VDP rule that top of screen is -1
  97+ 4DE7 55           	LD D, L
  98+ 4DE8 C3 04 4E     	JP .X
  99+ 4DEB              .OUT3:
 100+ 4DEB E1           	POP HL ; skip x value
 101+ 4DEC              .OUT2:
 102+ 4DEC E1           	POP HL ; skip pattern
 103+ 4DED E1           	POP HL ; skip color
 104+ 4DEE 3E D1        	LD A, #D1
 105+ 4DF0 ED 79        	OUT (C), A ; sprite hidden
 106+ 4DF2 00          > NOP
 106+ 4DF3 00          > NOP
 106+ 4DF4 00          > NOP
 107+ 4DF5 ED 79        	OUT (C), A ; value unimportant
 108+ 4DF7 00          > NOP
 108+ 4DF8 00          > NOP
 108+ 4DF9 00          > NOP
 109+ 4DFA ED 79        	OUT (C), A ; value unimportant
 110+ 4DFC 00          > NOP
 110+ 4DFD 00          > NOP
 110+ 4DFE 00          > NOP
 111+ 4DFF ED 79        	OUT (C), A ; value unimportant
 112+ 4E01 C3 2F 4E     	JP .NEXT
 113+ 4E04              .X:
 114+ 4E04 E1           	POP HL
 115+ 4E05 24           	INC H
 116+ 4E06 28 08        	JR Z, .L2
 117+ 4E08 25           	DEC H
 118+ 4E09 20 E1        	JR NZ, .OUT2
 119+ 4E0B 1E 00        	LD E, 0 ; EC bit
 120+ 4E0D C3 19 4E     	JP .XY
 121+ 4E10              .L2:
 122+ 4E10 7D           	LD A, L
 123+ 4E11 C6 20        	ADD 32
 124+ 4E13 FA EC 4D     	JP M, .OUT2
 125+ 4E16 6F           	LD L, A
 126+ 4E17 1E 80        	LD E, #80
 127+ 4E19              .XY:
 128+ 4E19 ED 51        	OUT (C), D
 129+ 4E1B 3A E0 F3     	LD A, (REG1SAV)
 130+ 4E1E E6 02        	AND 2
 131+ 4E20 ED 69        	OUT (C), L
 132+ 4E22 E1           	POP HL ; pattern
 133+ 4E23 7D           	LD A, L
 134+ 4E24 28 02        	JR Z, .SMALLSPRITES
 135+ 4E26 87           	ADD A, A
 136+ 4E27 87           	ADD A, A ; needs to go at 4x
 137+ 4E28              .SMALLSPRITES:
 138+ 4E28 D3 98        	OUT (#98), A
 139+ 4E2A E1           	POP HL ; color
 140+ 4E2B 7D           	LD A, L
 141+ 4E2C B3           	OR E
 142+ 4E2D D3 98        	OUT (#98), A
 143+ 4E2F              .NEXT:
 144+ 4E2F 08           	EX AF, AF'
 145+ 4E30 3C           	INC A ; increase current sprite
 146+ 4E31 DD BE 00     	CP (IX) ; compare to maximum handled
 147+ 4E34 C2 54 4E     	JP NZ, .NEXT2 ; continue if not over
 148+ 4E37 AF           	XOR A ; back to zero
 149+ 4E38 08           	EX AF, AF'
 150+ 4E39 3A AF FC         LD A,(SCRMOD)
 151+ 4E3C 3D               DEC A
 152+ 4E3D 20 05            JR NZ,.L6
 153+ 4E3F 2A C3 F3         LD HL, (T32ATR)
 154+ 4E42 18 03            JR .L7
 155+ 4E44              .L6:
 156+ 4E44 2A CD F3         LD HL, (GRPATR)
 157+ 4E47              .L7:
 158+ 4E47              	; CALL SETWRT_LOCAL not allowed as SP modified
 159+ 4E47 7D           	LD	A, L
 160+ 4E48 D3 99        	OUT	(099H), A
 161+ 4E4A 7C           	LD	A, H
 162+ 4E4B E6 3F        	AND	03FH
 163+ 4E4D F6 40        	OR	040H
 164+ 4E4F D3 99        	OUT	(099H), A
 165+ 4E51 C3 55 4E     	JP .NEXT3
 166+ 4E54              .NEXT2:
 167+ 4E54 08           	EX AF, AF'
 168+ 4E55              .NEXT3:
 169+ 4E55 05           	DEC B
 170+ 4E56 C2 CF 4D     	JP NZ, .LOOP
 171+ 4E59 08           	EX AF, AF'
 172+ 4E5A 3C           	INC A ; increase flicker to start at the next one on next vblank
 173+ 4E5B DD BE 00     	CP (IX)
 174+ 4E5E 20 01        	JR NZ,.L8
 175+ 4E60 AF           	XOR A
 176+ 4E61              .L8:
 177+ 4E61 32 85 4D     	LD (FLICKER), A
 178+ 4E64
 179+ 4E64 ED 7B 87 4D  	LD SP, (TMPSP)
 180+ 4E68 2A 80 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 181+ 4E6B 36 00        	LD (HL), 0 ; zero out update flag
 182+ 4E6D C9           	RET
 183+ 4E6E              ; *******************************************************************************************************
 184+ 4E6E
 185+ 4E6E               IF (BASIC_EXTENSION == 1)
 186+ 4E6E              ; *******************************************************************************************************
 187+ 4E6E              ; function to handle CALL SPRENABLE basic extension
 188+ 4E6E              ; initializes sprites handler
 189+ 4E6E              ; _SPRENABLE ( INT[3][31] variable sprites_attributes,
 190+ 4E6E              ;			   INT variable update_variable,
 191+ 4E6E              ;			   BYTE sprite_flicker_enabled,
 192+ 4E6E              ;			   BYTE num_sprites_handled )
 193+ 4E6E              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA, SPRFLICKER_ENABLED and NUM_SPRITES_HANDLED
 194+ 4E6E              SPRENABLE:
 195+ 4E6E              	; opening (
 196+ 4E6E CD CA 65     	CALL CHKCHAR
 197+ 4E71 28           	DB '('
 198+ 4E72              	; get address of sprite attribute table DIM SA%(3,31)
 199+ 4E72 3E 02        	LD A,2
 200+ 4E74 06 02        	LD B,2
 201+ 4E76 11 20 04     	LD DE,#0420
 202+ 4E79 CD F7 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
 203+ 4E7C ED 43 82 4D  	LD (SPRATR_DATA), BC
 204+ 4E80              	; comma
 205+ 4E80 CD CA 65     	CALL CHKCHAR
 206+ 4E83 2C           	DB ','
 207+ 4E84              	; get address of sprite update flag
 208+ 4E84 DD 21 A4 5E  	LD IX, PTRGET
 209+ 4E88 CD 59 01     	CALL CALBAS
 210+ 4E8B ED 53 80 4D  	LD (SPRATR_UPDATE_FLAG), DE
 211+ 4E8F              	; comma
 212+ 4E8F CD CA 65     	CALL CHKCHAR
 213+ 4E92 2C           	DB ','
 214+ 4E93              	; get flicker enabled flag
 215+ 4E93 DD 21 1C 52  	LD IX, GETBYT
 216+ 4E97 CD 59 01     	CALL CALBAS
 217+ 4E9A 32 84 4D     	LD (SPRFLICKER_ENABLED), A
 218+ 4E9D              	; comma
 219+ 4E9D CD CA 65     	CALL CHKCHAR
 220+ 4EA0 2C           	DB ','
 221+ 4EA1              	; get number of handled sprites
 222+ 4EA1 DD 21 1C 52  	LD IX, GETBYT
 223+ 4EA5 CD 59 01     	CALL CALBAS
 224+ 4EA8 32 86 4D     	LD (NUM_SPRITES_HANDLED),A
 225+ 4EAB              	; ending )
 226+ 4EAB CD CA 65     	CALL CHKCHAR
 227+ 4EAE 29           	DB ')'
 228+ 4EAF              .L0:
 229+ 4EAF 3E 01        	LD A, 1
 230+ 4EB1 32 7F 4D     	LD (SPRATR_INIT_STATUS), A
 231+ 4EB4 C9           	RET
 232+ 4EB5              ; *******************************************************************************************************
 233+ 4EB5               ENDIF
 234+ 4EB5
 235+ 4EB5               IF (DEFUSR_EXTENSION == 1)
 236+ 4EB5              ; same as SPRENABLE but for DEFUSR approach
 237+ 4EB5              ; input IX=pointer to input array, real data from +2
 238+ 4EB5              ; +2 = pointer to sprite attributes array data
 239+ 4EB5              ; +4 = pointer to sprite update variable
 240+ 4EB5              ; +6 = flicker flag
 241+ 4EB5              ; +8 = number of sprites to handle
 242+ 4EB5              SPRENABLE_DEFUSR:
 243+ 4EB5 DD 6E 02     	LD L,(IX+2)
 244+ 4EB8 DD 66 03     	LD H,(IX+3)
 245+ 4EBB 22 82 4D     	LD (SPRATR_DATA),HL
 246+ 4EBE DD 6E 04     	LD L,(IX+4)
 247+ 4EC1 DD 66 05     	LD H,(IX+5)
 248+ 4EC4 22 80 4D     	LD (SPRATR_UPDATE_FLAG),HL
 249+ 4EC7 DD 7E 06     	LD A,(IX+6)
 250+ 4ECA 32 84 4D     	LD (SPRFLICKER_ENABLED),A
 251+ 4ECD DD 7E 08     	LD A,(IX+8)
 252+ 4ED0 32 86 4D     	LD (NUM_SPRITES_HANDLED),A
 253+ 4ED3               IF (BASIC_EXTENSION == 1)
 254+ 4ED3 18 DA        	JR SPRENABLE.L0
 255+ 4ED5               ELSE
 256+ 4ED5 ~            	LD A, 1
 257+ 4ED5 ~            	LD (SPRATR_INIT_STATUS), A
 258+ 4ED5 ~            	RET
 259+ 4ED5               ENDIF
 260+ 4ED5               ENDIF
 261+ 4ED5
 262+ 4ED5               IF (DEFUSR_EXTENSION + BASIC_EXTENSION > 0)
 263+ 4ED5              ; *******************************************************************************************************
 264+ 4ED5              ; function to handle CALL SPRDISABLE basic extension
 265+ 4ED5              ; disables sprites handling
 266+ 4ED5              ; _SPRDISABLE
 267+ 4ED5              ; resets variable SPRATR_INIT_STATUS
 268+ 4ED5              SPRDISABLE:
 269+ 4ED5              SPRDISABLE_DEFUSR:
 270+ 4ED5 AF           	XOR A
 271+ 4ED6 32 7F 4D     	LD (SPRATR_INIT_STATUS), A
 272+ 4ED9 C9           	RET
 273+ 4EDA              ; *******************************************************************************************************
 274+ 4EDA               ENDIF
 275+ 4EDA
 276+ 4EDA              ; *******************************************************************************************************
 277+ 4EDA              ; function to handle CALL SPRSET basic extension
 278+ 4EDA              ; sets position, and optionally pattern and color of sprite
 279+ 4EDA              ; _SPRSET ( BYTE sprite_num , valid 0-31
 280+ 4EDA              ;			INT x,
 281+ 4EDA              ;			INT y,
 282+ 4EDA              ;			INT pattern, valid 0-63, otherwise ignored
 283+ 4EDA              ;			INT color, valid 0-15, otherwise ignored
 284+ 4EDA              ;SPRSET:
 285+ 4EDA              ;	LD A, (SPRATR_INIT_STATUS)
 286+ 4EDA              ;	OR A
 287+ 4EDA              ;	JR NZ, .L1
 288+ 4EDA              ;	LD E, 5 ; illegal function call
 289+ 4EDA              ;	JP THROW_ERROR
 290+ 4EDA              ;.L1:
 291+ 4EDA              ;	; opening (
 292+ 4EDA              ;	CALL CHKCHAR
 293+ 4EDA              ;	DB '('
 294+ 4EDA              ;	; get sprite number
 295+ 4EDA              ;	LD IX, GETBYT
 296+ 4EDA              ;	CALL CALBAS
 297+ 4EDA              ;	PUSH AF
 298+ 4EDA              ;	; comma
 299+ 4EDA              ;	CALL CHKCHAR
 300+ 4EDA              ;	DB ','
 301+ 4EDA              ;	; get x
 302+ 4EDA              ;	LD IX, FRMQNT
 303+ 4EDA              ;	CALL CALBAS
 304+ 4EDA              ;	PUSH DE
 305+ 4EDA              ;	; comma
 306+ 4EDA              ;	CALL CHKCHAR
 307+ 4EDA              ;	DB ','
 308+ 4EDA              ;	; get y
 309+ 4EDA              ;	LD IX, FRMQNT
 310+ 4EDA              ;	CALL CALBAS
 311+ 4EDA              ;	PUSH DE
 312+ 4EDA              ;	; comma
 313+ 4EDA              ;	CALL CHKCHAR
 314+ 4EDA              ;	DB ','
 315+ 4EDA              ;	; get pattern
 316+ 4EDA              ;	LD IX, FRMQNT
 317+ 4EDA              ;	CALL CALBAS
 318+ 4EDA              ;	PUSH DE
 319+ 4EDA              ;	; comma
 320+ 4EDA              ;	CALL CHKCHAR
 321+ 4EDA              ;	DB ','
 322+ 4EDA              ;	; get color
 323+ 4EDA              ;	LD IX, FRMQNT
 324+ 4EDA              ;	CALL CALBAS
 325+ 4EDA              ;	PUSH DE
 326+ 4EDA              ;	; ending )
 327+ 4EDA              ;	CALL CHKCHAR
 328+ 4EDA              ;	DB ')'
 329+ 4EDA              ;
 330+ 4EDA              ;   ; save position in BASIC text
 331+ 4EDA              ;	PUSH HL
 332+ 4EDA              ;	POP IX
 333+ 4EDA              ;
 334+ 4EDA              ;	POP BC ; color
 335+ 4EDA              ;	POP DE ; pattern
 336+ 4EDA              ;	EXX
 337+ 4EDA              ;	POP BC ; y
 338+ 4EDA              ;	POP DE ; x
 339+ 4EDA              ;	POP AF ; sprite number
 340+ 4EDA              ;	CP 32
 341+ 4EDA              ;	JR C, .L2
 342+ 4EDA              ;	LD E, 5 ; illegal function call
 343+ 4EDA              ;	JP THROW_ERROR
 344+ 4EDA              ;.L2:
 345+ 4EDA              ;	; find location in sprite attributes table
 346+ 4EDA              ;	PUSH DE
 347+ 4EDA              ;	CALL GETnthSPRATTR
 348+ 4EDA              ;	POP DE
 349+ 4EDA              ;	DI
 350+ 4EDA              ;	; set y
 351+ 4EDA              ;	LD (HL), C
 352+ 4EDA              ;	INC HL
 353+ 4EDA              ;	LD (HL), B
 354+ 4EDA              ;	INC HL
 355+ 4EDA              ;	; set x
 356+ 4EDA              ;	LD (HL), E
 357+ 4EDA              ;	INC HL
 358+ 4EDA              ;	LD (HL), D
 359+ 4EDA              ;	INC HL
 360+ 4EDA              ;	PUSH HL
 361+ 4EDA              ;	EXX
 362+ 4EDA              ;	POP HL
 363+ 4EDA              ;	; check if 0<=pattern<64
 364+ 4EDA              ;	LD A, D
 365+ 4EDA              ;	OR A
 366+ 4EDA              ;	JR NZ, .L3
 367+ 4EDA              ;	LD A, E
 368+ 4EDA              ;	CP 64
 369+ 4EDA              ;	JR NC, .L3
 370+ 4EDA              ;	; set pattern
 371+ 4EDA              ;	;ADD A, A
 372+ 4EDA              ;	;ADD A, A
 373+ 4EDA              ;	;ADD A, A
 374+ 4EDA              ;	LD (HL), A
 375+ 4EDA              ;	INC HL
 376+ 4EDA              ;	LD (HL), D
 377+ 4EDA              ;	INC HL
 378+ 4EDA              ;	JR .L4
 379+ 4EDA              ;.L3:
 380+ 4EDA              ;	; skip pattern
 381+ 4EDA              ;	.2 INC HL
 382+ 4EDA              ;.L4:
 383+ 4EDA              ;	; check if 0<=color<16
 384+ 4EDA              ;	LD A, B
 385+ 4EDA              ;	OR A
 386+ 4EDA              ;	JR NZ, .L5
 387+ 4EDA              ;	LD A, C
 388+ 4EDA              ;	CP 16
 389+ 4EDA              ;	JR NC, .L5
 390+ 4EDA              ;	; set color
 391+ 4EDA              ;	LD (HL), C
 392+ 4EDA              ;	INC HL
 393+ 4EDA              ;	LD (HL), B
 394+ 4EDA              ;
 395+ 4EDA              ;.L5:
 396+ 4EDA              ;	EI
 397+ 4EDA              ;	PUSH IX
 398+ 4EDA              ;	POP HL
 399+ 4EDA              ;	RET
 400+ 4EDA              ; *******************************************************************************************************
 401+ 4EDA
 402+ 4EDA              ; *******************************************************************************************************
 403+ 4EDA              ; function sets sprite location based on initial coordinates and offset provided
 404+ 4EDA              ; input A=sprite number in SPRATR_DATA , 0-31
 405+ 4EDA              ; input DE=initial x
 406+ 4EDA              ; input BC=initial y
 407+ 4EDA              ; input IY=location where delta y,x are located
 408+ 4EDA              ; modifies AF, HL, IX
 409+ 4EDA              SPRSET_DELTA_POS:
 410+ 4EDA D5           	PUSH DE
 411+ 4EDB CD 89 4D     	CALL GETnthSPRATTR
 412+ 4EDE E5           	PUSH HL
 413+ 4EDF DD E1        	POP IX
 414+ 4EE1 D1           	POP DE
 415+ 4EE2              	; IX=sprite's y location
 416+ 4EE2 FD 6E 00     	LD L, (IY)
 417+ 4EE5 FD 66 01     	LD H, (IY+1)
 418+ 4EE8 09           	ADD HL, BC
 419+ 4EE9 DD 75 00     	LD (IX), L
 420+ 4EEC DD 74 01     	LD (IX+1), H
 421+ 4EEF FD 6E 02     	LD L, (IY+2)
 422+ 4EF2 FD 66 03     	LD H, (IY+3)
 423+ 4EF5 19           	ADD HL, DE
 424+ 4EF6 DD 75 02     	LD (IX+2), L
 425+ 4EF9 DD 74 03     	LD (IX+3), H
 426+ 4EFC C9           	RET
 427+ 4EFD              ; *******************************************************************************************************
 428+ 4EFD
 429+ 4EFD              ; *******************************************************************************************************
 430+ 4EFD              ; function to handle CALL SPRGRPMOV basic extension
 431+ 4EFD              ; sets position of a group of sprites described with
 432+ 4EFD              ; { int sprite_num, int delta_y, int delta_x } [count]
 433+ 4EFD              ; _SPRGRPMOV ( INT x,
 434+ 4EFD              ;			   INT y,
 435+ 4EFD              ;			   BYTE count,
 436+ 4EFD              ;			   INT[2][count] data_ptr
 437+ 4EFD              SPRGRPMOV:
 438+ 4EFD 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
 439+ 4F00 B7           	OR A
 440+ 4F01 CA EA 65     	JP Z,ILLEGAL_FUNCTION
 441+ 4F04              	; opening (
 442+ 4F04 CD CA 65     	CALL CHKCHAR
 443+ 4F07 28           	DB '('
 444+ 4F08              	; get x
 445+ 4F08 DD 21 2F 54  	LD IX, FRMQNT
 446+ 4F0C CD 59 01     	CALL CALBAS
 447+ 4F0F ED 53 C5 62  	LD (BLIT_STRUCT),DE
 448+ 4F13              	; comma
 449+ 4F13 CD CA 65     	CALL CHKCHAR
 450+ 4F16 2C           	DB ','
 451+ 4F17              	; get y
 452+ 4F17 DD 21 2F 54  	LD IX, FRMQNT
 453+ 4F1B CD 59 01     	CALL CALBAS
 454+ 4F1E ED 53 C7 62  	LD (BLIT_STRUCT+2),DE
 455+ 4F22              	; comma
 456+ 4F22 CD CA 65     	CALL CHKCHAR
 457+ 4F25 2C           	DB ','
 458+ 4F26              	; get count
 459+ 4F26 DD 21 1C 52  	LD IX, GETBYT
 460+ 4F2A CD 59 01     	CALL CALBAS
 461+ 4F2D 32 C9 62     	LD (BLIT_STRUCT+4),A
 462+ 4F30              	; comma
 463+ 4F30 CD CA 65     	CALL CHKCHAR
 464+ 4F33 2C           	DB ','
 465+ 4F34              	; get sprite group definition array data pointer
 466+ 4F34 3A C9 62     	LD A,(BLIT_STRUCT+4)
 467+ 4F37 5F           	LD E,A
 468+ 4F38 16 03        	LD D,3
 469+ 4F3A 3E 02        	LD A,2
 470+ 4F3C 47           	LD B,A
 471+ 4F3D CD F7 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
 472+ 4F40 ED 43 CA 62  	LD (BLIT_STRUCT+5),BC
 473+ 4F44              	; ending )
 474+ 4F44 CD CA 65     	CALL CHKCHAR
 475+ 4F47 29           	DB ')'
 476+ 4F48
 477+ 4F48 E5           	PUSH HL
 478+ 4F49
 479+ 4F49 D9               EXX
 480+ 4F4A ED 5B C5 62      LD DE,(BLIT_STRUCT) ; initial x
 481+ 4F4E ED 4B C7 62      LD BC,(BLIT_STRUCT+2) ; initial y
 482+ 4F52 D9               EXX
 483+ 4F53 2A CA 62         LD HL,(BLIT_STRUCT+5) ; pointer to data
 484+ 4F56 3A C9 62         LD A,(BLIT_STRUCT+4) ; number of entries
 485+ 4F59 47               LD B,A
 486+ 4F5A 3E 01        	LD A,1
 487+ 4F5C 32 D6 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 488+ 4F5F F3           	DI
 489+ 4F60 CD 6A 4F     	CALL .UPDATE_LOC
 490+ 4F63 FB           	EI
 491+ 4F64 AF           	XOR A
 492+ 4F65 32 D6 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 493+ 4F68
 494+ 4F68 E1           	POP HL
 495+ 4F69 C9           	RET
 496+ 4F6A
 497+ 4F6A              .UPDATE_LOC:
 498+ 4F6A 7E           	LD A, (HL)
 499+ 4F6B 23           	INC HL
 500+ 4F6C 23           	INC HL
 501+ 4F6D E5           	PUSH HL
 502+ 4F6E FD E1        	POP IY
 503+ 4F70 D9           	EXX
 504+ 4F71 CD DA 4E     	CALL SPRSET_DELTA_POS
 505+ 4F74 D9           	EXX
 506+ 4F75 23          > INC HL
 506+ 4F76 23          > INC HL
 506+ 4F77 23          > INC HL
 506+ 4F78 23          > INC HL
 507+ 4F79 10 EF        	DJNZ .UPDATE_LOC
 508+ 4F7B C9           	RET
 509+ 4F7C              ; *******************************************************************************************************
 510+ 4F7C
# file closed: asm\SPRITES.asm
 130  4F7C               ENDIF
 131  4F7C
 132  4F7C               IF (ANIM_CMDS == 1)
 133  4F7C               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4F7C              ; sprite animation routines
   2+ 4F7C
   3+ 4F7C              ; number of animation items and pointer
   4+ 4F7C              ANIMITEMNUM:
   5+ 4F7C 00            DB 0
   6+ 4F7D              ANIMITEMPTR:
   7+ 4F7D 2C 66         DW EXT_END
   8+ 4F7F              ; number of animation definitions and pointer
   9+ 4F7F              ANIMDEFNUM:
  10+ 4F7F 00            DB 0
  11+ 4F80              ANIMDEFPTR:
  12+ 4F80 2C 66         DW EXT_END
  13+ 4F82              ; number of links between sprite and animation definitions
  14+ 4F82              ANIMSPRNUM:
  15+ 4F82 00            DB 0
  16+ 4F83              ANIMSPRPTR:
  17+ 4F83 2C 66         DW EXT_END
  18+ 4F85              ; number of automatic sprite group move and animate structures
  19+ 4F85              AUTOSGAMNUM:
  20+ 4F85 00            DB 0
  21+ 4F86              AUTOSGAMPTR:
  22+ 4F86 2C 66         DW EXT_END
  23+ 4F88
  24+ 4F88              ; ANIMATION ITEM
  25+ 4F88              ; byte type = [0 - pattern and color change
  26+ 4F88              ;              1 - pattern definition change ]
  27+ 4F88              ; word ticks - number of ticks to hold this state
  28+ 4F88              ; for type = 0
  29+ 4F88              ;   byte pattern;
  30+ 4F88              ;   byte color;
  31+ 4F88              ; for type = 1
  32+ 4F88              ;   work data_pointer;
  33+ 4F88              ; total size = 5b
  34+ 4F88
  35+ 4F88              ; ANIMATION DEFINITION
  36+ 4F88              ; byte number of items 1-15
  37+ 4F88              ; byte[15] anim_item;
  38+ 4F88              ; total size = 16b
  39+ 4F88
  40+ 4F88              ; SPRITE/CHAR ANIMATION
  41+ 4F88              ; +00 byte sprite/char number;
  42+ 4F88              ; +01 word time;
  43+ 4F88              ; +03 byte current item;
  44+ 4F88              ; +04 byte animation definition;
  45+ 4F88              ; +05 byte cyclic;
  46+ 4F88              ; +06 byte active;
  47+ 4F88              ; +07 byte 0=sprite, 1-3 character bank
  48+ 4F88              ; total size = 8b
  49+ 4F88
  50+ 4F88              ; AUTOMATIC SPRITE GROUP MOVE AND ANIMATE structure
  51+ 4F88              ; +00 pointer to X variable
  52+ 4F88              ; +02 pointer to Y variable
  53+ 4F88              ; +04 minimum value
  54+ 4F88              ; +06 maximal value
  55+ 4F88              ; +08 delta value
  56+ 4F88              ; +10 direction 0=horizontal, <>0 = vertical
  57+ 4F88              ; +11 sprite group size
  58+ 4F88              ; +12 sprite group pointer
  59+ 4F88              ; +14 animation list size
  60+ 4F88              ; +15 animation list pointer for negative delta values
  61+ 4F88              ; +17 animation list pointer for positive delta values
  62+ 4F88              ; +19 active flag
  63+ 4F88              ; +20 ticks for movement
  64+ 4F88              ; +22 timer
  65+ 4F88              ; total = 24b
  66+ 4F88
  67+ 4F88              ; *******************************************************************************************************
  68+ 4F88              ; helper function HL=A*5
  69+ 4F88              ; changes HL,DE
  70+ 4F88              Ax5:
  71+ 4F88 26 00            LD H,0
  72+ 4F8A 6F               LD L,A
  73+ 4F8B 54               LD D,H
  74+ 4F8C 5D               LD E,L
  75+ 4F8D 29               ADD HL,HL
  76+ 4F8E 29               ADD HL,HL
  77+ 4F8F 19               ADD HL,DE
  78+ 4F90 C9               RET
  79+ 4F91              ; *******************************************************************************************************
  80+ 4F91
  81+ 4F91              ; *******************************************************************************************************
  82+ 4F91              ; helper function gets pointer to n-th animation item
  83+ 4F91              ; changes HL,DE
  84+ 4F91              GETnthANIMITEM:
  85+ 4F91 CD 88 4F         CALL Ax5
  86+ 4F94 ED 5B 7D 4F      LD DE,(ANIMITEMPTR)
  87+ 4F98 19               ADD HL,DE
  88+ 4F99 C9               RET
  89+ 4F9A              ; *******************************************************************************************************
  90+ 4F9A
  91+ 4F9A              ; *******************************************************************************************************
  92+ 4F9A              ; helper function gets pointer to n-th entry in animation definition
  93+ 4F9A              ; changes HL,DE
  94+ 4F9A              GETnthANIMDEF:
  95+ 4F9A 26 00            LD H,0
  96+ 4F9C 6F               LD L,A
  97+ 4F9D CD B7 64         CALL HLx16
  98+ 4FA0 ED 5B 80 4F      LD DE,(ANIMDEFPTR)
  99+ 4FA4 19               ADD HL,DE
 100+ 4FA5 C9               RET
 101+ 4FA6              ; *******************************************************************************************************
 102+ 4FA6
 103+ 4FA6              ; *******************************************************************************************************
 104+ 4FA6              ; helper function gets pointer to n-th entry in sprite animation
 105+ 4FA6              ; changes HL,DE
 106+ 4FA6              GETnthSPRANIM:
 107+ 4FA6 26 00            LD H,0
 108+ 4FA8 6F               LD L,A
 109+ 4FA9 CD B8 64         CALL HLx8
 110+ 4FAC ED 5B 83 4F      LD DE,(ANIMSPRPTR)
 111+ 4FB0 19               ADD HL,DE
 112+ 4FB1 C9               RET
 113+ 4FB2              ; *******************************************************************************************************
 114+ 4FB2
 115+ 4FB2              ; *******************************************************************************************************
 116+ 4FB2              ; helper function gets pointer to n-th entry in autosgam table
 117+ 4FB2              ; changes HL,DE
 118+ 4FB2              GETnthAUTOSGAM:
 119+ 4FB2 26 00            LD H,0
 120+ 4FB4 6F               LD L,A
 121+ 4FB5 CD B8 64         CALL HLx8
 122+ 4FB8 54               LD D,H
 123+ 4FB9 5D               LD E,L
 124+ 4FBA 29               ADD HL,HL
 125+ 4FBB 19               ADD HL,DE
 126+ 4FBC ED 5B 86 4F      LD DE,(AUTOSGAMPTR)
 127+ 4FC0 19               ADD HL,DE
 128+ 4FC1 C9               RET
 129+ 4FC2              ; *******************************************************************************************************
 130+ 4FC2
 131+ 4FC2              ; *******************************************************************************************************
 132+ 4FC2              ; function to handle CALL MAXANIMITEMS basic extension
 133+ 4FC2              ; MAXANIMITEMS (BYTE number)
 134+ 4FC2              ; sets new number and moves memory buffers as needed
 135+ 4FC2              MAXANIMITEMS:
 136+ 4FC2              	; opening (
 137+ 4FC2 CD CA 65     	CALL CHKCHAR
 138+ 4FC5 28           	DB '('
 139+ 4FC6              	; get value
 140+ 4FC6 DD 21 1C 52  	LD IX, GETBYT
 141+ 4FCA CD 59 01     	CALL CALBAS
 142+ 4FCD F5               PUSH AF
 143+ 4FCE              	; ending )
 144+ 4FCE CD CA 65     	CALL CHKCHAR
 145+ 4FD1 29           	DB ')'
 146+ 4FD2 F1               POP AF
 147+ 4FD3 F3               DI
 148+ 4FD4              	; save position
 149+ 4FD4 E5           	PUSH HL
 150+ 4FD5              .ENTRY:
 151+ 4FD5 47               LD B,A
 152+ 4FD6 3A 7C 4F         LD A,(ANIMITEMNUM)
 153+ 4FD9 90               SUB B
 154+ 4FDA 28 28            JR Z, .EXIT; same value as before
 155+ 4FDC FD 21 80 4F      LD IY,ANIMDEFPTR
 156+ 4FE0 FA 07 50         JP M, .INCREASE
 157+ 4FE3                  ; new value is lower than previous one
 158+ 4FE3 CD 26 50         CALL .SIZEDIFF
 159+ 4FE6 CD 41 50         CALL .DECREASE_COMMON
 160+ 4FE9 2A 83 4F         LD HL,(ANIMSPRPTR)
 161+ 4FEC AF               XOR A
 162+ 4FED ED 42            SBC HL,BC
 163+ 4FEF 22 83 4F         LD (ANIMSPRPTR),HL
 164+ 4FF2              .E1:
 165+ 4FF2 2A 86 4F         LD HL,(AUTOSGAMPTR)
 166+ 4FF5 AF               XOR A
 167+ 4FF6 ED 42            SBC HL,BC
 168+ 4FF8 22 86 4F         LD (AUTOSGAMPTR),HL
 169+ 4FFB              .E3:
 170+ 4FFB 2A 10 40         LD HL,(FREEMEMPTR)
 171+ 4FFE AF               XOR A
 172+ 4FFF ED 42            SBC HL,BC
 173+ 5001 22 10 40         LD (FREEMEMPTR),HL
 174+ 5004              .EXIT:
 175+ 5004 FB               EI
 176+ 5005 E1           	POP HL
 177+ 5006 C9           	RET
 178+ 5007              .INCREASE:
 179+ 5007 ED 44            NEG
 180+ 5009 CD 26 50         CALL .SIZEDIFF
 181+ 500C CD 6D 50         CALL .INCREASE_COMMON
 182+ 500F 2A 83 4F         LD HL,(ANIMSPRPTR)
 183+ 5012 09               ADD HL,BC
 184+ 5013 22 83 4F         LD (ANIMSPRPTR),HL
 185+ 5016              .E2:
 186+ 5016 2A 86 4F         LD HL,(AUTOSGAMPTR)
 187+ 5019 09               ADD HL,BC
 188+ 501A 22 86 4F         LD (AUTOSGAMPTR),HL
 189+ 501D              .E4:
 190+ 501D 2A 10 40         LD HL,(FREEMEMPTR)
 191+ 5020 09               ADD HL,BC
 192+ 5021 22 10 40         LD (FREEMEMPTR),HL
 193+ 5024 18 DE            JR .EXIT
 194+ 5026              .SIZEDIFF:
 195+ 5026 CD 88 4F         CALL Ax5
 196+ 5029 78               LD A,B
 197+ 502A 32 7C 4F         LD (ANIMITEMNUM),A
 198+ 502D 44               LD B,H
 199+ 502E 4D               LD C,L
 200+ 502F C9               RET ; BC=size difference in bytes
 201+ 5030              .SIZETOMOVE:
 202+ 5030 D5               PUSH DE
 203+ 5031 2A 10 40         LD HL,(FREEMEMPTR)
 204+ 5034 FD 5E 00         LD E,(IY)
 205+ 5037 FD 56 01         LD D,(IY+1)
 206+ 503A AF               XOR A
 207+ 503B ED 52            SBC HL,DE
 208+ 503D 44               LD B,H
 209+ 503E 4D               LD C,L
 210+ 503F D1               POP DE
 211+ 5040 C9               RET
 212+ 5041              .DECREASE_COMMON:
 213+ 5041 FD 6E 00         LD L,(IY)
 214+ 5044 FD 66 01         LD H,(IY+1)
 215+ 5047 AF               XOR A
 216+ 5048 ED 42            SBC HL,BC
 217+ 504A EB               EX DE,HL
 218+ 504B C5               PUSH BC
 219+ 504C CD 30 50         CALL .SIZETOMOVE
 220+ 504F F3               DI
 221+ 5050 78               LD A,B
 222+ 5051 B1               OR C
 223+ 5052 28 08            JR Z,.L1
 224+ 5054 FD 6E 00         LD L,(IY)
 225+ 5057 FD 66 01         LD H,(IY+1)
 226+ 505A ED B0            LDIR
 227+ 505C              .L1:
 228+ 505C C1               POP BC
 229+ 505D FD 6E 00         LD L,(IY)
 230+ 5060 FD 66 01         LD H,(IY+1)
 231+ 5063 AF               XOR A
 232+ 5064 ED 42            SBC HL,BC
 233+ 5066 FD 75 00         LD (IY),L
 234+ 5069 FD 74 01         LD (IY+1),H
 235+ 506C C9               RET
 236+ 506D              .INCREASE_COMMON:
 237+ 506D 2A 10 40         LD HL,(FREEMEMPTR)
 238+ 5070 2B               DEC HL
 239+ 5071 AF               XOR A
 240+ 5072 ED 42            SBC HL,BC
 241+ 5074 EB               EX DE,HL
 242+ 5075 C5               PUSH BC
 243+ 5076 CD 30 50         CALL .SIZETOMOVE
 244+ 5079 F3               DI
 245+ 507A 78               LD A,B
 246+ 507B B1               OR C
 247+ 507C 28 06            JR Z,.L2
 248+ 507E 2A 10 40         LD HL,(FREEMEMPTR)
 249+ 5081 2B               DEC HL
 250+ 5082 ED B8            LDDR
 251+ 5084              .L2:
 252+ 5084 C1               POP BC
 253+ 5085 FD 6E 00         LD L,(IY)
 254+ 5088 FD 66 01         LD H,(IY+1)
 255+ 508B 09               ADD HL,BC
 256+ 508C FD 75 00         LD (IY),L
 257+ 508F FD 74 01         LD (IY+1),H
 258+ 5092 C9               RET
 259+ 5093              ; *******************************************************************************************************
 260+ 5093
 261+ 5093              ; *******************************************************************************************************
 262+ 5093              ; function to handle CALL ANIMITEMPAT basic extension
 263+ 5093              ; ANIMITEMPAT ( BYTE id,
 264+ 5093              ;               INT ticks >0,
 265+ 5093              ;               BYTE pattern,
 266+ 5093              ;               BYTE color )
 267+ 5093              ; fills animation item data, returns an error if ID out of bounds
 268+ 5093              ANIMITEMPAT:
 269+ 5093                  ; opening (
 270+ 5093 CD CA 65     	CALL CHKCHAR
 271+ 5096 28           	DB '('
 272+ 5097              	; get id
 273+ 5097 DD 21 1C 52  	LD IX, GETBYT
 274+ 509B CD 59 01     	CALL CALBAS
 275+ 509E F5               PUSH AF
 276+ 509F                  ; check if out of bounds
 277+ 509F 3C               INC A
 278+ 50A0 4F               LD C,A
 279+ 50A1 3A 7C 4F         LD A,(ANIMITEMNUM)
 280+ 50A4 B9               CP C
 281+ 50A5 DA E2 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 282+ 50A8              	; comma
 283+ 50A8 CD CA 65     	CALL CHKCHAR
 284+ 50AB 2C           	DB ','
 285+ 50AC              	; get ticks
 286+ 50AC DD 21 2F 54  	LD IX, FRMQNT
 287+ 50B0 CD 59 01     	CALL CALBAS
 288+ 50B3 7A               LD A,D
 289+ 50B4 B3               OR E
 290+ 50B5 CA E6 65         JP Z, OVERFLOW
 291+ 50B8 D5           	PUSH DE
 292+ 50B9              	; comma
 293+ 50B9 CD CA 65     	CALL CHKCHAR
 294+ 50BC 2C           	DB ','
 295+ 50BD              	; get pattern
 296+ 50BD DD 21 1C 52  	LD IX, GETBYT
 297+ 50C1 CD 59 01     	CALL CALBAS
 298+ 50C4 F5               PUSH AF
 299+ 50C5              	; comma
 300+ 50C5 CD CA 65     	CALL CHKCHAR
 301+ 50C8 2C           	DB ','
 302+ 50C9              	; get color
 303+ 50C9 DD 21 1C 52  	LD IX, GETBYT
 304+ 50CD CD 59 01     	CALL CALBAS
 305+ 50D0 F5               PUSH AF
 306+ 50D1              	; ending )
 307+ 50D1 CD CA 65     	CALL CHKCHAR
 308+ 50D4 29           	DB ')'
 309+ 50D5              .ENTRY:
 310+ 50D5 E5               PUSH HL
 311+ 50D6 DD E1            POP IX
 312+ 50D8 D9               EXX
 313+ 50D9 C1               POP BC ; color
 314+ 50DA D1               POP DE ; pattern
 315+ 50DB E1               POP HL ; ticks
 316+ 50DC D9               EXX
 317+ 50DD F1               POP AF
 318+ 50DE CD 91 4F         CALL GETnthANIMITEM
 319+ 50E1 E5               PUSH HL
 320+ 50E2 FD E1            POP IY
 321+ 50E4 D9               EXX
 322+ 50E5 FD 36 00 00      LD (IY),0 ; type=0
 323+ 50E9 FD 75 01         LD (IY+1),L
 324+ 50EC FD 74 02         LD (IY+2),H
 325+ 50EF FD 72 03         LD (IY+3),D
 326+ 50F2 FD 70 04         LD (IY+4),B
 327+ 50F5
 328+ 50F5 DD E5            PUSH IX
 329+ 50F7 E1               POP HL
 330+ 50F8 C9               RET
 331+ 50F9              ; *******************************************************************************************************
 332+ 50F9
 333+ 50F9              ; *******************************************************************************************************
 334+ 50F9              ; function to handle CALL ANIMITEMPTR basic extension
 335+ 50F9              ; ANIMITEMPTR ( BYTE id,
 336+ 50F9              ;               INT ticks,
 337+ 50F9              ;               INT pointer,
 338+ 50F9              ; fills animation item data, returns an error if ID out of bounds
 339+ 50F9              ANIMITEMPTR_CMD:
 340+ 50F9                  ; opening (
 341+ 50F9 CD CA 65     	CALL CHKCHAR
 342+ 50FC 28           	DB '('
 343+ 50FD              	; get id
 344+ 50FD DD 21 1C 52  	LD IX, GETBYT
 345+ 5101 CD 59 01     	CALL CALBAS
 346+ 5104 F5               PUSH AF
 347+ 5105                  ; check if out of bounds
 348+ 5105 3C               INC A
 349+ 5106 4F               LD C,A
 350+ 5107 3A 7C 4F         LD A,(ANIMITEMNUM)
 351+ 510A B9               CP C
 352+ 510B DA E2 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 353+ 510E              	; comma
 354+ 510E CD CA 65     	CALL CHKCHAR
 355+ 5111 2C           	DB ','
 356+ 5112              	; get ticks
 357+ 5112 DD 21 2F 54  	LD IX, FRMQNT
 358+ 5116 CD 59 01     	CALL CALBAS
 359+ 5119 7A               LD A,D
 360+ 511A B3               OR E
 361+ 511B CA E6 65         JP Z,OVERFLOW
 362+ 511E D5           	PUSH DE
 363+ 511F              	; comma
 364+ 511F CD CA 65     	CALL CHKCHAR
 365+ 5122 2C           	DB ','
 366+ 5123              	; get pointer
 367+ 5123 DD 21 2F 54  	LD IX, FRMQNT
 368+ 5127 CD 59 01     	CALL CALBAS
 369+ 512A D5           	PUSH DE
 370+ 512B              	; ending )
 371+ 512B CD CA 65     	CALL CHKCHAR
 372+ 512E 29           	DB ')'
 373+ 512F              .ENTRY:
 374+ 512F E5               PUSH HL
 375+ 5130 DD E1            POP IX
 376+ 5132 D9               EXX
 377+ 5133 D1               POP DE ; pointer
 378+ 5134 E1               POP HL ; ticks
 379+ 5135 D9               EXX
 380+ 5136 F1               POP AF
 381+ 5137 CD 91 4F         CALL GETnthANIMITEM
 382+ 513A E5               PUSH HL
 383+ 513B FD E1            POP IY
 384+ 513D D9               EXX
 385+ 513E FD 36 00 01      LD (IY),1 ; type=1
 386+ 5142 FD 75 01         LD (IY+1),L
 387+ 5145 FD 74 02         LD (IY+2),H
 388+ 5148 FD 73 03         LD (IY+3),E
 389+ 514B FD 72 04         LD (IY+4),D
 390+ 514E
 391+ 514E DD E5            PUSH IX
 392+ 5150 E1               POP HL
 393+ 5151 C9               RET
 394+ 5152              ; *******************************************************************************************************
 395+ 5152
 396+ 5152              ; *******************************************************************************************************
 397+ 5152              ; function to handle CALL MAXANIMDEFS basic extension
 398+ 5152              ; MAXANIMDEFS (BYTE number)
 399+ 5152              ; sets new number and moves memory buffers as needed
 400+ 5152              MAXANIMDEFS:
 401+ 5152              	; opening (
 402+ 5152 CD CA 65     	CALL CHKCHAR
 403+ 5155 28           	DB '('
 404+ 5156              	; get value
 405+ 5156 DD 21 1C 52  	LD IX, GETBYT
 406+ 515A CD 59 01     	CALL CALBAS
 407+ 515D F5               PUSH AF
 408+ 515E              	; ending )
 409+ 515E CD CA 65     	CALL CHKCHAR
 410+ 5161 29           	DB ')'
 411+ 5162 F1               POP AF
 412+ 5163 F3               DI
 413+ 5164              	; save position
 414+ 5164 E5           	PUSH HL
 415+ 5165              .ENTRY:
 416+ 5165 47               LD B,A
 417+ 5166 3A 7F 4F         LD A,(ANIMDEFNUM)
 418+ 5169 90               SUB B
 419+ 516A CA 04 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 420+ 516D FD 21 83 4F      LD IY,ANIMSPRPTR
 421+ 5171 FA 7D 51         JP M, .INCREASE
 422+ 5174                  ; new value is lower than previous one
 423+ 5174 CD 88 51         CALL .SIZEDIFF
 424+ 5177 CD 41 50         CALL MAXANIMITEMS.DECREASE_COMMON
 425+ 517A C3 F2 4F         JP MAXANIMITEMS.E1
 426+ 517D              .INCREASE:
 427+ 517D ED 44            NEG
 428+ 517F CD 88 51         CALL .SIZEDIFF
 429+ 5182 CD 6D 50         CALL MAXANIMITEMS.INCREASE_COMMON
 430+ 5185 C3 16 50         JP MAXANIMITEMS.E2
 431+ 5188              .SIZEDIFF:
 432+ 5188 26 00            LD H,0
 433+ 518A 6F               LD L,A
 434+ 518B CD B7 64         CALL HLx16
 435+ 518E 78               LD A,B
 436+ 518F 32 7F 4F         LD (ANIMDEFNUM),A
 437+ 5192 44               LD B,H
 438+ 5193 4D               LD C,L
 439+ 5194 C9               RET ; BC=size difference in bytes
 440+ 5195              ; *******************************************************************************************************
 441+ 5195
 442+ 5195              ; *******************************************************************************************************
 443+ 5195              ; function to handle CALL ANIMDEF basic extension
 444+ 5195              ; ANIMITEMPAT ( BYTE id,
 445+ 5195              ;               BYTE size,
 446+ 5195              ;               INT[] list )
 447+ 5195              ; fills animation definition data, returns an error if out of bounds, or invalid type
 448+ 5195              ANIMDEF:
 449+ 5195                  ; opening (
 450+ 5195 CD CA 65     	CALL CHKCHAR
 451+ 5198 28           	DB '('
 452+ 5199              	; get id
 453+ 5199 DD 21 1C 52  	LD IX, GETBYT
 454+ 519D CD 59 01     	CALL CALBAS
 455+ 51A0 F5               PUSH AF
 456+ 51A1                  ; check if out of bounds
 457+ 51A1 3C               INC A
 458+ 51A2 4F               LD C,A
 459+ 51A3 3A 7F 4F         LD A,(ANIMDEFNUM)
 460+ 51A6 B9               CP C
 461+ 51A7 DA E2 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 462+ 51AA              	; comma
 463+ 51AA CD CA 65     	CALL CHKCHAR
 464+ 51AD 2C           	DB ','
 465+ 51AE              	; get size
 466+ 51AE DD 21 1C 52  	LD IX, GETBYT
 467+ 51B2 CD 59 01     	CALL CALBAS
 468+ 51B5 FE 10            CP 16
 469+ 51B7 D2 E6 65         JP NC, OVERFLOW
 470+ 51BA B7               OR A
 471+ 51BB CA E6 65         JP Z, OVERFLOW
 472+ 51BE F5           	PUSH AF
 473+ 51BF              	; comma
 474+ 51BF CD CA 65     	CALL CHKCHAR
 475+ 51C2 2C           	DB ','
 476+ 51C3              	; get pointer to a list of animation items in integer array format
 477+ 51C3                  ; get array pointer
 478+ 51C3 D1               POP DE
 479+ 51C4 D5               PUSH DE
 480+ 51C5 3E 02            LD A,2
 481+ 51C7 06 01            LD B,1
 482+ 51C9 CD F7 65         CALL GET_BASIC_ARRAY_DATA_POINTER
 483+ 51CC C5               PUSH BC
 484+ 51CD              	; ending )
 485+ 51CD CD CA 65     	CALL CHKCHAR
 486+ 51D0 29           	DB ')'
 487+ 51D1              .ENTRY:
 488+ 51D1 E5               PUSH HL
 489+ 51D2 DD E1            POP IX
 490+ 51D4 D1               POP DE ; pointer to INT array
 491+ 51D5 C1               POP BC ; B=item number
 492+ 51D6 F1               POP AF ; id
 493+ 51D7 D5               PUSH DE
 494+ 51D8 CD 9A 4F         CALL GETnthANIMDEF
 495+ 51DB D1               POP DE
 496+ 51DC 70               LD (HL),B
 497+ 51DD              .L1:
 498+ 51DD 23               INC HL
 499+ 51DE 1A               LD A,(DE)
 500+ 51DF 13          > INC DE
 500+ 51E0 13          > INC DE
 501+ 51E1 77               LD (HL),A
 502+ 51E2 10 F9            DJNZ .L1
 503+ 51E4 DD E5            PUSH IX
 504+ 51E6 E1               POP HL
 505+ 51E7 C9               RET
 506+ 51E8              ; *******************************************************************************************************
 507+ 51E8
 508+ 51E8              ; *******************************************************************************************************
 509+ 51E8              ; function to handle CALL MAXANIMSPRS basic extension
 510+ 51E8              ; MAXANIMSPRS (BYTE number)
 511+ 51E8              ; sets new number and moves memory buffers as needed
 512+ 51E8              MAXANIMSPRS:
 513+ 51E8              	; opening (
 514+ 51E8 CD CA 65     	CALL CHKCHAR
 515+ 51EB 28           	DB '('
 516+ 51EC              	; get value
 517+ 51EC DD 21 1C 52  	LD IX, GETBYT
 518+ 51F0 CD 59 01     	CALL CALBAS
 519+ 51F3 F5               PUSH AF
 520+ 51F4              	; ending )
 521+ 51F4 CD CA 65     	CALL CHKCHAR
 522+ 51F7 29           	DB ')'
 523+ 51F8 F1               POP AF
 524+ 51F9 F3               DI
 525+ 51FA              	; save position
 526+ 51FA E5           	PUSH HL
 527+ 51FB              .ENTRY:
 528+ 51FB 47               LD B,A
 529+ 51FC 3A 82 4F         LD A,(ANIMSPRNUM)
 530+ 51FF 90               SUB B
 531+ 5200 CA 04 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 532+ 5203 FD 21 86 4F      LD IY,AUTOSGAMPTR
 533+ 5207 FA 13 52         JP M, .INCREASE
 534+ 520A                  ; new value is lower than previous one
 535+ 520A CD 34 52         CALL .SIZEDIFF
 536+ 520D CD 41 50         CALL MAXANIMITEMS.DECREASE_COMMON
 537+ 5210 C3 FB 4F         JP MAXANIMITEMS.E3
 538+ 5213              .INCREASE:
 539+ 5213 ED 44            NEG
 540+ 5215 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 541+ 5216 CD 34 52         CALL .SIZEDIFF
 542+ 5219 CD 6D 50         CALL MAXANIMITEMS.INCREASE_COMMON
 543+ 521C AF               XOR A
 544+ 521D ED 42            SBC HL,BC ; location of new stuff
 545+ 521F F1               POP AF
 546+ 5220 C5               PUSH BC
 547+ 5221 47               LD B,A
 548+ 5222 11 08 00         LD DE,8
 549+ 5225 E5               PUSH HL
 550+ 5226 DD E1            POP IX
 551+ 5228              .L1:
 552+ 5228 DD 36 06 00      LD (IX+6),0 ; active flag
 553+ 522C DD 19            ADD IX,DE
 554+ 522E 10 F8            DJNZ .L1
 555+ 5230 C1               POP BC
 556+ 5231 C3 1D 50         JP MAXANIMITEMS.E4
 557+ 5234              .SIZEDIFF:
 558+ 5234 26 00            LD H,0
 559+ 5236 6F               LD L,A
 560+ 5237 CD B8 64         CALL HLx8
 561+ 523A 78               LD A,B
 562+ 523B 32 82 4F         LD (ANIMSPRNUM),A
 563+ 523E 44               LD B,H
 564+ 523F 4D               LD C,L
 565+ 5240 C9               RET ; BC=size difference in bytes
 566+ 5241              ; *******************************************************************************************************
 567+ 5241
 568+ 5241              ; *******************************************************************************************************
 569+ 5241              ; function to handle CALL ANIMSPRITE basic extension
 570+ 5241              ; ANIMSPRITE ( BYTE id,
 571+ 5241              ;              BYTE sprite_number,
 572+ 5241              ;              BYTE animation_definition_id,
 573+ 5241              ;              BYTE cyclic_flag )
 574+ 5241              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 575+ 5241              ANIMSPRITE:
 576+ 5241                  ; opening (
 577+ 5241 CD CA 65     	CALL CHKCHAR
 578+ 5244 28           	DB '('
 579+ 5245              	; get sprite animation id
 580+ 5245 DD 21 1C 52  	LD IX, GETBYT
 581+ 5249 CD 59 01     	CALL CALBAS
 582+ 524C F5               PUSH AF
 583+ 524D 3C               INC A
 584+ 524E 4F               LD C,A
 585+ 524F 3A 82 4F         LD A,(ANIMSPRNUM)
 586+ 5252 B9               CP C
 587+ 5253 DA E2 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 588+ 5256              	; comma
 589+ 5256 CD CA 65     	CALL CHKCHAR
 590+ 5259 2C           	DB ','
 591+ 525A              	; get sprite number
 592+ 525A DD 21 1C 52  	LD IX, GETBYT
 593+ 525E CD 59 01     	CALL CALBAS
 594+ 5261 F5               PUSH AF
 595+ 5262                  ; check if out of bounds
 596+ 5262 FE 20            CP 32
 597+ 5264 D2 E2 65         JP NC, SUBSCRIPT_OUT_OF_RANGE
 598+ 5267              	; comma
 599+ 5267 CD CA 65     	CALL CHKCHAR
 600+ 526A 2C           	DB ','
 601+ 526B              	; get animation definition id
 602+ 526B DD 21 1C 52  	LD IX, GETBYT
 603+ 526F CD 59 01     	CALL CALBAS
 604+ 5272 F5               PUSH AF
 605+ 5273 3C               INC A
 606+ 5274 4F               LD C,A
 607+ 5275 3A 7F 4F         LD A,(ANIMDEFNUM)
 608+ 5278 B9               CP C
 609+ 5279 DA E2 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 610+ 527C              	; comma
 611+ 527C CD CA 65     	CALL CHKCHAR
 612+ 527F 2C           	DB ','
 613+ 5280              	; get cyclic flag
 614+ 5280 DD 21 1C 52  	LD IX, GETBYT
 615+ 5284 CD 59 01         CALL CALBAS
 616+ 5287 F5           	PUSH AF
 617+ 5288              	; ending )
 618+ 5288 CD CA 65     	CALL CHKCHAR
 619+ 528B 29           	DB ')'
 620+ 528C              .ENTRY:
 621+ 528C E5               PUSH HL
 622+ 528D DD E1            POP IX
 623+ 528F D9               EXX
 624+ 5290 D1               POP DE ; cyclic
 625+ 5291 C1               POP BC ; animation definition id
 626+ 5292 E1               POP HL ; sprite number
 627+ 5293 D9               EXX
 628+ 5294 F1               POP AF ; sprite animation id
 629+ 5295 CD A6 4F         CALL GETnthSPRANIM
 630+ 5298 E5               PUSH HL
 631+ 5299 FD E1            POP IY
 632+ 529B D9               EXX
 633+ 529C FD 74 00         LD (IY),H
 634+ 529F FD 70 04         LD (IY+4),B
 635+ 52A2 FD 72 05         LD (IY+5),D
 636+ 52A5                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 637+ 52A5                  ; following will do preparation for ANIMSTEP situation
 638+ 52A5                  ; current item set to above limit and timer to 1
 639+ 52A5                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 640+ 52A5 FD 36 03 FF      LD (IY+3),255
 641+ 52A9 FD 36 01 01      LD (IY+1),1
 642+ 52AD FD 36 02 00      LD (IY+2),0
 643+ 52B1                  ; mark as sprite animation
 644+ 52B1 FD 36 07 00      LD (IY+7),0
 645+ 52B5 DD E5            PUSH IX
 646+ 52B7 E1               POP HL
 647+ 52B8 C9               RET
 648+ 52B9              ; *******************************************************************************************************
 649+ 52B9
 650+ 52B9              ; *******************************************************************************************************
 651+ 52B9              ; function to handle CALL ANIMCHAR basic extension
 652+ 52B9              ; ANIMCHAR ( BYTE id,
 653+ 52B9              ;            INT character number 0-767,
 654+ 52B9              ;            BYTE animation_definition_id,
 655+ 52B9              ;            BYTE cyclic_flag )
 656+ 52B9              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 657+ 52B9              ANIMCHAR:
 658+ 52B9                  ; opening (
 659+ 52B9 CD CA 65     	CALL CHKCHAR
 660+ 52BC 28           	DB '('
 661+ 52BD              	; get sprite animation id
 662+ 52BD DD 21 1C 52  	LD IX, GETBYT
 663+ 52C1 CD 59 01     	CALL CALBAS
 664+ 52C4 F5               PUSH AF
 665+ 52C5 3C               INC A
 666+ 52C6 4F               LD C,A
 667+ 52C7 3A 82 4F         LD A,(ANIMSPRNUM)
 668+ 52CA B9               CP C
 669+ 52CB DA E2 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 670+ 52CE              	; comma
 671+ 52CE CD CA 65     	CALL CHKCHAR
 672+ 52D1 2C           	DB ','
 673+ 52D2              	; get character number
 674+ 52D2 DD 21 2F 54  	LD IX, FRMQNT
 675+ 52D6 CD 59 01     	CALL CALBAS
 676+ 52D9 D5               PUSH DE
 677+ 52DA                  ; check if out of bounds
 678+ 52DA 7A               LD A,D
 679+ 52DB FE 03            CP 3
 680+ 52DD D2 E2 65         JP NC, SUBSCRIPT_OUT_OF_RANGE
 681+ 52E0              	; comma
 682+ 52E0 CD CA 65     	CALL CHKCHAR
 683+ 52E3 2C           	DB ','
 684+ 52E4              	; get animation definition id
 685+ 52E4 DD 21 1C 52  	LD IX, GETBYT
 686+ 52E8 CD 59 01     	CALL CALBAS
 687+ 52EB F5               PUSH AF
 688+ 52EC 3C               INC A
 689+ 52ED 4F               LD C,A
 690+ 52EE 3A 7F 4F         LD A,(ANIMDEFNUM)
 691+ 52F1 B9               CP C
 692+ 52F2 DA E2 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 693+ 52F5              	; comma
 694+ 52F5 CD CA 65     	CALL CHKCHAR
 695+ 52F8 2C           	DB ','
 696+ 52F9              	; get cyclic flag
 697+ 52F9 DD 21 1C 52  	LD IX, GETBYT
 698+ 52FD CD 59 01         CALL CALBAS
 699+ 5300 F5           	PUSH AF
 700+ 5301              	; ending )
 701+ 5301 CD CA 65     	CALL CHKCHAR
 702+ 5304 29           	DB ')'
 703+ 5305              .ENTRY:
 704+ 5305 E5               PUSH HL
 705+ 5306 DD E1            POP IX
 706+ 5308 D9               EXX
 707+ 5309 D1               POP DE ; cyclic
 708+ 530A C1               POP BC ; animation definition id
 709+ 530B E1               POP HL ; character number
 710+ 530C D9               EXX
 711+ 530D F1               POP AF ; sprite animation id
 712+ 530E CD A6 4F         CALL GETnthSPRANIM
 713+ 5311 E5               PUSH HL
 714+ 5312 FD E1            POP IY
 715+ 5314 D9               EXX
 716+ 5315 FD 75 00         LD (IY),L
 717+ 5318 24               INC H ; save character bank+1
 718+ 5319 FD 74 07         LD (IY+7),H
 719+ 531C FD 70 04         LD (IY+4),B
 720+ 531F FD 72 05         LD (IY+5),D
 721+ 5322                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 722+ 5322                  ; following will do preparation for ANIMSTEP situation
 723+ 5322                  ; current item set to above limit and timer to 1
 724+ 5322                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 725+ 5322 FD 36 03 FF      LD (IY+3),255
 726+ 5326 FD 36 01 01      LD (IY+1),1
 727+ 532A FD 36 02 00      LD (IY+2),0
 728+ 532E DD E5            PUSH IX
 729+ 5330 E1               POP HL
 730+ 5331 C9               RET
 731+ 5332              ; *******************************************************************************************************
 732+ 5332
 733+ 5332              ; *******************************************************************************************************
 734+ 5332              ; function to handle CALL MAXAUTOSGAMS basic extension
 735+ 5332              ; MAXAUTOSGAMS (BYTE number)
 736+ 5332              ; sets new number and moves memory buffers as needed
 737+ 5332              MAXAUTOSGAMS:
 738+ 5332              	; opening (
 739+ 5332 CD CA 65     	CALL CHKCHAR
 740+ 5335 28           	DB '('
 741+ 5336              	; get value
 742+ 5336 DD 21 1C 52  	LD IX, GETBYT
 743+ 533A CD 59 01     	CALL CALBAS
 744+ 533D F5               PUSH AF
 745+ 533E              	; ending )
 746+ 533E CD CA 65     	CALL CHKCHAR
 747+ 5341 29           	DB ')'
 748+ 5342 F1               POP AF
 749+ 5343 F3               DI
 750+ 5344              	; save position
 751+ 5344 E5           	PUSH HL
 752+ 5345              .ENTRY:
 753+ 5345 47               LD B,A
 754+ 5346 3A 85 4F         LD A,(AUTOSGAMNUM)
 755+ 5349 90               SUB B
 756+ 534A CA 04 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 757+ 534D FD 21 10 40      LD IY,FREEMEMPTR
 758+ 5351 FA 5D 53         JP M, .INCREASE
 759+ 5354                  ; new value is lower than previous one
 760+ 5354 CD 7E 53         CALL .SIZEDIFF
 761+ 5357 CD 41 50         CALL MAXANIMITEMS.DECREASE_COMMON
 762+ 535A C3 04 50         JP MAXANIMITEMS.EXIT
 763+ 535D              .INCREASE:
 764+ 535D ED 44            NEG
 765+ 535F F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 766+ 5360 CD 7E 53         CALL .SIZEDIFF
 767+ 5363 CD 6D 50         CALL MAXANIMITEMS.INCREASE_COMMON
 768+ 5366 AF               XOR A
 769+ 5367 ED 42            SBC HL,BC ; location of new stuff
 770+ 5369 F1               POP AF
 771+ 536A C5               PUSH BC
 772+ 536B 47               LD B,A
 773+ 536C 11 18 00         LD DE,24
 774+ 536F E5               PUSH HL
 775+ 5370 DD E1            POP IX
 776+ 5372              .L1:
 777+ 5372 DD 36 13 00      LD (IX+19),0 ; active flag
 778+ 5376 DD 19            ADD IX,DE
 779+ 5378 10 F8            DJNZ .L1
 780+ 537A C1               POP BC
 781+ 537B C3 04 50         JP MAXANIMITEMS.EXIT
 782+ 537E              .SIZEDIFF:
 783+ 537E 26 00            LD H,0
 784+ 5380 6F               LD L,A
 785+ 5381 CD B8 64         CALL HLx8
 786+ 5384 54               LD D,H
 787+ 5385 5D               LD E,L
 788+ 5386 29               ADD HL,HL
 789+ 5387 19               ADD HL,DE
 790+ 5388 78               LD A,B
 791+ 5389 32 85 4F         LD (AUTOSGAMNUM),A
 792+ 538C 44               LD B,H
 793+ 538D 4D               LD C,L
 794+ 538E C9               RET ; BC=size difference in bytes
 795+ 538F              ; *******************************************************************************************************
 796+ 538F
 797+ 538F              ; *******************************************************************************************************
 798+ 538F              ; function to handle CALL AUTOSGAMDEF basic extension
 799+ 538F              ; AUTOSGAMDEF ( BYTE id,
 800+ 538F              ;               INT VARIABLE x, INT VARIABLE y,
 801+ 538F              ;               INT minimum, INT maximum, INT delta,
 802+ 538F              ;               INT direction =0 horizontal,
 803+ 538F              ;               INT ticks,
 804+ 538F              ;               BYTE sprite_group_count,
 805+ 538F              ;               INT[2][sprite_group_count] VARIABLE sprite_group,
 806+ 538F              ;               BYTE item_number,
 807+ 538F              ;               INT[] VARIABLE sprite_animations_negative_direction,
 808+ 538F              ;               INT[] VARIABLE sprite_animations_positive_direction
 809+ 538F              AUTOSGAMDEF:
 810+ 538F                  ; opening (
 811+ 538F CD CA 65     	CALL CHKCHAR
 812+ 5392 28           	DB '('
 813+ 5393              	; get sprite animation id
 814+ 5393 DD 21 1C 52  	LD IX, GETBYT
 815+ 5397 CD 59 01     	CALL CALBAS
 816+ 539A F5               PUSH AF
 817+ 539B 3C               INC A
 818+ 539C 4F               LD C,A
 819+ 539D 3A 85 4F         LD A,(AUTOSGAMNUM)
 820+ 53A0 B9               CP C
 821+ 53A1 DA E2 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 822+ 53A4 F1               POP AF
 823+ 53A5 E5               PUSH HL
 824+ 53A6 CD B2 4F         CALL GETnthAUTOSGAM
 825+ 53A9 22 C1 62         LD (BLIT_TMP),HL ; for later
 826+ 53AC E1               POP HL
 827+ 53AD              	; comma
 828+ 53AD CD CA 65     	CALL CHKCHAR
 829+ 53B0 2C           	DB ','
 830+ 53B1              	; get address of the X coordinate variable
 831+ 53B1 DD 21 A4 5E  	LD IX, PTRGET
 832+ 53B5 CD 59 01     	CALL CALBAS
 833+ 53B8 DD 2A C1 62  	LD IX,(BLIT_TMP)
 834+ 53BC DD 73 00         LD (IX+0),E
 835+ 53BF DD 72 01         LD (IX+1),D
 836+ 53C2              	; comma
 837+ 53C2 CD CA 65     	CALL CHKCHAR
 838+ 53C5 2C           	DB ','
 839+ 53C6              	; get address of the Y coordinate variable
 840+ 53C6 DD 21 A4 5E  	LD IX, PTRGET
 841+ 53CA CD 59 01     	CALL CALBAS
 842+ 53CD DD 2A C1 62  	LD IX,(BLIT_TMP)
 843+ 53D1 DD 73 02         LD (IX+2),E
 844+ 53D4 DD 72 03         LD (IX+3),D
 845+ 53D7              	; comma
 846+ 53D7 CD CA 65     	CALL CHKCHAR
 847+ 53DA 2C           	DB ','
 848+ 53DB              	; get minimum value
 849+ 53DB DD 21 2F 54  	LD IX, FRMQNT
 850+ 53DF CD 59 01     	CALL CALBAS
 851+ 53E2 DD 2A C1 62  	LD IX,(BLIT_TMP)
 852+ 53E6 DD 73 04         LD (IX+4),E
 853+ 53E9 DD 72 05         LD (IX+5),D
 854+ 53EC              	; comma
 855+ 53EC CD CA 65     	CALL CHKCHAR
 856+ 53EF 2C           	DB ','
 857+ 53F0              	; get maximum value
 858+ 53F0 DD 21 2F 54  	LD IX, FRMQNT
 859+ 53F4 CD 59 01     	CALL CALBAS
 860+ 53F7 DD 2A C1 62  	LD IX,(BLIT_TMP)
 861+ 53FB DD 73 06         LD (IX+6),E
 862+ 53FE DD 72 07         LD (IX+7),D
 863+ 5401              	; comma
 864+ 5401 CD CA 65     	CALL CHKCHAR
 865+ 5404 2C           	DB ','
 866+ 5405              	; get delta value
 867+ 5405 DD 21 2F 54  	LD IX, FRMQNT
 868+ 5409 CD 59 01     	CALL CALBAS
 869+ 540C DD 2A C1 62  	LD IX,(BLIT_TMP)
 870+ 5410 DD 73 08         LD (IX+8),E
 871+ 5413 DD 72 09         LD (IX+9),D
 872+ 5416              	; comma
 873+ 5416 CD CA 65     	CALL CHKCHAR
 874+ 5419 2C           	DB ','
 875+ 541A              	; get direction value
 876+ 541A DD 21 2F 54  	LD IX, FRMQNT
 877+ 541E CD 59 01     	CALL CALBAS
 878+ 5421 DD 2A C1 62  	LD IX,(BLIT_TMP)
 879+ 5425 DD 73 0A         LD (IX+10),E
 880+ 5428 DD 72 0B         LD (IX+11),D
 881+ 542B              	; comma
 882+ 542B CD CA 65     	CALL CHKCHAR
 883+ 542E 2C           	DB ','
 884+ 542F              	; get ticks value
 885+ 542F DD 21 2F 54  	LD IX, FRMQNT
 886+ 5433 CD 59 01     	CALL CALBAS
 887+ 5436 DD 2A C1 62  	LD IX,(BLIT_TMP)
 888+ 543A DD 73 14         LD (IX+20),E
 889+ 543D DD 72 15         LD (IX+21),D
 890+ 5440              	; comma
 891+ 5440 CD CA 65     	CALL CHKCHAR
 892+ 5443 2C           	DB ','
 893+ 5444              	; get sprite group count
 894+ 5444 DD 21 1C 52  	LD IX, GETBYT
 895+ 5448 CD 59 01     	CALL CALBAS
 896+ 544B B7               OR A
 897+ 544C CA E2 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
 898+ 544F DD 2A C1 62  	LD IX,(BLIT_TMP)
 899+ 5453 DD 77 0B         LD (IX+11),A
 900+ 5456              	; comma
 901+ 5456 CD CA 65     	CALL CHKCHAR
 902+ 5459 2C           	DB ','
 903+ 545A              	; get sprite group definition array data pointer
 904+ 545A DD 2A C1 62  	LD IX,(BLIT_TMP)
 905+ 545E DD 5E 0B         LD E,(IX+11)
 906+ 5461 16 03        	LD D,3
 907+ 5463 3E 02        	LD A,2
 908+ 5465 47           	LD B,A
 909+ 5466 CD F7 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
 910+ 5469 DD 2A C1 62  	LD IX,(BLIT_TMP)
 911+ 546D DD 71 0C     	LD (IX+12),C
 912+ 5470 DD 70 0D         LD (IX+13),B
 913+ 5473              	; comma
 914+ 5473 CD CA 65     	CALL CHKCHAR
 915+ 5476 2C           	DB ','
 916+ 5477              	; get sprite animation array size
 917+ 5477 DD 21 1C 52  	LD IX,GETBYT
 918+ 547B CD 59 01     	CALL CALBAS
 919+ 547E DD 2A C1 62  	LD IX,(BLIT_TMP)
 920+ 5482 DD 77 0E         LD (IX+14),A
 921+ 5485 B7               OR A
 922+ 5486 CA E2 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
 923+ 5489              	; comma
 924+ 5489 CD CA 65     	CALL CHKCHAR
 925+ 548C 2C           	DB ','
 926+ 548D                  ; get array pointer for negative direction
 927+ 548D DD 2A C1 62  	LD IX,(BLIT_TMP)
 928+ 5491 DD 56 0E         LD D,(IX+14)
 929+ 5494 3E 02            LD A,2
 930+ 5496 06 01            LD B,1
 931+ 5498 CD F7 65         CALL GET_BASIC_ARRAY_DATA_POINTER
 932+ 549B DD 2A C1 62  	LD IX,(BLIT_TMP)
 933+ 549F DD 71 0F         LD (IX+15),C
 934+ 54A2 DD 70 10         LD (IX+16),B
 935+ 54A5              	; comma
 936+ 54A5 CD CA 65     	CALL CHKCHAR
 937+ 54A8 2C           	DB ','
 938+ 54A9                  ; get array pointer for positive direction
 939+ 54A9 DD 2A C1 62  	LD IX,(BLIT_TMP)
 940+ 54AD DD 56 0E         LD D,(IX+14)
 941+ 54B0 3E 02            LD A,2
 942+ 54B2 06 01            LD B,1
 943+ 54B4 CD F7 65         CALL GET_BASIC_ARRAY_DATA_POINTER
 944+ 54B7 DD 2A C1 62  	LD IX,(BLIT_TMP)
 945+ 54BB DD 71 11         LD (IX+17),C
 946+ 54BE DD 70 12         LD (IX+18),B
 947+ 54C1              	; ending )
 948+ 54C1 CD CA 65     	CALL CHKCHAR
 949+ 54C4 29           	DB ')'
 950+ 54C5 C9               RET
 951+ 54C6              ; *******************************************************************************************************
 952+ 54C6
 953+ 54C6              ; *******************************************************************************************************
 954+ 54C6              ; function to handle CALL AUTOSGAMSTART basic extension
 955+ 54C6              ; AUTOSGAMSTART ( BYTE id )
 956+ 54C6              AUTOSGAMSTART:
 957+ 54C6 3E 01            LD A,1
 958+ 54C8              .COMMON:
 959+ 54C8 32 F4 54         LD (.SETVALUE+3),A
 960+ 54CB                  ; opening (
 961+ 54CB CD CA 65     	CALL CHKCHAR
 962+ 54CE 28           	DB '('
 963+ 54CF              	; get sprite animation id
 964+ 54CF DD 21 1C 52  	LD IX, GETBYT
 965+ 54D3 CD 59 01     	CALL CALBAS
 966+ 54D6 F5               PUSH AF
 967+ 54D7 3C               INC A
 968+ 54D8 4F               LD C,A
 969+ 54D9 3A 85 4F         LD A,(AUTOSGAMNUM)
 970+ 54DC B9               CP C
 971+ 54DD DA E2 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 972+ 54E0 F1               POP AF
 973+ 54E1 E5               PUSH HL
 974+ 54E2 CD B2 4F         CALL GETnthAUTOSGAM
 975+ 54E5 E5               PUSH HL
 976+ 54E6 DD E1            POP IX
 977+ 54E8 E1               POP HL
 978+ 54E9 DD E5            PUSH IX
 979+ 54EB              	; ending )
 980+ 54EB CD CA 65     	CALL CHKCHAR
 981+ 54EE 29           	DB ')'
 982+ 54EF
 983+ 54EF                  ; so syntax is fine
 984+ 54EF DD E1            POP IX
 985+ 54F1              .SETVALUE:
 986+ 54F1 DD 36 13 01      LD (IX+19),1 ; active flag
 987+ 54F5                  ; set initial timer
 988+ 54F5 DD 7E 14         LD A,(IX+20)
 989+ 54F8 DD 77 16         LD (IX+22),A
 990+ 54FB DD 7E 15         LD A,(IX+21)
 991+ 54FE DD 77 17         LD (IX+23),A
 992+ 5501 C9               RET
 993+ 5502              ; *******************************************************************************************************
 994+ 5502
 995+ 5502              ; *******************************************************************************************************
 996+ 5502              ; function to handle CALL AUTOSGAMSTOP basic extension
 997+ 5502              ; AUTOSGAMSTOP ( BYTE id )
 998+ 5502              AUTOSGAMSTOP:
 999+ 5502 AF               XOR A
1000+ 5503 18 C3            JR AUTOSGAMSTART.COMMON
1001+ 5505              ; *******************************************************************************************************
1002+ 5505
1003+ 5505              ; *******************************************************************************************************
1004+ 5505              ; function to handle CALL ANIMSTEP basic extension
1005+ 5505              ; two forms
1006+ 5505              ; ANIMSTEP ( BYTE id )
1007+ 5505              ; or
1008+ 5505              ; ANIMSTEP ( BYTE item_number,
1009+ 5505              ;            INT[] sprite_animations )
1010+ 5505              ANIMSTEP:
1011+ 5505 11 84 55         LD DE,ANIMSTARTSTOP_COMMON.STEP
1012+ 5508 18 08            JR ANIMSTARTSTOP_COMMON
1013+ 550A              ; *******************************************************************************************************
1014+ 550A              ; *******************************************************************************************************
1015+ 550A              ; function to handle CALL ANIMSTART basic extension
1016+ 550A              ; two forms
1017+ 550A              ; ANIMSTART ( BYTE id )
1018+ 550A              ; or
1019+ 550A              ; ANIMSTART ( BYTE item_number,
1020+ 550A              ;             INT[] sprite_animations )
1021+ 550A              ; sets active flag to 1
1022+ 550A              ANIMSTART:
1023+ 550A 11 72 55         LD DE,ANIMSTARTSTOP_COMMON.START
1024+ 550D 18 03            JR ANIMSTARTSTOP_COMMON
1025+ 550F              ; *******************************************************************************************************
1026+ 550F              ; *******************************************************************************************************
1027+ 550F              ; function to handle CALL ANIMSTOP basic extension
1028+ 550F              ; two forms
1029+ 550F              ; ANIMSTOP ( BYTE id )
1030+ 550F              ; or
1031+ 550F              ; ANIMSTOP ( BYTE item_number,
1032+ 550F              ;            INT[] sprite_animations )
1033+ 550F              ; sets active flag to 0
1034+ 550F              ANIMSTOP:
1035+ 550F 11 7F 55         LD DE,ANIMSTARTSTOP_COMMON.STOP
1036+ 5512              ; *******************************************************************************************************
1037+ 5512              ANIMSTARTSTOP_COMMON:
1038+ 5512 ED 53 70 55      LD (ANIMSTARTSTOP_COMMON.FN+1),DE
1039+ 5516                  ; opening (
1040+ 5516 CD CA 65     	CALL CHKCHAR
1041+ 5519 28           	DB '('
1042+ 551A              	; get sprite animation id or array size
1043+ 551A DD 21 1C 52  	LD IX,GETBYT
1044+ 551E CD 59 01     	CALL CALBAS
1045+ 5521 F5               PUSH AF
1046+ 5522                  ; check if comma present
1047+ 5522 CD D4 65         CALL GETPREVCHAR
1048+ 5525 23               INC HL
1049+ 5526 FE 2C            CP ','
1050+ 5528 28 0E            JR Z,.L1
1051+ 552A FE 29            CP ')'
1052+ 552C C2 EE 65         JP NZ,SYNTAX_ERROR
1053+ 552F                  ; ok so single argument variant
1054+ 552F F1               POP AF
1055+ 5530 E5               PUSH HL
1056+ 5531 F3               DI
1057+ 5532 CD 5E 55         CALL .SETVALUE
1058+ 5535 FB               EI
1059+ 5536 E1               POP HL
1060+ 5537 C9               RET
1061+ 5538              .L1:
1062+ 5538                  ; get array pointer
1063+ 5538 D1               POP DE
1064+ 5539 D5               PUSH DE
1065+ 553A 3E 02            LD A,2
1066+ 553C 06 01            LD B,1
1067+ 553E CD F7 65         CALL GET_BASIC_ARRAY_DATA_POINTER
1068+ 5541 C5               PUSH BC
1069+ 5542              	; ending )
1070+ 5542 CD CA 65     	CALL CHKCHAR
1071+ 5545 29           	DB ')'
1072+ 5546 D1               POP DE ; array pointer
1073+ 5547 C1               POP BC ; number of items
1074+ 5548 78               LD A,B
1075+ 5549 B7               OR A
1076+ 554A CA E2 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
1077+ 554D E5               PUSH HL
1078+ 554E F3               DI
1079+ 554F              .L2:
1080+ 554F C5               PUSH BC
1081+ 5550 1A               LD A,(DE)
1082+ 5551 13          > INC DE
1082+ 5552 13          > INC DE
1083+ 5553 D5               PUSH DE
1084+ 5554 CD 5E 55         CALL .SETVALUE
1085+ 5557 D1               POP DE
1086+ 5558 C1               POP BC
1087+ 5559 10 F4            DJNZ .L2
1088+ 555B FB               EI
1089+ 555C E1               POP HL
1090+ 555D C9               RET
1091+ 555E
1092+ 555E              .SETVALUE:
1093+ 555E 47               LD B,A
1094+ 555F 3C               INC A
1095+ 5560 4F               LD C,A
1096+ 5561 3A 82 4F         LD A,(ANIMSPRNUM)
1097+ 5564 B9               CP C
1098+ 5565 DA E2 65         JP C,SUBSCRIPT_OUT_OF_RANGE
1099+ 5568 78               LD A,B
1100+ 5569 CD A6 4F         CALL GETnthSPRANIM
1101+ 556C E5               PUSH HL
1102+ 556D DD E1            POP IX
1103+ 556F              .FN:
1104+ 556F C3 00 00         JP 0
1105+ 5572              .START:
1106+ 5572 DD 36 06 01      LD (IX+6),1 ; active flag
1107+ 5576 DD 36 03 00      LD (IX+3),0 ; current item
1108+ 557A 06 00            LD B,0 ; setup timer
1109+ 557C C3 03 56         JP SETUP_ANIM_STEP
1110+ 557F              .STOP:
1111+ 557F DD 36 06 00      LD (IX+6),0 ; active flag
1112+ 5583 C9               RET
1113+ 5584              .STEP:
1114+ 5584 06 00            LD B,0
1115+ 5586 C3 A7 55         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1116+ 5589              ; *******************************************************************************************************
1117+ 5589
1118+ 5589              ; *******************************************************************************************************
1119+ 5589              ; function processes animations during vblank period
1120+ 5589              PROCESS_ANIMATIONS:
1121+ 5589 3A 82 4F         LD A,(ANIMSPRNUM)
1122+ 558C B7               OR A
1123+ 558D C8               RET Z; no animations defined
1124+ 558E 47               LD B,A
1125+ 558F DD 2A 83 4F      LD IX,(ANIMSPRPTR)
1126+ 5593              .L1:
1127+ 5593 C5               PUSH BC
1128+ 5594 06 00            LD B,0 ; normal mode, change on timer expiry only
1129+ 5596 CD A2 55         CALL PROCESS_SINGLE_ANIMATION
1130+ 5599 11 08 00         LD DE,8
1131+ 559C DD 19            ADD IX,DE
1132+ 559E C1               POP BC
1133+ 559F 10 F2            DJNZ .L1
1134+ 55A1 C9               RET
1135+ 55A2              ; *******************************************************************************************************
1136+ 55A2
1137+ 55A2              ; *******************************************************************************************************
1138+ 55A2              ; processes single sprite animation
1139+ 55A2              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
1140+ 55A2              ; on timer expiry goes to next animation item
1141+ 55A2              ; input IX=sprite animation pointer
1142+ 55A2              ; input B=1 force mode, activate animation action regardless of expired timer
1143+ 55A2              PROCESS_SINGLE_ANIMATION:
1144+ 55A2 DD 7E 06         LD A,(IX+6); active
1145+ 55A5 B7               OR A
1146+ 55A6 C8               RET Z ; inactive animation
1147+ 55A7              .INACTIVE_TOO:
1148+ 55A7 DD 6E 01         LD L,(IX+1)
1149+ 55AA DD 66 02         LD H,(IX+2) ; HL=end time
1150+ 55AD 2B               DEC HL
1151+ 55AE DD 75 01         LD (IX+1),L
1152+ 55B1 DD 74 02         LD (IX+2),H
1153+ 55B4 7D               LD A,L
1154+ 55B5 B4               OR H
1155+ 55B6 28 06            JR Z,.STEP
1156+ 55B8 05               DEC B
1157+ 55B9 04               INC B
1158+ 55BA C8               RET Z ; not forced mode, return
1159+ 55BB C3 03 56         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
1160+ 55BE              .STEP:
1161+ 55BE 06 00            LD B,0; setup timer
1162+ 55C0 DD 34 03         INC (IX+3) ; current animation item
1163+ 55C3 C3 03 56         JP SETUP_ANIM_STEP
1164+ 55C6              ; *******************************************************************************************************
1165+ 55C6
1166+ 55C6              ; *******************************************************************************************************
1167+ 55C6              ; function will setup sprite animation after current item change
1168+ 55C6              ; input A=current animation definition
1169+ 55C6              ; input IX=pointer to sprite animation
1170+ 55C6              ; input B=1 skip timer setup
1171+ 55C6              ; output IY=pointer to animation item
1172+ 55C6              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
1173+ 55C6              ; basically sets new end time for current animation
1174+ 55C6              INIT_CURRENT_ANIMATION:
1175+ 55C6 CD 9A 4F         CALL GETnthANIMDEF
1176+ 55C9 DD 7E 03         LD A,(IX+3) ; current animation item
1177+ 55CC BE               CP (HL) ; number of animation items in the animation definition
1178+ 55CD 38 0A            JR C,.L3 ; last item not reached
1179+ 55CF                  ; last item reached
1180+ 55CF DD 7E 05         LD A,(IX+5) ; cyclic flag
1181+ 55D2 B7               OR A
1182+ 55D3 28 2C            JR Z,.ERROR ; non-cyclic animation
1183+ 55D5                  ; cyclic animation, restart
1184+ 55D5 DD 36 03 00      LD (IX+3),0; current item
1185+ 55D9              .L3:
1186+ 55D9                  ; HL = animation definition
1187+ 55D9 23               INC HL ; skip animation definition size field
1188+ 55DA 16 00            LD D,0
1189+ 55DC DD 5E 03         LD E,(IX+3); current item
1190+ 55DF 19               ADD HL,DE
1191+ 55E0 4E               LD C,(HL) ; current animation item
1192+ 55E1 0C               INC C
1193+ 55E2 3A 7C 4F         LD A,(ANIMITEMNUM)
1194+ 55E5 B9               CP C
1195+ 55E6 38 19            JR C,.ERROR ; invalid animation item, stop animation
1196+ 55E8 0D               DEC C
1197+ 55E9 79               LD A,C
1198+ 55EA CD 91 4F         CALL GETnthANIMITEM
1199+ 55ED E5               PUSH HL
1200+ 55EE FD E1            POP IY ; IY=animation item
1201+ 55F0 05               DEC B
1202+ 55F1 28 0C            JR Z,.EXIT
1203+ 55F3 FD 5E 01         LD E,(IY+1)
1204+ 55F6 FD 56 02         LD D,(IY+2) ; duration
1205+ 55F9 DD 73 01         LD (IX+1),E
1206+ 55FC DD 72 02         LD (IX+2),D
1207+ 55FF              .EXIT:
1208+ 55FF AF               XOR A
1209+ 5600 C9               RET
1210+ 5601              .ERROR:
1211+ 5601 37               SCF
1212+ 5602 C9               RET
1213+ 5603              ; *******************************************************************************************************
1214+ 5603
1215+ 5603              ; *******************************************************************************************************
1216+ 5603              ; function will display currect item and set up expiry time
1217+ 5603              ; it will also stop the animation if expired
1218+ 5603              ; sets sprite update flag if any changes in sprite data made
1219+ 5603              ; input IX=current sprite animation
1220+ 5603              ; input B=1 skip timer setup
1221+ 5603              SETUP_ANIM_STEP:
1222+ 5603 DD 4E 04         LD C,(IX+4) ; animation definition ID
1223+ 5606 0C               INC C
1224+ 5607 3A 7F 4F         LD A,(ANIMDEFNUM)
1225+ 560A B9               CP C
1226+ 560B 30 05            JR NC,.L2
1227+ 560D                  ; given animation item is outside of bounds, deactivate animation
1228+ 560D              .STOPANIM:
1229+ 560D DD 36 06 00      LD (IX+6),0
1230+ 5611 C9               RET
1231+ 5612              .L2:
1232+ 5612 0D               DEC C
1233+ 5613 79               LD A,C
1234+ 5614 CD C6 55         CALL INIT_CURRENT_ANIMATION
1235+ 5617 38 F4            JR C, .STOPANIM
1236+ 5619 FD 7E 00         LD A,(IY) ; type of animation item
1237+ 561C B7               OR A
1238+ 561D 28 44            JR Z,.L4 ; change pattern and/or color
1239+ 561F              .PAT:
1240+ 561F                  ; change pattern definition
1241+ 561F                  ; check if sprite or character
1242+ 561F DD 7E 07         LD A,(IX+7)
1243+ 5622 B7               OR A
1244+ 5623 20 58            JR NZ,.CHAR
1245+ 5625 DD 7E 00         LD A,(IX) ; sprite number
1246+ 5628 CD 89 4D         CALL GETnthSPRATTR
1247+ 562B 23          > INC HL ; skip y and x
1247+ 562C 23          > INC HL
1247+ 562D 23          > INC HL
1247+ 562E 23          > INC HL
1248+ 562F 7E               LD A,(HL); current pattern
1249+ 5630 26 00            LD H,0
1250+ 5632 6F               LD L,A
1251+ 5633 3A E0 F3         LD A,(REG1SAV)
1252+ 5636 E6 02            AND 2
1253+ 5638 20 07            JR NZ,.L6
1254+ 563A                  ; 8x8 sprite
1255+ 563A CD B8 64         CALL HLx8
1256+ 563D 06 08            LD B,8
1257+ 563F 18 05            JR .L5
1258+ 5641              .L6:
1259+ 5641 CD B6 64         CALL HLx32
1260+ 5644 06 20            LD B,32
1261+ 5646              .L5:
1262+ 5646 3A AF FC         LD A,(SCRMOD)
1263+ 5649 3D               DEC A
1264+ 564A 20 06            JR NZ,.L10
1265+ 564C ED 5B C5 F3      LD DE,(T32PAT)
1266+ 5650 18 04            JR .L7
1267+ 5652              .L10:
1268+ 5652 ED 5B CF F3      LD DE,(GRPPAT)
1269+ 5656              .L7:
1270+ 5656 19               ADD HL,DE
1271+ 5657 CD A3 64         CALL SETWRT_LOCAL
1272+ 565A FD 6E 03         LD L,(IY+3)
1273+ 565D FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
1274+ 5660 C3 AE 64         JP BBYTECOPY
1275+ 5663              .L4:
1276+ 5663                  ; change pattern and color in sprite attributes table
1277+ 5663 DD 7E 00         LD A,(IX) ; sprite number
1278+ 5666 CD 89 4D         CALL GETnthSPRATTR
1279+ 5669 23          > INC HL ; skip y and x
1279+ 566A 23          > INC HL
1279+ 566B 23          > INC HL
1279+ 566C 23          > INC HL
1280+ 566D FD 7E 03         LD A,(IY+3) ; new pattern
1281+ 5670 77               LD (HL),A
1282+ 5671 23          > INC HL
1282+ 5672 23          > INC HL
1283+ 5673 FD 7E 04         LD A,(IY+4) ; new color
1284+ 5676 77               LD (HL),A
1285+ 5677 2A 80 4D         LD HL,(SPRATR_UPDATE_FLAG)
1286+ 567A 36 01            LD (HL),1
1287+ 567C C9               RET
1288+ 567D              .CHAR:
1289+ 567D DD 6E 00         LD L,(IX)
1290+ 5680 3D               DEC A
1291+ 5681 67               LD H,A
1292+ 5682 CD B8 64         CALL HLx8
1293+ 5685 3A AF FC         LD A,(SCRMOD)
1294+ 5688 3D               DEC A
1295+ 5689 20 06            JR NZ,.L8
1296+ 568B ED 5B C1 F3      LD DE,(T32CGP)
1297+ 568F 18 04            JR .L9
1298+ 5691              .L8:
1299+ 5691 ED 5B CB F3      LD DE,(GRPCGP)
1300+ 5695              .L9:
1301+ 5695 06 08            LD B,8
1302+ 5697 18 BD            JR .L7
1303+ 5699              ; *******************************************************************************************************
1304+ 5699
# file closed: asm\ANIMATION.asm
 134  5699               INCLUDE "SGAM.asm"
# file opened: asm\SGAM.asm
   1+ 5699              ; Sprite Group Animate and Move
   2+ 5699
   3+ 5699              ; *******************************************************************************************************
   4+ 5699              ; shared function to process a list of animations
   5+ 5699              ; input B=list size
   6+ 5699              ; input DE=list pointer
   7+ 5699              SGAM_PROCESS_ANIM_LIST:
   8+ 5699 21 AC 56         LD HL,.STEP
   9+ 569C 22 70 55         LD (ANIMSTARTSTOP_COMMON.FN+1),HL
  10+ 569F              .L1:
  11+ 569F C5               PUSH BC
  12+ 56A0 1A               LD A,(DE)
  13+ 56A1 13          > INC DE
  13+ 56A2 13          > INC DE
  14+ 56A3 D5               PUSH DE
  15+ 56A4 CD 5E 55         CALL ANIMSTARTSTOP_COMMON.SETVALUE
  16+ 56A7 D1               POP DE
  17+ 56A8 C1               POP BC
  18+ 56A9 10 F4            DJNZ .L1
  19+ 56AB C9           	RET
  20+ 56AC              .STEP:
  21+ 56AC 06 01            LD B,1
  22+ 56AE C3 A7 55         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
  23+ 56B1              ; *******************************************************************************************************
  24+ 56B1
  25+ 56B1              ; *******************************************************************************************************
  26+ 56B1              ; function to handle CALL SGAM basic extension
  27+ 56B1              ; sets position of a group of sprites as described in SPRGRPMOV
  28+ 56B1              ; and manually animate a list of animations
  29+ 56B1              ; _SGAM ( INT x,
  30+ 56B1              ;	      INT y,
  31+ 56B1              ;		  BYTE count,
  32+ 56B1              ;		  INT[2][count] data_ptr,
  33+ 56B1              ;         BYTE item_number,
  34+ 56B1              ;         INT[] sprite_animations )
  35+ 56B1              ; will put ram in page 0 also, page 1 is already there
  36+ 56B1              SGAM:
  37+ 56B1 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
  38+ 56B4 B7           	OR A
  39+ 56B5 CA EA 65     	JP Z,ILLEGAL_FUNCTION
  40+ 56B8              	; opening (
  41+ 56B8 CD CA 65     	CALL CHKCHAR
  42+ 56BB 28           	DB '('
  43+ 56BC              	; get x
  44+ 56BC DD 21 2F 54  	LD IX, FRMQNT
  45+ 56C0 CD 59 01     	CALL CALBAS
  46+ 56C3 ED 53 C5 62  	LD (BLIT_STRUCT),DE
  47+ 56C7              	; comma
  48+ 56C7 CD CA 65     	CALL CHKCHAR
  49+ 56CA 2C           	DB ','
  50+ 56CB              	; get y
  51+ 56CB DD 21 2F 54  	LD IX, FRMQNT
  52+ 56CF CD 59 01     	CALL CALBAS
  53+ 56D2 ED 53 C7 62  	LD (BLIT_STRUCT+2),DE
  54+ 56D6              	; comma
  55+ 56D6 CD CA 65     	CALL CHKCHAR
  56+ 56D9 2C           	DB ','
  57+ 56DA              	; get count
  58+ 56DA DD 21 1C 52  	LD IX, GETBYT
  59+ 56DE CD 59 01     	CALL CALBAS
  60+ 56E1 B7               OR A
  61+ 56E2 CA E2 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
  62+ 56E5 32 C9 62     	LD (BLIT_STRUCT+4),A
  63+ 56E8              	; comma
  64+ 56E8 CD CA 65     	CALL CHKCHAR
  65+ 56EB 2C           	DB ','
  66+ 56EC              	; get sprite group definition array data pointer
  67+ 56EC 3A C9 62         LD A,(BLIT_STRUCT+4)
  68+ 56EF 5F           	LD E,A
  69+ 56F0 16 03        	LD D,3
  70+ 56F2 3E 02        	LD A,2
  71+ 56F4 47           	LD B,A
  72+ 56F5 CD F7 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
  73+ 56F8 ED 43 CA 62  	LD (BLIT_STRUCT+5),BC
  74+ 56FC              	; comma
  75+ 56FC CD CA 65     	CALL CHKCHAR
  76+ 56FF 2C           	DB ','
  77+ 5700              	; get sprite animation array size
  78+ 5700 DD 21 1C 52  	LD IX,GETBYT
  79+ 5704 CD 59 01     	CALL CALBAS
  80+ 5707 32 CC 62         LD (BLIT_STRUCT+7),A
  81+ 570A B7               OR A
  82+ 570B CA E2 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
  83+ 570E              	; comma
  84+ 570E CD CA 65     	CALL CHKCHAR
  85+ 5711 2C           	DB ','
  86+ 5712                  ; get array pointer
  87+ 5712 3A CC 62         LD A,(BLIT_STRUCT+7)
  88+ 5715 57               LD D,A
  89+ 5716 3E 02            LD A,2
  90+ 5718 06 01            LD B,1
  91+ 571A CD F7 65         CALL GET_BASIC_ARRAY_DATA_POINTER
  92+ 571D ED 43 CD 62      LD (BLIT_STRUCT+8),BC
  93+ 5721              	; ending )
  94+ 5721 CD CA 65     	CALL CHKCHAR
  95+ 5724 29           	DB ')'
  96+ 5725              .ENTRY:
  97+ 5725 E5               PUSH HL
  98+ 5726 F3               DI
  99+ 5727
 100+ 5727              	; enable page 0
 101+ 5727 FD 21 2E 57  	LD IY, .RET
 102+ 572B C3 7C 65     	JP ENABLE_PAGE0
 103+ 572E              .RET:
 104+ 572E D9               EXX
 105+ 572F ED 5B C5 62      LD DE,(BLIT_STRUCT) ; initial x
 106+ 5733 ED 4B C7 62      LD BC,(BLIT_STRUCT+2) ; initial y
 107+ 5737 D9               EXX
 108+ 5738 2A CA 62         LD HL,(BLIT_STRUCT+5) ; pointer to data
 109+ 573B 3A C9 62         LD A,(BLIT_STRUCT+4) ; number of entries
 110+ 573E 47               LD B,A
 111+ 573F CD 6A 4F         CALL SPRGRPMOV.UPDATE_LOC
 112+ 5742
 113+ 5742 3A CC 62         LD A,(BLIT_STRUCT+7) ; anim number
 114+ 5745 47               LD B,A
 115+ 5746 ED 5B CD 62      LD DE,(BLIT_STRUCT+8) ; anim list
 116+ 574A CD 99 56     	CALL SGAM_PROCESS_ANIM_LIST
 117+ 574D
 118+ 574D D1               POP DE
 119+ 574E C1               POP BC
 120+ 574F CD F3 64         CALL RESTORE_PAGE_INFO
 121+ 5752 FB               EI
 122+ 5753 E1               POP HL
 123+ 5754 C9               RET
 124+ 5755              ; *******************************************************************************************************
 125+ 5755
 126+ 5755              ; *******************************************************************************************************
 127+ 5755              ; handles automatic move and animate sprite groups during interrupt
 128+ 5755              PROCESS_AUTOSGAMS:
 129+ 5755 3A 85 4F     	LD A,(AUTOSGAMNUM)
 130+ 5758 B7           	OR A
 131+ 5759 C8           	RET Z
 132+ 575A 47           	LD B,A
 133+ 575B DD 2A 86 4F  	LD IX,(AUTOSGAMPTR)
 134+ 575F              .L1:
 135+ 575F C5           	PUSH BC
 136+ 5760 DD 7E 13     	LD A,(IX+19) ; active flag
 137+ 5763 B7           	OR A
 138+ 5764 28 28        	JR Z,.LOOPEND
 139+ 5766              	; active, check timer
 140+ 5766 DD 6E 16     	LD L,(IX+22)
 141+ 5769 DD 66 17     	LD H,(IX+23) ; timer
 142+ 576C 2B           	DEC HL
 143+ 576D 7C           	LD A,H
 144+ 576E B5           	OR L
 145+ 576F 28 08        	JR Z,.L2
 146+ 5771              	; not expired
 147+ 5771 DD 75 16     	LD (IX+22),L
 148+ 5774 DD 74 17     	LD (IX+23),H
 149+ 5777 18 15        	JR .LOOPEND
 150+ 5779              .L2:
 151+ 5779              	; expired, process
 152+ 5779
 153+ 5779                  ; set initial timer
 154+ 5779 DD 7E 14         LD A,(IX+20)
 155+ 577C DD 77 16         LD (IX+22),A
 156+ 577F DD 7E 15         LD A,(IX+21)
 157+ 5782 DD 77 17         LD (IX+23),A
 158+ 5785
 159+ 5785 CD 97 57     	CALL .MOVE
 160+ 5788 CD 02 58     	CALL .UPDATELOC
 161+ 578B CD 27 58     	CALL .PROCESS_ANIM_LIST
 162+ 578E
 163+ 578E              .LOOPEND:
 164+ 578E 11 18 00     	LD DE,24
 165+ 5791 DD 19        	ADD IX,DE
 166+ 5793 C1           	POP BC
 167+ 5794 10 C9        	DJNZ .L1
 168+ 5796 C9           	RET
 169+ 5797
 170+ 5797              .MOVE:
 171+ 5797              	; process movement
 172+ 5797 DD 7E 0A     	LD A,(IX+10) ; direction
 173+ 579A B7           	OR A
 174+ 579B 28 08        	JR Z, .MOVE_L1
 175+ 579D              	; vertical
 176+ 579D DD 6E 02     	LD L,(IX+2)
 177+ 57A0 DD 66 03     	LD H,(IX+3) ; vertical variable pointer
 178+ 57A3 18 06        	JR .MOVE_L2
 179+ 57A5              .MOVE_L1:
 180+ 57A5              	; horizontal
 181+ 57A5 DD 6E 00     	LD L,(IX+0)
 182+ 57A8 DD 66 01     	LD H,(IX+1) ; horizontal variable pointer
 183+ 57AB              .MOVE_L2:
 184+ 57AB E5           	PUSH HL
 185+ 57AC FD E1        	POP IY
 186+ 57AE FD 6E 00     	LD L,(IY+0)
 187+ 57B1 FD 66 01     	LD H,(IY+1)
 188+ 57B4 DD 5E 08     	LD E,(IX+8)
 189+ 57B7 DD 56 09     	LD D,(IX+9) ; delta value
 190+ 57BA 19           	ADD HL,DE
 191+ 57BB E5           	PUSH HL
 192+ 57BC DD 5E 04     	LD E,(IX+4)
 193+ 57BF DD 56 05     	LD D,(IX+5) ; minimum value
 194+ 57C2 A7           	AND A
 195+ 57C3 ED 52        	SBC HL,DE
 196+ 57C5 FA DF 57     	JP M,.MOVE_L3 ; below minimum
 197+ 57C8 E1           	POP HL
 198+ 57C9 E5           	PUSH HL
 199+ 57CA DD 5E 06     	LD E,(IX+6)
 200+ 57CD DD 56 07     	LD D,(IX+7) ; maximum value
 201+ 57D0 EB           	EX DE,HL
 202+ 57D1 A7           	AND A
 203+ 57D2 ED 52        	SBC HL,DE
 204+ 57D4 FA E7 57     	JP M,.MOVE_L4 ; above maximum
 205+ 57D7 E1           	POP HL
 206+ 57D8              	; within bounds
 207+ 57D8              .MOVE_L5:
 208+ 57D8 FD 75 00     	LD (IY+0),L
 209+ 57DB FD 74 01     	LD (IY+1),H
 210+ 57DE C9           	RET
 211+ 57DF              .MOVE_L3:
 212+ 57DF E1           	POP HL
 213+ 57E0 CD F3 57     	CALL .INVERSE_DELTA
 214+ 57E3 6B           	LD L,E
 215+ 57E4 62           	LD H,D
 216+ 57E5 18 F1        	JR .MOVE_L5
 217+ 57E7              .MOVE_L4:
 218+ 57E7 E1           	POP HL
 219+ 57E8 CD F3 57     	CALL .INVERSE_DELTA
 220+ 57EB DD 6E 06     	LD L,(IX+6)
 221+ 57EE DD 66 07     	LD H,(IX+7) ; maximum
 222+ 57F1 18 E5        	JR .MOVE_L5
 223+ 57F3              .INVERSE_DELTA:
 224+ 57F3 AF           	XOR A
 225+ 57F4 DD 96 08     	SUB (IX+8)
 226+ 57F7 DD 77 08     	LD (IX+8),A
 227+ 57FA 9F           	SBC A,A
 228+ 57FB DD 96 09     	SUB (IX+9)
 229+ 57FE DD 77 09     	LD (IX+9),A
 230+ 5801 C9           	RET
 231+ 5802
 232+ 5802              .UPDATELOC:
 233+ 5802 DD E5        	PUSH IX
 234+ 5804 D9           	EXX
 235+ 5805 DD 6E 00     	LD L,(IX+0)
 236+ 5808 DD 66 01     	LD H,(IX+1)
 237+ 580B 5E           	LD E,(HL)
 238+ 580C 23           	INC HL
 239+ 580D 56           	LD D,(HL)
 240+ 580E DD 6E 02     	LD L,(IX+2)
 241+ 5811 DD 66 03     	LD H,(IX+3)
 242+ 5814 4E           	LD C,(HL)
 243+ 5815 23           	INC HL
 244+ 5816 46           	LD B,(HL)
 245+ 5817 D9           	EXX
 246+ 5818 DD 6E 0C     	LD L,(IX+12)
 247+ 581B DD 66 0D     	LD H,(IX+13) ; pointer to sprite group data
 248+ 581E DD 46 0B     	LD B,(IX+11) ; sprite group size
 249+ 5821 CD 6A 4F     	CALL SPRGRPMOV.UPDATE_LOC
 250+ 5824 DD E1        	POP IX
 251+ 5826 C9           	RET
 252+ 5827
 253+ 5827              .PROCESS_ANIM_LIST:
 254+ 5827 DD E5        	PUSH IX
 255+ 5829 DD 46 0E         LD B,(IX+14) ; anim list size
 256+ 582C DD CB 09 7E  	BIT 7,(IX+9)
 257+ 5830 28 08        	JR Z,.PROCESS_ANIM_LIST_L1
 258+ 5832              	; negative direction
 259+ 5832 DD 5E 0F     	LD E,(IX+15)
 260+ 5835 DD 56 10     	LD D,(IX+16)
 261+ 5838 18 06        	JR .PROCESS_ANIM_LIST_L2
 262+ 583A              .PROCESS_ANIM_LIST_L1:
 263+ 583A              	; positive direction
 264+ 583A DD 5E 11     	LD E,(IX+17)
 265+ 583D DD 56 12     	LD D,(IX+18)
 266+ 5840              .PROCESS_ANIM_LIST_L2:
 267+ 5840 CD 99 56     	CALL SGAM_PROCESS_ANIM_LIST
 268+ 5843 DD E1        	POP IX
 269+ 5845 C9           	RET
 270+ 5846              ; *******************************************************************************************************
 271+ 5846
# file closed: asm\SGAM.asm
 135  5846               ENDIF
 136  5846
 137  5846               IF (RAM_CMDS == 1)
 138  5846               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
   1+ 5846               IF (BASIC_EXTENSION == 1)
   2+ 5846              ; *******************************************************************************************************
   3+ 5846              ; function to handle CALL MEMCPY basic extension
   4+ 5846              ; _MEMCPY ( INT source,
   5+ 5846              ;			INT destination,
   6+ 5846              ;			INT count,
   7+ 5846              ; will put ram in page 0 also, page 1 is already there
   8+ 5846              MEMCPY:
   9+ 5846              	; opening (
  10+ 5846 CD CA 65     	CALL CHKCHAR
  11+ 5849 28           	DB '('
  12+ 584A              	; get source address
  13+ 584A DD 21 2F 54  	LD IX, FRMQNT
  14+ 584E CD 59 01     	CALL CALBAS
  15+ 5851 D5           	PUSH DE
  16+ 5852              	; comma
  17+ 5852 CD CA 65     	CALL CHKCHAR
  18+ 5855 2C           	DB ','
  19+ 5856              	; get destination address
  20+ 5856 DD 21 2F 54  	LD IX, FRMQNT
  21+ 585A CD 59 01     	CALL CALBAS
  22+ 585D D5           	PUSH DE
  23+ 585E              	; comma
  24+ 585E CD CA 65     	CALL CHKCHAR
  25+ 5861 2C           	DB ','
  26+ 5862              	; get length
  27+ 5862 DD 21 2F 54  	LD IX, FRMQNT
  28+ 5866 CD 59 01     	CALL CALBAS
  29+ 5869 D5           	PUSH DE
  30+ 586A              	; ending )
  31+ 586A CD CA 65     	CALL CHKCHAR
  32+ 586D 29           	DB ')'
  33+ 586E
  34+ 586E              	; save position
  35+ 586E E5           	PUSH HL
  36+ 586F DD E1        	POP IX
  37+ 5871
  38+ 5871 C1           	POP BC ; count
  39+ 5872 D1           	POP DE ; destination
  40+ 5873 E1           	POP HL ; source
  41+ 5874 D9           	EXX
  42+ 5875              	; enable page 0
  43+ 5875 F3           	DI
  44+ 5876 FD 21 7D 58  	LD IY, .RET
  45+ 587A C3 7C 65     	JP ENABLE_PAGE0
  46+ 587D              .RET:
  47+ 587D FB           	EI
  48+ 587E D9           	EXX
  49+ 587F ED B0        	LDIR
  50+ 5881 D1               POP DE
  51+ 5882 C1               POP BC
  52+ 5883 CD F3 64         CALL RESTORE_PAGE_INFO
  53+ 5886 DD E5        	PUSH IX
  54+ 5888 E1           	POP HL
  55+ 5889 C9           	RET
  56+ 588A              ; *******************************************************************************************************
  57+ 588A               ENDIF
  58+ 588A
  59+ 588A               IF (DEFUSR_EXTENSION == 1)
  60+ 588A              ; *******************************************************************************************************
  61+ 588A              ; same as MEMCPY but for DEFUSR approach
  62+ 588A              ; input IX=pointer to input array, real data from +2
  63+ 588A              ; +2 = source address
  64+ 588A              ; +4 = destination address
  65+ 588A              ; +6 = lenght
  66+ 588A              MEMCPY_DEFUSR:
  67+ 588A              	; enable page 0
  68+ 588A F3           	DI
  69+ 588B FD 21 92 58  	LD IY, .RET
  70+ 588F C3 7C 65     	JP ENABLE_PAGE0
  71+ 5892              .RET:
  72+ 5892 FB           	EI
  73+ 5893 DD 6E 02     	LD L,(IX+2)
  74+ 5896 DD 66 03     	LD H,(IX+3)
  75+ 5899 DD 5E 04     	LD E,(IX+4)
  76+ 589C DD 56 05     	LD D,(IX+5)
  77+ 589F DD 4E 06     	LD C,(IX+6)
  78+ 58A2 DD 46 07     	LD B,(IX+7)
  79+ 58A5 ED B0        	LDIR
  80+ 58A7 D1               POP DE
  81+ 58A8 C1               POP BC
  82+ 58A9 C3 F3 64         JP RESTORE_PAGE_INFO
  83+ 58AC              ; *******************************************************************************************************
  84+ 58AC               ENDIF
  85+ 58AC
  86+ 58AC              ; *******************************************************************************************************
  87+ 58AC              ; function to handle CALL FILRAM basic extension
  88+ 58AC              ; FILRAM ( INT start address,
  89+ 58AC              ;		   INT count,
  90+ 58AC              ;		   BYTE value )
  91+ 58AC              ; will put ram in page 0 also, page 1 is already there
  92+ 58AC              FILRAM:
  93+ 58AC              	; opening (
  94+ 58AC CD CA 65     	CALL CHKCHAR
  95+ 58AF 28           	DB '('
  96+ 58B0              	; get start address
  97+ 58B0 DD 21 2F 54  	LD IX, FRMQNT
  98+ 58B4 CD 59 01     	CALL CALBAS
  99+ 58B7 D5           	PUSH DE
 100+ 58B8              	; comma
 101+ 58B8 CD CA 65     	CALL CHKCHAR
 102+ 58BB 2C           	DB ','
 103+ 58BC              	; get count
 104+ 58BC DD 21 2F 54  	LD IX, FRMQNT
 105+ 58C0 CD 59 01     	CALL CALBAS
 106+ 58C3 D5           	PUSH DE
 107+ 58C4              	; comma
 108+ 58C4 CD CA 65     	CALL CHKCHAR
 109+ 58C7 2C           	DB ','
 110+ 58C8              	; get value
 111+ 58C8 DD 21 1C 52  	LD IX, GETBYT
 112+ 58CC CD 59 01     	CALL CALBAS
 113+ 58CF F5           	PUSH AF
 114+ 58D0              	; ending )
 115+ 58D0 CD CA 65     	CALL CHKCHAR
 116+ 58D3 29           	DB ')'
 117+ 58D4
 118+ 58D4              	; save position
 119+ 58D4 E5           	PUSH HL
 120+ 58D5 DD E1        	POP IX
 121+ 58D7
 122+ 58D7 D1           	POP DE ; actually AF
 123+ 58D8 C1           	POP BC ; count
 124+ 58D9 E1           	POP HL ; start address
 125+ 58DA 78           	LD A, B
 126+ 58DB B7           	OR A
 127+ 58DC 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 128+ 58DE B1           	OR C
 129+ 58DF 28 1A        	JR Z, .EXIT ; 0 bytes to fill, skip
 130+ 58E1 79           	LD A, C
 131+ 58E2 3D           	DEC A
 132+ 58E3 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 133+ 58E5              	; one byte to fill
 134+ 58E5 72           	LD (HL), D
 135+ 58E6 18 13        	JR .EXIT
 136+ 58E8              .L1:
 137+ 58E8 D9           	EXX
 138+ 58E9              	; enable page 0
 139+ 58E9 F3           	DI
 140+ 58EA FD 21 F1 58  	LD IY, .RET
 141+ 58EE C3 7C 65     	JP ENABLE_PAGE0
 142+ 58F1              .RET:
 143+ 58F1 FB           	EI
 144+ 58F2 D9           	EXX
 145+ 58F3 CD FF 58     	CALL .FILLVALUE
 146+ 58F6 D1               POP DE
 147+ 58F7 C1               POP BC
 148+ 58F8 CD F3 64         CALL RESTORE_PAGE_INFO
 149+ 58FB              .EXIT:
 150+ 58FB DD E5        	PUSH IX
 151+ 58FD E1           	POP HL
 152+ 58FE C9           	RET
 153+ 58FF
 154+ 58FF              .FILLVALUE:
 155+ 58FF 72               LD (HL), D
 156+ 5900 54               LD D, H
 157+ 5901 5D               LD E, L
 158+ 5902 13               INC DE
 159+ 5903 0B               DEC BC
 160+ 5904 ED B0            LDIR
 161+ 5906 C9               RET
 162+ 5907              ; *******************************************************************************************************
 163+ 5907
# file closed: asm\MEMORY.asm
 139  5907               ENDIF
 140  5907
 141  5907               IF (SOUND_CMDS == 1)
 142  5907               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
   1+ 5907              MUSIC_INIT_STATUS:
   2+ 5907 00            DB 0
   3+ 5908              SFX_INIT_STATUS:
   4+ 5908 00            DB 0
   5+ 5909              SOUND_ENABLED:
   6+ 5909 00            DB 0
   7+ 590A
   8+ 590A              ; *******************************************************************************************************
   9+ 590A              ; function to handle CALL SNDPLYINIT basic extension
  10+ 590A              ; initializes sound player
  11+ 590A              ; _SNDPLYINIT ( INT music_offset,
  12+ 590A              ;				INT sfx_offset, can be -1 if no SFX
  13+ 590A              ; will put ram in page 0 also, page 1 is already there
  14+ 590A              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
  15+ 590A              SNDPLYINIT:
  16+ 590A              	; opening (
  17+ 590A CD CA 65     	CALL CHKCHAR
  18+ 590D 28           	DB '('
  19+ 590E              	; get music address
  20+ 590E DD 21 2F 54  	LD IX, FRMQNT
  21+ 5912 CD 59 01     	CALL CALBAS
  22+ 5915 D5           	PUSH DE
  23+ 5916              	; comma
  24+ 5916 CD CA 65     	CALL CHKCHAR
  25+ 5919 2C           	DB ','
  26+ 591A              	; get sfx address
  27+ 591A DD 21 2F 54  	LD IX, FRMQNT
  28+ 591E CD 59 01     	CALL CALBAS
  29+ 5921 D5           	PUSH DE
  30+ 5922              	; ending )
  31+ 5922 CD CA 65     	CALL CHKCHAR
  32+ 5925 29           	DB ')'
  33+ 5926
  34+ 5926                  ; save position in BASIC text
  35+ 5926 44           	LD B, H
  36+ 5927 4D           	LD C, L
  37+ 5928
  38+ 5928              	; pop LDIR parameters and store away for later
  39+ 5928 D1           	POP DE ; sfx address
  40+ 5929 E1           	POP HL ; music address
  41+ 592A C5           	PUSH BC ; basic text location
  42+ 592B D9           	EXX
  43+ 592C FD 21 33 59  	LD IY, .RET
  44+ 5930 C3 7C 65     	JP ENABLE_PAGE0
  45+ 5933              .RET:
  46+ 5933 D9           	EXX
  47+ 5934
  48+ 5934 D5           	PUSH DE
  49+ 5935 AF           	XOR A
  50+ 5936              	; HL = music location
  51+ 5936 CD 65 41     	CALL PLY_AKG_INIT
  52+ 5939 3E 01        	LD A, 1
  53+ 593B 32 07 59     	LD (MUSIC_INIT_STATUS), A
  54+ 593E
  55+ 593E E1           	POP HL ; SFX
  56+ 593F              	; check if SFX address -1
  57+ 593F 23           	INC HL
  58+ 5940 7D           	LD A, L
  59+ 5941 B4           	OR H
  60+ 5942 28 09        	JR Z,.L1
  61+ 5944 2B           	DEC HL
  62+ 5945 CD 20 40     	CALL PLY_AKG_INITSOUNDEFFECTS
  63+ 5948 3E 01        	LD A, 1
  64+ 594A 32 08 59     	LD (SFX_INIT_STATUS), A
  65+ 594D              .L1:
  66+ 594D D1               POP DE
  67+ 594E C1               POP BC
  68+ 594F CD F3 64         CALL RESTORE_PAGE_INFO
  69+ 5952
  70+ 5952 E1           	POP HL
  71+ 5953 C9           	RET
  72+ 5954              ; *******************************************************************************************************
  73+ 5954
  74+ 5954              ; *******************************************************************************************************
  75+ 5954              ; function to handle CALL SNDPLYON basic extension
  76+ 5954              ; enables sound player
  77+ 5954              ; _SNDPLYON
  78+ 5954              ; sets SOUND_ENABLED variable to 1 if init call was done
  79+ 5954              ; if not throws out of data error
  80+ 5954              SNDPLYON:
  81+ 5954 3A 07 59     	LD A, (MUSIC_INIT_STATUS)
  82+ 5957 B7           	OR A
  83+ 5958 20 05        	JR NZ, .L1
  84+ 595A              	; player not initialized, throw error
  85+ 595A 1E 04        	LD E, 04 ; Out of DATA
  86+ 595C C3 F0 65     	JP THROW_ERROR
  87+ 595F              .L1:
  88+ 595F 32 09 59     	LD (SOUND_ENABLED), A
  89+ 5962              	; disable key click
  90+ 5962 AF           	XOR A
  91+ 5963 32 DB F3     	LD (CLIKSW), A
  92+ 5966 C9           	RET
  93+ 5967              ; *******************************************************************************************************
  94+ 5967
  95+ 5967              ; *******************************************************************************************************
  96+ 5967              ; function to handle CALL SNDPLYOFF basic extension
  97+ 5967              ; disables sound player
  98+ 5967              ; _SNDPLYOFF
  99+ 5967              ; sets SOUND_ENABLED variable to 0
 100+ 5967              ; calls AKG to stop music and SFX on all channels if initialized
 101+ 5967              SNDPLYOFF:
 102+ 5967 3A 09 59     	LD A, (SOUND_ENABLED)
 103+ 596A B7           	OR A
 104+ 596B C8           	RET Z ; already stopped
 105+ 596C AF           	XOR A
 106+ 596D 32 09 59     	LD (SOUND_ENABLED), A
 107+ 5970 E5           	PUSH HL
 108+ 5971 CD 24 42     	CALL PLY_AKG_STOP
 109+ 5974 3A 08 59     	LD A, (SFX_INIT_STATUS)
 110+ 5977 B7           	OR A
 111+ 5978 28 0E        	JR Z, .EXIT ; SFX not in use
 112+ 597A AF           	XOR A
 113+ 597B CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 114+ 597E 3E 01        	LD A, 1
 115+ 5980 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 116+ 5983 3E 02        	LD A, 2
 117+ 5985 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 118+ 5988              .EXIT:
 119+ 5988 E1           	POP HL
 120+ 5989 C9           	RET
 121+ 598A              ; *******************************************************************************************************
 122+ 598A
 123+ 598A              ; *******************************************************************************************************
 124+ 598A              ; function to handle CALL SNDSFX basic extension
 125+ 598A              ; plays a sound effect
 126+ 598A              ; _SNDSFX ( BYTE sfx_number, >0
 127+ 598A              ;			BYTE channel, = 0,1 or 2
 128+ 598A              ;			BYTE inverted_volume = 0-16, 0 being full volume
 129+ 598A              ; will put ram in page 0 also, page 1 is already there
 130+ 598A              ; if sound off throws illegal function call
 131+ 598A              ; if sfx not initialized, throws out of data
 132+ 598A              SNDSFX:
 133+ 598A              	; opening (
 134+ 598A CD CA 65     	CALL CHKCHAR
 135+ 598D 28           	DB '('
 136+ 598E              	; get sfx_number
 137+ 598E DD 21 1C 52  	LD IX, GETBYT
 138+ 5992 CD 59 01     	CALL CALBAS
 139+ 5995 D5           	PUSH DE
 140+ 5996              	; comma
 141+ 5996 CD CA 65     	CALL CHKCHAR
 142+ 5999 2C           	DB ','
 143+ 599A              	; get sfx address
 144+ 599A DD 21 1C 52  	LD IX, GETBYT
 145+ 599E CD 59 01     	CALL CALBAS
 146+ 59A1 D5           	PUSH DE
 147+ 59A2              	; comma
 148+ 59A2 CD CA 65     	CALL CHKCHAR
 149+ 59A5 2C           	DB ','
 150+ 59A6              	; get inverted volume
 151+ 59A6 DD 21 1C 52  	LD IX, GETBYT
 152+ 59AA CD 59 01     	CALL CALBAS
 153+ 59AD D5           	PUSH DE
 154+ 59AE              	; ending )
 155+ 59AE CD CA 65     	CALL CHKCHAR
 156+ 59B1 29           	DB ')'
 157+ 59B2
 158+ 59B2 3A 09 59     	LD A, (SOUND_ENABLED)
 159+ 59B5 B7           	OR A
 160+ 59B6 20 05        	JR NZ, .L1
 161+ 59B8              	; sound disabled, throw illegal function call
 162+ 59B8 1E 05        	LD E, 5
 163+ 59BA C3 F0 65     	JP THROW_ERROR
 164+ 59BD              .L1:
 165+ 59BD 3A 08 59     	LD A, (SFX_INIT_STATUS)
 166+ 59C0 B7           	OR A
 167+ 59C1 20 05        	JR NZ, .L2
 168+ 59C3              	; sfx data not initialized, throw out of data
 169+ 59C3 1E 04        	LD E, 4
 170+ 59C5 C3 F0 65     	JP THROW_ERROR
 171+ 59C8              .L2:
 172+ 59C8              	; pop  parameters and store away for later
 173+ 59C8 D1           	POP DE ; inverted volume
 174+ 59C9 43           	LD B, E
 175+ 59CA D1           	POP DE ; channel
 176+ 59CB 4B           	LD C, E
 177+ 59CC D1           	POP DE
 178+ 59CD 7B           	LD A, E
 179+ 59CE 08           	EX AF, AF'
 180+ 59CF E5           	PUSH HL ; basic text location
 181+ 59D0 D9           	EXX
 182+ 59D1 FD 21 D8 59  	LD IY, .RET
 183+ 59D5 C3 7C 65     	JP ENABLE_PAGE0
 184+ 59D8              .RET:
 185+ 59D8 D9           	EXX
 186+ 59D9 08           	EX AF, AF'
 187+ 59DA CD 24 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
 188+ 59DD
 189+ 59DD D1               POP DE
 190+ 59DE C1               POP BC
 191+ 59DF CD F3 64         CALL RESTORE_PAGE_INFO
 192+ 59E2
 193+ 59E2 E1           	POP HL
 194+ 59E3 C9           	RET
 195+ 59E4              ; *******************************************************************************************************
# file closed: asm\SOUND.asm
 143  59E4               ENDIF
 144  59E4
 145  59E4               IF (VRAM_CMDS == 1)
 146  59E4               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
   1+ 59E4              ; *******************************************************************************************************
   2+ 59E4              ; function to handle CALL FILVRM basic extension
   3+ 59E4              ; FILVRM ( INT offset,
   4+ 59E4              ;		   INT count,
   5+ 59E4              ;		   BYTE value,
   6+ 59E4              ;		   BYTE wait_vsync) >0 = true
   7+ 59E4              ; wait_vsync will issue HALT before copying
   8+ 59E4              FILVRM:
   9+ 59E4              	; opening (
  10+ 59E4 CD CA 65     	CALL CHKCHAR
  11+ 59E7 28           	DB '('
  12+ 59E8              	; get offset address
  13+ 59E8 DD 21 2F 54  	LD IX, FRMQNT
  14+ 59EC CD 59 01     	CALL CALBAS
  15+ 59EF D5           	PUSH DE
  16+ 59F0              	; comma
  17+ 59F0 CD CA 65     	CALL CHKCHAR
  18+ 59F3 2C           	DB ','
  19+ 59F4              	; get count
  20+ 59F4 DD 21 2F 54  	LD IX, FRMQNT
  21+ 59F8 CD 59 01     	CALL CALBAS
  22+ 59FB D5           	PUSH DE
  23+ 59FC              	; comma
  24+ 59FC CD CA 65     	CALL CHKCHAR
  25+ 59FF 2C           	DB ','
  26+ 5A00              	; get value
  27+ 5A00 DD 21 1C 52  	LD IX, GETBYT
  28+ 5A04 CD 59 01     	CALL CALBAS
  29+ 5A07 F5           	PUSH AF
  30+ 5A08              	; comma
  31+ 5A08 CD CA 65     	CALL CHKCHAR
  32+ 5A0B 2C           	DB ','
  33+ 5A0C              	; get vsync wait
  34+ 5A0C DD 21 1C 52  	LD IX, GETBYT
  35+ 5A10 CD 59 01     	CALL CALBAS
  36+ 5A13 F5           	PUSH AF
  37+ 5A14              	; ending )
  38+ 5A14 CD CA 65     	CALL CHKCHAR
  39+ 5A17 29           	DB ')'
  40+ 5A18
  41+ 5A18              	; save position
  42+ 5A18 E5           	PUSH HL
  43+ 5A19 DD E1        	POP IX
  44+ 5A1B
  45+ 5A1B              	; syntax ok
  46+ 5A1B              	; wait for vsync if needed
  47+ 5A1B F1           	POP AF
  48+ 5A1C B7           	OR A
  49+ 5A1D 28 01        	JR Z, .L1
  50+ 5A1F 76           	HALT
  51+ 5A20
  52+ 5A20              .L1:
  53+ 5A20 3E 01        	LD A,1
  54+ 5A22 32 D6 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
  55+ 5A25 F1               POP AF ; value
  56+ 5A26 C1               POP BC ; count
  57+ 5A27 E1               POP HL ; offset
  58+ 5A28 CD 56 00         CALL BIOS_FILVRM
  59+ 5A2B AF           	XOR A
  60+ 5A2C 32 D6 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
  61+ 5A2F
  62+ 5A2F              .L3:
  63+ 5A2F DD E5        	PUSH IX
  64+ 5A31 E1           	POP HL
  65+ 5A32 C9           	RET
  66+ 5A33              ; *******************************************************************************************************
  67+ 5A33
  68+ 5A33               IF (BASIC_EXTENSION == 1)
  69+ 5A33              ; *******************************************************************************************************
  70+ 5A33              ; function to handle CALL MEMVRM basic extension
  71+ 5A33              ; copies from RAM to VRAM
  72+ 5A33              ; _MEMVRM ( INT source,
  73+ 5A33              ;			INT destination,
  74+ 5A33              ;			INT count,
  75+ 5A33              ;			BYTE wait_vsync) >0 = true
  76+ 5A33              ; will put ram in page 0 also, page 1 is already there
  77+ 5A33              ; wait_vsync will issue HALT before copying
  78+ 5A33              MEMVRM:
  79+ 5A33              	; opening (
  80+ 5A33 CD CA 65     	CALL CHKCHAR
  81+ 5A36 28           	DB '('
  82+ 5A37              	; get source address
  83+ 5A37 DD 21 2F 54  	LD IX, FRMQNT
  84+ 5A3B CD 59 01     	CALL CALBAS
  85+ 5A3E D5           	PUSH DE
  86+ 5A3F              	; comma
  87+ 5A3F CD CA 65     	CALL CHKCHAR
  88+ 5A42 2C           	DB ','
  89+ 5A43              	; get destination address
  90+ 5A43 DD 21 2F 54  	LD IX, FRMQNT
  91+ 5A47 CD 59 01     	CALL CALBAS
  92+ 5A4A D5           	PUSH DE
  93+ 5A4B              	; comma
  94+ 5A4B CD CA 65     	CALL CHKCHAR
  95+ 5A4E 2C           	DB ','
  96+ 5A4F              	; get length
  97+ 5A4F DD 21 2F 54  	LD IX, FRMQNT
  98+ 5A53 CD 59 01     	CALL CALBAS
  99+ 5A56 D5           	PUSH DE
 100+ 5A57              	; comma
 101+ 5A57 CD CA 65     	CALL CHKCHAR
 102+ 5A5A 2C           	DB ','
 103+ 5A5B              	; get vsync wait
 104+ 5A5B DD 21 1C 52  	LD IX, GETBYT
 105+ 5A5F CD 59 01     	CALL CALBAS
 106+ 5A62 F5           	PUSH AF
 107+ 5A63              	; ending )
 108+ 5A63 CD CA 65     	CALL CHKCHAR
 109+ 5A66 29           	DB ')'
 110+ 5A67
 111+ 5A67                  ; save position in BASIC text
 112+ 5A67 E5           	PUSH HL
 113+ 5A68 DD E1        	POP IX
 114+ 5A6A
 115+ 5A6A F1           	POP AF ; wait vsync
 116+ 5A6B B7           	OR A
 117+ 5A6C 28 01        	JR Z, .L1
 118+ 5A6E 76           	HALT
 119+ 5A6F              .L1:
 120+ 5A6F F3           	DI
 121+ 5A70              	; pop LDIR parameters and store away for later
 122+ 5A70 C1           	POP BC ; count
 123+ 5A71 D1           	POP DE ; vram destination
 124+ 5A72 E1           	POP HL ; ram source
 125+ 5A73 D9           	EXX
 126+ 5A74 FD 21 7B 5A   	LD IY, .RET
 127+ 5A78 C3 7C 65     	JP ENABLE_PAGE0
 128+ 5A7B              .RET:
 129+ 5A7B FB           	EI
 130+ 5A7C D9           	EXX
 131+ 5A7D CD B3 5A     	CALL VRAM_LDIRVM
 132+ 5A80 D1               POP DE
 133+ 5A81 C1               POP BC
 134+ 5A82 CD F3 64         CALL RESTORE_PAGE_INFO
 135+ 5A85 DD E5        	PUSH IX
 136+ 5A87 E1           	POP HL
 137+ 5A88 C9           	RET
 138+ 5A89              ; *******************************************************************************************************
 139+ 5A89               ENDIF
 140+ 5A89
 141+ 5A89               IF (DEFUSR_EXTENSION == 1)
 142+ 5A89              ; *******************************************************************************************************
 143+ 5A89              ; same as MEMVRM but for DEFUSR approach
 144+ 5A89              ; input IX=pointer to input array, real data from +2
 145+ 5A89              ; +2 = source address
 146+ 5A89              ; +4 = destination address
 147+ 5A89              ; +6 = lenght
 148+ 5A89              ; +8 = vsync wait flag
 149+ 5A89              MEMVRM_DEFUSR:
 150+ 5A89 DD 7E 08     	LD A,(IX+8)
 151+ 5A8C B7           	OR A
 152+ 5A8D 28 01        	JR Z,.L0
 153+ 5A8F 76           	HALT
 154+ 5A90              .L0:
 155+ 5A90              	; enable page 0
 156+ 5A90 F3           	DI
 157+ 5A91 FD 21 98 5A  	LD IY, .RET
 158+ 5A95 C3 7C 65     	JP ENABLE_PAGE0
 159+ 5A98              .RET:
 160+ 5A98 FB           	EI
 161+ 5A99 DD 6E 02     	LD L,(IX+2)
 162+ 5A9C DD 66 03     	LD H,(IX+3)
 163+ 5A9F DD 5E 04     	LD E,(IX+4)
 164+ 5AA2 DD 56 05     	LD D,(IX+5)
 165+ 5AA5 DD 4E 06     	LD C,(IX+6)
 166+ 5AA8 DD 46 07     	LD B,(IX+7)
 167+ 5AAB CD B3 5A     	CALL VRAM_LDIRVM
 168+ 5AAE D1               POP DE
 169+ 5AAF C1               POP BC
 170+ 5AB0 C3 F3 64         JP RESTORE_PAGE_INFO
 171+ 5AB3              ; *******************************************************************************************************
 172+ 5AB3               ENDIF
 173+ 5AB3
 174+ 5AB3               IF (BASIC_EXTENSION + DEFUSR_EXTENSION > 0)
 175+ 5AB3              ; *******************************************************************************************************
 176+ 5AB3              ; common code to copy from memory to VRAM
 177+ 5AB3              ; input HL=RAM source
 178+ 5AB3              ; input DE=VRAM destination
 179+ 5AB3              ; BC=count
 180+ 5AB3              VRAM_LDIRVM:
 181+ 5AB3 3E 01        	LD A,1
 182+ 5AB5 32 D6 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 183+ 5AB8 EB           	EX DE, HL
 184+ 5AB9 F3           	DI
 185+ 5ABA CD A3 64     	CALL SETWRT_LOCAL
 186+ 5ABD FB           	EI
 187+ 5ABE EB           	EX DE, HL
 188+ 5ABF 78           	LD A, B
 189+ 5AC0 B7           	OR A
 190+ 5AC1 28 0D        	JR Z, .L3
 191+ 5AC3 C5           	PUSH BC
 192+ 5AC4 0E 98        	LD C, #98
 193+ 5AC6              .L2:
 194+ 5AC6 50           	LD D, B
 195+ 5AC7 06 00        	LD B, 0
 196+ 5AC9 CD B0 64     	CALL BBYTECOPY_NO_C
 197+ 5ACC 42           	LD B, D
 198+ 5ACD 10 F7        	DJNZ .L2
 199+ 5ACF C1           	POP BC
 200+ 5AD0              .L3:
 201+ 5AD0 79           	LD A, C
 202+ 5AD1 B7           	OR A
 203+ 5AD2 C8           	RET Z
 204+ 5AD3 41           	LD B, C
 205+ 5AD4 CD AE 64     	CALL BBYTECOPY
 206+ 5AD7 AF           	XOR A
 207+ 5AD8 32 D6 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 208+ 5ADB C9           	RET
 209+ 5ADC              ; *******************************************************************************************************
 210+ 5ADC               ENDIF
 211+ 5ADC
 212+ 5ADC              ; *******************************************************************************************************
 213+ 5ADC              ; function to handle CALL VRMMEM basic extension
 214+ 5ADC              ; copies from RAM to VRAM
 215+ 5ADC              ; _VRMMEM ( INT source,
 216+ 5ADC              ;			INT destination,
 217+ 5ADC              ;			INT count
 218+ 5ADC              ; will put ram in page 0 also, page 1 is already there
 219+ 5ADC              VRMMEM:
 220+ 5ADC              	; opening (
 221+ 5ADC CD CA 65     	CALL CHKCHAR
 222+ 5ADF 28           	DB '('
 223+ 5AE0              	; get source address
 224+ 5AE0 DD 21 2F 54  	LD IX, FRMQNT
 225+ 5AE4 CD 59 01     	CALL CALBAS
 226+ 5AE7 D5           	PUSH DE
 227+ 5AE8              	; comma
 228+ 5AE8 CD CA 65     	CALL CHKCHAR
 229+ 5AEB 2C           	DB ','
 230+ 5AEC              	; get destination address
 231+ 5AEC DD 21 2F 54  	LD IX, FRMQNT
 232+ 5AF0 CD 59 01     	CALL CALBAS
 233+ 5AF3 D5           	PUSH DE
 234+ 5AF4              	; comma
 235+ 5AF4 CD CA 65     	CALL CHKCHAR
 236+ 5AF7 2C           	DB ','
 237+ 5AF8              	; get length
 238+ 5AF8 DD 21 2F 54  	LD IX, FRMQNT
 239+ 5AFC CD 59 01     	CALL CALBAS
 240+ 5AFF D5           	PUSH DE
 241+ 5B00              	; ending )
 242+ 5B00 CD CA 65     	CALL CHKCHAR
 243+ 5B03 29           	DB ')'
 244+ 5B04
 245+ 5B04                  ; save position in BASIC text
 246+ 5B04 E5           	PUSH HL
 247+ 5B05 DD E1        	POP IX
 248+ 5B07
 249+ 5B07 C1           	POP BC ; count
 250+ 5B08 D1           	POP DE ; destination
 251+ 5B09 E1           	POP HL ; source
 252+ 5B0A D9           	EXX
 253+ 5B0B FD 21 13 5B  	LD IY, .RET
 254+ 5B0F F3           	DI
 255+ 5B10 C3 7C 65     	JP ENABLE_PAGE0
 256+ 5B13              .RET:
 257+ 5B13 FB           	EI
 258+ 5B14 D9           	EXX
 259+ 5B15 3E 01        	LD A,1
 260+ 5B17 32 D6 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 261+ 5B1A CD 2A 5B     	CALL .LDIRMV
 262+ 5B1D AF           	XOR A
 263+ 5B1E 32 D6 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 264+ 5B21 D1               POP DE
 265+ 5B22 C1               POP BC
 266+ 5B23 CD F3 64         CALL RESTORE_PAGE_INFO
 267+ 5B26 DD E5        	PUSH IX
 268+ 5B28 E1           	POP HL
 269+ 5B29 C9           	RET
 270+ 5B2A
 271+ 5B2A              .LDIRMV:
 272+ 5B2A              	; set VRAM address *exactly* as in ROM, otherwise corruption
 273+ 5B2A 7D           	LD	A, L
 274+ 5B2B F3           	DI
 275+ 5B2C D3 99        	OUT	(099H), A
 276+ 5B2E 7C           	LD	A, H
 277+ 5B2F E6 3F        	AND	03FH
 278+ 5B31 D3 99        	OUT	(099H), A
 279+ 5B33 FB           	EI
 280+ 5B34              	;EX (SP), HL
 281+ 5B34              	;EX (SP), HL
 282+ 5B34              	;NOP
 283+ 5B34              	;NOP
 284+ 5B34              .L4:
 285+ 5B34 DB 98            IN A, (#98)
 286+ 5B36 12           	LD (DE), A
 287+ 5B37 13               INC DE
 288+ 5B38 0B               DEC BC
 289+ 5B39 79               LD A, C
 290+ 5B3A B0               OR B
 291+ 5B3B 20 F7            JR NZ, .L4
 292+ 5B3D C9               RET
 293+ 5B3E              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
 147  5B3E               ENDIF
 148  5B3E
 149  5B3E               IF (GENCAL_CMD == 1)
 150  5B3E               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
   1+ 5B3E              ; *******************************************************************************************************
   2+ 5B3E              ; function to handle CALL GENCAL basic extension
   3+ 5B3E              ; GENCAL ( INT fn_addr, = address of the function to call
   4+ 5B3E              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
   5+ 5B3E              ; output values of registers will also be stored at reg_list_ptr
   6+ 5B3E              GENCAL:
   7+ 5B3E              	; opening (
   8+ 5B3E CD CA 65     	CALL CHKCHAR
   9+ 5B41 28           	DB '('
  10+ 5B42              	; get function address
  11+ 5B42 DD 21 2F 54  	LD IX, FRMQNT
  12+ 5B46 CD 59 01     	CALL CALBAS
  13+ 5B49 D5           	PUSH DE
  14+ 5B4A              	; comma
  15+ 5B4A CD CA 65     	CALL CHKCHAR
  16+ 5B4D 2C           	DB ','
  17+ 5B4E              	; get pointer to register list
  18+ 5B4E 3E 02            LD A,2
  19+ 5B50 06 01            LD B,1
  20+ 5B52 11 00 05         LD DE,#0500
  21+ 5B55 CD F7 65         CALL GET_BASIC_ARRAY_DATA_POINTER
  22+ 5B58 C5           	PUSH BC
  23+ 5B59              	; ending )
  24+ 5B59 CD CA 65     	CALL CHKCHAR
  25+ 5B5C 29           	DB ')'
  26+ 5B5D
  27+ 5B5D              	; save BASIC token position
  28+ 5B5D E5           	PUSH HL
  29+ 5B5E D9               EXX
  30+ 5B5F E1           	POP HL ; HL'=next basic token
  31+ 5B60 D9               EXX
  32+ 5B61
  33+ 5B61 E1               POP HL ; get pointer to register values
  34+ 5B62 F3           	DI
  35+ 5B63 ED 73 C5 62      LD (BLIT_STRUCT), SP
  36+ 5B67 F9               LD SP, HL
  37+ 5B68 F1               POP AF
  38+ 5B69 C1               POP BC
  39+ 5B6A D1               POP DE
  40+ 5B6B E1               POP HL
  41+ 5B6C DD E1            POP IX
  42+ 5B6E FD E1            POP IY
  43+ 5B70 D9               EXX
  44+ 5B71 ED 73 C7 62      LD (BLIT_STRUCT+2), SP
  45+ 5B75 ED 7B C5 62      LD SP, (BLIT_STRUCT)
  46+ 5B79 FB               EI
  47+ 5B7A D1               POP DE ; get function to call
  48+ 5B7B E5               PUSH HL
  49+ 5B7C CD 97 5B         CALL .EXXDECALL
  50+ 5B7F F3               DI
  51+ 5B80 ED 73 C5 62      LD (BLIT_STRUCT), SP
  52+ 5B84 ED 7B C7 62      LD SP, (BLIT_STRUCT+2)
  53+ 5B88 FD E5            PUSH IY
  54+ 5B8A DD E5            PUSH IX
  55+ 5B8C E5               PUSH HL
  56+ 5B8D D5               PUSH DE
  57+ 5B8E C5               PUSH BC
  58+ 5B8F F5               PUSH AF
  59+ 5B90 ED 7B C5 62      LD SP, (BLIT_STRUCT)
  60+ 5B94 FB               EI
  61+ 5B95 E1               POP HL
  62+ 5B96 C9           	RET
  63+ 5B97
  64+ 5B97              .EXXDECALL:
  65+ 5B97 D5               PUSH DE
  66+ 5B98 D9               EXX
  67+ 5B99 C9               RET
  68+ 5B9A              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
 151  5B9A               ENDIF
 152  5B9A
 153  5B9A               IF (BOX_CMDS == 1)
 154  5B9A               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
   1+ 5B9A              ; *******************************************************************************************************
   2+ 5B9A              ; generic function to implement rectangle data copy
   3+ 5B9A              ; should be modified to call appropriate function for memory or vram
   4+ 5B9A              ; input IX=pointer to following structure
   5+ 5B9A              ; +00 source data pointer
   6+ 5B9A              ; +02 num bytes in a row
   7+ 5B9A              ; +04 number of rows
   8+ 5B9A              ; +06 source add-to value till next row
   9+ 5B9A              ; +08 destination address
  10+ 5B9A              ; +10 destination add-to value till next row
  11+ 5B9A              ; modifies AF, BC, DE, HL
  12+ 5B9A              RECTANGLE_COPY:
  13+ 5B9A DD 6E 00     	LD L, (IX+0)
  14+ 5B9D DD 66 01     	LD H, (IX+1) ; source address
  15+ 5BA0 DD 5E 08     	LD E, (IX+8)
  16+ 5BA3 DD 56 09     	LD D, (IX+9) ; destination
  17+ 5BA6 DD 46 04     	LD B, (IX+4) ; row number
  18+ 5BA9              .L1:
  19+ 5BA9 C5           	PUSH BC
  20+ 5BAA E5           		PUSH HL
  21+ 5BAB D5           			PUSH DE
  22+ 5BAC DD 4E 02     				LD C, (IX+2)
  23+ 5BAF DD 46 03     				LD B, (IX+3) ; num bytes in a row
  24+ 5BB2              .CALL1:
  25+ 5BB2 CD 00 00     				CALL 0 ; set destination address from DE
  26+ 5BB5              .CALL2:
  27+ 5BB5 CD 00 00     				CALL 0 ; copy data fn
  28+ 5BB8 E1           			POP HL
  29+ 5BB9 DD 4E 0A     			LD C, (IX+10)
  30+ 5BBC DD 46 0B     			LD B, (IX+11) ; destination add-to
  31+ 5BBF 09           			ADD HL, BC
  32+ 5BC0 EB           			EX DE, HL
  33+ 5BC1 E1           		POP HL
  34+ 5BC2 DD 4E 06     		LD C, (IX+6)
  35+ 5BC5 DD 46 07     		LD B, (IX+7) ; src add-to
  36+ 5BC8 09           		ADD HL, BC
  37+ 5BC9 C1           	POP BC
  38+ 5BCA 10 DD        	DJNZ .L1
  39+ 5BCC C9           	RET
  40+ 5BCD              ; *******************************************************************************************************
  41+ 5BCD
  42+ 5BCD              ; *******************************************************************************************************
  43+ 5BCD              ; function to handle CALL BOXMEMCPY basic extension
  44+ 5BCD              ; copies data with window like boundaries within ram
  45+ 5BCD              ; BOXMEMCPY ( INT source data pointer,
  46+ 5BCD              ;			  INT source number of bytes in a row,
  47+ 5BCD              ;			  INT number of rows,
  48+ 5BCD              ;			  INT source add-to value till next row,
  49+ 5BCD              ; 			  INT destination pointer,
  50+ 5BCD              ;			  INT destination add-to value till next row )
  51+ 5BCD              ; request_data_ptr described in RECTANGLE_COPY
  52+ 5BCD              ; will put ram in page 0 also, page 1 is already there
  53+ 5BCD              BOXMEMCPY:
  54+ 5BCD 11 D7 5B     	LD DE,BOXMEMCPY.RET
  55+ 5BD0 ED 53 4C 5C  	LD (BOXCOMMON.ADDR+2), DE
  56+ 5BD4 C3 EA 5B     	JP BOXCOMMON
  57+ 5BD7              .RET:
  58+ 5BD7 FB           	EI
  59+ 5BD8              	; set RAM functions to call
  60+ 5BD8 21 00 00     	LD HL, 0
  61+ 5BDB 22 B2 5B     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
  62+ 5BDE 22 B4 5B     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
  63+ 5BE1 21 ED B0     	LD HL, #B0ED ; LDIR
  64+ 5BE4 22 B6 5B     	LD (RECTANGLE_COPY.CALL1+4), HL
  65+ 5BE7 C3 51 5C     	JP BOXCOMMON.CALL
  66+ 5BEA              ; *******************************************************************************************************
  67+ 5BEA
  68+ 5BEA              ; *******************************************************************************************************
  69+ 5BEA              ; common parts of BOX commands
  70+ 5BEA              BOXCOMMON:
  71+ 5BEA              	; opening (
  72+ 5BEA CD CA 65     	CALL CHKCHAR
  73+ 5BED 28           	DB '('
  74+ 5BEE              	; get source data pointer
  75+ 5BEE DD 21 2F 54  	LD IX, FRMQNT
  76+ 5BF2 CD 59 01     	CALL CALBAS
  77+ 5BF5 ED 53 C5 62  	LD (BLIT_STRUCT+0), DE
  78+ 5BF9              	; comma
  79+ 5BF9 CD CA 65     	CALL CHKCHAR
  80+ 5BFC 2C           	DB ','
  81+ 5BFD              	; source number of bytes in a row
  82+ 5BFD DD 21 2F 54  	LD IX, FRMQNT
  83+ 5C01 CD 59 01     	CALL CALBAS
  84+ 5C04 ED 53 C7 62  	LD (BLIT_STRUCT+2), DE
  85+ 5C08              	; comma
  86+ 5C08 CD CA 65     	CALL CHKCHAR
  87+ 5C0B 2C           	DB ','
  88+ 5C0C              	; number of rows
  89+ 5C0C DD 21 2F 54  	LD IX, FRMQNT
  90+ 5C10 CD 59 01     	CALL CALBAS
  91+ 5C13 ED 53 C9 62  	LD (BLIT_STRUCT+4), DE
  92+ 5C17              	; comma
  93+ 5C17 CD CA 65     	CALL CHKCHAR
  94+ 5C1A 2C           	DB ','
  95+ 5C1B              	; source add-to value till next row
  96+ 5C1B DD 21 2F 54  	LD IX, FRMQNT
  97+ 5C1F CD 59 01     	CALL CALBAS
  98+ 5C22 ED 53 CB 62  	LD (BLIT_STRUCT+6), DE
  99+ 5C26              	; comma
 100+ 5C26 CD CA 65     	CALL CHKCHAR
 101+ 5C29 2C           	DB ','
 102+ 5C2A              	; destination pointer
 103+ 5C2A DD 21 2F 54  	LD IX, FRMQNT
 104+ 5C2E CD 59 01     	CALL CALBAS
 105+ 5C31 ED 53 CD 62  	LD (BLIT_STRUCT+8), DE
 106+ 5C35              	; comma
 107+ 5C35 CD CA 65     	CALL CHKCHAR
 108+ 5C38 2C           	DB ','
 109+ 5C39              	; destination add-to value till next row
 110+ 5C39 DD 21 2F 54  	LD IX, FRMQNT
 111+ 5C3D CD 59 01     	CALL CALBAS
 112+ 5C40 ED 53 CF 62  	LD (BLIT_STRUCT+10), DE
 113+ 5C44              	; ending )
 114+ 5C44 CD CA 65     	CALL CHKCHAR
 115+ 5C47 29           	DB ')'
 116+ 5C48
 117+ 5C48 E5           	PUSH HL ; save position in BASIC buffer
 118+ 5C49 F3           	DI
 119+ 5C4A              .ADDR:
 120+ 5C4A FD 21 00 00  	LD IY, 0
 121+ 5C4E C3 7C 65     	JP ENABLE_PAGE0
 122+ 5C51              .CALL:
 123+ 5C51 DD 21 C5 62  	LD IX,BLIT_STRUCT
 124+ 5C55 CD 9A 5B     	CALL RECTANGLE_COPY
 125+ 5C58 AF           	XOR A
 126+ 5C59 32 D6 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 127+ 5C5C
 128+ 5C5C D1               POP DE
 129+ 5C5D C1               POP BC
 130+ 5C5E CD F3 64         CALL RESTORE_PAGE_INFO
 131+ 5C61
 132+ 5C61 E1           	POP HL
 133+ 5C62 C9           	RET
 134+ 5C63              ; *******************************************************************************************************
 135+ 5C63
 136+ 5C63              ; *******************************************************************************************************
 137+ 5C63              ; function to handle CALL BOXMEMVRM basic extension
 138+ 5C63              ; copies data with window like boundaries from ram to Vram
 139+ 5C63              ; BOXMEMVRM ( INT source data pointer,
 140+ 5C63              ;			  INT source number of bytes in a row,
 141+ 5C63              ;			  INT number of rows,
 142+ 5C63              ;			  INT source add-to value till next row,
 143+ 5C63              ; 			  INT destination pointer,
 144+ 5C63              ;			  INT destination add-to value till next row )
 145+ 5C63              ; request_data_ptr described in RECTANGLE_COPY
 146+ 5C63              ; will put ram in page 0 also, page 1 is already there
 147+ 5C63              BOXMEMVRM:
 148+ 5C63 11 6D 5C     	LD DE,BOXMEMVRM.RET
 149+ 5C66 ED 53 4C 5C  	LD (BOXCOMMON.ADDR+2), DE
 150+ 5C6A C3 EA 5B     	JP BOXCOMMON
 151+ 5C6D              .RET:
 152+ 5C6D FB           	EI
 153+ 5C6E              	; set RAM functions to call
 154+ 5C6E 21 88 5C     	LD HL, .SETDEST
 155+ 5C71 22 B3 5B     	LD (RECTANGLE_COPY.CALL1+1), HL
 156+ 5C74 21 90 5C     	LD HL, .COPYDATA
 157+ 5C77 22 B6 5B     	LD (RECTANGLE_COPY.CALL2+1), HL
 158+ 5C7A 3E CD        	LD A, #CD ; CALL
 159+ 5C7C 32 B2 5B     	LD (RECTANGLE_COPY.CALL1), A
 160+ 5C7F 32 B5 5B     	LD (RECTANGLE_COPY.CALL2), A
 161+ 5C82              	;LD A,1
 162+ 5C82 32 D6 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 163+ 5C85 C3 51 5C     	JP BOXCOMMON.CALL
 164+ 5C88              .SETDEST:
 165+ 5C88 EB           	EX DE, HL
 166+ 5C89 F3           	DI
 167+ 5C8A CD A3 64     	CALL SETWRT_LOCAL
 168+ 5C8D FB           	EI
 169+ 5C8E EB           	EX DE, HL
 170+ 5C8F C9           	RET
 171+ 5C90              .COPYDATA:
 172+ 5C90 41           	LD B, C
 173+ 5C91 C3 AE 64     	JP BBYTECOPY
 174+ 5C94              ; *******************************************************************************************************
# file closed: asm\BOX.asm
 155  5C94               ENDIF
 156  5C94
 157  5C94               IF (BLIT_CMDS == 1)
 158  5C94               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
   1+ 5C94              ; *******************************************************************************************************
   2+ 5C94              ; function rotates mask and data of several characters and applies to background data
   3+ 5C94              ; this handles x-shift from 0 to 4
   4+ 5C94              ; contains self-modifying code that is set-up from external function
   5+ 5C94              ; input HL=pointer to mask data
   6+ 5C94              ; input HL'=pointer to character data
   7+ 5C94              ; input DE=output buffer containing background data
   8+ 5C94              ; input BC=DE+8
   9+ 5C94              ; input A=number of characters to process
  10+ 5C94              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  11+ 5C94              SHIFT04:
  12+ 5C94 08           	EX AF, AF'
  13+ 5C95 7E           	LD A, (HL) ; get mask
  14+ 5C96 D9           	EXX
  15+ 5C97 57           	LD D, A
  16+ 5C98 1E FF        	LD E, #FF
  17+ 5C9A 37           	SCF
  18+ 5C9B              .M1:
  19+ 5C9B 18 FE        	JR .M1 ; this is self-modifying part
  20+ 5C9D CB 1A        	RR D
  21+ 5C9F CB 1B        	RR E
  22+ 5CA1 CB 1A        	RR D
  23+ 5CA3 CB 1B        	RR E
  24+ 5CA5 CB 1A        	RR D
  25+ 5CA7 CB 1B        	RR E
  26+ 5CA9 CB 1A        	RR D
  27+ 5CAB CB 1B        	RR E
  28+ 5CAD
  29+ 5CAD 46           	LD B, (HL) ; get data
  30+ 5CAE 0E 00        	LD C, 0
  31+ 5CB0              .M2:
  32+ 5CB0 18 FE        	JR .M2 ; also self-modifying part
  33+ 5CB2 CB 38        	SRL B
  34+ 5CB4 CB 19        	RR C
  35+ 5CB6 CB 38        	SRL B
  36+ 5CB8 CB 19        	RR C
  37+ 5CBA CB 38        	SRL B
  38+ 5CBC CB 19        	RR C
  39+ 5CBE CB 38        	SRL B
  40+ 5CC0 CB 19        	RR C
  41+ 5CC2
  42+ 5CC2 D9           	EXX
  43+ 5CC3 1A           	LD A, (DE) ; background
  44+ 5CC4 D9           	EXX
  45+ 5CC5 A2           	AND D
  46+ 5CC6 B0           	OR B
  47+ 5CC7 D9           	EXX
  48+ 5CC8 12           	LD (DE), A
  49+ 5CC9
  50+ 5CC9 0A           	LD A, (BC)
  51+ 5CCA D9           	EXX
  52+ 5CCB A3           	AND E
  53+ 5CCC B1           	OR C
  54+ 5CCD 23           	INC HL
  55+ 5CCE D9           	EXX
  56+ 5CCF 02           	LD (BC), A
  57+ 5CD0
  58+ 5CD0 23           	INC HL
  59+ 5CD1 13           	INC DE
  60+ 5CD2 03           	INC BC
  61+ 5CD3
  62+ 5CD3 08           	EX AF, AF'
  63+ 5CD4 3D           	DEC A
  64+ 5CD5 C2 94 5C     	JP NZ, SHIFT04
  65+ 5CD8 C9           	RET
  66+ 5CD9              ; *******************************************************************************************************
  67+ 5CD9
  68+ 5CD9              ; *******************************************************************************************************
  69+ 5CD9              ; function rotates mask and data of several characters and applies to background data
  70+ 5CD9              ; this handles x-shift from 5 to 8
  71+ 5CD9              ; contains self-modifying code that is set-up from external function
  72+ 5CD9              ; input HL=pointer to mask data
  73+ 5CD9              ; input HL'=pointer to character data
  74+ 5CD9              ; input DE=output buffer containing background data
  75+ 5CD9              ; input BC=DE+8
  76+ 5CD9              ; input A=number of characters to process
  77+ 5CD9              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  78+ 5CD9              SHIFT58:
  79+ 5CD9 08           	EX AF, AF'
  80+ 5CDA 7E           	LD A, (HL) ; get mask
  81+ 5CDB D9           	EXX
  82+ 5CDC 57           	LD D, A
  83+ 5CDD 1E FF        	LD E, #FF
  84+ 5CDF 37           	SCF
  85+ 5CE0              .M1:
  86+ 5CE0 18 FE        	JR .M1 ; this is self-modifying part
  87+ 5CE2 CB 12        	RL D
  88+ 5CE4 CB 13        	RL E
  89+ 5CE6 CB 12        	RL D
  90+ 5CE8 CB 13        	RL E
  91+ 5CEA CB 12        	RL D
  92+ 5CEC CB 13        	RL E
  93+ 5CEE
  94+ 5CEE 46           	LD B, (HL)
  95+ 5CEF 0E 00        	LD C, 0
  96+ 5CF1              .M2:
  97+ 5CF1 18 FE        	JR .M2 ; also self-modifying part
  98+ 5CF3 CB 20        	SLA B
  99+ 5CF5 CB 11        	RL C
 100+ 5CF7 CB 20        	SLA B
 101+ 5CF9 CB 11        	RL C
 102+ 5CFB CB 20        	SLA B
 103+ 5CFD CB 11        	RL C
 104+ 5CFF
 105+ 5CFF D9           	EXX
 106+ 5D00 1A           	LD A, (DE) ; background
 107+ 5D01 D9           	EXX
 108+ 5D02 A3           	AND E
 109+ 5D03 B1           	OR C
 110+ 5D04 D9           	EXX
 111+ 5D05 12           	LD (DE), A
 112+ 5D06
 113+ 5D06 0A           	LD A, (BC)
 114+ 5D07 D9           	EXX
 115+ 5D08 A2           	AND D
 116+ 5D09 B0           	OR B
 117+ 5D0A 23           	INC HL
 118+ 5D0B D9           	EXX
 119+ 5D0C 02           	LD (BC), A
 120+ 5D0D
 121+ 5D0D 23           	INC HL
 122+ 5D0E 13           	INC DE
 123+ 5D0F 03           	INC BC
 124+ 5D10
 125+ 5D10 08           	EX AF, AF'
 126+ 5D11 3D           	DEC A
 127+ 5D12 C2 D9 5C     	JP NZ, SHIFT58
 128+ 5D15 C9           	RET
 129+ 5D16              ; *******************************************************************************************************
 130+ 5D16
 131+ 5D16              ; *******************************************************************************************************
 132+ 5D16              ; routine that shifts one row of characters
 133+ 5D16              ; contains self-modifying code that is set-up from external function
 134+ 5D16              ; input HL=pointer to mask data
 135+ 5D16              ; input HL'=pointer to character data
 136+ 5D16              ; input DE=output buffer containing background data
 137+ 5D16              ; input A=number of characters to process
 138+ 5D16              ; input IX=pointer to structure describing input data
 139+ 5D16              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 140+ 5D16              SHIFT_ROW:
 141+ 5D16 F5           	PUSH AF
 142+ 5D17 ED 53 C1 62  		LD (BLIT_TMP1), DE
 143+ 5D1B E5           		PUSH HL
 144+ 5D1C CD 5F 5D     			CALL .ADDYSHIFT
 145+ 5D1F E1           		POP HL
 146+ 5D20 ED 53 C3 62  		LD (BLIT_TMP2), DE ; DE+vertical shift
 147+ 5D24              .L1:
 148+ 5D24 3E 08        		LD A, 8
 149+ 5D26 DD 96 02     		SUB (IX+2) ; y shift
 150+ 5D29              .CALL1:
 151+ 5D29 CD 00 00     		CALL 0
 152+ 5D2C DD 7E 02     		LD A, (IX+2); y shift
 153+ 5D2F B7           		OR A
 154+ 5D30 28 26        		JR Z, .DONE
 155+ 5D32 ED 5B C1 62  		LD DE, (BLIT_TMP1)
 156+ 5D36 E5           		PUSH HL
 157+ 5D37 CD 6D 5D     			CALL .DETONEXTROW
 158+ 5D3A E1           		POP HL
 159+ 5D3B              .CALL2:
 160+ 5D3B CD 00 00     		CALL 0
 161+ 5D3E ED 5B C1 62  		LD DE, (BLIT_TMP1)
 162+ 5D42 E5           		PUSH HL
 163+ 5D43 CD 67 5D     			CALL .ADD8
 164+ 5D46 E1           		POP HL
 165+ 5D47 ED 53 C1 62  		LD (BLIT_TMP1), DE
 166+ 5D4B ED 5B C3 62  		LD DE, (BLIT_TMP2)
 167+ 5D4F E5           		PUSH HL
 168+ 5D50 CD 67 5D     			CALL .ADD8
 169+ 5D53 E1           		POP HL
 170+ 5D54 ED 53 C3 62  		LD (BLIT_TMP2), DE ; DE+vertical shift
 171+ 5D58              .DONE:
 172+ 5D58 F1           	POP AF
 173+ 5D59 3D           	DEC A
 174+ 5D5A C8           	RET Z
 175+ 5D5B F5           	PUSH AF
 176+ 5D5C C3 24 5D     	JP .L1
 177+ 5D5F              .ADDYSHIFT:
 178+ 5D5F EB           	EX DE, HL
 179+ 5D60 16 00        	LD D, 0
 180+ 5D62 DD 5E 02     	LD E, (IX+2); y shift
 181+ 5D65 18 0C        	JR .MOVDEBC
 182+ 5D67              .ADD8:
 183+ 5D67 21 08 00     	LD HL, 8
 184+ 5D6A C3 73 5D     	JP .MOVDEBC
 185+ 5D6D              .DETONEXTROW:
 186+ 5D6D DD 6E 06     	LD L, (IX+6)
 187+ 5D70 DD 66 07     	LD H, (IX+7) ; bkg add to value
 188+ 5D73              .MOVDEBC:
 189+ 5D73 19           	ADD HL, DE
 190+ 5D74 54           	LD D, H
 191+ 5D75 5D           	LD E, L
 192+ 5D76 01 08 00     	LD BC, 8
 193+ 5D79 09           	ADD HL, BC
 194+ 5D7A 44           	LD B, H
 195+ 5D7B 4D           	LD C, L
 196+ 5D7C C9           	RET
 197+ 5D7D              ; *******************************************************************************************************
 198+ 5D7D
 199+ 5D7D              ; *******************************************************************************************************
 200+ 5D7D              ; function rotates mask and character data and applies it to background
 201+ 5D7D              ; input IX=pointer to structure describing input data
 202+ 5D7D              ; +0  DW horizontal shift count 0-7 (low byte used)
 203+ 5D7D              ; +2  DW vertical shift count 0-7 (low byte used)
 204+ 5D7D              ; +4  DW background data start;
 205+ 5D7D              ; +6  DW background add to value to next row of background data
 206+ 5D7D              ; +8  DW mask data start;
 207+ 5D7D              ; +10  DW character data start;
 208+ 5D7D              ; +12 DW character&mask add to value to next row of data
 209+ 5D7D              ; +14 DW columns (low byte used)
 210+ 5D7D              ; +16 DW rows (low byte used)
 211+ 5D7D              SHIFT_MERGE_CHARACTER:
 212+ 5D7D DD 7E 00     	LD A, (IX) ; shift
 213+ 5D80 FE 05        	CP 5
 214+ 5D82 38 25        	JR C, .RIGHT
 215+ 5D84              	; shifts 5-7, use rotate towards left 1-3
 216+ 5D84 21 D9 5C     	LD HL, SHIFT58
 217+ 5D87 22 2A 5D     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 218+ 5D8A 22 3C 5D     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 219+ 5D8D D6 05        	SUB 5
 220+ 5D8F 28 0D        	JR Z, .L1
 221+ 5D91 87           	ADD A, A
 222+ 5D92 87           	ADD A, A
 223+ 5D93 67           	LD H, A
 224+ 5D94 2E 18        	LD L, #18 ; JR opcode
 225+ 5D96 22 E0 5C     	LD (SHIFT58.M1), HL
 226+ 5D99 22 F1 5C     	LD (SHIFT58.M2), HL
 227+ 5D9C 18 32        	JR .DO
 228+ 5D9E              .L1:
 229+ 5D9E 21 00 00     	LD HL, 0 ; 2xNOP opcode
 230+ 5DA1 22 E0 5C     	LD (SHIFT58.M1), HL
 231+ 5DA4 22 F1 5C     	LD (SHIFT58.M2), HL
 232+ 5DA7 18 27        	JR .DO
 233+ 5DA9              .RIGHT:
 234+ 5DA9              	; shifts 0-4, rotate towards right
 235+ 5DA9 21 94 5C     	LD HL, SHIFT04
 236+ 5DAC 22 2A 5D     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 237+ 5DAF 22 3C 5D     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 238+ 5DB2 FE 04        	CP 4
 239+ 5DB4 28 11        	JR Z, .R1
 240+ 5DB6 D6 04        	SUB 4
 241+ 5DB8 ED 44        	NEG
 242+ 5DBA 87           	ADD A, A
 243+ 5DBB 87           	ADD A, A
 244+ 5DBC 67           	LD H, A
 245+ 5DBD 2E 18        	LD L, #18 ; JR opcode
 246+ 5DBF 22 9B 5C     	LD (SHIFT04.M1), HL
 247+ 5DC2 22 B0 5C     	LD (SHIFT04.M2), HL
 248+ 5DC5 18 09        	JR .DO
 249+ 5DC7              .R1:
 250+ 5DC7 21 00 00     	LD HL, 0 ; 2xNOP opcode
 251+ 5DCA 22 9B 5C     	LD (SHIFT04.M1), HL
 252+ 5DCD 22 B0 5C     	LD (SHIFT04.M2), HL
 253+ 5DD0              .DO:
 254+ 5DD0 DD 46 10     	LD B, (IX+16) ; rows
 255+ 5DD3 DD 6E 08     	LD L, (IX+8)
 256+ 5DD6 DD 66 09     	LD H, (IX+9) ; mask data
 257+ 5DD9 DD 5E 04     	LD E, (IX+4)
 258+ 5DDC DD 56 05     	LD D, (IX+5) ; background data
 259+ 5DDF D9           	EXX
 260+ 5DE0 DD 6E 0A     	LD L, (IX+10)
 261+ 5DE3 DD 66 0B     	LD H, (IX+11) ; character data
 262+ 5DE6 D9           	EXX
 263+ 5DE7              .LOOP:
 264+ 5DE7 C5           	PUSH BC
 265+ 5DE8 E5           		PUSH HL
 266+ 5DE9 D5           			PUSH DE
 267+ 5DEA D9           				EXX
 268+ 5DEB E5           				PUSH HL
 269+ 5DEC D9           					EXX
 270+ 5DED DD 7E 0E     					LD A, (IX+14) ; columns
 271+ 5DF0              .CALL:
 272+ 5DF0 CD 16 5D     					CALL SHIFT_ROW
 273+ 5DF3 E1           				POP HL
 274+ 5DF4 DD 5E 0C     				LD E, (IX+12)
 275+ 5DF7 DD 56 0D     				LD D, (IX+13) ; char data to next row
 276+ 5DFA 19           				ADD HL, DE
 277+ 5DFB D9           				EXX
 278+ 5DFC E1           			POP HL
 279+ 5DFD DD 5E 06     			LD E, (IX+6)
 280+ 5E00 DD 56 07     			LD D, (IX+7) ; background to next row
 281+ 5E03 19           			ADD HL, DE
 282+ 5E04 EB           			EX DE, HL
 283+ 5E05 E1           		POP HL
 284+ 5E06 DD 4E 0C     		LD C, (IX+12)
 285+ 5E09 DD 46 0D     		LD B, (IX+13) ; char data to next row
 286+ 5E0C 09           		ADD HL, BC
 287+ 5E0D C1           	POP BC
 288+ 5E0E 10 D7        	DJNZ .LOOP
 289+ 5E10 C9           	RET
 290+ 5E11              ; *******************************************************************************************************
 291+ 5E11
 292+ 5E11               IFNDEF CMDS_WITH_PARAMETERS
 293+ 5E11 ~            ; *******************************************************************************************************
 294+ 5E11 ~            ; function to handle CALL BLIT basic extension
 295+ 5E11 ~            ; rotates 1-bit character drawing horizontally with mask and character data and
 296+ 5E11 ~            ; fuses with background data and applies vertical shift too
 297+ 5E11 ~            ; BLIT ( INT request_data_ptr )
 298+ 5E11 ~            ; request_data_ptr described in SHIFT_MERGE_CHARACTER
 299+ 5E11 ~            ; will put ram in page 0 also, page 1 is already there
 300+ 5E11 ~            BLIT:
 301+ 5E11 ~            	; opening (
 302+ 5E11 ~            	CALL CHKCHAR
 303+ 5E11 ~            	DB '('
 304+ 5E11 ~            	; get pointer to request struct
 305+ 5E11 ~            	LD IX, FRMQNT
 306+ 5E11 ~            	CALL CALBAS
 307+ 5E11 ~            	PUSH DE
 308+ 5E11 ~            	; ending )
 309+ 5E11 ~            	CALL CHKCHAR
 310+ 5E11 ~            	DB ')'
 311+ 5E11 ~
 312+ 5E11 ~            	POP IX ; pointer to request struct
 313+ 5E11 ~
 314+ 5E11 ~            	PUSH HL ; save position in BASIC buffer
 315+ 5E11 ~
 316+ 5E11 ~            	LD IY, .RET
 317+ 5E11 ~            	JP ENABLE_PAGE0
 318+ 5E11 ~            .RET:
 319+ 5E11 ~            	EI
 320+ 5E11 ~            	CALL SHIFT_MERGE_CHARACTER
 321+ 5E11 ~
 322+ 5E11 ~                POP DE
 323+ 5E11 ~                POP BC
 324+ 5E11 ~                CALL RESTORE_PAGE_INFO
 325+ 5E11 ~
 326+ 5E11 ~            	POP HL
 327+ 5E11 ~            	RET
 328+ 5E11 ~            ; *******************************************************************************************************
 329+ 5E11               ENDIF
 330+ 5E11
 331+ 5E11               IFDEF CMDS_WITH_PARAMETERS
 332+ 5E11              ; *******************************************************************************************************
 333+ 5E11              ; function to handle CALL BLIT basic extension
 334+ 5E11              ; rotates 1-bit character drawing horizontally with mask and character data and
 335+ 5E11              ; fuses with background data and applies vertical shift too
 336+ 5E11              ; in form without pointers
 337+ 5E11              ; BLIT ( INT x,
 338+ 5E11              ;		 INT y,
 339+ 5E11              ;		 INT char_data_pointer,
 340+ 5E11              ;		 INT mask_data_pointer,
 341+ 5E11              ;		 INT width (in characters),
 342+ 5E11              ;		 INT height (in characters),
 343+ 5E11              ;		 INT background_pointer (top left),
 344+ 5E11              ;		 INT background_width (in characters),
 345+ 5E11              ; will put ram in page 0 also, page 1 is already there
 346+ 5E11              BLIT:
 347+ 5E11              	; opening (
 348+ 5E11 CD CA 65     	CALL CHKCHAR
 349+ 5E14 28           	DB '('
 350+ 5E15              	; get x coordinate
 351+ 5E15 DD 21 2F 54  	LD IX, FRMQNT
 352+ 5E19 CD 59 01     	CALL CALBAS
 353+ 5E1C 7B           	LD A, E
 354+ 5E1D E6 07        	AND 7
 355+ 5E1F 32 C5 62     	LD (BLIT_STRUCT+0), A
 356+ 5E22 CD F1 5E     	CALL .DAdiv8
 357+ 5E25 32 C1 62     	LD (BLIT_TMP+0),A
 358+ 5E28              	; comma
 359+ 5E28 CD CA 65     	CALL CHKCHAR
 360+ 5E2B 2C           	DB ','
 361+ 5E2C              	; get y coordinate
 362+ 5E2C DD 21 2F 54  	LD IX, FRMQNT
 363+ 5E30 CD 59 01     	CALL CALBAS
 364+ 5E33 7B           	LD A, E
 365+ 5E34 E6 07        	AND 7
 366+ 5E36 32 C7 62     	LD (BLIT_STRUCT+2), A
 367+ 5E39 CD F1 5E     	CALL .DAdiv8
 368+ 5E3C 32 C2 62     	LD (BLIT_TMP+1),A
 369+ 5E3F              	; comma
 370+ 5E3F CD CA 65     	CALL CHKCHAR
 371+ 5E42 2C           	DB ','
 372+ 5E43              	; get char data pointer
 373+ 5E43 DD 21 2F 54  	LD IX, FRMQNT
 374+ 5E47 CD 59 01     	CALL CALBAS
 375+ 5E4A ED 53 CF 62  	LD (BLIT_STRUCT+10), DE
 376+ 5E4E              	; comma
 377+ 5E4E CD CA 65     	CALL CHKCHAR
 378+ 5E51 2C           	DB ','
 379+ 5E52              	; get mask data pointer
 380+ 5E52 DD 21 2F 54  	LD IX, FRMQNT
 381+ 5E56 CD 59 01     	CALL CALBAS
 382+ 5E59 ED 53 CD 62  	LD (BLIT_STRUCT+8), DE
 383+ 5E5D              	; comma
 384+ 5E5D CD CA 65     	CALL CHKCHAR
 385+ 5E60 2C           	DB ','
 386+ 5E61              	; get width
 387+ 5E61 DD 21 2F 54  	LD IX, FRMQNT
 388+ 5E65 CD 59 01     	CALL CALBAS
 389+ 5E68 7B           	LD A, E
 390+ 5E69 32 D3 62     	LD (BLIT_STRUCT+14), A
 391+ 5E6C              	; comma
 392+ 5E6C CD CA 65     	CALL CHKCHAR
 393+ 5E6F 2C           	DB ','
 394+ 5E70              	; get height
 395+ 5E70 DD 21 2F 54  	LD IX, FRMQNT
 396+ 5E74 CD 59 01     	CALL CALBAS
 397+ 5E77 7B           	LD A, E
 398+ 5E78 32 D5 62     	LD (BLIT_STRUCT+16), A
 399+ 5E7B              	; comma
 400+ 5E7B CD CA 65     	CALL CHKCHAR
 401+ 5E7E 2C           	DB ','
 402+ 5E7F              	; get background pointer
 403+ 5E7F DD 21 2F 54  	LD IX, FRMQNT
 404+ 5E83 CD 59 01     	CALL CALBAS
 405+ 5E86 ED 53 C9 62  	LD (BLIT_STRUCT+4), DE
 406+ 5E8A              	; comma
 407+ 5E8A CD CA 65     	CALL CHKCHAR
 408+ 5E8D 2C           	DB ','
 409+ 5E8E              	; get background width
 410+ 5E8E DD 21 2F 54  	LD IX, FRMQNT
 411+ 5E92 CD 59 01     	CALL CALBAS
 412+ 5E95 7B           	LD A, E
 413+ 5E96 32 C3 62     	LD (BLIT_TMP+2), A
 414+ 5E99              	; ending )
 415+ 5E99 CD CA 65     	CALL CHKCHAR
 416+ 5E9C 29           	DB ')'
 417+ 5E9D
 418+ 5E9D E5           	PUSH HL ; save position in BASIC buffer
 419+ 5E9E
 420+ 5E9E              	; calculate char&mask add to value
 421+ 5E9E 26 00        	LD H, 0
 422+ 5EA0 3A D3 62     	LD A, (BLIT_STRUCT+14)
 423+ 5EA3 6F           	LD L, A
 424+ 5EA4 CD B8 64     	CALL HLx8
 425+ 5EA7 22 D1 62     	LD (BLIT_STRUCT+12), HL
 426+ 5EAA              	; calculate background add to value
 427+ 5EAA 26 00        	LD H, 0
 428+ 5EAC 3A C3 62     	LD A, (BLIT_TMP+2)
 429+ 5EAF 6F           	LD L, A
 430+ 5EB0 CD B8 64     	CALL HLx8
 431+ 5EB3 22 CB 62     	LD (BLIT_STRUCT+6), HL
 432+ 5EB6              	; calculate pointer to background location
 433+ 5EB6 21 00 00     	LD HL, 0
 434+ 5EB9 3A C2 62     	LD A,(BLIT_TMP+1)
 435+ 5EBC B7           	OR A
 436+ 5EBD 28 08        	JR Z, .L1
 437+ 5EBF 47           	LD B,A
 438+ 5EC0 ED 5B CB 62  	LD DE,(BLIT_STRUCT+6)
 439+ 5EC4              .L0:
 440+ 5EC4 19           	ADD HL, DE
 441+ 5EC5 10 FD        	DJNZ .L0
 442+ 5EC7              .L1:
 443+ 5EC7 EB           	EX DE,HL
 444+ 5EC8 26 00        	LD H,0
 445+ 5ECA 3A C1 62     	LD A,(BLIT_TMP+0)
 446+ 5ECD 6F           	LD L,A
 447+ 5ECE CD B8 64     	CALL HLx8
 448+ 5ED1 19           	ADD HL,DE
 449+ 5ED2 ED 5B C9 62  	LD DE,(BLIT_STRUCT+4)
 450+ 5ED6 19           	ADD HL,DE
 451+ 5ED7 22 C9 62     	LD (BLIT_STRUCT+4),HL
 452+ 5EDA
 453+ 5EDA F3           	DI
 454+ 5EDB FD 21 E2 5E  	LD IY, .RET
 455+ 5EDF C3 7C 65     	JP ENABLE_PAGE0
 456+ 5EE2              .RET:
 457+ 5EE2 FB           	EI
 458+ 5EE3 DD 21 C5 62  	LD IX, BLIT_STRUCT
 459+ 5EE7 CD 7D 5D     	CALL SHIFT_MERGE_CHARACTER
 460+ 5EEA
 461+ 5EEA D1               POP DE
 462+ 5EEB C1               POP BC
 463+ 5EEC CD F3 64         CALL RESTORE_PAGE_INFO
 464+ 5EEF
 465+ 5EEF E1           	POP HL
 466+ 5EF0 C9           	RET
 467+ 5EF1              .DAdiv8:
 468+ 5EF1 7B           	LD A,E
 469+ 5EF2 CB 2A        	SRA D
 470+ 5EF4 CB 1F            RR  A
 471+ 5EF6 CB 2A            SRA D
 472+ 5EF8 CB 1F            RR  A
 473+ 5EFA CB 2A            SRA D
 474+ 5EFC CB 1F            RR  A
 475+ 5EFE C9           	RET
 476+ 5EFF              ; *******************************************************************************************************
 477+ 5EFF               ENDIF
# file closed: asm\BLIT.asm
 159  5EFF               ENDIF
 160  5EFF
 161  5EFF               IF (TILE_CMDS == 1)
 162  5EFF               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
   1+ 5EFF              ; *******************************************************************************************************
   2+ 5EFF              ; generic function to implement tiling
   3+ 5EFF              ; should be modified to call appropriate function for memory or vram
   4+ 5EFF              ; input IX=pointer to following structure
   5+ 5EFF              ; +00 tile_data_ptr
   6+ 5EFF              ; +02 tile_rows
   7+ 5EFF              ; +04 tile_columns
   8+ 5EFF              ; +06 destination_address
   9+ 5EFF              ; +08 dest_to_next_row_add_to_value
  10+ 5EFF              ; +10 num_horizontal_tiles
  11+ 5EFF              ; +12 num_vertical_tiles
  12+ 5EFF              ; modifies AF, BC, DE, HL
  13+ 5EFF              TILE:
  14+ 5EFF DD 6E 06     	LD L, (IX+6)
  15+ 5F02 DD 66 07     	LD H, (IX+7) ; destination address
  16+ 5F05 22 C1 62     	LD (TILETMP1), HL
  17+ 5F08 DD 46 0C     	LD B, (IX+12) ; vertical tile number
  18+ 5F0B              .L1:
  19+ 5F0B C5           	PUSH BC
  20+ 5F0C DD 6E 00     		LD L, (IX+0)
  21+ 5F0F DD 66 01     		LD H, (IX+1) ; tile address
  22+ 5F12 22 C3 62     		LD (TILETMP2), HL
  23+ 5F15 DD 46 02     		LD B, (IX+2) ; tile rows
  24+ 5F18              .L2:
  25+ 5F18 C5           		PUSH BC
  26+ 5F19 CD 00 00     .CALL1:		CALL 0
  27+ 5F1C DD 46 0A     			LD B, (IX+10) ; horizontal tile num
  28+ 5F1F              .L3:
  29+ 5F1F C5           			PUSH BC
  30+ 5F20 2A C3 62     				LD HL, (TILETMP2)
  31+ 5F23 DD 46 04     				LD B, (IX+4) ; tile columns
  32+ 5F26              .L4:
  33+ 5F26 C5           				PUSH BC
  34+ 5F27              .CALL2:
  35+ 5F27 CD 00 00     					CALL 0
  36+ 5F2A C1           				POP BC
  37+ 5F2B 10 F9        				DJNZ .L4
  38+ 5F2D C1           			POP BC
  39+ 5F2E 10 EF        			DJNZ .L3
  40+ 5F30 22 C3 62     			LD (TILETMP2), HL
  41+ 5F33 2A C1 62     			LD HL, (TILETMP1)
  42+ 5F36 DD 5E 08     			LD E, (IX+8)
  43+ 5F39 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
  44+ 5F3C 19           			ADD HL, DE
  45+ 5F3D 22 C1 62     			LD (TILETMP1), HL
  46+ 5F40 C1           		POP BC
  47+ 5F41 10 D5        		DJNZ .L2
  48+ 5F43 C1           	POP BC
  49+ 5F44 10 C5        	DJNZ .L1
  50+ 5F46 C9           	RET
  51+ 5F47              ; *******************************************************************************************************
  52+ 5F47
  53+ 5F47               IFNDEF CMDS_WITH_PARAMETERS
  54+ 5F47 ~            ; *******************************************************************************************************
  55+ 5F47 ~            ; function to handle CALL TILERAM basic extension
  56+ 5F47 ~            ; fills memory with tiles
  57+ 5F47 ~            ; TILERAM ( INT request_data_ptr )
  58+ 5F47 ~            ; request_data_ptr described in TILE
  59+ 5F47 ~            ; will put ram in page 0 also, page 1 is already there
  60+ 5F47 ~            TILERAM:
  61+ 5F47 ~            	; opening (
  62+ 5F47 ~            	CALL CHKCHAR
  63+ 5F47 ~            	DB '('
  64+ 5F47 ~            	; get pointer to request struct
  65+ 5F47 ~            	LD IX, FRMQNT
  66+ 5F47 ~            	CALL CALBAS
  67+ 5F47 ~            	PUSH DE
  68+ 5F47 ~            	; ending )
  69+ 5F47 ~            	CALL CHKCHAR
  70+ 5F47 ~            	DB ')'
  71+ 5F47 ~
  72+ 5F47 ~            	POP IX ; pointer to request struct
  73+ 5F47 ~
  74+ 5F47 ~            	PUSH HL ; save position in BASIC buffer
  75+ 5F47 ~            	DI
  76+ 5F47 ~            	LD IY, .RET
  77+ 5F47 ~            	JP ENABLE_PAGE0
  78+ 5F47 ~            .RET:
  79+ 5F47 ~            	EI
  80+ 5F47 ~            	; set RAM functions to call
  81+ 5F47 ~            	LD HL, .TILECOPY
  82+ 5F47 ~            	LD (TILE.CALL2+1), HL
  83+ 5F47 ~            	LD HL, .SETDESTROW
  84+ 5F47 ~            	LD (TILE.CALL1+1), HL
  85+ 5F47 ~            	LD A,1
  86+ 5F47 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  87+ 5F47 ~            	CALL TILE
  88+ 5F47 ~            	XOR A
  89+ 5F47 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  90+ 5F47 ~
  91+ 5F47 ~                POP DE
  92+ 5F47 ~                POP BC
  93+ 5F47 ~                CALL RESTORE_PAGE_INFO
  94+ 5F47 ~
  95+ 5F47 ~            	POP HL
  96+ 5F47 ~            	RET
  97+ 5F47 ~            .TILECOPY:
  98+ 5F47 ~            	.8 LDI
  99+ 5F47 ~            	RET
 100+ 5F47 ~            .SETDESTROW:
 101+ 5F47 ~            	LD DE, (TILETMP1)
 102+ 5F47 ~            	RET
 103+ 5F47 ~            ; *******************************************************************************************************
 104+ 5F47               ENDIF
 105+ 5F47
 106+ 5F47               IFDEF CMDS_WITH_PARAMETERS
 107+ 5F47              ; *******************************************************************************************************
 108+ 5F47              ; function to handle CALL TILERAM basic extension
 109+ 5F47              ; fills memory with tiles
 110+ 5F47              ; TILERAM ( INT tile_data_pointer,
 111+ 5F47              ;			INT tile_columns,
 112+ 5F47              ;			INT tile_rows,
 113+ 5F47              ;			INT destination_pointer,
 114+ 5F47              ;			INT destination_columns,
 115+ 5F47              ;			INT destination_rows,
 116+ 5F47              ;			INT destination_begin_column,
 117+ 5F47              ;			INT destination_begin_row,
 118+ 5F47              ;			INT number_of_tiles_horizontally,
 119+ 5F47              ;			INT	number_of_tiles_vertically )
 120+ 5F47              ; will put ram in page 0 also, page 1 is already there
 121+ 5F47              TILERAM:
 122+ 5F47              	; opening (
 123+ 5F47 CD CA 65     	CALL CHKCHAR
 124+ 5F4A 28           	DB '('
 125+ 5F4B              	; get tile data pointer coordinate
 126+ 5F4B DD 21 2F 54  	LD IX, FRMQNT
 127+ 5F4F CD 59 01     	CALL CALBAS
 128+ 5F52 ED 53 C5 62  	LD (BLIT_STRUCT+0), DE
 129+ 5F56              	; comma
 130+ 5F56 CD CA 65     	CALL CHKCHAR
 131+ 5F59 2C           	DB ','
 132+ 5F5A              	; get tile columns
 133+ 5F5A DD 21 2F 54  	LD IX, FRMQNT
 134+ 5F5E CD 59 01     	CALL CALBAS
 135+ 5F61 ED 53 C9 62  	LD (BLIT_STRUCT+4), DE
 136+ 5F65              	; comma
 137+ 5F65 CD CA 65     	CALL CHKCHAR
 138+ 5F68 2C           	DB ','
 139+ 5F69              	; get tile columns
 140+ 5F69 DD 21 2F 54  	LD IX, FRMQNT
 141+ 5F6D CD 59 01     	CALL CALBAS
 142+ 5F70 ED 53 C7 62  	LD (BLIT_STRUCT+2), DE
 143+ 5F74              	; comma
 144+ 5F74 CD CA 65     	CALL CHKCHAR
 145+ 5F77 2C           	DB ','
 146+ 5F78              	; get destintion pointer
 147+ 5F78 DD 21 2F 54  	LD IX, FRMQNT
 148+ 5F7C CD 59 01     	CALL CALBAS
 149+ 5F7F ED 53 CB 62  	LD (BLIT_STRUCT+6), DE
 150+ 5F83              	; comma
 151+ 5F83 CD CA 65     	CALL CHKCHAR
 152+ 5F86 2C           	DB ','
 153+ 5F87              	; get destination columns
 154+ 5F87 DD 21 2F 54  	LD IX, FRMQNT
 155+ 5F8B CD 59 01     	CALL CALBAS
 156+ 5F8E 7B           	LD A, E
 157+ 5F8F 32 C1 62     	LD (BLIT_TMP+0), A
 158+ 5F92              	; comma
 159+ 5F92 CD CA 65     	CALL CHKCHAR
 160+ 5F95 2C           	DB ','
 161+ 5F96              	; get destination rows
 162+ 5F96 DD 21 2F 54  	LD IX, FRMQNT
 163+ 5F9A CD 59 01     	CALL CALBAS
 164+ 5F9D 7B           	LD A, E
 165+ 5F9E 32 C2 62     	LD (BLIT_TMP+1), A
 166+ 5FA1              	; comma
 167+ 5FA1 CD CA 65     	CALL CHKCHAR
 168+ 5FA4 2C           	DB ','
 169+ 5FA5              	; get destination begin column
 170+ 5FA5 DD 21 2F 54  	LD IX, FRMQNT
 171+ 5FA9 CD 59 01     	CALL CALBAS
 172+ 5FAC 7B           	LD A, E
 173+ 5FAD 32 C3 62     	LD (BLIT_TMP+2), A
 174+ 5FB0              	; comma
 175+ 5FB0 CD CA 65     	CALL CHKCHAR
 176+ 5FB3 2C           	DB ','
 177+ 5FB4              	; get destination begin row
 178+ 5FB4 DD 21 2F 54  	LD IX, FRMQNT
 179+ 5FB8 CD 59 01     	CALL CALBAS
 180+ 5FBB 7B           	LD A, E
 181+ 5FBC 32 C4 62     	LD (BLIT_TMP+3), A
 182+ 5FBF              	; comma
 183+ 5FBF CD CA 65     	CALL CHKCHAR
 184+ 5FC2 2C           	DB ','
 185+ 5FC3              	; get number of tiles horizontally
 186+ 5FC3 DD 21 2F 54  	LD IX, FRMQNT
 187+ 5FC7 CD 59 01     	CALL CALBAS
 188+ 5FCA ED 53 CF 62  	LD (BLIT_STRUCT+10), DE
 189+ 5FCE              	; comma
 190+ 5FCE CD CA 65     	CALL CHKCHAR
 191+ 5FD1 2C           	DB ','
 192+ 5FD2              	; get number of tiles vertically
 193+ 5FD2 DD 21 2F 54  	LD IX, FRMQNT
 194+ 5FD6 CD 59 01     	CALL CALBAS
 195+ 5FD9 ED 53 D1 62  	LD (BLIT_STRUCT+12), DE
 196+ 5FDD              	; ending )
 197+ 5FDD CD CA 65     	CALL CHKCHAR
 198+ 5FE0 29           	DB ')'
 199+ 5FE1
 200+ 5FE1 E5           	PUSH HL ; save position in BASIC buffer
 201+ 5FE2
 202+ 5FE2              	; calculate destination add to value
 203+ 5FE2 26 00        	LD H, 0
 204+ 5FE4 3A C1 62     	LD A, (BLIT_TMP+0)
 205+ 5FE7 6F           	LD L, A
 206+ 5FE8 CD B8 64     	CALL HLx8
 207+ 5FEB 22 CD 62     	LD (BLIT_STRUCT+8), HL
 208+ 5FEE              	; calculate pointer to background location
 209+ 5FEE 21 00 00     	LD HL, 0
 210+ 5FF1 3A C4 62     	LD A,(BLIT_TMP+3)
 211+ 5FF4 B7           	OR A
 212+ 5FF5 28 08        	JR Z, .L1
 213+ 5FF7 47           	LD B,A
 214+ 5FF8 ED 5B CD 62  	LD DE,(BLIT_STRUCT+8)
 215+ 5FFC              .L0:
 216+ 5FFC 19           	ADD HL, DE
 217+ 5FFD 10 FD        	DJNZ .L0
 218+ 5FFF              .L1:
 219+ 5FFF EB           	EX DE,HL
 220+ 6000 26 00        	LD H,0
 221+ 6002 3A C3 62     	LD A,(BLIT_TMP+2)
 222+ 6005 6F           	LD L,A
 223+ 6006 CD B8 64     	CALL HLx8
 224+ 6009 19           	ADD HL,DE
 225+ 600A ED 5B CB 62  	LD DE,(BLIT_STRUCT+6)
 226+ 600E 19           	ADD HL,DE
 227+ 600F 22 CB 62     	LD (BLIT_STRUCT+6),HL
 228+ 6012 F3           	DI
 229+ 6013 FD 21 1A 60  	LD IY, .RET
 230+ 6017 C3 7C 65     	JP ENABLE_PAGE0
 231+ 601A              .RET:
 232+ 601A FB           	EI
 233+ 601B              	; set RAM functions to call
 234+ 601B 21 35 60     	LD HL, .TILECOPY
 235+ 601E 22 28 5F     	LD (TILE.CALL2+1), HL
 236+ 6021 21 46 60     	LD HL, .SETDESTROW
 237+ 6024 22 1A 5F     	LD (TILE.CALL1+1), HL
 238+ 6027 DD 21 C5 62  	LD IX,BLIT_STRUCT
 239+ 602B CD FF 5E     	CALL TILE
 240+ 602E
 241+ 602E D1               POP DE
 242+ 602F C1               POP BC
 243+ 6030 CD F3 64         CALL RESTORE_PAGE_INFO
 244+ 6033
 245+ 6033 E1           	POP HL
 246+ 6034 C9           	RET
 247+ 6035              .TILECOPY:
 248+ 6035 ED A0       > LDI
 248+ 6037 ED A0       > LDI
 248+ 6039 ED A0       > LDI
 248+ 603B ED A0       > LDI
 248+ 603D ED A0       > LDI
 248+ 603F ED A0       > LDI
 248+ 6041 ED A0       > LDI
 248+ 6043 ED A0       > LDI
 249+ 6045 C9           	RET
 250+ 6046              .SETDESTROW:
 251+ 6046 ED 5B C1 62  	LD DE, (TILETMP1)
 252+ 604A C9           	RET
 253+ 604B              ; *******************************************************************************************************
 254+ 604B               ENDIF
 255+ 604B
 256+ 604B               IFDEF CMDS_WITH_PARAMETERS
 257+ 604B              ; *******************************************************************************************************
 258+ 604B              ; function to handle CALL TILEVRM basic extension
 259+ 604B              ; fills vram with tiles
 260+ 604B              ; TILEVRM ( INT tile_data_pointer,
 261+ 604B              ;			INT tile_columns,
 262+ 604B              ;			INT tile_rows,
 263+ 604B              ;			INT destination_begin_column,
 264+ 604B              ;			INT destination_begin_row,
 265+ 604B              ;			INT number_of_tiles_horizontally,
 266+ 604B              ;			INT	number_of_tiles_vertically )
 267+ 604B              ; will put ram in page 0 also, page 1 is already there
 268+ 604B              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
 269+ 604B              TILEVRM:
 270+ 604B              	; opening (
 271+ 604B CD CA 65     	CALL CHKCHAR
 272+ 604E 28           	DB '('
 273+ 604F              	; get tile data pointer coordinate
 274+ 604F DD 21 2F 54  	LD IX, FRMQNT
 275+ 6053 CD 59 01     	CALL CALBAS
 276+ 6056 ED 53 C5 62  	LD (BLIT_STRUCT+0), DE
 277+ 605A              	; comma
 278+ 605A CD CA 65     	CALL CHKCHAR
 279+ 605D 2C           	DB ','
 280+ 605E              	; get tile columns
 281+ 605E DD 21 2F 54  	LD IX, FRMQNT
 282+ 6062 CD 59 01     	CALL CALBAS
 283+ 6065 ED 53 C9 62  	LD (BLIT_STRUCT+4), DE
 284+ 6069              	; comma
 285+ 6069 CD CA 65     	CALL CHKCHAR
 286+ 606C 2C           	DB ','
 287+ 606D              	; get tile columns
 288+ 606D DD 21 2F 54  	LD IX, FRMQNT
 289+ 6071 CD 59 01     	CALL CALBAS
 290+ 6074 ED 53 C7 62  	LD (BLIT_STRUCT+2), DE
 291+ 6078              	; comma
 292+ 6078 CD CA 65     	CALL CHKCHAR
 293+ 607B 2C           	DB ','
 294+ 607C              	; get destination begin column
 295+ 607C DD 21 2F 54  	LD IX, FRMQNT
 296+ 6080 CD 59 01     	CALL CALBAS
 297+ 6083 7B           	LD A, E
 298+ 6084 32 C3 62     	LD (BLIT_TMP+2), A
 299+ 6087              	; comma
 300+ 6087 CD CA 65     	CALL CHKCHAR
 301+ 608A 2C           	DB ','
 302+ 608B              	; get destination begin row
 303+ 608B DD 21 2F 54  	LD IX, FRMQNT
 304+ 608F CD 59 01     	CALL CALBAS
 305+ 6092 7B           	LD A, E
 306+ 6093 32 C4 62     	LD (BLIT_TMP+3), A
 307+ 6096              	; comma
 308+ 6096 CD CA 65     	CALL CHKCHAR
 309+ 6099 2C           	DB ','
 310+ 609A              	; get number of tiles horizontally
 311+ 609A DD 21 2F 54  	LD IX, FRMQNT
 312+ 609E CD 59 01     	CALL CALBAS
 313+ 60A1 ED 53 CF 62  	LD (BLIT_STRUCT+10), DE
 314+ 60A5              	; comma
 315+ 60A5 CD CA 65     	CALL CHKCHAR
 316+ 60A8 2C           	DB ','
 317+ 60A9              	; get number of tiles vertically
 318+ 60A9 DD 21 2F 54  	LD IX, FRMQNT
 319+ 60AD CD 59 01     	CALL CALBAS
 320+ 60B0 ED 53 D1 62  	LD (BLIT_STRUCT+12), DE
 321+ 60B4              	; ending )
 322+ 60B4 CD CA 65     	CALL CHKCHAR
 323+ 60B7 29           	DB ')'
 324+ 60B8
 325+ 60B8 E5           	PUSH HL ; save position in BASIC buffer
 326+ 60B9
 327+ 60B9              	; calculate destination add to value
 328+ 60B9 21 00 01     	LD HL, 256
 329+ 60BC 22 CD 62     	LD (BLIT_STRUCT+8), HL
 330+ 60BF              	; calculate pointer to background location
 331+ 60BF 3A C4 62     	LD A,(BLIT_TMP+3)
 332+ 60C2 67           	LD H,A
 333+ 60C3 2E 00        	LD L,0
 334+ 60C5 EB           	EX DE,HL
 335+ 60C6 26 00        	LD H,0
 336+ 60C8 3A C3 62     	LD A,(BLIT_TMP+2)
 337+ 60CB 6F           	LD L,A
 338+ 60CC CD B8 64     	CALL HLx8
 339+ 60CF 19           	ADD HL,DE
 340+ 60D0 ED 5B CB F3  	LD DE,(GRPCGP)
 341+ 60D4 19           	ADD HL,DE
 342+ 60D5 22 CB 62     	LD (BLIT_STRUCT+6),HL
 343+ 60D8 F3           	DI
 344+ 60D9 FD 21 E0 60  	LD IY, .RET
 345+ 60DD C3 7C 65     	JP ENABLE_PAGE0
 346+ 60E0              .RET:
 347+ 60E0 FB           	EI
 348+ 60E1              	; set RAM functions to call
 349+ 60E1 21 FB 60     	LD HL, .TILECOPY
 350+ 60E4 22 28 5F     	LD (TILE.CALL2+1), HL
 351+ 60E7 21 01 61     	LD HL, .SETDESTROW
 352+ 60EA 22 1A 5F     	LD (TILE.CALL1+1), HL
 353+ 60ED DD 21 C5 62  	LD IX,BLIT_STRUCT
 354+ 60F1 CD FF 5E     	CALL TILE
 355+ 60F4
 356+ 60F4 D1               POP DE
 357+ 60F5 C1               POP BC
 358+ 60F6 CD F3 64         CALL RESTORE_PAGE_INFO
 359+ 60F9
 360+ 60F9 E1           	POP HL
 361+ 60FA C9           	RET
 362+ 60FB              .TILECOPY:
 363+ 60FB 01 98 08     	LD BC, #0898
 364+ 60FE C3 B0 64     	JP BBYTECOPY_NO_C
 365+ 6101              .SETDESTROW:
 366+ 6101 2A C1 62     	LD HL, (TILETMP1)
 367+ 6104 F3           	DI
 368+ 6105 CD A3 64     	CALL SETWRT_LOCAL
 369+ 6108 FB           	EI
 370+ 6109 C9           	RET
 371+ 610A              ; *******************************************************************************************************
 372+ 610A               ENDIF
 373+ 610A
 374+ 610A               IFNDEF CMDS_WITH_PARAMETERS
 375+ 610A ~            ; *******************************************************************************************************
 376+ 610A ~            ; function to handle CALL TILEVRM basic extension
 377+ 610A ~            ; fills vram with tiles
 378+ 610A ~            ; TILEVRM ( INT request_data_ptr )
 379+ 610A ~            ; request_data_ptr described in TILE
 380+ 610A ~            ; will put ram in page 0 also, page 1 is already there
 381+ 610A ~            TILEVRM:
 382+ 610A ~            	; opening (
 383+ 610A ~            	CALL CHKCHAR
 384+ 610A ~            	DB '('
 385+ 610A ~            	; get pointer to request struct
 386+ 610A ~            	LD IX, FRMQNT
 387+ 610A ~            	CALL CALBAS
 388+ 610A ~            	PUSH DE
 389+ 610A ~            	; ending )
 390+ 610A ~            	CALL CHKCHAR
 391+ 610A ~            	DB ')'
 392+ 610A ~
 393+ 610A ~            	POP IX ; pointer to request struct
 394+ 610A ~
 395+ 610A ~            	PUSH HL ; save position in BASIC buffer
 396+ 610A ~            	DI
 397+ 610A ~            	LD IY, .RET
 398+ 610A ~            	JP ENABLE_PAGE0
 399+ 610A ~            .RET:
 400+ 610A ~            	EI
 401+ 610A ~            	; set RAM functions to call
 402+ 610A ~            	LD HL, .TILECOPY
 403+ 610A ~            	LD (TILE.CALL2+1), HL
 404+ 610A ~            	LD HL, .SETDESTROW
 405+ 610A ~            	LD (TILE.CALL1+1), HL
 406+ 610A ~            	CALL TILE
 407+ 610A ~
 408+ 610A ~                POP DE
 409+ 610A ~                POP BC
 410+ 610A ~                CALL RESTORE_PAGE_INFO
 411+ 610A ~
 412+ 610A ~            	POP HL
 413+ 610A ~            	RET
 414+ 610A ~            .TILECOPY:
 415+ 610A ~            	LD BC, #0898
 416+ 610A ~            	JP BBYTECOPY_NO_C
 417+ 610A ~            .SETDESTROW:
 418+ 610A ~            	LD HL, (TILETMP1)
 419+ 610A ~            	DI
 420+ 610A ~            	CALL SETWRT_LOCAL
 421+ 610A ~            	EI
 422+ 610A ~            	RET
 423+ 610A ~            ; *******************************************************************************************************
 424+ 610A               ENDIF
# file closed: asm\TILE.asm
 163  610A               ENDIF
 164  610A
 165  610A               IF (COLL_CMD == 1)
 166  610A               INCLUDE "COLLISION.asm"
# file opened: asm\COLLISION.asm
   1+ 610A              ; generic collision checking routines
   2+ 610A              ; in BASIC we use rectangle structure array DIM R%(7,n) of the format
   3+ 610A              ; R%(0,n) is active flag, <>0 active / 0 skipped in checks
   4+ 610A              ; R%(1,n) is either upper left x coordinate or sprite id (0-31) depending on R(7,n)
   5+ 610A              ; R%(2,n) is either upper left y coordinate or unused depending on R(7,n)
   6+ 610A              ; R%(3,n) x offset where rectangle begins
   7+ 610A              ; R%(4,n) y offset where rectangle begins
   8+ 610A              ; R%(5,n) is width
   9+ 610A              ; R%(6,n) is height
  10+ 610A              ; R%(7,0) is type, 0=generic where R%(1,0) contains x coordinate
  11+ 610A              ;                  <>0 sprite where R%(1,0) contains sprite id
  12+ 610A              ; for type sprite, upper left coordinates are taken from sprite attribute array
  13+ 610A
  14+ 610A              ; ************************************************************************************************
  15+ 610A              ; quick test if HL<=DE<=HL+BC
  16+ 610A              ; input BC=width, DE=x, HL=min
  17+ 610A              ; if not true flag C set
  18+ 610A              ; modifies AF
  19+ 610A              GENERIC_INNER_CHECK:
  20+ 610A E5               PUSH HL
  21+ 610B D5               PUSH DE
  22+ 610C EB               EX DE,HL
  23+ 610D A7               AND A
  24+ 610E ED 52            SBC HL, DE
  25+ 6110 FA 1E 61         JP M, .GENERIC_INNER_CHECK_NOT
  26+ 6113 A7               AND A
  27+ 6114 ED 42            SBC HL, BC
  28+ 6116 28 03            JR Z, .L2
  29+ 6118 F2 1E 61         JP P, .GENERIC_INNER_CHECK_NOT
  30+ 611B              .L2:
  31+ 611B A7               AND A
  32+ 611C 18 01            JR .EXIT
  33+ 611E              .GENERIC_INNER_CHECK_NOT:
  34+ 611E 37               SCF
  35+ 611F              .EXIT:
  36+ 611F D1               POP DE
  37+ 6120 E1               POP HL
  38+ 6121 C9               RET
  39+ 6122              ; ************************************************************************************************
  40+ 6122
  41+ 6122              ; ************************************************************************************************
  42+ 6122              ; function to check if rectangles are overlapping
  43+ 6122              ; input IX=IY=pointer to struct
  44+ 6122              ;  +00 active flag
  45+ 6122              ;  +02 x coordinate
  46+ 6122              ;  +04 y coordinate
  47+ 6122              ;  +06 x offset where rectangle begins
  48+ 6122              ;  +08 y offset where rectangle begins
  49+ 6122              ;  +10 width
  50+ 6122              ;  +12 height
  51+ 6122              ; where IY is used to read +2 and +4, and IX to read +6, +8, +10 and +12
  52+ 6122              ; this is a hack to allow location being taken from sprite attributes table
  53+ 6122              ; input BLIT_STRUCT data
  54+ 6122              ;  +00 x coordinate
  55+ 6122              ;  +02 y coordinate
  56+ 6122              ;  +04 width
  57+ 6122              ;  +06 height
  58+ 6122              ; returns CF=1 if not overlapping, CF=0 if overlapping
  59+ 6122              RECTANGLE_OVERLAP_CHECK:
  60+ 6122                  ; first check which rectangle is higher
  61+ 6122 DD 6E 0C         LD L,(IX+12)
  62+ 6125 DD 66 0D         LD H,(IX+13)
  63+ 6128 ED 5B CB 62      LD DE,(BLIT_STRUCT+6)
  64+ 612C A7               AND A
  65+ 612D ED 52            SBC HL,DE
  66+ 612F FD 6E 04         LD L,(IY+4)
  67+ 6132 FD 66 05         LD H,(IY+5)
  68+ 6135 DD 5E 08         LD E,(IX+8)
  69+ 6138 DD 56 09         LD D,(IX+9)
  70+ 613B FA 5B 61         JP M,.L1
  71+ 613E                  ; equally high or IX defined one higher
  72+ 613E                  ; check upper boundary
  73+ 613E 19               ADD HL,DE
  74+ 613F ED 5B C7 62      LD DE,(BLIT_STRUCT+2)
  75+ 6143 DD 4E 0C         LD C,(IX+12)
  76+ 6146 DD 46 0D         LD B,(IX+13)
  77+ 6149 CD 0A 61         CALL GENERIC_INNER_CHECK
  78+ 614C 30 29            JR NC,.INSIDE
  79+ 614E                  ; check lower boundary
  80+ 614E E5               PUSH HL
  81+ 614F 2A CB 62         LD HL,(BLIT_STRUCT+6)
  82+ 6152 19               ADD HL,DE
  83+ 6153 EB               EX DE,HL
  84+ 6154 E1               POP HL
  85+ 6155 CD 0A 61         CALL GENERIC_INNER_CHECK
  86+ 6158 30 1D            JR NC,.INSIDE
  87+ 615A C9               RET ; not overlapping
  88+ 615B              .L1:
  89+ 615B                  ; rectangle defined in BLIT_STRUCT is higher
  90+ 615B 19               ADD HL,DE
  91+ 615C EB               EX DE,HL
  92+ 615D 2A C7 62         LD HL,(BLIT_STRUCT+2)
  93+ 6160 ED 4B CB 62      LD BC,(BLIT_STRUCT+6)
  94+ 6164 CD 0A 61         CALL GENERIC_INNER_CHECK
  95+ 6167 30 0E            JR NC,.INSIDE
  96+ 6169 E5               PUSH HL
  97+ 616A DD 6E 0C         LD L,(IX+12)
  98+ 616D DD 66 0D         LD H,(IX+13)
  99+ 6170 19               ADD HL,DE
 100+ 6171 EB               EX DE,HL
 101+ 6172 E1               POP HL
 102+ 6173 CD 0A 61         CALL GENERIC_INNER_CHECK
 103+ 6176 D8               RET C
 104+ 6177              .INSIDE:
 105+ 6177                  ; check x coordinate
 106+ 6177                  ; first check which rectangle is wider
 107+ 6177 DD 6E 0A         LD L,(IX+10)
 108+ 617A DD 66 0B         LD H,(IX+11)
 109+ 617D ED 5B C9 62      LD DE,(BLIT_STRUCT+4)
 110+ 6181 A7               AND A
 111+ 6182 ED 52            SBC HL,DE
 112+ 6184 FD 6E 02         LD L,(IY+2)
 113+ 6187 FD 66 03         LD H,(IY+3)
 114+ 618A DD 5E 06         LD E,(IX+6)
 115+ 618D DD 56 07         LD D,(IX+7)
 116+ 6190 FA AC 61         JP M,.L2
 117+ 6193                  ; equally wide or IX defined one wider
 118+ 6193                  ; check left boundary
 119+ 6193 19               ADD HL,DE
 120+ 6194 ED 5B C5 62      LD DE,(BLIT_STRUCT+0)
 121+ 6198 DD 4E 0A         LD C,(IX+10)
 122+ 619B DD 46 0B         LD B,(IX+11)
 123+ 619E CD 0A 61         CALL GENERIC_INNER_CHECK
 124+ 61A1 D0               RET NC ; overlap
 125+ 61A2                  ; check right boundary
 126+ 61A2 E5               PUSH HL
 127+ 61A3 2A C9 62         LD HL,(BLIT_STRUCT+4)
 128+ 61A6 19               ADD HL,DE
 129+ 61A7 EB               EX DE,HL
 130+ 61A8 E1               POP HL
 131+ 61A9 C3 0A 61         JP GENERIC_INNER_CHECK ; CF and result set by fn call
 132+ 61AC              .L2:
 133+ 61AC                  ; rectangle defined in BLIT_STRUCT is higher
 134+ 61AC 19               ADD HL,DE
 135+ 61AD EB               EX DE,HL
 136+ 61AE 2A C5 62         LD HL,(BLIT_STRUCT+0)
 137+ 61B1 ED 4B C9 62      LD BC,(BLIT_STRUCT+4)
 138+ 61B5 CD 0A 61         CALL GENERIC_INNER_CHECK
 139+ 61B8 D0               RET NC ; overlap
 140+ 61B9 E5               PUSH HL
 141+ 61BA DD 6E 0A         LD L,(IX+10)
 142+ 61BD DD 66 0B         LD H,(IX+11)
 143+ 61C0 19               ADD HL,DE
 144+ 61C1 EB               EX DE,HL
 145+ 61C2 E1               POP HL
 146+ 61C3 C3 0A 61         JP GENERIC_INNER_CHECK
 147+ 61C6              ; ************************************************************************************************
 148+ 61C6
 149+ 61C6              ; ************************************************************************************************
 150+ 61C6              ; function tries to find rectangle overlap and returns an index if found
 151+ 61C6              ; input BLIT_STRUCT data
 152+ 61C6              ;  +00 x coordinate
 153+ 61C6              ;  +02 y coordinate
 154+ 61C6              ;  +04 width
 155+ 61C6              ;  +06 height
 156+ 61C6              ;  +08 number of items in a list, described under RECTANGLE_OVERLAP_CHECK
 157+ 61C6              ;  +09 pointer to first element of R%(7,n)
 158+ 61C6              ;  +11 pointer to INT result variable
 159+ 61C6              ; returns CF=1 if not overlapping
 160+ 61C6              ; returns A=list index and CF=0 if overlapping
 161+ 61C6              FIND_OVERLAP:
 162+ 61C6 3A CD 62         LD A,(BLIT_STRUCT+8)
 163+ 61C9 47               LD B,A
 164+ 61CA DD 2A CE 62      LD IX,(BLIT_STRUCT+9)
 165+ 61CE              .L1:
 166+ 61CE C5               PUSH BC
 167+ 61CF                  ; check active flag
 168+ 61CF DD 7E 00         LD A,(IX)
 169+ 61D2 DD B6 01         OR (IX+1)
 170+ 61D5 28 18            JR Z,.NEXT
 171+ 61D7                  ; check type
 172+ 61D7 DD 7E 0E         LD A,(IX+14)
 173+ 61DA DD B6 0F         OR (IX+15)
 174+ 61DD 20 1A            JR NZ,.L2
 175+ 61DF DD E5            PUSH IX
 176+ 61E1 FD E1            POP IY
 177+ 61E3              .L3:
 178+ 61E3 CD 22 61         CALL RECTANGLE_OVERLAP_CHECK
 179+ 61E6 38 07            JR C,.NEXT
 180+ 61E8                  ; found
 181+ 61E8 C1               POP BC
 182+ 61E9 3A CD 62         LD A,(BLIT_STRUCT+8)
 183+ 61EC 90               SUB B
 184+ 61ED A7               AND A
 185+ 61EE C9               RET
 186+ 61EF              .NEXT:
 187+ 61EF 11 10 00         LD DE,16
 188+ 61F2 DD 19            ADD IX,DE
 189+ 61F4 C1               POP BC
 190+ 61F5 10 D7            DJNZ .L1
 191+ 61F7 37               SCF
 192+ 61F8 C9               RET
 193+ 61F9              .L2:
 194+ 61F9                  ; sprite, need to build a temporary data struct since x and y values are inversed
 195+ 61F9                  ; at BLIT_STRUCT+13
 196+ 61F9 DD 7E 02         LD A,(IX+2) ; sprite ID
 197+ 61FC CD 89 4D         CALL GETnthSPRATTR
 198+ 61FF FD 21 D0 62      LD IY,BLIT_STRUCT+11
 199+ 6203 7E               LD A,(HL)
 200+ 6204 FD 77 04         LD (IY+4),A
 201+ 6207 23               INC HL
 202+ 6208 7E               LD A,(HL)
 203+ 6209 FD 77 05         LD (IY+5),A
 204+ 620C 23               INC HL
 205+ 620D 7E               LD A,(HL)
 206+ 620E FD 77 02         LD (IY+2),A
 207+ 6211 23               INC HL
 208+ 6212 7E               LD A,(HL)
 209+ 6213 FD 77 03         LD (IY+3),A
 210+ 6216 18 CB            JR .L3
 211+ 6218              ; ************************************************************************************************
 212+ 6218
 213+ 6218              ; ************************************************************************************************
 214+ 6218              ; function to handle CALL COLL basic extension
 215+ 6218              ; checks for collision between player and other rectangles
 216+ 6218              ; COLL ( INT result variable,
 217+ 6218              ;	     INT player x value,
 218+ 6218              ;	     INT player y value,
 219+ 6218              ;	     INT player width,
 220+ 6218              ;	     INT player height,
 221+ 6218              ;	     INT number of items in a list,
 222+ 6218              ;		 INT[6][n] rectangle struct )
 223+ 6218              ; will fill result variable with index or -1 if no collision
 224+ 6218              ; rectangle struct described under RECTANGLE_OVERLAP_CHECK
 225+ 6218              COLL:
 226+ 6218              	; opening (
 227+ 6218 CD CA 65     	CALL CHKCHAR
 228+ 621B 28           	DB '('
 229+ 621C              	; get address of result variable
 230+ 621C DD 21 A4 5E  	LD IX, PTRGET
 231+ 6220 CD 59 01     	CALL CALBAS
 232+ 6223 ED 53 D0 62  	LD (BLIT_STRUCT+11),DE
 233+ 6227              	; comma
 234+ 6227 CD CA 65     	CALL CHKCHAR
 235+ 622A 2C           	DB ','
 236+ 622B              	; get x
 237+ 622B DD 21 2F 54  	LD IX, FRMQNT
 238+ 622F CD 59 01     	CALL CALBAS
 239+ 6232 ED 53 C5 62  	LD (BLIT_STRUCT+0),DE
 240+ 6236              	; comma
 241+ 6236 CD CA 65     	CALL CHKCHAR
 242+ 6239 2C           	DB ','
 243+ 623A              	; get y
 244+ 623A DD 21 2F 54  	LD IX, FRMQNT
 245+ 623E CD 59 01     	CALL CALBAS
 246+ 6241 ED 53 C7 62  	LD (BLIT_STRUCT+2),DE
 247+ 6245              	; comma
 248+ 6245 CD CA 65     	CALL CHKCHAR
 249+ 6248 2C           	DB ','
 250+ 6249              	; get width
 251+ 6249 DD 21 2F 54  	LD IX, FRMQNT
 252+ 624D CD 59 01     	CALL CALBAS
 253+ 6250 ED 53 C9 62  	LD (BLIT_STRUCT+4),DE
 254+ 6254              	; comma
 255+ 6254 CD CA 65     	CALL CHKCHAR
 256+ 6257 2C           	DB ','
 257+ 6258              	; get height
 258+ 6258 DD 21 2F 54  	LD IX, FRMQNT
 259+ 625C CD 59 01     	CALL CALBAS
 260+ 625F ED 53 CB 62  	LD (BLIT_STRUCT+6),DE
 261+ 6263              	; comma
 262+ 6263 CD CA 65     	CALL CHKCHAR
 263+ 6266 2C           	DB ','
 264+ 6267              	; get number of items in a list
 265+ 6267 DD 21 1C 52  	LD IX, GETBYT
 266+ 626B CD 59 01     	CALL CALBAS
 267+ 626E 32 CD 62     	LD (BLIT_STRUCT+8),A
 268+ 6271              	; comma
 269+ 6271 CD CA 65     	CALL CHKCHAR
 270+ 6274 2C           	DB ','
 271+ 6275              	; get address of rectangle structure array DIM R%(7,n)
 272+ 6275 3A CD 62     	LD A,(BLIT_STRUCT+8)
 273+ 6278 5F               LD E,A
 274+ 6279 3E 02            LD A,2
 275+ 627B 47           	LD B,A
 276+ 627C 16 07        	LD D,7
 277+ 627E CD F7 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
 278+ 6281 ED 43 CE 62  	LD (BLIT_STRUCT+9),BC
 279+ 6285              	; ending )
 280+ 6285 CD CA 65     	CALL CHKCHAR
 281+ 6288 29           	DB ')'
 282+ 6289
 283+ 6289 E5               PUSH HL
 284+ 628A CD C6 61         CALL FIND_OVERLAP
 285+ 628D 2A D0 62         LD HL,(BLIT_STRUCT+11)
 286+ 6290 38 06            JR C,.NOTFOUND
 287+ 6292 77               LD (HL),A
 288+ 6293 23               INC HL
 289+ 6294 36 00            LD (HL),0
 290+ 6296 E1               POP HL
 291+ 6297 C9               RET
 292+ 6298              .NOTFOUND:
 293+ 6298 36 FF            LD (HL),#FF
 294+ 629A 23               INC HL
 295+ 629B 36 FF            LD (HL),#FF
 296+ 629D E1               POP HL
 297+ 629E C9               RET
 298+ 629F              ; ************************************************************************************************
 299+ 629F
# file closed: asm\COLLISION.asm
 167  629F               ENDIF
 168  629F
 169  629F               IF (DEFUSR_EXTENSION == 1)
 170  629F               INCLUDE "DEFUSR.asm"
# file opened: asm\DEFUSR.asm
   1+ 629F              ; entry function that handles call using CALLF
   2+ 629F              ; pointer to data structure is expected at DAC+2
   3+ 629F              ; first entry must be function id followed by function specific parameters
   4+ 629F
   5+ 629F              DEFUSR_TABLE_ENTRIES    EQU 4
   6+ 629F
   7+ 629F              DEFUSR_JUMP_TABLE:
   8+ 629F               IF (SPRITE_CMDS == 1)
   9+ 629F B5 4E         DW SPRENABLE_DEFUSR        ; 0
  10+ 62A1               ELSE
  11+ 62A1 ~             DW NOACTION_DEFUSR
  12+ 62A1               ENDIF
  13+ 62A1
  14+ 62A1               IF (SPRITE_CMDS == 1)
  15+ 62A1 D5 4E         DW SPRDISABLE_DEFUSR        ; 1
  16+ 62A3               ELSE
  17+ 62A3 ~             DW NOACTION_DEFUSR
  18+ 62A3               ENDIF
  19+ 62A3
  20+ 62A3               IF (RAM_CMDS == 1)
  21+ 62A3 8A 58         DW MEMCPY_DEFUSR           ; 2
  22+ 62A5               ELSE
  23+ 62A5 ~             DW NOACTION_DEFUSR
  24+ 62A5               ENDIF
  25+ 62A5
  26+ 62A5               IF (VRAM_CMDS == 1)        ; 3
  27+ 62A5 89 5A         DW MEMVRM_DEFUSR
  28+ 62A7               ELSE
  29+ 62A7 ~             DW NOACTION_DEFUSR
  30+ 62A7               ENDIF
  31+ 62A7
  32+ 62A7              DEFUSR_ENTRY:
  33+ 62A7 FB               EI
  34+ 62A8 DD 2A F8 F7      LD IX,(DAC+2)
  35+ 62AC DD 7E 00         LD A,(IX)
  36+ 62AF FE 04            CP DEFUSR_TABLE_ENTRIES
  37+ 62B1 D0               RET NC ; return if an undefined function requested
  38+ 62B2 26 00            LD H,0
  39+ 62B4 6F               LD L,A
  40+ 62B5 29               ADD HL,HL
  41+ 62B6 11 9F 62         LD DE,DEFUSR_JUMP_TABLE
  42+ 62B9 19               ADD HL,DE
  43+ 62BA EB               EX DE,HL
  44+ 62BB 1A               LD A,(DE)
  45+ 62BC 6F               LD L,A
  46+ 62BD 13               INC DE
  47+ 62BE 1A               LD A,(DE)
  48+ 62BF 67               LD H,A
  49+ 62C0 E9               JP (HL) ; call function with IX=pointer to data array
  50+ 62C1
# file closed: asm\DEFUSR.asm
 171  62C1               ENDIF
 172  62C1
 173  62C1              ; temp variables for BLIT, TILE functions
 174  62C1               IF (BLIT_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS + COLL_CMD > 0)
 175  62C1              BLIT_TMP:
 176  62C1              TILETMP1:
 177  62C1              BLIT_TMP1:
 178  62C1 00 00         DW 0
 179  62C3              TILETMP2:
 180  62C3              BLIT_TMP2:
 181  62C3 00 00         DW 0
 182  62C5                IFDEF CMDS_WITH_PARAMETERS
 183  62C5              BLIT_STRUCT:
 184  62C5 00 00 00...   DS 17
 185  62C9                ENDIF
 186  62C9               ENDIF
 187  62D6
 188  62D6               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 189  62D6              VRAM_UPDATE_IN_PROGRESS:
 190  62D6 00            DB 0
 191  62D7               ENDIF
 192  62D7
 193  62D7              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 194  62D7              ; per starting letter, if no commands with this letter, NULL value
 195  62D7              CMDS:
 196  62D7               IF (ANIM_CMDS == 1)
 197  62D7 0D 64        	DW CMDS_A ;
 198  62D9               ELSE
 199  62D9 ~                DW 0 ; A
 200  62D9               ENDIF
 201  62D9               IF (BLIT_CMDS + BOX_CMDS > 0)
 202  62D9 D8 63            DW CMDS_B ; B
 203  62DB               ELSE
 204  62DB ~            	DW 0
 205  62DB               ENDIF
 206  62DB               IF (COLL_CMD == 1)
 207  62DB 9B 64        	DW CMDS_C ;
 208  62DD               ELSE
 209  62DD ~                DW 0 ; C
 210  62DD               ENDIF
 211  62DD 00 00            DW 0 ; D
 212  62DF 00 00            DW 0 ; E
 213  62E1               IF (VRAM_CMDS + RAM_CMDS > 0)
 214  62E1 58 63            DW CMDS_F; F
 215  62E3               ELSE
 216  62E3 ~            	DW 0
 217  62E3               ENDIF
 218  62E3               IF (GENCAL_CMD > 0)
 219  62E3 6B 63            DW CMDS_G; G
 220  62E5               ELSE
 221  62E5 ~            	DW 0
 222  62E5               ENDIF
 223  62E5 00 00            DW 0 ; H
 224  62E7 00 00            DW 0 ; I
 225  62E9 00 00            DW 0 ; J
 226  62EB 00 00            DW 0 ; K
 227  62ED 00 00            DW 0 ; L
 228  62EF               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 229  62EF 0B 63            DW CMDS_M ; M
 230  62F1               ELSE
 231  62F1 ~            	DW 0
 232  62F1               ENDIF
 233  62F1 00 00            DW 0 ; N
 234  62F3 00 00            DW 0 ; O
 235  62F5 00 00            DW 0 ; P
 236  62F7 00 00            DW 0 ; Q
 237  62F9 00 00            DW 0 ; R
 238  62FB               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 239  62FB 7F 63            DW CMDS_S ; S
 240  62FD               ELSE
 241  62FD ~            	DW 0
 242  62FD               ENDIF
 243  62FD               IF (TILE_CMDS > 0)
 244  62FD F8 63            DW CMDS_T ; T
 245  62FF               ELSE
 246  62FF ~            	DW 0
 247  62FF               ENDIF
 248  62FF 00 00            DW 0 ; U
 249  6301               IF (VRAM_CMDS > 0)
 250  6301 75 63            DW CMDS_V ; V
 251  6303               ELSE
 252  6303 ~            	DW 0
 253  6303               ENDIF
 254  6303 00 00            DW 0 ; W
 255  6305 00 00            DW 0 ; X
 256  6307 00 00            DW 0 ; Y
 257  6309 00 00            DW 0 ; Z
 258  630B
 259  630B              CMDS_M:
 260  630B               IF (VRAM_CMDS == 1)
 261  630B 4D 45 4D 56      DB "MEMVRM", 0
 261  630F 52 4D 00
 262  6312 33 5A            DW MEMVRM
 263  6314               ENDIF
 264  6314               IF (RAM_CMDS == 1)
 265  6314 4D 45 4D 43  	DB "MEMCPY", 0
 265  6318 50 59 00
 266  631B 46 58        	DW MEMCPY
 267  631D               ENDIF
 268  631D               IF (ANIM_CMDS == 1)
 269  631D 4D 41 58 41  	DB "MAXANIMITEMS",0
 269  6321 4E 49 4D 49
 269  6325 54 45 4D 53
 269  6329 00
 270  632A C2 4F        	DW MAXANIMITEMS
 271  632C 4D 41 58 41  	DB "MAXANIMDEFS",0
 271  6330 4E 49 4D 44
 271  6334 45 46 53 00
 272  6338 52 51        	DW MAXANIMDEFS
 273  633A 4D 41 58 41  	DB "MAXANIMSPRS",0
 273  633E 4E 49 4D 53
 273  6342 50 52 53 00
 274  6346 E8 51        	DW MAXANIMSPRS
 275  6348 4D 41 58 41     DB "MAXAUTOSGAMS",0
 275  634C 55 54 4F 53
 275  6350 47 41 4D 53
 275  6354 00
 276  6355 32 53           DW MAXAUTOSGAMS
 277  6357               ENDIF
 278  6357               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 279  6357 00           	DB 0
 280  6358               ENDIF
 281  6358              CMDS_F:
 282  6358               IF (VRAM_CMDS == 1)
 283  6358 46 49 4C 56      DB "FILVRM", 0
 283  635C 52 4D 00
 284  635F E4 59            DW FILVRM
 285  6361               ENDIF
 286  6361               IF (RAM_CMDS == 1)
 287  6361 46 49 4C 52      DB "FILRAM", 0
 287  6365 41 4D 00
 288  6368 AC 58            DW FILRAM
 289  636A               ENDIF
 290  636A               IF (VRAM_CMDS + RAM_CMDS > 0)
 291  636A 00               DB 0
 292  636B               ENDIF
 293  636B              CMDS_G:
 294  636B               IF (GENCAL_CMD == 1)
 295  636B 47 45 4E 43      DB "GENCAL", 0
 295  636F 41 4C 00
 296  6372 3E 5B            DW GENCAL
 297  6374               ENDIF
 298  6374               IF (GENCAL_CMD > 0)
 299  6374 00           	DB	0
 300  6375               ENDIF
 301  6375              CMDS_V:
 302  6375               IF (VRAM_CMDS == 1)
 303  6375 56 52 4D 4D  	DB "VRMMEM", 0
 303  6379 45 4D 00
 304  637C DC 5A        	DW VRMMEM
 305  637E               ENDIF
 306  637E               IF (VRAM_CMDS > 0)
 307  637E 00           	DB 0
 308  637F               ENDIF
 309  637F              CMDS_S:
 310  637F               IF (SPRITE_CMDS + ANIM_CMDS > 0)
 311  637F 53 47 41 4D      DB "SGAM",0
 311  6383 00
 312  6384 B1 56            DW SGAM
 313  6386               ENDIF
 314  6386               IF (SPRITE_CMDS == 1)
 315  6386 53 50 52 47  	DB "SPRGRPMOV", 0
 315  638A 52 50 4D 4F
 315  638E 56 00
 316  6390 FD 4E        	DW SPRGRPMOV
 317  6392               ENDIF
 318  6392               IF (SOUND_CMDS == 1)
 319  6392 53 4E 44 53  	DB "SNDSFX", 0
 319  6396 46 58 00
 320  6399 8A 59        	DW SNDSFX
 321  639B 53 4E 44 50  	DB "SNDPLYON", 0
 321  639F 4C 59 4F 4E
 321  63A3 00
 322  63A4 54 59        	DW SNDPLYON
 323  63A6 53 4E 44 50  	DB "SNDPLYOFF", 0
 323  63AA 4C 59 4F 46
 323  63AE 46 00
 324  63B0 67 59        	DW SNDPLYOFF
 325  63B2 53 4E 44 50  	DB "SNDPLYINI", 0
 325  63B6 4C 59 49 4E
 325  63BA 49 00
 326  63BC 0A 59        	DW SNDPLYINIT
 327  63BE               ENDIF
 328  63BE               IF (SPRITE_CMDS == 1)
 329  63BE 53 50 52 45  	DB "SPRENABLE", 0
 329  63C2 4E 41 42 4C
 329  63C6 45 00
 330  63C8 6E 4E        	DW SPRENABLE
 331  63CA 53 50 52 44  	DB "SPRDISABLE", 0
 331  63CE 49 53 41 42
 331  63D2 4C 45 00
 332  63D5 D5 4E        	DW SPRDISABLE
 333  63D7               ENDIF
 334  63D7               IF (SOUND_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 335  63D7 00           	DB 0
 336  63D8               ENDIF
 337  63D8              CMDS_B:
 338  63D8               IF (BLIT_CMDS == 1)
 339  63D8 42 4C 49 54  	DB "BLIT", 0
 339  63DC 00
 340  63DD 11 5E        	DW BLIT
 341  63DF               ENDIF
 342  63DF               IF (BOX_CMDS == 1)
 343  63DF 42 4F 58 4D  	DB "BOXMEMCPY", 0
 343  63E3 45 4D 43 50
 343  63E7 59 00
 344  63E9 CD 5B        	DW BOXMEMCPY
 345  63EB 42 4F 58 4D  	DB "BOXMEMVRM", 0
 345  63EF 45 4D 56 52
 345  63F3 4D 00
 346  63F5 63 5C        	DW BOXMEMVRM
 347  63F7               ENDIF
 348  63F7               IF (BLIT_CMDS + BOX_CMDS > 0)
 349  63F7 00           	DB 0
 350  63F8               ENDIF
 351  63F8              CMDS_T:
 352  63F8               IF (TILE_CMDS == 1)
 353  63F8 54 49 4C 45  	DB "TILERAM", 0
 353  63FC 52 41 4D 00
 354  6400 47 5F        	DW TILERAM
 355  6402 54 49 4C 45  	DB "TILEVRM", 0
 355  6406 56 52 4D 00
 356  640A 4B 60        	DW TILEVRM
 357  640C               ENDIF
 358  640C               IF (TILE_CMDS > 0)
 359  640C 00           	DB 0
 360  640D               ENDIF
 361  640D              CMDS_A:
 362  640D               IF (ANIM_CMDS == 1)
 363  640D 41 4E 49 4D     DB "ANIMSTEP",0
 363  6411 53 54 45 50
 363  6415 00
 364  6416 05 55           DW ANIMSTEP
 365  6418 41 4E 49 4D  	DB "ANIMSTART",0
 365  641C 53 54 41 52
 365  6420 54 00
 366  6422 0A 55        	DW ANIMSTART
 367  6424 41 4E 49 4D  	DB "ANIMSTOP",0
 367  6428 53 54 4F 50
 367  642C 00
 368  642D 0F 55        	DW ANIMSTOP
 369  642F 41 4E 49 4D  	DB "ANIMITEMPAT",0
 369  6433 49 54 45 4D
 369  6437 50 41 54 00
 370  643B 93 50        	DW ANIMITEMPAT
 371  643D 41 4E 49 4D  	DB "ANIMITEMPTR",0
 371  6441 49 54 45 4D
 371  6445 50 54 52 00
 372  6449 F9 50        	DW ANIMITEMPTR_CMD
 373  644B 41 4E 49 4D  	DB "ANIMDEF",0
 373  644F 44 45 46 00
 374  6453 95 51        	DW ANIMDEF
 375  6455 41 4E 49 4D  	DB "ANIMSPRITE",0
 375  6459 53 50 52 49
 375  645D 54 45 00
 376  6460 41 52        	DW ANIMSPRITE
 377  6462 41 4E 49 4D     DB "ANIMCHAR",0
 377  6466 43 48 41 52
 377  646A 00
 378  646B B9 52           DW ANIMCHAR
 379  646D 41 55 54 4F     DB "AUTOSGAMDEF",0
 379  6471 53 47 41 4D
 379  6475 44 45 46 00
 380  6479 8F 53           DW AUTOSGAMDEF
 381  647B 41 55 54 4F     DB "AUTOSGAMSTART",0
 381  647F 53 47 41 4D
 381  6483 53 54 41 52
 381  6487 54 00
 382  6489 C6 54           DW AUTOSGAMSTART
 383  648B 41 55 54 4F     DB "AUTOSGAMSTOP",0
 383  648F 53 47 41 4D
 383  6493 53 54 4F 50
 383  6497 00
 384  6498 02 55           DW AUTOSGAMSTOP
 385  649A 00           	DB 0
 386  649B               ENDIF
 387  649B              CMDS_C:
 388  649B               IF (COLL_CMD == 1)
 389  649B 43 4F 4C 4C      DB "COLL", 0
 389  649F 00
 390  64A0 18 62            DW COLL
 391  64A2               ENDIF
 392  64A2               IF (COLL_CMD > 0)
 393  64A2 00           	DB	0
 394  64A3               ENDIF
 395  64A3
 396  64A3               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 397  64A3              ; ****************************************************************************************************
 398  64A3              ; function sets VRAM address
 399  64A3              ; input HL=address
 400  64A3              ; modifies AF
 401  64A3              SETWRT_LOCAL:
 402  64A3 7D           	LD	A, L
 403  64A4 D3 99        	OUT	(099H), A
 404  64A6 7C           	LD	A, H
 405  64A7 E6 3F        	AND	03FH
 406  64A9 F6 40        	OR	040H
 407  64AB D3 99        	OUT	(099H), A
 408  64AD C9           	RET
 409  64AE              ; ****************************************************************************************************
 410  64AE               ENDIF
 411  64AE
 412  64AE               IF (VRAM_CMDS + TILE_CMDS > 0)
 413  64AE              ; ****************************************************************************************************
 414  64AE              ; function copies data from RAM to VRAM
 415  64AE              ; input HL=address in RAM
 416  64AE              ; input B=count
 417  64AE              ; modifies AF, BC, HL
 418  64AE              BBYTECOPY:
 419  64AE 0E 98        	LD C,#98
 420  64B0              BBYTECOPY_NO_C:
 421  64B0 ED A3        	OUTI
 422  64B2 C2 B0 64     	JP	NZ, BBYTECOPY_NO_C
 423  64B5 C9           	RET
 424  64B6              ; ****************************************************************************************************
 425  64B6               ENDIF
 426  64B6
 427  64B6              ; ****************************************************************************************************
 428  64B6              ; function multiplies HL by 32
 429  64B6              HLx32:
 430  64B6 29           	ADD HL,HL
 431  64B7              ; ****************************************************************************************************
 432  64B7              ; function multiplies HL by 16
 433  64B7              HLx16:
 434  64B7 29           	ADD HL,HL
 435  64B8              ; ****************************************************************************************************
 436  64B8              ; function multiplies HL by 8
 437  64B8              HLx8:
 438  64B8 29          > ADD HL, HL
 438  64B9 29          > ADD HL, HL
 438  64BA 29          > ADD HL, HL
 439  64BB C9           	RET
 440  64BC              ; ****************************************************************************************************
 441  64BC
 442  64BC              ; ****************************************************************************************************
 443  64BC              ; function gets slot and subslot data for specific page
 444  64BC              ; input A=page (0, 1 or 2)
 445  64BC              ; output B = 0A8H register value
 446  64BC              ; output D = 0 is no subslots, 1 if yes
 447  64BC              ; output C = 0A8H value when page 3 slot equals to requested page slot
 448  64BC              ; output E = subslot value if present
 449  64BC              ; modifies AF, BC, DE, HL
 450  64BC              GET_PAGE_INFO:
 451  64BC 6F               LD L, A
 452  64BD C6 C1            ADD A, low (EXPTBL)
 453  64BF 32 C9 64         LD (GET_PAGE_INFO_L1+1), A
 454  64C2 DB A8            IN A, (0A8H)
 455  64C4 47               LD B, A
 456  64C5 E6 3F            AND 03FH
 457  64C7 4F               LD C, A
 458  64C8              GET_PAGE_INFO_L1:
 459  64C8 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 460  64CB E6 80            AND 080H
 461  64CD 28 1B            JR Z, GET_PAGE_INFO_L2
 462  64CF                  ; expanded
 463  64CF 2D               DEC L
 464  64D0 FA EF 64         JP M, GET_PAGE_INFO_L3
 465  64D3 2D               DEC L
 466  64D4 FA ED 64         JP M, GET_PAGE_INFO_L4
 467  64D7                  ; page 2
 468  64D7 07               RLCA
 469  64D8 07               RLCA
 470  64D9              GET_PAGE_INFO_L5:
 471  64D9 E6 C0            AND 0C0H
 472  64DB B1               OR C
 473  64DC D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 474  64DE 4F               LD C, A
 475  64DF 3A FF FF         LD A, (0FFFFH)
 476  64E2 2F               CPL
 477  64E3 5F               LD E, A
 478  64E4 16 01            LD D, 1
 479  64E6 78               LD A, B ; return stack
 480  64E7 D3 A8            OUT (0A8H), A
 481  64E9 C9               RET
 482  64EA              GET_PAGE_INFO_L2:
 483  64EA                  ; not expanded
 484  64EA 16 00            LD D, 0
 485  64EC C9               RET
 486  64ED              GET_PAGE_INFO_L4:
 487  64ED                  ; page 1
 488  64ED 0F               RRCA
 489  64EE 0F               RRCA
 490  64EF              GET_PAGE_INFO_L3:
 491  64EF                  ; page 0
 492  64EF 0F               RRCA
 493  64F0 0F               RRCA
 494  64F1 18 E6            JR GET_PAGE_INFO_L5
 495  64F3              ; ****************************************************************************************************
 496  64F3
 497  64F3              ; ****************************************************************************************************
 498  64F3              ; function returns original slot and subslot info
 499  64F3              ; input B = 0A8H register value
 500  64F3              ; input D = 0 is no subslots, 1 if yes
 501  64F3              ; input C = 0A8H value when page 3 slot equals to requested page slot
 502  64F3              ; input E = subslot value if present
 503  64F3              ; modifies AF, disables interrupts
 504  64F3              RESTORE_PAGE_INFO:
 505  64F3 7A              LD A, D
 506  64F4 B7              OR A
 507  64F5 28 08           JR Z, RESTORE_PAGE_INFO_L1
 508  64F7 79              LD A, C
 509  64F8 F3           	DI
 510  64F9 D3 A8           OUT (0A8H), A
 511  64FB 7B              LD A, E
 512  64FC 32 FF FF        LD (0FFFFH), A
 513  64FF              RESTORE_PAGE_INFO_L1:
 514  64FF 78              LD A, B
 515  6500 D3 A8           OUT (0A8H), A
 516  6502              NOACTION_DEFUSR: ; just a safe RET for use when DEFUSR table has an empty entry
 517  6502 C9              RET
 518  6503              ; ****************************************************************************************************
 519  6503
 520  6503              ; *******************************************************************************************************
 521  6503              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 522  6503              ; INPUT:  A = SLOT ID: EXXXSSPP
 523  6503              ; E = EXPANDED FLAG
 524  6503              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 525  6503              ; PP = PRIMARY SLOT NUMBER
 526  6503              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 527  6503              ; CHANGES: AF, BC, DE
 528  6503
 529  6503              LOCAL_ENASLT:
 530  6503 CD 23 65         CALL L0353
 531  6506 FA 10 65         JP M, L0340
 532  6509 DB A8            IN A, (0A8H)
 533  650B A1               AND C
 534  650C B0               OR B
 535  650D D3 A8            OUT (0A8H), A
 536  650F C9               RET
 537  6510              L0340:
 538  6510 E5               PUSH HL
 539  6511 CD 48 65         CALL L0378
 540  6514 4F               LD C, A
 541  6515 06 00            LD B, 0
 542  6517 7D               LD A, L
 543  6518 A4               AND H
 544  6519 B2               OR D
 545  651A 21 C5 FC         LD HL, 0FCC5H
 546  651D 09               ADD HL, BC
 547  651E 77               LD (HL), A
 548  651F E1               POP HL
 549  6520 79               LD A, C
 550  6521 18 E0            JR LOCAL_ENASLT
 551  6523              L0353:
 552  6523 F3               DI
 553  6524 F5               PUSH AF
 554  6525 7C               LD A, H
 555  6526 07               RLCA
 556  6527 07               RLCA
 557  6528 E6 03            AND 3
 558  652A 5F               LD E, A
 559  652B 3E C0            LD A, 0C0H
 560  652D              L035D:
 561  652D 07               RLCA
 562  652E 07               RLCA
 563  652F 1D               DEC E
 564  6530 F2 2D 65         JP P, L035D
 565  6533 5F               LD E, A
 566  6534 2F               CPL
 567  6535 4F               LD C, A
 568  6536 F1               POP AF
 569  6537 F5               PUSH AF
 570  6538 E6 03            AND 3
 571  653A 3C               INC A
 572  653B 47               LD B, A
 573  653C 3E AB            LD A, 0ABH
 574  653E              L036E:
 575  653E C6 55            ADD A, 055H
 576  6540 10 FC            DJNZ L036E
 577  6542 57               LD D, A
 578  6543 A3               AND E
 579  6544 47               LD B, A
 580  6545 F1               POP AF
 581  6546 A7               AND A
 582  6547 C9               RET
 583  6548              L0378:
 584  6548 F5               PUSH AF
 585  6549 7A               LD A, D
 586  654A E6 C0            AND 0C0H
 587  654C 4F               LD C, A
 588  654D F1               POP AF
 589  654E F5               PUSH AF
 590  654F 57               LD D, A
 591  6550 DB A8            IN A, (0A8H)
 592  6552 47               LD B, A
 593  6553 E6 3F            AND 03FH
 594  6555 B1               OR C
 595  6556 D3 A8            OUT (0A8H), A
 596  6558 7A               LD A, D
 597  6559 0F               RRCA
 598  655A 0F               RRCA
 599  655B E6 03            AND 3
 600  655D 57               LD D, A
 601  655E 3E AB            LD A, 0ABH
 602  6560              L0390:
 603  6560 C6 55            ADD A, 055H
 604  6562 15               DEC D
 605  6563 F2 60 65         JP P, L0390
 606  6566 A3               AND E
 607  6567 57               LD D, A
 608  6568 7B               LD A, E
 609  6569 2F               CPL
 610  656A 67               LD H, A
 611  656B 3A FF FF         LD A, (0FFFFH)
 612  656E 2F               CPL
 613  656F 6F               LD L, A
 614  6570 A4               AND H
 615  6571 B2               OR D
 616  6572 32 FF FF         LD (0FFFFH), A
 617  6575 78               LD A, B
 618  6576 D3 A8            OUT (0A8H), A
 619  6578 F1               POP AF
 620  6579 E6 03            AND 3
 621  657B C9               RET
 622  657C              ; *******************************************************************************************************
 623  657C
 624  657C              ; *******************************************************************************************************
 625  657C              ; some common code to activate page 0 and place values needed to restore original page on stack
 626  657C              ; input IY=return address
 627  657C              ENABLE_PAGE0:
 628  657C AF              XOR A
 629  657D CD BC 64        CALL GET_PAGE_INFO
 630  6580 C5              PUSH BC
 631  6581 D5              PUSH DE
 632  6582 3A 41 F3        LD A, (RAMAD0)
 633  6585 26 00           LD H, 0
 634  6587 CD 03 65        CALL LOCAL_ENASLT
 635  658A FD E9        	JP (IY)
 636  658C              ; *******************************************************************************************************
 637  658C
 638  658C              ; General BASIC CALL-instruction handler
 639  658C              CALLHAND:
 640  658C FB              EI
 641  658D E5           	PUSH HL
 642  658E 21 D7 62     	LD	HL, CMDS ; pointer table based on starting letter
 643  6591 3A 89 FD        LD A, (PROCNM)
 644  6594 D6 41           SUB 'A'
 645  6596 87              ADD A, A
 646  6597 16 00           LD D, 0
 647  6599 5F              LD E, A
 648  659A 19              ADD HL, DE
 649  659B 5E              LD E, (HL)
 650  659C 23              INC HL
 651  659D 56              LD D, (HL)
 652  659E 7A              LD A, D
 653  659F B3              OR E
 654  65A0 28 23           JR Z, .CMDNOTRECOGNIZED
 655  65A2 EB              EX DE, HL
 656  65A3              .CHKCMD:
 657  65A3 11 89 FD     	LD	DE, PROCNM
 658  65A6              .LOOP:
 659  65A6 1A              LD	A,(DE)
 660  65A7 BE           	CP	(HL)
 661  65A8 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 662  65AA 13           	INC	DE
 663  65AB 23           	INC	HL
 664  65AC A7           	AND	A
 665  65AD 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 666  65AF 5E           	LD	E,(HL)
 667  65B0 23           	INC	HL
 668  65B1 56           	LD	D,(HL)
 669  65B2 E1           	POP	HL		; routine address
 670  65B3 CD D4 65     	CALL	GETPREVCHAR
 671  65B6 CD C8 65     	CALL	.CALLDE		; Call routine
 672  65B9 A7           	AND	A
 673  65BA C9           	RET
 674  65BB
 675  65BB              .TONEXTCMD:
 676  65BB 0E FF        	LD	C,0FFH
 677  65BD AF           	XOR	A
 678  65BE ED B1        	CPIR			; Skip to end of instruction name
 679  65C0 23           	INC	HL
 680  65C1 23           	INC	HL		; Skip address
 681  65C2 BE           	CP	(HL)
 682  65C3 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 683  65C5              .CMDNOTRECOGNIZED:
 684  65C5 E1           	POP	HL
 685  65C6 37              SCF
 686  65C7 C9           	RET
 687  65C8
 688  65C8              .CALLDE:
 689  65C8 D5           	PUSH	DE
 690  65C9 C9           	RET
 691  65CA
 692  65CA              ;---------------------------
 693  65CA
 694  65CA              ;GETSTRPNT:
 695  65CA              ; OUT:
 696  65CA              ; HL = String Address
 697  65CA              ; B  = Lenght
 698  65CA              ;        LD      HL,(USR)
 699  65CA              ;        LD      B,(HL)
 700  65CA              ;        INC     HL
 701  65CA              ;        LD      E,(HL)
 702  65CA              ;        INC     HL
 703  65CA              ;        LD      D,(HL)
 704  65CA              ;        EX      DE,HL
 705  65CA              ;        RET
 706  65CA
 707  65CA              ;EVALTXTPARAM:
 708  65CA              ;	CALL	CHKCHAR
 709  65CA              ;	DEFB	"("             ; Check for (
 710  65CA              ;	LD	IX,FRMEVL
 711  65CA              ;	CALL	CALBAS		; Evaluate expression
 712  65CA              ;       LD      A,(VALTYP)
 713  65CA              ;        CP      3               ; Text type?
 714  65CA              ;        JP      NZ,TYPE_MISMATCH
 715  65CA              ;        PUSH	HL
 716  65CA              ;        LD	IX,FRESTR         ; Free the temporary string
 717  65CA              ;        CALL	CALBAS
 718  65CA              ;        POP	HL
 719  65CA              ;	CALL	CHKCHAR
 720  65CA              ;	DEFB	")"             ; Check for )
 721  65CA              ;        RET
 722  65CA
 723  65CA
 724  65CA              CHKCHAR:
 725  65CA CD D4 65     	CALL	GETPREVCHAR	; Get previous basic char
 726  65CD E3           	EX	(SP),HL
 727  65CE BE           	CP	(HL) 	        ; Check if good char
 728  65CF 20 1D        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 729  65D1 23           	INC	HL
 730  65D2 E3           	EX	(SP),HL
 731  65D3 23           	INC	HL		; Get next basic char
 732  65D4
 733  65D4              GETPREVCHAR:
 734  65D4 2B           	DEC HL
 735  65D5 DD 21 66 46  	LD	IX,CHRGTR
 736  65D9 CD 59 01     	CALL CALBAS
 737  65DC FB              EI
 738  65DD C9              RET
 739  65DE
 740  65DE
 741  65DE              TYPE_MISMATCH:
 742  65DE 1E 0D            LD E, 13 ; Type mismatch
 743  65E0 18 0E            JR THROW_ERROR
 744  65E2              SUBSCRIPT_OUT_OF_RANGE:
 745  65E2 1E 09            LD E,9 ; subscript out of range
 746  65E4 18 0A        	JR THROW_ERROR
 747  65E6              OVERFLOW:
 748  65E6 1E 06        	LD E,6
 749  65E8 18 06        	JR THROW_ERROR
 750  65EA              ILLEGAL_FUNCTION:
 751  65EA 1E 05            LD E, 5 ; illegal function call
 752  65EC 18 02            JR THROW_ERROR
 753  65EE              SYNTAX_ERROR:
 754  65EE 1E 02            LD E, 2 ; Syntax error
 755  65F0              THROW_ERROR:
 756  65F0 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 757  65F4 C3 59 01     	JP	CALBAS
 758  65F7
 759  65F7              ;---------------------------
 760  65F7
 761  65F7              ; *******************************************************************************************************
 762  65F7              ; helper function to get pointer to BASIC array data
 763  65F7              ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
 764  65F7              ; input B=dimensions (1 or 2)
 765  65F7              ; input D=minimal first dimension
 766  65F7              ; input E=minimal second dimension, if applicable
 767  65F7              ; returns BC=pointer to first data element
 768  65F7              ; throws BASIC error if invalid type
 769  65F7              GET_BASIC_ARRAY_DATA_POINTER:
 770  65F7 D5           	PUSH DE
 771  65F8 C5           	PUSH BC
 772  65F9 F5           	PUSH AF
 773  65FA 3E 01           LD A,1
 774  65FC 32 A5 F6        LD (SUBFLG),A ; search for arrays only
 775  65FF DD 21 A4 5E  	LD IX, PTRGET
 776  6603 CD 59 01     	CALL CALBAS
 777  6606 AF              XOR A
 778  6607 32 A5 F6        LD (SUBFLG),A ; if not reset will cause syntax errors
 779  660A 3A 63 F6     	LD A,(VALTYP)
 780  660D D1           	POP DE ; required type
 781  660E BA           	CP D
 782  660F C2 DE 65     	JP NZ,TYPE_MISMATCH
 783  6612 0A           	LD A,(BC)
 784  6613 03           	INC BC
 785  6614 D1           	POP DE ; required number of dimensions
 786  6615 BA           	CP D
 787  6616 C2 DE 65     	JP NZ,TYPE_MISMATCH
 788  6619 D1           	POP DE ; required minimal array dimensions
 789  661A 3D           	DEC A
 790  661B 28 07        	JR Z,.ONE_DIMENSION
 791  661D              	; 2-dimension array
 792  661D 0A           	LD A,(BC)
 793  661E 03          > INC BC
 793  661F 03          > INC BC
 794  6620 BB           	CP E
 795  6621 DA E2 65     	JP C,SUBSCRIPT_OUT_OF_RANGE
 796  6624              .ONE_DIMENSION:
 797  6624 0A           	LD A,(BC)
 798  6625 03          > INC BC
 798  6626 03          > INC BC
 799  6627 BA           	CP D
 800  6628 DA E2 65     	JP C,SUBSCRIPT_OUT_OF_RANGE
 801  662B C9           	RET
 802  662C              ; *******************************************************************************************************
 803  662C
 804  662C              EXT_END:
 805  662C
# file closed: asm\main.asm
