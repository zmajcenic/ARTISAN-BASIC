# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		   EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000              COLL_CMD       EQU 1
  14  4000
  15  4000              BASIC_EXTENSION   EQU 0
  16  4000              DEFUSR_EXTENSION  EQU 1
  17  4000
  18  4000              CHPUT   EQU    #A2
  19  4000              CALBAS  EQU		#159
  20  4000              ERRHAND EQU    #406F
  21  4000              FRMEVL  EQU    #4C64
  22  4000              FRESTR  EQU		#67D0
  23  4000              ; FRMQNT = formula quantificator
  24  4000              ; input HL=pointer to current program expression
  25  4000              ; output HL=next address
  26  4000              ; output DE=integer datum
  27  4000              FRMQNT	EQU		#542F
  28  4000              ; GETBYT = get byte parameter
  29  4000              ; input HL=pointer to current program expression
  30  4000              ; output HL=next address
  31  4000              ; output A=E=byte read
  32  4000              GETBYT		EQU	#521C
  33  4000              CHRGTR  	   EQU   #4666
  34  4000              PTRGET		EQU 	#5EA4
  35  4000              SUBFLG		EQU	#F6A5
  36  4000              SYNCHR		EQU	#558C
  37  4000              VALTYP  	   EQU   #F663
  38  4000              DAC         EQU   #F7F6
  39  4000              USR     	   EQU   #F7F8
  40  4000              PROCNM		EQU	#FD89
  41  4000              BIOS_FILVRM EQU   #0056
  42  4000              CLIKSW		EQU	#F3DB
  43  4000
  44  4000              RAMAD0	   EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  45  4000              RAMAD1	   EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  46  4000              RAMAD2	   EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  47  4000              RAMAD3	   EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  48  4000              EXPTBL	   EQU   #FCC1
  49  4000              SCRMOD	   EQU   #FCAF ; current screen mode
  50  4000              REG1SAV     EQU   #F3E0 ; VDP(1)
  51  4000              JIFFY	      EQU   #FC9E
  52  4000              GRPPAT	   EQU   #F3CF ; SCREEN 2 sprite generator table address
  53  4000              GRPCGP		EQU	#F3CB ; SCREEN 2 pattern generator table address
  54  4000              GRPATR      EQU   #F3CD ; SCREEN 2 sprite attribute table address
  55  4000              T32PAT	   EQU   #F3C5 ; SCREEN 1 sprite generator table address
  56  4000              T32CGP      EQU   #F3C1 ; SCREEN 1 pattern ganarator table address
  57  4000              T32ATR      EQU   #F3C3 ; SCREEN 1 sprite attribute table address
  58  4000
  59  4000              ; BASIC error codes
  60  4000              ;01 NEXT without FOR
  61  4000              ;02 Syntax error
  62  4000              ;03 RETURN without GOSUB
  63  4000              ;04 Out of DATA
  64  4000              ;05 Illegal function call
  65  4000              ;06 Overflow
  66  4000              ;07 Out of memory
  67  4000              ;08 Undefined line number
  68  4000              ;09 Subscript out of range
  69  4000              ;10 Redimensioned array
  70  4000              ;11 Division by zero
  71  4000              ;12 Illegal direct
  72  4000              ;13 Type mismatch
  73  4000              ;14 Out of string space
  74  4000              ;15 String too long
  75  4000              ;16 String formula too complex
  76  4000              ;17 Can't CONTINUE
  77  4000              ;18 Undefined user function
  78  4000              ;19 Device I/O error
  79  4000              ;20 Verify error
  80  4000              ;21 No RESUME
  81  4000              ;22 RESUME without error
  82  4000              ;23 Unprintable error
  83  4000              ;24 Missing operand
  84  4000              ;25 Line buffer overflow
  85  4000              ;50 FIELD overflow
  86  4000              ;51 Internal error
  87  4000              ;52 Bad file number
  88  4000              ;53 File not found
  89  4000              ;54 File already open
  90  4000              ;55 Input past end
  91  4000              ;56 Bad file name
  92  4000              ;57 Direct statement in file
  93  4000              ;58 Sequential I/O only
  94  4000              ;59 File not OPEN
  95  4000
  96  4000
  97  4000               ; simulate cartridge with BASIC extension
  98  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  98  4004 42 5E 00 00
  98  4008 00 00 00 00
  98  400C 00 00 00 00
  99  4010
 100  4010              ; this location #4010 stores last location used by basic extension
 101  4010              ; free memory after that point
 102  4010              FREEMEMPTR:
 103  4010 EE 5E         DW EXT_END
 104  4012
 105  4012              ; this location #4012 stores extension version in DAA format
 106  4012              ; first byte is major version and second minor
 107  4012              VERSION:
 108  4012 00 81         DB #00, #81
 109  4014
 110  4014              ; this location #4014 contains a jump to entry point for DEFUSR approach
 111  4014              ; if excluded it contains 3xRET so that sound player can be at aspecific spot
 112  4014               IF (DEFUSR_EXTENSION == 1)
 113  4014 C3 E9 5C        JP DEFUSR_ENTRY
 114  4017               ELSE
 115  4017 ~               .3 RET
 116  4017               ENDIF
 117  4017
 118  4017              ; binary included AKG player compiled at #4017
 119  4017               IF (SOUND_CMDS == 1)
 120  4017              	INCBIN "bin/AKG.bin"
 121  4CF3              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF3              MAIN_PLAYER_START EQU 04017H
   2+ 4CF3              PLY_AKG_START EQU 04017H
   3+ 4CF3              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 04020H
   4+ 4CF3              PLY_AKG_INITSOUNDEFFECTS EQU 04020H
   5+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04024H
   6+ 4CF3              PLY_AKG_PLAYSOUNDEFFECT EQU 04024H
   7+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04025H
   8+ 4CF3              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04025H
   9+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 0404CH
  10+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 0404CH
  11+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 0405AH
  12+ 4CF3              PLY_AKG_PSES_PLAY EQU 04093H
  13+ 4CF3              PLY_AKG_PSES_READFIRSTBYTE EQU 0409CH
  14+ 4CF3              PLY_AKG_PSES_S_ENDORLOOP EQU 040B4H
  15+ 4CF3              PLY_AKG_PSES_S_LOOP EQU 040BFH
  16+ 4CF3              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C5H
  17+ 4CF3              PLY_AKG_PSES_NOTREACHED EQU 040D8H
  18+ 4CF3              PLY_AKG_PSES_HARDWAREONLY EQU 040DCH
  19+ 4CF3              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E3H
  20+ 4CF3              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F5H
  21+ 4CF3              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FFH
  22+ 4CF3              PLY_AKG_PSES_H_AFTERRETRIG EQU 04109H
  23+ 4CF3              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411DH
  24+ 4CF3              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 04122H
  25+ 4CF3              PLY_AKG_PSES_READHARDWAREPERIOD EQU 0412AH
  26+ 4CF3              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04135H
  27+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 04141H
  28+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04143H
  29+ 4CF3              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04149H
  30+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414DH
  31+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414DH
  32+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414FH
  33+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414FH
  34+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414FH
  35+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 04150H
  36+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 04151H
  37+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04155H
  38+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04155H
  39+ 4CF3              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04155H
  40+ 4CF3              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415DH
  41+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04165H
  42+ 4CF3              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04165H
  43+ 4CF3              PLY_AKG_INIT EQU 04165H
  44+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04165H
  45+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04193H
  46+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A7H
  47+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B9H
  48+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D8H
  49+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E5H
  50+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL EQU 041EBH
  51+ 4CF3              PLY_AKG_INITTABLE0 EQU 041EEH
  52+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EEH
  53+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04208H
  54+ 4CF3              PLY_AKG_INITTABLE0_END EQU 04208H
  55+ 4CF3              PLY_AKG_INITTABLE1 EQU 04208H
  56+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04208H
  57+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 0420CH
  58+ 4CF3              PLY_AKG_INITTABLE1_END EQU 0420CH
  59+ 4CF3              PLY_AKG_INITTABLEORA EQU 0420CH
  60+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 0420CH
  61+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04224H
  62+ 4CF3              PLY_AKG_INITTABLEORA_END EQU 04224H
  63+ 4CF3              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04224H
  64+ 4CF3              PLY_AKG_STOP EQU 04224H
  65+ 4CF3              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04236H
  66+ 4CF3              PLY_AKG_PLAY EQU 04236H
  67+ 4CF3              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423EH
  68+ 4CF3              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04244H
  69+ 4CF3              PLY_AKG_READLINKER EQU 04249H
  70+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04249H
  71+ 4CF3              PLY_AKG_READLINKER_PTLINKER EQU 04249H
  72+ 4CF3              PLY_AKG_READLINKER_NOLOOP EQU 04254H
  73+ 4CF3              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428DH
  74+ 4CF3              PLY_AKG_READLINE EQU 04290H
  75+ 4CF3              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 04290H
  76+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04296H
  77+ 4CF3              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04296H
  78+ 4CF3              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A3H
  79+ 4CF3              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A7H
  80+ 4CF3              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042AAH
  81+ 4CF3              PLY_AKG_SPEEDTRACK_END EQU 042ADH
  82+ 4CF3              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042ADH
  83+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B3H
  84+ 4CF3              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B3H
  85+ 4CF3              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042C0H
  86+ 4CF3              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C4H
  87+ 4CF3              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C7H
  88+ 4CF3              PLY_AKG_EVENTTRACK_END EQU 042CAH
  89+ 4CF3              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042CAH
  90+ 4CF3              PLY_AKG_CHANNEL1_READTRACK EQU 042D6H
  91+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D6H
  92+ 4CF3              PLY_AKG_CHANNEL1_PTTRACK EQU 042D6H
  93+ 4CF3              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042F1H
  94+ 4CF3              PLY_AKG_CHANNEL1_WAIT EQU 042FCH
  95+ 4CF3              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04303H
  96+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04303H
  97+ 4CF3              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04303H
  98+ 4CF3              PLY_AKG_CHANNEL1_NOTE EQU 0430CH
  99+ 4CF3              PLY_AKG_BASENOTEINDEX EQU 0430CH
 100+ 4CF3              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430EH
 101+ 4CF3              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430EH
 102+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431EH
 103+ 4CF3              PLY_AKG_INSTRUMENTSTABLE EQU 0431EH
 104+ 4CF3              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 04330H
 105+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 04340H
 106+ 4CF3              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04368H
 107+ 4CF3              PLY_AKG_CHANNEL1_READCELLEND EQU 0436BH
 108+ 4CF3              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 0436BH
 109+ 4CF3              PLY_AKG_CHANNEL2_READTRACK EQU 04377H
 110+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04377H
 111+ 4CF3              PLY_AKG_CHANNEL2_PTTRACK EQU 04377H
 112+ 4CF3              PLY_AKG_CHANNEL2_SMALLWAIT EQU 04392H
 113+ 4CF3              PLY_AKG_CHANNEL2_WAIT EQU 0439DH
 114+ 4CF3              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A4H
 115+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A4H
 116+ 4CF3              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A4H
 117+ 4CF3              PLY_AKG_CHANNEL2_NOTE EQU 043ADH
 118+ 4CF3              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043B2H
 119+ 4CF3              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043B2H
 120+ 4CF3              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D4H
 121+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E4H
 122+ 4CF3              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 0440CH
 123+ 4CF3              PLY_AKG_CHANNEL2_READCELLEND EQU 0440FH
 124+ 4CF3              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440FH
 125+ 4CF3              PLY_AKG_CHANNEL3_READTRACK EQU 0441BH
 126+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 0441BH
 127+ 4CF3              PLY_AKG_CHANNEL3_PTTRACK EQU 0441BH
 128+ 4CF3              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04436H
 129+ 4CF3              PLY_AKG_CHANNEL3_WAIT EQU 04441H
 130+ 4CF3              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04448H
 131+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04448H
 132+ 4CF3              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04448H
 133+ 4CF3              PLY_AKG_CHANNEL3_NOTE EQU 04451H
 134+ 4CF3              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04456H
 135+ 4CF3              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04456H
 136+ 4CF3              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04478H
 137+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04488H
 138+ 4CF3              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044B0H
 139+ 4CF3              PLY_AKG_CHANNEL3_READCELLEND EQU 044B3H
 140+ 4CF3              PLY_AKG_CURRENTSPEED EQU 044B3H
 141+ 4CF3              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B5H
 142+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B8H
 143+ 4CF3              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B8H
 144+ 4CF3              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044BBH
 145+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BEH
 146+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BEH
 147+ 4CF3              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044CAH
 148+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044D1H
 149+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D4H
 150+ 4CF3              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044DAH
 151+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DDH
 152+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DDH
 153+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044EBH
 154+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044F0H
 155+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044FBH
 156+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FEH
 157+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FEH
 158+ 4CF3              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 04501H
 159+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04504H
 160+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04504H
 161+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450DH
 162+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04517H
 163+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 0451AH
 164+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 0451AH
 165+ 4CF3              PLY_AKG_CHANNEL1_PITCH EQU 0451AH
 166+ 4CF3              PLY_AKG_CHANNEL1_ISPITCH EQU 0451DH
 167+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 04522H
 168+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACK EQU 04522H
 169+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04526H
 170+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04528H
 171+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 0452AH
 172+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 04531H
 173+ 4CF3              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 04532H
 174+ 4CF3              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04535H
 175+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04535H
 176+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 04551H
 177+ 4CF3              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 04551H
 178+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455EH
 179+ 4CF3              PLY_AKG_CHANNEL1_GLIDEOVER EQU 04562H
 180+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 04572H
 181+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 04572H
 182+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04573H
 183+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04574H
 184+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04576H
 185+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04576H
 186+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04576H
 187+ 4CF3              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04577H
 188+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04578H
 189+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 0457AH
 190+ 4CF3              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 0457AH
 191+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 0457AH
 192+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 0457AH
 193+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 0457AH
 194+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457DH
 195+ 4CF3              PLY_AKG_CHANNEL1_PITCH_END EQU 0457FH
 196+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04587H
 197+ 4CF3              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04587H
 198+ 4CF3              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 0458AH
 199+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458DH
 200+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458DH
 201+ 4CF3              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04599H
 202+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 045A0H
 203+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A3H
 204+ 4CF3              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A9H
 205+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045ACH
 206+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045ACH
 207+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045BAH
 208+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BFH
 209+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045CAH
 210+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CDH
 211+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CDH
 212+ 4CF3              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045D0H
 213+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D3H
 214+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D3H
 215+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045DCH
 216+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E6H
 217+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E9H
 218+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E9H
 219+ 4CF3              PLY_AKG_CHANNEL2_PITCH EQU 045E9H
 220+ 4CF3              PLY_AKG_CHANNEL2_ISPITCH EQU 045ECH
 221+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045F1H
 222+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045F1H
 223+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F5H
 224+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F7H
 225+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F9H
 226+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 04600H
 227+ 4CF3              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 04601H
 228+ 4CF3              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04604H
 229+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04604H
 230+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 04620H
 231+ 4CF3              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 04620H
 232+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462DH
 233+ 4CF3              PLY_AKG_CHANNEL2_GLIDEOVER EQU 04631H
 234+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 04641H
 235+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 04641H
 236+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 04642H
 237+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04643H
 238+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04645H
 239+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04645H
 240+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04645H
 241+ 4CF3              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04646H
 242+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04647H
 243+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04649H
 244+ 4CF3              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04649H
 245+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04649H
 246+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04649H
 247+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04649H
 248+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_END EQU 0464CH
 249+ 4CF3              PLY_AKG_CHANNEL2_PITCH_END EQU 0464EH
 250+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04656H
 251+ 4CF3              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04656H
 252+ 4CF3              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04659H
 253+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 0465CH
 254+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 0465CH
 255+ 4CF3              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04668H
 256+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466FH
 257+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 04672H
 258+ 4CF3              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04678H
 259+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 0467BH
 260+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 0467BH
 261+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04689H
 262+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468EH
 263+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04699H
 264+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 0469CH
 265+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 0469CH
 266+ 4CF3              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469FH
 267+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 046A2H
 268+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE EQU 046A2H
 269+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046ABH
 270+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B5H
 271+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B8H
 272+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B8H
 273+ 4CF3              PLY_AKG_CHANNEL3_PITCH EQU 046B8H
 274+ 4CF3              PLY_AKG_CHANNEL3_ISPITCH EQU 046BBH
 275+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046C0H
 276+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046C0H
 277+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C4H
 278+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C6H
 279+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C8H
 280+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CFH
 281+ 4CF3              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046D0H
 282+ 4CF3              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D3H
 283+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D3H
 284+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046EFH
 285+ 4CF3              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046EFH
 286+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046FCH
 287+ 4CF3              PLY_AKG_CHANNEL3_GLIDEOVER EQU 04700H
 288+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 04710H
 289+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 04710H
 290+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 04711H
 291+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 04712H
 292+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04714H
 293+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04714H
 294+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04714H
 295+ 4CF3              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04715H
 296+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04716H
 297+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04718H
 298+ 4CF3              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04718H
 299+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04718H
 300+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04718H
 301+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04718H
 302+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_END EQU 0471BH
 303+ 4CF3              PLY_AKG_CHANNEL3_PITCH_END EQU 0471DH
 304+ 4CF3              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04729H
 305+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04729H
 306+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04729H
 307+ 4CF3              PLY_AKG_CHANNEL1_TRACKNOTE EQU 0472CH
 308+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472EH
 309+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04734H
 310+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04737H
 311+ 4CF3              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04737H
 312+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 0473AH
 313+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04743H
 314+ 4CF3              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 0474BH
 315+ 4CF3              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04758H
 316+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04758H
 317+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04758H
 318+ 4CF3              PLY_AKG_CHANNEL2_TRACKNOTE EQU 0475BH
 319+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475DH
 320+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04763H
 321+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04766H
 322+ 4CF3              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04766H
 323+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04769H
 324+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 04772H
 325+ 4CF3              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 0477AH
 326+ 4CF3              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04788H
 327+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04788H
 328+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04788H
 329+ 4CF3              PLY_AKG_CHANNEL3_TRACKNOTE EQU 0478BH
 330+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478DH
 331+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04793H
 332+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04796H
 333+ 4CF3              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04796H
 334+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04799H
 335+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 047A2H
 336+ 4CF3              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047AAH
 337+ 4CF3              PLY_AKG_SENDPSGREGISTERS EQU 047B9H
 338+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047C1H
 339+ 4CF3              PLY_AKG_PSGREG01_INSTR EQU 047C1H
 340+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047D1H
 341+ 4CF3              PLY_AKG_PSGREG23_INSTR EQU 047D1H
 342+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047E2H
 343+ 4CF3              PLY_AKG_PSGREG45_INSTR EQU 047E2H
 344+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F3H
 345+ 4CF3              PLY_AKG_PSGREG6_8_INSTR EQU 047F3H
 346+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04804H
 347+ 4CF3              PLY_AKG_PSGREG9_10_INSTR EQU 04804H
 348+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04815H
 349+ 4CF3              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04815H
 350+ 4CF3              PLY_AKG_PSGREG13_OLDVALUE EQU 0482AH
 351+ 4CF3              PLY_AKG_RETRIG EQU 0482CH
 352+ 4CF3              PLY_AKG_PSGREG13_INSTR EQU 0482EH
 353+ 4CF3              PLY_AKG_PSGREG13_END EQU 0483DH
 354+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483DH
 355+ 4CF3              PLY_AKG_SAVESP EQU 0483DH
 356+ 4CF3              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 04841H
 357+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTS EQU 04849H
 358+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04856H
 359+ 4CF3              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04856H
 360+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485EH
 361+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 0486BH
 362+ 4CF3              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 0486BH
 363+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTS EQU 04873H
 364+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487EH
 365+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS EQU 0487EH
 366+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488DH
 367+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488DH
 368+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04894H
 369+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A4H
 370+ 4CF3              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A4H
 371+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048ABH
 372+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048ABH
 373+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048AEH
 374+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B7H
 375+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B7H
 376+ 4CF3              PLY_AKG_READINSTRUMENTCELL EQU 048BDH
 377+ 4CF3              PLY_AKG_NOSOFTNOHARD EQU 048CAH
 378+ 4CF3              PLY_AKG_NSNH_NONOISE EQU 048DFH
 379+ 4CF3              PLY_AKG_SOFT EQU 048E2H
 380+ 4CF3              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E9H
 381+ 4CF3              PLY_AKG_S_NOTSIMPLE EQU 048F1H
 382+ 4CF3              PLY_AKG_S_AFTERSIMPLETEST EQU 048F4H
 383+ 4CF3              PLY_AKG_HARDTOSOFT EQU 04901H
 384+ 4CF3              PLY_AKG_HS_JUMPRATIO EQU 0490CH
 385+ 4CF3              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04939H
 386+ 4CF3              PLY_AKG_ENDWITHOUTLOOP EQU 0493BH
 387+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 0493BH
 388+ 4CF3              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 0493BH
 389+ 4CF3              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04943H
 390+ 4CF3              PLY_AKG_SH_JUMPRATIO EQU 04950H
 391+ 4CF3              PLY_AKG_SH_JUMPRATIOEND EQU 04971H
 392+ 4CF3              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 04980H
 393+ 4CF3              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04986H
 394+ 4CF3              PLY_AKG_H_OR_ENDWITHLOOP EQU 049A0H
 395+ 4CF3              PLY_AKG_H_RETRIGEND EQU 049B2H
 396+ 4CF3              PLY_AKG_H_AFTERRETRIG EQU 049B3H
 397+ 4CF3              PLY_AKG_ENDWITHLOOP EQU 049C5H
 398+ 4CF3              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049CCH
 399+ 4CF3              PLY_AKG_S_OR_H_NEXTBYTE EQU 049E2H
 400+ 4CF3              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049F0H
 401+ 4CF3              PLY_AKG_S_OR_H_AFTERPITCH EQU 04A00H
 402+ 4CF3              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0EH
 403+ 4CF3              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1DH
 404+ 4CF3              PLY_AKG_SHOHS_RETRIGEND EQU 04A2CH
 405+ 4CF3              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2DH
 406+ 4CF3              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3FH
 407+ 4CF3              PLY_AKG_EFFECTTABLE EQU 04A4DH
 408+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4DH
 409+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A71H
 410+ 4CF3              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A71H
 411+ 4CF3              PLY_AKG_EFFECT_RESET EQU 04A74H
 412+ 4CF3              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A76H
 413+ 4CF3              PLY_AKG_EFFECT_VOLUME EQU 04A91H
 414+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9DH
 415+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA3H
 416+ 4CF3              PLY_AKG_ARPEGGIOSTABLE EQU 04AA3H
 417+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04ACAH
 418+ 4CF3              PLY_AKG_EFFECT_PITCHTABLE EQU 04AD1H
 419+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD7H
 420+ 4CF3              PLY_AKG_PITCHESTABLE EQU 04AD7H
 421+ 4CF3              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFEH
 422+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B05H
 423+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B16H
 424+ 4CF3              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1DH
 425+ 4CF3              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2DH
 426+ 4CF3              PLY_AKG_EFFECT_PITCHUP EQU 04B42H
 427+ 4CF3              PLY_AKG_EFFECT_PITCHSTOP EQU 04B54H
 428+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B5BH
 429+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B85H
 430+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B85H
 431+ 4CF3              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9EH
 432+ 4CF3              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9EH
 433+ 4CF3              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BB0H
 434+ 4CF3              PLY_AKG_EFFECT_LEGATO EQU 04BC6H
 435+ 4CF3              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BDAH
 436+ 4CF3              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BE2H
 437+ 4CF3              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BEAH
 438+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BF2H
 439+ 4CF3              PLY_AKG_EVENT EQU 04BF2H
 440+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF3H
 441+ 4CF3              PLY_AKG_PERIODTABLE EQU 04BF3H
 442+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF3H
 443+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF3H
 444+ 4CF3              PLY_AKG_PERIODTABLE_END EQU 04CF3H
 445+ 4CF3              PLY_AKG_END EQU 04CF3H
 446+ 4CF3              MAIN_PLAYER_END EQU 04CF3H
 447+ 4CF3              TESTEREND EQU 04CF3H
 448+ 4CF3
# file closed: ./symbol/AKG.sym
 122  4CF3               ENDIF
 123  4CF3
 124  4CF3               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
   1+ 4CF3              ORIG.HTIMI:
   2+ 4CF3 00 00 00 00  	DB 0, 0, 0, 0, 0
   2+ 4CF7 00
   3+ 4CF8               EXPORT ORIG.HTIMI
   4+ 4CF8
   5+ 4CF8              ; *******************************************************************************************************
   6+ 4CF8              ; interrupt handler when page 0 enabled
   7+ 4CF8              ; we are here only if one of the extended basic commands have paged in page 0
   8+ 4CF8              ; which means we arrived from BASIC so page 2 is already good
   9+ 4CF8              VBLANK:
  10+ 4CF8              	EXPORT VBLANK
  11+ 4CF8
  12+ 4CF8 F5               PUSH AF
  13+ 4CF9              	; is VDP originator ?
  14+ 4CF9 DB 99        	IN	A, (099H)
  15+ 4CFB A7           	AND	A
  16+ 4CFC F2 23 4D     	JP P, .EXIT
  17+ 4CFF
  18+ 4CFF               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  19+ 4CFF C5               PUSH BC
  20+ 4D00 D5               PUSH DE
  21+ 4D01 E5               PUSH HL
  22+ 4D02 08               EX AF, AF'
  23+ 4D03 D9               EXX
  24+ 4D04 F5               PUSH AF
  25+ 4D05 C5               PUSH BC
  26+ 4D06 D5               PUSH DE
  27+ 4D07 E5               PUSH HL
  28+ 4D08 DD E5            PUSH IX
  29+ 4D0A FD E5            PUSH IY
  30+ 4D0C
  31+ 4D0C               IF (SPRITE_CMDS == 1)
  32+ 4D0C CD 5D 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  33+ 4D0F               ENDIF
  34+ 4D0F
  35+ 4D0F               IF (SOUND_CMDS == 1)
  36+ 4D0F 3A 74 55     	LD A, (SOUND_ENABLED)
  37+ 4D12 B7           	OR A
  38+ 4D13 C4 36 42     	CALL NZ,PLY_AKG_PLAY
  39+ 4D16               ENDIF
  40+ 4D16
  41+ 4D16                  ; increase JIFFY
  42+ 4D16                  ;LD HL,(JIFFY)
  43+ 4D16                  ;INC HL
  44+ 4D16                  ;LD (JIFFY),HL
  45+ 4D16
  46+ 4D16 FD E1            POP IY
  47+ 4D18 DD E1            POP IX
  48+ 4D1A E1               POP HL
  49+ 4D1B D1               POP DE
  50+ 4D1C C1               POP BC
  51+ 4D1D F1               POP AF
  52+ 4D1E 08               EX AF, AF'
  53+ 4D1F D9               EXX
  54+ 4D20 E1               POP HL
  55+ 4D21 D1               POP DE
  56+ 4D22 C1               POP BC
  57+ 4D23               ENDIF
  58+ 4D23
  59+ 4D23              .EXIT:
  60+ 4D23 F1           	POP AF
  61+ 4D24 FB           	EI
  62+ 4D25 ED 4D        	RETI
  63+ 4D27              ; *******************************************************************************************************
  64+ 4D27
  65+ 4D27              ; *******************************************************************************************************
  66+ 4D27              ; H.TIMI function
  67+ 4D27              ; we can end up here from anywhere so page in both page 0 and 2
  68+ 4D27              MBGE_HTIMI:
  69+ 4D27               EXPORT MBGE_HTIMI
  70+ 4D27
  71+ 4D27               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  72+ 4D27
  73+ 4D27 F5           	PUSH AF
  74+ 4D28
  75+ 4D28              	; enable page 2
  76+ 4D28 3E 02            LD A, 2
  77+ 4D2A CD 71 5D         CALL GET_PAGE_INFO
  78+ 4D2D C5               PUSH BC
  79+ 4D2E D5               PUSH DE
  80+ 4D2F 3A 43 F3         LD A, (RAMAD2)
  81+ 4D32 26 80            LD H, 080H
  82+ 4D34 CD B8 5D         CALL LOCAL_ENASLT
  83+ 4D37              	; enable page 0
  84+ 4D37 AF               XOR A
  85+ 4D38 CD 71 5D         CALL GET_PAGE_INFO
  86+ 4D3B C5               PUSH BC
  87+ 4D3C D5               PUSH DE
  88+ 4D3D 3A 41 F3         LD A, (RAMAD0)
  89+ 4D40 26 00            LD H, 0
  90+ 4D42 CD B8 5D         CALL LOCAL_ENASLT
  91+ 4D45
  92+ 4D45               IF (SPRITE_CMDS == 1)
  93+ 4D45 CD 5D 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  94+ 4D48               ENDIF
  95+ 4D48
  96+ 4D48               IF (SOUND_CMDS == 1)
  97+ 4D48 3A 74 55     	LD A, (SOUND_ENABLED)
  98+ 4D4B B7           	OR A
  99+ 4D4C C4 36 42     	CALL NZ,PLY_AKG_PLAY
 100+ 4D4F               ENDIF
 101+ 4D4F
 102+ 4D4F              	; restore page 0
 103+ 4D4F D1               POP DE
 104+ 4D50 C1               POP BC
 105+ 4D51 CD A8 5D         CALL RESTORE_PAGE_INFO
 106+ 4D54              	; restore page 2
 107+ 4D54 D1               POP DE
 108+ 4D55 C1               POP BC
 109+ 4D56 CD A8 5D         CALL RESTORE_PAGE_INFO
 110+ 4D59
 111+ 4D59 F1           	POP AF
 112+ 4D5A               ENDIF
 113+ 4D5A C3 F3 4C     	JP ORIG.HTIMI
 114+ 4D5D              ; *******************************************************************************************************
 115+ 4D5D
 116+ 4D5D              ; *******************************************************************************************************
 117+ 4D5D              ; function checks if the sprite system is initialized and what screen mode we are running
 118+ 4D5D              ; also checks if some VRAM modifying command is running
 119+ 4D5D              ; when that checks out calls sprite updates and animation processing
 120+ 4D5D              ; if in an unsupported mode disables sprite handling
 121+ 4D5D              PROCESS_SPRITES_AND_ANIMATIONS:
 122+ 4D5D              	; check if initialized
 123+ 4D5D 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
 124+ 4D60 B7           	OR A
 125+ 4D61 C8           	RET Z
 126+ 4D62              	; check screen mode
 127+ 4D62 3A AF FC     	LD A, (SCRMOD)
 128+ 4D65 3D           	DEC A
 129+ 4D66 28 08        	JR Z, .L0 ; screen 1
 130+ 4D68 3D           	DEC A
 131+ 4D69 28 05            JR Z, .L0 ; screen 2
 132+ 4D6B              	; unsupported screen mode, disable
 133+ 4D6B AF               XOR A
 134+ 4D6C 32 7F 4D         LD (SPRATR_INIT_STATUS),A
 135+ 4D6F C9               RET
 136+ 4D70              .L0:
 137+ 4D70                  ; check if anyone else is working with VRAM
 138+ 4D70 3A 18 5D         LD A,(VRAM_UPDATE_IN_PROGRESS)
 139+ 4D73 B7               OR A
 140+ 4D74 C0               RET NZ
 141+ 4D75
 142+ 4D75 CD 95 4D         CALL SPRATR_UPDATE
 143+ 4D78
 144+ 4D78               IF (ANIM_CMDS == 1)
 145+ 4D78 CD D3 52         CALL PROCESS_ANIMATIONS
 146+ 4D7B CD 32 54         CALL PROCESS_AUTOSGAMS
 147+ 4D7E               ENDIF
 148+ 4D7E C9               RET
 149+ 4D7F              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
 125  4D7F
 126  4D7F               IF (SPRITE_CMDS == 1)
 127  4D7F               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4D7F              ; commands and variables related to sprites
   2+ 4D7F
   3+ 4D7F              SPRATR_INIT_STATUS:
   4+ 4D7F 00            DB 0
   5+ 4D80              SPRATR_UPDATE_FLAG:
   6+ 4D80 00 00         DW 0
   7+ 4D82              SPRATR_DATA:
   8+ 4D82 00 00         DW 0
   9+ 4D84              SPRFLICKER_ENABLED:
  10+ 4D84 00            DB 0
  11+ 4D85              ; to support sprite flicker
  12+ 4D85              FLICKER:
  13+ 4D85 00            DB 0
  14+ 4D86              NUM_SPRITES_HANDLED:
  15+ 4D86 20            DB 32
  16+ 4D87
  17+ 4D87              ; to temporarily store stack pointer
  18+ 4D87              TMPSP:
  19+ 4D87 00 00         DW 0
  20+ 4D89
  21+ 4D89              ; *******************************************************************************************************
  22+ 4D89              ; helper function gets pointer to n-th entry in sprite attributes
  23+ 4D89              ; changes HL,DE
  24+ 4D89              GETnthSPRATTR:
  25+ 4D89 26 00            LD H,0
  26+ 4D8B 6F               LD L,A
  27+ 4D8C CD 6D 5D         CALL HLx8
  28+ 4D8F ED 5B 82 4D      LD DE,(SPRATR_DATA)
  29+ 4D93 19               ADD HL,DE
  30+ 4D94 C9               RET
  31+ 4D95              ; *******************************************************************************************************
  32+ 4D95
  33+ 4D95              ; *******************************************************************************************************
  34+ 4D95              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  35+ 4D95              ; struct {
  36+ 4D95              ; DW y
  37+ 4D95              ; DW x
  38+ 4D95              ; DW pattern (0-63)
  39+ 4D95              ; DW color
  40+ 4D95              ; } [32]
  41+ 4D95              ; will hide sprites whose location is outside of visible area
  42+ 4D95              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  43+ 4D95              ; modifies AF, AF', BC, DE, HL, IX
  44+ 4D95              SPRATR_UPDATE:
  45+ 4D95              	; check if update requested
  46+ 4D95 2A 80 4D     	LD HL, (SPRATR_UPDATE_FLAG)
  47+ 4D98 7E           	LD A, (HL)
  48+ 4D99 B7           	OR A
  49+ 4D9A C8           	RET Z
  50+ 4D9B
  51+ 4D9B DD 21 86 4D  	LD IX,NUM_SPRITES_HANDLED
  52+ 4D9F DD 46 00     	LD B, (IX) ; sprite number
  53+ 4DA2 0E 98        	LD C, #98 ; register for vdp data output
  54+ 4DA4              	; set VDP address
  55+ 4DA4 3A AF FC         LD A,(SCRMOD)
  56+ 4DA7 3D               DEC A
  57+ 4DA8 20 05            JR NZ,.L4
  58+ 4DAA 2A C3 F3         LD HL, (T32ATR)
  59+ 4DAD 18 03            JR .L5
  60+ 4DAF              .L4:
  61+ 4DAF 2A CD F3         LD HL, (GRPATR)
  62+ 4DB2              .L5:
  63+ 4DB2 3A 84 4D     	LD A, (SPRFLICKER_ENABLED)
  64+ 4DB5 B7           	OR A
  65+ 4DB6 28 03        	JR Z, .L3
  66+ 4DB8 3A 85 4D     	LD A, (FLICKER)
  67+ 4DBB              .L3:
  68+ 4DBB 5F           	LD E, A
  69+ 4DBC 08           	EX AF, AF'
  70+ 4DBD 7B           	LD A, E
  71+ 4DBE 87           	ADD A, A
  72+ 4DBF 87           	ADD A, A
  73+ 4DC0 16 00        	LD D, 0
  74+ 4DC2 5F           	LD E, A
  75+ 4DC3 19           	ADD HL, DE
  76+ 4DC4 CD 58 5D     	CALL SETWRT_LOCAL
  77+ 4DC7 ED 73 87 4D  	LD (TMPSP), SP
  78+ 4DCB ED 7B 82 4D  	LD SP, (SPRATR_DATA)
  79+ 4DCF
  80+ 4DCF              .LOOP:
  81+ 4DCF E1           	POP HL
  82+ 4DD0 24           	INC H
  83+ 4DD1 28 0D        	JR Z, .L1 ; negative number between -256 and -1
  84+ 4DD3 25           	DEC H
  85+ 4DD4 20 15        	JR NZ, .OUT3 ; sprite vertically can't be visible
  86+ 4DD6 7D           	LD A, L
  87+ 4DD7 FE C0        	CP 192
  88+ 4DD9 30 10        	JR NC, .OUT3
  89+ 4DDB 3D           	DEC A ; due to VDP rule that top of screen is -1
  90+ 4DDC 57           	LD D, A
  91+ 4DDD C3 04 4E     	JP .X
  92+ 4DE0              .L1:
  93+ 4DE0 7D           	LD A, L
  94+ 4DE1 C6 10        	ADD 16
  95+ 4DE3 FA EB 4D     	JP M, .OUT3 ; below -16
  96+ 4DE6 2D           	DEC L ; due to VDP rule that top of screen is -1
  97+ 4DE7 55           	LD D, L
  98+ 4DE8 C3 04 4E     	JP .X
  99+ 4DEB              .OUT3:
 100+ 4DEB E1           	POP HL ; skip x value
 101+ 4DEC              .OUT2:
 102+ 4DEC E1           	POP HL ; skip pattern
 103+ 4DED E1           	POP HL ; skip color
 104+ 4DEE 3E D1        	LD A, #D1
 105+ 4DF0 ED 79        	OUT (C), A ; sprite hidden
 106+ 4DF2 00          > NOP
 106+ 4DF3 00          > NOP
 106+ 4DF4 00          > NOP
 107+ 4DF5 ED 79        	OUT (C), A ; value unimportant
 108+ 4DF7 00          > NOP
 108+ 4DF8 00          > NOP
 108+ 4DF9 00          > NOP
 109+ 4DFA ED 79        	OUT (C), A ; value unimportant
 110+ 4DFC 00          > NOP
 110+ 4DFD 00          > NOP
 110+ 4DFE 00          > NOP
 111+ 4DFF ED 79        	OUT (C), A ; value unimportant
 112+ 4E01 C3 2F 4E     	JP .NEXT
 113+ 4E04              .X:
 114+ 4E04 E1           	POP HL
 115+ 4E05 24           	INC H
 116+ 4E06 28 08        	JR Z, .L2
 117+ 4E08 25           	DEC H
 118+ 4E09 20 E1        	JR NZ, .OUT2
 119+ 4E0B 1E 00        	LD E, 0 ; EC bit
 120+ 4E0D C3 19 4E     	JP .XY
 121+ 4E10              .L2:
 122+ 4E10 7D           	LD A, L
 123+ 4E11 C6 20        	ADD 32
 124+ 4E13 FA EC 4D     	JP M, .OUT2
 125+ 4E16 6F           	LD L, A
 126+ 4E17 1E 80        	LD E, #80
 127+ 4E19              .XY:
 128+ 4E19 ED 51        	OUT (C), D
 129+ 4E1B 3A E0 F3     	LD A, (REG1SAV)
 130+ 4E1E E6 02        	AND 2
 131+ 4E20 ED 69        	OUT (C), L
 132+ 4E22 E1           	POP HL ; pattern
 133+ 4E23 7D           	LD A, L
 134+ 4E24 28 02        	JR Z, .SMALLSPRITES
 135+ 4E26 87           	ADD A, A
 136+ 4E27 87           	ADD A, A ; needs to go at 4x
 137+ 4E28              .SMALLSPRITES:
 138+ 4E28 D3 98        	OUT (#98), A
 139+ 4E2A E1           	POP HL ; color
 140+ 4E2B 7D           	LD A, L
 141+ 4E2C B3           	OR E
 142+ 4E2D D3 98        	OUT (#98), A
 143+ 4E2F              .NEXT:
 144+ 4E2F 08           	EX AF, AF'
 145+ 4E30 3C           	INC A ; increase current sprite
 146+ 4E31 DD BE 00     	CP (IX) ; compare to maximum handled
 147+ 4E34 C2 54 4E     	JP NZ, .NEXT2 ; continue if not over
 148+ 4E37 AF           	XOR A ; back to zero
 149+ 4E38 08           	EX AF, AF'
 150+ 4E39 3A AF FC         LD A,(SCRMOD)
 151+ 4E3C 3D               DEC A
 152+ 4E3D 20 05            JR NZ,.L6
 153+ 4E3F 2A C3 F3         LD HL, (T32ATR)
 154+ 4E42 18 03            JR .L7
 155+ 4E44              .L6:
 156+ 4E44 2A CD F3         LD HL, (GRPATR)
 157+ 4E47              .L7:
 158+ 4E47              	; CALL SETWRT_LOCAL not allowed as SP modified
 159+ 4E47 7D           	LD	A, L
 160+ 4E48 D3 99        	OUT	(099H), A
 161+ 4E4A 7C           	LD	A, H
 162+ 4E4B E6 3F        	AND	03FH
 163+ 4E4D F6 40        	OR	040H
 164+ 4E4F D3 99        	OUT	(099H), A
 165+ 4E51 C3 55 4E     	JP .NEXT3
 166+ 4E54              .NEXT2:
 167+ 4E54 08           	EX AF, AF'
 168+ 4E55              .NEXT3:
 169+ 4E55 05           	DEC B
 170+ 4E56 C2 CF 4D     	JP NZ, .LOOP
 171+ 4E59 08           	EX AF, AF'
 172+ 4E5A 3C           	INC A ; increase flicker to start at the next one on next vblank
 173+ 4E5B DD BE 00     	CP (IX)
 174+ 4E5E 20 01        	JR NZ,.L8
 175+ 4E60 AF           	XOR A
 176+ 4E61              .L8:
 177+ 4E61 32 85 4D     	LD (FLICKER), A
 178+ 4E64
 179+ 4E64 ED 7B 87 4D  	LD SP, (TMPSP)
 180+ 4E68 2A 80 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 181+ 4E6B 36 00        	LD (HL), 0 ; zero out update flag
 182+ 4E6D C9           	RET
 183+ 4E6E              ; *******************************************************************************************************
 184+ 4E6E
 185+ 4E6E               IF (BASIC_EXTENSION == 1)
 186+ 4E6E ~            ; *******************************************************************************************************
 187+ 4E6E ~            ; function to handle CALL SPRENABLE basic extension
 188+ 4E6E ~            ; initializes sprites handler
 189+ 4E6E ~            ; _SPRENABLE ( INT[3][31] variable sprites_attributes,
 190+ 4E6E ~            ;			   INT variable update_variable,
 191+ 4E6E ~            ;			   BYTE sprite_flicker_enabled,
 192+ 4E6E ~            ;			   BYTE num_sprites_handled )
 193+ 4E6E ~            ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA, SPRFLICKER_ENABLED and NUM_SPRITES_HANDLED
 194+ 4E6E ~            SPRENABLE:
 195+ 4E6E ~            	; opening (
 196+ 4E6E ~            	CALL CHKCHAR
 197+ 4E6E ~            	DB '('
 198+ 4E6E ~            	; get address of sprite attribute table DIM SA%(3,31)
 199+ 4E6E ~            	LD A,2
 200+ 4E6E ~            	LD B,2
 201+ 4E6E ~            	LD DE,#0420
 202+ 4E6E ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
 203+ 4E6E ~            	LD (SPRATR_DATA), BC
 204+ 4E6E ~            	; comma
 205+ 4E6E ~            	CALL CHKCHAR
 206+ 4E6E ~            	DB ','
 207+ 4E6E ~            	; get address of sprite update flag
 208+ 4E6E ~            	LD IX, PTRGET
 209+ 4E6E ~            	CALL CALBAS
 210+ 4E6E ~            	LD (SPRATR_UPDATE_FLAG), DE
 211+ 4E6E ~            	; comma
 212+ 4E6E ~            	CALL CHKCHAR
 213+ 4E6E ~            	DB ','
 214+ 4E6E ~            	; get flicker enabled flag
 215+ 4E6E ~            	LD IX, GETBYT
 216+ 4E6E ~            	CALL CALBAS
 217+ 4E6E ~            	LD (SPRFLICKER_ENABLED), A
 218+ 4E6E ~            	; comma
 219+ 4E6E ~            	CALL CHKCHAR
 220+ 4E6E ~            	DB ','
 221+ 4E6E ~            	; get number of handled sprites
 222+ 4E6E ~            	LD IX, GETBYT
 223+ 4E6E ~            	CALL CALBAS
 224+ 4E6E ~            	LD (NUM_SPRITES_HANDLED),A
 225+ 4E6E ~            	; ending )
 226+ 4E6E ~            	CALL CHKCHAR
 227+ 4E6E ~            	DB ')'
 228+ 4E6E ~            .L0:
 229+ 4E6E ~            	LD A, 1
 230+ 4E6E ~            	LD (SPRATR_INIT_STATUS), A
 231+ 4E6E ~            	RET
 232+ 4E6E ~            ; *******************************************************************************************************
 233+ 4E6E               ENDIF
 234+ 4E6E
 235+ 4E6E               IF (DEFUSR_EXTENSION == 1)
 236+ 4E6E              ; same as SPRENABLE but for DEFUSR approach
 237+ 4E6E              ; input IX=pointer to input array, real data from +2
 238+ 4E6E              ; +2 = pointer to sprite attributes array data
 239+ 4E6E              ; +4 = pointer to sprite update variable
 240+ 4E6E              ; +6 = flicker flag
 241+ 4E6E              ; +8 = number of sprites to handle
 242+ 4E6E              SPRENABLE_DEFUSR:
 243+ 4E6E DD 6E 02     	LD L,(IX+2)
 244+ 4E71 DD 66 03     	LD H,(IX+3)
 245+ 4E74 22 82 4D     	LD (SPRATR_DATA),HL
 246+ 4E77 DD 6E 04     	LD L,(IX+4)
 247+ 4E7A DD 66 05     	LD H,(IX+5)
 248+ 4E7D 22 80 4D     	LD (SPRATR_UPDATE_FLAG),HL
 249+ 4E80 DD 7E 06     	LD A,(IX+6)
 250+ 4E83 32 84 4D     	LD (SPRFLICKER_ENABLED),A
 251+ 4E86 DD 7E 08     	LD A,(IX+8)
 252+ 4E89 32 86 4D     	LD (NUM_SPRITES_HANDLED),A
 253+ 4E8C               IF (BASIC_EXTENSION == 1)
 254+ 4E8C ~            	JR SPRENABLE.L0
 255+ 4E8C               ELSE
 256+ 4E8C 3E 01        	LD A, 1
 257+ 4E8E 32 7F 4D     	LD (SPRATR_INIT_STATUS), A
 258+ 4E91 C9           	RET
 259+ 4E92               ENDIF
 260+ 4E92               ENDIF
 261+ 4E92
 262+ 4E92               IF (DEFUSR_EXTENSION + BASIC_EXTENSION > 0)
 263+ 4E92              ; *******************************************************************************************************
 264+ 4E92              ; function to handle CALL SPRDISABLE basic extension
 265+ 4E92              ; disables sprites handling
 266+ 4E92              ; _SPRDISABLE
 267+ 4E92              ; resets variable SPRATR_INIT_STATUS
 268+ 4E92              SPRDISABLE:
 269+ 4E92              SPRDISABLE_DEFUSR:
 270+ 4E92 AF           	XOR A
 271+ 4E93 32 7F 4D     	LD (SPRATR_INIT_STATUS), A
 272+ 4E96 C9           	RET
 273+ 4E97              ; *******************************************************************************************************
 274+ 4E97               ENDIF
 275+ 4E97
 276+ 4E97              ; *******************************************************************************************************
 277+ 4E97              ; function to handle CALL SPRSET basic extension
 278+ 4E97              ; sets position, and optionally pattern and color of sprite
 279+ 4E97              ; _SPRSET ( BYTE sprite_num , valid 0-31
 280+ 4E97              ;			INT x,
 281+ 4E97              ;			INT y,
 282+ 4E97              ;			INT pattern, valid 0-63, otherwise ignored
 283+ 4E97              ;			INT color, valid 0-15, otherwise ignored
 284+ 4E97              ;SPRSET:
 285+ 4E97              ;	LD A, (SPRATR_INIT_STATUS)
 286+ 4E97              ;	OR A
 287+ 4E97              ;	JR NZ, .L1
 288+ 4E97              ;	LD E, 5 ; illegal function call
 289+ 4E97              ;	JP THROW_ERROR
 290+ 4E97              ;.L1:
 291+ 4E97              ;	; opening (
 292+ 4E97              ;	CALL CHKCHAR
 293+ 4E97              ;	DB '('
 294+ 4E97              ;	; get sprite number
 295+ 4E97              ;	LD IX, GETBYT
 296+ 4E97              ;	CALL CALBAS
 297+ 4E97              ;	PUSH AF
 298+ 4E97              ;	; comma
 299+ 4E97              ;	CALL CHKCHAR
 300+ 4E97              ;	DB ','
 301+ 4E97              ;	; get x
 302+ 4E97              ;	LD IX, FRMQNT
 303+ 4E97              ;	CALL CALBAS
 304+ 4E97              ;	PUSH DE
 305+ 4E97              ;	; comma
 306+ 4E97              ;	CALL CHKCHAR
 307+ 4E97              ;	DB ','
 308+ 4E97              ;	; get y
 309+ 4E97              ;	LD IX, FRMQNT
 310+ 4E97              ;	CALL CALBAS
 311+ 4E97              ;	PUSH DE
 312+ 4E97              ;	; comma
 313+ 4E97              ;	CALL CHKCHAR
 314+ 4E97              ;	DB ','
 315+ 4E97              ;	; get pattern
 316+ 4E97              ;	LD IX, FRMQNT
 317+ 4E97              ;	CALL CALBAS
 318+ 4E97              ;	PUSH DE
 319+ 4E97              ;	; comma
 320+ 4E97              ;	CALL CHKCHAR
 321+ 4E97              ;	DB ','
 322+ 4E97              ;	; get color
 323+ 4E97              ;	LD IX, FRMQNT
 324+ 4E97              ;	CALL CALBAS
 325+ 4E97              ;	PUSH DE
 326+ 4E97              ;	; ending )
 327+ 4E97              ;	CALL CHKCHAR
 328+ 4E97              ;	DB ')'
 329+ 4E97              ;
 330+ 4E97              ;   ; save position in BASIC text
 331+ 4E97              ;	PUSH HL
 332+ 4E97              ;	POP IX
 333+ 4E97              ;
 334+ 4E97              ;	POP BC ; color
 335+ 4E97              ;	POP DE ; pattern
 336+ 4E97              ;	EXX
 337+ 4E97              ;	POP BC ; y
 338+ 4E97              ;	POP DE ; x
 339+ 4E97              ;	POP AF ; sprite number
 340+ 4E97              ;	CP 32
 341+ 4E97              ;	JR C, .L2
 342+ 4E97              ;	LD E, 5 ; illegal function call
 343+ 4E97              ;	JP THROW_ERROR
 344+ 4E97              ;.L2:
 345+ 4E97              ;	; find location in sprite attributes table
 346+ 4E97              ;	PUSH DE
 347+ 4E97              ;	CALL GETnthSPRATTR
 348+ 4E97              ;	POP DE
 349+ 4E97              ;	DI
 350+ 4E97              ;	; set y
 351+ 4E97              ;	LD (HL), C
 352+ 4E97              ;	INC HL
 353+ 4E97              ;	LD (HL), B
 354+ 4E97              ;	INC HL
 355+ 4E97              ;	; set x
 356+ 4E97              ;	LD (HL), E
 357+ 4E97              ;	INC HL
 358+ 4E97              ;	LD (HL), D
 359+ 4E97              ;	INC HL
 360+ 4E97              ;	PUSH HL
 361+ 4E97              ;	EXX
 362+ 4E97              ;	POP HL
 363+ 4E97              ;	; check if 0<=pattern<64
 364+ 4E97              ;	LD A, D
 365+ 4E97              ;	OR A
 366+ 4E97              ;	JR NZ, .L3
 367+ 4E97              ;	LD A, E
 368+ 4E97              ;	CP 64
 369+ 4E97              ;	JR NC, .L3
 370+ 4E97              ;	; set pattern
 371+ 4E97              ;	;ADD A, A
 372+ 4E97              ;	;ADD A, A
 373+ 4E97              ;	;ADD A, A
 374+ 4E97              ;	LD (HL), A
 375+ 4E97              ;	INC HL
 376+ 4E97              ;	LD (HL), D
 377+ 4E97              ;	INC HL
 378+ 4E97              ;	JR .L4
 379+ 4E97              ;.L3:
 380+ 4E97              ;	; skip pattern
 381+ 4E97              ;	.2 INC HL
 382+ 4E97              ;.L4:
 383+ 4E97              ;	; check if 0<=color<16
 384+ 4E97              ;	LD A, B
 385+ 4E97              ;	OR A
 386+ 4E97              ;	JR NZ, .L5
 387+ 4E97              ;	LD A, C
 388+ 4E97              ;	CP 16
 389+ 4E97              ;	JR NC, .L5
 390+ 4E97              ;	; set color
 391+ 4E97              ;	LD (HL), C
 392+ 4E97              ;	INC HL
 393+ 4E97              ;	LD (HL), B
 394+ 4E97              ;
 395+ 4E97              ;.L5:
 396+ 4E97              ;	EI
 397+ 4E97              ;	PUSH IX
 398+ 4E97              ;	POP HL
 399+ 4E97              ;	RET
 400+ 4E97              ; *******************************************************************************************************
 401+ 4E97
 402+ 4E97              ; *******************************************************************************************************
 403+ 4E97              ; function sets sprite location based on initial coordinates and offset provided
 404+ 4E97              ; input A=sprite number in SPRATR_DATA , 0-31
 405+ 4E97              ; input DE=initial x
 406+ 4E97              ; input BC=initial y
 407+ 4E97              ; input IY=location where delta y,x are located
 408+ 4E97              ; modifies AF, HL, IX
 409+ 4E97              SPRSET_DELTA_POS:
 410+ 4E97 D5           	PUSH DE
 411+ 4E98 CD 89 4D     	CALL GETnthSPRATTR
 412+ 4E9B E5           	PUSH HL
 413+ 4E9C DD E1        	POP IX
 414+ 4E9E D1           	POP DE
 415+ 4E9F              	; IX=sprite's y location
 416+ 4E9F FD 6E 00     	LD L, (IY)
 417+ 4EA2 FD 66 01     	LD H, (IY+1)
 418+ 4EA5 09           	ADD HL, BC
 419+ 4EA6 DD 75 00     	LD (IX), L
 420+ 4EA9 DD 74 01     	LD (IX+1), H
 421+ 4EAC FD 6E 02     	LD L, (IY+2)
 422+ 4EAF FD 66 03     	LD H, (IY+3)
 423+ 4EB2 19           	ADD HL, DE
 424+ 4EB3 DD 75 02     	LD (IX+2), L
 425+ 4EB6 DD 74 03     	LD (IX+3), H
 426+ 4EB9 C9           	RET
 427+ 4EBA              ; *******************************************************************************************************
 428+ 4EBA
 429+ 4EBA              ; *******************************************************************************************************
 430+ 4EBA              ; helper function to set new locations for a set of sprites
 431+ 4EBA              ; input B=number of sprites
 432+ 4EBA              ; HL=pointer to list of sprites and offsets
 433+ 4EBA              SPR_UPDATE_LOC:
 434+ 4EBA 3E 01        	LD A,1
 435+ 4EBC 32 18 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 436+ 4EBF 7E           	LD A, (HL)
 437+ 4EC0 23           	INC HL
 438+ 4EC1 23           	INC HL
 439+ 4EC2 E5           	PUSH HL
 440+ 4EC3 FD E1        	POP IY
 441+ 4EC5 D9           	EXX
 442+ 4EC6 CD 97 4E     	CALL SPRSET_DELTA_POS
 443+ 4EC9 D9           	EXX
 444+ 4ECA 23          > INC HL
 444+ 4ECB 23          > INC HL
 444+ 4ECC 23          > INC HL
 444+ 4ECD 23          > INC HL
 445+ 4ECE 10 EA        	DJNZ SPR_UPDATE_LOC
 446+ 4ED0 AF           	XOR A
 447+ 4ED1 32 18 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 448+ 4ED4 C9           	RET
 449+ 4ED5              ; *******************************************************************************************************
 450+ 4ED5
 451+ 4ED5               IF (BASIC_EXTENSION == 1)
 452+ 4ED5 ~            ; *******************************************************************************************************
 453+ 4ED5 ~            ; function to handle CALL SPRGRPMOV basic extension
 454+ 4ED5 ~            ; sets position of a group of sprites described with
 455+ 4ED5 ~            ; { int sprite_num, int delta_y, int delta_x } [count]
 456+ 4ED5 ~            ; _SPRGRPMOV ( INT x,
 457+ 4ED5 ~            ;			   INT y,
 458+ 4ED5 ~            ;			   BYTE count,
 459+ 4ED5 ~            ;			   INT[2][count] data_ptr
 460+ 4ED5 ~            SPRGRPMOV:
 461+ 4ED5 ~            	LD A, (SPRATR_INIT_STATUS)
 462+ 4ED5 ~            	OR A
 463+ 4ED5 ~            	JP Z,ILLEGAL_FUNCTION
 464+ 4ED5 ~            	; opening (
 465+ 4ED5 ~            	CALL CHKCHAR
 466+ 4ED5 ~            	DB '('
 467+ 4ED5 ~            	; get x
 468+ 4ED5 ~            	LD IX, FRMQNT
 469+ 4ED5 ~            	CALL CALBAS
 470+ 4ED5 ~            	LD (BLIT_STRUCT),DE
 471+ 4ED5 ~            	; comma
 472+ 4ED5 ~            	CALL CHKCHAR
 473+ 4ED5 ~            	DB ','
 474+ 4ED5 ~            	; get y
 475+ 4ED5 ~            	LD IX, FRMQNT
 476+ 4ED5 ~            	CALL CALBAS
 477+ 4ED5 ~            	LD (BLIT_STRUCT+2),DE
 478+ 4ED5 ~            	; comma
 479+ 4ED5 ~            	CALL CHKCHAR
 480+ 4ED5 ~            	DB ','
 481+ 4ED5 ~            	; get count
 482+ 4ED5 ~            	LD IX, GETBYT
 483+ 4ED5 ~            	CALL CALBAS
 484+ 4ED5 ~            	LD (BLIT_STRUCT+4),A
 485+ 4ED5 ~            	; comma
 486+ 4ED5 ~            	CALL CHKCHAR
 487+ 4ED5 ~            	DB ','
 488+ 4ED5 ~            	; get sprite group definition array data pointer
 489+ 4ED5 ~            	LD A,(BLIT_STRUCT+4)
 490+ 4ED5 ~            	LD E,A
 491+ 4ED5 ~            	LD D,3
 492+ 4ED5 ~            	LD A,2
 493+ 4ED5 ~            	LD B,A
 494+ 4ED5 ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
 495+ 4ED5 ~            	LD (BLIT_STRUCT+5),BC
 496+ 4ED5 ~            	; ending )
 497+ 4ED5 ~            	CALL CHKCHAR
 498+ 4ED5 ~            	DB ')'
 499+ 4ED5 ~
 500+ 4ED5 ~            	PUSH HL
 501+ 4ED5 ~
 502+ 4ED5 ~                EXX
 503+ 4ED5 ~                LD DE,(BLIT_STRUCT) ; initial x
 504+ 4ED5 ~                LD BC,(BLIT_STRUCT+2) ; initial y
 505+ 4ED5 ~                EXX
 506+ 4ED5 ~                LD HL,(BLIT_STRUCT+5) ; pointer to data
 507+ 4ED5 ~                LD A,(BLIT_STRUCT+4) ; number of entries
 508+ 4ED5 ~                LD B,A
 509+ 4ED5 ~            	CALL SPR_UPDATE_LOC
 510+ 4ED5 ~
 511+ 4ED5 ~            	POP HL
 512+ 4ED5 ~            	RET
 513+ 4ED5 ~            ; *******************************************************************************************************
 514+ 4ED5               ENDIF
 515+ 4ED5
 516+ 4ED5               IF (DEFUSR_EXTENSION == 1)
 517+ 4ED5              ; *******************************************************************************************************
 518+ 4ED5              ; same as SPRGRPMOV but for DEFUSR approach
 519+ 4ED5              ; input IX=pointer to input array, real data from +2
 520+ 4ED5              ; +2 = X
 521+ 4ED5              ; +4 = Y
 522+ 4ED5              ; +6 = count
 523+ 4ED5              ; +8 = data pointer
 524+ 4ED5              SPRGRPMOV_DEFUSR:
 525+ 4ED5 D9               EXX
 526+ 4ED6 DD 5E 02     	LD E,(IX+2)
 527+ 4ED9 DD 56 03     	LD D,(IX+3) ; initial x
 528+ 4EDC DD 4E 04     	LD C,(IX+4)
 529+ 4EDF DD 46 05     	LD B,(IX+5) ; initial y
 530+ 4EE2 D9               EXX
 531+ 4EE3 DD 6E 08     	LD L,(IX+8)
 532+ 4EE6 DD 66 09     	LD H,(IX+9) ; pointer to data
 533+ 4EE9 DD 46 06         LD B,(IX+6) ; count
 534+ 4EEC C3 BA 4E         JP SPR_UPDATE_LOC
 535+ 4EEF              ; *******************************************************************************************************
 536+ 4EEF               ENDIF
# file closed: asm\SPRITES.asm
 128  4EEF               ENDIF
 129  4EEF
 130  4EEF               IF (ANIM_CMDS == 1)
 131  4EEF               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4EEF              ; sprite animation routines
   2+ 4EEF
   3+ 4EEF              ; number of animation items and pointer
   4+ 4EEF              ANIMITEMNUM:
   5+ 4EEF 00            DB 0
   6+ 4EF0              ANIMITEMPTR:
   7+ 4EF0 EE 5E         DW EXT_END
   8+ 4EF2              ; number of animation definitions and pointer
   9+ 4EF2              ANIMDEFNUM:
  10+ 4EF2 00            DB 0
  11+ 4EF3              ANIMDEFPTR:
  12+ 4EF3 EE 5E         DW EXT_END
  13+ 4EF5              ; number of links between sprite and animation definitions
  14+ 4EF5              ANIMSPRNUM:
  15+ 4EF5 00            DB 0
  16+ 4EF6              ANIMSPRPTR:
  17+ 4EF6 EE 5E         DW EXT_END
  18+ 4EF8              ; number of automatic sprite group move and animate structures
  19+ 4EF8              AUTOSGAMNUM:
  20+ 4EF8 00            DB 0
  21+ 4EF9              AUTOSGAMPTR:
  22+ 4EF9 EE 5E         DW EXT_END
  23+ 4EFB
  24+ 4EFB              ; ANIMATION ITEM
  25+ 4EFB              ; byte type = [0 - pattern and color change
  26+ 4EFB              ;              1 - pattern definition change ]
  27+ 4EFB              ; word ticks - number of ticks to hold this state
  28+ 4EFB              ; for type = 0
  29+ 4EFB              ;   byte pattern;
  30+ 4EFB              ;   byte color;
  31+ 4EFB              ; for type = 1
  32+ 4EFB              ;   work data_pointer;
  33+ 4EFB              ; total size = 5b
  34+ 4EFB
  35+ 4EFB              ; ANIMATION DEFINITION
  36+ 4EFB              ; byte number of items 1-15
  37+ 4EFB              ; byte[15] anim_item;
  38+ 4EFB              ; total size = 16b
  39+ 4EFB
  40+ 4EFB              ; SPRITE/CHAR ANIMATION
  41+ 4EFB              ; +00 byte sprite/char number;
  42+ 4EFB              ; +01 word time;
  43+ 4EFB              ; +03 byte current item;
  44+ 4EFB              ; +04 byte animation definition;
  45+ 4EFB              ; +05 byte cyclic;
  46+ 4EFB              ; +06 byte active;
  47+ 4EFB              ; +07 byte 0=sprite, 1-3 character bank
  48+ 4EFB              ; total size = 8b
  49+ 4EFB
  50+ 4EFB              ; AUTOMATIC SPRITE GROUP MOVE AND ANIMATE structure
  51+ 4EFB              ; +00 pointer to X variable
  52+ 4EFB              ; +02 pointer to Y variable
  53+ 4EFB              ; +04 minimum value
  54+ 4EFB              ; +06 maximal value
  55+ 4EFB              ; +08 delta value
  56+ 4EFB              ; +10 direction 0=horizontal, <>0 = vertical
  57+ 4EFB              ; +11 sprite group size
  58+ 4EFB              ; +12 sprite group pointer
  59+ 4EFB              ; +14 animation list size
  60+ 4EFB              ; +15 animation list pointer for negative delta values
  61+ 4EFB              ; +17 animation list pointer for positive delta values
  62+ 4EFB              ; +19 active flag
  63+ 4EFB              ; +20 ticks for movement
  64+ 4EFB              ; +22 timer
  65+ 4EFB              ; total = 24b
  66+ 4EFB
  67+ 4EFB              ; *******************************************************************************************************
  68+ 4EFB              ; helper function HL=A*5
  69+ 4EFB              ; changes HL,DE
  70+ 4EFB              Ax5:
  71+ 4EFB 26 00            LD H,0
  72+ 4EFD 6F               LD L,A
  73+ 4EFE 54               LD D,H
  74+ 4EFF 5D               LD E,L
  75+ 4F00 29               ADD HL,HL
  76+ 4F01 29               ADD HL,HL
  77+ 4F02 19               ADD HL,DE
  78+ 4F03 C9               RET
  79+ 4F04              ; *******************************************************************************************************
  80+ 4F04
  81+ 4F04              ; *******************************************************************************************************
  82+ 4F04              ; helper function gets pointer to n-th animation item
  83+ 4F04              ; changes HL,DE
  84+ 4F04              GETnthANIMITEM:
  85+ 4F04 CD FB 4E         CALL Ax5
  86+ 4F07 ED 5B F0 4E      LD DE,(ANIMITEMPTR)
  87+ 4F0B 19               ADD HL,DE
  88+ 4F0C C9               RET
  89+ 4F0D              ; *******************************************************************************************************
  90+ 4F0D
  91+ 4F0D              ; *******************************************************************************************************
  92+ 4F0D              ; helper function gets pointer to n-th entry in animation definition
  93+ 4F0D              ; changes HL,DE
  94+ 4F0D              GETnthANIMDEF:
  95+ 4F0D 26 00            LD H,0
  96+ 4F0F 6F               LD L,A
  97+ 4F10 CD 6C 5D         CALL HLx16
  98+ 4F13 ED 5B F3 4E      LD DE,(ANIMDEFPTR)
  99+ 4F17 19               ADD HL,DE
 100+ 4F18 C9               RET
 101+ 4F19              ; *******************************************************************************************************
 102+ 4F19
 103+ 4F19              ; *******************************************************************************************************
 104+ 4F19              ; helper function gets pointer to n-th entry in sprite animation
 105+ 4F19              ; changes HL,DE
 106+ 4F19              GETnthSPRANIM:
 107+ 4F19 26 00            LD H,0
 108+ 4F1B 6F               LD L,A
 109+ 4F1C CD 6D 5D         CALL HLx8
 110+ 4F1F ED 5B F6 4E      LD DE,(ANIMSPRPTR)
 111+ 4F23 19               ADD HL,DE
 112+ 4F24 C9               RET
 113+ 4F25              ; *******************************************************************************************************
 114+ 4F25
 115+ 4F25              ; *******************************************************************************************************
 116+ 4F25              ; helper function gets pointer to n-th entry in autosgam table
 117+ 4F25              ; changes HL,DE
 118+ 4F25              GETnthAUTOSGAM:
 119+ 4F25 26 00            LD H,0
 120+ 4F27 6F               LD L,A
 121+ 4F28 CD 6D 5D         CALL HLx8
 122+ 4F2B 54               LD D,H
 123+ 4F2C 5D               LD E,L
 124+ 4F2D 29               ADD HL,HL
 125+ 4F2E 19               ADD HL,DE
 126+ 4F2F ED 5B F9 4E      LD DE,(AUTOSGAMPTR)
 127+ 4F33 19               ADD HL,DE
 128+ 4F34 C9               RET
 129+ 4F35              ; *******************************************************************************************************
 130+ 4F35
 131+ 4F35               IF (DEFUSR_EXTENSION == 1)
 132+ 4F35              ; *******************************************************************************************************
 133+ 4F35              ; same as MAXIANIMITEMS but for DEFUSR approach
 134+ 4F35              ; input IX=pointer to input array, real data from +2
 135+ 4F35              ; +2 = number
 136+ 4F35              MAXANIMITEMS_DEFUSR:
 137+ 4F35 DD 7E 02         LD A,(IX+2)
 138+ 4F38 18 00            JR MAXANIMITEMS.COMMON
 139+ 4F3A              ; *******************************************************************************************************
 140+ 4F3A               ENDIF
 141+ 4F3A
 142+ 4F3A              ; *******************************************************************************************************
 143+ 4F3A              ; function to handle CALL MAXANIMITEMS basic extension
 144+ 4F3A              ; MAXANIMITEMS (BYTE number)
 145+ 4F3A              ; sets new number and moves memory buffers as needed
 146+ 4F3A              MAXANIMITEMS:
 147+ 4F3A               IF (BASIC_EXTENSION == 1)
 148+ 4F3A ~            	; opening (
 149+ 4F3A ~            	CALL CHKCHAR
 150+ 4F3A ~            	DB '('
 151+ 4F3A ~            	; get value
 152+ 4F3A ~            	LD IX, GETBYT
 153+ 4F3A ~            	CALL CALBAS
 154+ 4F3A ~                PUSH AF
 155+ 4F3A ~            	; ending )
 156+ 4F3A ~            	CALL CHKCHAR
 157+ 4F3A ~            	DB ')'
 158+ 4F3A ~                POP AF
 159+ 4F3A               ENDIF
 160+ 4F3A              .COMMON: ; entry for DEFUSR part, A=number
 161+ 4F3A F3               DI
 162+ 4F3B              	; save position
 163+ 4F3B E5           	PUSH HL
 164+ 4F3C              .ENTRY:
 165+ 4F3C 47               LD B,A
 166+ 4F3D 3A EF 4E         LD A,(ANIMITEMNUM)
 167+ 4F40 90               SUB B
 168+ 4F41 28 28            JR Z, .EXIT; same value as before
 169+ 4F43 FD 21 F3 4E      LD IY,ANIMDEFPTR
 170+ 4F47 FA 6E 4F         JP M, .INCREASE
 171+ 4F4A                  ; new value is lower than previous one
 172+ 4F4A CD 8D 4F         CALL .SIZEDIFF
 173+ 4F4D CD A8 4F         CALL .DECREASE_COMMON
 174+ 4F50 2A F6 4E         LD HL,(ANIMSPRPTR)
 175+ 4F53 AF               XOR A
 176+ 4F54 ED 42            SBC HL,BC
 177+ 4F56 22 F6 4E         LD (ANIMSPRPTR),HL
 178+ 4F59              .E1:
 179+ 4F59 2A F9 4E         LD HL,(AUTOSGAMPTR)
 180+ 4F5C AF               XOR A
 181+ 4F5D ED 42            SBC HL,BC
 182+ 4F5F 22 F9 4E         LD (AUTOSGAMPTR),HL
 183+ 4F62              .E3:
 184+ 4F62 2A 10 40         LD HL,(FREEMEMPTR)
 185+ 4F65 AF               XOR A
 186+ 4F66 ED 42            SBC HL,BC
 187+ 4F68 22 10 40         LD (FREEMEMPTR),HL
 188+ 4F6B              .EXIT:
 189+ 4F6B FB               EI
 190+ 4F6C E1           	POP HL
 191+ 4F6D C9           	RET
 192+ 4F6E              .INCREASE:
 193+ 4F6E ED 44            NEG
 194+ 4F70 CD 8D 4F         CALL .SIZEDIFF
 195+ 4F73 CD D4 4F         CALL .INCREASE_COMMON
 196+ 4F76 2A F6 4E         LD HL,(ANIMSPRPTR)
 197+ 4F79 09               ADD HL,BC
 198+ 4F7A 22 F6 4E         LD (ANIMSPRPTR),HL
 199+ 4F7D              .E2:
 200+ 4F7D 2A F9 4E         LD HL,(AUTOSGAMPTR)
 201+ 4F80 09               ADD HL,BC
 202+ 4F81 22 F9 4E         LD (AUTOSGAMPTR),HL
 203+ 4F84              .E4:
 204+ 4F84 2A 10 40         LD HL,(FREEMEMPTR)
 205+ 4F87 09               ADD HL,BC
 206+ 4F88 22 10 40         LD (FREEMEMPTR),HL
 207+ 4F8B 18 DE            JR .EXIT
 208+ 4F8D              .SIZEDIFF:
 209+ 4F8D CD FB 4E         CALL Ax5
 210+ 4F90 78               LD A,B
 211+ 4F91 32 EF 4E         LD (ANIMITEMNUM),A
 212+ 4F94 44               LD B,H
 213+ 4F95 4D               LD C,L
 214+ 4F96 C9               RET ; BC=size difference in bytes
 215+ 4F97              .SIZETOMOVE:
 216+ 4F97 D5               PUSH DE
 217+ 4F98 2A 10 40         LD HL,(FREEMEMPTR)
 218+ 4F9B FD 5E 00         LD E,(IY)
 219+ 4F9E FD 56 01         LD D,(IY+1)
 220+ 4FA1 AF               XOR A
 221+ 4FA2 ED 52            SBC HL,DE
 222+ 4FA4 44               LD B,H
 223+ 4FA5 4D               LD C,L
 224+ 4FA6 D1               POP DE
 225+ 4FA7 C9               RET
 226+ 4FA8              .DECREASE_COMMON:
 227+ 4FA8 FD 6E 00         LD L,(IY)
 228+ 4FAB FD 66 01         LD H,(IY+1)
 229+ 4FAE AF               XOR A
 230+ 4FAF ED 42            SBC HL,BC
 231+ 4FB1 EB               EX DE,HL
 232+ 4FB2 C5               PUSH BC
 233+ 4FB3 CD 97 4F         CALL .SIZETOMOVE
 234+ 4FB6 F3               DI
 235+ 4FB7 78               LD A,B
 236+ 4FB8 B1               OR C
 237+ 4FB9 28 08            JR Z,.L1
 238+ 4FBB FD 6E 00         LD L,(IY)
 239+ 4FBE FD 66 01         LD H,(IY+1)
 240+ 4FC1 ED B0            LDIR
 241+ 4FC3              .L1:
 242+ 4FC3 C1               POP BC
 243+ 4FC4 FD 6E 00         LD L,(IY)
 244+ 4FC7 FD 66 01         LD H,(IY+1)
 245+ 4FCA AF               XOR A
 246+ 4FCB ED 42            SBC HL,BC
 247+ 4FCD FD 75 00         LD (IY),L
 248+ 4FD0 FD 74 01         LD (IY+1),H
 249+ 4FD3 C9               RET
 250+ 4FD4              .INCREASE_COMMON:
 251+ 4FD4 2A 10 40         LD HL,(FREEMEMPTR)
 252+ 4FD7 2B               DEC HL
 253+ 4FD8 AF               XOR A
 254+ 4FD9 ED 42            SBC HL,BC
 255+ 4FDB EB               EX DE,HL
 256+ 4FDC C5               PUSH BC
 257+ 4FDD CD 97 4F         CALL .SIZETOMOVE
 258+ 4FE0 F3               DI
 259+ 4FE1 78               LD A,B
 260+ 4FE2 B1               OR C
 261+ 4FE3 28 06            JR Z,.L2
 262+ 4FE5 2A 10 40         LD HL,(FREEMEMPTR)
 263+ 4FE8 2B               DEC HL
 264+ 4FE9 ED B8            LDDR
 265+ 4FEB              .L2:
 266+ 4FEB C1               POP BC
 267+ 4FEC FD 6E 00         LD L,(IY)
 268+ 4FEF FD 66 01         LD H,(IY+1)
 269+ 4FF2 09               ADD HL,BC
 270+ 4FF3 FD 75 00         LD (IY),L
 271+ 4FF6 FD 74 01         LD (IY+1),H
 272+ 4FF9 C9               RET
 273+ 4FFA              ; *******************************************************************************************************
 274+ 4FFA
 275+ 4FFA               IF (BASIC_EXTENSION == 1)
 276+ 4FFA ~            ; *******************************************************************************************************
 277+ 4FFA ~            ; function to handle CALL ANIMITEMPAT basic extension
 278+ 4FFA ~            ; ANIMITEMPAT ( BYTE id,
 279+ 4FFA ~            ;               INT ticks >0,
 280+ 4FFA ~            ;               BYTE pattern,
 281+ 4FFA ~            ;               BYTE color )
 282+ 4FFA ~            ; fills animation item data, returns an error if ID out of bounds
 283+ 4FFA ~            ANIMITEMPAT:
 284+ 4FFA ~                ; opening (
 285+ 4FFA ~            	CALL CHKCHAR
 286+ 4FFA ~            	DB '('
 287+ 4FFA ~            	; get id
 288+ 4FFA ~            	LD IX, GETBYT
 289+ 4FFA ~            	CALL CALBAS
 290+ 4FFA ~                PUSH AF
 291+ 4FFA ~                ; check if out of bounds
 292+ 4FFA ~                INC A
 293+ 4FFA ~                LD C,A
 294+ 4FFA ~                LD A,(ANIMITEMNUM)
 295+ 4FFA ~                CP C
 296+ 4FFA ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 297+ 4FFA ~            	; comma
 298+ 4FFA ~            	CALL CHKCHAR
 299+ 4FFA ~            	DB ','
 300+ 4FFA ~            	; get ticks
 301+ 4FFA ~            	LD IX, FRMQNT
 302+ 4FFA ~            	CALL CALBAS
 303+ 4FFA ~                LD A,D
 304+ 4FFA ~                OR E
 305+ 4FFA ~                JP Z, OVERFLOW
 306+ 4FFA ~            	PUSH DE
 307+ 4FFA ~            	; comma
 308+ 4FFA ~            	CALL CHKCHAR
 309+ 4FFA ~            	DB ','
 310+ 4FFA ~            	; get pattern
 311+ 4FFA ~            	LD IX, GETBYT
 312+ 4FFA ~            	CALL CALBAS
 313+ 4FFA ~                PUSH AF
 314+ 4FFA ~            	; comma
 315+ 4FFA ~            	CALL CHKCHAR
 316+ 4FFA ~            	DB ','
 317+ 4FFA ~            	; get color
 318+ 4FFA ~            	LD IX, GETBYT
 319+ 4FFA ~            	CALL CALBAS
 320+ 4FFA ~                PUSH AF
 321+ 4FFA ~            	; ending )
 322+ 4FFA ~            	CALL CHKCHAR
 323+ 4FFA ~            	DB ')'
 324+ 4FFA ~            .ENTRY:
 325+ 4FFA ~                PUSH HL
 326+ 4FFA ~                POP IX
 327+ 4FFA ~                EXX
 328+ 4FFA ~                POP BC ; color
 329+ 4FFA ~                POP DE ; pattern
 330+ 4FFA ~                POP HL ; ticks
 331+ 4FFA ~                EXX
 332+ 4FFA ~                POP AF
 333+ 4FFA ~                CALL GETnthANIMITEM
 334+ 4FFA ~                PUSH HL
 335+ 4FFA ~                POP IY
 336+ 4FFA ~                EXX
 337+ 4FFA ~                LD (IY),0 ; type=0
 338+ 4FFA ~                LD (IY+1),L
 339+ 4FFA ~                LD (IY+2),H
 340+ 4FFA ~                LD (IY+3),D
 341+ 4FFA ~                LD (IY+4),B
 342+ 4FFA ~
 343+ 4FFA ~                PUSH IX
 344+ 4FFA ~                POP HL
 345+ 4FFA ~                RET
 346+ 4FFA ~            ; *******************************************************************************************************
 347+ 4FFA               ENDIF
 348+ 4FFA
 349+ 4FFA               IF (DEFUSR_EXTENSION == 1)
 350+ 4FFA              ; *******************************************************************************************************
 351+ 4FFA              ; same as ANIMITEMPAT but for DEFUSR approach
 352+ 4FFA              ; input IX=pointer to input array, real data from +2
 353+ 4FFA              ; +02 = ID
 354+ 4FFA              ; +04 = ticks
 355+ 4FFA              ; +06 = pattern
 356+ 4FFA              ; +08 = color
 357+ 4FFA              ANIMITEMPAT_DEFUSR:
 358+ 4FFA                  ; check if out of bounds
 359+ 4FFA DD 4E 02         LD C,(IX+2)
 360+ 4FFD 0C               INC C
 361+ 4FFE 3A EF 4E         LD A,(ANIMITEMNUM)
 362+ 5001 B9               CP C
 363+ 5002 D8               RET C ; out of bounds, prevent memory corruption
 364+ 5003 79               LD A,C
 365+ 5004 3D               DEC A
 366+ 5005 CD 04 4F         CALL GETnthANIMITEM
 367+ 5008 36 00            LD (HL),0 ; type=0
 368+ 500A 23               INC HL
 369+ 500B DD 7E 04         LD A,(IX+4) ; ticks low
 370+ 500E 77               LD (HL),A
 371+ 500F 23               INC HL
 372+ 5010 DD 7E 05         LD A,(IX+5) ; ticks high
 373+ 5013 77               LD (HL),A
 374+ 5014 23               INC HL
 375+ 5015 DD 7E 06         LD A,(IX+6) ; pattern
 376+ 5018 77               LD (HL),A
 377+ 5019 23               INC HL
 378+ 501A DD 7E 08         LD A,(IX+8) ; color
 379+ 501D 77               LD (HL),A
 380+ 501E C9               RET
 381+ 501F              ; *******************************************************************************************************
 382+ 501F               ENDIF
 383+ 501F
 384+ 501F               IF (BASIC_EXTENSION == 1)
 385+ 501F ~            ; *******************************************************************************************************
 386+ 501F ~            ; function to handle CALL ANIMITEMPTR basic extension
 387+ 501F ~            ; ANIMITEMPTR ( BYTE id,
 388+ 501F ~            ;               INT ticks,
 389+ 501F ~            ;               INT pointer,
 390+ 501F ~            ; fills animation item data, returns an error if ID out of bounds
 391+ 501F ~            ANIMITEMPTR_CMD:
 392+ 501F ~                ; opening (
 393+ 501F ~            	CALL CHKCHAR
 394+ 501F ~            	DB '('
 395+ 501F ~            	; get id
 396+ 501F ~            	LD IX, GETBYT
 397+ 501F ~            	CALL CALBAS
 398+ 501F ~                PUSH AF
 399+ 501F ~                ; check if out of bounds
 400+ 501F ~                INC A
 401+ 501F ~                LD C,A
 402+ 501F ~                LD A,(ANIMITEMNUM)
 403+ 501F ~                CP C
 404+ 501F ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 405+ 501F ~            	; comma
 406+ 501F ~            	CALL CHKCHAR
 407+ 501F ~            	DB ','
 408+ 501F ~            	; get ticks
 409+ 501F ~            	LD IX, FRMQNT
 410+ 501F ~            	CALL CALBAS
 411+ 501F ~                LD A,D
 412+ 501F ~                OR E
 413+ 501F ~                JP Z,OVERFLOW
 414+ 501F ~            	PUSH DE
 415+ 501F ~            	; comma
 416+ 501F ~            	CALL CHKCHAR
 417+ 501F ~            	DB ','
 418+ 501F ~            	; get pointer
 419+ 501F ~            	LD IX, FRMQNT
 420+ 501F ~            	CALL CALBAS
 421+ 501F ~            	PUSH DE
 422+ 501F ~            	; ending )
 423+ 501F ~            	CALL CHKCHAR
 424+ 501F ~            	DB ')'
 425+ 501F ~            .ENTRY:
 426+ 501F ~                PUSH HL
 427+ 501F ~                POP IX
 428+ 501F ~                EXX
 429+ 501F ~                POP DE ; pointer
 430+ 501F ~                POP HL ; ticks
 431+ 501F ~                EXX
 432+ 501F ~                POP AF
 433+ 501F ~                CALL GETnthANIMITEM
 434+ 501F ~                PUSH HL
 435+ 501F ~                POP IY
 436+ 501F ~                EXX
 437+ 501F ~                LD (IY),1 ; type=1
 438+ 501F ~                LD (IY+1),L
 439+ 501F ~                LD (IY+2),H
 440+ 501F ~                LD (IY+3),E
 441+ 501F ~                LD (IY+4),D
 442+ 501F ~
 443+ 501F ~                PUSH IX
 444+ 501F ~                POP HL
 445+ 501F ~                RET
 446+ 501F ~            ; *******************************************************************************************************
 447+ 501F               ENDIF
 448+ 501F
 449+ 501F               IF (DEFUSR_EXTENSION == 1)
 450+ 501F              ; *******************************************************************************************************
 451+ 501F              ; same as ANIMITEMPTR but for DEFUSR approach
 452+ 501F              ; input IX=pointer to input array, real data from +2
 453+ 501F              ; +02 = ID
 454+ 501F              ; +04 = ticks
 455+ 501F              ; +06 = pointer
 456+ 501F              ANIMITEMPTR_DEFUSR:
 457+ 501F                  ; check if out of bounds
 458+ 501F DD 4E 02         LD C,(IX+2)
 459+ 5022 0C               INC C
 460+ 5023 3A EF 4E         LD A,(ANIMITEMNUM)
 461+ 5026 B9               CP C
 462+ 5027 D8               RET C ; out of bounds, prevent memory corruption
 463+ 5028 79               LD A,C
 464+ 5029 3D               DEC A
 465+ 502A CD 04 4F         CALL GETnthANIMITEM
 466+ 502D 36 01            LD (HL),1 ; type=1
 467+ 502F 23               INC HL
 468+ 5030 DD 7E 04         LD A,(IX+4) ; ticks low
 469+ 5033 77               LD (HL),A
 470+ 5034 23               INC HL
 471+ 5035 DD 7E 05         LD A,(IX+5) ; ticks high
 472+ 5038 77               LD (HL),A
 473+ 5039 23               INC HL
 474+ 503A DD 7E 06         LD A,(IX+6) ; pointer low
 475+ 503D 77               LD (HL),A
 476+ 503E 23               INC HL
 477+ 503F DD 7E 07         LD A,(IX+7) ; pointer high
 478+ 5042 77               LD (HL),A
 479+ 5043 C9               RET
 480+ 5044              ; *******************************************************************************************************
 481+ 5044               ENDIF
 482+ 5044
 483+ 5044               IF (DEFUSR_EXTENSION == 1)
 484+ 5044              ; *******************************************************************************************************
 485+ 5044              ; same as MAXANIMDEFS but for DEFUSR approach
 486+ 5044              ; input IX=pointer to input array, real data from +2
 487+ 5044              ; +2 = number
 488+ 5044              MAXANIMDEFS_DEFUSR:
 489+ 5044 DD 7E 02         LD A,(IX+2)
 490+ 5047 18 00            JR MAXANIMDEFS.COMMON
 491+ 5049              ; *******************************************************************************************************
 492+ 5049               ENDIF
 493+ 5049
 494+ 5049              ; *******************************************************************************************************
 495+ 5049              ; function to handle CALL MAXANIMDEFS basic extension
 496+ 5049              ; MAXANIMDEFS (BYTE number)
 497+ 5049              ; sets new number and moves memory buffers as needed
 498+ 5049              MAXANIMDEFS:
 499+ 5049               IF (BASIC_EXTENSION == 1)
 500+ 5049 ~            	; opening (
 501+ 5049 ~            	CALL CHKCHAR
 502+ 5049 ~            	DB '('
 503+ 5049 ~            	; get value
 504+ 5049 ~            	LD IX, GETBYT
 505+ 5049 ~            	CALL CALBAS
 506+ 5049 ~                PUSH AF
 507+ 5049 ~            	; ending )
 508+ 5049 ~            	CALL CHKCHAR
 509+ 5049 ~            	DB ')'
 510+ 5049 ~                POP AF
 511+ 5049               ENDIF
 512+ 5049              .COMMON:
 513+ 5049 F3               DI
 514+ 504A              	; save position
 515+ 504A E5           	PUSH HL
 516+ 504B              .ENTRY:
 517+ 504B 47               LD B,A
 518+ 504C 3A F2 4E         LD A,(ANIMDEFNUM)
 519+ 504F 90               SUB B
 520+ 5050 CA 6B 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 521+ 5053 FD 21 F6 4E      LD IY,ANIMSPRPTR
 522+ 5057 FA 63 50         JP M, .INCREASE
 523+ 505A                  ; new value is lower than previous one
 524+ 505A CD 6E 50         CALL .SIZEDIFF
 525+ 505D CD A8 4F         CALL MAXANIMITEMS.DECREASE_COMMON
 526+ 5060 C3 59 4F         JP MAXANIMITEMS.E1
 527+ 5063              .INCREASE:
 528+ 5063 ED 44            NEG
 529+ 5065 CD 6E 50         CALL .SIZEDIFF
 530+ 5068 CD D4 4F         CALL MAXANIMITEMS.INCREASE_COMMON
 531+ 506B C3 7D 4F         JP MAXANIMITEMS.E2
 532+ 506E              .SIZEDIFF:
 533+ 506E 26 00            LD H,0
 534+ 5070 6F               LD L,A
 535+ 5071 CD 6C 5D         CALL HLx16
 536+ 5074 78               LD A,B
 537+ 5075 32 F2 4E         LD (ANIMDEFNUM),A
 538+ 5078 44               LD B,H
 539+ 5079 4D               LD C,L
 540+ 507A C9               RET ; BC=size difference in bytes
 541+ 507B              ; *******************************************************************************************************
 542+ 507B
 543+ 507B               IF (BASIC_EXTENSION == 1)
 544+ 507B ~            ; *******************************************************************************************************
 545+ 507B ~            ; function to handle CALL ANIMDEF basic extension
 546+ 507B ~            ; ANIMITEMPAT ( BYTE id,
 547+ 507B ~            ;               BYTE size,
 548+ 507B ~            ;               INT[] list )
 549+ 507B ~            ; fills animation definition data, returns an error if out of bounds, or invalid type
 550+ 507B ~            ANIMDEF:
 551+ 507B ~                ; opening (
 552+ 507B ~            	CALL CHKCHAR
 553+ 507B ~            	DB '('
 554+ 507B ~            	; get id
 555+ 507B ~            	LD IX, GETBYT
 556+ 507B ~            	CALL CALBAS
 557+ 507B ~                PUSH AF
 558+ 507B ~                ; check if out of bounds
 559+ 507B ~                INC A
 560+ 507B ~                LD C,A
 561+ 507B ~                LD A,(ANIMDEFNUM)
 562+ 507B ~                CP C
 563+ 507B ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 564+ 507B ~            	; comma
 565+ 507B ~            	CALL CHKCHAR
 566+ 507B ~            	DB ','
 567+ 507B ~            	; get size
 568+ 507B ~            	LD IX, GETBYT
 569+ 507B ~            	CALL CALBAS
 570+ 507B ~                CP 16
 571+ 507B ~                JP NC, OVERFLOW
 572+ 507B ~                OR A
 573+ 507B ~                JP Z, OVERFLOW
 574+ 507B ~            	PUSH AF
 575+ 507B ~            	; comma
 576+ 507B ~            	CALL CHKCHAR
 577+ 507B ~            	DB ','
 578+ 507B ~            	; get pointer to a list of animation items in integer array format
 579+ 507B ~                ; get array pointer
 580+ 507B ~                POP DE
 581+ 507B ~                PUSH DE
 582+ 507B ~                LD A,2
 583+ 507B ~                LD B,1
 584+ 507B ~                CALL GET_BASIC_ARRAY_DATA_POINTER
 585+ 507B ~                PUSH BC
 586+ 507B ~            	; ending )
 587+ 507B ~            	CALL CHKCHAR
 588+ 507B ~            	DB ')'
 589+ 507B ~            .ENTRY:
 590+ 507B ~                PUSH HL
 591+ 507B ~                POP IX
 592+ 507B ~                POP DE ; pointer to INT array
 593+ 507B ~                POP BC ; B=item number
 594+ 507B ~                POP AF ; id
 595+ 507B ~                PUSH DE
 596+ 507B ~                CALL GETnthANIMDEF
 597+ 507B ~                POP DE
 598+ 507B ~                LD (HL),B
 599+ 507B ~            .L1:
 600+ 507B ~                INC HL
 601+ 507B ~                LD A,(DE)
 602+ 507B ~                .2 INC DE
 603+ 507B ~                LD (HL),A
 604+ 507B ~                DJNZ .L1
 605+ 507B ~                PUSH IX
 606+ 507B ~                POP HL
 607+ 507B ~                RET
 608+ 507B ~            ; *******************************************************************************************************
 609+ 507B               ENDIF
 610+ 507B
 611+ 507B               IF (DEFUSR_EXTENSION == 1)
 612+ 507B              ; *******************************************************************************************************
 613+ 507B              ; same as ANIMDEF but for DEFUSR approach
 614+ 507B              ; input IX=pointer to input array, real data from +2
 615+ 507B              ; +02 = ID
 616+ 507B              ; +04 = list size
 617+ 507B              ; +06 = list pointer
 618+ 507B              ANIMDEF_DEFUSR:
 619+ 507B                  ; check if out of bounds
 620+ 507B DD 4E 02         LD C,(IX+2)
 621+ 507E 0C               INC C
 622+ 507F 3A F2 4E         LD A,(ANIMDEFNUM)
 623+ 5082 B9               CP C
 624+ 5083 D8               RET C ; invalid id
 625+ 5084              	; get size
 626+ 5084 DD 7E 04         LD A,(IX+4)
 627+ 5087 FE 10            CP 16
 628+ 5089 D0               RET NC ; overflow
 629+ 508A B7               OR A
 630+ 508B C8               RET Z ; ID=0, invalid
 631+ 508C 47               LD B,A
 632+ 508D 79               LD A,C
 633+ 508E 3D               DEC A
 634+ 508F CD 0D 4F         CALL GETnthANIMDEF
 635+ 5092 70               LD (HL),B
 636+ 5093 DD 5E 06         LD E,(IX+6)
 637+ 5096 DD 56 07         LD D,(IX+7)
 638+ 5099              .L1:
 639+ 5099 23               INC HL
 640+ 509A 1A               LD A,(DE)
 641+ 509B 13          > INC DE
 641+ 509C 13          > INC DE
 642+ 509D 77               LD (HL),A
 643+ 509E 10 F9            DJNZ .L1
 644+ 50A0 C9               RET
 645+ 50A1              ; *******************************************************************************************************
 646+ 50A1               ENDIF
 647+ 50A1
 648+ 50A1               IF (DEFUSR_EXTENSION == 1)
 649+ 50A1              ; *******************************************************************************************************
 650+ 50A1              ; same as MAXANIMSPRS but for DEFUSR approach
 651+ 50A1              ; input IX=pointer to input array, real data from +2
 652+ 50A1              ; +2 = number
 653+ 50A1              MAXANIMSPRS_DEFUSR:
 654+ 50A1 DD 7E 02         LD A,(IX+2)
 655+ 50A4 18 00            JR MAXANIMSPRS.COMMON
 656+ 50A6              ; *******************************************************************************************************
 657+ 50A6               ENDIF
 658+ 50A6
 659+ 50A6              ; *******************************************************************************************************
 660+ 50A6              ; function to handle CALL MAXANIMSPRS basic extension
 661+ 50A6              ; MAXANIMSPRS (BYTE number)
 662+ 50A6              ; sets new number and moves memory buffers as needed
 663+ 50A6              MAXANIMSPRS:
 664+ 50A6               IF (BASIC_EXTENSION == 1)
 665+ 50A6 ~            	; opening (
 666+ 50A6 ~            	CALL CHKCHAR
 667+ 50A6 ~            	DB '('
 668+ 50A6 ~            	; get value
 669+ 50A6 ~            	LD IX, GETBYT
 670+ 50A6 ~            	CALL CALBAS
 671+ 50A6 ~                PUSH AF
 672+ 50A6 ~            	; ending )
 673+ 50A6 ~            	CALL CHKCHAR
 674+ 50A6 ~            	DB ')'
 675+ 50A6 ~                POP AF
 676+ 50A6               ENDIF
 677+ 50A6              .COMMON:
 678+ 50A6 F3               DI
 679+ 50A7              	; save position
 680+ 50A7 E5           	PUSH HL
 681+ 50A8              .ENTRY:
 682+ 50A8 47               LD B,A
 683+ 50A9 3A F5 4E         LD A,(ANIMSPRNUM)
 684+ 50AC 90               SUB B
 685+ 50AD CA 6B 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 686+ 50B0 FD 21 F9 4E      LD IY,AUTOSGAMPTR
 687+ 50B4 FA C0 50         JP M, .INCREASE
 688+ 50B7                  ; new value is lower than previous one
 689+ 50B7 CD E1 50         CALL .SIZEDIFF
 690+ 50BA CD A8 4F         CALL MAXANIMITEMS.DECREASE_COMMON
 691+ 50BD C3 62 4F         JP MAXANIMITEMS.E3
 692+ 50C0              .INCREASE:
 693+ 50C0 ED 44            NEG
 694+ 50C2 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 695+ 50C3 CD E1 50         CALL .SIZEDIFF
 696+ 50C6 CD D4 4F         CALL MAXANIMITEMS.INCREASE_COMMON
 697+ 50C9 AF               XOR A
 698+ 50CA ED 42            SBC HL,BC ; location of new stuff
 699+ 50CC F1               POP AF
 700+ 50CD C5               PUSH BC
 701+ 50CE 47               LD B,A
 702+ 50CF 11 08 00         LD DE,8
 703+ 50D2 E5               PUSH HL
 704+ 50D3 DD E1            POP IX
 705+ 50D5              .L1:
 706+ 50D5 DD 36 06 00      LD (IX+6),0 ; active flag
 707+ 50D9 DD 19            ADD IX,DE
 708+ 50DB 10 F8            DJNZ .L1
 709+ 50DD C1               POP BC
 710+ 50DE C3 84 4F         JP MAXANIMITEMS.E4
 711+ 50E1              .SIZEDIFF:
 712+ 50E1 26 00            LD H,0
 713+ 50E3 6F               LD L,A
 714+ 50E4 CD 6D 5D         CALL HLx8
 715+ 50E7 78               LD A,B
 716+ 50E8 32 F5 4E         LD (ANIMSPRNUM),A
 717+ 50EB 44               LD B,H
 718+ 50EC 4D               LD C,L
 719+ 50ED C9               RET ; BC=size difference in bytes
 720+ 50EE              ; *******************************************************************************************************
 721+ 50EE
 722+ 50EE               IF (BASIC_EXTENSION == 1)
 723+ 50EE ~            ; *******************************************************************************************************
 724+ 50EE ~            ; function to handle CALL ANIMSPRITE basic extension
 725+ 50EE ~            ; ANIMSPRITE ( BYTE id,
 726+ 50EE ~            ;              BYTE sprite_number,
 727+ 50EE ~            ;              BYTE animation_definition_id,
 728+ 50EE ~            ;              BYTE cyclic_flag )
 729+ 50EE ~            ; fills sprite animation data, returns an error if out of bounds, or invalid type
 730+ 50EE ~            ANIMSPRITE:
 731+ 50EE ~                ; opening (
 732+ 50EE ~            	CALL CHKCHAR
 733+ 50EE ~            	DB '('
 734+ 50EE ~            	; get sprite animation id
 735+ 50EE ~            	LD IX, GETBYT
 736+ 50EE ~            	CALL CALBAS
 737+ 50EE ~                PUSH AF
 738+ 50EE ~                INC A
 739+ 50EE ~                LD C,A
 740+ 50EE ~                LD A,(ANIMSPRNUM)
 741+ 50EE ~                CP C
 742+ 50EE ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 743+ 50EE ~            	; comma
 744+ 50EE ~            	CALL CHKCHAR
 745+ 50EE ~            	DB ','
 746+ 50EE ~            	; get sprite number
 747+ 50EE ~            	LD IX, GETBYT
 748+ 50EE ~            	CALL CALBAS
 749+ 50EE ~                PUSH AF
 750+ 50EE ~                ; check if out of bounds
 751+ 50EE ~                CP 32
 752+ 50EE ~                JP NC, SUBSCRIPT_OUT_OF_RANGE
 753+ 50EE ~            	; comma
 754+ 50EE ~            	CALL CHKCHAR
 755+ 50EE ~            	DB ','
 756+ 50EE ~            	; get animation definition id
 757+ 50EE ~            	LD IX, GETBYT
 758+ 50EE ~            	CALL CALBAS
 759+ 50EE ~                PUSH AF
 760+ 50EE ~                INC A
 761+ 50EE ~                LD C,A
 762+ 50EE ~                LD A,(ANIMDEFNUM)
 763+ 50EE ~                CP C
 764+ 50EE ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 765+ 50EE ~            	; comma
 766+ 50EE ~            	CALL CHKCHAR
 767+ 50EE ~            	DB ','
 768+ 50EE ~            	; get cyclic flag
 769+ 50EE ~            	LD IX, GETBYT
 770+ 50EE ~                CALL CALBAS
 771+ 50EE ~            	PUSH AF
 772+ 50EE ~            	; ending )
 773+ 50EE ~            	CALL CHKCHAR
 774+ 50EE ~            	DB ')'
 775+ 50EE ~            .ENTRY:
 776+ 50EE ~                PUSH HL
 777+ 50EE ~                POP IX
 778+ 50EE ~                EXX
 779+ 50EE ~                POP DE ; cyclic
 780+ 50EE ~                POP BC ; animation definition id
 781+ 50EE ~                POP HL ; sprite number
 782+ 50EE ~                EXX
 783+ 50EE ~                POP AF ; sprite animation id
 784+ 50EE ~                CALL GETnthSPRANIM
 785+ 50EE ~                PUSH HL
 786+ 50EE ~                POP IY
 787+ 50EE ~                EXX
 788+ 50EE ~                LD (IY),H
 789+ 50EE ~                LD (IY+4),B
 790+ 50EE ~                LD (IY+5),D
 791+ 50EE ~                ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 792+ 50EE ~                ; following will do preparation for ANIMSTEP situation
 793+ 50EE ~                ; current item set to above limit and timer to 1
 794+ 50EE ~                ; any call to ANIMSTEP will switch and setup to first item for cyclic
 795+ 50EE ~                LD (IY+3),255
 796+ 50EE ~                LD (IY+1),1
 797+ 50EE ~                LD (IY+2),0
 798+ 50EE ~                ; mark as sprite animation
 799+ 50EE ~                LD (IY+7),0
 800+ 50EE ~                PUSH IX
 801+ 50EE ~                POP HL
 802+ 50EE ~                RET
 803+ 50EE ~            ; *******************************************************************************************************
 804+ 50EE               ENDIF
 805+ 50EE
 806+ 50EE               IF (DEFUSR_EXTENSION == 1)
 807+ 50EE              ; *******************************************************************************************************
 808+ 50EE              ; same as ANIMSPRITE but for DEFUSR approach
 809+ 50EE              ; input IX=pointer to input array, real data from +2
 810+ 50EE              ; +02 = ID
 811+ 50EE              ; +04 = sprite number
 812+ 50EE              ; +06 = animation definition id
 813+ 50EE              ; +08 = cyclic flag
 814+ 50EE              ANIMSPRITE_DEFUSR:
 815+ 50EE DD 4E 02         LD C,(IX+2)
 816+ 50F1 0C               INC C
 817+ 50F2 3A F5 4E         LD A,(ANIMSPRNUM)
 818+ 50F5 B9               CP C
 819+ 50F6 D8               RET C ; invalid id
 820+ 50F7              	; get sprite number
 821+ 50F7 DD 7E 04         LD A,(IX+4)
 822+ 50FA FE 20            CP 32
 823+ 50FC D0               RET NC ; invalid sprite id
 824+ 50FD DD 46 06         LD B,(IX+6)
 825+ 5100 04               INC B
 826+ 5101 3A F2 4E         LD A,(ANIMDEFNUM)
 827+ 5104 B8               CP B
 828+ 5105 D8               RET C ; invalid animation definition id
 829+ 5106 79               LD A,C
 830+ 5107 3D               DEC A
 831+ 5108 CD 19 4F         CALL GETnthSPRANIM
 832+ 510B E5               PUSH HL
 833+ 510C DD 7E 04         LD A,(IX+4)
 834+ 510F 77               LD (HL),A ; +0
 835+ 5110 23               INC HL
 836+ 5111 36 01            LD (HL),1 ; +1
 837+ 5113 23               INC HL
 838+ 5114 36 00            LD (HL),0 ; +2
 839+ 5116 23               INC HL
 840+ 5117 36 FF            LD (HL),255 ; +3
 841+ 5119 23               INC HL
 842+ 511A 05               DEC B
 843+ 511B 70               LD (HL),B ; +4
 844+ 511C 23               INC HL
 845+ 511D DD 7E 08         LD A,(IX+8) ; +5
 846+ 5120 77               LD (HL),A
 847+ 5121 23               INC HL
 848+ 5122 23               INC HL
 849+ 5123 36 00            LD (HL),0 ; +7
 850+ 5125 C9               RET
 851+ 5126              ; *******************************************************************************************************
 852+ 5126               ENDIF
 853+ 5126
 854+ 5126
 855+ 5126               IF (BASIC_EXTENSION == 1)
 856+ 5126 ~            ; *******************************************************************************************************
 857+ 5126 ~            ; function to handle CALL ANIMCHAR basic extension
 858+ 5126 ~            ; ANIMCHAR ( BYTE id,
 859+ 5126 ~            ;            INT character number 0-767,
 860+ 5126 ~            ;            BYTE animation_definition_id,
 861+ 5126 ~            ;            BYTE cyclic_flag )
 862+ 5126 ~            ; fills sprite animation data, returns an error if out of bounds, or invalid type
 863+ 5126 ~            ANIMCHAR:
 864+ 5126 ~                ; opening (
 865+ 5126 ~            	CALL CHKCHAR
 866+ 5126 ~            	DB '('
 867+ 5126 ~            	; get sprite animation id
 868+ 5126 ~            	LD IX, GETBYT
 869+ 5126 ~            	CALL CALBAS
 870+ 5126 ~                PUSH AF
 871+ 5126 ~                INC A
 872+ 5126 ~                LD C,A
 873+ 5126 ~                LD A,(ANIMSPRNUM)
 874+ 5126 ~                CP C
 875+ 5126 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 876+ 5126 ~            	; comma
 877+ 5126 ~            	CALL CHKCHAR
 878+ 5126 ~            	DB ','
 879+ 5126 ~            	; get character number
 880+ 5126 ~            	LD IX, FRMQNT
 881+ 5126 ~            	CALL CALBAS
 882+ 5126 ~                PUSH DE
 883+ 5126 ~                ; check if out of bounds
 884+ 5126 ~                LD A,D
 885+ 5126 ~                CP 3
 886+ 5126 ~                JP NC, SUBSCRIPT_OUT_OF_RANGE
 887+ 5126 ~            	; comma
 888+ 5126 ~            	CALL CHKCHAR
 889+ 5126 ~            	DB ','
 890+ 5126 ~            	; get animation definition id
 891+ 5126 ~            	LD IX, GETBYT
 892+ 5126 ~            	CALL CALBAS
 893+ 5126 ~                PUSH AF
 894+ 5126 ~                INC A
 895+ 5126 ~                LD C,A
 896+ 5126 ~                LD A,(ANIMDEFNUM)
 897+ 5126 ~                CP C
 898+ 5126 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 899+ 5126 ~            	; comma
 900+ 5126 ~            	CALL CHKCHAR
 901+ 5126 ~            	DB ','
 902+ 5126 ~            	; get cyclic flag
 903+ 5126 ~            	LD IX, GETBYT
 904+ 5126 ~                CALL CALBAS
 905+ 5126 ~            	PUSH AF
 906+ 5126 ~            	; ending )
 907+ 5126 ~            	CALL CHKCHAR
 908+ 5126 ~            	DB ')'
 909+ 5126 ~            .ENTRY:
 910+ 5126 ~                PUSH HL
 911+ 5126 ~                POP IX
 912+ 5126 ~                EXX
 913+ 5126 ~                POP DE ; cyclic
 914+ 5126 ~                POP BC ; animation definition id
 915+ 5126 ~                POP HL ; character number
 916+ 5126 ~                EXX
 917+ 5126 ~                POP AF ; sprite animation id
 918+ 5126 ~                CALL GETnthSPRANIM
 919+ 5126 ~                PUSH HL
 920+ 5126 ~                POP IY
 921+ 5126 ~                EXX
 922+ 5126 ~                LD (IY),L
 923+ 5126 ~                INC H ; save character bank+1
 924+ 5126 ~                LD (IY+7),H
 925+ 5126 ~                LD (IY+4),B
 926+ 5126 ~                LD (IY+5),D
 927+ 5126 ~                ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 928+ 5126 ~                ; following will do preparation for ANIMSTEP situation
 929+ 5126 ~                ; current item set to above limit and timer to 1
 930+ 5126 ~                ; any call to ANIMSTEP will switch and setup to first item for cyclic
 931+ 5126 ~                LD (IY+3),255
 932+ 5126 ~                LD (IY+1),1
 933+ 5126 ~                LD (IY+2),0
 934+ 5126 ~                PUSH IX
 935+ 5126 ~                POP HL
 936+ 5126 ~                RET
 937+ 5126 ~            ; *******************************************************************************************************
 938+ 5126               ENDIF
 939+ 5126
 940+ 5126               IF (DEFUSR_EXTENSION == 1)
 941+ 5126              ; *******************************************************************************************************
 942+ 5126              ; same as ANIMCHAR but for DEFUSR approach
 943+ 5126              ; input IX=pointer to input array, real data from +2
 944+ 5126              ; +02 = ID
 945+ 5126              ; +04 = character number
 946+ 5126              ; +06 = animation definition id
 947+ 5126              ; +08 = cyclic flag
 948+ 5126              ANIMCHAR_DEFUSR:
 949+ 5126 DD 4E 02         LD C,(IX+2)
 950+ 5129 0C               INC C
 951+ 512A 3A F5 4E         LD A,(ANIMSPRNUM)
 952+ 512D B9               CP C
 953+ 512E D8               RET C ; invalid id
 954+ 512F              	; get sprite number
 955+ 512F DD 7E 05         LD A,(IX+5)
 956+ 5132 FE 03            CP 3
 957+ 5134 D0               RET NC ; invalid character (>767)
 958+ 5135 DD 46 06         LD B,(IX+6)
 959+ 5138 04               INC B
 960+ 5139 3A F2 4E         LD A,(ANIMDEFNUM)
 961+ 513C B8               CP B
 962+ 513D D8               RET C ; invalid animation definition id
 963+ 513E 79               LD A,C
 964+ 513F 3D               DEC A
 965+ 5140 CD 19 4F         CALL GETnthSPRANIM
 966+ 5143 E5               PUSH HL
 967+ 5144 DD 7E 04         LD A,(IX+4)
 968+ 5147 77               LD (HL),A ; +0
 969+ 5148 23               INC HL
 970+ 5149 36 01            LD (HL),1 ; +1
 971+ 514B 23               INC HL
 972+ 514C 36 00            LD (HL),0 ; +2
 973+ 514E 23               INC HL
 974+ 514F 36 FF            LD (HL),255 ; +3
 975+ 5151 23               INC HL
 976+ 5152 05               DEC B
 977+ 5153 70               LD (HL),B ; +4
 978+ 5154 23               INC HL
 979+ 5155 DD 7E 08         LD A,(IX+8) ; +5
 980+ 5158 77               LD (HL),A
 981+ 5159 23               INC HL
 982+ 515A 23               INC HL
 983+ 515B DD 7E 05         LD A,(IX+5)
 984+ 515E 3C               INC A
 985+ 515F 77               LD (HL),A ; +7
 986+ 5160 C9               RET
 987+ 5161              ; *******************************************************************************************************
 988+ 5161               ENDIF
 989+ 5161
 990+ 5161               IF (DEFUSR_EXTENSION == 1)
 991+ 5161              ; *******************************************************************************************************
 992+ 5161              ; same as MAXAUTOSGAMS but for DEFUSR approach
 993+ 5161              ; input IX=pointer to input array, real data from +2
 994+ 5161              ; +2 = number
 995+ 5161              MAXAUTOSGAMS_DEFUSR:
 996+ 5161 DD 7E 02         LD A,(IX+2)
 997+ 5164 18 00            JR MAXAUTOSGAMS.COMMON
 998+ 5166              ; *******************************************************************************************************
 999+ 5166               ENDIF
1000+ 5166
1001+ 5166              ; *******************************************************************************************************
1002+ 5166              ; function to handle CALL MAXAUTOSGAMS basic extension
1003+ 5166              ; MAXAUTOSGAMS (BYTE number)
1004+ 5166              ; sets new number and moves memory buffers as needed
1005+ 5166              MAXAUTOSGAMS:
1006+ 5166               IF (BASIC_EXTENSION == 1)
1007+ 5166 ~            	; opening (
1008+ 5166 ~            	CALL CHKCHAR
1009+ 5166 ~            	DB '('
1010+ 5166 ~            	; get value
1011+ 5166 ~            	LD IX, GETBYT
1012+ 5166 ~            	CALL CALBAS
1013+ 5166 ~                PUSH AF
1014+ 5166 ~            	; ending )
1015+ 5166 ~            	CALL CHKCHAR
1016+ 5166 ~            	DB ')'
1017+ 5166 ~                POP AF
1018+ 5166               ENDIF
1019+ 5166              .COMMON:
1020+ 5166 F3               DI
1021+ 5167              	; save position
1022+ 5167 E5           	PUSH HL
1023+ 5168              .ENTRY:
1024+ 5168 47               LD B,A
1025+ 5169 3A F8 4E         LD A,(AUTOSGAMNUM)
1026+ 516C 90               SUB B
1027+ 516D CA 6B 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
1028+ 5170 FD 21 10 40      LD IY,FREEMEMPTR
1029+ 5174 FA 80 51         JP M, .INCREASE
1030+ 5177                  ; new value is lower than previous one
1031+ 5177 CD A1 51         CALL .SIZEDIFF
1032+ 517A CD A8 4F         CALL MAXANIMITEMS.DECREASE_COMMON
1033+ 517D C3 6B 4F         JP MAXANIMITEMS.EXIT
1034+ 5180              .INCREASE:
1035+ 5180 ED 44            NEG
1036+ 5182 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
1037+ 5183 CD A1 51         CALL .SIZEDIFF
1038+ 5186 CD D4 4F         CALL MAXANIMITEMS.INCREASE_COMMON
1039+ 5189 AF               XOR A
1040+ 518A ED 42            SBC HL,BC ; location of new stuff
1041+ 518C F1               POP AF
1042+ 518D C5               PUSH BC
1043+ 518E 47               LD B,A
1044+ 518F 11 18 00         LD DE,24
1045+ 5192 E5               PUSH HL
1046+ 5193 DD E1            POP IX
1047+ 5195              .L1:
1048+ 5195 DD 36 13 00      LD (IX+19),0 ; active flag
1049+ 5199 DD 19            ADD IX,DE
1050+ 519B 10 F8            DJNZ .L1
1051+ 519D C1               POP BC
1052+ 519E C3 6B 4F         JP MAXANIMITEMS.EXIT
1053+ 51A1              .SIZEDIFF:
1054+ 51A1 26 00            LD H,0
1055+ 51A3 6F               LD L,A
1056+ 51A4 CD 6D 5D         CALL HLx8
1057+ 51A7 54               LD D,H
1058+ 51A8 5D               LD E,L
1059+ 51A9 29               ADD HL,HL
1060+ 51AA 19               ADD HL,DE
1061+ 51AB 78               LD A,B
1062+ 51AC 32 F8 4E         LD (AUTOSGAMNUM),A
1063+ 51AF 44               LD B,H
1064+ 51B0 4D               LD C,L
1065+ 51B1 C9               RET ; BC=size difference in bytes
1066+ 51B2              ; *******************************************************************************************************
1067+ 51B2
1068+ 51B2               IF (BASIC_EXTENSION == 1)
1069+ 51B2 ~            ; *******************************************************************************************************
1070+ 51B2 ~            ; function to handle CALL AUTOSGAMDEF basic extension
1071+ 51B2 ~            ; AUTOSGAMDEF ( BYTE id,
1072+ 51B2 ~            ;               INT VARIABLE x, INT VARIABLE y,
1073+ 51B2 ~            ;               INT minimum, INT maximum, INT delta,
1074+ 51B2 ~            ;               INT direction =0 horizontal,
1075+ 51B2 ~            ;               INT ticks,
1076+ 51B2 ~            ;               BYTE sprite_group_count,
1077+ 51B2 ~            ;               INT[2][sprite_group_count] VARIABLE sprite_group,
1078+ 51B2 ~            ;               BYTE item_number,
1079+ 51B2 ~            ;               INT[] VARIABLE sprite_animations_negative_direction,
1080+ 51B2 ~            ;               INT[] VARIABLE sprite_animations_positive_direction
1081+ 51B2 ~            AUTOSGAMDEF:
1082+ 51B2 ~                ; opening (
1083+ 51B2 ~            	CALL CHKCHAR
1084+ 51B2 ~            	DB '('
1085+ 51B2 ~            	; get sprite animation id
1086+ 51B2 ~            	LD IX, GETBYT
1087+ 51B2 ~            	CALL CALBAS
1088+ 51B2 ~                PUSH AF
1089+ 51B2 ~                INC A
1090+ 51B2 ~                LD C,A
1091+ 51B2 ~                LD A,(AUTOSGAMNUM)
1092+ 51B2 ~                CP C
1093+ 51B2 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
1094+ 51B2 ~                POP AF
1095+ 51B2 ~                PUSH HL
1096+ 51B2 ~                CALL GETnthAUTOSGAM
1097+ 51B2 ~                LD (BLIT_TMP),HL ; for later
1098+ 51B2 ~                POP HL
1099+ 51B2 ~            	; comma
1100+ 51B2 ~            	CALL CHKCHAR
1101+ 51B2 ~            	DB ','
1102+ 51B2 ~            	; get address of the X coordinate variable
1103+ 51B2 ~            	LD IX, PTRGET
1104+ 51B2 ~            	CALL CALBAS
1105+ 51B2 ~            	LD IX,(BLIT_TMP)
1106+ 51B2 ~                LD (IX+0),E
1107+ 51B2 ~                LD (IX+1),D
1108+ 51B2 ~            	; comma
1109+ 51B2 ~            	CALL CHKCHAR
1110+ 51B2 ~            	DB ','
1111+ 51B2 ~            	; get address of the Y coordinate variable
1112+ 51B2 ~            	LD IX, PTRGET
1113+ 51B2 ~            	CALL CALBAS
1114+ 51B2 ~            	LD IX,(BLIT_TMP)
1115+ 51B2 ~                LD (IX+2),E
1116+ 51B2 ~                LD (IX+3),D
1117+ 51B2 ~            	; comma
1118+ 51B2 ~            	CALL CHKCHAR
1119+ 51B2 ~            	DB ','
1120+ 51B2 ~            	; get minimum value
1121+ 51B2 ~            	LD IX, FRMQNT
1122+ 51B2 ~            	CALL CALBAS
1123+ 51B2 ~            	LD IX,(BLIT_TMP)
1124+ 51B2 ~                LD (IX+4),E
1125+ 51B2 ~                LD (IX+5),D
1126+ 51B2 ~            	; comma
1127+ 51B2 ~            	CALL CHKCHAR
1128+ 51B2 ~            	DB ','
1129+ 51B2 ~            	; get maximum value
1130+ 51B2 ~            	LD IX, FRMQNT
1131+ 51B2 ~            	CALL CALBAS
1132+ 51B2 ~            	LD IX,(BLIT_TMP)
1133+ 51B2 ~                LD (IX+6),E
1134+ 51B2 ~                LD (IX+7),D
1135+ 51B2 ~            	; comma
1136+ 51B2 ~            	CALL CHKCHAR
1137+ 51B2 ~            	DB ','
1138+ 51B2 ~            	; get delta value
1139+ 51B2 ~            	LD IX, FRMQNT
1140+ 51B2 ~            	CALL CALBAS
1141+ 51B2 ~            	LD IX,(BLIT_TMP)
1142+ 51B2 ~                LD (IX+8),E
1143+ 51B2 ~                LD (IX+9),D
1144+ 51B2 ~            	; comma
1145+ 51B2 ~            	CALL CHKCHAR
1146+ 51B2 ~            	DB ','
1147+ 51B2 ~            	; get direction value
1148+ 51B2 ~            	LD IX, FRMQNT
1149+ 51B2 ~            	CALL CALBAS
1150+ 51B2 ~            	LD IX,(BLIT_TMP)
1151+ 51B2 ~                LD (IX+10),E
1152+ 51B2 ~            	; comma
1153+ 51B2 ~            	CALL CHKCHAR
1154+ 51B2 ~            	DB ','
1155+ 51B2 ~            	; get ticks value
1156+ 51B2 ~            	LD IX, FRMQNT
1157+ 51B2 ~            	CALL CALBAS
1158+ 51B2 ~            	LD IX,(BLIT_TMP)
1159+ 51B2 ~                LD (IX+20),E
1160+ 51B2 ~                LD (IX+21),D
1161+ 51B2 ~            	; comma
1162+ 51B2 ~            	CALL CHKCHAR
1163+ 51B2 ~            	DB ','
1164+ 51B2 ~            	; get sprite group count
1165+ 51B2 ~            	LD IX, GETBYT
1166+ 51B2 ~            	CALL CALBAS
1167+ 51B2 ~                OR A
1168+ 51B2 ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
1169+ 51B2 ~            	LD IX,(BLIT_TMP)
1170+ 51B2 ~                LD (IX+11),A
1171+ 51B2 ~            	; comma
1172+ 51B2 ~            	CALL CHKCHAR
1173+ 51B2 ~            	DB ','
1174+ 51B2 ~            	; get sprite group definition array data pointer
1175+ 51B2 ~            	LD IX,(BLIT_TMP)
1176+ 51B2 ~                LD E,(IX+11)
1177+ 51B2 ~            	LD D,3
1178+ 51B2 ~            	LD A,2
1179+ 51B2 ~            	LD B,A
1180+ 51B2 ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
1181+ 51B2 ~            	LD IX,(BLIT_TMP)
1182+ 51B2 ~            	LD (IX+12),C
1183+ 51B2 ~                LD (IX+13),B
1184+ 51B2 ~            	; comma
1185+ 51B2 ~            	CALL CHKCHAR
1186+ 51B2 ~            	DB ','
1187+ 51B2 ~            	; get sprite animation array size
1188+ 51B2 ~            	LD IX,GETBYT
1189+ 51B2 ~            	CALL CALBAS
1190+ 51B2 ~            	LD IX,(BLIT_TMP)
1191+ 51B2 ~                LD (IX+14),A
1192+ 51B2 ~                OR A
1193+ 51B2 ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
1194+ 51B2 ~            	; comma
1195+ 51B2 ~            	CALL CHKCHAR
1196+ 51B2 ~            	DB ','
1197+ 51B2 ~                ; get array pointer for negative direction
1198+ 51B2 ~            	LD IX,(BLIT_TMP)
1199+ 51B2 ~                LD D,(IX+14)
1200+ 51B2 ~                LD A,2
1201+ 51B2 ~                LD B,1
1202+ 51B2 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
1203+ 51B2 ~            	LD IX,(BLIT_TMP)
1204+ 51B2 ~                LD (IX+15),C
1205+ 51B2 ~                LD (IX+16),B
1206+ 51B2 ~            	; comma
1207+ 51B2 ~            	CALL CHKCHAR
1208+ 51B2 ~            	DB ','
1209+ 51B2 ~                ; get array pointer for positive direction
1210+ 51B2 ~            	LD IX,(BLIT_TMP)
1211+ 51B2 ~                LD D,(IX+14)
1212+ 51B2 ~                LD A,2
1213+ 51B2 ~                LD B,1
1214+ 51B2 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
1215+ 51B2 ~            	LD IX,(BLIT_TMP)
1216+ 51B2 ~                LD (IX+17),C
1217+ 51B2 ~                LD (IX+18),B
1218+ 51B2 ~            	; ending )
1219+ 51B2 ~            	CALL CHKCHAR
1220+ 51B2 ~            	DB ')'
1221+ 51B2 ~                RET
1222+ 51B2 ~            ; *******************************************************************************************************
1223+ 51B2               ENDIF
1224+ 51B2
1225+ 51B2               IF (DEFUSR_EXTENSION == 1)
1226+ 51B2              ; *******************************************************************************************************
1227+ 51B2              ; same as AUTOSGAMDEF but for DEFUSR approach
1228+ 51B2              ; input IX=pointer to input array, real data from +2
1229+ 51B2              ; +02 = ID
1230+ 51B2              ; +04 = pointer to X variable
1231+ 51B2              ; +06 = pointer to Y variable
1232+ 51B2              ; +08 = minimum
1233+ 51B2              ; +10 = maximum
1234+ 51B2              ; +12 = delta
1235+ 51B2              ; +14 = direction
1236+ 51B2              ; +16 = ticks
1237+ 51B2              ; +18 = sprite group count
1238+ 51B2              ; +20 = sprite group array pointer
1239+ 51B2              ; +22 = item number
1240+ 51B2              ; +24 = sprite animations negative direction array pointer
1241+ 51B2              ; +26 = sprite animations positive direction array pointer
1242+ 51B2              AUTOSGAMDEF_DEFUSR:
1243+ 51B2 DD 4E 02         LD C,(IX+2)
1244+ 51B5 0C               INC C
1245+ 51B6 3A F8 4E         LD A,(AUTOSGAMNUM)
1246+ 51B9 B9               CP C
1247+ 51BA D8               RET C ; invalid id
1248+ 51BB 79               LD A,C
1249+ 51BC 3D               DEC A
1250+ 51BD CD 25 4F         CALL GETnthAUTOSGAM
1251+ 51C0 E5               PUSH HL
1252+ 51C1 FD E1            POP IY
1253+ 51C3                  ; X variable
1254+ 51C3 DD 7E 04         LD A,(IX+4)
1255+ 51C6 FD 77 00         LD (IY+0),A
1256+ 51C9 DD 7E 05         LD A,(IX+5)
1257+ 51CC FD 77 01         LD (IY+1),A
1258+ 51CF              	; Y variable
1259+ 51CF DD 7E 06         LD A,(IX+6)
1260+ 51D2 FD 77 02         LD (IY+2),A
1261+ 51D5 DD 7E 07         LD A,(IX+7)
1262+ 51D8 FD 77 03         LD (IY+3),A
1263+ 51DB              	; get minimum value
1264+ 51DB DD 7E 08         LD A,(IX+8)
1265+ 51DE FD 77 04         LD (IY+4),A
1266+ 51E1 DD 7E 09         LD A,(IX+9)
1267+ 51E4 FD 77 05         LD (IY+5),A
1268+ 51E7              	; get maximum value
1269+ 51E7 DD 7E 0A         LD A,(IX+10)
1270+ 51EA FD 77 06         LD (IY+6),A
1271+ 51ED DD 7E 0B         LD A,(IX+11)
1272+ 51F0 FD 77 07         LD (IY+7),A
1273+ 51F3              	; get delta value
1274+ 51F3 DD 7E 0C         LD A,(IX+12)
1275+ 51F6 FD 77 08         LD (IY+8),A
1276+ 51F9 DD 7E 0D         LD A,(IX+13)
1277+ 51FC FD 77 09         LD (IY+9),A
1278+ 51FF              	; get direction value
1279+ 51FF DD 7E 0E         LD A,(IX+14)
1280+ 5202 FD 77 0A         LD (IY+10),A
1281+ 5205              	; get ticks value
1282+ 5205 DD 7E 10         LD A,(IX+16)
1283+ 5208 FD 77 14         LD (IY+20),A
1284+ 520B DD 7E 11         LD A,(IX+17)
1285+ 520E FD 77 15         LD (IY+21),A
1286+ 5211              	; get sprite group count
1287+ 5211 DD 7E 12         LD A,(IX+18)
1288+ 5214 FD 77 0B         LD (IY+11),A
1289+ 5217              	; get sprite group definition array data pointer
1290+ 5217 DD 7E 14         LD A,(IX+20)
1291+ 521A FD 77 0C         LD (IY+12),A
1292+ 521D DD 7E 15         LD A,(IX+21)
1293+ 5220 FD 77 0D         LD (IY+13),A
1294+ 5223              	; get sprite animation array size
1295+ 5223 DD 7E 16         LD A,(IX+22)
1296+ 5226 FD 77 0E         LD (IY+14),A
1297+ 5229                  ; get array pointer for negative direction
1298+ 5229 DD 7E 18         LD A,(IX+24)
1299+ 522C FD 77 0F         LD (IY+15),A
1300+ 522F DD 7E 19         LD A,(IX+25)
1301+ 5232 FD 77 10         LD (IY+16),A
1302+ 5235                  ; get array pointer for positive direction
1303+ 5235 DD 7E 1A         LD A,(IX+26)
1304+ 5238 FD 77 11         LD (IY+17),A
1305+ 523B DD 7E 1B         LD A,(IX+27)
1306+ 523E FD 77 12         LD (IY+18),A
1307+ 5241              ; *******************************************************************************************************
1308+ 5241               ENDIF
1309+ 5241
1310+ 5241               IF (BASIC_EXTENSION == 1)
1311+ 5241 ~            ; *******************************************************************************************************
1312+ 5241 ~            ; function to handle CALL AUTOSGAMSTART basic extension
1313+ 5241 ~            ; AUTOSGAMSTART ( BYTE id )
1314+ 5241 ~            AUTOSGAMSTART:
1315+ 5241 ~                LD A,1
1316+ 5241 ~            .COMMON:
1317+ 5241 ~                LD (.SETVALUE+3),A
1318+ 5241 ~                ; opening (
1319+ 5241 ~            	CALL CHKCHAR
1320+ 5241 ~            	DB '('
1321+ 5241 ~            	; get sprite animation id
1322+ 5241 ~            	LD IX, GETBYT
1323+ 5241 ~            	CALL CALBAS
1324+ 5241 ~                PUSH AF
1325+ 5241 ~                INC A
1326+ 5241 ~                LD C,A
1327+ 5241 ~                LD A,(AUTOSGAMNUM)
1328+ 5241 ~                CP C
1329+ 5241 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
1330+ 5241 ~                POP AF
1331+ 5241 ~                PUSH HL
1332+ 5241 ~                CALL GETnthAUTOSGAM
1333+ 5241 ~                PUSH HL
1334+ 5241 ~                POP IX
1335+ 5241 ~                POP HL
1336+ 5241 ~                PUSH IX
1337+ 5241 ~            	; ending )
1338+ 5241 ~            	CALL CHKCHAR
1339+ 5241 ~            	DB ')'
1340+ 5241 ~
1341+ 5241 ~                ; so syntax is fine
1342+ 5241 ~                POP IX
1343+ 5241 ~            .SETVALUE:
1344+ 5241 ~                LD (IX+19),1 ; active flag
1345+ 5241 ~                ; set initial timer
1346+ 5241 ~                LD A,(IX+20)
1347+ 5241 ~                LD (IX+22),A
1348+ 5241 ~                LD A,(IX+21)
1349+ 5241 ~                LD (IX+23),A
1350+ 5241 ~                RET
1351+ 5241 ~            ; *******************************************************************************************************
1352+ 5241 ~
1353+ 5241 ~            ; *******************************************************************************************************
1354+ 5241 ~            ; function to handle CALL AUTOSGAMSTOP basic extension
1355+ 5241 ~            ; AUTOSGAMSTOP ( BYTE id )
1356+ 5241 ~            AUTOSGAMSTOP:
1357+ 5241 ~                XOR A
1358+ 5241 ~                JR AUTOSGAMSTART.COMMON
1359+ 5241 ~            ; *******************************************************************************************************
1360+ 5241               ENDIF
1361+ 5241
1362+ 5241               IF (DEFUSR_EXTENSION == 1)
1363+ 5241              ; *******************************************************************************************************
1364+ 5241              ; function to handle CALL AUTOSGAMSTART basic extension in DEFUSR mode
1365+ 5241              ; input IX=pointer to input array, real data from +2
1366+ 5241              ; +2 = source address
1367+ 5241              AUTOSGAMSTART_DEFUSR:
1368+ 5241 3E 01            LD A,1
1369+ 5243              .COMMON:
1370+ 5243 32 5A 52         LD (.SETVALUE+3),A
1371+ 5246 DD 4E 02         LD C,(IX+2)
1372+ 5249 0C               INC C
1373+ 524A 3A F8 4E         LD A,(AUTOSGAMNUM)
1374+ 524D B9               CP C
1375+ 524E D8               RET C ; invalid id
1376+ 524F 79               LD A,C
1377+ 5250 3D               DEC A
1378+ 5251 CD 25 4F         CALL GETnthAUTOSGAM
1379+ 5254 E5               PUSH HL
1380+ 5255 DD E1            POP IX
1381+ 5257              .SETVALUE:
1382+ 5257 DD 36 13 01      LD (IX+19),1 ; active flag
1383+ 525B                  ; set initial timer
1384+ 525B DD 7E 14         LD A,(IX+20)
1385+ 525E DD 77 16         LD (IX+22),A
1386+ 5261 DD 7E 15         LD A,(IX+21)
1387+ 5264 DD 77 17         LD (IX+23),A
1388+ 5267 C9               RET
1389+ 5268              ; *******************************************************************************************************
1390+ 5268
1391+ 5268              ; *******************************************************************************************************
1392+ 5268              ; function to handle CALL AUTOSGAMSTOP basic extension in DEFUSR mode
1393+ 5268              ; input IX=pointer to input array, real data from +2
1394+ 5268              ; +2 = source address
1395+ 5268              AUTOSGAMSTOP_DEFUSR:
1396+ 5268 AF               XOR A
1397+ 5269 18 D8            JR AUTOSGAMSTART_DEFUSR.COMMON
1398+ 526B              ; *******************************************************************************************************
1399+ 526B               ENDIF
1400+ 526B
1401+ 526B               IF (BASIC_EXTENSION == 1)
1402+ 526B ~            ; *******************************************************************************************************
1403+ 526B ~            ; function to handle CALL ANIMSTEP basic extension
1404+ 526B ~            ; two forms
1405+ 526B ~            ; ANIMSTEP ( BYTE id )
1406+ 526B ~            ; or
1407+ 526B ~            ; ANIMSTEP ( BYTE item_number,
1408+ 526B ~            ;            INT[] sprite_animations )
1409+ 526B ~            ANIMSTEP:
1410+ 526B ~                LD DE,ANIMSTARTSTOP_COMMON.STEP
1411+ 526B ~                JR ANIMSTARTSTOP_COMMON
1412+ 526B ~            ; *******************************************************************************************************
1413+ 526B ~            ; *******************************************************************************************************
1414+ 526B ~            ; function to handle CALL ANIMSTART basic extension
1415+ 526B ~            ; two forms
1416+ 526B ~            ; ANIMSTART ( BYTE id )
1417+ 526B ~            ; or
1418+ 526B ~            ; ANIMSTART ( BYTE item_number,
1419+ 526B ~            ;             INT[] sprite_animations )
1420+ 526B ~            ; sets active flag to 1
1421+ 526B ~            ANIMSTART:
1422+ 526B ~                LD DE,ANIMSTARTSTOP_COMMON.START
1423+ 526B ~                JR ANIMSTARTSTOP_COMMON
1424+ 526B ~            ; *******************************************************************************************************
1425+ 526B ~            ; *******************************************************************************************************
1426+ 526B ~            ; function to handle CALL ANIMSTOP basic extension
1427+ 526B ~            ; two forms
1428+ 526B ~            ; ANIMSTOP ( BYTE id )
1429+ 526B ~            ; or
1430+ 526B ~            ; ANIMSTOP ( BYTE item_number,
1431+ 526B ~            ;            INT[] sprite_animations )
1432+ 526B ~            ; sets active flag to 0
1433+ 526B ~            ANIMSTOP:
1434+ 526B ~                LD DE,ANIMSTARTSTOP_COMMON.STOP
1435+ 526B ~            ; *******************************************************************************************************
1436+ 526B ~            ANIMSTARTSTOP_COMMON:
1437+ 526B ~                LD (ANIMSTARTSTOP_COMMON.FN+1),DE
1438+ 526B ~                ; opening (
1439+ 526B ~            	CALL CHKCHAR
1440+ 526B ~            	DB '('
1441+ 526B ~            	; get sprite animation id or array size
1442+ 526B ~            	LD IX,GETBYT
1443+ 526B ~            	CALL CALBAS
1444+ 526B ~                PUSH AF
1445+ 526B ~                ; check if comma present
1446+ 526B ~                CALL GETPREVCHAR
1447+ 526B ~                INC HL
1448+ 526B ~                CP ','
1449+ 526B ~                JR Z,.L1
1450+ 526B ~                CP ')'
1451+ 526B ~                JP NZ,SYNTAX_ERROR
1452+ 526B ~                ; ok so single argument variant
1453+ 526B ~                POP AF
1454+ 526B ~                PUSH HL
1455+ 526B ~                DI
1456+ 526B ~                CALL .SETVALUE
1457+ 526B ~                EI
1458+ 526B ~                POP HL
1459+ 526B ~                RET
1460+ 526B ~            .L1:
1461+ 526B ~                ; get array pointer
1462+ 526B ~                POP DE
1463+ 526B ~                PUSH DE
1464+ 526B ~                LD A,2
1465+ 526B ~                LD B,1
1466+ 526B ~                CALL GET_BASIC_ARRAY_DATA_POINTER
1467+ 526B ~                PUSH BC
1468+ 526B ~            	; ending )
1469+ 526B ~            	CALL CHKCHAR
1470+ 526B ~            	DB ')'
1471+ 526B ~                POP DE ; array pointer
1472+ 526B ~                POP BC ; number of items
1473+ 526B ~                LD A,B
1474+ 526B ~                OR A
1475+ 526B ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
1476+ 526B ~                PUSH HL
1477+ 526B ~                DI
1478+ 526B ~            .L2:
1479+ 526B ~                PUSH BC
1480+ 526B ~                LD A,(DE)
1481+ 526B ~                .2 INC DE
1482+ 526B ~                PUSH DE
1483+ 526B ~                CALL .SETVALUE
1484+ 526B ~                POP DE
1485+ 526B ~                POP BC
1486+ 526B ~                DJNZ .L2
1487+ 526B ~                EI
1488+ 526B ~                POP HL
1489+ 526B ~                RET
1490+ 526B ~
1491+ 526B ~            .SETVALUE:
1492+ 526B ~                LD B,A
1493+ 526B ~                INC A
1494+ 526B ~                LD C,A
1495+ 526B ~                LD A,(ANIMSPRNUM)
1496+ 526B ~                CP C
1497+ 526B ~                JP C,SUBSCRIPT_OUT_OF_RANGE
1498+ 526B ~                LD A,B
1499+ 526B ~                CALL GETnthSPRANIM
1500+ 526B ~                PUSH HL
1501+ 526B ~                POP IX
1502+ 526B ~            .FN:
1503+ 526B ~                JP 0
1504+ 526B ~            .START:
1505+ 526B ~                LD (IX+6),1 ; active flag
1506+ 526B ~                LD (IX+3),0 ; current item
1507+ 526B ~                LD B,0 ; setup timer
1508+ 526B ~                JP SETUP_ANIM_STEP
1509+ 526B ~            .STOP:
1510+ 526B ~                LD (IX+6),0 ; active flag
1511+ 526B ~                RET
1512+ 526B ~            .STEP:
1513+ 526B ~                LD B,0
1514+ 526B ~                JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1515+ 526B ~            ; *******************************************************************************************************
1516+ 526B               ENDIF
1517+ 526B
1518+ 526B              ; *******************************************************************************************************
1519+ 526B              ; helper function to locate single animation and execute operation
1520+ 526B              ; needs to have jump set to a correct function
1521+ 526B              ; used by SGAM helper routines so always needed
1522+ 526B              ; input A=animation item
1523+ 526B              ANIM_SETVALUE:
1524+ 526B 47               LD B,A
1525+ 526C 3C               INC A
1526+ 526D 4F               LD C,A
1527+ 526E 3A F5 4E         LD A,(ANIMSPRNUM)
1528+ 5271 B9               CP C
1529+ 5272 D8               RET C ; out of range, so do nothing
1530+ 5273 78               LD A,B
1531+ 5274 CD 19 4F         CALL GETnthSPRANIM
1532+ 5277 E5               PUSH HL
1533+ 5278 DD E1            POP IX
1534+ 527A              .FN:
1535+ 527A C3 00 00         JP 0
1536+ 527D              ; *******************************************************************************************************
1537+ 527D
1538+ 527D               IF (DEFUSR_EXTENSION == 1)
1539+ 527D              ; *******************************************************************************************************
1540+ 527D              ; helper function to set values of multiple animations
1541+ 527D              ; needs to have jump set to a correct function
1542+ 527D              ; input B=number of animation item
1543+ 527D              ; input DE=animation item array
1544+ 527D              ANIM_LIST_SETVALUE:
1545+ 527D F3               DI
1546+ 527E C5               PUSH BC
1547+ 527F 1A               LD A,(DE)
1548+ 5280 13          > INC DE
1548+ 5281 13          > INC DE
1549+ 5282 D5               PUSH DE
1550+ 5283 CD 6B 52         CALL ANIM_SETVALUE
1551+ 5286 D1               POP DE
1552+ 5287 C1               POP BC
1553+ 5288 10 F3            DJNZ ANIM_LIST_SETVALUE
1554+ 528A FB               EI
1555+ 528B C9               RET
1556+ 528C              ; *******************************************************************************************************
1557+ 528C
1558+ 528C              ; *******************************************************************************************************
1559+ 528C              ; function to handle single item ANIMSTEP in DEFUSR mode
1560+ 528C              ; input IX=pointer to input array, real data from +2
1561+ 528C              ; +2 = animation id
1562+ 528C              ANIMSTEP_SINGLE_DEFUSR:
1563+ 528C 21 97 52         LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1564+ 528F              .L1:
1565+ 528F 22 7B 52         LD (ANIM_SETVALUE.FN+1),HL
1566+ 5292 DD 7E 02         LD A,(IX+2)
1567+ 5295 18 D4            JR ANIM_SETVALUE
1568+ 5297              .STEP:
1569+ 5297 06 00            LD B,0
1570+ 5299 C3 F1 52         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1571+ 529C              ; *******************************************************************************************************
1572+ 529C
1573+ 529C              ; *******************************************************************************************************
1574+ 529C              ; function to handle multi item ANIMSTEP in DEFUSR mode
1575+ 529C              ; input IX=pointer to input array, real data from +2
1576+ 529C              ; +2 = list size
1577+ 529C              ; +4 = array pointer holding items
1578+ 529C              ANIMSTEP_MULTI_DEFUSR:
1579+ 529C 21 97 52         LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1580+ 529F              .L1:
1581+ 529F 22 7B 52         LD (ANIM_SETVALUE.FN+1),HL
1582+ 52A2 DD 46 02         LD B,(IX+2)
1583+ 52A5 DD 5E 04         LD E,(IX+4)
1584+ 52A8 DD 56 05         LD D,(IX+5)
1585+ 52AB 18 D0            JR ANIM_LIST_SETVALUE
1586+ 52AD              ; *******************************************************************************************************
1587+ 52AD
1588+ 52AD              ; *******************************************************************************************************
1589+ 52AD              ; function to handle single item ANIMSTART in DEFUSR mode
1590+ 52AD              ; input IX=pointer to input array, real data from +2
1591+ 52AD              ; +2 = animation id
1592+ 52AD              ANIMSTART_SINGLE_DEFUSR:
1593+ 52AD 21 B2 52         LD HL,ANIMSTART_SINGLE_DEFUSR.START
1594+ 52B0 18 DD            JR ANIMSTEP_SINGLE_DEFUSR.L1
1595+ 52B2              .START:
1596+ 52B2 DD 36 06 01      LD (IX+6),1 ; active flag
1597+ 52B6 DD 36 03 00      LD (IX+3),0 ; current item
1598+ 52BA 06 00            LD B,0 ; setup timer
1599+ 52BC C3 4D 53         JP SETUP_ANIM_STEP
1600+ 52BF              ; *******************************************************************************************************
1601+ 52BF
1602+ 52BF              ; *******************************************************************************************************
1603+ 52BF              ; function to handle multi item ANIMSTART in DEFUSR mode
1604+ 52BF              ; input IX=pointer to input array, real data from +2
1605+ 52BF              ; +2 = list size
1606+ 52BF              ; +4 = array pointer holding items
1607+ 52BF              ANIMSTART_MULTI_DEFUSR:
1608+ 52BF 21 B2 52         LD HL,ANIMSTART_SINGLE_DEFUSR.START
1609+ 52C2 18 DB            JR ANIMSTEP_MULTI_DEFUSR.L1
1610+ 52C4              ; *******************************************************************************************************
1611+ 52C4
1612+ 52C4              ; *******************************************************************************************************
1613+ 52C4              ; function to handle single item ANIMSTOP in DEFUSR mode
1614+ 52C4              ; input IX=pointer to input array, real data from +2
1615+ 52C4              ; +2 = animation id
1616+ 52C4              ANIMSTOP_SINGLE_DEFUSR:
1617+ 52C4 21 C9 52         LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1618+ 52C7 18 C6            JR ANIMSTEP_SINGLE_DEFUSR.L1
1619+ 52C9              .STOP:
1620+ 52C9 DD 36 06 00      LD (IX+6),0 ; active flag
1621+ 52CD C9               RET
1622+ 52CE              ; *******************************************************************************************************
1623+ 52CE
1624+ 52CE              ; *******************************************************************************************************
1625+ 52CE              ; function to handle multi item ANIMSTOP in DEFUSR mode
1626+ 52CE              ; input IX=pointer to input array, real data from +2
1627+ 52CE              ; +2 = list size
1628+ 52CE              ; +4 = array pointer holding items
1629+ 52CE              ANIMSTOP_MULTI_DEFUSR:
1630+ 52CE 21 C9 52         LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1631+ 52D1 18 CC            JR ANIMSTEP_MULTI_DEFUSR.L1
1632+ 52D3              ; *******************************************************************************************************
1633+ 52D3               ENDIF
1634+ 52D3
1635+ 52D3              ; *******************************************************************************************************
1636+ 52D3              ; function processes animations during vblank period
1637+ 52D3              PROCESS_ANIMATIONS:
1638+ 52D3 3A F5 4E         LD A,(ANIMSPRNUM)
1639+ 52D6 B7               OR A
1640+ 52D7 C8               RET Z; no animations defined
1641+ 52D8 47               LD B,A
1642+ 52D9 DD 2A F6 4E      LD IX,(ANIMSPRPTR)
1643+ 52DD              .L1:
1644+ 52DD C5               PUSH BC
1645+ 52DE 06 00            LD B,0 ; normal mode, change on timer expiry only
1646+ 52E0 CD EC 52         CALL PROCESS_SINGLE_ANIMATION
1647+ 52E3 11 08 00         LD DE,8
1648+ 52E6 DD 19            ADD IX,DE
1649+ 52E8 C1               POP BC
1650+ 52E9 10 F2            DJNZ .L1
1651+ 52EB C9               RET
1652+ 52EC              ; *******************************************************************************************************
1653+ 52EC
1654+ 52EC              ; *******************************************************************************************************
1655+ 52EC              ; processes single sprite animation
1656+ 52EC              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
1657+ 52EC              ; on timer expiry goes to next animation item
1658+ 52EC              ; input IX=sprite animation pointer
1659+ 52EC              ; input B=1 force mode, activate animation action regardless of expired timer
1660+ 52EC              PROCESS_SINGLE_ANIMATION:
1661+ 52EC DD 7E 06         LD A,(IX+6); active
1662+ 52EF B7               OR A
1663+ 52F0 C8               RET Z ; inactive animation
1664+ 52F1              .INACTIVE_TOO:
1665+ 52F1 DD 6E 01         LD L,(IX+1)
1666+ 52F4 DD 66 02         LD H,(IX+2) ; HL=end time
1667+ 52F7 2B               DEC HL
1668+ 52F8 DD 75 01         LD (IX+1),L
1669+ 52FB DD 74 02         LD (IX+2),H
1670+ 52FE 7D               LD A,L
1671+ 52FF B4               OR H
1672+ 5300 28 06            JR Z,.STEP
1673+ 5302 05               DEC B
1674+ 5303 04               INC B
1675+ 5304 C8               RET Z ; not forced mode, return
1676+ 5305 C3 4D 53         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
1677+ 5308              .STEP:
1678+ 5308 06 00            LD B,0; setup timer
1679+ 530A DD 34 03         INC (IX+3) ; current animation item
1680+ 530D C3 4D 53         JP SETUP_ANIM_STEP
1681+ 5310              ; *******************************************************************************************************
1682+ 5310
1683+ 5310              ; *******************************************************************************************************
1684+ 5310              ; function will setup sprite animation after current item change
1685+ 5310              ; input A=current animation definition
1686+ 5310              ; input IX=pointer to sprite animation
1687+ 5310              ; input B=1 skip timer setup
1688+ 5310              ; output IY=pointer to animation item
1689+ 5310              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
1690+ 5310              ; basically sets new end time for current animation
1691+ 5310              INIT_CURRENT_ANIMATION:
1692+ 5310 CD 0D 4F         CALL GETnthANIMDEF
1693+ 5313 DD 7E 03         LD A,(IX+3) ; current animation item
1694+ 5316 BE               CP (HL) ; number of animation items in the animation definition
1695+ 5317 38 0A            JR C,.L3 ; last item not reached
1696+ 5319                  ; last item reached
1697+ 5319 DD 7E 05         LD A,(IX+5) ; cyclic flag
1698+ 531C B7               OR A
1699+ 531D 28 2C            JR Z,.ERROR ; non-cyclic animation
1700+ 531F                  ; cyclic animation, restart
1701+ 531F DD 36 03 00      LD (IX+3),0; current item
1702+ 5323              .L3:
1703+ 5323                  ; HL = animation definition
1704+ 5323 23               INC HL ; skip animation definition size field
1705+ 5324 16 00            LD D,0
1706+ 5326 DD 5E 03         LD E,(IX+3); current item
1707+ 5329 19               ADD HL,DE
1708+ 532A 4E               LD C,(HL) ; current animation item
1709+ 532B 0C               INC C
1710+ 532C 3A EF 4E         LD A,(ANIMITEMNUM)
1711+ 532F B9               CP C
1712+ 5330 38 19            JR C,.ERROR ; invalid animation item, stop animation
1713+ 5332 0D               DEC C
1714+ 5333 79               LD A,C
1715+ 5334 CD 04 4F         CALL GETnthANIMITEM
1716+ 5337 E5               PUSH HL
1717+ 5338 FD E1            POP IY ; IY=animation item
1718+ 533A 05               DEC B
1719+ 533B 28 0C            JR Z,.EXIT
1720+ 533D FD 5E 01         LD E,(IY+1)
1721+ 5340 FD 56 02         LD D,(IY+2) ; duration
1722+ 5343 DD 73 01         LD (IX+1),E
1723+ 5346 DD 72 02         LD (IX+2),D
1724+ 5349              .EXIT:
1725+ 5349 AF               XOR A
1726+ 534A C9               RET
1727+ 534B              .ERROR:
1728+ 534B 37               SCF
1729+ 534C C9               RET
1730+ 534D              ; *******************************************************************************************************
1731+ 534D
1732+ 534D              ; *******************************************************************************************************
1733+ 534D              ; function will display currect item and set up expiry time
1734+ 534D              ; it will also stop the animation if expired
1735+ 534D              ; sets sprite update flag if any changes in sprite data made
1736+ 534D              ; input IX=current sprite animation
1737+ 534D              ; input B=1 skip timer setup
1738+ 534D              SETUP_ANIM_STEP:
1739+ 534D DD 4E 04         LD C,(IX+4) ; animation definition ID
1740+ 5350 0C               INC C
1741+ 5351 3A F2 4E         LD A,(ANIMDEFNUM)
1742+ 5354 B9               CP C
1743+ 5355 30 05            JR NC,.L2
1744+ 5357                  ; given animation item is outside of bounds, deactivate animation
1745+ 5357              .STOPANIM:
1746+ 5357 DD 36 06 00      LD (IX+6),0
1747+ 535B C9               RET
1748+ 535C              .L2:
1749+ 535C 0D               DEC C
1750+ 535D 79               LD A,C
1751+ 535E CD 10 53         CALL INIT_CURRENT_ANIMATION
1752+ 5361 38 F4            JR C, .STOPANIM
1753+ 5363 FD 7E 00         LD A,(IY) ; type of animation item
1754+ 5366 B7               OR A
1755+ 5367 28 44            JR Z,.L4 ; change pattern and/or color
1756+ 5369              .PAT:
1757+ 5369                  ; change pattern definition
1758+ 5369                  ; check if sprite or character
1759+ 5369 DD 7E 07         LD A,(IX+7)
1760+ 536C B7               OR A
1761+ 536D 20 58            JR NZ,.CHAR
1762+ 536F DD 7E 00         LD A,(IX) ; sprite number
1763+ 5372 CD 89 4D         CALL GETnthSPRATTR
1764+ 5375 23          > INC HL ; skip y and x
1764+ 5376 23          > INC HL
1764+ 5377 23          > INC HL
1764+ 5378 23          > INC HL
1765+ 5379 7E               LD A,(HL); current pattern
1766+ 537A 26 00            LD H,0
1767+ 537C 6F               LD L,A
1768+ 537D 3A E0 F3         LD A,(REG1SAV)
1769+ 5380 E6 02            AND 2
1770+ 5382 20 07            JR NZ,.L6
1771+ 5384                  ; 8x8 sprite
1772+ 5384 CD 6D 5D         CALL HLx8
1773+ 5387 06 08            LD B,8
1774+ 5389 18 05            JR .L5
1775+ 538B              .L6:
1776+ 538B CD 6B 5D         CALL HLx32
1777+ 538E 06 20            LD B,32
1778+ 5390              .L5:
1779+ 5390 3A AF FC         LD A,(SCRMOD)
1780+ 5393 3D               DEC A
1781+ 5394 20 06            JR NZ,.L10
1782+ 5396 ED 5B C5 F3      LD DE,(T32PAT)
1783+ 539A 18 04            JR .L7
1784+ 539C              .L10:
1785+ 539C ED 5B CF F3      LD DE,(GRPPAT)
1786+ 53A0              .L7:
1787+ 53A0 19               ADD HL,DE
1788+ 53A1 CD 58 5D         CALL SETWRT_LOCAL
1789+ 53A4 FD 6E 03         LD L,(IY+3)
1790+ 53A7 FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
1791+ 53AA C3 63 5D         JP BBYTECOPY
1792+ 53AD              .L4:
1793+ 53AD                  ; change pattern and color in sprite attributes table
1794+ 53AD DD 7E 00         LD A,(IX) ; sprite number
1795+ 53B0 CD 89 4D         CALL GETnthSPRATTR
1796+ 53B3 23          > INC HL ; skip y and x
1796+ 53B4 23          > INC HL
1796+ 53B5 23          > INC HL
1796+ 53B6 23          > INC HL
1797+ 53B7 FD 7E 03         LD A,(IY+3) ; new pattern
1798+ 53BA 77               LD (HL),A
1799+ 53BB 23          > INC HL
1799+ 53BC 23          > INC HL
1800+ 53BD FD 7E 04         LD A,(IY+4) ; new color
1801+ 53C0 77               LD (HL),A
1802+ 53C1 2A 80 4D         LD HL,(SPRATR_UPDATE_FLAG)
1803+ 53C4 36 01            LD (HL),1
1804+ 53C6 C9               RET
1805+ 53C7              .CHAR:
1806+ 53C7 DD 6E 00         LD L,(IX)
1807+ 53CA 3D               DEC A
1808+ 53CB 67               LD H,A
1809+ 53CC CD 6D 5D         CALL HLx8
1810+ 53CF 3A AF FC         LD A,(SCRMOD)
1811+ 53D2 3D               DEC A
1812+ 53D3 20 06            JR NZ,.L8
1813+ 53D5 ED 5B C1 F3      LD DE,(T32CGP)
1814+ 53D9 18 04            JR .L9
1815+ 53DB              .L8:
1816+ 53DB ED 5B CB F3      LD DE,(GRPCGP)
1817+ 53DF              .L9:
1818+ 53DF 06 08            LD B,8
1819+ 53E1 18 BD            JR .L7
1820+ 53E3              ; *******************************************************************************************************
1821+ 53E3
# file closed: asm\ANIMATION.asm
 132  53E3               INCLUDE "SGAM.asm"
# file opened: asm\SGAM.asm
   1+ 53E3              ; Sprite Group Animate and Move
   2+ 53E3
   3+ 53E3              ; *******************************************************************************************************
   4+ 53E3              ; shared function to process a list of animations
   5+ 53E3              ; input B=list size
   6+ 53E3              ; input DE=list pointer
   7+ 53E3              SGAM_PROCESS_ANIM_LIST:
   8+ 53E3 21 F6 53         LD HL,.STEP
   9+ 53E6 22 7B 52         LD (ANIM_SETVALUE.FN+1),HL
  10+ 53E9              .L1:
  11+ 53E9 C5               PUSH BC
  12+ 53EA 1A               LD A,(DE)
  13+ 53EB 13          > INC DE
  13+ 53EC 13          > INC DE
  14+ 53ED D5               PUSH DE
  15+ 53EE CD 6B 52         CALL ANIM_SETVALUE
  16+ 53F1 D1               POP DE
  17+ 53F2 C1               POP BC
  18+ 53F3 10 F4            DJNZ .L1
  19+ 53F5 C9           	RET
  20+ 53F6              .STEP:
  21+ 53F6 06 01            LD B,1
  22+ 53F8 C3 F1 52         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
  23+ 53FB              ; *******************************************************************************************************
  24+ 53FB
  25+ 53FB               IF (BASIC_EXTENSION == 1)
  26+ 53FB ~            ; *******************************************************************************************************
  27+ 53FB ~            ; function to handle CALL SGAM basic extension
  28+ 53FB ~            ; sets position of a group of sprites as described in SPRGRPMOV
  29+ 53FB ~            ; and manually animate a list of animations
  30+ 53FB ~            ; _SGAM ( INT x,
  31+ 53FB ~            ;	      INT y,
  32+ 53FB ~            ;		  BYTE count,
  33+ 53FB ~            ;		  INT[2][count] data_ptr,
  34+ 53FB ~            ;         BYTE item_number,
  35+ 53FB ~            ;         INT[] sprite_animations )
  36+ 53FB ~            ; will put ram in page 0 also, page 1 is already there
  37+ 53FB ~            SGAM:
  38+ 53FB ~            	LD A, (SPRATR_INIT_STATUS)
  39+ 53FB ~            	OR A
  40+ 53FB ~            	JP Z,ILLEGAL_FUNCTION
  41+ 53FB ~            	; opening (
  42+ 53FB ~            	CALL CHKCHAR
  43+ 53FB ~            	DB '('
  44+ 53FB ~            	; get x
  45+ 53FB ~            	LD IX, FRMQNT
  46+ 53FB ~            	CALL CALBAS
  47+ 53FB ~            	LD (BLIT_STRUCT),DE
  48+ 53FB ~            	; comma
  49+ 53FB ~            	CALL CHKCHAR
  50+ 53FB ~            	DB ','
  51+ 53FB ~            	; get y
  52+ 53FB ~            	LD IX, FRMQNT
  53+ 53FB ~            	CALL CALBAS
  54+ 53FB ~            	LD (BLIT_STRUCT+2),DE
  55+ 53FB ~            	; comma
  56+ 53FB ~            	CALL CHKCHAR
  57+ 53FB ~            	DB ','
  58+ 53FB ~            	; get count
  59+ 53FB ~            	LD IX, GETBYT
  60+ 53FB ~            	CALL CALBAS
  61+ 53FB ~                OR A
  62+ 53FB ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
  63+ 53FB ~            	LD (BLIT_STRUCT+4),A
  64+ 53FB ~            	; comma
  65+ 53FB ~            	CALL CHKCHAR
  66+ 53FB ~            	DB ','
  67+ 53FB ~            	; get sprite group definition array data pointer
  68+ 53FB ~                LD A,(BLIT_STRUCT+4)
  69+ 53FB ~            	LD E,A
  70+ 53FB ~            	LD D,3
  71+ 53FB ~            	LD A,2
  72+ 53FB ~            	LD B,A
  73+ 53FB ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
  74+ 53FB ~            	LD (BLIT_STRUCT+5),BC
  75+ 53FB ~            	; comma
  76+ 53FB ~            	CALL CHKCHAR
  77+ 53FB ~            	DB ','
  78+ 53FB ~            	; get sprite animation array size
  79+ 53FB ~            	LD IX,GETBYT
  80+ 53FB ~            	CALL CALBAS
  81+ 53FB ~                LD (BLIT_STRUCT+7),A
  82+ 53FB ~                OR A
  83+ 53FB ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
  84+ 53FB ~            	; comma
  85+ 53FB ~            	CALL CHKCHAR
  86+ 53FB ~            	DB ','
  87+ 53FB ~                ; get array pointer
  88+ 53FB ~                LD A,(BLIT_STRUCT+7)
  89+ 53FB ~                LD D,A
  90+ 53FB ~                LD A,2
  91+ 53FB ~                LD B,1
  92+ 53FB ~                CALL GET_BASIC_ARRAY_DATA_POINTER
  93+ 53FB ~                LD (BLIT_STRUCT+8),BC
  94+ 53FB ~            	; ending )
  95+ 53FB ~            	CALL CHKCHAR
  96+ 53FB ~            	DB ')'
  97+ 53FB ~            .ENTRY:
  98+ 53FB ~                PUSH HL
  99+ 53FB ~
 100+ 53FB ~            	; enable page 0
 101+ 53FB ~            	LD IY, .RET
 102+ 53FB ~            	JP ENABLE_PAGE0
 103+ 53FB ~            .RET:
 104+ 53FB ~                EXX
 105+ 53FB ~                LD DE,(BLIT_STRUCT) ; initial x
 106+ 53FB ~                LD BC,(BLIT_STRUCT+2) ; initial y
 107+ 53FB ~                EXX
 108+ 53FB ~                LD HL,(BLIT_STRUCT+5) ; pointer to data
 109+ 53FB ~                LD A,(BLIT_STRUCT+4) ; number of entries
 110+ 53FB ~                LD B,A
 111+ 53FB ~                CALL SPR_UPDATE_LOC
 112+ 53FB ~
 113+ 53FB ~                LD A,(BLIT_STRUCT+7) ; anim number
 114+ 53FB ~                LD B,A
 115+ 53FB ~                LD DE,(BLIT_STRUCT+8) ; anim list
 116+ 53FB ~            	CALL SGAM_PROCESS_ANIM_LIST
 117+ 53FB ~
 118+ 53FB ~                POP DE
 119+ 53FB ~                POP BC
 120+ 53FB ~                CALL RESTORE_PAGE_INFO
 121+ 53FB ~                EI
 122+ 53FB ~                POP HL
 123+ 53FB ~                RET
 124+ 53FB ~            ; *******************************************************************************************************
 125+ 53FB               ENDIF
 126+ 53FB
 127+ 53FB               IF (DEFUSR_EXTENSION == 1)
 128+ 53FB              ; *******************************************************************************************************
 129+ 53FB              ; same as SGAM but for DEFUSR approach
 130+ 53FB              ; input IX=pointer to input array, real data from +2
 131+ 53FB              ; +02 = X
 132+ 53FB              ; +04 = Y
 133+ 53FB              ; +06 = count
 134+ 53FB              ; +08 = data pointer
 135+ 53FB              ; +10 = anim number
 136+ 53FB              ; +12 = sprite animations
 137+ 53FB              SGAM_DEFUSR:
 138+ 53FB              	; enable page 0
 139+ 53FB FD 21 02 54  	LD IY, .RET
 140+ 53FF C3 31 5E     	JP ENABLE_PAGE0
 141+ 5402              .RET:
 142+ 5402 FB           	EI
 143+ 5403 D9               EXX
 144+ 5404 DD 5E 02     	LD E,(IX+2)
 145+ 5407 DD 56 03     	LD D,(IX+3) ; initial x
 146+ 540A DD 4E 04     	LD C,(IX+4)
 147+ 540D DD 46 05     	LD B,(IX+5) ; initial y
 148+ 5410 D9               EXX
 149+ 5411 DD 6E 08     	LD L,(IX+8)
 150+ 5414 DD 66 09     	LD H,(IX+9) ; pointer to data
 151+ 5417 DD 46 06         LD B,(IX+6) ; count
 152+ 541A DD E5        	PUSH IX
 153+ 541C CD BA 4E         CALL SPR_UPDATE_LOC
 154+ 541F DD E1        	POP IX
 155+ 5421 DD 46 0A         LD B,(IX+10) ; anim number
 156+ 5424 DD 5E 0C     	LD E,(IX+12)
 157+ 5427 DD 56 0D     	LD D,(IX+13)
 158+ 542A CD E3 53     	CALL SGAM_PROCESS_ANIM_LIST
 159+ 542D
 160+ 542D D1               POP DE
 161+ 542E C1               POP BC
 162+ 542F C3 A8 5D         JP RESTORE_PAGE_INFO
 163+ 5432              ; *******************************************************************************************************
 164+ 5432               ENDIF
 165+ 5432
 166+ 5432              ; *******************************************************************************************************
 167+ 5432              ; handles automatic move and animate sprite groups during interrupt
 168+ 5432              PROCESS_AUTOSGAMS:
 169+ 5432 3A F8 4E     	LD A,(AUTOSGAMNUM)
 170+ 5435 B7           	OR A
 171+ 5436 C8           	RET Z
 172+ 5437 47           	LD B,A
 173+ 5438 DD 2A F9 4E  	LD IX,(AUTOSGAMPTR)
 174+ 543C              .L1:
 175+ 543C C5           	PUSH BC
 176+ 543D DD 7E 13     	LD A,(IX+19) ; active flag
 177+ 5440 B7           	OR A
 178+ 5441 28 28        	JR Z,.LOOPEND
 179+ 5443              	; active, check timer
 180+ 5443 DD 6E 16     	LD L,(IX+22)
 181+ 5446 DD 66 17     	LD H,(IX+23) ; timer
 182+ 5449 2B           	DEC HL
 183+ 544A 7C           	LD A,H
 184+ 544B B5           	OR L
 185+ 544C 28 08        	JR Z,.L2
 186+ 544E              	; not expired
 187+ 544E DD 75 16     	LD (IX+22),L
 188+ 5451 DD 74 17     	LD (IX+23),H
 189+ 5454 18 15        	JR .LOOPEND
 190+ 5456              .L2:
 191+ 5456              	; expired, process
 192+ 5456
 193+ 5456                  ; set initial timer
 194+ 5456 DD 7E 14         LD A,(IX+20)
 195+ 5459 DD 77 16         LD (IX+22),A
 196+ 545C DD 7E 15         LD A,(IX+21)
 197+ 545F DD 77 17         LD (IX+23),A
 198+ 5462
 199+ 5462 CD 74 54     	CALL .MOVE
 200+ 5465 CD DF 54     	CALL .UPDATELOC
 201+ 5468 CD 04 55     	CALL .PROCESS_ANIM_LIST
 202+ 546B
 203+ 546B              .LOOPEND:
 204+ 546B 11 18 00     	LD DE,24
 205+ 546E DD 19        	ADD IX,DE
 206+ 5470 C1           	POP BC
 207+ 5471 10 C9        	DJNZ .L1
 208+ 5473 C9           	RET
 209+ 5474
 210+ 5474              .MOVE:
 211+ 5474              	; process movement
 212+ 5474 DD 7E 0A     	LD A,(IX+10) ; direction
 213+ 5477 B7           	OR A
 214+ 5478 28 08        	JR Z, .MOVE_L1
 215+ 547A              	; vertical
 216+ 547A DD 6E 02     	LD L,(IX+2)
 217+ 547D DD 66 03     	LD H,(IX+3) ; vertical variable pointer
 218+ 5480 18 06        	JR .MOVE_L2
 219+ 5482              .MOVE_L1:
 220+ 5482              	; horizontal
 221+ 5482 DD 6E 00     	LD L,(IX+0)
 222+ 5485 DD 66 01     	LD H,(IX+1) ; horizontal variable pointer
 223+ 5488              .MOVE_L2:
 224+ 5488 E5           	PUSH HL
 225+ 5489 FD E1        	POP IY
 226+ 548B FD 6E 00     	LD L,(IY+0)
 227+ 548E FD 66 01     	LD H,(IY+1)
 228+ 5491 DD 5E 08     	LD E,(IX+8)
 229+ 5494 DD 56 09     	LD D,(IX+9) ; delta value
 230+ 5497 19           	ADD HL,DE
 231+ 5498 E5           	PUSH HL
 232+ 5499 DD 5E 04     	LD E,(IX+4)
 233+ 549C DD 56 05     	LD D,(IX+5) ; minimum value
 234+ 549F A7           	AND A
 235+ 54A0 ED 52        	SBC HL,DE
 236+ 54A2 FA BC 54     	JP M,.MOVE_L3 ; below minimum
 237+ 54A5 E1           	POP HL
 238+ 54A6 E5           	PUSH HL
 239+ 54A7 DD 5E 06     	LD E,(IX+6)
 240+ 54AA DD 56 07     	LD D,(IX+7) ; maximum value
 241+ 54AD EB           	EX DE,HL
 242+ 54AE A7           	AND A
 243+ 54AF ED 52        	SBC HL,DE
 244+ 54B1 FA C4 54     	JP M,.MOVE_L4 ; above maximum
 245+ 54B4 E1           	POP HL
 246+ 54B5              	; within bounds
 247+ 54B5              .MOVE_L5:
 248+ 54B5 FD 75 00     	LD (IY+0),L
 249+ 54B8 FD 74 01     	LD (IY+1),H
 250+ 54BB C9           	RET
 251+ 54BC              .MOVE_L3:
 252+ 54BC E1           	POP HL
 253+ 54BD CD D0 54     	CALL .INVERSE_DELTA
 254+ 54C0 6B           	LD L,E
 255+ 54C1 62           	LD H,D
 256+ 54C2 18 F1        	JR .MOVE_L5
 257+ 54C4              .MOVE_L4:
 258+ 54C4 E1           	POP HL
 259+ 54C5 CD D0 54     	CALL .INVERSE_DELTA
 260+ 54C8 DD 6E 06     	LD L,(IX+6)
 261+ 54CB DD 66 07     	LD H,(IX+7) ; maximum
 262+ 54CE 18 E5        	JR .MOVE_L5
 263+ 54D0              .INVERSE_DELTA:
 264+ 54D0 AF           	XOR A
 265+ 54D1 DD 96 08     	SUB (IX+8)
 266+ 54D4 DD 77 08     	LD (IX+8),A
 267+ 54D7 9F           	SBC A,A
 268+ 54D8 DD 96 09     	SUB (IX+9)
 269+ 54DB DD 77 09     	LD (IX+9),A
 270+ 54DE C9           	RET
 271+ 54DF
 272+ 54DF              .UPDATELOC:
 273+ 54DF DD E5        	PUSH IX
 274+ 54E1 D9           	EXX
 275+ 54E2 DD 6E 00     	LD L,(IX+0)
 276+ 54E5 DD 66 01     	LD H,(IX+1)
 277+ 54E8 5E           	LD E,(HL)
 278+ 54E9 23           	INC HL
 279+ 54EA 56           	LD D,(HL)
 280+ 54EB DD 6E 02     	LD L,(IX+2)
 281+ 54EE DD 66 03     	LD H,(IX+3)
 282+ 54F1 4E           	LD C,(HL)
 283+ 54F2 23           	INC HL
 284+ 54F3 46           	LD B,(HL)
 285+ 54F4 D9           	EXX
 286+ 54F5 DD 6E 0C     	LD L,(IX+12)
 287+ 54F8 DD 66 0D     	LD H,(IX+13) ; pointer to sprite group data
 288+ 54FB DD 46 0B     	LD B,(IX+11) ; sprite group size
 289+ 54FE CD BA 4E     	CALL SPR_UPDATE_LOC
 290+ 5501 DD E1        	POP IX
 291+ 5503 C9           	RET
 292+ 5504
 293+ 5504              .PROCESS_ANIM_LIST:
 294+ 5504 DD E5        	PUSH IX
 295+ 5506 DD 46 0E         LD B,(IX+14) ; anim list size
 296+ 5509 DD CB 09 7E  	BIT 7,(IX+9)
 297+ 550D 28 08        	JR Z,.PROCESS_ANIM_LIST_L1
 298+ 550F              	; negative direction
 299+ 550F DD 5E 0F     	LD E,(IX+15)
 300+ 5512 DD 56 10     	LD D,(IX+16)
 301+ 5515 18 06        	JR .PROCESS_ANIM_LIST_L2
 302+ 5517              .PROCESS_ANIM_LIST_L1:
 303+ 5517              	; positive direction
 304+ 5517 DD 5E 11     	LD E,(IX+17)
 305+ 551A DD 56 12     	LD D,(IX+18)
 306+ 551D              .PROCESS_ANIM_LIST_L2:
 307+ 551D CD E3 53     	CALL SGAM_PROCESS_ANIM_LIST
 308+ 5520 DD E1        	POP IX
 309+ 5522 C9           	RET
 310+ 5523              ; *******************************************************************************************************
 311+ 5523
# file closed: asm\SGAM.asm
 133  5523               ENDIF
 134  5523
 135  5523               IF (RAM_CMDS == 1)
 136  5523               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
   1+ 5523               IF (BASIC_EXTENSION == 1)
   2+ 5523 ~            ; *******************************************************************************************************
   3+ 5523 ~            ; function to handle CALL MEMCPY basic extension
   4+ 5523 ~            ; _MEMCPY ( INT source,
   5+ 5523 ~            ;			INT destination,
   6+ 5523 ~            ;			INT count,
   7+ 5523 ~            ; will put ram in page 0 also, page 1 is already there
   8+ 5523 ~            MEMCPY:
   9+ 5523 ~            	; opening (
  10+ 5523 ~            	CALL CHKCHAR
  11+ 5523 ~            	DB '('
  12+ 5523 ~            	; get source address
  13+ 5523 ~            	LD IX, FRMQNT
  14+ 5523 ~            	CALL CALBAS
  15+ 5523 ~            	PUSH DE
  16+ 5523 ~            	; comma
  17+ 5523 ~            	CALL CHKCHAR
  18+ 5523 ~            	DB ','
  19+ 5523 ~            	; get destination address
  20+ 5523 ~            	LD IX, FRMQNT
  21+ 5523 ~            	CALL CALBAS
  22+ 5523 ~            	PUSH DE
  23+ 5523 ~            	; comma
  24+ 5523 ~            	CALL CHKCHAR
  25+ 5523 ~            	DB ','
  26+ 5523 ~            	; get length
  27+ 5523 ~            	LD IX, FRMQNT
  28+ 5523 ~            	CALL CALBAS
  29+ 5523 ~            	PUSH DE
  30+ 5523 ~            	; ending )
  31+ 5523 ~            	CALL CHKCHAR
  32+ 5523 ~            	DB ')'
  33+ 5523 ~
  34+ 5523 ~            	; save position
  35+ 5523 ~            	PUSH HL
  36+ 5523 ~            	POP IX
  37+ 5523 ~
  38+ 5523 ~            	POP BC ; count
  39+ 5523 ~            	POP DE ; destination
  40+ 5523 ~            	POP HL ; source
  41+ 5523 ~            	EXX
  42+ 5523 ~            	; enable page 0
  43+ 5523 ~            	LD IY, .RET
  44+ 5523 ~            	JP ENABLE_PAGE0
  45+ 5523 ~            .RET:
  46+ 5523 ~            	EI
  47+ 5523 ~            	EXX
  48+ 5523 ~            	LDIR
  49+ 5523 ~                POP DE
  50+ 5523 ~                POP BC
  51+ 5523 ~                CALL RESTORE_PAGE_INFO
  52+ 5523 ~            	PUSH IX
  53+ 5523 ~            	POP HL
  54+ 5523 ~            	RET
  55+ 5523 ~            ; *******************************************************************************************************
  56+ 5523               ENDIF
  57+ 5523
  58+ 5523               IF (DEFUSR_EXTENSION == 1)
  59+ 5523              ; *******************************************************************************************************
  60+ 5523              ; same as MEMCPY but for DEFUSR approach
  61+ 5523              ; input IX=pointer to input array, real data from +2
  62+ 5523              ; +2 = source address
  63+ 5523              ; +4 = destination address
  64+ 5523              ; +6 = lenght
  65+ 5523              MEMCPY_DEFUSR:
  66+ 5523              	; enable page 0
  67+ 5523 FD 21 2A 55  	LD IY, .RET
  68+ 5527 C3 31 5E     	JP ENABLE_PAGE0
  69+ 552A              .RET:
  70+ 552A FB           	EI
  71+ 552B DD 6E 02     	LD L,(IX+2)
  72+ 552E DD 66 03     	LD H,(IX+3)
  73+ 5531 DD 5E 04     	LD E,(IX+4)
  74+ 5534 DD 56 05     	LD D,(IX+5)
  75+ 5537 DD 4E 06     	LD C,(IX+6)
  76+ 553A DD 46 07     	LD B,(IX+7)
  77+ 553D ED B0        	LDIR
  78+ 553F D1               POP DE
  79+ 5540 C1               POP BC
  80+ 5541 C3 A8 5D         JP RESTORE_PAGE_INFO
  81+ 5544              ; *******************************************************************************************************
  82+ 5544               ENDIF
  83+ 5544
  84+ 5544               IF (BASIC_EXTENSION == 1)
  85+ 5544 ~            ; *******************************************************************************************************
  86+ 5544 ~            ; function to handle CALL FILRAM basic extension
  87+ 5544 ~            ; FILRAM ( INT start address,
  88+ 5544 ~            ;		   INT count,
  89+ 5544 ~            ;		   BYTE value )
  90+ 5544 ~            ; will put ram in page 0 also, page 1 is already there
  91+ 5544 ~            FILRAM:
  92+ 5544 ~            	; opening (
  93+ 5544 ~            	CALL CHKCHAR
  94+ 5544 ~            	DB '('
  95+ 5544 ~            	; get start address
  96+ 5544 ~            	LD IX, FRMQNT
  97+ 5544 ~            	CALL CALBAS
  98+ 5544 ~            	PUSH DE
  99+ 5544 ~            	; comma
 100+ 5544 ~            	CALL CHKCHAR
 101+ 5544 ~            	DB ','
 102+ 5544 ~            	; get count
 103+ 5544 ~            	LD IX, FRMQNT
 104+ 5544 ~            	CALL CALBAS
 105+ 5544 ~            	PUSH DE
 106+ 5544 ~            	; comma
 107+ 5544 ~            	CALL CHKCHAR
 108+ 5544 ~            	DB ','
 109+ 5544 ~            	; get value
 110+ 5544 ~            	LD IX, GETBYT
 111+ 5544 ~            	CALL CALBAS
 112+ 5544 ~            	PUSH AF
 113+ 5544 ~            	; ending )
 114+ 5544 ~            	CALL CHKCHAR
 115+ 5544 ~            	DB ')'
 116+ 5544 ~
 117+ 5544 ~            	; save position
 118+ 5544 ~            	PUSH HL
 119+ 5544 ~            	POP IX
 120+ 5544 ~
 121+ 5544 ~            	POP DE ; actually AF
 122+ 5544 ~            	POP BC ; count
 123+ 5544 ~            	POP HL ; start address
 124+ 5544 ~            	LD A, B
 125+ 5544 ~            	OR C
 126+ 5544 ~            	JR Z, .EXIT ; 0 bytes to fill, skip
 127+ 5544 ~            	EXX
 128+ 5544 ~            	; enable page 0
 129+ 5544 ~            	LD IY, .RET
 130+ 5544 ~            	JP ENABLE_PAGE0
 131+ 5544 ~            .RET:
 132+ 5544 ~            	EI
 133+ 5544 ~            	EXX
 134+ 5544 ~            	CALL FILVRM_FILLVALUE
 135+ 5544 ~                POP DE
 136+ 5544 ~                POP BC
 137+ 5544 ~                CALL RESTORE_PAGE_INFO
 138+ 5544 ~            .EXIT:
 139+ 5544 ~            	PUSH IX
 140+ 5544 ~            	POP HL
 141+ 5544 ~            	RET
 142+ 5544 ~            ; *******************************************************************************************************
 143+ 5544               ENDIF
 144+ 5544
 145+ 5544               IF (DEFUSR_EXTENSION == 1)
 146+ 5544              ; *******************************************************************************************************
 147+ 5544              ; same as FILVRM but for DEFUSR approach
 148+ 5544              ; input IX=pointer to input array, real data from +2
 149+ 5544              ; +2 = start address
 150+ 5544              ; +4 = count
 151+ 5544              ; +6 = value
 152+ 5544              FILRAM_DEFUSR:
 153+ 5544              	; enable page 0
 154+ 5544 FD 21 4B 55  	LD IY, .RET
 155+ 5548 C3 31 5E     	JP ENABLE_PAGE0
 156+ 554B              .RET:
 157+ 554B FB           	EI
 158+ 554C DD 6E 02     	LD L,(IX+2)
 159+ 554F DD 66 03     	LD H,(IX+3)
 160+ 5552 DD 4E 04     	LD C,(IX+4)
 161+ 5555 DD 46 05     	LD B,(IX+5)
 162+ 5558 78           	LD A,B
 163+ 5559 B1           	OR C
 164+ 555A 28 06        	JR Z,.EXIT
 165+ 555C DD 56 06     	LD D,(IX+6)
 166+ 555F CD 67 55     	CALL FILVRM_FILLVALUE
 167+ 5562              .EXIT:
 168+ 5562 D1               POP DE
 169+ 5563 C1               POP BC
 170+ 5564 C3 A8 5D         JP RESTORE_PAGE_INFO
 171+ 5567              ; *******************************************************************************************************
 172+ 5567               ENDIF
 173+ 5567
 174+ 5567              ; *******************************************************************************************************
 175+ 5567              ; common function to fill RAM
 176+ 5567              FILVRM_FILLVALUE:
 177+ 5567 72               LD (HL), D
 178+ 5568 54               LD D, H
 179+ 5569 5D               LD E, L
 180+ 556A 13               INC DE
 181+ 556B 0B               DEC BC
 182+ 556C 78           	LD A,B
 183+ 556D B1           	OR C
 184+ 556E C8           	RET Z ; if count was 1
 185+ 556F ED B0            LDIR
 186+ 5571 C9               RET
 187+ 5572              ; *******************************************************************************************************
# file closed: asm\MEMORY.asm
 137  5572               ENDIF
 138  5572
 139  5572               IF (SOUND_CMDS == 1)
 140  5572               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
   1+ 5572              MUSIC_INIT_STATUS:
   2+ 5572 00            DB 0
   3+ 5573              SFX_INIT_STATUS:
   4+ 5573 00            DB 0
   5+ 5574              SOUND_ENABLED:
   6+ 5574 00            DB 0
   7+ 5575
   8+ 5575               IF (BASIC_EXTENSION == 1)
   9+ 5575 ~            ; *******************************************************************************************************
  10+ 5575 ~            ; function to handle CALL SNDPLYINIT basic extension
  11+ 5575 ~            ; initializes sound player
  12+ 5575 ~            ; _SNDPLYINIT ( INT music_offset,
  13+ 5575 ~            ;				INT sfx_offset, can be -1 if no SFX
  14+ 5575 ~            ; will put ram in page 0 also, page 1 is already there
  15+ 5575 ~            ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
  16+ 5575 ~            SNDPLYINIT:
  17+ 5575 ~            	; opening (
  18+ 5575 ~            	CALL CHKCHAR
  19+ 5575 ~            	DB '('
  20+ 5575 ~            	; get music address
  21+ 5575 ~            	LD IX, FRMQNT
  22+ 5575 ~            	CALL CALBAS
  23+ 5575 ~            	PUSH DE
  24+ 5575 ~            	; comma
  25+ 5575 ~            	CALL CHKCHAR
  26+ 5575 ~            	DB ','
  27+ 5575 ~            	; get sfx address
  28+ 5575 ~            	LD IX, FRMQNT
  29+ 5575 ~            	CALL CALBAS
  30+ 5575 ~            	PUSH DE
  31+ 5575 ~            	; ending )
  32+ 5575 ~            	CALL CHKCHAR
  33+ 5575 ~            	DB ')'
  34+ 5575 ~
  35+ 5575 ~                ; save position in BASIC text
  36+ 5575 ~            	LD B, H
  37+ 5575 ~            	LD C, L
  38+ 5575 ~
  39+ 5575 ~            	; pop LDIR parameters and store away for later
  40+ 5575 ~            	POP DE ; sfx address
  41+ 5575 ~            	POP HL ; music address
  42+ 5575 ~            	PUSH BC ; basic text location
  43+ 5575 ~            	EXX
  44+ 5575 ~            	LD IY, .RET
  45+ 5575 ~            	JP ENABLE_PAGE0
  46+ 5575 ~            .RET:
  47+ 5575 ~            	EXX
  48+ 5575 ~
  49+ 5575 ~            	PUSH DE
  50+ 5575 ~            	XOR A
  51+ 5575 ~            	; HL = music location
  52+ 5575 ~            	CALL PLY_AKG_INIT
  53+ 5575 ~            	LD A, 1
  54+ 5575 ~            	LD (MUSIC_INIT_STATUS), A
  55+ 5575 ~
  56+ 5575 ~            	POP HL ; SFX
  57+ 5575 ~            	; check if SFX address -1
  58+ 5575 ~            	INC HL
  59+ 5575 ~            	LD A, L
  60+ 5575 ~            	OR H
  61+ 5575 ~            	JR Z,.L1
  62+ 5575 ~            	DEC HL
  63+ 5575 ~            	CALL PLY_AKG_INITSOUNDEFFECTS
  64+ 5575 ~            	LD A, 1
  65+ 5575 ~            	LD (SFX_INIT_STATUS), A
  66+ 5575 ~            .L1:
  67+ 5575 ~                POP DE
  68+ 5575 ~                POP BC
  69+ 5575 ~                CALL RESTORE_PAGE_INFO
  70+ 5575 ~
  71+ 5575 ~            	POP HL
  72+ 5575 ~            	RET
  73+ 5575 ~            ; *******************************************************************************************************
  74+ 5575               ENDIF
  75+ 5575
  76+ 5575               IF (DEFUSR_EXTENSION == 1)
  77+ 5575              ; *******************************************************************************************************
  78+ 5575              ; same as SNDPLYINI but for DEFUSR approach
  79+ 5575              ; input IX=pointer to input array, real data from +2
  80+ 5575              ; +2 = music address
  81+ 5575              ; +4 = sfx address
  82+ 5575              SNDPLYINI_DEFUSR:
  83+ 5575 FD 21 7C 55  	LD IY, .RET
  84+ 5579 C3 31 5E     	JP ENABLE_PAGE0
  85+ 557C              .RET:
  86+ 557C AF           	XOR A
  87+ 557D DD 6E 02     	LD L,(IX+2)
  88+ 5580 DD 66 03     	LD H,(IX+3)
  89+ 5583 DD E5        	PUSH IX
  90+ 5585 CD 65 41     	CALL PLY_AKG_INIT
  91+ 5588 DD E1        	POP IX
  92+ 558A 3E 01        	LD A, 1
  93+ 558C 32 72 55     	LD (MUSIC_INIT_STATUS), A
  94+ 558F
  95+ 558F DD 6E 04     	LD L,(IX+4)
  96+ 5592 DD 66 05     	LD H,(IX+5)
  97+ 5595              	; check if SFX address -1
  98+ 5595 23           	INC HL
  99+ 5596 7D           	LD A, L
 100+ 5597 B4           	OR H
 101+ 5598 28 09        	JR Z,.L1
 102+ 559A 2B           	DEC HL
 103+ 559B CD 20 40     	CALL PLY_AKG_INITSOUNDEFFECTS
 104+ 559E 3E 01        	LD A, 1
 105+ 55A0 32 73 55     	LD (SFX_INIT_STATUS), A
 106+ 55A3              .L1:
 107+ 55A3 D1               POP DE
 108+ 55A4 C1               POP BC
 109+ 55A5 C3 A8 5D         JP RESTORE_PAGE_INFO
 110+ 55A8              ; *******************************************************************************************************
 111+ 55A8               ENDIF
 112+ 55A8
 113+ 55A8              ; *******************************************************************************************************
 114+ 55A8              ; function to handle CALL SNDPLYON basic extension
 115+ 55A8              ; enables sound player
 116+ 55A8              ; _SNDPLYON
 117+ 55A8              ; sets SOUND_ENABLED variable to 1 if init call was done
 118+ 55A8              ; if not throws out of data error
 119+ 55A8              SNDPLYON_DEFUSR:
 120+ 55A8              SNDPLYON:
 121+ 55A8 3A 72 55     	LD A, (MUSIC_INIT_STATUS)
 122+ 55AB B7           	OR A
 123+ 55AC 20 05        	JR NZ, .L1
 124+ 55AE              	; player not initialized, throw error
 125+ 55AE 1E 04        	LD E, 04 ; Out of DATA
 126+ 55B0 C3 A6 5E     	JP THROW_ERROR
 127+ 55B3              .L1:
 128+ 55B3 32 74 55     	LD (SOUND_ENABLED), A
 129+ 55B6              	; disable key click
 130+ 55B6 AF           	XOR A
 131+ 55B7 32 DB F3     	LD (CLIKSW), A
 132+ 55BA C9           	RET
 133+ 55BB              ; *******************************************************************************************************
 134+ 55BB
 135+ 55BB              ; *******************************************************************************************************
 136+ 55BB              ; function to handle CALL SNDPLYOFF basic extension
 137+ 55BB              ; disables sound player
 138+ 55BB              ; _SNDPLYOFF
 139+ 55BB              ; sets SOUND_ENABLED variable to 0
 140+ 55BB              ; calls AKG to stop music and SFX on all channels if initialized
 141+ 55BB              SNDPLYOFF_DEFUSR:
 142+ 55BB              SNDPLYOFF:
 143+ 55BB 3A 74 55     	LD A, (SOUND_ENABLED)
 144+ 55BE B7           	OR A
 145+ 55BF C8           	RET Z ; already stopped
 146+ 55C0 AF           	XOR A
 147+ 55C1 32 74 55     	LD (SOUND_ENABLED), A
 148+ 55C4 E5           	PUSH HL
 149+ 55C5 CD 24 42     	CALL PLY_AKG_STOP
 150+ 55C8 3A 73 55     	LD A, (SFX_INIT_STATUS)
 151+ 55CB B7           	OR A
 152+ 55CC 28 0E        	JR Z, .EXIT ; SFX not in use
 153+ 55CE AF           	XOR A
 154+ 55CF CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 155+ 55D2 3E 01        	LD A, 1
 156+ 55D4 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 157+ 55D7 3E 02        	LD A, 2
 158+ 55D9 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 159+ 55DC              .EXIT:
 160+ 55DC E1           	POP HL
 161+ 55DD C9           	RET
 162+ 55DE              ; *******************************************************************************************************
 163+ 55DE
 164+ 55DE               IF (BASIC_EXTENSION == 1)
 165+ 55DE ~            ; *******************************************************************************************************
 166+ 55DE ~            ; function to handle CALL SNDSFX basic extension
 167+ 55DE ~            ; plays a sound effect
 168+ 55DE ~            ; _SNDSFX ( BYTE sfx_number, >0
 169+ 55DE ~            ;			BYTE channel, = 0,1 or 2
 170+ 55DE ~            ;			BYTE inverted_volume = 0-16, 0 being full volume
 171+ 55DE ~            ; will put ram in page 0 also, page 1 is already there
 172+ 55DE ~            ; if sound off throws illegal function call
 173+ 55DE ~            ; if sfx not initialized, throws out of data
 174+ 55DE ~            SNDSFX:
 175+ 55DE ~            	; opening (
 176+ 55DE ~            	CALL CHKCHAR
 177+ 55DE ~            	DB '('
 178+ 55DE ~            	; get sfx_number
 179+ 55DE ~            	LD IX, GETBYT
 180+ 55DE ~            	CALL CALBAS
 181+ 55DE ~            	PUSH DE
 182+ 55DE ~            	; comma
 183+ 55DE ~            	CALL CHKCHAR
 184+ 55DE ~            	DB ','
 185+ 55DE ~            	; get sfx address
 186+ 55DE ~            	LD IX, GETBYT
 187+ 55DE ~            	CALL CALBAS
 188+ 55DE ~            	PUSH DE
 189+ 55DE ~            	; comma
 190+ 55DE ~            	CALL CHKCHAR
 191+ 55DE ~            	DB ','
 192+ 55DE ~            	; get inverted volume
 193+ 55DE ~            	LD IX, GETBYT
 194+ 55DE ~            	CALL CALBAS
 195+ 55DE ~            	PUSH DE
 196+ 55DE ~            	; ending )
 197+ 55DE ~            	CALL CHKCHAR
 198+ 55DE ~            	DB ')'
 199+ 55DE ~
 200+ 55DE ~            	LD A, (SOUND_ENABLED)
 201+ 55DE ~            	OR A
 202+ 55DE ~            	JR NZ, .L1
 203+ 55DE ~            	; sound disabled, throw illegal function call
 204+ 55DE ~            	LD E, 5
 205+ 55DE ~            	JP THROW_ERROR
 206+ 55DE ~            .L1:
 207+ 55DE ~            	LD A, (SFX_INIT_STATUS)
 208+ 55DE ~            	OR A
 209+ 55DE ~            	JR NZ, .L2
 210+ 55DE ~            	; sfx data not initialized, throw out of data
 211+ 55DE ~            	LD E, 4
 212+ 55DE ~            	JP THROW_ERROR
 213+ 55DE ~            .L2:
 214+ 55DE ~            	; pop  parameters and store away for later
 215+ 55DE ~            	POP DE ; inverted volume
 216+ 55DE ~            	LD B, E
 217+ 55DE ~            	POP DE ; channel
 218+ 55DE ~            	LD C, E
 219+ 55DE ~            	POP DE
 220+ 55DE ~            	LD A, E
 221+ 55DE ~            	EX AF, AF'
 222+ 55DE ~            	PUSH HL ; basic text location
 223+ 55DE ~            	EXX
 224+ 55DE ~            	LD IY, .RET
 225+ 55DE ~            	JP ENABLE_PAGE0
 226+ 55DE ~            .RET:
 227+ 55DE ~            	EXX
 228+ 55DE ~            	EX AF, AF'
 229+ 55DE ~            	CALL PLY_AKG_PLAYSOUNDEFFECT
 230+ 55DE ~
 231+ 55DE ~                POP DE
 232+ 55DE ~                POP BC
 233+ 55DE ~                CALL RESTORE_PAGE_INFO
 234+ 55DE ~
 235+ 55DE ~            	POP HL
 236+ 55DE ~            	RET
 237+ 55DE ~            ; *******************************************************************************************************
 238+ 55DE               ENDIF
 239+ 55DE
 240+ 55DE               IF (DEFUSR_EXTENSION == 1)
 241+ 55DE              ; *******************************************************************************************************
 242+ 55DE              ; same as SNDSFX but for DEFUSR approach
 243+ 55DE              ; input IX=pointer to input array, real data from +2
 244+ 55DE              ; +2 = SFX number
 245+ 55DE              ; +4 = channel
 246+ 55DE              ; +6 = volume
 247+ 55DE              SNDSFX_DEFUSR:
 248+ 55DE 3A 74 55     	LD A, (SOUND_ENABLED)
 249+ 55E1 B7           	OR A
 250+ 55E2 C8           	RET Z ; sound disabled, just exit
 251+ 55E3 3A 73 55     	LD A, (SFX_INIT_STATUS)
 252+ 55E6 B7           	OR A
 253+ 55E7 C8           	RET Z ; sfx data not initialized, just exit
 254+ 55E8 FD 21 EF 55  	LD IY, .RET
 255+ 55EC C3 31 5E     	JP ENABLE_PAGE0
 256+ 55EF              .RET:
 257+ 55EF FB           	EI
 258+ 55F0 DD 7E 02     	LD A,(IX+2) ; SFX number
 259+ 55F3 DD 4E 04     	LD C,(IX+4) ; channel
 260+ 55F6 DD 46 06     	LD B,(IX+6) ; volume
 261+ 55F9 CD 24 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
 262+ 55FC D1               POP DE
 263+ 55FD C1               POP BC
 264+ 55FE C3 A8 5D         JP RESTORE_PAGE_INFO
 265+ 5601              ; *******************************************************************************************************
 266+ 5601               ENDIF
# file closed: asm\SOUND.asm
 141  5601               ENDIF
 142  5601
 143  5601               IF (VRAM_CMDS == 1)
 144  5601               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
   1+ 5601               IF (BASIC_EXTENSION == 1)
   2+ 5601 ~            ; *******************************************************************************************************
   3+ 5601 ~            ; function to handle CALL FILVRM basic extension
   4+ 5601 ~            ; FILVRM ( INT offset,
   5+ 5601 ~            ;		   INT count,
   6+ 5601 ~            ;		   BYTE value,
   7+ 5601 ~            ;		   BYTE wait_vsync) >0 = true
   8+ 5601 ~            ; wait_vsync will issue HALT before copying
   9+ 5601 ~            FILVRM:
  10+ 5601 ~            	; opening (
  11+ 5601 ~            	CALL CHKCHAR
  12+ 5601 ~            	DB '('
  13+ 5601 ~            	; get offset address
  14+ 5601 ~            	LD IX, FRMQNT
  15+ 5601 ~            	CALL CALBAS
  16+ 5601 ~            	PUSH DE
  17+ 5601 ~            	; comma
  18+ 5601 ~            	CALL CHKCHAR
  19+ 5601 ~            	DB ','
  20+ 5601 ~            	; get count
  21+ 5601 ~            	LD IX, FRMQNT
  22+ 5601 ~            	CALL CALBAS
  23+ 5601 ~            	PUSH DE
  24+ 5601 ~            	; comma
  25+ 5601 ~            	CALL CHKCHAR
  26+ 5601 ~            	DB ','
  27+ 5601 ~            	; get value
  28+ 5601 ~            	LD IX, GETBYT
  29+ 5601 ~            	CALL CALBAS
  30+ 5601 ~            	PUSH AF
  31+ 5601 ~            	; comma
  32+ 5601 ~            	CALL CHKCHAR
  33+ 5601 ~            	DB ','
  34+ 5601 ~            	; get vsync wait
  35+ 5601 ~            	LD IX, GETBYT
  36+ 5601 ~            	CALL CALBAS
  37+ 5601 ~            	PUSH AF
  38+ 5601 ~            	; ending )
  39+ 5601 ~            	CALL CHKCHAR
  40+ 5601 ~            	DB ')'
  41+ 5601 ~
  42+ 5601 ~            	; save position
  43+ 5601 ~            	PUSH HL
  44+ 5601 ~            	POP IX
  45+ 5601 ~
  46+ 5601 ~            	; syntax ok
  47+ 5601 ~            	; wait for vsync if needed
  48+ 5601 ~            	POP AF
  49+ 5601 ~            	OR A
  50+ 5601 ~            	JR Z, .L1
  51+ 5601 ~            	HALT
  52+ 5601 ~
  53+ 5601 ~            .L1:
  54+ 5601 ~            	LD A,1
  55+ 5601 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  56+ 5601 ~                POP AF ; value
  57+ 5601 ~                POP BC ; count
  58+ 5601 ~                POP HL ; offset
  59+ 5601 ~                CALL BIOS_FILVRM
  60+ 5601 ~            	XOR A
  61+ 5601 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  62+ 5601 ~
  63+ 5601 ~            .L3:
  64+ 5601 ~            	PUSH IX
  65+ 5601 ~            	POP HL
  66+ 5601 ~            	RET
  67+ 5601 ~            ; *******************************************************************************************************
  68+ 5601               ENDIF
  69+ 5601
  70+ 5601               IF (DEFUSR_EXTENSION == 1)
  71+ 5601              ; *******************************************************************************************************
  72+ 5601              ; same as FILVRM but for DEFUSR approach
  73+ 5601              ; input IX=pointer to input array, real data from +2
  74+ 5601              ; +2 = offset
  75+ 5601              ; +4 = count
  76+ 5601              ; +6 = value
  77+ 5601              ; +8 = halt flag
  78+ 5601              FILVRM_DEFUSR:
  79+ 5601 DD 7E 08     	LD A,(IX+8)
  80+ 5604 B7           	OR A
  81+ 5605 28 01        	JR Z,.L0
  82+ 5607 76           	HALT
  83+ 5608              .L0:
  84+ 5608 3E 01        	LD A,1
  85+ 560A 32 18 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
  86+ 560D DD 6E 02     	LD L,(IX+2)
  87+ 5610 DD 66 03     	LD H,(IX+3)
  88+ 5613 DD 4E 04     	LD C,(IX+4)
  89+ 5616 DD 46 05     	LD B,(IX+5)
  90+ 5619 DD 7E 06     	LD A,(IX+6)
  91+ 561C CD 56 00     	CALL BIOS_FILVRM
  92+ 561F AF           	XOR A
  93+ 5620 32 18 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
  94+ 5623 C9           	RET
  95+ 5624              ; *******************************************************************************************************
  96+ 5624               ENDIF
  97+ 5624
  98+ 5624               IF (BASIC_EXTENSION == 1)
  99+ 5624 ~            ; *******************************************************************************************************
 100+ 5624 ~            ; function to handle CALL MEMVRM basic extension
 101+ 5624 ~            ; copies from RAM to VRAM
 102+ 5624 ~            ; _MEMVRM ( INT source,
 103+ 5624 ~            ;			INT destination,
 104+ 5624 ~            ;			INT count,
 105+ 5624 ~            ;			BYTE wait_vsync) >0 = true
 106+ 5624 ~            ; will put ram in page 0 also, page 1 is already there
 107+ 5624 ~            ; wait_vsync will issue HALT before copying
 108+ 5624 ~            MEMVRM:
 109+ 5624 ~            	; opening (
 110+ 5624 ~            	CALL CHKCHAR
 111+ 5624 ~            	DB '('
 112+ 5624 ~            	; get source address
 113+ 5624 ~            	LD IX, FRMQNT
 114+ 5624 ~            	CALL CALBAS
 115+ 5624 ~            	PUSH DE
 116+ 5624 ~            	; comma
 117+ 5624 ~            	CALL CHKCHAR
 118+ 5624 ~            	DB ','
 119+ 5624 ~            	; get destination address
 120+ 5624 ~            	LD IX, FRMQNT
 121+ 5624 ~            	CALL CALBAS
 122+ 5624 ~            	PUSH DE
 123+ 5624 ~            	; comma
 124+ 5624 ~            	CALL CHKCHAR
 125+ 5624 ~            	DB ','
 126+ 5624 ~            	; get length
 127+ 5624 ~            	LD IX, FRMQNT
 128+ 5624 ~            	CALL CALBAS
 129+ 5624 ~            	PUSH DE
 130+ 5624 ~            	; comma
 131+ 5624 ~            	CALL CHKCHAR
 132+ 5624 ~            	DB ','
 133+ 5624 ~            	; get vsync wait
 134+ 5624 ~            	LD IX, GETBYT
 135+ 5624 ~            	CALL CALBAS
 136+ 5624 ~            	PUSH AF
 137+ 5624 ~            	; ending )
 138+ 5624 ~            	CALL CHKCHAR
 139+ 5624 ~            	DB ')'
 140+ 5624 ~
 141+ 5624 ~                ; save position in BASIC text
 142+ 5624 ~            	PUSH HL
 143+ 5624 ~            	POP IX
 144+ 5624 ~
 145+ 5624 ~            	POP AF ; wait vsync
 146+ 5624 ~            	OR A
 147+ 5624 ~            	JR Z, .L1
 148+ 5624 ~            	HALT
 149+ 5624 ~            .L1:
 150+ 5624 ~            	; pop LDIR parameters and store away for later
 151+ 5624 ~            	POP BC ; count
 152+ 5624 ~            	POP DE ; vram destination
 153+ 5624 ~            	POP HL ; ram source
 154+ 5624 ~            	EXX
 155+ 5624 ~             	LD IY, .RET
 156+ 5624 ~            	JP ENABLE_PAGE0
 157+ 5624 ~            .RET:
 158+ 5624 ~            	EI
 159+ 5624 ~            	EXX
 160+ 5624 ~            	CALL VRAM_LDIRVM
 161+ 5624 ~                POP DE
 162+ 5624 ~                POP BC
 163+ 5624 ~                CALL RESTORE_PAGE_INFO
 164+ 5624 ~            	PUSH IX
 165+ 5624 ~            	POP HL
 166+ 5624 ~            	RET
 167+ 5624 ~            ; *******************************************************************************************************
 168+ 5624               ENDIF
 169+ 5624
 170+ 5624               IF (DEFUSR_EXTENSION == 1)
 171+ 5624              ; *******************************************************************************************************
 172+ 5624              ; same as MEMVRM but for DEFUSR approach
 173+ 5624              ; input IX=pointer to input array, real data from +2
 174+ 5624              ; +2 = source address
 175+ 5624              ; +4 = destination address
 176+ 5624              ; +6 = lenght
 177+ 5624              ; +8 = vsync wait flag
 178+ 5624              MEMVRM_DEFUSR:
 179+ 5624 DD 7E 08     	LD A,(IX+8)
 180+ 5627 B7           	OR A
 181+ 5628 28 01        	JR Z,.L0
 182+ 562A 76           	HALT
 183+ 562B              .L0:
 184+ 562B              	; enable page 0
 185+ 562B FD 21 32 56  	LD IY, .RET
 186+ 562F C3 31 5E     	JP ENABLE_PAGE0
 187+ 5632              .RET:
 188+ 5632 FB           	EI
 189+ 5633 DD 6E 02     	LD L,(IX+2)
 190+ 5636 DD 66 03     	LD H,(IX+3)
 191+ 5639 DD 5E 04     	LD E,(IX+4)
 192+ 563C DD 56 05     	LD D,(IX+5)
 193+ 563F DD 4E 06     	LD C,(IX+6)
 194+ 5642 DD 46 07     	LD B,(IX+7)
 195+ 5645 CD 4D 56     	CALL VRAM_LDIRVM
 196+ 5648 D1               POP DE
 197+ 5649 C1               POP BC
 198+ 564A C3 A8 5D         JP RESTORE_PAGE_INFO
 199+ 564D              ; *******************************************************************************************************
 200+ 564D               ENDIF
 201+ 564D
 202+ 564D              ; *******************************************************************************************************
 203+ 564D              ; common code to copy from memory to VRAM
 204+ 564D              ; input HL=RAM source
 205+ 564D              ; input DE=VRAM destination
 206+ 564D              ; BC=count
 207+ 564D              VRAM_LDIRVM:
 208+ 564D 3E 01        	LD A,1
 209+ 564F 32 18 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 210+ 5652 EB           	EX DE, HL
 211+ 5653 F3           	DI
 212+ 5654 CD 58 5D     	CALL SETWRT_LOCAL
 213+ 5657 FB           	EI
 214+ 5658 EB           	EX DE, HL
 215+ 5659 78           	LD A, B
 216+ 565A B7           	OR A
 217+ 565B 28 0D        	JR Z, .L3
 218+ 565D C5           	PUSH BC
 219+ 565E 0E 98        	LD C, #98
 220+ 5660              .L2:
 221+ 5660 50           	LD D, B
 222+ 5661 06 00        	LD B, 0
 223+ 5663 CD 65 5D     	CALL BBYTECOPY_NO_C
 224+ 5666 42           	LD B, D
 225+ 5667 10 F7        	DJNZ .L2
 226+ 5669 C1           	POP BC
 227+ 566A              .L3:
 228+ 566A 79           	LD A, C
 229+ 566B B7           	OR A
 230+ 566C 28 04        	JR Z,.L4
 231+ 566E 41           	LD B, C
 232+ 566F CD 63 5D     	CALL BBYTECOPY
 233+ 5672              .L4:
 234+ 5672 AF           	XOR A
 235+ 5673 32 18 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 236+ 5676 C9           	RET
 237+ 5677              ; *******************************************************************************************************
 238+ 5677
 239+ 5677               IF (BASIC_EXTENSION == 1)
 240+ 5677 ~            ; *******************************************************************************************************
 241+ 5677 ~            ; function to handle CALL VRMMEM basic extension
 242+ 5677 ~            ; copies from RAM to VRAM
 243+ 5677 ~            ; _VRMMEM ( INT source,
 244+ 5677 ~            ;			INT destination,
 245+ 5677 ~            ;			INT count
 246+ 5677 ~            ; will put ram in page 0 also, page 1 is already there
 247+ 5677 ~            VRMMEM:
 248+ 5677 ~            	; opening (
 249+ 5677 ~            	CALL CHKCHAR
 250+ 5677 ~            	DB '('
 251+ 5677 ~            	; get source address
 252+ 5677 ~            	LD IX, FRMQNT
 253+ 5677 ~            	CALL CALBAS
 254+ 5677 ~            	PUSH DE
 255+ 5677 ~            	; comma
 256+ 5677 ~            	CALL CHKCHAR
 257+ 5677 ~            	DB ','
 258+ 5677 ~            	; get destination address
 259+ 5677 ~            	LD IX, FRMQNT
 260+ 5677 ~            	CALL CALBAS
 261+ 5677 ~            	PUSH DE
 262+ 5677 ~            	; comma
 263+ 5677 ~            	CALL CHKCHAR
 264+ 5677 ~            	DB ','
 265+ 5677 ~            	; get length
 266+ 5677 ~            	LD IX, FRMQNT
 267+ 5677 ~            	CALL CALBAS
 268+ 5677 ~            	PUSH DE
 269+ 5677 ~            	; ending )
 270+ 5677 ~            	CALL CHKCHAR
 271+ 5677 ~            	DB ')'
 272+ 5677 ~
 273+ 5677 ~                ; save position in BASIC text
 274+ 5677 ~            	PUSH HL
 275+ 5677 ~            	POP IX
 276+ 5677 ~
 277+ 5677 ~            	POP BC ; count
 278+ 5677 ~            	POP DE ; destination
 279+ 5677 ~            	POP HL ; source
 280+ 5677 ~            	EXX
 281+ 5677 ~            	LD IY, .RET
 282+ 5677 ~            	JP ENABLE_PAGE0
 283+ 5677 ~            .RET:
 284+ 5677 ~            	EI
 285+ 5677 ~            	EXX
 286+ 5677 ~            	CALL VRAM_LDIRMV
 287+ 5677 ~                POP DE
 288+ 5677 ~                POP BC
 289+ 5677 ~                CALL RESTORE_PAGE_INFO
 290+ 5677 ~            	PUSH IX
 291+ 5677 ~            	POP HL
 292+ 5677 ~            	RET
 293+ 5677 ~            ; *******************************************************************************************************
 294+ 5677               ENDIF
 295+ 5677
 296+ 5677               IF (DEFUSR_EXTENSION == 1)
 297+ 5677              ; *******************************************************************************************************
 298+ 5677              ; same as VRMMEM but for DEFUSR approach
 299+ 5677              ; input IX=pointer to input array, real data from +2
 300+ 5677              ; +2 = source address
 301+ 5677              ; +4 = destination address
 302+ 5677              ; +6 = count
 303+ 5677              VRMMEM_DEFUSR:
 304+ 5677              	; enable page 0
 305+ 5677 FD 21 7E 56  	LD IY, .RET
 306+ 567B C3 31 5E     	JP ENABLE_PAGE0
 307+ 567E              .RET:
 308+ 567E FB           	EI
 309+ 567F DD 6E 02     	LD L,(IX+2)
 310+ 5682 DD 66 03     	LD H,(IX+3)
 311+ 5685 DD 5E 04     	LD E,(IX+4)
 312+ 5688 DD 56 05     	LD D,(IX+5)
 313+ 568B DD 4E 06     	LD C,(IX+6)
 314+ 568E DD 46 07     	LD B,(IX+7)
 315+ 5691 CD 99 56     	CALL VRAM_LDIRMV
 316+ 5694 D1               POP DE
 317+ 5695 C1               POP BC
 318+ 5696 C3 A8 5D         JP RESTORE_PAGE_INFO
 319+ 5699              ; *******************************************************************************************************
 320+ 5699               ENDIF
 321+ 5699
 322+ 5699              ; *******************************************************************************************************
 323+ 5699              ; common code to copy from VRAM to RAM
 324+ 5699              ; input HL=VRAM source
 325+ 5699              ; input DE=RAM destination
 326+ 5699              ; BC=count
 327+ 5699              VRAM_LDIRMV:
 328+ 5699 3E 01        	LD A,1
 329+ 569B 32 18 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 330+ 569E 7D           	LD	A, L
 331+ 569F F3           	DI
 332+ 56A0 D3 99        	OUT	(099H), A
 333+ 56A2 7C           	LD	A, H
 334+ 56A3 E6 3F        	AND	03FH
 335+ 56A5 D3 99        	OUT	(099H), A
 336+ 56A7 FB           	EI
 337+ 56A8              .L4:
 338+ 56A8 DB 98            IN A, (#98)
 339+ 56AA 12           	LD (DE), A
 340+ 56AB 13               INC DE
 341+ 56AC 0B               DEC BC
 342+ 56AD 79               LD A, C
 343+ 56AE B0               OR B
 344+ 56AF 20 F7            JR NZ, .L4
 345+ 56B1 AF           	XOR A
 346+ 56B2 32 18 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 347+ 56B5 C9               RET
 348+ 56B6              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
 145  56B6               ENDIF
 146  56B6
 147  56B6               IF (GENCAL_CMD == 1)
 148  56B6               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
   1+ 56B6               IF (DEFUSR_EXTENSION == 1)
   2+ 56B6              ; *******************************************************************************************************
   3+ 56B6              ; same as GENCAL but for DEFUSR approach
   4+ 56B6              ; input IX=pointer to input array, real data from +2
   5+ 56B6              ; +2 = function address to call
   6+ 56B6              ; +4 = register list array pointer
   7+ 56B6              GENCAL_DEFUSR:
   8+ 56B6 DD 6E 02         LD L,(IX+2)
   9+ 56B9 DD 66 03         LD H,(IX+3)
  10+ 56BC E5               PUSH HL
  11+ 56BD DD 6E 04         LD L,(IX+4)
  12+ 56C0 DD 66 05         LD H,(IX+5)
  13+ 56C3 E5               PUSH HL
  14+ 56C4 18 00            JR GENCAL.COMMON
  15+ 56C6              ; *******************************************************************************************************
  16+ 56C6               ENDIF
  17+ 56C6
  18+ 56C6              ; *******************************************************************************************************
  19+ 56C6              ; function to handle CALL GENCAL basic extension
  20+ 56C6              ; GENCAL ( INT fn_addr, = address of the function to call
  21+ 56C6              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
  22+ 56C6              ; output values of registers will also be stored at reg_list_ptr
  23+ 56C6              GENCAL:
  24+ 56C6               IF (BASIC_EXTENSION == 1)
  25+ 56C6 ~            	; opening (
  26+ 56C6 ~            	CALL CHKCHAR
  27+ 56C6 ~            	DB '('
  28+ 56C6 ~            	; get function address
  29+ 56C6 ~            	LD IX, FRMQNT
  30+ 56C6 ~            	CALL CALBAS
  31+ 56C6 ~            	PUSH DE
  32+ 56C6 ~            	; comma
  33+ 56C6 ~            	CALL CHKCHAR
  34+ 56C6 ~            	DB ','
  35+ 56C6 ~            	; get pointer to register list
  36+ 56C6 ~                LD A,2
  37+ 56C6 ~                LD B,1
  38+ 56C6 ~                LD DE,#0500
  39+ 56C6 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
  40+ 56C6 ~            	PUSH BC
  41+ 56C6 ~            	; ending )
  42+ 56C6 ~            	CALL CHKCHAR
  43+ 56C6 ~            	DB ')'
  44+ 56C6               ENDIF
  45+ 56C6              .COMMON:
  46+ 56C6              	; save BASIC token position
  47+ 56C6 E5           	PUSH HL
  48+ 56C7 D9               EXX
  49+ 56C8 E1           	POP HL ; HL'=next basic token
  50+ 56C9 D9               EXX
  51+ 56CA
  52+ 56CA E1               POP HL ; get pointer to register values
  53+ 56CB F3           	DI
  54+ 56CC ED 73 07 5D      LD (BLIT_STRUCT), SP
  55+ 56D0 F9               LD SP, HL
  56+ 56D1 F1               POP AF
  57+ 56D2 C1               POP BC
  58+ 56D3 D1               POP DE
  59+ 56D4 E1               POP HL
  60+ 56D5 DD E1            POP IX
  61+ 56D7 FD E1            POP IY
  62+ 56D9 D9               EXX
  63+ 56DA ED 73 09 5D      LD (BLIT_STRUCT+2), SP
  64+ 56DE ED 7B 07 5D      LD SP, (BLIT_STRUCT)
  65+ 56E2 FB               EI
  66+ 56E3 D1               POP DE ; get function to call
  67+ 56E4 E5               PUSH HL
  68+ 56E5 CD 00 57         CALL .EXXDECALL
  69+ 56E8 F3               DI
  70+ 56E9 ED 73 07 5D      LD (BLIT_STRUCT), SP
  71+ 56ED ED 7B 09 5D      LD SP, (BLIT_STRUCT+2)
  72+ 56F1 FD E5            PUSH IY
  73+ 56F3 DD E5            PUSH IX
  74+ 56F5 E5               PUSH HL
  75+ 56F6 D5               PUSH DE
  76+ 56F7 C5               PUSH BC
  77+ 56F8 F5               PUSH AF
  78+ 56F9 ED 7B 07 5D      LD SP, (BLIT_STRUCT)
  79+ 56FD FB               EI
  80+ 56FE E1               POP HL
  81+ 56FF C9           	RET
  82+ 5700
  83+ 5700              .EXXDECALL:
  84+ 5700 D5               PUSH DE
  85+ 5701 D9               EXX
  86+ 5702 C9               RET
  87+ 5703              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
 149  5703               ENDIF
 150  5703
 151  5703               IF (BOX_CMDS == 1)
 152  5703               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
   1+ 5703              ; *******************************************************************************************************
   2+ 5703              ; generic function to implement rectangle data copy
   3+ 5703              ; should be modified to call appropriate function for memory or vram
   4+ 5703              ; input IX=pointer to following structure
   5+ 5703              ; +00 source data pointer
   6+ 5703              ; +02 num bytes in a row
   7+ 5703              ; +04 number of rows
   8+ 5703              ; +06 source add-to value till next row
   9+ 5703              ; +08 destination address
  10+ 5703              ; +10 destination add-to value till next row
  11+ 5703              ; modifies AF, BC, DE, HL
  12+ 5703              RECTANGLE_COPY:
  13+ 5703 DD 6E 00     	LD L, (IX+0)
  14+ 5706 DD 66 01     	LD H, (IX+1) ; source address
  15+ 5709 DD 5E 08     	LD E, (IX+8)
  16+ 570C DD 56 09     	LD D, (IX+9) ; destination
  17+ 570F DD 46 04     	LD B, (IX+4) ; row number
  18+ 5712              .L1:
  19+ 5712 C5           	PUSH BC
  20+ 5713 E5           		PUSH HL
  21+ 5714 D5           			PUSH DE
  22+ 5715 DD 4E 02     				LD C, (IX+2)
  23+ 5718 DD 46 03     				LD B, (IX+3) ; num bytes in a row
  24+ 571B              .CALL1:
  25+ 571B CD 00 00     				CALL 0 ; set destination address from DE
  26+ 571E              .CALL2:
  27+ 571E CD 00 00     				CALL 0 ; copy data fn
  28+ 5721 E1           			POP HL
  29+ 5722 DD 4E 0A     			LD C, (IX+10)
  30+ 5725 DD 46 0B     			LD B, (IX+11) ; destination add-to
  31+ 5728 09           			ADD HL, BC
  32+ 5729 EB           			EX DE, HL
  33+ 572A E1           		POP HL
  34+ 572B DD 4E 06     		LD C, (IX+6)
  35+ 572E DD 46 07     		LD B, (IX+7) ; src add-to
  36+ 5731 09           		ADD HL, BC
  37+ 5732 C1           	POP BC
  38+ 5733 10 DD        	DJNZ .L1
  39+ 5735 C9           	RET
  40+ 5736              ; *******************************************************************************************************
  41+ 5736
  42+ 5736               IF (BASIC_EXTENSION == 1)
  43+ 5736 ~            ; *******************************************************************************************************
  44+ 5736 ~            ; function to handle CALL BOXMEMCPY basic extension
  45+ 5736 ~            ; copies data with window like boundaries within ram
  46+ 5736 ~            ; BOXMEMCPY ( INT source data pointer,
  47+ 5736 ~            ;			  INT source number of bytes in a row,
  48+ 5736 ~            ;			  INT number of rows,
  49+ 5736 ~            ;			  INT source add-to value till next row,
  50+ 5736 ~            ; 			  INT destination pointer,
  51+ 5736 ~            ;			  INT destination add-to value till next row )
  52+ 5736 ~            ; request_data_ptr described in RECTANGLE_COPY
  53+ 5736 ~            ; will put ram in page 0 also, page 1 is already there
  54+ 5736 ~            BOXMEMCPY:
  55+ 5736 ~            	LD DE,BOXMEMCPY_COMMON
  56+ 5736 ~            	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
  57+ 5736 ~            	JP BOX_EXTENSION_PARAMS_COMMON
  58+ 5736               ENDIF
  59+ 5736
  60+ 5736               IF (DEFUSR_EXTENSION == 1)
  61+ 5736              ; *******************************************************************************************************
  62+ 5736              ; same as BOXMEMCPY but for DEFUSR approach
  63+ 5736              ; input IX=pointer to input array, real data from +2
  64+ 5736              ; +02 = source data pointer
  65+ 5736              ; +04 = source number of bytes in a row
  66+ 5736              ; +06 = number of rows
  67+ 5736              ; +08 = source add-to value till next row
  68+ 5736              ; +10 = destination pointer
  69+ 5736              ; +12 = destination add-to value till next row
  70+ 5736              BOXMEMCPY_DEFUSR:
  71+ 5736 21 43 57     	LD HL,BOXMEMCPY_COMMON
  72+ 5739 22 59 57     	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
  73+ 573C DD 23        	INC IX
  74+ 573E DD 23        	INC IX
  75+ 5740 C3 56 57     	JP BOXCOMMON_DEFUSR
  76+ 5743               ENDIF
  77+ 5743
  78+ 5743              BOXMEMCPY_COMMON:
  79+ 5743 FB           	EI
  80+ 5744              	; set RAM functions to call
  81+ 5744 21 00 00     	LD HL, 0
  82+ 5747 22 1B 57     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
  83+ 574A 22 1D 57     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
  84+ 574D 21 ED B0     	LD HL, #B0ED ; LDIR
  85+ 5750 22 1F 57     	LD (RECTANGLE_COPY.CALL1+4), HL
  86+ 5753 C3 5E 57     	JP BOXCOMMON_DEFUSR.CALL
  87+ 5756              ; *******************************************************************************************************
  88+ 5756
  89+ 5756               IF (BASIC_EXTENSION == 1)
  90+ 5756 ~            ; *******************************************************************************************************
  91+ 5756 ~            ; common parts of BOX commands to load parameters
  92+ 5756 ~            BOX_EXTENSION_PARAMS_COMMON:
  93+ 5756 ~            	; opening (
  94+ 5756 ~            	CALL CHKCHAR
  95+ 5756 ~            	DB '('
  96+ 5756 ~            	; get source data pointer
  97+ 5756 ~            	LD IX, FRMQNT
  98+ 5756 ~            	CALL CALBAS
  99+ 5756 ~            	LD (BLIT_STRUCT+0), DE
 100+ 5756 ~            	; comma
 101+ 5756 ~            	CALL CHKCHAR
 102+ 5756 ~            	DB ','
 103+ 5756 ~            	; source number of bytes in a row
 104+ 5756 ~            	LD IX, FRMQNT
 105+ 5756 ~            	CALL CALBAS
 106+ 5756 ~            	LD (BLIT_STRUCT+2), DE
 107+ 5756 ~            	; comma
 108+ 5756 ~            	CALL CHKCHAR
 109+ 5756 ~            	DB ','
 110+ 5756 ~            	; number of rows
 111+ 5756 ~            	LD IX, FRMQNT
 112+ 5756 ~            	CALL CALBAS
 113+ 5756 ~            	LD (BLIT_STRUCT+4), DE
 114+ 5756 ~            	; comma
 115+ 5756 ~            	CALL CHKCHAR
 116+ 5756 ~            	DB ','
 117+ 5756 ~            	; source add-to value till next row
 118+ 5756 ~            	LD IX, FRMQNT
 119+ 5756 ~            	CALL CALBAS
 120+ 5756 ~            	LD (BLIT_STRUCT+6), DE
 121+ 5756 ~            	; comma
 122+ 5756 ~            	CALL CHKCHAR
 123+ 5756 ~            	DB ','
 124+ 5756 ~            	; destination pointer
 125+ 5756 ~            	LD IX, FRMQNT
 126+ 5756 ~            	CALL CALBAS
 127+ 5756 ~            	LD (BLIT_STRUCT+8), DE
 128+ 5756 ~            	; comma
 129+ 5756 ~            	CALL CHKCHAR
 130+ 5756 ~            	DB ','
 131+ 5756 ~            	; destination add-to value till next row
 132+ 5756 ~            	LD IX, FRMQNT
 133+ 5756 ~            	CALL CALBAS
 134+ 5756 ~            	LD (BLIT_STRUCT+10), DE
 135+ 5756 ~            	; ending )
 136+ 5756 ~            	CALL CHKCHAR
 137+ 5756 ~            	DB ')'
 138+ 5756 ~            	LD IX,BLIT_STRUCT
 139+ 5756               ENDIF
 140+ 5756              BOXCOMMON_DEFUSR:
 141+ 5756 E5           	PUSH HL ; save position in BASIC buffer
 142+ 5757              .ADDR:
 143+ 5757 FD 21 00 00  	LD IY, 0 ; modified by code
 144+ 575B C3 31 5E     	JP ENABLE_PAGE0
 145+ 575E              .CALL:
 146+ 575E CD 03 57     	CALL RECTANGLE_COPY
 147+ 5761 AF           	XOR A
 148+ 5762 32 18 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 149+ 5765
 150+ 5765 D1               POP DE
 151+ 5766 C1               POP BC
 152+ 5767 CD A8 5D         CALL RESTORE_PAGE_INFO
 153+ 576A
 154+ 576A E1           	POP HL
 155+ 576B C9           	RET
 156+ 576C              ; *******************************************************************************************************
 157+ 576C
 158+ 576C               IF (BASIC_EXTENSION == 1)
 159+ 576C ~            ; *******************************************************************************************************
 160+ 576C ~            ; function to handle CALL BOXMEMVRM basic extension
 161+ 576C ~            ; copies data with window like boundaries from ram to Vram
 162+ 576C ~            ; BOXMEMVRM ( INT source data pointer,
 163+ 576C ~            ;			  INT source number of bytes in a row,
 164+ 576C ~            ;			  INT number of rows,
 165+ 576C ~            ;			  INT source add-to value till next row,
 166+ 576C ~            ; 			  INT destination pointer,
 167+ 576C ~            ;			  INT destination add-to value till next row )
 168+ 576C ~            ; request_data_ptr described in RECTANGLE_COPY
 169+ 576C ~            ; will put ram in page 0 also, page 1 is already there
 170+ 576C ~            BOXMEMVRM:
 171+ 576C ~            	LD DE,BOXMEMVRM_COMMON
 172+ 576C ~            	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
 173+ 576C ~            	JP BOX_EXTENSION_PARAMS_COMMON
 174+ 576C               ENDIF
 175+ 576C
 176+ 576C               IF (DEFUSR_EXTENSION == 1)
 177+ 576C              ; *******************************************************************************************************
 178+ 576C              ; same as BOXMEMVRM but for DEFUSR approach
 179+ 576C              ; input IX=pointer to input array, real data from +2
 180+ 576C              ; +02 = source data pointer
 181+ 576C              ; +04 = source number of bytes in a row
 182+ 576C              ; +06 = number of rows
 183+ 576C              ; +08 = source add-to value till next row
 184+ 576C              ; +10 = destination pointer
 185+ 576C              ; +12 = destination add-to value till next row
 186+ 576C              BOXMEMVRM_DEFUSR:
 187+ 576C 21 79 57     	LD HL,BOXMEMVRM_COMMON
 188+ 576F 22 59 57     	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
 189+ 5772 DD 23        	INC IX
 190+ 5774 DD 23        	INC IX
 191+ 5776 C3 56 57     	JP BOXCOMMON_DEFUSR
 192+ 5779               ENDIF
 193+ 5779
 194+ 5779              BOXMEMVRM_COMMON:
 195+ 5779 FB           	EI
 196+ 577A              	; set RAM functions to call
 197+ 577A 21 94 57     	LD HL, .SETDEST
 198+ 577D 22 1C 57     	LD (RECTANGLE_COPY.CALL1+1), HL
 199+ 5780 21 9C 57     	LD HL, .COPYDATA
 200+ 5783 22 1F 57     	LD (RECTANGLE_COPY.CALL2+1), HL
 201+ 5786 3E CD        	LD A, #CD ; CALL
 202+ 5788 32 1B 57     	LD (RECTANGLE_COPY.CALL1), A
 203+ 578B 32 1E 57     	LD (RECTANGLE_COPY.CALL2), A
 204+ 578E              	;LD A,1
 205+ 578E 32 18 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 206+ 5791 C3 5E 57     	JP BOXCOMMON_DEFUSR.CALL
 207+ 5794              .SETDEST:
 208+ 5794 EB           	EX DE, HL
 209+ 5795 F3           	DI
 210+ 5796 CD 58 5D     	CALL SETWRT_LOCAL
 211+ 5799 FB           	EI
 212+ 579A EB           	EX DE, HL
 213+ 579B C9           	RET
 214+ 579C              .COPYDATA:
 215+ 579C 41           	LD B, C
 216+ 579D C3 63 5D     	JP BBYTECOPY
 217+ 57A0              ; *******************************************************************************************************
# file closed: asm\BOX.asm
 153  57A0               ENDIF
 154  57A0
 155  57A0               IF (BLIT_CMDS == 1)
 156  57A0               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
   1+ 57A0              ; *******************************************************************************************************
   2+ 57A0              ; function rotates mask and data of several characters and applies to background data
   3+ 57A0              ; this handles x-shift from 0 to 4
   4+ 57A0              ; contains self-modifying code that is set-up from external function
   5+ 57A0              ; input HL=pointer to mask data
   6+ 57A0              ; input HL'=pointer to character data
   7+ 57A0              ; input DE=output buffer containing background data
   8+ 57A0              ; input BC=DE+8
   9+ 57A0              ; input A=number of characters to process
  10+ 57A0              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  11+ 57A0              SHIFT04:
  12+ 57A0 08           	EX AF, AF'
  13+ 57A1 7E           	LD A, (HL) ; get mask
  14+ 57A2 D9           	EXX
  15+ 57A3 57           	LD D, A
  16+ 57A4 1E FF        	LD E, #FF
  17+ 57A6 37           	SCF
  18+ 57A7              .M1:
  19+ 57A7 18 FE        	JR .M1 ; this is self-modifying part
  20+ 57A9 CB 1A        	RR D
  21+ 57AB CB 1B        	RR E
  22+ 57AD CB 1A        	RR D
  23+ 57AF CB 1B        	RR E
  24+ 57B1 CB 1A        	RR D
  25+ 57B3 CB 1B        	RR E
  26+ 57B5 CB 1A        	RR D
  27+ 57B7 CB 1B        	RR E
  28+ 57B9
  29+ 57B9 46           	LD B, (HL) ; get data
  30+ 57BA 0E 00        	LD C, 0
  31+ 57BC              .M2:
  32+ 57BC 18 FE        	JR .M2 ; also self-modifying part
  33+ 57BE CB 38        	SRL B
  34+ 57C0 CB 19        	RR C
  35+ 57C2 CB 38        	SRL B
  36+ 57C4 CB 19        	RR C
  37+ 57C6 CB 38        	SRL B
  38+ 57C8 CB 19        	RR C
  39+ 57CA CB 38        	SRL B
  40+ 57CC CB 19        	RR C
  41+ 57CE
  42+ 57CE D9           	EXX
  43+ 57CF 1A           	LD A, (DE) ; background
  44+ 57D0 D9           	EXX
  45+ 57D1 A2           	AND D
  46+ 57D2 B0           	OR B
  47+ 57D3 D9           	EXX
  48+ 57D4 12           	LD (DE), A
  49+ 57D5
  50+ 57D5 0A           	LD A, (BC)
  51+ 57D6 D9           	EXX
  52+ 57D7 A3           	AND E
  53+ 57D8 B1           	OR C
  54+ 57D9 23           	INC HL
  55+ 57DA D9           	EXX
  56+ 57DB 02           	LD (BC), A
  57+ 57DC
  58+ 57DC 23           	INC HL
  59+ 57DD 13           	INC DE
  60+ 57DE 03           	INC BC
  61+ 57DF
  62+ 57DF 08           	EX AF, AF'
  63+ 57E0 3D           	DEC A
  64+ 57E1 C2 A0 57     	JP NZ, SHIFT04
  65+ 57E4 C9           	RET
  66+ 57E5              ; *******************************************************************************************************
  67+ 57E5
  68+ 57E5              ; *******************************************************************************************************
  69+ 57E5              ; function rotates mask and data of several characters and applies to background data
  70+ 57E5              ; this handles x-shift from 5 to 8
  71+ 57E5              ; contains self-modifying code that is set-up from external function
  72+ 57E5              ; input HL=pointer to mask data
  73+ 57E5              ; input HL'=pointer to character data
  74+ 57E5              ; input DE=output buffer containing background data
  75+ 57E5              ; input BC=DE+8
  76+ 57E5              ; input A=number of characters to process
  77+ 57E5              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  78+ 57E5              SHIFT58:
  79+ 57E5 08           	EX AF, AF'
  80+ 57E6 7E           	LD A, (HL) ; get mask
  81+ 57E7 D9           	EXX
  82+ 57E8 57           	LD D, A
  83+ 57E9 1E FF        	LD E, #FF
  84+ 57EB 37           	SCF
  85+ 57EC              .M1:
  86+ 57EC 18 FE        	JR .M1 ; this is self-modifying part
  87+ 57EE CB 12        	RL D
  88+ 57F0 CB 13        	RL E
  89+ 57F2 CB 12        	RL D
  90+ 57F4 CB 13        	RL E
  91+ 57F6 CB 12        	RL D
  92+ 57F8 CB 13        	RL E
  93+ 57FA
  94+ 57FA 46           	LD B, (HL)
  95+ 57FB 0E 00        	LD C, 0
  96+ 57FD              .M2:
  97+ 57FD 18 FE        	JR .M2 ; also self-modifying part
  98+ 57FF CB 20        	SLA B
  99+ 5801 CB 11        	RL C
 100+ 5803 CB 20        	SLA B
 101+ 5805 CB 11        	RL C
 102+ 5807 CB 20        	SLA B
 103+ 5809 CB 11        	RL C
 104+ 580B
 105+ 580B D9           	EXX
 106+ 580C 1A           	LD A, (DE) ; background
 107+ 580D D9           	EXX
 108+ 580E A3           	AND E
 109+ 580F B1           	OR C
 110+ 5810 D9           	EXX
 111+ 5811 12           	LD (DE), A
 112+ 5812
 113+ 5812 0A           	LD A, (BC)
 114+ 5813 D9           	EXX
 115+ 5814 A2           	AND D
 116+ 5815 B0           	OR B
 117+ 5816 23           	INC HL
 118+ 5817 D9           	EXX
 119+ 5818 02           	LD (BC), A
 120+ 5819
 121+ 5819 23           	INC HL
 122+ 581A 13           	INC DE
 123+ 581B 03           	INC BC
 124+ 581C
 125+ 581C 08           	EX AF, AF'
 126+ 581D 3D           	DEC A
 127+ 581E C2 E5 57     	JP NZ, SHIFT58
 128+ 5821 C9           	RET
 129+ 5822              ; *******************************************************************************************************
 130+ 5822
 131+ 5822              ; *******************************************************************************************************
 132+ 5822              ; routine that shifts one row of characters
 133+ 5822              ; contains self-modifying code that is set-up from external function
 134+ 5822              ; input HL=pointer to mask data
 135+ 5822              ; input HL'=pointer to character data
 136+ 5822              ; input DE=output buffer containing background data
 137+ 5822              ; input A=number of characters to process
 138+ 5822              ; input IX=pointer to structure describing input data
 139+ 5822              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 140+ 5822              SHIFT_ROW:
 141+ 5822 F5           	PUSH AF
 142+ 5823 ED 53 03 5D  		LD (BLIT_TMP1), DE
 143+ 5827 E5           		PUSH HL
 144+ 5828 CD 6B 58     			CALL .ADDYSHIFT
 145+ 582B E1           		POP HL
 146+ 582C ED 53 05 5D  		LD (BLIT_TMP2), DE ; DE+vertical shift
 147+ 5830              .L1:
 148+ 5830 3E 08        		LD A, 8
 149+ 5832 DD 96 02     		SUB (IX+2) ; y shift
 150+ 5835              .CALL1:
 151+ 5835 CD 00 00     		CALL 0
 152+ 5838 DD 7E 02     		LD A, (IX+2); y shift
 153+ 583B B7           		OR A
 154+ 583C 28 26        		JR Z, .DONE
 155+ 583E ED 5B 03 5D  		LD DE, (BLIT_TMP1)
 156+ 5842 E5           		PUSH HL
 157+ 5843 CD 79 58     			CALL .DETONEXTROW
 158+ 5846 E1           		POP HL
 159+ 5847              .CALL2:
 160+ 5847 CD 00 00     		CALL 0
 161+ 584A ED 5B 03 5D  		LD DE, (BLIT_TMP1)
 162+ 584E E5           		PUSH HL
 163+ 584F CD 73 58     			CALL .ADD8
 164+ 5852 E1           		POP HL
 165+ 5853 ED 53 03 5D  		LD (BLIT_TMP1), DE
 166+ 5857 ED 5B 05 5D  		LD DE, (BLIT_TMP2)
 167+ 585B E5           		PUSH HL
 168+ 585C CD 73 58     			CALL .ADD8
 169+ 585F E1           		POP HL
 170+ 5860 ED 53 05 5D  		LD (BLIT_TMP2), DE ; DE+vertical shift
 171+ 5864              .DONE:
 172+ 5864 F1           	POP AF
 173+ 5865 3D           	DEC A
 174+ 5866 C8           	RET Z
 175+ 5867 F5           	PUSH AF
 176+ 5868 C3 30 58     	JP .L1
 177+ 586B              .ADDYSHIFT:
 178+ 586B EB           	EX DE, HL
 179+ 586C 16 00        	LD D, 0
 180+ 586E DD 5E 02     	LD E, (IX+2); y shift
 181+ 5871 18 0C        	JR .MOVDEBC
 182+ 5873              .ADD8:
 183+ 5873 21 08 00     	LD HL, 8
 184+ 5876 C3 7F 58     	JP .MOVDEBC
 185+ 5879              .DETONEXTROW:
 186+ 5879 DD 6E 06     	LD L, (IX+6)
 187+ 587C DD 66 07     	LD H, (IX+7) ; bkg add to value
 188+ 587F              .MOVDEBC:
 189+ 587F 19           	ADD HL, DE
 190+ 5880 54           	LD D, H
 191+ 5881 5D           	LD E, L
 192+ 5882 01 08 00     	LD BC, 8
 193+ 5885 09           	ADD HL, BC
 194+ 5886 44           	LD B, H
 195+ 5887 4D           	LD C, L
 196+ 5888 C9           	RET
 197+ 5889              ; *******************************************************************************************************
 198+ 5889
 199+ 5889              ; *******************************************************************************************************
 200+ 5889              ; function rotates mask and character data and applies it to background
 201+ 5889              ; input IX=pointer to structure describing input data
 202+ 5889              ; +0  DW horizontal shift count 0-7 (low byte used)
 203+ 5889              ; +2  DW vertical shift count 0-7 (low byte used)
 204+ 5889              ; +4  DW background data start;
 205+ 5889              ; +6  DW background add to value to next row of background data
 206+ 5889              ; +8  DW mask data start;
 207+ 5889              ; +10  DW character data start;
 208+ 5889              ; +12 DW character&mask add to value to next row of data
 209+ 5889              ; +14 DW columns (low byte used)
 210+ 5889              ; +16 DW rows (low byte used)
 211+ 5889              SHIFT_MERGE_CHARACTER:
 212+ 5889 DD 7E 00     	LD A, (IX) ; shift
 213+ 588C FE 05        	CP 5
 214+ 588E 38 25        	JR C, .RIGHT
 215+ 5890              	; shifts 5-7, use rotate towards left 1-3
 216+ 5890 21 E5 57     	LD HL, SHIFT58
 217+ 5893 22 36 58     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 218+ 5896 22 48 58     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 219+ 5899 D6 05        	SUB 5
 220+ 589B 28 0D        	JR Z, .L1
 221+ 589D 87           	ADD A, A
 222+ 589E 87           	ADD A, A
 223+ 589F 67           	LD H, A
 224+ 58A0 2E 18        	LD L, #18 ; JR opcode
 225+ 58A2 22 EC 57     	LD (SHIFT58.M1), HL
 226+ 58A5 22 FD 57     	LD (SHIFT58.M2), HL
 227+ 58A8 18 32        	JR .DO
 228+ 58AA              .L1:
 229+ 58AA 21 00 00     	LD HL, 0 ; 2xNOP opcode
 230+ 58AD 22 EC 57     	LD (SHIFT58.M1), HL
 231+ 58B0 22 FD 57     	LD (SHIFT58.M2), HL
 232+ 58B3 18 27        	JR .DO
 233+ 58B5              .RIGHT:
 234+ 58B5              	; shifts 0-4, rotate towards right
 235+ 58B5 21 A0 57     	LD HL, SHIFT04
 236+ 58B8 22 36 58     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 237+ 58BB 22 48 58     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 238+ 58BE FE 04        	CP 4
 239+ 58C0 28 11        	JR Z, .R1
 240+ 58C2 D6 04        	SUB 4
 241+ 58C4 ED 44        	NEG
 242+ 58C6 87           	ADD A, A
 243+ 58C7 87           	ADD A, A
 244+ 58C8 67           	LD H, A
 245+ 58C9 2E 18        	LD L, #18 ; JR opcode
 246+ 58CB 22 A7 57     	LD (SHIFT04.M1), HL
 247+ 58CE 22 BC 57     	LD (SHIFT04.M2), HL
 248+ 58D1 18 09        	JR .DO
 249+ 58D3              .R1:
 250+ 58D3 21 00 00     	LD HL, 0 ; 2xNOP opcode
 251+ 58D6 22 A7 57     	LD (SHIFT04.M1), HL
 252+ 58D9 22 BC 57     	LD (SHIFT04.M2), HL
 253+ 58DC              .DO:
 254+ 58DC DD 46 10     	LD B, (IX+16) ; rows
 255+ 58DF DD 6E 08     	LD L, (IX+8)
 256+ 58E2 DD 66 09     	LD H, (IX+9) ; mask data
 257+ 58E5 DD 5E 04     	LD E, (IX+4)
 258+ 58E8 DD 56 05     	LD D, (IX+5) ; background data
 259+ 58EB D9           	EXX
 260+ 58EC DD 6E 0A     	LD L, (IX+10)
 261+ 58EF DD 66 0B     	LD H, (IX+11) ; character data
 262+ 58F2 D9           	EXX
 263+ 58F3              .LOOP:
 264+ 58F3 C5           	PUSH BC
 265+ 58F4 E5           		PUSH HL
 266+ 58F5 D5           			PUSH DE
 267+ 58F6 D9           				EXX
 268+ 58F7 E5           				PUSH HL
 269+ 58F8 D9           					EXX
 270+ 58F9 DD 7E 0E     					LD A, (IX+14) ; columns
 271+ 58FC              .CALL:
 272+ 58FC CD 22 58     					CALL SHIFT_ROW
 273+ 58FF E1           				POP HL
 274+ 5900 DD 5E 0C     				LD E, (IX+12)
 275+ 5903 DD 56 0D     				LD D, (IX+13) ; char data to next row
 276+ 5906 19           				ADD HL, DE
 277+ 5907 D9           				EXX
 278+ 5908 E1           			POP HL
 279+ 5909 DD 5E 06     			LD E, (IX+6)
 280+ 590C DD 56 07     			LD D, (IX+7) ; background to next row
 281+ 590F 19           			ADD HL, DE
 282+ 5910 EB           			EX DE, HL
 283+ 5911 E1           		POP HL
 284+ 5912 DD 4E 0C     		LD C, (IX+12)
 285+ 5915 DD 46 0D     		LD B, (IX+13) ; char data to next row
 286+ 5918 09           		ADD HL, BC
 287+ 5919 C1           	POP BC
 288+ 591A 10 D7        	DJNZ .LOOP
 289+ 591C C9           	RET
 290+ 591D              ; *******************************************************************************************************
 291+ 591D
 292+ 591D              ; *******************************************************************************************************
 293+ 591D              ; helper function DE \ 8
 294+ 591D              DEdiv8:
 295+ 591D 7B           	LD A,E
 296+ 591E CB 2A        	SRA D
 297+ 5920 CB 1F            RR  A
 298+ 5922 CB 2A            SRA D
 299+ 5924 CB 1F            RR  A
 300+ 5926 CB 2A            SRA D
 301+ 5928 CB 1F            RR  A
 302+ 592A C9           	RET
 303+ 592B              ; *******************************************************************************************************
 304+ 592B
 305+ 592B               IF (DEFUSR_EXTENSION == 1)
 306+ 592B              ; *******************************************************************************************************
 307+ 592B              ; function to handle BLIT basic extension through DEFUSR call in RAW format
 308+ 592B              ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 309+ 592B              ; +2  DW horizontal shift count 0-7 (low byte used)
 310+ 592B              ; +4  DW vertical shift count 0-7 (low byte used)
 311+ 592B              ; +6  DW background data start;
 312+ 592B              ; +8  DW background add to value to next row of background data
 313+ 592B              ; +10  DW mask data start;
 314+ 592B              ; +12  DW character data start;
 315+ 592B              ; +14 DW character&mask add to value to next row of data
 316+ 592B              ; +16 DW columns (low byte used)
 317+ 592B              ; +18 DW rows (low byte used)
 318+ 592B              ; will put ram in page 0 also, page 1 is already there
 319+ 592B              ;BLIT_DEFUSR:
 320+ 592B              ;	DI
 321+ 592B              ;	LD IY, .RET
 322+ 592B              ;	JP ENABLE_PAGE0
 323+ 592B              ;.RET:
 324+ 592B              ;	EI
 325+ 592B              ;	INC IX
 326+ 592B              ;	INC IX
 327+ 592B              ;	CALL SHIFT_MERGE_CHARACTER
 328+ 592B              ;
 329+ 592B              ;   POP DE
 330+ 592B              ;    POP BC
 331+ 592B              ;    JP RESTORE_PAGE_INFO
 332+ 592B              ; *******************************************************************************************************
 333+ 592B
 334+ 592B              ; *******************************************************************************************************
 335+ 592B              ; function to handle CALL BLIT basic extension in DEFUSR form
 336+ 592B              ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 337+ 592B              ; +02 x
 338+ 592B              ; +04 y
 339+ 592B              ; +06 char_data_pointer
 340+ 592B              ; +08 mask_data_pointer
 341+ 592B              ; +10 width
 342+ 592B              ; +12 height
 343+ 592B              ; +14 background_pointer
 344+ 592B              ; +16 background_width
 345+ 592B              ; BLIT ( INT x,
 346+ 592B              ;		 INT y,
 347+ 592B              ;		 INT char_data_pointer,
 348+ 592B              ;		 INT mask_data_pointer,
 349+ 592B              ;		 INT width (in characters),
 350+ 592B              ;		 INT height (in characters),
 351+ 592B              ;		 INT background_pointer (top left),
 352+ 592B              ;		 INT background_width (in characters),
 353+ 592B              BLIT_DEFUSR:
 354+ 592B DD 5E 02     	LD E,(IX+2)
 355+ 592E DD 56 03     	LD D,(IX+3)
 356+ 5931 7B           	LD A,E
 357+ 5932 E6 07        	AND 7
 358+ 5934 32 07 5D     	LD (BLIT_STRUCT+0),A
 359+ 5937 CD 1D 59     	CALL DEdiv8
 360+ 593A 32 03 5D     	LD (BLIT_TMP+0),A
 361+ 593D DD 5E 04     	LD E,(IX+4)
 362+ 5940 DD 56 05     	LD D,(IX+5)
 363+ 5943 7B           	LD A,E
 364+ 5944 E6 07        	AND 7
 365+ 5946 32 09 5D     	LD (BLIT_STRUCT+2),A
 366+ 5949 CD 1D 59     	CALL DEdiv8
 367+ 594C 32 04 5D     	LD (BLIT_TMP+1),A
 368+ 594F DD 6E 06     	LD L,(IX+6)
 369+ 5952 DD 66 07     	LD H,(IX+7)
 370+ 5955 22 11 5D     	LD (BLIT_STRUCT+10),HL
 371+ 5958 DD 6E 08     	LD L,(IX+8)
 372+ 595B DD 66 09     	LD H,(IX+9)
 373+ 595E 22 0F 5D     	LD (BLIT_STRUCT+8),HL
 374+ 5961 DD 7E 0A     	LD A,(IX+10)
 375+ 5964 32 15 5D     	LD (BLIT_STRUCT+14),A
 376+ 5967 DD 7E 0C     	LD A,(IX+12)
 377+ 596A 32 17 5D     	LD (BLIT_STRUCT+16),A
 378+ 596D DD 6E 0E     	LD L,(IX+14)
 379+ 5970 DD 66 0F     	LD H,(IX+15)
 380+ 5973 22 0B 5D     	LD (BLIT_STRUCT+4),HL
 381+ 5976              	;LD A,(IX+16)
 382+ 5976              	;LD (BLIT_TMP+2),A
 383+ 5976
 384+ 5976              	; calculate char&mask add to value
 385+ 5976 26 00        	LD H,0
 386+ 5978 3A 15 5D     	LD A,(BLIT_STRUCT+14)
 387+ 597B 6F           	LD L,A
 388+ 597C CD 6D 5D     	CALL HLx8
 389+ 597F 22 13 5D     	LD (BLIT_STRUCT+12),HL
 390+ 5982              	; calculate background add to value
 391+ 5982 26 00        	LD H,0
 392+ 5984 DD 6E 10     	LD L,(IX+16)
 393+ 5987 CD 6D 5D     	CALL HLx8
 394+ 598A 22 0D 5D     	LD (BLIT_STRUCT+6),HL
 395+ 598D              	; calculate pointer to background location
 396+ 598D 21 00 00     	LD HL,0
 397+ 5990 3A 04 5D     	LD A,(BLIT_TMP+1)
 398+ 5993 B7           	OR A
 399+ 5994 28 08        	JR Z, .L1
 400+ 5996 47           	LD B,A
 401+ 5997 ED 5B 0D 5D  	LD DE,(BLIT_STRUCT+6)
 402+ 599B              .L0:
 403+ 599B 19           	ADD HL, DE
 404+ 599C 10 FD        	DJNZ .L0
 405+ 599E              .L1:
 406+ 599E EB           	EX DE,HL
 407+ 599F 26 00        	LD H,0
 408+ 59A1 3A 03 5D     	LD A,(BLIT_TMP+0)
 409+ 59A4 6F           	LD L,A
 410+ 59A5 CD 6D 5D     	CALL HLx8
 411+ 59A8 19           	ADD HL,DE
 412+ 59A9 ED 5B 0B 5D  	LD DE,(BLIT_STRUCT+4)
 413+ 59AD 19           	ADD HL,DE
 414+ 59AE 22 0B 5D     	LD (BLIT_STRUCT+4),HL
 415+ 59B1
 416+ 59B1 FD 21 B8 59  	LD IY, .RET
 417+ 59B5 C3 31 5E     	JP ENABLE_PAGE0
 418+ 59B8              .RET:
 419+ 59B8 FB           	EI
 420+ 59B9 DD 21 07 5D  	LD IX, BLIT_STRUCT
 421+ 59BD CD 89 58     	CALL SHIFT_MERGE_CHARACTER
 422+ 59C0
 423+ 59C0 D1               POP DE
 424+ 59C1 C1               POP BC
 425+ 59C2 C3 A8 5D         JP RESTORE_PAGE_INFO
 426+ 59C5              ; *******************************************************************************************************
 427+ 59C5               ENDIF
 428+ 59C5
 429+ 59C5               IF (BASIC_EXTENSION == 1)
 430+ 59C5 ~            ; *******************************************************************************************************
 431+ 59C5 ~            ; function to handle CALL BLIT basic extension
 432+ 59C5 ~            ; rotates 1-bit character drawing horizontally with mask and character data and
 433+ 59C5 ~            ; fuses with background data and applies vertical shift too
 434+ 59C5 ~            ; in form without pointers
 435+ 59C5 ~            ; BLIT ( INT x,
 436+ 59C5 ~            ;		 INT y,
 437+ 59C5 ~            ;		 INT char_data_pointer,
 438+ 59C5 ~            ;		 INT mask_data_pointer,
 439+ 59C5 ~            ;		 INT width (in characters),
 440+ 59C5 ~            ;		 INT height (in characters),
 441+ 59C5 ~            ;		 INT background_pointer (top left),
 442+ 59C5 ~            ;		 INT background_width (in characters),
 443+ 59C5 ~            ; will put ram in page 0 also, page 1 is already there
 444+ 59C5 ~            BLIT:
 445+ 59C5 ~            	; opening (
 446+ 59C5 ~            	CALL CHKCHAR
 447+ 59C5 ~            	DB '('
 448+ 59C5 ~            	; get x coordinate
 449+ 59C5 ~            	LD IX, FRMQNT
 450+ 59C5 ~            	CALL CALBAS
 451+ 59C5 ~            	LD A, E
 452+ 59C5 ~            	AND 7
 453+ 59C5 ~            	LD (BLIT_STRUCT+0), A
 454+ 59C5 ~            	CALL DEdiv8
 455+ 59C5 ~            	LD (BLIT_TMP+0),A
 456+ 59C5 ~            	; comma
 457+ 59C5 ~            	CALL CHKCHAR
 458+ 59C5 ~            	DB ','
 459+ 59C5 ~            	; get y coordinate
 460+ 59C5 ~            	LD IX, FRMQNT
 461+ 59C5 ~            	CALL CALBAS
 462+ 59C5 ~            	LD A, E
 463+ 59C5 ~            	AND 7
 464+ 59C5 ~            	LD (BLIT_STRUCT+2), A
 465+ 59C5 ~            	CALL DEdiv8
 466+ 59C5 ~            	LD (BLIT_TMP+1),A
 467+ 59C5 ~            	; comma
 468+ 59C5 ~            	CALL CHKCHAR
 469+ 59C5 ~            	DB ','
 470+ 59C5 ~            	; get char data pointer
 471+ 59C5 ~            	LD IX, FRMQNT
 472+ 59C5 ~            	CALL CALBAS
 473+ 59C5 ~            	LD (BLIT_STRUCT+10), DE
 474+ 59C5 ~            	; comma
 475+ 59C5 ~            	CALL CHKCHAR
 476+ 59C5 ~            	DB ','
 477+ 59C5 ~            	; get mask data pointer
 478+ 59C5 ~            	LD IX, FRMQNT
 479+ 59C5 ~            	CALL CALBAS
 480+ 59C5 ~            	LD (BLIT_STRUCT+8), DE
 481+ 59C5 ~            	; comma
 482+ 59C5 ~            	CALL CHKCHAR
 483+ 59C5 ~            	DB ','
 484+ 59C5 ~            	; get width
 485+ 59C5 ~            	LD IX, FRMQNT
 486+ 59C5 ~            	CALL CALBAS
 487+ 59C5 ~            	LD A, E
 488+ 59C5 ~            	LD (BLIT_STRUCT+14), A
 489+ 59C5 ~            	; comma
 490+ 59C5 ~            	CALL CHKCHAR
 491+ 59C5 ~            	DB ','
 492+ 59C5 ~            	; get height
 493+ 59C5 ~            	LD IX, FRMQNT
 494+ 59C5 ~            	CALL CALBAS
 495+ 59C5 ~            	LD A, E
 496+ 59C5 ~            	LD (BLIT_STRUCT+16), A
 497+ 59C5 ~            	; comma
 498+ 59C5 ~            	CALL CHKCHAR
 499+ 59C5 ~            	DB ','
 500+ 59C5 ~            	; get background pointer
 501+ 59C5 ~            	LD IX, FRMQNT
 502+ 59C5 ~            	CALL CALBAS
 503+ 59C5 ~            	LD (BLIT_STRUCT+4), DE
 504+ 59C5 ~            	; comma
 505+ 59C5 ~            	CALL CHKCHAR
 506+ 59C5 ~            	DB ','
 507+ 59C5 ~            	; get background width
 508+ 59C5 ~            	LD IX, FRMQNT
 509+ 59C5 ~            	CALL CALBAS
 510+ 59C5 ~            	LD A, E
 511+ 59C5 ~            	LD (BLIT_TMP+2), A
 512+ 59C5 ~            	; ending )
 513+ 59C5 ~            	CALL CHKCHAR
 514+ 59C5 ~            	DB ')'
 515+ 59C5 ~
 516+ 59C5 ~            	PUSH HL ; save position in BASIC buffer
 517+ 59C5 ~
 518+ 59C5 ~            	; calculate char&mask add to value
 519+ 59C5 ~            	LD H, 0
 520+ 59C5 ~            	LD A, (BLIT_STRUCT+14)
 521+ 59C5 ~            	LD L, A
 522+ 59C5 ~            	CALL HLx8
 523+ 59C5 ~            	LD (BLIT_STRUCT+12), HL
 524+ 59C5 ~            	; calculate background add to value
 525+ 59C5 ~            	LD H, 0
 526+ 59C5 ~            	LD A, (BLIT_TMP+2)
 527+ 59C5 ~            	LD L, A
 528+ 59C5 ~            	CALL HLx8
 529+ 59C5 ~            	LD (BLIT_STRUCT+6), HL
 530+ 59C5 ~            	; calculate pointer to background location
 531+ 59C5 ~            	LD HL, 0
 532+ 59C5 ~            	LD A,(BLIT_TMP+1)
 533+ 59C5 ~            	OR A
 534+ 59C5 ~            	JR Z, .L1
 535+ 59C5 ~            	LD B,A
 536+ 59C5 ~            	LD DE,(BLIT_STRUCT+6)
 537+ 59C5 ~            .L0:
 538+ 59C5 ~            	ADD HL, DE
 539+ 59C5 ~            	DJNZ .L0
 540+ 59C5 ~            .L1:
 541+ 59C5 ~            	EX DE,HL
 542+ 59C5 ~            	LD H,0
 543+ 59C5 ~            	LD A,(BLIT_TMP+0)
 544+ 59C5 ~            	LD L,A
 545+ 59C5 ~            	CALL HLx8
 546+ 59C5 ~            	ADD HL,DE
 547+ 59C5 ~            	LD DE,(BLIT_STRUCT+4)
 548+ 59C5 ~            	ADD HL,DE
 549+ 59C5 ~            	LD (BLIT_STRUCT+4),HL
 550+ 59C5 ~
 551+ 59C5 ~            	LD IY, .RET
 552+ 59C5 ~            	JP ENABLE_PAGE0
 553+ 59C5 ~            .RET:
 554+ 59C5 ~            	EI
 555+ 59C5 ~            	LD IX, BLIT_STRUCT
 556+ 59C5 ~            	CALL SHIFT_MERGE_CHARACTER
 557+ 59C5 ~
 558+ 59C5 ~                POP DE
 559+ 59C5 ~                POP BC
 560+ 59C5 ~                CALL RESTORE_PAGE_INFO
 561+ 59C5 ~
 562+ 59C5 ~            	POP HL
 563+ 59C5 ~            	RET
 564+ 59C5 ~            ; *******************************************************************************************************
 565+ 59C5               ENDIF
# file closed: asm\BLIT.asm
 157  59C5               ENDIF
 158  59C5
 159  59C5               IF (TILE_CMDS == 1)
 160  59C5               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
   1+ 59C5              ; *******************************************************************************************************
   2+ 59C5              ; generic function to implement tiling
   3+ 59C5              ; should be modified to call appropriate function for memory or vram
   4+ 59C5              ; input IX=pointer to following structure
   5+ 59C5              ; +00 tile_data_ptr
   6+ 59C5              ; +02 tile_rows
   7+ 59C5              ; +04 tile_columns
   8+ 59C5              ; +06 destination_address
   9+ 59C5              ; +08 dest_to_next_row_add_to_value
  10+ 59C5              ; +10 num_horizontal_tiles
  11+ 59C5              ; +12 num_vertical_tiles
  12+ 59C5              ; modifies AF, BC, DE, HL
  13+ 59C5              TILE:
  14+ 59C5 DD 6E 06     	LD L, (IX+6)
  15+ 59C8 DD 66 07     	LD H, (IX+7) ; destination address
  16+ 59CB 22 03 5D     	LD (TILETMP1), HL
  17+ 59CE DD 46 0C     	LD B, (IX+12) ; vertical tile number
  18+ 59D1              .L1:
  19+ 59D1 C5           	PUSH BC
  20+ 59D2 DD 6E 00     		LD L, (IX+0)
  21+ 59D5 DD 66 01     		LD H, (IX+1) ; tile address
  22+ 59D8 22 05 5D     		LD (TILETMP2), HL
  23+ 59DB DD 46 02     		LD B, (IX+2) ; tile rows
  24+ 59DE              .L2:
  25+ 59DE C5           		PUSH BC
  26+ 59DF CD 00 00     .CALL1:		CALL 0
  27+ 59E2 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
  28+ 59E5              .L3:
  29+ 59E5 C5           			PUSH BC
  30+ 59E6 2A 05 5D     				LD HL, (TILETMP2)
  31+ 59E9 DD 46 04     				LD B, (IX+4) ; tile columns
  32+ 59EC              .L4:
  33+ 59EC C5           				PUSH BC
  34+ 59ED              .CALL2:
  35+ 59ED CD 00 00     					CALL 0
  36+ 59F0 C1           				POP BC
  37+ 59F1 10 F9        				DJNZ .L4
  38+ 59F3 C1           			POP BC
  39+ 59F4 10 EF        			DJNZ .L3
  40+ 59F6 22 05 5D     			LD (TILETMP2), HL
  41+ 59F9 2A 03 5D     			LD HL, (TILETMP1)
  42+ 59FC DD 5E 08     			LD E, (IX+8)
  43+ 59FF DD 56 09     			LD D, (IX+9) ; add to value for dest next row
  44+ 5A02 19           			ADD HL, DE
  45+ 5A03 22 03 5D     			LD (TILETMP1), HL
  46+ 5A06 C1           		POP BC
  47+ 5A07 10 D5        		DJNZ .L2
  48+ 5A09 C1           	POP BC
  49+ 5A0A 10 C5        	DJNZ .L1
  50+ 5A0C C9           	RET
  51+ 5A0D              ; *******************************************************************************************************
  52+ 5A0D
  53+ 5A0D               IF (DEFUSR_EXTENSION == 1)
  54+ 5A0D              ; *******************************************************************************************************
  55+ 5A0D              ; same as TILERAM but for DEFUSR approach
  56+ 5A0D              ; input IX=pointer to input array, real data from +2
  57+ 5A0D              ; +02 = tile data pointer
  58+ 5A0D              ; +04 = tile columns
  59+ 5A0D              ; +06 = tile rows
  60+ 5A0D              ; +08 = destination pointer
  61+ 5A0D              ; +10 = destination columns
  62+ 5A0D              ; +12 = destination rows
  63+ 5A0D              ; +14 = destination begin column
  64+ 5A0D              ; +16 = destination begin row
  65+ 5A0D              ; +18 = number of tiles horizontally
  66+ 5A0D              ; +20 = number of tiles vertically
  67+ 5A0D              ; *******************************************************************************************************
  68+ 5A0D              TILERAM_DEFUSR:
  69+ 5A0D              	; tile data pointer
  70+ 5A0D DD 6E 02     	LD L,(IX+2)
  71+ 5A10 DD 66 03     	LD H,(IX+3)
  72+ 5A13 22 07 5D     	LD (BLIT_STRUCT+0),HL
  73+ 5A16              	; tile columns
  74+ 5A16 DD 6E 04     	LD L,(IX+4)
  75+ 5A19 DD 66 05     	LD H,(IX+5)
  76+ 5A1C 22 0B 5D     	LD (BLIT_STRUCT+4),HL
  77+ 5A1F              	; tile rows
  78+ 5A1F DD 6E 06     	LD L,(IX+6)
  79+ 5A22 DD 66 07     	LD H,(IX+7)
  80+ 5A25 22 09 5D     	LD (BLIT_STRUCT+2),HL
  81+ 5A28              	; destintion pointer
  82+ 5A28 DD 6E 08     	LD L,(IX+8)
  83+ 5A2B DD 66 09     	LD H,(IX+9)
  84+ 5A2E 22 0D 5D     	LD (BLIT_STRUCT+6),HL
  85+ 5A31              	; destination columns
  86+ 5A31 DD 7E 0A     	LD A,(IX+10)
  87+ 5A34 32 03 5D     	LD (BLIT_TMP+0),A
  88+ 5A37              	; destination rows
  89+ 5A37 DD 7E 0C     	LD A,(IX+12)
  90+ 5A3A 32 04 5D     	LD (BLIT_TMP+1),A
  91+ 5A3D              	; destination begin column
  92+ 5A3D DD 7E 0E     	LD A,(IX+14)
  93+ 5A40 32 05 5D     	LD (BLIT_TMP+2),A
  94+ 5A43              	; destination begin row
  95+ 5A43 DD 7E 10     	LD A,(IX+16)
  96+ 5A46 32 06 5D     	LD (BLIT_TMP+3),A
  97+ 5A49              	; number of tiles horizontally
  98+ 5A49 DD 6E 12     	LD L,(IX+18)
  99+ 5A4C DD 66 13     	LD H,(IX+19)
 100+ 5A4F 22 11 5D     	LD (BLIT_STRUCT+10),HL
 101+ 5A52              	; number of tiles vertically
 102+ 5A52 DD 6E 14     	LD L,(IX+20)
 103+ 5A55 DD 66 15     	LD H,(IX+21)
 104+ 5A58 22 13 5D     	LD (BLIT_STRUCT+12),HL
 105+ 5A5B               IF (BASIC_EXTENSION == 1) ; otherwise we just continue with code below
 106+ 5A5B ~            	JP TILERAM.COMMON
 107+ 5A5B               ENDIF
 108+ 5A5B               ENDIF
 109+ 5A5B
 110+ 5A5B              ; *******************************************************************************************************
 111+ 5A5B              ; function to handle CALL TILERAM basic extension
 112+ 5A5B              ; fills memory with tiles
 113+ 5A5B              ; TILERAM ( INT tile_data_pointer,
 114+ 5A5B              ;			INT tile_columns,
 115+ 5A5B              ;			INT tile_rows,
 116+ 5A5B              ;			INT destination_pointer,
 117+ 5A5B              ;			INT destination_columns,
 118+ 5A5B              ;			INT destination_rows,
 119+ 5A5B              ;			INT destination_begin_column,
 120+ 5A5B              ;			INT destination_begin_row,
 121+ 5A5B              ;			INT number_of_tiles_horizontally,
 122+ 5A5B              ;			INT	number_of_tiles_vertically )
 123+ 5A5B              ; will put ram in page 0 also, page 1 is already there
 124+ 5A5B              TILERAM:
 125+ 5A5B               IF (BASIC_EXTENSION == 1)
 126+ 5A5B ~            	; opening (
 127+ 5A5B ~            	CALL CHKCHAR
 128+ 5A5B ~            	DB '('
 129+ 5A5B ~            	; get tile data pointer coordinate
 130+ 5A5B ~            	LD IX, FRMQNT
 131+ 5A5B ~            	CALL CALBAS
 132+ 5A5B ~            	LD (BLIT_STRUCT+0), DE
 133+ 5A5B ~            	; comma
 134+ 5A5B ~            	CALL CHKCHAR
 135+ 5A5B ~            	DB ','
 136+ 5A5B ~            	; get tile columns
 137+ 5A5B ~            	LD IX, FRMQNT
 138+ 5A5B ~            	CALL CALBAS
 139+ 5A5B ~            	LD (BLIT_STRUCT+4), DE
 140+ 5A5B ~            	; comma
 141+ 5A5B ~            	CALL CHKCHAR
 142+ 5A5B ~            	DB ','
 143+ 5A5B ~            	; get tile columns
 144+ 5A5B ~            	LD IX, FRMQNT
 145+ 5A5B ~            	CALL CALBAS
 146+ 5A5B ~            	LD (BLIT_STRUCT+2), DE
 147+ 5A5B ~            	; comma
 148+ 5A5B ~            	CALL CHKCHAR
 149+ 5A5B ~            	DB ','
 150+ 5A5B ~            	; get destintion pointer
 151+ 5A5B ~            	LD IX, FRMQNT
 152+ 5A5B ~            	CALL CALBAS
 153+ 5A5B ~            	LD (BLIT_STRUCT+6), DE
 154+ 5A5B ~            	; comma
 155+ 5A5B ~            	CALL CHKCHAR
 156+ 5A5B ~            	DB ','
 157+ 5A5B ~            	; get destination columns
 158+ 5A5B ~            	LD IX, FRMQNT
 159+ 5A5B ~            	CALL CALBAS
 160+ 5A5B ~            	LD A, E
 161+ 5A5B ~            	LD (BLIT_TMP+0), A
 162+ 5A5B ~            	; comma
 163+ 5A5B ~            	CALL CHKCHAR
 164+ 5A5B ~            	DB ','
 165+ 5A5B ~            	; get destination rows
 166+ 5A5B ~            	LD IX, FRMQNT
 167+ 5A5B ~            	CALL CALBAS
 168+ 5A5B ~            	LD A, E
 169+ 5A5B ~            	LD (BLIT_TMP+1), A
 170+ 5A5B ~            	; comma
 171+ 5A5B ~            	CALL CHKCHAR
 172+ 5A5B ~            	DB ','
 173+ 5A5B ~            	; get destination begin column
 174+ 5A5B ~            	LD IX, FRMQNT
 175+ 5A5B ~            	CALL CALBAS
 176+ 5A5B ~            	LD A, E
 177+ 5A5B ~            	LD (BLIT_TMP+2), A
 178+ 5A5B ~            	; comma
 179+ 5A5B ~            	CALL CHKCHAR
 180+ 5A5B ~            	DB ','
 181+ 5A5B ~            	; get destination begin row
 182+ 5A5B ~            	LD IX, FRMQNT
 183+ 5A5B ~            	CALL CALBAS
 184+ 5A5B ~            	LD A, E
 185+ 5A5B ~            	LD (BLIT_TMP+3), A
 186+ 5A5B ~            	; comma
 187+ 5A5B ~            	CALL CHKCHAR
 188+ 5A5B ~            	DB ','
 189+ 5A5B ~            	; get number of tiles horizontally
 190+ 5A5B ~            	LD IX, FRMQNT
 191+ 5A5B ~            	CALL CALBAS
 192+ 5A5B ~            	LD (BLIT_STRUCT+10), DE
 193+ 5A5B ~            	; comma
 194+ 5A5B ~            	CALL CHKCHAR
 195+ 5A5B ~            	DB ','
 196+ 5A5B ~            	; get number of tiles vertically
 197+ 5A5B ~            	LD IX, FRMQNT
 198+ 5A5B ~            	CALL CALBAS
 199+ 5A5B ~            	LD (BLIT_STRUCT+12), DE
 200+ 5A5B ~            	; ending )
 201+ 5A5B ~            	CALL CHKCHAR
 202+ 5A5B ~            	DB ')'
 203+ 5A5B               ENDIF
 204+ 5A5B              .COMMON:
 205+ 5A5B E5           	PUSH HL ; save position in BASIC buffer
 206+ 5A5C
 207+ 5A5C              	; calculate destination add to value
 208+ 5A5C 26 00        	LD H, 0
 209+ 5A5E 3A 03 5D     	LD A, (BLIT_TMP+0)
 210+ 5A61 6F           	LD L, A
 211+ 5A62 CD 6D 5D     	CALL HLx8
 212+ 5A65 22 0F 5D     	LD (BLIT_STRUCT+8), HL
 213+ 5A68              	; calculate pointer to background location
 214+ 5A68 21 00 00     	LD HL, 0
 215+ 5A6B 3A 06 5D     	LD A,(BLIT_TMP+3)
 216+ 5A6E B7           	OR A
 217+ 5A6F 28 08        	JR Z, .L1
 218+ 5A71 47           	LD B,A
 219+ 5A72 ED 5B 0F 5D  	LD DE,(BLIT_STRUCT+8)
 220+ 5A76              .L0:
 221+ 5A76 19           	ADD HL, DE
 222+ 5A77 10 FD        	DJNZ .L0
 223+ 5A79              .L1:
 224+ 5A79 EB           	EX DE,HL
 225+ 5A7A 26 00        	LD H,0
 226+ 5A7C 3A 05 5D     	LD A,(BLIT_TMP+2)
 227+ 5A7F 6F           	LD L,A
 228+ 5A80 CD 6D 5D     	CALL HLx8
 229+ 5A83 19           	ADD HL,DE
 230+ 5A84 ED 5B 0D 5D  	LD DE,(BLIT_STRUCT+6)
 231+ 5A88 19           	ADD HL,DE
 232+ 5A89 22 0D 5D     	LD (BLIT_STRUCT+6),HL
 233+ 5A8C FD 21 93 5A  	LD IY, .RET
 234+ 5A90 C3 31 5E     	JP ENABLE_PAGE0
 235+ 5A93              .RET:
 236+ 5A93 FB           	EI
 237+ 5A94              	; set RAM functions to call
 238+ 5A94 21 AE 5A     	LD HL, .TILECOPY
 239+ 5A97 22 EE 59     	LD (TILE.CALL2+1), HL
 240+ 5A9A 21 BF 5A     	LD HL, .SETDESTROW
 241+ 5A9D 22 E0 59     	LD (TILE.CALL1+1), HL
 242+ 5AA0 DD 21 07 5D  	LD IX,BLIT_STRUCT
 243+ 5AA4 CD C5 59     	CALL TILE
 244+ 5AA7
 245+ 5AA7 D1               POP DE
 246+ 5AA8 C1               POP BC
 247+ 5AA9 CD A8 5D         CALL RESTORE_PAGE_INFO
 248+ 5AAC
 249+ 5AAC E1           	POP HL
 250+ 5AAD C9           	RET
 251+ 5AAE              .TILECOPY:
 252+ 5AAE ED A0       > LDI
 252+ 5AB0 ED A0       > LDI
 252+ 5AB2 ED A0       > LDI
 252+ 5AB4 ED A0       > LDI
 252+ 5AB6 ED A0       > LDI
 252+ 5AB8 ED A0       > LDI
 252+ 5ABA ED A0       > LDI
 252+ 5ABC ED A0       > LDI
 253+ 5ABE C9           	RET
 254+ 5ABF              .SETDESTROW:
 255+ 5ABF ED 5B 03 5D  	LD DE, (TILETMP1)
 256+ 5AC3 C9           	RET
 257+ 5AC4              ; *******************************************************************************************************
 258+ 5AC4
 259+ 5AC4               IF (DEFUSR_EXTENSION == 1)
 260+ 5AC4              ; *******************************************************************************************************
 261+ 5AC4              ; same as TILEVRM but for DEFUSR approach
 262+ 5AC4              ; input IX=pointer to input array, real data from +2
 263+ 5AC4              ; +02 = tile data pointer
 264+ 5AC4              ; +04 = tile columns
 265+ 5AC4              ; +06 = tile rows
 266+ 5AC4              ; +08 = destination begin column
 267+ 5AC4              ; +10 = destination begin row
 268+ 5AC4              ; +12 = number of tiles horizontally
 269+ 5AC4              ; +14 = number of tiles vertically
 270+ 5AC4              ; *******************************************************************************************************
 271+ 5AC4              TILEVRM_DEFUSR:
 272+ 5AC4              	; tile data pointer
 273+ 5AC4 DD 6E 02     	LD L,(IX+2)
 274+ 5AC7 DD 66 03     	LD H,(IX+3)
 275+ 5ACA 22 07 5D     	LD (BLIT_STRUCT+0),HL
 276+ 5ACD              	; tile columns
 277+ 5ACD DD 6E 04     	LD L,(IX+4)
 278+ 5AD0 DD 66 05     	LD H,(IX+5)
 279+ 5AD3 22 0B 5D     	LD (BLIT_STRUCT+4),HL
 280+ 5AD6              	; tile rows
 281+ 5AD6 DD 6E 06     	LD L,(IX+6)
 282+ 5AD9 DD 66 07     	LD H,(IX+7)
 283+ 5ADC 22 09 5D     	LD (BLIT_STRUCT+2),HL
 284+ 5ADF              	; destination begin column
 285+ 5ADF DD 7E 08     	LD A,(IX+8)
 286+ 5AE2 32 05 5D     	LD (BLIT_TMP+2),A
 287+ 5AE5              	; destination begin row
 288+ 5AE5 DD 7E 0A     	LD A,(IX+10)
 289+ 5AE8 32 06 5D     	LD (BLIT_TMP+3),A
 290+ 5AEB              	; number of tiles horizontally
 291+ 5AEB DD 6E 0C     	LD L,(IX+12)
 292+ 5AEE DD 66 0D     	LD H,(IX+13)
 293+ 5AF1 22 11 5D     	LD (BLIT_STRUCT+10),HL
 294+ 5AF4              	; number of tiles vertically
 295+ 5AF4 DD 6E 0E     	LD L,(IX+14)
 296+ 5AF7 DD 66 0F     	LD H,(IX+15)
 297+ 5AFA 22 13 5D     	LD (BLIT_STRUCT+12),HL
 298+ 5AFD               IF (BASIC_EXTENSION == 1) ; otherwise we just continue with code below
 299+ 5AFD ~            	JP TILEVRM.COMMON
 300+ 5AFD               ENDIF
 301+ 5AFD               ENDIF
 302+ 5AFD
 303+ 5AFD              ; *******************************************************************************************************
 304+ 5AFD              ; function to handle CALL TILEVRM basic extension
 305+ 5AFD              ; fills vram with tiles
 306+ 5AFD              ; TILEVRM ( INT tile_data_pointer,
 307+ 5AFD              ;			INT tile_columns,
 308+ 5AFD              ;			INT tile_rows,
 309+ 5AFD              ;			INT destination_begin_column,
 310+ 5AFD              ;			INT destination_begin_row,
 311+ 5AFD              ;			INT number_of_tiles_horizontally,
 312+ 5AFD              ;			INT	number_of_tiles_vertically )
 313+ 5AFD              ; will put ram in page 0 also, page 1 is already there
 314+ 5AFD              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
 315+ 5AFD              TILEVRM:
 316+ 5AFD               IF (BASIC_EXTENSION == 1)
 317+ 5AFD ~            	; opening (
 318+ 5AFD ~            	CALL CHKCHAR
 319+ 5AFD ~            	DB '('
 320+ 5AFD ~            	; get tile data pointer coordinate
 321+ 5AFD ~            	LD IX, FRMQNT
 322+ 5AFD ~            	CALL CALBAS
 323+ 5AFD ~            	LD (BLIT_STRUCT+0), DE
 324+ 5AFD ~            	; comma
 325+ 5AFD ~            	CALL CHKCHAR
 326+ 5AFD ~            	DB ','
 327+ 5AFD ~            	; get tile columns
 328+ 5AFD ~            	LD IX, FRMQNT
 329+ 5AFD ~            	CALL CALBAS
 330+ 5AFD ~            	LD (BLIT_STRUCT+4), DE
 331+ 5AFD ~            	; comma
 332+ 5AFD ~            	CALL CHKCHAR
 333+ 5AFD ~            	DB ','
 334+ 5AFD ~            	; get tile columns
 335+ 5AFD ~            	LD IX, FRMQNT
 336+ 5AFD ~            	CALL CALBAS
 337+ 5AFD ~            	LD (BLIT_STRUCT+2), DE
 338+ 5AFD ~            	; comma
 339+ 5AFD ~            	CALL CHKCHAR
 340+ 5AFD ~            	DB ','
 341+ 5AFD ~            	; get destination begin column
 342+ 5AFD ~            	LD IX, FRMQNT
 343+ 5AFD ~            	CALL CALBAS
 344+ 5AFD ~            	LD A, E
 345+ 5AFD ~            	LD (BLIT_TMP+2), A
 346+ 5AFD ~            	; comma
 347+ 5AFD ~            	CALL CHKCHAR
 348+ 5AFD ~            	DB ','
 349+ 5AFD ~            	; get destination begin row
 350+ 5AFD ~            	LD IX, FRMQNT
 351+ 5AFD ~            	CALL CALBAS
 352+ 5AFD ~            	LD A, E
 353+ 5AFD ~            	LD (BLIT_TMP+3), A
 354+ 5AFD ~            	; comma
 355+ 5AFD ~            	CALL CHKCHAR
 356+ 5AFD ~            	DB ','
 357+ 5AFD ~            	; get number of tiles horizontally
 358+ 5AFD ~            	LD IX, FRMQNT
 359+ 5AFD ~            	CALL CALBAS
 360+ 5AFD ~            	LD (BLIT_STRUCT+10), DE
 361+ 5AFD ~            	; comma
 362+ 5AFD ~            	CALL CHKCHAR
 363+ 5AFD ~            	DB ','
 364+ 5AFD ~            	; get number of tiles vertically
 365+ 5AFD ~            	LD IX, FRMQNT
 366+ 5AFD ~            	CALL CALBAS
 367+ 5AFD ~            	LD (BLIT_STRUCT+12), DE
 368+ 5AFD ~            	; ending )
 369+ 5AFD ~            	CALL CHKCHAR
 370+ 5AFD ~            	DB ')'
 371+ 5AFD               ENDIF
 372+ 5AFD
 373+ 5AFD              .COMMON:
 374+ 5AFD E5           	PUSH HL ; save position in BASIC buffer
 375+ 5AFE
 376+ 5AFE              	; calculate destination add to value
 377+ 5AFE 21 00 01     	LD HL, 256
 378+ 5B01 22 0F 5D     	LD (BLIT_STRUCT+8), HL
 379+ 5B04              	; calculate pointer to background location
 380+ 5B04 3A 06 5D     	LD A,(BLIT_TMP+3)
 381+ 5B07 67           	LD H,A
 382+ 5B08 2E 00        	LD L,0
 383+ 5B0A EB           	EX DE,HL
 384+ 5B0B 26 00        	LD H,0
 385+ 5B0D 3A 05 5D     	LD A,(BLIT_TMP+2)
 386+ 5B10 6F           	LD L,A
 387+ 5B11 CD 6D 5D     	CALL HLx8
 388+ 5B14 19           	ADD HL,DE
 389+ 5B15 ED 5B CB F3  	LD DE,(GRPCGP)
 390+ 5B19 19           	ADD HL,DE
 391+ 5B1A 22 0D 5D     	LD (BLIT_STRUCT+6),HL
 392+ 5B1D FD 21 24 5B  	LD IY, .RET
 393+ 5B21 C3 31 5E     	JP ENABLE_PAGE0
 394+ 5B24              .RET:
 395+ 5B24 FB           	EI
 396+ 5B25              	; set RAM functions to call
 397+ 5B25 21 3F 5B     	LD HL, .TILECOPY
 398+ 5B28 22 EE 59     	LD (TILE.CALL2+1), HL
 399+ 5B2B 21 45 5B     	LD HL, .SETDESTROW
 400+ 5B2E 22 E0 59     	LD (TILE.CALL1+1), HL
 401+ 5B31 DD 21 07 5D  	LD IX,BLIT_STRUCT
 402+ 5B35 CD C5 59     	CALL TILE
 403+ 5B38
 404+ 5B38 D1               POP DE
 405+ 5B39 C1               POP BC
 406+ 5B3A CD A8 5D         CALL RESTORE_PAGE_INFO
 407+ 5B3D
 408+ 5B3D E1           	POP HL
 409+ 5B3E C9           	RET
 410+ 5B3F              .TILECOPY:
 411+ 5B3F 01 98 08     	LD BC, #0898
 412+ 5B42 C3 65 5D     	JP BBYTECOPY_NO_C
 413+ 5B45              .SETDESTROW:
 414+ 5B45 2A 03 5D     	LD HL, (TILETMP1)
 415+ 5B48 F3           	DI
 416+ 5B49 CD 58 5D     	CALL SETWRT_LOCAL
 417+ 5B4C FB           	EI
 418+ 5B4D C9           	RET
 419+ 5B4E              ; *******************************************************************************************************
 420+ 5B4E
# file closed: asm\TILE.asm
 161  5B4E               ENDIF
 162  5B4E
 163  5B4E               IF (COLL_CMD == 1)
 164  5B4E               INCLUDE "COLLISION.asm"
# file opened: asm\COLLISION.asm
   1+ 5B4E              ; generic collision checking routines
   2+ 5B4E              ; in BASIC we use rectangle structure array DIM R%(7,n) of the format
   3+ 5B4E              ; R%(0,n) is active flag, <>0 active / 0 skipped in checks
   4+ 5B4E              ; R%(1,n) is either upper left x coordinate or sprite id (0-31) depending on R(7,n)
   5+ 5B4E              ; R%(2,n) is either upper left y coordinate or unused depending on R(7,n)
   6+ 5B4E              ; R%(3,n) x offset where rectangle begins
   7+ 5B4E              ; R%(4,n) y offset where rectangle begins
   8+ 5B4E              ; R%(5,n) is width
   9+ 5B4E              ; R%(6,n) is height
  10+ 5B4E              ; R%(7,0) is type, 0=generic where R%(1,0) contains x coordinate
  11+ 5B4E              ;                  <>0 sprite where R%(1,0) contains sprite id
  12+ 5B4E              ; for type sprite, upper left coordinates are taken from sprite attribute array
  13+ 5B4E
  14+ 5B4E              ; ************************************************************************************************
  15+ 5B4E              ; quick test if HL<=DE<=HL+BC
  16+ 5B4E              ; input BC=width, DE=x, HL=min
  17+ 5B4E              ; if not true flag C set
  18+ 5B4E              ; modifies AF
  19+ 5B4E              GENERIC_INNER_CHECK:
  20+ 5B4E E5               PUSH HL
  21+ 5B4F D5               PUSH DE
  22+ 5B50 EB               EX DE,HL
  23+ 5B51 A7               AND A
  24+ 5B52 ED 52            SBC HL, DE
  25+ 5B54 FA 62 5B         JP M, .GENERIC_INNER_CHECK_NOT
  26+ 5B57 A7               AND A
  27+ 5B58 ED 42            SBC HL, BC
  28+ 5B5A 28 03            JR Z, .L2
  29+ 5B5C F2 62 5B         JP P, .GENERIC_INNER_CHECK_NOT
  30+ 5B5F              .L2:
  31+ 5B5F A7               AND A
  32+ 5B60 18 01            JR .EXIT
  33+ 5B62              .GENERIC_INNER_CHECK_NOT:
  34+ 5B62 37               SCF
  35+ 5B63              .EXIT:
  36+ 5B63 D1               POP DE
  37+ 5B64 E1               POP HL
  38+ 5B65 C9               RET
  39+ 5B66              ; ************************************************************************************************
  40+ 5B66
  41+ 5B66              ; ************************************************************************************************
  42+ 5B66              ; function to check if rectangles are overlapping
  43+ 5B66              ; input IX=IY=pointer to struct
  44+ 5B66              ;  +00 active flag
  45+ 5B66              ;  +02 x coordinate
  46+ 5B66              ;  +04 y coordinate
  47+ 5B66              ;  +06 x offset where rectangle begins
  48+ 5B66              ;  +08 y offset where rectangle begins
  49+ 5B66              ;  +10 width
  50+ 5B66              ;  +12 height
  51+ 5B66              ; where IY is used to read +2 and +4, and IX to read +6, +8, +10 and +12
  52+ 5B66              ; this is a hack to allow location being taken from sprite attributes table
  53+ 5B66              ; input BLIT_STRUCT data
  54+ 5B66              ;  +00 x coordinate
  55+ 5B66              ;  +02 y coordinate
  56+ 5B66              ;  +04 width
  57+ 5B66              ;  +06 height
  58+ 5B66              ; returns CF=1 if not overlapping, CF=0 if overlapping
  59+ 5B66              RECTANGLE_OVERLAP_CHECK:
  60+ 5B66                  ; first check which rectangle is higher
  61+ 5B66 DD 6E 0C         LD L,(IX+12)
  62+ 5B69 DD 66 0D         LD H,(IX+13)
  63+ 5B6C ED 5B 0D 5D      LD DE,(BLIT_STRUCT+6)
  64+ 5B70 A7               AND A
  65+ 5B71 ED 52            SBC HL,DE
  66+ 5B73 FD 6E 04         LD L,(IY+4)
  67+ 5B76 FD 66 05         LD H,(IY+5)
  68+ 5B79 DD 5E 08         LD E,(IX+8)
  69+ 5B7C DD 56 09         LD D,(IX+9)
  70+ 5B7F FA 9F 5B         JP M,.L1
  71+ 5B82                  ; equally high or IX defined one higher
  72+ 5B82                  ; check upper boundary
  73+ 5B82 19               ADD HL,DE
  74+ 5B83 ED 5B 09 5D      LD DE,(BLIT_STRUCT+2)
  75+ 5B87 DD 4E 0C         LD C,(IX+12)
  76+ 5B8A DD 46 0D         LD B,(IX+13)
  77+ 5B8D CD 4E 5B         CALL GENERIC_INNER_CHECK
  78+ 5B90 30 29            JR NC,.INSIDE
  79+ 5B92                  ; check lower boundary
  80+ 5B92 E5               PUSH HL
  81+ 5B93 2A 0D 5D         LD HL,(BLIT_STRUCT+6)
  82+ 5B96 19               ADD HL,DE
  83+ 5B97 EB               EX DE,HL
  84+ 5B98 E1               POP HL
  85+ 5B99 CD 4E 5B         CALL GENERIC_INNER_CHECK
  86+ 5B9C 30 1D            JR NC,.INSIDE
  87+ 5B9E C9               RET ; not overlapping
  88+ 5B9F              .L1:
  89+ 5B9F                  ; rectangle defined in BLIT_STRUCT is higher
  90+ 5B9F 19               ADD HL,DE
  91+ 5BA0 EB               EX DE,HL
  92+ 5BA1 2A 09 5D         LD HL,(BLIT_STRUCT+2)
  93+ 5BA4 ED 4B 0D 5D      LD BC,(BLIT_STRUCT+6)
  94+ 5BA8 CD 4E 5B         CALL GENERIC_INNER_CHECK
  95+ 5BAB 30 0E            JR NC,.INSIDE
  96+ 5BAD E5               PUSH HL
  97+ 5BAE DD 6E 0C         LD L,(IX+12)
  98+ 5BB1 DD 66 0D         LD H,(IX+13)
  99+ 5BB4 19               ADD HL,DE
 100+ 5BB5 EB               EX DE,HL
 101+ 5BB6 E1               POP HL
 102+ 5BB7 CD 4E 5B         CALL GENERIC_INNER_CHECK
 103+ 5BBA D8               RET C
 104+ 5BBB              .INSIDE:
 105+ 5BBB                  ; check x coordinate
 106+ 5BBB                  ; first check which rectangle is wider
 107+ 5BBB DD 6E 0A         LD L,(IX+10)
 108+ 5BBE DD 66 0B         LD H,(IX+11)
 109+ 5BC1 ED 5B 0B 5D      LD DE,(BLIT_STRUCT+4)
 110+ 5BC5 A7               AND A
 111+ 5BC6 ED 52            SBC HL,DE
 112+ 5BC8 FD 6E 02         LD L,(IY+2)
 113+ 5BCB FD 66 03         LD H,(IY+3)
 114+ 5BCE DD 5E 06         LD E,(IX+6)
 115+ 5BD1 DD 56 07         LD D,(IX+7)
 116+ 5BD4 FA F0 5B         JP M,.L2
 117+ 5BD7                  ; equally wide or IX defined one wider
 118+ 5BD7                  ; check left boundary
 119+ 5BD7 19               ADD HL,DE
 120+ 5BD8 ED 5B 07 5D      LD DE,(BLIT_STRUCT+0)
 121+ 5BDC DD 4E 0A         LD C,(IX+10)
 122+ 5BDF DD 46 0B         LD B,(IX+11)
 123+ 5BE2 CD 4E 5B         CALL GENERIC_INNER_CHECK
 124+ 5BE5 D0               RET NC ; overlap
 125+ 5BE6                  ; check right boundary
 126+ 5BE6 E5               PUSH HL
 127+ 5BE7 2A 0B 5D         LD HL,(BLIT_STRUCT+4)
 128+ 5BEA 19               ADD HL,DE
 129+ 5BEB EB               EX DE,HL
 130+ 5BEC E1               POP HL
 131+ 5BED C3 4E 5B         JP GENERIC_INNER_CHECK ; CF and result set by fn call
 132+ 5BF0              .L2:
 133+ 5BF0                  ; rectangle defined in BLIT_STRUCT is higher
 134+ 5BF0 19               ADD HL,DE
 135+ 5BF1 EB               EX DE,HL
 136+ 5BF2 2A 07 5D         LD HL,(BLIT_STRUCT+0)
 137+ 5BF5 ED 4B 0B 5D      LD BC,(BLIT_STRUCT+4)
 138+ 5BF9 CD 4E 5B         CALL GENERIC_INNER_CHECK
 139+ 5BFC D0               RET NC ; overlap
 140+ 5BFD E5               PUSH HL
 141+ 5BFE DD 6E 0A         LD L,(IX+10)
 142+ 5C01 DD 66 0B         LD H,(IX+11)
 143+ 5C04 19               ADD HL,DE
 144+ 5C05 EB               EX DE,HL
 145+ 5C06 E1               POP HL
 146+ 5C07 C3 4E 5B         JP GENERIC_INNER_CHECK
 147+ 5C0A              ; ************************************************************************************************
 148+ 5C0A
 149+ 5C0A              ; ************************************************************************************************
 150+ 5C0A              ; function tries to find rectangle overlap and returns an index if found
 151+ 5C0A              ; input BLIT_STRUCT data
 152+ 5C0A              ;  +00 x coordinate
 153+ 5C0A              ;  +02 y coordinate
 154+ 5C0A              ;  +04 width
 155+ 5C0A              ;  +06 height
 156+ 5C0A              ;  +08 number of items in a list, described under RECTANGLE_OVERLAP_CHECK
 157+ 5C0A              ;  +09 pointer to first element of R%(7,n)
 158+ 5C0A              ;  +11 pointer to INT result variable
 159+ 5C0A              ; returns CF=1 if not overlapping
 160+ 5C0A              ; returns A=list index and CF=0 if overlapping
 161+ 5C0A              FIND_OVERLAP:
 162+ 5C0A 3A 0F 5D         LD A,(BLIT_STRUCT+8)
 163+ 5C0D 47               LD B,A
 164+ 5C0E DD 2A 10 5D      LD IX,(BLIT_STRUCT+9)
 165+ 5C12              .L1:
 166+ 5C12 C5               PUSH BC
 167+ 5C13                  ; check active flag
 168+ 5C13 DD 7E 00         LD A,(IX)
 169+ 5C16 DD B6 01         OR (IX+1)
 170+ 5C19 28 18            JR Z,.NEXT
 171+ 5C1B                  ; check type
 172+ 5C1B DD 7E 0E         LD A,(IX+14)
 173+ 5C1E DD B6 0F         OR (IX+15)
 174+ 5C21 20 1A            JR NZ,.L2
 175+ 5C23 DD E5            PUSH IX
 176+ 5C25 FD E1            POP IY
 177+ 5C27              .L3:
 178+ 5C27 CD 66 5B         CALL RECTANGLE_OVERLAP_CHECK
 179+ 5C2A 38 07            JR C,.NEXT
 180+ 5C2C                  ; found
 181+ 5C2C C1               POP BC
 182+ 5C2D 3A 0F 5D         LD A,(BLIT_STRUCT+8)
 183+ 5C30 90               SUB B
 184+ 5C31 A7               AND A
 185+ 5C32 C9               RET
 186+ 5C33              .NEXT:
 187+ 5C33 11 10 00         LD DE,16
 188+ 5C36 DD 19            ADD IX,DE
 189+ 5C38 C1               POP BC
 190+ 5C39 10 D7            DJNZ .L1
 191+ 5C3B 37               SCF
 192+ 5C3C C9               RET
 193+ 5C3D              .L2:
 194+ 5C3D                  ; sprite, need to build a temporary data struct since x and y values are inversed
 195+ 5C3D                  ; at BLIT_STRUCT+13
 196+ 5C3D DD 7E 02         LD A,(IX+2) ; sprite ID
 197+ 5C40 CD 89 4D         CALL GETnthSPRATTR
 198+ 5C43 FD 21 12 5D      LD IY,BLIT_STRUCT+11
 199+ 5C47 7E               LD A,(HL)
 200+ 5C48 FD 77 04         LD (IY+4),A
 201+ 5C4B 23               INC HL
 202+ 5C4C 7E               LD A,(HL)
 203+ 5C4D FD 77 05         LD (IY+5),A
 204+ 5C50 23               INC HL
 205+ 5C51 7E               LD A,(HL)
 206+ 5C52 FD 77 02         LD (IY+2),A
 207+ 5C55 23               INC HL
 208+ 5C56 7E               LD A,(HL)
 209+ 5C57 FD 77 03         LD (IY+3),A
 210+ 5C5A 18 CB            JR .L3
 211+ 5C5C              ; ************************************************************************************************
 212+ 5C5C
 213+ 5C5C               IF (BASIC_EXTENSION == 1)
 214+ 5C5C ~            ; ************************************************************************************************
 215+ 5C5C ~            ; function to handle CALL COLL basic extension
 216+ 5C5C ~            ; checks for collision between player and other rectangles
 217+ 5C5C ~            ; COLL ( INT result variable,
 218+ 5C5C ~            ;	     INT player x value,
 219+ 5C5C ~            ;	     INT player y value,
 220+ 5C5C ~            ;	     INT player width,
 221+ 5C5C ~            ;	     INT player height,
 222+ 5C5C ~            ;	     INT number of items in a list,
 223+ 5C5C ~            ;		 INT[6][n] rectangle struct )
 224+ 5C5C ~            ; will fill result variable with index or -1 if no collision
 225+ 5C5C ~            ; rectangle struct described under RECTANGLE_OVERLAP_CHECK
 226+ 5C5C ~            COLL:
 227+ 5C5C ~            	; opening (
 228+ 5C5C ~            	CALL CHKCHAR
 229+ 5C5C ~            	DB '('
 230+ 5C5C ~            	; get address of result variable
 231+ 5C5C ~            	LD IX, PTRGET
 232+ 5C5C ~            	CALL CALBAS
 233+ 5C5C ~            	LD (BLIT_STRUCT+11),DE
 234+ 5C5C ~            	; comma
 235+ 5C5C ~            	CALL CHKCHAR
 236+ 5C5C ~            	DB ','
 237+ 5C5C ~            	; get x
 238+ 5C5C ~            	LD IX, FRMQNT
 239+ 5C5C ~            	CALL CALBAS
 240+ 5C5C ~            	LD (BLIT_STRUCT+0),DE
 241+ 5C5C ~            	; comma
 242+ 5C5C ~            	CALL CHKCHAR
 243+ 5C5C ~            	DB ','
 244+ 5C5C ~            	; get y
 245+ 5C5C ~            	LD IX, FRMQNT
 246+ 5C5C ~            	CALL CALBAS
 247+ 5C5C ~            	LD (BLIT_STRUCT+2),DE
 248+ 5C5C ~            	; comma
 249+ 5C5C ~            	CALL CHKCHAR
 250+ 5C5C ~            	DB ','
 251+ 5C5C ~            	; get width
 252+ 5C5C ~            	LD IX, FRMQNT
 253+ 5C5C ~            	CALL CALBAS
 254+ 5C5C ~            	LD (BLIT_STRUCT+4),DE
 255+ 5C5C ~            	; comma
 256+ 5C5C ~            	CALL CHKCHAR
 257+ 5C5C ~            	DB ','
 258+ 5C5C ~            	; get height
 259+ 5C5C ~            	LD IX, FRMQNT
 260+ 5C5C ~            	CALL CALBAS
 261+ 5C5C ~            	LD (BLIT_STRUCT+6),DE
 262+ 5C5C ~            	; comma
 263+ 5C5C ~            	CALL CHKCHAR
 264+ 5C5C ~            	DB ','
 265+ 5C5C ~            	; get number of items in a list
 266+ 5C5C ~            	LD IX, GETBYT
 267+ 5C5C ~            	CALL CALBAS
 268+ 5C5C ~            	LD (BLIT_STRUCT+8),A
 269+ 5C5C ~            	; comma
 270+ 5C5C ~            	CALL CHKCHAR
 271+ 5C5C ~            	DB ','
 272+ 5C5C ~            	; get address of rectangle structure array DIM R%(7,n)
 273+ 5C5C ~            	LD A,(BLIT_STRUCT+8)
 274+ 5C5C ~                LD E,A
 275+ 5C5C ~                LD A,2
 276+ 5C5C ~            	LD B,A
 277+ 5C5C ~            	LD D,7
 278+ 5C5C ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
 279+ 5C5C ~            	LD (BLIT_STRUCT+9),BC
 280+ 5C5C ~            	; ending )
 281+ 5C5C ~            	CALL CHKCHAR
 282+ 5C5C ~            	DB ')'
 283+ 5C5C ~
 284+ 5C5C ~                PUSH HL
 285+ 5C5C ~                CALL FIND_OVERLAP
 286+ 5C5C ~                LD HL,(BLIT_STRUCT+11)
 287+ 5C5C ~                JR C,.NOTFOUND
 288+ 5C5C ~                LD (HL),A
 289+ 5C5C ~                INC HL
 290+ 5C5C ~                LD (HL),0
 291+ 5C5C ~                POP HL
 292+ 5C5C ~                RET
 293+ 5C5C ~            .NOTFOUND:
 294+ 5C5C ~                LD (HL),#FF
 295+ 5C5C ~                INC HL
 296+ 5C5C ~                LD (HL),#FF
 297+ 5C5C ~                POP HL
 298+ 5C5C ~                RET
 299+ 5C5C ~            ; ************************************************************************************************
 300+ 5C5C               ENDIF
 301+ 5C5C
 302+ 5C5C               IF (DEFUSR_EXTENSION == 1)
 303+ 5C5C              ; *******************************************************************************************************
 304+ 5C5C              ; same as COLL but for DEFUSR approach
 305+ 5C5C              ; input IX=pointer to input array, real data from +2
 306+ 5C5C              ; +02 = pointer to result variable
 307+ 5C5C              ; +04 = player X
 308+ 5C5C              ; +06 = player Y
 309+ 5C5C              ; +08 = player width
 310+ 5C5C              ; +10 = player height
 311+ 5C5C              ; +12 = number of list items
 312+ 5C5C              ; +14 = pointer to list of collidable objects
 313+ 5C5C              COLL_DEFUSR:
 314+ 5C5C DD E5            PUSH IX
 315+ 5C5E E1               POP HL
 316+ 5C5F 23          > INC HL ; skip over to player x
 316+ 5C60 23          > INC HL
 316+ 5C61 23          > INC HL
 316+ 5C62 23          > INC HL
 317+ 5C63 11 07 5D         LD DE,BLIT_STRUCT
 318+ 5C66 01 09 00         LD BC,9
 319+ 5C69 ED B0            LDIR ; copy over x,y,w,h,list item number
 320+ 5C6B DD 7E 0E         LD A,(IX+14)
 321+ 5C6E 32 10 5D         LD (BLIT_STRUCT+9),A
 322+ 5C71 DD 7E 0F         LD A,(IX+15)
 323+ 5C74 32 11 5D         LD (BLIT_STRUCT+10),A ; address to collidable objects array
 324+ 5C77 DD 7E 02         LD A,(IX+2)
 325+ 5C7A 32 12 5D         LD (BLIT_STRUCT+11),A
 326+ 5C7D DD 7E 03         LD A,(IX+3)
 327+ 5C80 32 13 5D         LD (BLIT_STRUCT+12),A ; address to results variable
 328+ 5C83 DD E5            PUSH IX
 329+ 5C85 CD 0A 5C         CALL FIND_OVERLAP
 330+ 5C88 DD E1            POP IX
 331+ 5C8A DD 6E 02         LD L,(IX+2)
 332+ 5C8D DD 66 03         LD H,(IX+3)
 333+ 5C90 38 05            JR C,.NOTFOUND
 334+ 5C92 77               LD (HL),A
 335+ 5C93 23               INC HL
 336+ 5C94 36 00            LD (HL),0
 337+ 5C96 C9               RET
 338+ 5C97              .NOTFOUND:
 339+ 5C97 36 FF            LD (HL),#FF
 340+ 5C99 23               INC HL
 341+ 5C9A 36 FF            LD (HL),#FF
 342+ 5C9C C9               RET
 343+ 5C9D              ; *******************************************************************************************************
 344+ 5C9D               ENDIF
 345+ 5C9D
# file closed: asm\COLLISION.asm
 165  5C9D               ENDIF
 166  5C9D
 167  5C9D               IF (DEFUSR_EXTENSION == 1)
 168  5C9D               INCLUDE "DEFUSR.asm"
# file opened: asm\DEFUSR.asm
   1+ 5C9D              ; entry function that handles call using CALLF
   2+ 5C9D              ; pointer to data structure is expected at DAC+2
   3+ 5C9D              ; first entry must be function id followed by function specific parameters
   4+ 5C9D
   5+ 5C9D              DEFUSR_TABLE_ENTRIES    EQU 38
   6+ 5C9D
   7+ 5C9D              DEFUSR_JUMP_TABLE:
   8+ 5C9D               IF (SPRITE_CMDS == 1)
   9+ 5C9D 6E 4E         DW SPRENABLE_DEFUSR        ; 0
  10+ 5C9F               ELSE
  11+ 5C9F ~             DW NOACTION_DEFUSR
  12+ 5C9F               ENDIF
  13+ 5C9F
  14+ 5C9F               IF (SPRITE_CMDS == 1)
  15+ 5C9F 92 4E         DW SPRDISABLE_DEFUSR        ; 1
  16+ 5CA1               ELSE
  17+ 5CA1 ~             DW NOACTION_DEFUSR
  18+ 5CA1               ENDIF
  19+ 5CA1
  20+ 5CA1               IF (RAM_CMDS == 1)
  21+ 5CA1 23 55         DW MEMCPY_DEFUSR           ; 2
  22+ 5CA3               ELSE
  23+ 5CA3 ~             DW NOACTION_DEFUSR
  24+ 5CA3               ENDIF
  25+ 5CA3
  26+ 5CA3               IF (VRAM_CMDS == 1)        ; 3
  27+ 5CA3 24 56         DW MEMVRM_DEFUSR
  28+ 5CA5               ELSE
  29+ 5CA5 ~             DW NOACTION_DEFUSR
  30+ 5CA5               ENDIF
  31+ 5CA5
  32+ 5CA5               IF (BLIT_CMDS == 1)        ; 4
  33+ 5CA5 2B 59         DW BLIT_DEFUSR
  34+ 5CA7               ELSE
  35+ 5CA7 ~             DW NOACTION_DEFUSR
  36+ 5CA7               ENDIF
  37+ 5CA7
  38+ 5CA7               IF (ANIM_CMDS == 1)        ; 5
  39+ 5CA7 FB 53         DW SGAM_DEFUSR
  40+ 5CA9               ELSE
  41+ 5CA9 ~             DW NOACTION_DEFUSR
  42+ 5CA9               ENDIF
  43+ 5CA9
  44+ 5CA9               IF (SPRITE_CMDS == 1)
  45+ 5CA9 D5 4E         DW SPRGRPMOV_DEFUSR        ; 6
  46+ 5CAB               ELSE
  47+ 5CAB ~             DW NOACTION_DEFUSR
  48+ 5CAB               ENDIF
  49+ 5CAB
  50+ 5CAB               IF (COLL_CMD == 1)
  51+ 5CAB 5C 5C         DW COLL_DEFUSR             ; 7
  52+ 5CAD               ELSE
  53+ 5CAD ~             DW NOACTION_DEFUSR
  54+ 5CAD               ENDIF
  55+ 5CAD
  56+ 5CAD               IF (SOUND_CMDS == 1)
  57+ 5CAD DE 55         DW SNDSFX_DEFUSR             ; 8
  58+ 5CAF               ELSE
  59+ 5CAF ~             DW NOACTION_DEFUSR
  60+ 5CAF               ENDIF
  61+ 5CAF
  62+ 5CAF               IF (ANIM_CMDS == 1)
  63+ 5CAF 8C 52         DW ANIMSTEP_SINGLE_DEFUSR      ; 9
  64+ 5CB1 9C 52         DW ANIMSTEP_MULTI_DEFUSR       ; 10
  65+ 5CB3 AD 52         DW ANIMSTART_SINGLE_DEFUSR     ; 11
  66+ 5CB5 BF 52         DW ANIMSTART_MULTI_DEFUSR      ; 12
  67+ 5CB7 C4 52         DW ANIMSTOP_SINGLE_DEFUSR      ; 13
  68+ 5CB9 CE 52         DW ANIMSTOP_MULTI_DEFUSR       ; 14
  69+ 5CBB               ELSE
  70+ 5CBB ~             DW NOACTION_DEFUSR
  71+ 5CBB ~             DW NOACTION_DEFUSR
  72+ 5CBB ~             DW NOACTION_DEFUSR
  73+ 5CBB ~             DW NOACTION_DEFUSR
  74+ 5CBB ~             DW NOACTION_DEFUSR
  75+ 5CBB ~             DW NOACTION_DEFUSR
  76+ 5CBB               ENDIF
  77+ 5CBB
  78+ 5CBB               IF (BOX_CMDS == 1)
  79+ 5CBB 36 57         DW BOXMEMCPY_DEFUSR            ; 15
  80+ 5CBD 6C 57         DW BOXMEMVRM_DEFUSR            ; 16
  81+ 5CBF               ELSE
  82+ 5CBF ~             DW NOACTION_DEFUSR
  83+ 5CBF ~             DW NOACTION_DEFUSR
  84+ 5CBF               ENDIF
  85+ 5CBF
  86+ 5CBF               IF (ANIM_CMDS == 1)
  87+ 5CBF 35 4F         DW MAXANIMITEMS_DEFUSR         ; 17
  88+ 5CC1 44 50         DW MAXANIMDEFS_DEFUSR          ; 18
  89+ 5CC3 A1 50         DW MAXANIMSPRS_DEFUSR          ; 19
  90+ 5CC5 61 51         DW MAXAUTOSGAMS_DEFUSR         ; 20
  91+ 5CC7 FA 4F         DW ANIMITEMPAT_DEFUSR          ; 21
  92+ 5CC9 1F 50         DW ANIMITEMPTR_DEFUSR          ; 22
  93+ 5CCB 7B 50         DW ANIMDEF_DEFUSR              ; 23
  94+ 5CCD EE 50         DW ANIMSPRITE_DEFUSR           ; 24
  95+ 5CCF 26 51         DW ANIMCHAR_DEFUSR             ; 25
  96+ 5CD1 B2 51         DW AUTOSGAMDEF_DEFUSR          ; 26
  97+ 5CD3 41 52         DW AUTOSGAMSTART_DEFUSR        ; 27
  98+ 5CD5 68 52         DW AUTOSGAMSTOP_DEFUSR         ; 28
  99+ 5CD7               ELSE
 100+ 5CD7 ~             DW NOACTION_DEFUSR
 101+ 5CD7 ~             DW NOACTION_DEFUSR
 102+ 5CD7 ~             DW NOACTION_DEFUSR
 103+ 5CD7 ~             DW NOACTION_DEFUSR
 104+ 5CD7 ~             DW NOACTION_DEFUSR
 105+ 5CD7 ~             DW NOACTION_DEFUSR
 106+ 5CD7 ~             DW NOACTION_DEFUSR
 107+ 5CD7 ~             DW NOACTION_DEFUSR
 108+ 5CD7 ~             DW NOACTION_DEFUSR
 109+ 5CD7 ~             DW NOACTION_DEFUSR
 110+ 5CD7 ~             DW NOACTION_DEFUSR
 111+ 5CD7 ~             DW NOACTION_DEFUSR
 112+ 5CD7               ENDIF
 113+ 5CD7
 114+ 5CD7               IF (GENCAL_CMD == 1)
 115+ 5CD7 B6 56         DW GENCAL_DEFUSR               ; 29
 116+ 5CD9               ELSE
 117+ 5CD9 ~             DW NOACTION_DEFUSR
 118+ 5CD9               ENDIF
 119+ 5CD9
 120+ 5CD9               IF (RAM_CMDS == 1)
 121+ 5CD9 44 55         DW FILRAM_DEFUSR               ; 30
 122+ 5CDB               ELSE
 123+ 5CDB ~             DW NOACTION_DEFUSR
 124+ 5CDB               ENDIF
 125+ 5CDB
 126+ 5CDB               IF (SOUND_CMDS == 1)
 127+ 5CDB 75 55         DW SNDPLYINI_DEFUSR            ; 31
 128+ 5CDD A8 55         DW SNDPLYON_DEFUSR             ; 32
 129+ 5CDF BB 55         DW SNDPLYOFF_DEFUSR            ; 33
 130+ 5CE1               ELSE
 131+ 5CE1 ~             DW NOACTION_DEFUSR
 132+ 5CE1 ~             DW NOACTION_DEFUSR
 133+ 5CE1 ~             DW NOACTION_DEFUSR
 134+ 5CE1               ENDIF
 135+ 5CE1
 136+ 5CE1               IF (TILE_CMDS == 1)
 137+ 5CE1 0D 5A         DW TILERAM_DEFUSR              ; 34
 138+ 5CE3 C4 5A         DW TILEVRM_DEFUSR              ; 35
 139+ 5CE5               ELSE
 140+ 5CE5 ~             DW NOACTION_DEFUSR
 141+ 5CE5 ~             DW NOACTION_DEFUSR
 142+ 5CE5               ENDIF
 143+ 5CE5
 144+ 5CE5               IF (VRAM_CMDS == 1)
 145+ 5CE5 01 56         DW FILVRM_DEFUSR               ; 36
 146+ 5CE7 77 56         DW VRMMEM_DEFUSR               ; 37
 147+ 5CE9               ELSE
 148+ 5CE9 ~             DW NOACTION_DEFUSR
 149+ 5CE9 ~             DW NOACTION_DEFUSR
 150+ 5CE9               ENDIF
 151+ 5CE9
 152+ 5CE9              DEFUSR_ENTRY:
 153+ 5CE9 FB               EI
 154+ 5CEA DD 2A F8 F7      LD IX,(DAC+2)
 155+ 5CEE DD 7E 00         LD A,(IX)
 156+ 5CF1 FE 26            CP DEFUSR_TABLE_ENTRIES
 157+ 5CF3 D0               RET NC ; return if an undefined function requested
 158+ 5CF4 26 00            LD H,0
 159+ 5CF6 6F               LD L,A
 160+ 5CF7 29               ADD HL,HL
 161+ 5CF8 11 9D 5C         LD DE,DEFUSR_JUMP_TABLE
 162+ 5CFB 19               ADD HL,DE
 163+ 5CFC EB               EX DE,HL
 164+ 5CFD 1A               LD A,(DE)
 165+ 5CFE 6F               LD L,A
 166+ 5CFF 13               INC DE
 167+ 5D00 1A               LD A,(DE)
 168+ 5D01 67               LD H,A
 169+ 5D02 E9               JP (HL) ; call function with IX=pointer to data array
 170+ 5D03
# file closed: asm\DEFUSR.asm
 169  5D03               ENDIF
 170  5D03
 171  5D03              ; temp variables for BLIT, TILE functions
 172  5D03               IF (BLIT_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS + COLL_CMD > 0)
 173  5D03              BLIT_TMP:
 174  5D03              TILETMP1:
 175  5D03              BLIT_TMP1:
 176  5D03 00 00         DW 0
 177  5D05              TILETMP2:
 178  5D05              BLIT_TMP2:
 179  5D05 00 00         DW 0
 180  5D07              BLIT_STRUCT:
 181  5D07 00 00 00...   DS 17
 182  5D0B               ENDIF
 183  5D18
 184  5D18               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 185  5D18              VRAM_UPDATE_IN_PROGRESS:
 186  5D18 00            DB 0
 187  5D19               ENDIF
 188  5D19
 189  5D19              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 190  5D19              ; per starting letter, if no commands with this letter, NULL value
 191  5D19              CMDS:
 192  5D19 4D 5D        	DW CMDS_A ; always present due to ARTINFO
 193  5D1B               IF (BLIT_CMDS + BOX_CMDS > 0) && (BASIC_EXTENSION == 1)
 194  5D1B ~                DW CMDS_B ; B
 195  5D1B               ELSE
 196  5D1B 00 00        	DW 0
 197  5D1D               ENDIF
 198  5D1D               IF (COLL_CMD == 1) && (BASIC_EXTENSION == 1)
 199  5D1D ~            	DW CMDS_C ;
 200  5D1D               ELSE
 201  5D1D 00 00            DW 0 ; C
 202  5D1F               ENDIF
 203  5D1F 00 00            DW 0 ; D
 204  5D21 00 00            DW 0 ; E
 205  5D23               IF (VRAM_CMDS + RAM_CMDS > 0) && (BASIC_EXTENSION == 1)
 206  5D23 ~                DW CMDS_F; F
 207  5D23               ELSE
 208  5D23 00 00        	DW 0
 209  5D25               ENDIF
 210  5D25               IF (GENCAL_CMD > 0) && (BASIC_EXTENSION == 1)
 211  5D25 ~                DW CMDS_G; G
 212  5D25               ELSE
 213  5D25 00 00        	DW 0
 214  5D27               ENDIF
 215  5D27 00 00            DW 0 ; H
 216  5D29 00 00            DW 0 ; I
 217  5D2B 00 00            DW 0 ; J
 218  5D2D 00 00            DW 0 ; K
 219  5D2F 00 00            DW 0 ; L
 220  5D31               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0) && (BASIC_EXTENSION == 1)
 221  5D31 ~                DW CMDS_M ; M
 222  5D31               ELSE
 223  5D31 00 00        	DW 0
 224  5D33               ENDIF
 225  5D33 00 00            DW 0 ; N
 226  5D35 00 00            DW 0 ; O
 227  5D37 00 00            DW 0 ; P
 228  5D39 00 00            DW 0 ; Q
 229  5D3B 00 00            DW 0 ; R
 230  5D3D               IF (SOUND_CMDS + SPRITE_CMDS > 0) && (BASIC_EXTENSION == 1)
 231  5D3D ~                DW CMDS_S ; S
 232  5D3D               ELSE
 233  5D3D 00 00        	DW 0
 234  5D3F               ENDIF
 235  5D3F               IF (TILE_CMDS > 0) && (BASIC_EXTENSION == 1)
 236  5D3F ~                DW CMDS_T ; T
 237  5D3F               ELSE
 238  5D3F 00 00        	DW 0
 239  5D41               ENDIF
 240  5D41 00 00            DW 0 ; U
 241  5D43               IF (VRAM_CMDS > 0) && (BASIC_EXTENSION == 1)
 242  5D43 ~                DW CMDS_V ; V
 243  5D43               ELSE
 244  5D43 00 00        	DW 0
 245  5D45               ENDIF
 246  5D45 00 00            DW 0 ; W
 247  5D47 00 00            DW 0 ; X
 248  5D49 00 00            DW 0 ; Y
 249  5D4B 00 00            DW 0 ; Z
 250  5D4D
 251  5D4D               IF (BASIC_EXTENSION == 1)
 252  5D4D ~            CMDS_M:
 253  5D4D ~             IF (VRAM_CMDS == 1)
 254  5D4D ~                DB "MEMVRM", 0
 255  5D4D ~                DW MEMVRM
 256  5D4D ~             ENDIF
 257  5D4D ~             IF (RAM_CMDS == 1)
 258  5D4D ~            	DB "MEMCPY", 0
 259  5D4D ~            	DW MEMCPY
 260  5D4D ~             ENDIF
 261  5D4D ~             IF (ANIM_CMDS == 1)
 262  5D4D ~            	DB "MAXANIMITEMS",0
 263  5D4D ~            	DW MAXANIMITEMS
 264  5D4D ~            	DB "MAXANIMDEFS",0
 265  5D4D ~            	DW MAXANIMDEFS
 266  5D4D ~            	DB "MAXANIMSPRS",0
 267  5D4D ~            	DW MAXANIMSPRS
 268  5D4D ~               DB "MAXAUTOSGAMS",0
 269  5D4D ~               DW MAXAUTOSGAMS
 270  5D4D ~             ENDIF
 271  5D4D ~             IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 272  5D4D ~            	DB 0
 273  5D4D ~             ENDIF
 274  5D4D ~            CMDS_F:
 275  5D4D ~             IF (VRAM_CMDS == 1)
 276  5D4D ~                DB "FILVRM", 0
 277  5D4D ~                DW FILVRM
 278  5D4D ~             ENDIF
 279  5D4D ~             IF (RAM_CMDS == 1)
 280  5D4D ~                DB "FILRAM", 0
 281  5D4D ~                DW FILRAM
 282  5D4D ~             ENDIF
 283  5D4D ~             IF (VRAM_CMDS + RAM_CMDS > 0)
 284  5D4D ~                DB 0
 285  5D4D ~             ENDIF
 286  5D4D ~            CMDS_G:
 287  5D4D ~             IF (GENCAL_CMD == 1)
 288  5D4D ~                DB "GENCAL", 0
 289  5D4D ~                DW GENCAL
 290  5D4D ~             ENDIF
 291  5D4D ~             IF (GENCAL_CMD > 0)
 292  5D4D ~            	DB	0
 293  5D4D ~             ENDIF
 294  5D4D ~            CMDS_V:
 295  5D4D ~             IF (VRAM_CMDS == 1)
 296  5D4D ~            	DB "VRMMEM", 0
 297  5D4D ~            	DW VRMMEM
 298  5D4D ~             ENDIF
 299  5D4D ~             IF (VRAM_CMDS > 0)
 300  5D4D ~            	DB 0
 301  5D4D ~             ENDIF
 302  5D4D ~            CMDS_S:
 303  5D4D ~             IF (SPRITE_CMDS + ANIM_CMDS > 0)
 304  5D4D ~                DB "SGAM",0
 305  5D4D ~                DW SGAM
 306  5D4D ~             ENDIF
 307  5D4D ~             IF (SPRITE_CMDS == 1)
 308  5D4D ~            	DB "SPRGRPMOV", 0
 309  5D4D ~            	DW SPRGRPMOV
 310  5D4D ~             ENDIF
 311  5D4D ~             IF (SOUND_CMDS == 1)
 312  5D4D ~            	DB "SNDSFX", 0
 313  5D4D ~            	DW SNDSFX
 314  5D4D ~            	DB "SNDPLYON", 0
 315  5D4D ~            	DW SNDPLYON
 316  5D4D ~            	DB "SNDPLYOFF", 0
 317  5D4D ~            	DW SNDPLYOFF
 318  5D4D ~            	DB "SNDPLYINI", 0
 319  5D4D ~            	DW SNDPLYINIT
 320  5D4D ~             ENDIF
 321  5D4D ~             IF (SPRITE_CMDS == 1)
 322  5D4D ~            	DB "SPRENABLE", 0
 323  5D4D ~            	DW SPRENABLE
 324  5D4D ~            	DB "SPRDISABLE", 0
 325  5D4D ~            	DW SPRDISABLE
 326  5D4D ~             ENDIF
 327  5D4D ~             IF (SOUND_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 328  5D4D ~            	DB 0
 329  5D4D ~             ENDIF
 330  5D4D ~            CMDS_B:
 331  5D4D ~             IF (BLIT_CMDS == 1)
 332  5D4D ~            	DB "BLIT", 0
 333  5D4D ~            	DW BLIT
 334  5D4D ~             ENDIF
 335  5D4D ~             IF (BOX_CMDS == 1)
 336  5D4D ~            	DB "BOXMEMCPY", 0
 337  5D4D ~            	DW BOXMEMCPY
 338  5D4D ~            	DB "BOXMEMVRM", 0
 339  5D4D ~            	DW BOXMEMVRM
 340  5D4D ~             ENDIF
 341  5D4D ~             IF (BLIT_CMDS + BOX_CMDS > 0)
 342  5D4D ~            	DB 0
 343  5D4D ~             ENDIF
 344  5D4D ~            CMDS_T:
 345  5D4D ~             IF (TILE_CMDS == 1)
 346  5D4D ~            	DB "TILERAM", 0
 347  5D4D ~            	DW TILERAM
 348  5D4D ~            	DB "TILEVRM", 0
 349  5D4D ~            	DW TILEVRM
 350  5D4D ~             ENDIF
 351  5D4D ~             IF (TILE_CMDS > 0)
 352  5D4D ~            	DB 0
 353  5D4D ~             ENDIF
 354  5D4D ~            CMDS_C:
 355  5D4D ~             IF (COLL_CMD == 1)
 356  5D4D ~                DB "COLL", 0
 357  5D4D ~                DW COLL
 358  5D4D ~             ENDIF
 359  5D4D ~             IF (COLL_CMD > 0)
 360  5D4D ~            	DB	0
 361  5D4D ~             ENDIF
 362  5D4D ~            CMDS_A:
 363  5D4D ~             IF (ANIM_CMDS == 1)
 364  5D4D ~               DB "ANIMSTEP",0
 365  5D4D ~               DW ANIMSTEP
 366  5D4D ~            	DB "ANIMSTART",0
 367  5D4D ~            	DW ANIMSTART
 368  5D4D ~            	DB "ANIMSTOP",0
 369  5D4D ~            	DW ANIMSTOP
 370  5D4D ~            	DB "ANIMITEMPAT",0
 371  5D4D ~            	DW ANIMITEMPAT
 372  5D4D ~            	DB "ANIMITEMPTR",0
 373  5D4D ~            	DW ANIMITEMPTR_CMD
 374  5D4D ~            	DB "ANIMDEF",0
 375  5D4D ~            	DW ANIMDEF
 376  5D4D ~            	DB "ANIMSPRITE",0
 377  5D4D ~            	DW ANIMSPRITE
 378  5D4D ~               DB "ANIMCHAR",0
 379  5D4D ~               DW ANIMCHAR
 380  5D4D ~               DB "AUTOSGAMDEF",0
 381  5D4D ~               DW AUTOSGAMDEF
 382  5D4D ~               DB "AUTOSGAMSTART",0
 383  5D4D ~               DW AUTOSGAMSTART
 384  5D4D ~               DB "AUTOSGAMSTOP",0
 385  5D4D ~               DW AUTOSGAMSTOP
 386  5D4D ~             ENDIF
 387  5D4D ~               DB "ARTINFO",0
 388  5D4D ~               DW ARTINFO
 389  5D4D ~            	DB 0
 390  5D4D               ELSE
 391  5D4D              CMDS_A:
 392  5D4D 41 52 54 49   DB "ARTINFO",0
 392  5D51 4E 46 4F 00
 393  5D55 AD 5E         DW ARTINFO
 394  5D57 00            DB 0
 395  5D58               ENDIF
 396  5D58
 397  5D58
 398  5D58               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 399  5D58              ; ****************************************************************************************************
 400  5D58              ; function sets VRAM address
 401  5D58              ; input HL=address
 402  5D58              ; modifies AF
 403  5D58              SETWRT_LOCAL:
 404  5D58 7D           	LD	A,L
 405  5D59 D3 99        	OUT (099H),A
 406  5D5B 7C           	LD	A,H
 407  5D5C E6 3F        	AND 03FH
 408  5D5E F6 40        	OR	040H
 409  5D60 D3 99        	OUT (099H),A
 410  5D62 C9           	RET
 411  5D63              ; ****************************************************************************************************
 412  5D63               ENDIF
 413  5D63
 414  5D63               IF (VRAM_CMDS + TILE_CMDS > 0)
 415  5D63              ; ****************************************************************************************************
 416  5D63              ; function copies data from RAM to VRAM
 417  5D63              ; input HL=address in RAM
 418  5D63              ; input B=count
 419  5D63              ; modifies AF, BC, HL
 420  5D63              BBYTECOPY:
 421  5D63 0E 98        	LD C,#98
 422  5D65              BBYTECOPY_NO_C:
 423  5D65 ED A3        	OUTI
 424  5D67 C2 65 5D     	JP	NZ, BBYTECOPY_NO_C
 425  5D6A C9           	RET
 426  5D6B              ; ****************************************************************************************************
 427  5D6B               ENDIF
 428  5D6B
 429  5D6B              ; ****************************************************************************************************
 430  5D6B              ; function multiplies HL by 32
 431  5D6B              HLx32:
 432  5D6B 29           	ADD HL,HL
 433  5D6C              ; ****************************************************************************************************
 434  5D6C              ; function multiplies HL by 16
 435  5D6C              HLx16:
 436  5D6C 29           	ADD HL,HL
 437  5D6D              ; ****************************************************************************************************
 438  5D6D              ; function multiplies HL by 8
 439  5D6D              HLx8:
 440  5D6D 29          > ADD HL, HL
 440  5D6E 29          > ADD HL, HL
 440  5D6F 29          > ADD HL, HL
 441  5D70 C9           	RET
 442  5D71              ; ****************************************************************************************************
 443  5D71
 444  5D71              ; ****************************************************************************************************
 445  5D71              ; function gets slot and subslot data for specific page
 446  5D71              ; input A=page (0, 1 or 2)
 447  5D71              ; output B = 0A8H register value
 448  5D71              ; output D = 0 is no subslots, 1 if yes
 449  5D71              ; output C = 0A8H value when page 3 slot equals to requested page slot
 450  5D71              ; output E = subslot value if present
 451  5D71              ; modifies AF, BC, DE, HL
 452  5D71              GET_PAGE_INFO:
 453  5D71 6F               LD L, A
 454  5D72 C6 C1            ADD A, low (EXPTBL)
 455  5D74 32 7E 5D         LD (GET_PAGE_INFO_L1+1), A
 456  5D77 DB A8            IN A, (0A8H)
 457  5D79 47               LD B, A
 458  5D7A E6 3F            AND 03FH
 459  5D7C 4F               LD C, A
 460  5D7D              GET_PAGE_INFO_L1:
 461  5D7D 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 462  5D80 E6 80            AND 080H
 463  5D82 28 1B            JR Z, GET_PAGE_INFO_L2
 464  5D84                  ; expanded
 465  5D84 2D               DEC L
 466  5D85 FA A4 5D         JP M, GET_PAGE_INFO_L3
 467  5D88 2D               DEC L
 468  5D89 FA A2 5D         JP M, GET_PAGE_INFO_L4
 469  5D8C                  ; page 2
 470  5D8C 07               RLCA
 471  5D8D 07               RLCA
 472  5D8E              GET_PAGE_INFO_L5:
 473  5D8E E6 C0            AND 0C0H
 474  5D90 B1               OR C
 475  5D91 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 476  5D93 4F               LD C, A
 477  5D94 3A FF FF         LD A, (0FFFFH)
 478  5D97 2F               CPL
 479  5D98 5F               LD E, A
 480  5D99 16 01            LD D, 1
 481  5D9B 78               LD A, B ; return stack
 482  5D9C D3 A8            OUT (0A8H), A
 483  5D9E C9               RET
 484  5D9F              GET_PAGE_INFO_L2:
 485  5D9F                  ; not expanded
 486  5D9F 16 00            LD D, 0
 487  5DA1 C9               RET
 488  5DA2              GET_PAGE_INFO_L4:
 489  5DA2                  ; page 1
 490  5DA2 0F               RRCA
 491  5DA3 0F               RRCA
 492  5DA4              GET_PAGE_INFO_L3:
 493  5DA4                  ; page 0
 494  5DA4 0F               RRCA
 495  5DA5 0F               RRCA
 496  5DA6 18 E6            JR GET_PAGE_INFO_L5
 497  5DA8              ; ****************************************************************************************************
 498  5DA8
 499  5DA8              ; ****************************************************************************************************
 500  5DA8              ; function returns original slot and subslot info
 501  5DA8              ; input B = 0A8H register value
 502  5DA8              ; input D = 0 is no subslots, 1 if yes
 503  5DA8              ; input C = 0A8H value when page 3 slot equals to requested page slot
 504  5DA8              ; input E = subslot value if present
 505  5DA8              ; modifies AF, disables interrupts
 506  5DA8              RESTORE_PAGE_INFO:
 507  5DA8 F3              DI
 508  5DA9 7A              LD A, D
 509  5DAA B7              OR A
 510  5DAB 28 07           JR Z, RESTORE_PAGE_INFO_L1
 511  5DAD 79              LD A, C
 512  5DAE D3 A8           OUT (0A8H), A
 513  5DB0 7B              LD A, E
 514  5DB1 32 FF FF        LD (0FFFFH), A
 515  5DB4              RESTORE_PAGE_INFO_L1:
 516  5DB4 78              LD A, B
 517  5DB5 D3 A8           OUT (0A8H), A
 518  5DB7              NOACTION_DEFUSR: ; just a safe RET for use when DEFUSR table has an empty entry
 519  5DB7 C9              RET
 520  5DB8              ; ****************************************************************************************************
 521  5DB8
 522  5DB8              ; *******************************************************************************************************
 523  5DB8              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 524  5DB8              ; INPUT:  A = SLOT ID: EXXXSSPP
 525  5DB8              ; E = EXPANDED FLAG
 526  5DB8              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 527  5DB8              ; PP = PRIMARY SLOT NUMBER
 528  5DB8              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 529  5DB8              ; CHANGES: AF, BC, DE
 530  5DB8
 531  5DB8              LOCAL_ENASLT:
 532  5DB8 CD D8 5D         CALL L0353
 533  5DBB FA C5 5D         JP M, L0340
 534  5DBE DB A8            IN A, (0A8H)
 535  5DC0 A1               AND C
 536  5DC1 B0               OR B
 537  5DC2 D3 A8            OUT (0A8H), A
 538  5DC4 C9               RET
 539  5DC5              L0340:
 540  5DC5 E5               PUSH HL
 541  5DC6 CD FD 5D         CALL L0378
 542  5DC9 4F               LD C, A
 543  5DCA 06 00            LD B, 0
 544  5DCC 7D               LD A, L
 545  5DCD A4               AND H
 546  5DCE B2               OR D
 547  5DCF 21 C5 FC         LD HL, 0FCC5H
 548  5DD2 09               ADD HL, BC
 549  5DD3 77               LD (HL), A
 550  5DD4 E1               POP HL
 551  5DD5 79               LD A, C
 552  5DD6 18 E0            JR LOCAL_ENASLT
 553  5DD8              L0353:
 554  5DD8 F3               DI
 555  5DD9 F5               PUSH AF
 556  5DDA 7C               LD A, H
 557  5DDB 07               RLCA
 558  5DDC 07               RLCA
 559  5DDD E6 03            AND 3
 560  5DDF 5F               LD E, A
 561  5DE0 3E C0            LD A, 0C0H
 562  5DE2              L035D:
 563  5DE2 07               RLCA
 564  5DE3 07               RLCA
 565  5DE4 1D               DEC E
 566  5DE5 F2 E2 5D         JP P, L035D
 567  5DE8 5F               LD E, A
 568  5DE9 2F               CPL
 569  5DEA 4F               LD C, A
 570  5DEB F1               POP AF
 571  5DEC F5               PUSH AF
 572  5DED E6 03            AND 3
 573  5DEF 3C               INC A
 574  5DF0 47               LD B, A
 575  5DF1 3E AB            LD A, 0ABH
 576  5DF3              L036E:
 577  5DF3 C6 55            ADD A, 055H
 578  5DF5 10 FC            DJNZ L036E
 579  5DF7 57               LD D, A
 580  5DF8 A3               AND E
 581  5DF9 47               LD B, A
 582  5DFA F1               POP AF
 583  5DFB A7               AND A
 584  5DFC C9               RET
 585  5DFD              L0378:
 586  5DFD F5               PUSH AF
 587  5DFE 7A               LD A, D
 588  5DFF E6 C0            AND 0C0H
 589  5E01 4F               LD C, A
 590  5E02 F1               POP AF
 591  5E03 F5               PUSH AF
 592  5E04 57               LD D, A
 593  5E05 DB A8            IN A, (0A8H)
 594  5E07 47               LD B, A
 595  5E08 E6 3F            AND 03FH
 596  5E0A B1               OR C
 597  5E0B D3 A8            OUT (0A8H), A
 598  5E0D 7A               LD A, D
 599  5E0E 0F               RRCA
 600  5E0F 0F               RRCA
 601  5E10 E6 03            AND 3
 602  5E12 57               LD D, A
 603  5E13 3E AB            LD A, 0ABH
 604  5E15              L0390:
 605  5E15 C6 55            ADD A, 055H
 606  5E17 15               DEC D
 607  5E18 F2 15 5E         JP P, L0390
 608  5E1B A3               AND E
 609  5E1C 57               LD D, A
 610  5E1D 7B               LD A, E
 611  5E1E 2F               CPL
 612  5E1F 67               LD H, A
 613  5E20 3A FF FF         LD A, (0FFFFH)
 614  5E23 2F               CPL
 615  5E24 6F               LD L, A
 616  5E25 A4               AND H
 617  5E26 B2               OR D
 618  5E27 32 FF FF         LD (0FFFFH), A
 619  5E2A 78               LD A, B
 620  5E2B D3 A8            OUT (0A8H), A
 621  5E2D F1               POP AF
 622  5E2E E6 03            AND 3
 623  5E30 C9               RET
 624  5E31              ; *******************************************************************************************************
 625  5E31
 626  5E31              ; *******************************************************************************************************
 627  5E31              ; some common code to activate page 0 and place values needed to restore original page on stack
 628  5E31              ; input IY=return address
 629  5E31              ENABLE_PAGE0:
 630  5E31 F3              DI
 631  5E32 AF              XOR A
 632  5E33 CD 71 5D        CALL GET_PAGE_INFO
 633  5E36 C5              PUSH BC
 634  5E37 D5              PUSH DE
 635  5E38 3A 41 F3        LD A, (RAMAD0)
 636  5E3B 26 00           LD H, 0
 637  5E3D CD B8 5D        CALL LOCAL_ENASLT
 638  5E40 FD E9        	JP (IY)
 639  5E42              ; *******************************************************************************************************
 640  5E42
 641  5E42              ; General BASIC CALL-instruction handler
 642  5E42              CALLHAND:
 643  5E42 FB              EI
 644  5E43 E5           	PUSH HL
 645  5E44 21 19 5D     	LD	HL, CMDS ; pointer table based on starting letter
 646  5E47 3A 89 FD        LD A, (PROCNM)
 647  5E4A D6 41           SUB 'A'
 648  5E4C 87              ADD A, A
 649  5E4D 16 00           LD D, 0
 650  5E4F 5F              LD E, A
 651  5E50 19              ADD HL, DE
 652  5E51 5E              LD E, (HL)
 653  5E52 23              INC HL
 654  5E53 56              LD D, (HL)
 655  5E54 7A              LD A, D
 656  5E55 B3              OR E
 657  5E56 28 23           JR Z, .CMDNOTRECOGNIZED
 658  5E58 EB              EX DE, HL
 659  5E59              .CHKCMD:
 660  5E59 11 89 FD     	LD	DE, PROCNM
 661  5E5C              .LOOP:
 662  5E5C 1A              LD	A,(DE)
 663  5E5D BE           	CP	(HL)
 664  5E5E 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 665  5E60 13           	INC	DE
 666  5E61 23           	INC	HL
 667  5E62 A7           	AND	A
 668  5E63 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 669  5E65 5E           	LD	E,(HL)
 670  5E66 23           	INC	HL
 671  5E67 56           	LD	D,(HL)
 672  5E68 E1           	POP	HL		; routine address
 673  5E69 CD 8A 5E     	CALL	GETPREVCHAR
 674  5E6C CD 7E 5E     	CALL	.CALLDE		; Call routine
 675  5E6F A7           	AND	A
 676  5E70 C9           	RET
 677  5E71
 678  5E71              .TONEXTCMD:
 679  5E71 0E FF        	LD	C,0FFH
 680  5E73 AF           	XOR	A
 681  5E74 ED B1        	CPIR			; Skip to end of instruction name
 682  5E76 23           	INC	HL
 683  5E77 23           	INC	HL		; Skip address
 684  5E78 BE           	CP	(HL)
 685  5E79 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 686  5E7B              .CMDNOTRECOGNIZED:
 687  5E7B E1           	POP	HL
 688  5E7C 37              SCF
 689  5E7D C9           	RET
 690  5E7E
 691  5E7E              .CALLDE:
 692  5E7E D5           	PUSH	DE
 693  5E7F C9           	RET
 694  5E80
 695  5E80              ;---------------------------
 696  5E80
 697  5E80              ;GETSTRPNT:
 698  5E80              ; OUT:
 699  5E80              ; HL = String Address
 700  5E80              ; B  = Lenght
 701  5E80              ;        LD      HL,(USR)
 702  5E80              ;        LD      B,(HL)
 703  5E80              ;        INC     HL
 704  5E80              ;        LD      E,(HL)
 705  5E80              ;        INC     HL
 706  5E80              ;        LD      D,(HL)
 707  5E80              ;        EX      DE,HL
 708  5E80              ;        RET
 709  5E80
 710  5E80              ;EVALTXTPARAM:
 711  5E80              ;	CALL	CHKCHAR
 712  5E80              ;	DEFB	"("             ; Check for (
 713  5E80              ;	LD	IX,FRMEVL
 714  5E80              ;	CALL	CALBAS		; Evaluate expression
 715  5E80              ;       LD      A,(VALTYP)
 716  5E80              ;        CP      3               ; Text type?
 717  5E80              ;        JP      NZ,TYPE_MISMATCH
 718  5E80              ;        PUSH	HL
 719  5E80              ;        LD	IX,FRESTR         ; Free the temporary string
 720  5E80              ;        CALL	CALBAS
 721  5E80              ;        POP	HL
 722  5E80              ;	CALL	CHKCHAR
 723  5E80              ;	DEFB	")"             ; Check for )
 724  5E80              ;        RET
 725  5E80
 726  5E80
 727  5E80              CHKCHAR:
 728  5E80 CD 8A 5E     	CALL	GETPREVCHAR	; Get previous basic char
 729  5E83 E3           	EX	(SP),HL
 730  5E84 BE           	CP	(HL) 	        ; Check if good char
 731  5E85 20 1D        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 732  5E87 23           	INC	HL
 733  5E88 E3           	EX	(SP),HL
 734  5E89 23           	INC	HL		; Get next basic char
 735  5E8A
 736  5E8A              GETPREVCHAR:
 737  5E8A 2B           	DEC HL
 738  5E8B DD 21 66 46  	LD	IX,CHRGTR
 739  5E8F CD 59 01     	CALL CALBAS
 740  5E92 FB              EI
 741  5E93 C9              RET
 742  5E94
 743  5E94
 744  5E94              TYPE_MISMATCH:
 745  5E94 1E 0D            LD E, 13 ; Type mismatch
 746  5E96 18 0E            JR THROW_ERROR
 747  5E98              SUBSCRIPT_OUT_OF_RANGE:
 748  5E98 1E 09            LD E,9 ; subscript out of range
 749  5E9A 18 0A        	JR THROW_ERROR
 750  5E9C              OVERFLOW:
 751  5E9C 1E 06        	LD E,6
 752  5E9E 18 06        	JR THROW_ERROR
 753  5EA0              ILLEGAL_FUNCTION:
 754  5EA0 1E 05            LD E, 5 ; illegal function call
 755  5EA2 18 02            JR THROW_ERROR
 756  5EA4              SYNTAX_ERROR:
 757  5EA4 1E 02            LD E, 2 ; Syntax error
 758  5EA6              THROW_ERROR:
 759  5EA6 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 760  5EAA C3 59 01     	JP	CALBAS
 761  5EAD
 762  5EAD              ;---------------------------
 763  5EAD
 764  5EAD               IF (BASIC_EXTENSION == 1)
 765  5EAD ~            ; *******************************************************************************************************
 766  5EAD ~            ; helper function to get pointer to BASIC array data
 767  5EAD ~            ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
 768  5EAD ~            ; input B=dimensions (1 or 2)
 769  5EAD ~            ; input D=minimal first dimension
 770  5EAD ~            ; input E=minimal second dimension, if applicable
 771  5EAD ~            ; returns BC=pointer to first data element
 772  5EAD ~            ; throws BASIC error if invalid type
 773  5EAD ~            GET_BASIC_ARRAY_DATA_POINTER:
 774  5EAD ~            	PUSH DE
 775  5EAD ~            	PUSH BC
 776  5EAD ~            	PUSH AF
 777  5EAD ~               LD A,1
 778  5EAD ~               LD (SUBFLG),A ; search for arrays only
 779  5EAD ~            	LD IX, PTRGET
 780  5EAD ~            	CALL CALBAS
 781  5EAD ~               XOR A
 782  5EAD ~               LD (SUBFLG),A ; if not reset will cause syntax errors
 783  5EAD ~            	LD A,(VALTYP)
 784  5EAD ~            	POP DE ; required type
 785  5EAD ~            	CP D
 786  5EAD ~            	JP NZ,TYPE_MISMATCH
 787  5EAD ~            	LD A,(BC)
 788  5EAD ~            	INC BC
 789  5EAD ~            	POP DE ; required number of dimensions
 790  5EAD ~            	CP D
 791  5EAD ~            	JP NZ,TYPE_MISMATCH
 792  5EAD ~            	POP DE ; required minimal array dimensions
 793  5EAD ~            	DEC A
 794  5EAD ~            	JR Z,.ONE_DIMENSION
 795  5EAD ~            	; 2-dimension array
 796  5EAD ~            	LD A,(BC)
 797  5EAD ~            	.2 INC BC
 798  5EAD ~            	CP E
 799  5EAD ~            	JP C,SUBSCRIPT_OUT_OF_RANGE
 800  5EAD ~            .ONE_DIMENSION:
 801  5EAD ~            	LD A,(BC)
 802  5EAD ~            	.2 INC BC
 803  5EAD ~            	CP D
 804  5EAD ~            	JP C,SUBSCRIPT_OUT_OF_RANGE
 805  5EAD ~            	RET
 806  5EAD ~            ; *******************************************************************************************************
 807  5EAD               ENDIF
 808  5EAD
 809  5EAD              ; *******************************************************************************************************
 810  5EAD              ; function to handle CALL ARTINFO basic extension
 811  5EAD              ; returns info about the extension
 812  5EAD              ; _ARTINFO ( INT variable version,
 813  5EAD              ;			    INT variable build_flags,
 814  5EAD              ;			    INT variable free_memory_ptr )
 815  5EAD              ; this function is always available and can be used to test if the extension is active
 816  5EAD              ARTINFO:
 817  5EAD              	; opening (
 818  5EAD CD 80 5E     	CALL CHKCHAR
 819  5EB0 28           	DB '('
 820  5EB1              	; get address of version variable
 821  5EB1 DD 21 A4 5E  	LD IX, PTRGET
 822  5EB5 CD 59 01     	CALL CALBAS
 823  5EB8 3A 12 40     	LD A,(VERSION)
 824  5EBB 12              LD (DE),A
 825  5EBC 13              INC DE
 826  5EBD 3A 13 40        LD A,(VERSION+1)
 827  5EC0 12              LD (DE),A
 828  5EC1              	; comma
 829  5EC1 CD 80 5E     	CALL CHKCHAR
 830  5EC4 2C           	DB ','
 831  5EC5              	; get address of build flags variable
 832  5EC5 DD 21 A4 5E  	LD IX, PTRGET
 833  5EC9 CD 59 01     	CALL CALBAS
 834  5ECC E5              PUSH HL
 835  5ECD 21 FF 0B        LD HL,SOUND_CMDS+2*RAM_CMDS+4*VRAM_CMDS+8*BLIT_CMDS+16*SPRITE_CMDS+32*GENCAL_CMD+64*TILE_CMDS+128*BOX_CMDS+256*ANIM_CMDS+512*COLL_CMD+1024*BASIC_EXTENSION+2048*DEFUSR_EXTENSION
 836  5ED0 EB              EX DE,HL
 837  5ED1 73              LD (HL),E
 838  5ED2 23              INC HL
 839  5ED3 72              LD (HL),D
 840  5ED4 E1              POP HL
 841  5ED5              	; comma
 842  5ED5 CD 80 5E     	CALL CHKCHAR
 843  5ED8 2C           	DB ','
 844  5ED9              	; get address of free memory variable
 845  5ED9 DD 21 A4 5E  	LD IX, PTRGET
 846  5EDD CD 59 01     	CALL CALBAS
 847  5EE0 3A 10 40     	LD A,(FREEMEMPTR)
 848  5EE3 12              LD (DE),A
 849  5EE4 13              INC DE
 850  5EE5 3A 11 40        LD A,(FREEMEMPTR+1)
 851  5EE8 12              LD (DE),A
 852  5EE9              	; ending )
 853  5EE9 CD 80 5E     	CALL CHKCHAR
 854  5EEC 29           	DB ')'
 855  5EED C9           	RET
 856  5EEE              ; *******************************************************************************************************
 857  5EEE
 858  5EEE              EXT_END:
 859  5EEE
# file closed: asm\main.asm
