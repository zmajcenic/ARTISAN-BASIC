# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		   EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000              COLL_CMD       EQU 1
  14  4000
  15  4000              BASIC_EXTENSION   EQU 1
  16  4000              DEFUSR_EXTENSION  EQU 1
  17  4000
  18  4000               DEFINE CMDS_WITH_PARAMETERS
  19  4000
  20  4000              CHPUT   EQU    #A2
  21  4000              CALBAS  EQU		#159
  22  4000              ERRHAND EQU    #406F
  23  4000              FRMEVL  EQU    #4C64
  24  4000              FRESTR  EQU		#67D0
  25  4000              ; FRMQNT = formula quantificator
  26  4000              ; input HL=pointer to current program expression
  27  4000              ; output HL=next address
  28  4000              ; output DE=integer datum
  29  4000              FRMQNT	EQU		#542F
  30  4000              ; GETBYT = get byte parameter
  31  4000              ; input HL=pointer to current program expression
  32  4000              ; output HL=next address
  33  4000              ; output A=E=byte read
  34  4000              GETBYT		EQU	#521C
  35  4000              CHRGTR  	   EQU   #4666
  36  4000              PTRGET		EQU 	#5EA4
  37  4000              SUBFLG		EQU	#F6A5
  38  4000              SYNCHR		EQU	#558C
  39  4000              VALTYP  	   EQU   #F663
  40  4000              DAC         EQU   #F7F6
  41  4000              USR     	   EQU   #F7F8
  42  4000              PROCNM		EQU	#FD89
  43  4000              BIOS_FILVRM EQU   #0056
  44  4000              CLIKSW		EQU	#F3DB
  45  4000
  46  4000              RAMAD0	   EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  47  4000              RAMAD1	   EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  48  4000              RAMAD2	   EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  49  4000              RAMAD3	   EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  50  4000              EXPTBL	   EQU   #FCC1
  51  4000              SCRMOD	   EQU   #FCAF ; current screen mode
  52  4000              REG1SAV     EQU   #F3E0 ; VDP(1)
  53  4000              JIFFY	      EQU   #FC9E
  54  4000              GRPPAT	   EQU   #F3CF ; SCREEN 2 sprite generator table address
  55  4000              GRPCGP		EQU	#F3CB ; SCREEN 2 pattern generator table address
  56  4000              GRPATR      EQU   #F3CD ; SCREEN 2 sprite attribute table address
  57  4000              T32PAT	   EQU   #F3C5 ; SCREEN 1 sprite generator table address
  58  4000              T32CGP      EQU   #F3C1 ; SCREEN 1 pattern ganarator table address
  59  4000              T32ATR      EQU   #F3C3 ; SCREEN 1 sprite attribute table address
  60  4000
  61  4000              ; BASIC error codes
  62  4000              ;01 NEXT without FOR
  63  4000              ;02 Syntax error
  64  4000              ;03 RETURN without GOSUB
  65  4000              ;04 Out of DATA
  66  4000              ;05 Illegal function call
  67  4000              ;06 Overflow
  68  4000              ;07 Out of memory
  69  4000              ;08 Undefined line number
  70  4000              ;09 Subscript out of range
  71  4000              ;10 Redimensioned array
  72  4000              ;11 Division by zero
  73  4000              ;12 Illegal direct
  74  4000              ;13 Type mismatch
  75  4000              ;14 Out of string space
  76  4000              ;15 String too long
  77  4000              ;16 String formula too complex
  78  4000              ;17 Can't CONTINUE
  79  4000              ;18 Undefined user function
  80  4000              ;19 Device I/O error
  81  4000              ;20 Verify error
  82  4000              ;21 No RESUME
  83  4000              ;22 RESUME without error
  84  4000              ;23 Unprintable error
  85  4000              ;24 Missing operand
  86  4000              ;25 Line buffer overflow
  87  4000              ;50 FIELD overflow
  88  4000              ;51 Internal error
  89  4000              ;52 Bad file number
  90  4000              ;53 File not found
  91  4000              ;54 File already open
  92  4000              ;55 Input past end
  93  4000              ;56 Bad file name
  94  4000              ;57 Direct statement in file
  95  4000              ;58 Sequential I/O only
  96  4000              ;59 File not OPEN
  97  4000
  98  4000
  99  4000               ; simulate cartridge with BASIC extension
 100  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
 100  4004 41 69 00 00
 100  4008 00 00 00 00
 100  400C 00 00 00 00
 101  4010
 102  4010              ; this location #4010 stores last location used by basic extension
 103  4010              ; free memory after that point
 104  4010              FREEMEMPTR:
 105  4010 22 6A         DW EXT_END
 106  4012
 107  4012              ; this location #4012 stores extension version in DAA format
 108  4012              ; first byte is major version and second minor
 109  4012              VERSION:
 110  4012 00 81         DB #00, #81
 111  4014
 112  4014              ; this location #4014 contains a jump to entry point for DEFUSR approach
 113  4014              ; if excluded it contains 3xRET so that sound player can be at aspecific spot
 114  4014               IF (DEFUSR_EXTENSION == 1)
 115  4014 C3 52 66        JP DEFUSR_ENTRY
 116  4017               ELSE
 117  4017 ~               .3 RET
 118  4017               ENDIF
 119  4017
 120  4017              ; binary included AKG player compiled at #4017
 121  4017               IF (SOUND_CMDS == 1)
 122  4017              	INCBIN "bin/AKG.bin"
 123  4CF3              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF3              MAIN_PLAYER_START EQU 04017H
   2+ 4CF3              PLY_AKG_START EQU 04017H
   3+ 4CF3              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 04020H
   4+ 4CF3              PLY_AKG_INITSOUNDEFFECTS EQU 04020H
   5+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04024H
   6+ 4CF3              PLY_AKG_PLAYSOUNDEFFECT EQU 04024H
   7+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04025H
   8+ 4CF3              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04025H
   9+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 0404CH
  10+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 0404CH
  11+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 0405AH
  12+ 4CF3              PLY_AKG_PSES_PLAY EQU 04093H
  13+ 4CF3              PLY_AKG_PSES_READFIRSTBYTE EQU 0409CH
  14+ 4CF3              PLY_AKG_PSES_S_ENDORLOOP EQU 040B4H
  15+ 4CF3              PLY_AKG_PSES_S_LOOP EQU 040BFH
  16+ 4CF3              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C5H
  17+ 4CF3              PLY_AKG_PSES_NOTREACHED EQU 040D8H
  18+ 4CF3              PLY_AKG_PSES_HARDWAREONLY EQU 040DCH
  19+ 4CF3              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E3H
  20+ 4CF3              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F5H
  21+ 4CF3              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FFH
  22+ 4CF3              PLY_AKG_PSES_H_AFTERRETRIG EQU 04109H
  23+ 4CF3              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411DH
  24+ 4CF3              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 04122H
  25+ 4CF3              PLY_AKG_PSES_READHARDWAREPERIOD EQU 0412AH
  26+ 4CF3              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04135H
  27+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 04141H
  28+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04143H
  29+ 4CF3              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04149H
  30+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414DH
  31+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414DH
  32+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414FH
  33+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414FH
  34+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414FH
  35+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 04150H
  36+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 04151H
  37+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04155H
  38+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04155H
  39+ 4CF3              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04155H
  40+ 4CF3              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415DH
  41+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04165H
  42+ 4CF3              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04165H
  43+ 4CF3              PLY_AKG_INIT EQU 04165H
  44+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04165H
  45+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04193H
  46+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A7H
  47+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B9H
  48+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D8H
  49+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E5H
  50+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL EQU 041EBH
  51+ 4CF3              PLY_AKG_INITTABLE0 EQU 041EEH
  52+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EEH
  53+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04208H
  54+ 4CF3              PLY_AKG_INITTABLE0_END EQU 04208H
  55+ 4CF3              PLY_AKG_INITTABLE1 EQU 04208H
  56+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04208H
  57+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 0420CH
  58+ 4CF3              PLY_AKG_INITTABLE1_END EQU 0420CH
  59+ 4CF3              PLY_AKG_INITTABLEORA EQU 0420CH
  60+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 0420CH
  61+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04224H
  62+ 4CF3              PLY_AKG_INITTABLEORA_END EQU 04224H
  63+ 4CF3              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04224H
  64+ 4CF3              PLY_AKG_STOP EQU 04224H
  65+ 4CF3              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04236H
  66+ 4CF3              PLY_AKG_PLAY EQU 04236H
  67+ 4CF3              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423EH
  68+ 4CF3              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04244H
  69+ 4CF3              PLY_AKG_READLINKER EQU 04249H
  70+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04249H
  71+ 4CF3              PLY_AKG_READLINKER_PTLINKER EQU 04249H
  72+ 4CF3              PLY_AKG_READLINKER_NOLOOP EQU 04254H
  73+ 4CF3              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428DH
  74+ 4CF3              PLY_AKG_READLINE EQU 04290H
  75+ 4CF3              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 04290H
  76+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04296H
  77+ 4CF3              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04296H
  78+ 4CF3              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A3H
  79+ 4CF3              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A7H
  80+ 4CF3              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042AAH
  81+ 4CF3              PLY_AKG_SPEEDTRACK_END EQU 042ADH
  82+ 4CF3              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042ADH
  83+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B3H
  84+ 4CF3              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B3H
  85+ 4CF3              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042C0H
  86+ 4CF3              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C4H
  87+ 4CF3              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C7H
  88+ 4CF3              PLY_AKG_EVENTTRACK_END EQU 042CAH
  89+ 4CF3              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042CAH
  90+ 4CF3              PLY_AKG_CHANNEL1_READTRACK EQU 042D6H
  91+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D6H
  92+ 4CF3              PLY_AKG_CHANNEL1_PTTRACK EQU 042D6H
  93+ 4CF3              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042F1H
  94+ 4CF3              PLY_AKG_CHANNEL1_WAIT EQU 042FCH
  95+ 4CF3              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04303H
  96+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04303H
  97+ 4CF3              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04303H
  98+ 4CF3              PLY_AKG_CHANNEL1_NOTE EQU 0430CH
  99+ 4CF3              PLY_AKG_BASENOTEINDEX EQU 0430CH
 100+ 4CF3              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430EH
 101+ 4CF3              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430EH
 102+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431EH
 103+ 4CF3              PLY_AKG_INSTRUMENTSTABLE EQU 0431EH
 104+ 4CF3              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 04330H
 105+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 04340H
 106+ 4CF3              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04368H
 107+ 4CF3              PLY_AKG_CHANNEL1_READCELLEND EQU 0436BH
 108+ 4CF3              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 0436BH
 109+ 4CF3              PLY_AKG_CHANNEL2_READTRACK EQU 04377H
 110+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04377H
 111+ 4CF3              PLY_AKG_CHANNEL2_PTTRACK EQU 04377H
 112+ 4CF3              PLY_AKG_CHANNEL2_SMALLWAIT EQU 04392H
 113+ 4CF3              PLY_AKG_CHANNEL2_WAIT EQU 0439DH
 114+ 4CF3              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A4H
 115+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A4H
 116+ 4CF3              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A4H
 117+ 4CF3              PLY_AKG_CHANNEL2_NOTE EQU 043ADH
 118+ 4CF3              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043B2H
 119+ 4CF3              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043B2H
 120+ 4CF3              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D4H
 121+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E4H
 122+ 4CF3              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 0440CH
 123+ 4CF3              PLY_AKG_CHANNEL2_READCELLEND EQU 0440FH
 124+ 4CF3              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440FH
 125+ 4CF3              PLY_AKG_CHANNEL3_READTRACK EQU 0441BH
 126+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 0441BH
 127+ 4CF3              PLY_AKG_CHANNEL3_PTTRACK EQU 0441BH
 128+ 4CF3              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04436H
 129+ 4CF3              PLY_AKG_CHANNEL3_WAIT EQU 04441H
 130+ 4CF3              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04448H
 131+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04448H
 132+ 4CF3              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04448H
 133+ 4CF3              PLY_AKG_CHANNEL3_NOTE EQU 04451H
 134+ 4CF3              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04456H
 135+ 4CF3              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04456H
 136+ 4CF3              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04478H
 137+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04488H
 138+ 4CF3              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044B0H
 139+ 4CF3              PLY_AKG_CHANNEL3_READCELLEND EQU 044B3H
 140+ 4CF3              PLY_AKG_CURRENTSPEED EQU 044B3H
 141+ 4CF3              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B5H
 142+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B8H
 143+ 4CF3              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B8H
 144+ 4CF3              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044BBH
 145+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BEH
 146+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BEH
 147+ 4CF3              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044CAH
 148+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044D1H
 149+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D4H
 150+ 4CF3              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044DAH
 151+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DDH
 152+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DDH
 153+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044EBH
 154+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044F0H
 155+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044FBH
 156+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FEH
 157+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FEH
 158+ 4CF3              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 04501H
 159+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04504H
 160+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04504H
 161+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450DH
 162+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04517H
 163+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 0451AH
 164+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 0451AH
 165+ 4CF3              PLY_AKG_CHANNEL1_PITCH EQU 0451AH
 166+ 4CF3              PLY_AKG_CHANNEL1_ISPITCH EQU 0451DH
 167+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 04522H
 168+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACK EQU 04522H
 169+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04526H
 170+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04528H
 171+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 0452AH
 172+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 04531H
 173+ 4CF3              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 04532H
 174+ 4CF3              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04535H
 175+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04535H
 176+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 04551H
 177+ 4CF3              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 04551H
 178+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455EH
 179+ 4CF3              PLY_AKG_CHANNEL1_GLIDEOVER EQU 04562H
 180+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 04572H
 181+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 04572H
 182+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04573H
 183+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04574H
 184+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04576H
 185+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04576H
 186+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04576H
 187+ 4CF3              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04577H
 188+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04578H
 189+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 0457AH
 190+ 4CF3              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 0457AH
 191+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 0457AH
 192+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 0457AH
 193+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 0457AH
 194+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457DH
 195+ 4CF3              PLY_AKG_CHANNEL1_PITCH_END EQU 0457FH
 196+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04587H
 197+ 4CF3              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04587H
 198+ 4CF3              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 0458AH
 199+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458DH
 200+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458DH
 201+ 4CF3              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04599H
 202+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 045A0H
 203+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A3H
 204+ 4CF3              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A9H
 205+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045ACH
 206+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045ACH
 207+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045BAH
 208+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BFH
 209+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045CAH
 210+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CDH
 211+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CDH
 212+ 4CF3              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045D0H
 213+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D3H
 214+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D3H
 215+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045DCH
 216+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E6H
 217+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E9H
 218+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E9H
 219+ 4CF3              PLY_AKG_CHANNEL2_PITCH EQU 045E9H
 220+ 4CF3              PLY_AKG_CHANNEL2_ISPITCH EQU 045ECH
 221+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045F1H
 222+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045F1H
 223+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F5H
 224+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F7H
 225+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F9H
 226+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 04600H
 227+ 4CF3              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 04601H
 228+ 4CF3              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04604H
 229+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04604H
 230+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 04620H
 231+ 4CF3              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 04620H
 232+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462DH
 233+ 4CF3              PLY_AKG_CHANNEL2_GLIDEOVER EQU 04631H
 234+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 04641H
 235+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 04641H
 236+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 04642H
 237+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04643H
 238+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04645H
 239+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04645H
 240+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04645H
 241+ 4CF3              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04646H
 242+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04647H
 243+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04649H
 244+ 4CF3              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04649H
 245+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04649H
 246+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04649H
 247+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04649H
 248+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_END EQU 0464CH
 249+ 4CF3              PLY_AKG_CHANNEL2_PITCH_END EQU 0464EH
 250+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04656H
 251+ 4CF3              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04656H
 252+ 4CF3              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04659H
 253+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 0465CH
 254+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 0465CH
 255+ 4CF3              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04668H
 256+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466FH
 257+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 04672H
 258+ 4CF3              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04678H
 259+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 0467BH
 260+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 0467BH
 261+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04689H
 262+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468EH
 263+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04699H
 264+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 0469CH
 265+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 0469CH
 266+ 4CF3              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469FH
 267+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 046A2H
 268+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE EQU 046A2H
 269+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046ABH
 270+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B5H
 271+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B8H
 272+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B8H
 273+ 4CF3              PLY_AKG_CHANNEL3_PITCH EQU 046B8H
 274+ 4CF3              PLY_AKG_CHANNEL3_ISPITCH EQU 046BBH
 275+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046C0H
 276+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046C0H
 277+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C4H
 278+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C6H
 279+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C8H
 280+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CFH
 281+ 4CF3              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046D0H
 282+ 4CF3              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D3H
 283+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D3H
 284+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046EFH
 285+ 4CF3              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046EFH
 286+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046FCH
 287+ 4CF3              PLY_AKG_CHANNEL3_GLIDEOVER EQU 04700H
 288+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 04710H
 289+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 04710H
 290+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 04711H
 291+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 04712H
 292+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04714H
 293+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04714H
 294+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04714H
 295+ 4CF3              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04715H
 296+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04716H
 297+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04718H
 298+ 4CF3              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04718H
 299+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04718H
 300+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04718H
 301+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04718H
 302+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_END EQU 0471BH
 303+ 4CF3              PLY_AKG_CHANNEL3_PITCH_END EQU 0471DH
 304+ 4CF3              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04729H
 305+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04729H
 306+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04729H
 307+ 4CF3              PLY_AKG_CHANNEL1_TRACKNOTE EQU 0472CH
 308+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472EH
 309+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04734H
 310+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04737H
 311+ 4CF3              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04737H
 312+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 0473AH
 313+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04743H
 314+ 4CF3              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 0474BH
 315+ 4CF3              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04758H
 316+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04758H
 317+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04758H
 318+ 4CF3              PLY_AKG_CHANNEL2_TRACKNOTE EQU 0475BH
 319+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475DH
 320+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04763H
 321+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04766H
 322+ 4CF3              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04766H
 323+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04769H
 324+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 04772H
 325+ 4CF3              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 0477AH
 326+ 4CF3              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04788H
 327+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04788H
 328+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04788H
 329+ 4CF3              PLY_AKG_CHANNEL3_TRACKNOTE EQU 0478BH
 330+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478DH
 331+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04793H
 332+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04796H
 333+ 4CF3              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04796H
 334+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04799H
 335+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 047A2H
 336+ 4CF3              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047AAH
 337+ 4CF3              PLY_AKG_SENDPSGREGISTERS EQU 047B9H
 338+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047C1H
 339+ 4CF3              PLY_AKG_PSGREG01_INSTR EQU 047C1H
 340+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047D1H
 341+ 4CF3              PLY_AKG_PSGREG23_INSTR EQU 047D1H
 342+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047E2H
 343+ 4CF3              PLY_AKG_PSGREG45_INSTR EQU 047E2H
 344+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F3H
 345+ 4CF3              PLY_AKG_PSGREG6_8_INSTR EQU 047F3H
 346+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04804H
 347+ 4CF3              PLY_AKG_PSGREG9_10_INSTR EQU 04804H
 348+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04815H
 349+ 4CF3              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04815H
 350+ 4CF3              PLY_AKG_PSGREG13_OLDVALUE EQU 0482AH
 351+ 4CF3              PLY_AKG_RETRIG EQU 0482CH
 352+ 4CF3              PLY_AKG_PSGREG13_INSTR EQU 0482EH
 353+ 4CF3              PLY_AKG_PSGREG13_END EQU 0483DH
 354+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483DH
 355+ 4CF3              PLY_AKG_SAVESP EQU 0483DH
 356+ 4CF3              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 04841H
 357+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTS EQU 04849H
 358+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04856H
 359+ 4CF3              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04856H
 360+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485EH
 361+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 0486BH
 362+ 4CF3              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 0486BH
 363+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTS EQU 04873H
 364+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487EH
 365+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS EQU 0487EH
 366+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488DH
 367+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488DH
 368+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04894H
 369+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A4H
 370+ 4CF3              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A4H
 371+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048ABH
 372+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048ABH
 373+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048AEH
 374+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B7H
 375+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B7H
 376+ 4CF3              PLY_AKG_READINSTRUMENTCELL EQU 048BDH
 377+ 4CF3              PLY_AKG_NOSOFTNOHARD EQU 048CAH
 378+ 4CF3              PLY_AKG_NSNH_NONOISE EQU 048DFH
 379+ 4CF3              PLY_AKG_SOFT EQU 048E2H
 380+ 4CF3              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E9H
 381+ 4CF3              PLY_AKG_S_NOTSIMPLE EQU 048F1H
 382+ 4CF3              PLY_AKG_S_AFTERSIMPLETEST EQU 048F4H
 383+ 4CF3              PLY_AKG_HARDTOSOFT EQU 04901H
 384+ 4CF3              PLY_AKG_HS_JUMPRATIO EQU 0490CH
 385+ 4CF3              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04939H
 386+ 4CF3              PLY_AKG_ENDWITHOUTLOOP EQU 0493BH
 387+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 0493BH
 388+ 4CF3              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 0493BH
 389+ 4CF3              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04943H
 390+ 4CF3              PLY_AKG_SH_JUMPRATIO EQU 04950H
 391+ 4CF3              PLY_AKG_SH_JUMPRATIOEND EQU 04971H
 392+ 4CF3              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 04980H
 393+ 4CF3              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04986H
 394+ 4CF3              PLY_AKG_H_OR_ENDWITHLOOP EQU 049A0H
 395+ 4CF3              PLY_AKG_H_RETRIGEND EQU 049B2H
 396+ 4CF3              PLY_AKG_H_AFTERRETRIG EQU 049B3H
 397+ 4CF3              PLY_AKG_ENDWITHLOOP EQU 049C5H
 398+ 4CF3              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049CCH
 399+ 4CF3              PLY_AKG_S_OR_H_NEXTBYTE EQU 049E2H
 400+ 4CF3              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049F0H
 401+ 4CF3              PLY_AKG_S_OR_H_AFTERPITCH EQU 04A00H
 402+ 4CF3              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0EH
 403+ 4CF3              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1DH
 404+ 4CF3              PLY_AKG_SHOHS_RETRIGEND EQU 04A2CH
 405+ 4CF3              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2DH
 406+ 4CF3              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3FH
 407+ 4CF3              PLY_AKG_EFFECTTABLE EQU 04A4DH
 408+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4DH
 409+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A71H
 410+ 4CF3              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A71H
 411+ 4CF3              PLY_AKG_EFFECT_RESET EQU 04A74H
 412+ 4CF3              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A76H
 413+ 4CF3              PLY_AKG_EFFECT_VOLUME EQU 04A91H
 414+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9DH
 415+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA3H
 416+ 4CF3              PLY_AKG_ARPEGGIOSTABLE EQU 04AA3H
 417+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04ACAH
 418+ 4CF3              PLY_AKG_EFFECT_PITCHTABLE EQU 04AD1H
 419+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD7H
 420+ 4CF3              PLY_AKG_PITCHESTABLE EQU 04AD7H
 421+ 4CF3              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFEH
 422+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B05H
 423+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B16H
 424+ 4CF3              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1DH
 425+ 4CF3              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2DH
 426+ 4CF3              PLY_AKG_EFFECT_PITCHUP EQU 04B42H
 427+ 4CF3              PLY_AKG_EFFECT_PITCHSTOP EQU 04B54H
 428+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B5BH
 429+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B85H
 430+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B85H
 431+ 4CF3              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9EH
 432+ 4CF3              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9EH
 433+ 4CF3              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BB0H
 434+ 4CF3              PLY_AKG_EFFECT_LEGATO EQU 04BC6H
 435+ 4CF3              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BDAH
 436+ 4CF3              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BE2H
 437+ 4CF3              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BEAH
 438+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BF2H
 439+ 4CF3              PLY_AKG_EVENT EQU 04BF2H
 440+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF3H
 441+ 4CF3              PLY_AKG_PERIODTABLE EQU 04BF3H
 442+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF3H
 443+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF3H
 444+ 4CF3              PLY_AKG_PERIODTABLE_END EQU 04CF3H
 445+ 4CF3              PLY_AKG_END EQU 04CF3H
 446+ 4CF3              MAIN_PLAYER_END EQU 04CF3H
 447+ 4CF3              TESTEREND EQU 04CF3H
 448+ 4CF3
# file closed: ./symbol/AKG.sym
 124  4CF3               ENDIF
 125  4CF3
 126  4CF3               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
   1+ 4CF3              ORIG.HTIMI:
   2+ 4CF3 00 00 00 00  	DB 0, 0, 0, 0, 0
   2+ 4CF7 00
   3+ 4CF8               EXPORT ORIG.HTIMI
   4+ 4CF8
   5+ 4CF8              ; *******************************************************************************************************
   6+ 4CF8              ; interrupt handler when page 0 enabled
   7+ 4CF8              ; we are here only if one of the extended basic commands have paged in page 0
   8+ 4CF8              ; which means we arrived from BASIC so page 2 is already good
   9+ 4CF8              VBLANK:
  10+ 4CF8              	EXPORT VBLANK
  11+ 4CF8
  12+ 4CF8 F5               PUSH AF
  13+ 4CF9              	; is VDP originator ?
  14+ 4CF9 DB 99        	IN	A, (099H)
  15+ 4CFB A7           	AND	A
  16+ 4CFC F2 23 4D     	JP P, .EXIT
  17+ 4CFF
  18+ 4CFF               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  19+ 4CFF C5               PUSH BC
  20+ 4D00 D5               PUSH DE
  21+ 4D01 E5               PUSH HL
  22+ 4D02 08               EX AF, AF'
  23+ 4D03 D9               EXX
  24+ 4D04 F5               PUSH AF
  25+ 4D05 C5               PUSH BC
  26+ 4D06 D5               PUSH DE
  27+ 4D07 E5               PUSH HL
  28+ 4D08 DD E5            PUSH IX
  29+ 4D0A FD E5            PUSH IY
  30+ 4D0C
  31+ 4D0C               IF (SPRITE_CMDS == 1)
  32+ 4D0C CD 5D 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  33+ 4D0F               ENDIF
  34+ 4D0F
  35+ 4D0F               IF (SOUND_CMDS == 1)
  36+ 4D0F 3A 67 5B     	LD A, (SOUND_ENABLED)
  37+ 4D12 B7           	OR A
  38+ 4D13 C4 36 42     	CALL NZ,PLY_AKG_PLAY
  39+ 4D16               ENDIF
  40+ 4D16
  41+ 4D16                  ; increase JIFFY
  42+ 4D16                  ;LD HL,(JIFFY)
  43+ 4D16                  ;INC HL
  44+ 4D16                  ;LD (JIFFY),HL
  45+ 4D16
  46+ 4D16 FD E1            POP IY
  47+ 4D18 DD E1            POP IX
  48+ 4D1A E1               POP HL
  49+ 4D1B D1               POP DE
  50+ 4D1C C1               POP BC
  51+ 4D1D F1               POP AF
  52+ 4D1E 08               EX AF, AF'
  53+ 4D1F D9               EXX
  54+ 4D20 E1               POP HL
  55+ 4D21 D1               POP DE
  56+ 4D22 C1               POP BC
  57+ 4D23               ENDIF
  58+ 4D23
  59+ 4D23              .EXIT:
  60+ 4D23 F1           	POP AF
  61+ 4D24 FB           	EI
  62+ 4D25 ED 4D        	RETI
  63+ 4D27              ; *******************************************************************************************************
  64+ 4D27
  65+ 4D27              ; *******************************************************************************************************
  66+ 4D27              ; H.TIMI function
  67+ 4D27              ; we can end up here from anywhere so page in both page 0 and 2
  68+ 4D27              MBGE_HTIMI:
  69+ 4D27               EXPORT MBGE_HTIMI
  70+ 4D27
  71+ 4D27               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  72+ 4D27
  73+ 4D27 F5           	PUSH AF
  74+ 4D28
  75+ 4D28              	; enable page 2
  76+ 4D28 3E 02            LD A, 2
  77+ 4D2A CD 71 68         CALL GET_PAGE_INFO
  78+ 4D2D C5               PUSH BC
  79+ 4D2E D5               PUSH DE
  80+ 4D2F 3A 43 F3         LD A, (RAMAD2)
  81+ 4D32 26 80            LD H, 080H
  82+ 4D34 CD B8 68         CALL LOCAL_ENASLT
  83+ 4D37              	; enable page 0
  84+ 4D37 AF               XOR A
  85+ 4D38 CD 71 68         CALL GET_PAGE_INFO
  86+ 4D3B C5               PUSH BC
  87+ 4D3C D5               PUSH DE
  88+ 4D3D 3A 41 F3         LD A, (RAMAD0)
  89+ 4D40 26 00            LD H, 0
  90+ 4D42 CD B8 68         CALL LOCAL_ENASLT
  91+ 4D45
  92+ 4D45               IF (SPRITE_CMDS == 1)
  93+ 4D45 CD 5D 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  94+ 4D48               ENDIF
  95+ 4D48
  96+ 4D48               IF (SOUND_CMDS == 1)
  97+ 4D48 3A 67 5B     	LD A, (SOUND_ENABLED)
  98+ 4D4B B7           	OR A
  99+ 4D4C C4 36 42     	CALL NZ,PLY_AKG_PLAY
 100+ 4D4F               ENDIF
 101+ 4D4F
 102+ 4D4F              	; restore page 0
 103+ 4D4F D1               POP DE
 104+ 4D50 C1               POP BC
 105+ 4D51 CD A8 68         CALL RESTORE_PAGE_INFO
 106+ 4D54              	; restore page 2
 107+ 4D54 D1               POP DE
 108+ 4D55 C1               POP BC
 109+ 4D56 CD A8 68         CALL RESTORE_PAGE_INFO
 110+ 4D59
 111+ 4D59 F1           	POP AF
 112+ 4D5A               ENDIF
 113+ 4D5A C3 F3 4C     	JP ORIG.HTIMI
 114+ 4D5D              ; *******************************************************************************************************
 115+ 4D5D
 116+ 4D5D              ; *******************************************************************************************************
 117+ 4D5D              ; function checks if the sprite system is initialized and what screen mode we are running
 118+ 4D5D              ; also checks if some VRAM modifying command is running
 119+ 4D5D              ; when that checks out calls sprite updates and animation processing
 120+ 4D5D              ; if in an unsupported mode disables sprite handling
 121+ 4D5D              PROCESS_SPRITES_AND_ANIMATIONS:
 122+ 4D5D              	; check if initialized
 123+ 4D5D 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
 124+ 4D60 B7           	OR A
 125+ 4D61 C8           	RET Z
 126+ 4D62              	; check screen mode
 127+ 4D62 3A AF FC     	LD A, (SCRMOD)
 128+ 4D65 3D           	DEC A
 129+ 4D66 28 08        	JR Z, .L0 ; screen 1
 130+ 4D68 3D           	DEC A
 131+ 4D69 28 05            JR Z, .L0 ; screen 2
 132+ 4D6B              	; unsupported screen mode, disable
 133+ 4D6B AF               XOR A
 134+ 4D6C 32 7F 4D         LD (SPRATR_INIT_STATUS),A
 135+ 4D6F C9               RET
 136+ 4D70              .L0:
 137+ 4D70                  ; check if anyone else is working with VRAM
 138+ 4D70 3A 81 66         LD A,(VRAM_UPDATE_IN_PROGRESS)
 139+ 4D73 B7               OR A
 140+ 4D74 C0               RET NZ
 141+ 4D75
 142+ 4D75 CD 95 4D         CALL SPRATR_UPDATE
 143+ 4D78
 144+ 4D78               IF (ANIM_CMDS == 1)
 145+ 4D78 CD B6 57         CALL PROCESS_ANIMATIONS
 146+ 4D7B CD BA 59         CALL PROCESS_AUTOSGAMS
 147+ 4D7E               ENDIF
 148+ 4D7E C9               RET
 149+ 4D7F              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
 127  4D7F
 128  4D7F               IF (SPRITE_CMDS == 1)
 129  4D7F               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4D7F              ; commands and variables related to sprites
   2+ 4D7F
   3+ 4D7F              SPRATR_INIT_STATUS:
   4+ 4D7F 00            DB 0
   5+ 4D80              SPRATR_UPDATE_FLAG:
   6+ 4D80 00 00         DW 0
   7+ 4D82              SPRATR_DATA:
   8+ 4D82 00 00         DW 0
   9+ 4D84              SPRFLICKER_ENABLED:
  10+ 4D84 00            DB 0
  11+ 4D85              ; to support sprite flicker
  12+ 4D85              FLICKER:
  13+ 4D85 00            DB 0
  14+ 4D86              NUM_SPRITES_HANDLED:
  15+ 4D86 20            DB 32
  16+ 4D87
  17+ 4D87              ; to temporarily store stack pointer
  18+ 4D87              TMPSP:
  19+ 4D87 00 00         DW 0
  20+ 4D89
  21+ 4D89              ; *******************************************************************************************************
  22+ 4D89              ; helper function gets pointer to n-th entry in sprite attributes
  23+ 4D89              ; changes HL,DE
  24+ 4D89              GETnthSPRATTR:
  25+ 4D89 26 00            LD H,0
  26+ 4D8B 6F               LD L,A
  27+ 4D8C CD 6D 68         CALL HLx8
  28+ 4D8F ED 5B 82 4D      LD DE,(SPRATR_DATA)
  29+ 4D93 19               ADD HL,DE
  30+ 4D94 C9               RET
  31+ 4D95              ; *******************************************************************************************************
  32+ 4D95
  33+ 4D95              ; *******************************************************************************************************
  34+ 4D95              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  35+ 4D95              ; struct {
  36+ 4D95              ; DW y
  37+ 4D95              ; DW x
  38+ 4D95              ; DW pattern (0-63)
  39+ 4D95              ; DW color
  40+ 4D95              ; } [32]
  41+ 4D95              ; will hide sprites whose location is outside of visible area
  42+ 4D95              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  43+ 4D95              ; modifies AF, AF', BC, DE, HL, IX
  44+ 4D95              SPRATR_UPDATE:
  45+ 4D95              	; check if update requested
  46+ 4D95 2A 80 4D     	LD HL, (SPRATR_UPDATE_FLAG)
  47+ 4D98 7E           	LD A, (HL)
  48+ 4D99 B7           	OR A
  49+ 4D9A C8           	RET Z
  50+ 4D9B
  51+ 4D9B DD 21 86 4D  	LD IX,NUM_SPRITES_HANDLED
  52+ 4D9F DD 46 00     	LD B, (IX) ; sprite number
  53+ 4DA2 0E 98        	LD C, #98 ; register for vdp data output
  54+ 4DA4              	; set VDP address
  55+ 4DA4 3A AF FC         LD A,(SCRMOD)
  56+ 4DA7 3D               DEC A
  57+ 4DA8 20 05            JR NZ,.L4
  58+ 4DAA 2A C3 F3         LD HL, (T32ATR)
  59+ 4DAD 18 03            JR .L5
  60+ 4DAF              .L4:
  61+ 4DAF 2A CD F3         LD HL, (GRPATR)
  62+ 4DB2              .L5:
  63+ 4DB2 3A 84 4D     	LD A, (SPRFLICKER_ENABLED)
  64+ 4DB5 B7           	OR A
  65+ 4DB6 28 03        	JR Z, .L3
  66+ 4DB8 3A 85 4D     	LD A, (FLICKER)
  67+ 4DBB              .L3:
  68+ 4DBB 5F           	LD E, A
  69+ 4DBC 08           	EX AF, AF'
  70+ 4DBD 7B           	LD A, E
  71+ 4DBE 87           	ADD A, A
  72+ 4DBF 87           	ADD A, A
  73+ 4DC0 16 00        	LD D, 0
  74+ 4DC2 5F           	LD E, A
  75+ 4DC3 19           	ADD HL, DE
  76+ 4DC4 CD 58 68     	CALL SETWRT_LOCAL
  77+ 4DC7 ED 73 87 4D  	LD (TMPSP), SP
  78+ 4DCB ED 7B 82 4D  	LD SP, (SPRATR_DATA)
  79+ 4DCF
  80+ 4DCF              .LOOP:
  81+ 4DCF E1           	POP HL
  82+ 4DD0 24           	INC H
  83+ 4DD1 28 0D        	JR Z, .L1 ; negative number between -256 and -1
  84+ 4DD3 25           	DEC H
  85+ 4DD4 20 15        	JR NZ, .OUT3 ; sprite vertically can't be visible
  86+ 4DD6 7D           	LD A, L
  87+ 4DD7 FE C0        	CP 192
  88+ 4DD9 30 10        	JR NC, .OUT3
  89+ 4DDB 3D           	DEC A ; due to VDP rule that top of screen is -1
  90+ 4DDC 57           	LD D, A
  91+ 4DDD C3 04 4E     	JP .X
  92+ 4DE0              .L1:
  93+ 4DE0 7D           	LD A, L
  94+ 4DE1 C6 10        	ADD 16
  95+ 4DE3 FA EB 4D     	JP M, .OUT3 ; below -16
  96+ 4DE6 2D           	DEC L ; due to VDP rule that top of screen is -1
  97+ 4DE7 55           	LD D, L
  98+ 4DE8 C3 04 4E     	JP .X
  99+ 4DEB              .OUT3:
 100+ 4DEB E1           	POP HL ; skip x value
 101+ 4DEC              .OUT2:
 102+ 4DEC E1           	POP HL ; skip pattern
 103+ 4DED E1           	POP HL ; skip color
 104+ 4DEE 3E D1        	LD A, #D1
 105+ 4DF0 ED 79        	OUT (C), A ; sprite hidden
 106+ 4DF2 00          > NOP
 106+ 4DF3 00          > NOP
 106+ 4DF4 00          > NOP
 107+ 4DF5 ED 79        	OUT (C), A ; value unimportant
 108+ 4DF7 00          > NOP
 108+ 4DF8 00          > NOP
 108+ 4DF9 00          > NOP
 109+ 4DFA ED 79        	OUT (C), A ; value unimportant
 110+ 4DFC 00          > NOP
 110+ 4DFD 00          > NOP
 110+ 4DFE 00          > NOP
 111+ 4DFF ED 79        	OUT (C), A ; value unimportant
 112+ 4E01 C3 2F 4E     	JP .NEXT
 113+ 4E04              .X:
 114+ 4E04 E1           	POP HL
 115+ 4E05 24           	INC H
 116+ 4E06 28 08        	JR Z, .L2
 117+ 4E08 25           	DEC H
 118+ 4E09 20 E1        	JR NZ, .OUT2
 119+ 4E0B 1E 00        	LD E, 0 ; EC bit
 120+ 4E0D C3 19 4E     	JP .XY
 121+ 4E10              .L2:
 122+ 4E10 7D           	LD A, L
 123+ 4E11 C6 20        	ADD 32
 124+ 4E13 FA EC 4D     	JP M, .OUT2
 125+ 4E16 6F           	LD L, A
 126+ 4E17 1E 80        	LD E, #80
 127+ 4E19              .XY:
 128+ 4E19 ED 51        	OUT (C), D
 129+ 4E1B 3A E0 F3     	LD A, (REG1SAV)
 130+ 4E1E E6 02        	AND 2
 131+ 4E20 ED 69        	OUT (C), L
 132+ 4E22 E1           	POP HL ; pattern
 133+ 4E23 7D           	LD A, L
 134+ 4E24 28 02        	JR Z, .SMALLSPRITES
 135+ 4E26 87           	ADD A, A
 136+ 4E27 87           	ADD A, A ; needs to go at 4x
 137+ 4E28              .SMALLSPRITES:
 138+ 4E28 D3 98        	OUT (#98), A
 139+ 4E2A E1           	POP HL ; color
 140+ 4E2B 7D           	LD A, L
 141+ 4E2C B3           	OR E
 142+ 4E2D D3 98        	OUT (#98), A
 143+ 4E2F              .NEXT:
 144+ 4E2F 08           	EX AF, AF'
 145+ 4E30 3C           	INC A ; increase current sprite
 146+ 4E31 DD BE 00     	CP (IX) ; compare to maximum handled
 147+ 4E34 C2 54 4E     	JP NZ, .NEXT2 ; continue if not over
 148+ 4E37 AF           	XOR A ; back to zero
 149+ 4E38 08           	EX AF, AF'
 150+ 4E39 3A AF FC         LD A,(SCRMOD)
 151+ 4E3C 3D               DEC A
 152+ 4E3D 20 05            JR NZ,.L6
 153+ 4E3F 2A C3 F3         LD HL, (T32ATR)
 154+ 4E42 18 03            JR .L7
 155+ 4E44              .L6:
 156+ 4E44 2A CD F3         LD HL, (GRPATR)
 157+ 4E47              .L7:
 158+ 4E47              	; CALL SETWRT_LOCAL not allowed as SP modified
 159+ 4E47 7D           	LD	A, L
 160+ 4E48 D3 99        	OUT	(099H), A
 161+ 4E4A 7C           	LD	A, H
 162+ 4E4B E6 3F        	AND	03FH
 163+ 4E4D F6 40        	OR	040H
 164+ 4E4F D3 99        	OUT	(099H), A
 165+ 4E51 C3 55 4E     	JP .NEXT3
 166+ 4E54              .NEXT2:
 167+ 4E54 08           	EX AF, AF'
 168+ 4E55              .NEXT3:
 169+ 4E55 05           	DEC B
 170+ 4E56 C2 CF 4D     	JP NZ, .LOOP
 171+ 4E59 08           	EX AF, AF'
 172+ 4E5A 3C           	INC A ; increase flicker to start at the next one on next vblank
 173+ 4E5B DD BE 00     	CP (IX)
 174+ 4E5E 20 01        	JR NZ,.L8
 175+ 4E60 AF           	XOR A
 176+ 4E61              .L8:
 177+ 4E61 32 85 4D     	LD (FLICKER), A
 178+ 4E64
 179+ 4E64 ED 7B 87 4D  	LD SP, (TMPSP)
 180+ 4E68 2A 80 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 181+ 4E6B 36 00        	LD (HL), 0 ; zero out update flag
 182+ 4E6D C9           	RET
 183+ 4E6E              ; *******************************************************************************************************
 184+ 4E6E
 185+ 4E6E               IF (BASIC_EXTENSION == 1)
 186+ 4E6E              ; *******************************************************************************************************
 187+ 4E6E              ; function to handle CALL SPRENABLE basic extension
 188+ 4E6E              ; initializes sprites handler
 189+ 4E6E              ; _SPRENABLE ( INT[3][31] variable sprites_attributes,
 190+ 4E6E              ;			   INT variable update_variable,
 191+ 4E6E              ;			   BYTE sprite_flicker_enabled,
 192+ 4E6E              ;			   BYTE num_sprites_handled )
 193+ 4E6E              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA, SPRFLICKER_ENABLED and NUM_SPRITES_HANDLED
 194+ 4E6E              SPRENABLE:
 195+ 4E6E              	; opening (
 196+ 4E6E CD 7F 69     	CALL CHKCHAR
 197+ 4E71 28           	DB '('
 198+ 4E72              	; get address of sprite attribute table DIM SA%(3,31)
 199+ 4E72 3E 02        	LD A,2
 200+ 4E74 06 02        	LD B,2
 201+ 4E76 11 20 04     	LD DE,#0420
 202+ 4E79 CD AC 69     	CALL GET_BASIC_ARRAY_DATA_POINTER
 203+ 4E7C ED 43 82 4D  	LD (SPRATR_DATA), BC
 204+ 4E80              	; comma
 205+ 4E80 CD 7F 69     	CALL CHKCHAR
 206+ 4E83 2C           	DB ','
 207+ 4E84              	; get address of sprite update flag
 208+ 4E84 DD 21 A4 5E  	LD IX, PTRGET
 209+ 4E88 CD 59 01     	CALL CALBAS
 210+ 4E8B ED 53 80 4D  	LD (SPRATR_UPDATE_FLAG), DE
 211+ 4E8F              	; comma
 212+ 4E8F CD 7F 69     	CALL CHKCHAR
 213+ 4E92 2C           	DB ','
 214+ 4E93              	; get flicker enabled flag
 215+ 4E93 DD 21 1C 52  	LD IX, GETBYT
 216+ 4E97 CD 59 01     	CALL CALBAS
 217+ 4E9A 32 84 4D     	LD (SPRFLICKER_ENABLED), A
 218+ 4E9D              	; comma
 219+ 4E9D CD 7F 69     	CALL CHKCHAR
 220+ 4EA0 2C           	DB ','
 221+ 4EA1              	; get number of handled sprites
 222+ 4EA1 DD 21 1C 52  	LD IX, GETBYT
 223+ 4EA5 CD 59 01     	CALL CALBAS
 224+ 4EA8 32 86 4D     	LD (NUM_SPRITES_HANDLED),A
 225+ 4EAB              	; ending )
 226+ 4EAB CD 7F 69     	CALL CHKCHAR
 227+ 4EAE 29           	DB ')'
 228+ 4EAF              .L0:
 229+ 4EAF 3E 01        	LD A, 1
 230+ 4EB1 32 7F 4D     	LD (SPRATR_INIT_STATUS), A
 231+ 4EB4 C9           	RET
 232+ 4EB5              ; *******************************************************************************************************
 233+ 4EB5               ENDIF
 234+ 4EB5
 235+ 4EB5               IF (DEFUSR_EXTENSION == 1)
 236+ 4EB5              ; same as SPRENABLE but for DEFUSR approach
 237+ 4EB5              ; input IX=pointer to input array, real data from +2
 238+ 4EB5              ; +2 = pointer to sprite attributes array data
 239+ 4EB5              ; +4 = pointer to sprite update variable
 240+ 4EB5              ; +6 = flicker flag
 241+ 4EB5              ; +8 = number of sprites to handle
 242+ 4EB5              SPRENABLE_DEFUSR:
 243+ 4EB5 DD 6E 02     	LD L,(IX+2)
 244+ 4EB8 DD 66 03     	LD H,(IX+3)
 245+ 4EBB 22 82 4D     	LD (SPRATR_DATA),HL
 246+ 4EBE DD 6E 04     	LD L,(IX+4)
 247+ 4EC1 DD 66 05     	LD H,(IX+5)
 248+ 4EC4 22 80 4D     	LD (SPRATR_UPDATE_FLAG),HL
 249+ 4EC7 DD 7E 06     	LD A,(IX+6)
 250+ 4ECA 32 84 4D     	LD (SPRFLICKER_ENABLED),A
 251+ 4ECD DD 7E 08     	LD A,(IX+8)
 252+ 4ED0 32 86 4D     	LD (NUM_SPRITES_HANDLED),A
 253+ 4ED3               IF (BASIC_EXTENSION == 1)
 254+ 4ED3 18 DA        	JR SPRENABLE.L0
 255+ 4ED5               ELSE
 256+ 4ED5 ~            	LD A, 1
 257+ 4ED5 ~            	LD (SPRATR_INIT_STATUS), A
 258+ 4ED5 ~            	RET
 259+ 4ED5               ENDIF
 260+ 4ED5               ENDIF
 261+ 4ED5
 262+ 4ED5               IF (DEFUSR_EXTENSION + BASIC_EXTENSION > 0)
 263+ 4ED5              ; *******************************************************************************************************
 264+ 4ED5              ; function to handle CALL SPRDISABLE basic extension
 265+ 4ED5              ; disables sprites handling
 266+ 4ED5              ; _SPRDISABLE
 267+ 4ED5              ; resets variable SPRATR_INIT_STATUS
 268+ 4ED5              SPRDISABLE:
 269+ 4ED5              SPRDISABLE_DEFUSR:
 270+ 4ED5 AF           	XOR A
 271+ 4ED6 32 7F 4D     	LD (SPRATR_INIT_STATUS), A
 272+ 4ED9 C9           	RET
 273+ 4EDA              ; *******************************************************************************************************
 274+ 4EDA               ENDIF
 275+ 4EDA
 276+ 4EDA              ; *******************************************************************************************************
 277+ 4EDA              ; function to handle CALL SPRSET basic extension
 278+ 4EDA              ; sets position, and optionally pattern and color of sprite
 279+ 4EDA              ; _SPRSET ( BYTE sprite_num , valid 0-31
 280+ 4EDA              ;			INT x,
 281+ 4EDA              ;			INT y,
 282+ 4EDA              ;			INT pattern, valid 0-63, otherwise ignored
 283+ 4EDA              ;			INT color, valid 0-15, otherwise ignored
 284+ 4EDA              ;SPRSET:
 285+ 4EDA              ;	LD A, (SPRATR_INIT_STATUS)
 286+ 4EDA              ;	OR A
 287+ 4EDA              ;	JR NZ, .L1
 288+ 4EDA              ;	LD E, 5 ; illegal function call
 289+ 4EDA              ;	JP THROW_ERROR
 290+ 4EDA              ;.L1:
 291+ 4EDA              ;	; opening (
 292+ 4EDA              ;	CALL CHKCHAR
 293+ 4EDA              ;	DB '('
 294+ 4EDA              ;	; get sprite number
 295+ 4EDA              ;	LD IX, GETBYT
 296+ 4EDA              ;	CALL CALBAS
 297+ 4EDA              ;	PUSH AF
 298+ 4EDA              ;	; comma
 299+ 4EDA              ;	CALL CHKCHAR
 300+ 4EDA              ;	DB ','
 301+ 4EDA              ;	; get x
 302+ 4EDA              ;	LD IX, FRMQNT
 303+ 4EDA              ;	CALL CALBAS
 304+ 4EDA              ;	PUSH DE
 305+ 4EDA              ;	; comma
 306+ 4EDA              ;	CALL CHKCHAR
 307+ 4EDA              ;	DB ','
 308+ 4EDA              ;	; get y
 309+ 4EDA              ;	LD IX, FRMQNT
 310+ 4EDA              ;	CALL CALBAS
 311+ 4EDA              ;	PUSH DE
 312+ 4EDA              ;	; comma
 313+ 4EDA              ;	CALL CHKCHAR
 314+ 4EDA              ;	DB ','
 315+ 4EDA              ;	; get pattern
 316+ 4EDA              ;	LD IX, FRMQNT
 317+ 4EDA              ;	CALL CALBAS
 318+ 4EDA              ;	PUSH DE
 319+ 4EDA              ;	; comma
 320+ 4EDA              ;	CALL CHKCHAR
 321+ 4EDA              ;	DB ','
 322+ 4EDA              ;	; get color
 323+ 4EDA              ;	LD IX, FRMQNT
 324+ 4EDA              ;	CALL CALBAS
 325+ 4EDA              ;	PUSH DE
 326+ 4EDA              ;	; ending )
 327+ 4EDA              ;	CALL CHKCHAR
 328+ 4EDA              ;	DB ')'
 329+ 4EDA              ;
 330+ 4EDA              ;   ; save position in BASIC text
 331+ 4EDA              ;	PUSH HL
 332+ 4EDA              ;	POP IX
 333+ 4EDA              ;
 334+ 4EDA              ;	POP BC ; color
 335+ 4EDA              ;	POP DE ; pattern
 336+ 4EDA              ;	EXX
 337+ 4EDA              ;	POP BC ; y
 338+ 4EDA              ;	POP DE ; x
 339+ 4EDA              ;	POP AF ; sprite number
 340+ 4EDA              ;	CP 32
 341+ 4EDA              ;	JR C, .L2
 342+ 4EDA              ;	LD E, 5 ; illegal function call
 343+ 4EDA              ;	JP THROW_ERROR
 344+ 4EDA              ;.L2:
 345+ 4EDA              ;	; find location in sprite attributes table
 346+ 4EDA              ;	PUSH DE
 347+ 4EDA              ;	CALL GETnthSPRATTR
 348+ 4EDA              ;	POP DE
 349+ 4EDA              ;	DI
 350+ 4EDA              ;	; set y
 351+ 4EDA              ;	LD (HL), C
 352+ 4EDA              ;	INC HL
 353+ 4EDA              ;	LD (HL), B
 354+ 4EDA              ;	INC HL
 355+ 4EDA              ;	; set x
 356+ 4EDA              ;	LD (HL), E
 357+ 4EDA              ;	INC HL
 358+ 4EDA              ;	LD (HL), D
 359+ 4EDA              ;	INC HL
 360+ 4EDA              ;	PUSH HL
 361+ 4EDA              ;	EXX
 362+ 4EDA              ;	POP HL
 363+ 4EDA              ;	; check if 0<=pattern<64
 364+ 4EDA              ;	LD A, D
 365+ 4EDA              ;	OR A
 366+ 4EDA              ;	JR NZ, .L3
 367+ 4EDA              ;	LD A, E
 368+ 4EDA              ;	CP 64
 369+ 4EDA              ;	JR NC, .L3
 370+ 4EDA              ;	; set pattern
 371+ 4EDA              ;	;ADD A, A
 372+ 4EDA              ;	;ADD A, A
 373+ 4EDA              ;	;ADD A, A
 374+ 4EDA              ;	LD (HL), A
 375+ 4EDA              ;	INC HL
 376+ 4EDA              ;	LD (HL), D
 377+ 4EDA              ;	INC HL
 378+ 4EDA              ;	JR .L4
 379+ 4EDA              ;.L3:
 380+ 4EDA              ;	; skip pattern
 381+ 4EDA              ;	.2 INC HL
 382+ 4EDA              ;.L4:
 383+ 4EDA              ;	; check if 0<=color<16
 384+ 4EDA              ;	LD A, B
 385+ 4EDA              ;	OR A
 386+ 4EDA              ;	JR NZ, .L5
 387+ 4EDA              ;	LD A, C
 388+ 4EDA              ;	CP 16
 389+ 4EDA              ;	JR NC, .L5
 390+ 4EDA              ;	; set color
 391+ 4EDA              ;	LD (HL), C
 392+ 4EDA              ;	INC HL
 393+ 4EDA              ;	LD (HL), B
 394+ 4EDA              ;
 395+ 4EDA              ;.L5:
 396+ 4EDA              ;	EI
 397+ 4EDA              ;	PUSH IX
 398+ 4EDA              ;	POP HL
 399+ 4EDA              ;	RET
 400+ 4EDA              ; *******************************************************************************************************
 401+ 4EDA
 402+ 4EDA              ; *******************************************************************************************************
 403+ 4EDA              ; function sets sprite location based on initial coordinates and offset provided
 404+ 4EDA              ; input A=sprite number in SPRATR_DATA , 0-31
 405+ 4EDA              ; input DE=initial x
 406+ 4EDA              ; input BC=initial y
 407+ 4EDA              ; input IY=location where delta y,x are located
 408+ 4EDA              ; modifies AF, HL, IX
 409+ 4EDA              SPRSET_DELTA_POS:
 410+ 4EDA D5           	PUSH DE
 411+ 4EDB CD 89 4D     	CALL GETnthSPRATTR
 412+ 4EDE E5           	PUSH HL
 413+ 4EDF DD E1        	POP IX
 414+ 4EE1 D1           	POP DE
 415+ 4EE2              	; IX=sprite's y location
 416+ 4EE2 FD 6E 00     	LD L, (IY)
 417+ 4EE5 FD 66 01     	LD H, (IY+1)
 418+ 4EE8 09           	ADD HL, BC
 419+ 4EE9 DD 75 00     	LD (IX), L
 420+ 4EEC DD 74 01     	LD (IX+1), H
 421+ 4EEF FD 6E 02     	LD L, (IY+2)
 422+ 4EF2 FD 66 03     	LD H, (IY+3)
 423+ 4EF5 19           	ADD HL, DE
 424+ 4EF6 DD 75 02     	LD (IX+2), L
 425+ 4EF9 DD 74 03     	LD (IX+3), H
 426+ 4EFC C9           	RET
 427+ 4EFD              ; *******************************************************************************************************
 428+ 4EFD
 429+ 4EFD              ; *******************************************************************************************************
 430+ 4EFD              ; helper function to set new locations for a set of sprites
 431+ 4EFD              ; input B=number of sprites
 432+ 4EFD              ; HL=pointer to list of sprites and offsets
 433+ 4EFD              SPR_UPDATE_LOC:
 434+ 4EFD 3E 01        	LD A,1
 435+ 4EFF 32 81 66     	LD (VRAM_UPDATE_IN_PROGRESS),A
 436+ 4F02 7E           	LD A, (HL)
 437+ 4F03 23           	INC HL
 438+ 4F04 23           	INC HL
 439+ 4F05 E5           	PUSH HL
 440+ 4F06 FD E1        	POP IY
 441+ 4F08 D9           	EXX
 442+ 4F09 CD DA 4E     	CALL SPRSET_DELTA_POS
 443+ 4F0C D9           	EXX
 444+ 4F0D 23          > INC HL
 444+ 4F0E 23          > INC HL
 444+ 4F0F 23          > INC HL
 444+ 4F10 23          > INC HL
 445+ 4F11 10 EA        	DJNZ SPR_UPDATE_LOC
 446+ 4F13 AF           	XOR A
 447+ 4F14 32 81 66     	LD (VRAM_UPDATE_IN_PROGRESS),A
 448+ 4F17 C9           	RET
 449+ 4F18              ; *******************************************************************************************************
 450+ 4F18
 451+ 4F18               IF (BASIC_EXTENSION == 1)
 452+ 4F18              ; *******************************************************************************************************
 453+ 4F18              ; function to handle CALL SPRGRPMOV basic extension
 454+ 4F18              ; sets position of a group of sprites described with
 455+ 4F18              ; { int sprite_num, int delta_y, int delta_x } [count]
 456+ 4F18              ; _SPRGRPMOV ( INT x,
 457+ 4F18              ;			   INT y,
 458+ 4F18              ;			   BYTE count,
 459+ 4F18              ;			   INT[2][count] data_ptr
 460+ 4F18              SPRGRPMOV:
 461+ 4F18 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
 462+ 4F1B B7           	OR A
 463+ 4F1C CA 9F 69     	JP Z,ILLEGAL_FUNCTION
 464+ 4F1F              	; opening (
 465+ 4F1F CD 7F 69     	CALL CHKCHAR
 466+ 4F22 28           	DB '('
 467+ 4F23              	; get x
 468+ 4F23 DD 21 2F 54  	LD IX, FRMQNT
 469+ 4F27 CD 59 01     	CALL CALBAS
 470+ 4F2A ED 53 70 66  	LD (BLIT_STRUCT),DE
 471+ 4F2E              	; comma
 472+ 4F2E CD 7F 69     	CALL CHKCHAR
 473+ 4F31 2C           	DB ','
 474+ 4F32              	; get y
 475+ 4F32 DD 21 2F 54  	LD IX, FRMQNT
 476+ 4F36 CD 59 01     	CALL CALBAS
 477+ 4F39 ED 53 72 66  	LD (BLIT_STRUCT+2),DE
 478+ 4F3D              	; comma
 479+ 4F3D CD 7F 69     	CALL CHKCHAR
 480+ 4F40 2C           	DB ','
 481+ 4F41              	; get count
 482+ 4F41 DD 21 1C 52  	LD IX, GETBYT
 483+ 4F45 CD 59 01     	CALL CALBAS
 484+ 4F48 32 74 66     	LD (BLIT_STRUCT+4),A
 485+ 4F4B              	; comma
 486+ 4F4B CD 7F 69     	CALL CHKCHAR
 487+ 4F4E 2C           	DB ','
 488+ 4F4F              	; get sprite group definition array data pointer
 489+ 4F4F 3A 74 66     	LD A,(BLIT_STRUCT+4)
 490+ 4F52 5F           	LD E,A
 491+ 4F53 16 03        	LD D,3
 492+ 4F55 3E 02        	LD A,2
 493+ 4F57 47           	LD B,A
 494+ 4F58 CD AC 69     	CALL GET_BASIC_ARRAY_DATA_POINTER
 495+ 4F5B ED 43 75 66  	LD (BLIT_STRUCT+5),BC
 496+ 4F5F              	; ending )
 497+ 4F5F CD 7F 69     	CALL CHKCHAR
 498+ 4F62 29           	DB ')'
 499+ 4F63
 500+ 4F63 E5           	PUSH HL
 501+ 4F64
 502+ 4F64 D9               EXX
 503+ 4F65 ED 5B 70 66      LD DE,(BLIT_STRUCT) ; initial x
 504+ 4F69 ED 4B 72 66      LD BC,(BLIT_STRUCT+2) ; initial y
 505+ 4F6D D9               EXX
 506+ 4F6E 2A 75 66         LD HL,(BLIT_STRUCT+5) ; pointer to data
 507+ 4F71 3A 74 66         LD A,(BLIT_STRUCT+4) ; number of entries
 508+ 4F74 47               LD B,A
 509+ 4F75 CD FD 4E     	CALL SPR_UPDATE_LOC
 510+ 4F78
 511+ 4F78 E1           	POP HL
 512+ 4F79 C9           	RET
 513+ 4F7A              ; *******************************************************************************************************
 514+ 4F7A               ENDIF
 515+ 4F7A
 516+ 4F7A               IF (DEFUSR_EXTENSION == 1)
 517+ 4F7A              ; *******************************************************************************************************
 518+ 4F7A              ; same as SPRGRPMOV but for DEFUSR approach
 519+ 4F7A              ; input IX=pointer to input array, real data from +2
 520+ 4F7A              ; +2 = X
 521+ 4F7A              ; +4 = Y
 522+ 4F7A              ; +6 = count
 523+ 4F7A              ; +8 = data pointer
 524+ 4F7A              SPRGRPMOV_DEFUSR:
 525+ 4F7A D9               EXX
 526+ 4F7B DD 5E 02     	LD E,(IX+2)
 527+ 4F7E DD 56 03     	LD D,(IX+3) ; initial x
 528+ 4F81 DD 4E 04     	LD C,(IX+4)
 529+ 4F84 DD 46 05     	LD B,(IX+5) ; initial y
 530+ 4F87 D9               EXX
 531+ 4F88 DD 6E 08     	LD L,(IX+8)
 532+ 4F8B DD 66 09     	LD H,(IX+9) ; pointer to data
 533+ 4F8E DD 46 06         LD B,(IX+6) ; count
 534+ 4F91 C3 FD 4E         JP SPR_UPDATE_LOC
 535+ 4F94              ; *******************************************************************************************************
 536+ 4F94               ENDIF
# file closed: asm\SPRITES.asm
 130  4F94               ENDIF
 131  4F94
 132  4F94               IF (ANIM_CMDS == 1)
 133  4F94               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4F94              ; sprite animation routines
   2+ 4F94
   3+ 4F94              ; number of animation items and pointer
   4+ 4F94              ANIMITEMNUM:
   5+ 4F94 00            DB 0
   6+ 4F95              ANIMITEMPTR:
   7+ 4F95 22 6A         DW EXT_END
   8+ 4F97              ; number of animation definitions and pointer
   9+ 4F97              ANIMDEFNUM:
  10+ 4F97 00            DB 0
  11+ 4F98              ANIMDEFPTR:
  12+ 4F98 22 6A         DW EXT_END
  13+ 4F9A              ; number of links between sprite and animation definitions
  14+ 4F9A              ANIMSPRNUM:
  15+ 4F9A 00            DB 0
  16+ 4F9B              ANIMSPRPTR:
  17+ 4F9B 22 6A         DW EXT_END
  18+ 4F9D              ; number of automatic sprite group move and animate structures
  19+ 4F9D              AUTOSGAMNUM:
  20+ 4F9D 00            DB 0
  21+ 4F9E              AUTOSGAMPTR:
  22+ 4F9E 22 6A         DW EXT_END
  23+ 4FA0
  24+ 4FA0              ; ANIMATION ITEM
  25+ 4FA0              ; byte type = [0 - pattern and color change
  26+ 4FA0              ;              1 - pattern definition change ]
  27+ 4FA0              ; word ticks - number of ticks to hold this state
  28+ 4FA0              ; for type = 0
  29+ 4FA0              ;   byte pattern;
  30+ 4FA0              ;   byte color;
  31+ 4FA0              ; for type = 1
  32+ 4FA0              ;   work data_pointer;
  33+ 4FA0              ; total size = 5b
  34+ 4FA0
  35+ 4FA0              ; ANIMATION DEFINITION
  36+ 4FA0              ; byte number of items 1-15
  37+ 4FA0              ; byte[15] anim_item;
  38+ 4FA0              ; total size = 16b
  39+ 4FA0
  40+ 4FA0              ; SPRITE/CHAR ANIMATION
  41+ 4FA0              ; +00 byte sprite/char number;
  42+ 4FA0              ; +01 word time;
  43+ 4FA0              ; +03 byte current item;
  44+ 4FA0              ; +04 byte animation definition;
  45+ 4FA0              ; +05 byte cyclic;
  46+ 4FA0              ; +06 byte active;
  47+ 4FA0              ; +07 byte 0=sprite, 1-3 character bank
  48+ 4FA0              ; total size = 8b
  49+ 4FA0
  50+ 4FA0              ; AUTOMATIC SPRITE GROUP MOVE AND ANIMATE structure
  51+ 4FA0              ; +00 pointer to X variable
  52+ 4FA0              ; +02 pointer to Y variable
  53+ 4FA0              ; +04 minimum value
  54+ 4FA0              ; +06 maximal value
  55+ 4FA0              ; +08 delta value
  56+ 4FA0              ; +10 direction 0=horizontal, <>0 = vertical
  57+ 4FA0              ; +11 sprite group size
  58+ 4FA0              ; +12 sprite group pointer
  59+ 4FA0              ; +14 animation list size
  60+ 4FA0              ; +15 animation list pointer for negative delta values
  61+ 4FA0              ; +17 animation list pointer for positive delta values
  62+ 4FA0              ; +19 active flag
  63+ 4FA0              ; +20 ticks for movement
  64+ 4FA0              ; +22 timer
  65+ 4FA0              ; total = 24b
  66+ 4FA0
  67+ 4FA0              ; *******************************************************************************************************
  68+ 4FA0              ; helper function HL=A*5
  69+ 4FA0              ; changes HL,DE
  70+ 4FA0              Ax5:
  71+ 4FA0 26 00            LD H,0
  72+ 4FA2 6F               LD L,A
  73+ 4FA3 54               LD D,H
  74+ 4FA4 5D               LD E,L
  75+ 4FA5 29               ADD HL,HL
  76+ 4FA6 29               ADD HL,HL
  77+ 4FA7 19               ADD HL,DE
  78+ 4FA8 C9               RET
  79+ 4FA9              ; *******************************************************************************************************
  80+ 4FA9
  81+ 4FA9              ; *******************************************************************************************************
  82+ 4FA9              ; helper function gets pointer to n-th animation item
  83+ 4FA9              ; changes HL,DE
  84+ 4FA9              GETnthANIMITEM:
  85+ 4FA9 CD A0 4F         CALL Ax5
  86+ 4FAC ED 5B 95 4F      LD DE,(ANIMITEMPTR)
  87+ 4FB0 19               ADD HL,DE
  88+ 4FB1 C9               RET
  89+ 4FB2              ; *******************************************************************************************************
  90+ 4FB2
  91+ 4FB2              ; *******************************************************************************************************
  92+ 4FB2              ; helper function gets pointer to n-th entry in animation definition
  93+ 4FB2              ; changes HL,DE
  94+ 4FB2              GETnthANIMDEF:
  95+ 4FB2 26 00            LD H,0
  96+ 4FB4 6F               LD L,A
  97+ 4FB5 CD 6C 68         CALL HLx16
  98+ 4FB8 ED 5B 98 4F      LD DE,(ANIMDEFPTR)
  99+ 4FBC 19               ADD HL,DE
 100+ 4FBD C9               RET
 101+ 4FBE              ; *******************************************************************************************************
 102+ 4FBE
 103+ 4FBE              ; *******************************************************************************************************
 104+ 4FBE              ; helper function gets pointer to n-th entry in sprite animation
 105+ 4FBE              ; changes HL,DE
 106+ 4FBE              GETnthSPRANIM:
 107+ 4FBE 26 00            LD H,0
 108+ 4FC0 6F               LD L,A
 109+ 4FC1 CD 6D 68         CALL HLx8
 110+ 4FC4 ED 5B 9B 4F      LD DE,(ANIMSPRPTR)
 111+ 4FC8 19               ADD HL,DE
 112+ 4FC9 C9               RET
 113+ 4FCA              ; *******************************************************************************************************
 114+ 4FCA
 115+ 4FCA              ; *******************************************************************************************************
 116+ 4FCA              ; helper function gets pointer to n-th entry in autosgam table
 117+ 4FCA              ; changes HL,DE
 118+ 4FCA              GETnthAUTOSGAM:
 119+ 4FCA 26 00            LD H,0
 120+ 4FCC 6F               LD L,A
 121+ 4FCD CD 6D 68         CALL HLx8
 122+ 4FD0 54               LD D,H
 123+ 4FD1 5D               LD E,L
 124+ 4FD2 29               ADD HL,HL
 125+ 4FD3 19               ADD HL,DE
 126+ 4FD4 ED 5B 9E 4F      LD DE,(AUTOSGAMPTR)
 127+ 4FD8 19               ADD HL,DE
 128+ 4FD9 C9               RET
 129+ 4FDA              ; *******************************************************************************************************
 130+ 4FDA
 131+ 4FDA               IF (DEFUSR_EXTENSION == 1)
 132+ 4FDA              ; *******************************************************************************************************
 133+ 4FDA              ; same as MAXIANIMITEMS but for DEFUSR approach
 134+ 4FDA              ; input IX=pointer to input array, real data from +2
 135+ 4FDA              ; +2 = number
 136+ 4FDA              MAXANIMITEMS_DEFUSR:
 137+ 4FDA DD 7E 02         LD A,(IX+2)
 138+ 4FDD 18 11            JR MAXANIMITEMS.COMMON
 139+ 4FDF              ; *******************************************************************************************************
 140+ 4FDF               ENDIF
 141+ 4FDF
 142+ 4FDF              ; *******************************************************************************************************
 143+ 4FDF              ; function to handle CALL MAXANIMITEMS basic extension
 144+ 4FDF              ; MAXANIMITEMS (BYTE number)
 145+ 4FDF              ; sets new number and moves memory buffers as needed
 146+ 4FDF              MAXANIMITEMS:
 147+ 4FDF               IF (BASIC_EXTENSION == 1)
 148+ 4FDF              	; opening (
 149+ 4FDF CD 7F 69     	CALL CHKCHAR
 150+ 4FE2 28           	DB '('
 151+ 4FE3              	; get value
 152+ 4FE3 DD 21 1C 52  	LD IX, GETBYT
 153+ 4FE7 CD 59 01     	CALL CALBAS
 154+ 4FEA F5               PUSH AF
 155+ 4FEB              	; ending )
 156+ 4FEB CD 7F 69     	CALL CHKCHAR
 157+ 4FEE 29           	DB ')'
 158+ 4FEF F1               POP AF
 159+ 4FF0               ENDIF
 160+ 4FF0              .COMMON: ; entry for DEFUSR part, A=number
 161+ 4FF0 F3               DI
 162+ 4FF1              	; save position
 163+ 4FF1 E5           	PUSH HL
 164+ 4FF2              .ENTRY:
 165+ 4FF2 47               LD B,A
 166+ 4FF3 3A 94 4F         LD A,(ANIMITEMNUM)
 167+ 4FF6 90               SUB B
 168+ 4FF7 28 28            JR Z, .EXIT; same value as before
 169+ 4FF9 FD 21 98 4F      LD IY,ANIMDEFPTR
 170+ 4FFD FA 24 50         JP M, .INCREASE
 171+ 5000                  ; new value is lower than previous one
 172+ 5000 CD 43 50         CALL .SIZEDIFF
 173+ 5003 CD 5E 50         CALL .DECREASE_COMMON
 174+ 5006 2A 9B 4F         LD HL,(ANIMSPRPTR)
 175+ 5009 AF               XOR A
 176+ 500A ED 42            SBC HL,BC
 177+ 500C 22 9B 4F         LD (ANIMSPRPTR),HL
 178+ 500F              .E1:
 179+ 500F 2A 9E 4F         LD HL,(AUTOSGAMPTR)
 180+ 5012 AF               XOR A
 181+ 5013 ED 42            SBC HL,BC
 182+ 5015 22 9E 4F         LD (AUTOSGAMPTR),HL
 183+ 5018              .E3:
 184+ 5018 2A 10 40         LD HL,(FREEMEMPTR)
 185+ 501B AF               XOR A
 186+ 501C ED 42            SBC HL,BC
 187+ 501E 22 10 40         LD (FREEMEMPTR),HL
 188+ 5021              .EXIT:
 189+ 5021 FB               EI
 190+ 5022 E1           	POP HL
 191+ 5023 C9           	RET
 192+ 5024              .INCREASE:
 193+ 5024 ED 44            NEG
 194+ 5026 CD 43 50         CALL .SIZEDIFF
 195+ 5029 CD 8A 50         CALL .INCREASE_COMMON
 196+ 502C 2A 9B 4F         LD HL,(ANIMSPRPTR)
 197+ 502F 09               ADD HL,BC
 198+ 5030 22 9B 4F         LD (ANIMSPRPTR),HL
 199+ 5033              .E2:
 200+ 5033 2A 9E 4F         LD HL,(AUTOSGAMPTR)
 201+ 5036 09               ADD HL,BC
 202+ 5037 22 9E 4F         LD (AUTOSGAMPTR),HL
 203+ 503A              .E4:
 204+ 503A 2A 10 40         LD HL,(FREEMEMPTR)
 205+ 503D 09               ADD HL,BC
 206+ 503E 22 10 40         LD (FREEMEMPTR),HL
 207+ 5041 18 DE            JR .EXIT
 208+ 5043              .SIZEDIFF:
 209+ 5043 CD A0 4F         CALL Ax5
 210+ 5046 78               LD A,B
 211+ 5047 32 94 4F         LD (ANIMITEMNUM),A
 212+ 504A 44               LD B,H
 213+ 504B 4D               LD C,L
 214+ 504C C9               RET ; BC=size difference in bytes
 215+ 504D              .SIZETOMOVE:
 216+ 504D D5               PUSH DE
 217+ 504E 2A 10 40         LD HL,(FREEMEMPTR)
 218+ 5051 FD 5E 00         LD E,(IY)
 219+ 5054 FD 56 01         LD D,(IY+1)
 220+ 5057 AF               XOR A
 221+ 5058 ED 52            SBC HL,DE
 222+ 505A 44               LD B,H
 223+ 505B 4D               LD C,L
 224+ 505C D1               POP DE
 225+ 505D C9               RET
 226+ 505E              .DECREASE_COMMON:
 227+ 505E FD 6E 00         LD L,(IY)
 228+ 5061 FD 66 01         LD H,(IY+1)
 229+ 5064 AF               XOR A
 230+ 5065 ED 42            SBC HL,BC
 231+ 5067 EB               EX DE,HL
 232+ 5068 C5               PUSH BC
 233+ 5069 CD 4D 50         CALL .SIZETOMOVE
 234+ 506C F3               DI
 235+ 506D 78               LD A,B
 236+ 506E B1               OR C
 237+ 506F 28 08            JR Z,.L1
 238+ 5071 FD 6E 00         LD L,(IY)
 239+ 5074 FD 66 01         LD H,(IY+1)
 240+ 5077 ED B0            LDIR
 241+ 5079              .L1:
 242+ 5079 C1               POP BC
 243+ 507A FD 6E 00         LD L,(IY)
 244+ 507D FD 66 01         LD H,(IY+1)
 245+ 5080 AF               XOR A
 246+ 5081 ED 42            SBC HL,BC
 247+ 5083 FD 75 00         LD (IY),L
 248+ 5086 FD 74 01         LD (IY+1),H
 249+ 5089 C9               RET
 250+ 508A              .INCREASE_COMMON:
 251+ 508A 2A 10 40         LD HL,(FREEMEMPTR)
 252+ 508D 2B               DEC HL
 253+ 508E AF               XOR A
 254+ 508F ED 42            SBC HL,BC
 255+ 5091 EB               EX DE,HL
 256+ 5092 C5               PUSH BC
 257+ 5093 CD 4D 50         CALL .SIZETOMOVE
 258+ 5096 F3               DI
 259+ 5097 78               LD A,B
 260+ 5098 B1               OR C
 261+ 5099 28 06            JR Z,.L2
 262+ 509B 2A 10 40         LD HL,(FREEMEMPTR)
 263+ 509E 2B               DEC HL
 264+ 509F ED B8            LDDR
 265+ 50A1              .L2:
 266+ 50A1 C1               POP BC
 267+ 50A2 FD 6E 00         LD L,(IY)
 268+ 50A5 FD 66 01         LD H,(IY+1)
 269+ 50A8 09               ADD HL,BC
 270+ 50A9 FD 75 00         LD (IY),L
 271+ 50AC FD 74 01         LD (IY+1),H
 272+ 50AF C9               RET
 273+ 50B0              ; *******************************************************************************************************
 274+ 50B0
 275+ 50B0               IF (BASIC_EXTENSION == 1)
 276+ 50B0              ; *******************************************************************************************************
 277+ 50B0              ; function to handle CALL ANIMITEMPAT basic extension
 278+ 50B0              ; ANIMITEMPAT ( BYTE id,
 279+ 50B0              ;               INT ticks >0,
 280+ 50B0              ;               BYTE pattern,
 281+ 50B0              ;               BYTE color )
 282+ 50B0              ; fills animation item data, returns an error if ID out of bounds
 283+ 50B0              ANIMITEMPAT:
 284+ 50B0                  ; opening (
 285+ 50B0 CD 7F 69     	CALL CHKCHAR
 286+ 50B3 28           	DB '('
 287+ 50B4              	; get id
 288+ 50B4 DD 21 1C 52  	LD IX, GETBYT
 289+ 50B8 CD 59 01     	CALL CALBAS
 290+ 50BB F5               PUSH AF
 291+ 50BC                  ; check if out of bounds
 292+ 50BC 3C               INC A
 293+ 50BD 4F               LD C,A
 294+ 50BE 3A 94 4F         LD A,(ANIMITEMNUM)
 295+ 50C1 B9               CP C
 296+ 50C2 DA 97 69         JP C,SUBSCRIPT_OUT_OF_RANGE
 297+ 50C5              	; comma
 298+ 50C5 CD 7F 69     	CALL CHKCHAR
 299+ 50C8 2C           	DB ','
 300+ 50C9              	; get ticks
 301+ 50C9 DD 21 2F 54  	LD IX, FRMQNT
 302+ 50CD CD 59 01     	CALL CALBAS
 303+ 50D0 7A               LD A,D
 304+ 50D1 B3               OR E
 305+ 50D2 CA 9B 69         JP Z, OVERFLOW
 306+ 50D5 D5           	PUSH DE
 307+ 50D6              	; comma
 308+ 50D6 CD 7F 69     	CALL CHKCHAR
 309+ 50D9 2C           	DB ','
 310+ 50DA              	; get pattern
 311+ 50DA DD 21 1C 52  	LD IX, GETBYT
 312+ 50DE CD 59 01     	CALL CALBAS
 313+ 50E1 F5               PUSH AF
 314+ 50E2              	; comma
 315+ 50E2 CD 7F 69     	CALL CHKCHAR
 316+ 50E5 2C           	DB ','
 317+ 50E6              	; get color
 318+ 50E6 DD 21 1C 52  	LD IX, GETBYT
 319+ 50EA CD 59 01     	CALL CALBAS
 320+ 50ED F5               PUSH AF
 321+ 50EE              	; ending )
 322+ 50EE CD 7F 69     	CALL CHKCHAR
 323+ 50F1 29           	DB ')'
 324+ 50F2              .ENTRY:
 325+ 50F2 E5               PUSH HL
 326+ 50F3 DD E1            POP IX
 327+ 50F5 D9               EXX
 328+ 50F6 C1               POP BC ; color
 329+ 50F7 D1               POP DE ; pattern
 330+ 50F8 E1               POP HL ; ticks
 331+ 50F9 D9               EXX
 332+ 50FA F1               POP AF
 333+ 50FB CD A9 4F         CALL GETnthANIMITEM
 334+ 50FE E5               PUSH HL
 335+ 50FF FD E1            POP IY
 336+ 5101 D9               EXX
 337+ 5102 FD 36 00 00      LD (IY),0 ; type=0
 338+ 5106 FD 75 01         LD (IY+1),L
 339+ 5109 FD 74 02         LD (IY+2),H
 340+ 510C FD 72 03         LD (IY+3),D
 341+ 510F FD 70 04         LD (IY+4),B
 342+ 5112
 343+ 5112 DD E5            PUSH IX
 344+ 5114 E1               POP HL
 345+ 5115 C9               RET
 346+ 5116              ; *******************************************************************************************************
 347+ 5116               ENDIF
 348+ 5116
 349+ 5116               IF (DEFUSR_EXTENSION == 1)
 350+ 5116              ; *******************************************************************************************************
 351+ 5116              ; same as ANIMITEMPAT but for DEFUSR approach
 352+ 5116              ; input IX=pointer to input array, real data from +2
 353+ 5116              ; +02 = ID
 354+ 5116              ; +04 = ticks
 355+ 5116              ; +06 = pattern
 356+ 5116              ; +08 = color
 357+ 5116              ANIMITEMPAT_DEFUSR:
 358+ 5116                  ; check if out of bounds
 359+ 5116 DD 4E 02         LD C,(IX+2)
 360+ 5119 0C               INC C
 361+ 511A 3A 94 4F         LD A,(ANIMITEMNUM)
 362+ 511D B9               CP C
 363+ 511E D8               RET C ; out of bounds, prevent memory corruption
 364+ 511F 79               LD A,C
 365+ 5120 3D               DEC A
 366+ 5121 CD A9 4F         CALL GETnthANIMITEM
 367+ 5124 36 00            LD (HL),0 ; type=0
 368+ 5126 23               INC HL
 369+ 5127 DD 7E 04         LD A,(IX+4) ; ticks low
 370+ 512A 77               LD (HL),A
 371+ 512B 23               INC HL
 372+ 512C DD 7E 05         LD A,(IX+5) ; ticks high
 373+ 512F 77               LD (HL),A
 374+ 5130 23               INC HL
 375+ 5131 DD 7E 06         LD A,(IX+6) ; pattern
 376+ 5134 77               LD (HL),A
 377+ 5135 23               INC HL
 378+ 5136 DD 7E 08         LD A,(IX+8) ; color
 379+ 5139 77               LD (HL),A
 380+ 513A C9               RET
 381+ 513B              ; *******************************************************************************************************
 382+ 513B               ENDIF
 383+ 513B
 384+ 513B               IF (BASIC_EXTENSION == 1)
 385+ 513B              ; *******************************************************************************************************
 386+ 513B              ; function to handle CALL ANIMITEMPTR basic extension
 387+ 513B              ; ANIMITEMPTR ( BYTE id,
 388+ 513B              ;               INT ticks,
 389+ 513B              ;               INT pointer,
 390+ 513B              ; fills animation item data, returns an error if ID out of bounds
 391+ 513B              ANIMITEMPTR_CMD:
 392+ 513B                  ; opening (
 393+ 513B CD 7F 69     	CALL CHKCHAR
 394+ 513E 28           	DB '('
 395+ 513F              	; get id
 396+ 513F DD 21 1C 52  	LD IX, GETBYT
 397+ 5143 CD 59 01     	CALL CALBAS
 398+ 5146 F5               PUSH AF
 399+ 5147                  ; check if out of bounds
 400+ 5147 3C               INC A
 401+ 5148 4F               LD C,A
 402+ 5149 3A 94 4F         LD A,(ANIMITEMNUM)
 403+ 514C B9               CP C
 404+ 514D DA 97 69         JP C,SUBSCRIPT_OUT_OF_RANGE
 405+ 5150              	; comma
 406+ 5150 CD 7F 69     	CALL CHKCHAR
 407+ 5153 2C           	DB ','
 408+ 5154              	; get ticks
 409+ 5154 DD 21 2F 54  	LD IX, FRMQNT
 410+ 5158 CD 59 01     	CALL CALBAS
 411+ 515B 7A               LD A,D
 412+ 515C B3               OR E
 413+ 515D CA 9B 69         JP Z,OVERFLOW
 414+ 5160 D5           	PUSH DE
 415+ 5161              	; comma
 416+ 5161 CD 7F 69     	CALL CHKCHAR
 417+ 5164 2C           	DB ','
 418+ 5165              	; get pointer
 419+ 5165 DD 21 2F 54  	LD IX, FRMQNT
 420+ 5169 CD 59 01     	CALL CALBAS
 421+ 516C D5           	PUSH DE
 422+ 516D              	; ending )
 423+ 516D CD 7F 69     	CALL CHKCHAR
 424+ 5170 29           	DB ')'
 425+ 5171              .ENTRY:
 426+ 5171 E5               PUSH HL
 427+ 5172 DD E1            POP IX
 428+ 5174 D9               EXX
 429+ 5175 D1               POP DE ; pointer
 430+ 5176 E1               POP HL ; ticks
 431+ 5177 D9               EXX
 432+ 5178 F1               POP AF
 433+ 5179 CD A9 4F         CALL GETnthANIMITEM
 434+ 517C E5               PUSH HL
 435+ 517D FD E1            POP IY
 436+ 517F D9               EXX
 437+ 5180 FD 36 00 01      LD (IY),1 ; type=1
 438+ 5184 FD 75 01         LD (IY+1),L
 439+ 5187 FD 74 02         LD (IY+2),H
 440+ 518A FD 73 03         LD (IY+3),E
 441+ 518D FD 72 04         LD (IY+4),D
 442+ 5190
 443+ 5190 DD E5            PUSH IX
 444+ 5192 E1               POP HL
 445+ 5193 C9               RET
 446+ 5194              ; *******************************************************************************************************
 447+ 5194               ENDIF
 448+ 5194
 449+ 5194               IF (DEFUSR_EXTENSION == 1)
 450+ 5194              ; *******************************************************************************************************
 451+ 5194              ; same as ANIMITEMPTR but for DEFUSR approach
 452+ 5194              ; input IX=pointer to input array, real data from +2
 453+ 5194              ; +02 = ID
 454+ 5194              ; +04 = ticks
 455+ 5194              ; +06 = pointer
 456+ 5194              ANIMITEMPTR_DEFUSR:
 457+ 5194                  ; check if out of bounds
 458+ 5194 DD 4E 02         LD C,(IX+2)
 459+ 5197 0C               INC C
 460+ 5198 3A 94 4F         LD A,(ANIMITEMNUM)
 461+ 519B B9               CP C
 462+ 519C D8               RET C ; out of bounds, prevent memory corruption
 463+ 519D 79               LD A,C
 464+ 519E 3D               DEC A
 465+ 519F CD A9 4F         CALL GETnthANIMITEM
 466+ 51A2 36 01            LD (HL),1 ; type=1
 467+ 51A4 23               INC HL
 468+ 51A5 DD 7E 04         LD A,(IX+4) ; ticks low
 469+ 51A8 77               LD (HL),A
 470+ 51A9 23               INC HL
 471+ 51AA DD 7E 05         LD A,(IX+5) ; ticks high
 472+ 51AD 77               LD (HL),A
 473+ 51AE 23               INC HL
 474+ 51AF DD 7E 06         LD A,(IX+6) ; pointer low
 475+ 51B2 77               LD (HL),A
 476+ 51B3 23               INC HL
 477+ 51B4 DD 7E 07         LD A,(IX+7) ; pointer high
 478+ 51B7 77               LD (HL),A
 479+ 51B8 C9               RET
 480+ 51B9              ; *******************************************************************************************************
 481+ 51B9               ENDIF
 482+ 51B9
 483+ 51B9               IF (DEFUSR_EXTENSION == 1)
 484+ 51B9              ; *******************************************************************************************************
 485+ 51B9              ; same as MAXANIMDEFS but for DEFUSR approach
 486+ 51B9              ; input IX=pointer to input array, real data from +2
 487+ 51B9              ; +2 = number
 488+ 51B9              MAXANIMDEFS_DEFUSR:
 489+ 51B9 DD 7E 02         LD A,(IX+2)
 490+ 51BC 18 11            JR MAXANIMDEFS.COMMON
 491+ 51BE              ; *******************************************************************************************************
 492+ 51BE               ENDIF
 493+ 51BE
 494+ 51BE              ; *******************************************************************************************************
 495+ 51BE              ; function to handle CALL MAXANIMDEFS basic extension
 496+ 51BE              ; MAXANIMDEFS (BYTE number)
 497+ 51BE              ; sets new number and moves memory buffers as needed
 498+ 51BE              MAXANIMDEFS:
 499+ 51BE               IF (BASIC_EXTENSION == 1)
 500+ 51BE              	; opening (
 501+ 51BE CD 7F 69     	CALL CHKCHAR
 502+ 51C1 28           	DB '('
 503+ 51C2              	; get value
 504+ 51C2 DD 21 1C 52  	LD IX, GETBYT
 505+ 51C6 CD 59 01     	CALL CALBAS
 506+ 51C9 F5               PUSH AF
 507+ 51CA              	; ending )
 508+ 51CA CD 7F 69     	CALL CHKCHAR
 509+ 51CD 29           	DB ')'
 510+ 51CE F1               POP AF
 511+ 51CF               ENDIF
 512+ 51CF              .COMMON:
 513+ 51CF F3               DI
 514+ 51D0              	; save position
 515+ 51D0 E5           	PUSH HL
 516+ 51D1              .ENTRY:
 517+ 51D1 47               LD B,A
 518+ 51D2 3A 97 4F         LD A,(ANIMDEFNUM)
 519+ 51D5 90               SUB B
 520+ 51D6 CA 21 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 521+ 51D9 FD 21 9B 4F      LD IY,ANIMSPRPTR
 522+ 51DD FA E9 51         JP M, .INCREASE
 523+ 51E0                  ; new value is lower than previous one
 524+ 51E0 CD F4 51         CALL .SIZEDIFF
 525+ 51E3 CD 5E 50         CALL MAXANIMITEMS.DECREASE_COMMON
 526+ 51E6 C3 0F 50         JP MAXANIMITEMS.E1
 527+ 51E9              .INCREASE:
 528+ 51E9 ED 44            NEG
 529+ 51EB CD F4 51         CALL .SIZEDIFF
 530+ 51EE CD 8A 50         CALL MAXANIMITEMS.INCREASE_COMMON
 531+ 51F1 C3 33 50         JP MAXANIMITEMS.E2
 532+ 51F4              .SIZEDIFF:
 533+ 51F4 26 00            LD H,0
 534+ 51F6 6F               LD L,A
 535+ 51F7 CD 6C 68         CALL HLx16
 536+ 51FA 78               LD A,B
 537+ 51FB 32 97 4F         LD (ANIMDEFNUM),A
 538+ 51FE 44               LD B,H
 539+ 51FF 4D               LD C,L
 540+ 5200 C9               RET ; BC=size difference in bytes
 541+ 5201              ; *******************************************************************************************************
 542+ 5201
 543+ 5201               IF (BASIC_EXTENSION == 1)
 544+ 5201              ; *******************************************************************************************************
 545+ 5201              ; function to handle CALL ANIMDEF basic extension
 546+ 5201              ; ANIMITEMPAT ( BYTE id,
 547+ 5201              ;               BYTE size,
 548+ 5201              ;               INT[] list )
 549+ 5201              ; fills animation definition data, returns an error if out of bounds, or invalid type
 550+ 5201              ANIMDEF:
 551+ 5201                  ; opening (
 552+ 5201 CD 7F 69     	CALL CHKCHAR
 553+ 5204 28           	DB '('
 554+ 5205              	; get id
 555+ 5205 DD 21 1C 52  	LD IX, GETBYT
 556+ 5209 CD 59 01     	CALL CALBAS
 557+ 520C F5               PUSH AF
 558+ 520D                  ; check if out of bounds
 559+ 520D 3C               INC A
 560+ 520E 4F               LD C,A
 561+ 520F 3A 97 4F         LD A,(ANIMDEFNUM)
 562+ 5212 B9               CP C
 563+ 5213 DA 97 69         JP C,SUBSCRIPT_OUT_OF_RANGE
 564+ 5216              	; comma
 565+ 5216 CD 7F 69     	CALL CHKCHAR
 566+ 5219 2C           	DB ','
 567+ 521A              	; get size
 568+ 521A DD 21 1C 52  	LD IX, GETBYT
 569+ 521E CD 59 01     	CALL CALBAS
 570+ 5221 FE 10            CP 16
 571+ 5223 D2 9B 69         JP NC, OVERFLOW
 572+ 5226 B7               OR A
 573+ 5227 CA 9B 69         JP Z, OVERFLOW
 574+ 522A F5           	PUSH AF
 575+ 522B              	; comma
 576+ 522B CD 7F 69     	CALL CHKCHAR
 577+ 522E 2C           	DB ','
 578+ 522F              	; get pointer to a list of animation items in integer array format
 579+ 522F                  ; get array pointer
 580+ 522F D1               POP DE
 581+ 5230 D5               PUSH DE
 582+ 5231 3E 02            LD A,2
 583+ 5233 06 01            LD B,1
 584+ 5235 CD AC 69         CALL GET_BASIC_ARRAY_DATA_POINTER
 585+ 5238 C5               PUSH BC
 586+ 5239              	; ending )
 587+ 5239 CD 7F 69     	CALL CHKCHAR
 588+ 523C 29           	DB ')'
 589+ 523D              .ENTRY:
 590+ 523D E5               PUSH HL
 591+ 523E DD E1            POP IX
 592+ 5240 D1               POP DE ; pointer to INT array
 593+ 5241 C1               POP BC ; B=item number
 594+ 5242 F1               POP AF ; id
 595+ 5243 D5               PUSH DE
 596+ 5244 CD B2 4F         CALL GETnthANIMDEF
 597+ 5247 D1               POP DE
 598+ 5248 70               LD (HL),B
 599+ 5249              .L1:
 600+ 5249 23               INC HL
 601+ 524A 1A               LD A,(DE)
 602+ 524B 13          > INC DE
 602+ 524C 13          > INC DE
 603+ 524D 77               LD (HL),A
 604+ 524E 10 F9            DJNZ .L1
 605+ 5250 DD E5            PUSH IX
 606+ 5252 E1               POP HL
 607+ 5253 C9               RET
 608+ 5254              ; *******************************************************************************************************
 609+ 5254               ENDIF
 610+ 5254
 611+ 5254               IF (DEFUSR_EXTENSION == 1)
 612+ 5254              ; *******************************************************************************************************
 613+ 5254              ; same as ANIMDEF but for DEFUSR approach
 614+ 5254              ; input IX=pointer to input array, real data from +2
 615+ 5254              ; +02 = ID
 616+ 5254              ; +04 = list size
 617+ 5254              ; +06 = list pointer
 618+ 5254              ANIMDEF_DEFUSR:
 619+ 5254                  ; check if out of bounds
 620+ 5254 DD 4E 02         LD C,(IX+2)
 621+ 5257 0C               INC C
 622+ 5258 3A 97 4F         LD A,(ANIMDEFNUM)
 623+ 525B B9               CP C
 624+ 525C D8               RET C ; invalid id
 625+ 525D              	; get size
 626+ 525D DD 7E 04         LD A,(IX+4)
 627+ 5260 FE 10            CP 16
 628+ 5262 D0               RET NC ; overflow
 629+ 5263 B7               OR A
 630+ 5264 C8               RET Z ; ID=0, invalid
 631+ 5265 47               LD B,A
 632+ 5266 79               LD A,C
 633+ 5267 3D               DEC A
 634+ 5268 CD B2 4F         CALL GETnthANIMDEF
 635+ 526B 70               LD (HL),B
 636+ 526C DD 5E 06         LD E,(IX+6)
 637+ 526F DD 56 07         LD D,(IX+7)
 638+ 5272              .L1:
 639+ 5272 23               INC HL
 640+ 5273 1A               LD A,(DE)
 641+ 5274 13          > INC DE
 641+ 5275 13          > INC DE
 642+ 5276 77               LD (HL),A
 643+ 5277 10 F9            DJNZ .L1
 644+ 5279 C9               RET
 645+ 527A              ; *******************************************************************************************************
 646+ 527A               ENDIF
 647+ 527A
 648+ 527A               IF (DEFUSR_EXTENSION == 1)
 649+ 527A              ; *******************************************************************************************************
 650+ 527A              ; same as MAXANIMSPRS but for DEFUSR approach
 651+ 527A              ; input IX=pointer to input array, real data from +2
 652+ 527A              ; +2 = number
 653+ 527A              MAXANIMSPRS_DEFUSR:
 654+ 527A DD 7E 02         LD A,(IX+2)
 655+ 527D 18 11            JR MAXANIMSPRS.COMMON
 656+ 527F              ; *******************************************************************************************************
 657+ 527F               ENDIF
 658+ 527F
 659+ 527F              ; *******************************************************************************************************
 660+ 527F              ; function to handle CALL MAXANIMSPRS basic extension
 661+ 527F              ; MAXANIMSPRS (BYTE number)
 662+ 527F              ; sets new number and moves memory buffers as needed
 663+ 527F              MAXANIMSPRS:
 664+ 527F               IF (BASIC_EXTENSION == 1)
 665+ 527F              	; opening (
 666+ 527F CD 7F 69     	CALL CHKCHAR
 667+ 5282 28           	DB '('
 668+ 5283              	; get value
 669+ 5283 DD 21 1C 52  	LD IX, GETBYT
 670+ 5287 CD 59 01     	CALL CALBAS
 671+ 528A F5               PUSH AF
 672+ 528B              	; ending )
 673+ 528B CD 7F 69     	CALL CHKCHAR
 674+ 528E 29           	DB ')'
 675+ 528F F1               POP AF
 676+ 5290               ENDIF
 677+ 5290              .COMMON:
 678+ 5290 F3               DI
 679+ 5291              	; save position
 680+ 5291 E5           	PUSH HL
 681+ 5292              .ENTRY:
 682+ 5292 47               LD B,A
 683+ 5293 3A 9A 4F         LD A,(ANIMSPRNUM)
 684+ 5296 90               SUB B
 685+ 5297 CA 21 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 686+ 529A FD 21 9E 4F      LD IY,AUTOSGAMPTR
 687+ 529E FA AA 52         JP M, .INCREASE
 688+ 52A1                  ; new value is lower than previous one
 689+ 52A1 CD CB 52         CALL .SIZEDIFF
 690+ 52A4 CD 5E 50         CALL MAXANIMITEMS.DECREASE_COMMON
 691+ 52A7 C3 18 50         JP MAXANIMITEMS.E3
 692+ 52AA              .INCREASE:
 693+ 52AA ED 44            NEG
 694+ 52AC F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 695+ 52AD CD CB 52         CALL .SIZEDIFF
 696+ 52B0 CD 8A 50         CALL MAXANIMITEMS.INCREASE_COMMON
 697+ 52B3 AF               XOR A
 698+ 52B4 ED 42            SBC HL,BC ; location of new stuff
 699+ 52B6 F1               POP AF
 700+ 52B7 C5               PUSH BC
 701+ 52B8 47               LD B,A
 702+ 52B9 11 08 00         LD DE,8
 703+ 52BC E5               PUSH HL
 704+ 52BD DD E1            POP IX
 705+ 52BF              .L1:
 706+ 52BF DD 36 06 00      LD (IX+6),0 ; active flag
 707+ 52C3 DD 19            ADD IX,DE
 708+ 52C5 10 F8            DJNZ .L1
 709+ 52C7 C1               POP BC
 710+ 52C8 C3 3A 50         JP MAXANIMITEMS.E4
 711+ 52CB              .SIZEDIFF:
 712+ 52CB 26 00            LD H,0
 713+ 52CD 6F               LD L,A
 714+ 52CE CD 6D 68         CALL HLx8
 715+ 52D1 78               LD A,B
 716+ 52D2 32 9A 4F         LD (ANIMSPRNUM),A
 717+ 52D5 44               LD B,H
 718+ 52D6 4D               LD C,L
 719+ 52D7 C9               RET ; BC=size difference in bytes
 720+ 52D8              ; *******************************************************************************************************
 721+ 52D8
 722+ 52D8               IF (BASIC_EXTENSION == 1)
 723+ 52D8              ; *******************************************************************************************************
 724+ 52D8              ; function to handle CALL ANIMSPRITE basic extension
 725+ 52D8              ; ANIMSPRITE ( BYTE id,
 726+ 52D8              ;              BYTE sprite_number,
 727+ 52D8              ;              BYTE animation_definition_id,
 728+ 52D8              ;              BYTE cyclic_flag )
 729+ 52D8              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 730+ 52D8              ANIMSPRITE:
 731+ 52D8                  ; opening (
 732+ 52D8 CD 7F 69     	CALL CHKCHAR
 733+ 52DB 28           	DB '('
 734+ 52DC              	; get sprite animation id
 735+ 52DC DD 21 1C 52  	LD IX, GETBYT
 736+ 52E0 CD 59 01     	CALL CALBAS
 737+ 52E3 F5               PUSH AF
 738+ 52E4 3C               INC A
 739+ 52E5 4F               LD C,A
 740+ 52E6 3A 9A 4F         LD A,(ANIMSPRNUM)
 741+ 52E9 B9               CP C
 742+ 52EA DA 97 69         JP C,SUBSCRIPT_OUT_OF_RANGE
 743+ 52ED              	; comma
 744+ 52ED CD 7F 69     	CALL CHKCHAR
 745+ 52F0 2C           	DB ','
 746+ 52F1              	; get sprite number
 747+ 52F1 DD 21 1C 52  	LD IX, GETBYT
 748+ 52F5 CD 59 01     	CALL CALBAS
 749+ 52F8 F5               PUSH AF
 750+ 52F9                  ; check if out of bounds
 751+ 52F9 FE 20            CP 32
 752+ 52FB D2 97 69         JP NC, SUBSCRIPT_OUT_OF_RANGE
 753+ 52FE              	; comma
 754+ 52FE CD 7F 69     	CALL CHKCHAR
 755+ 5301 2C           	DB ','
 756+ 5302              	; get animation definition id
 757+ 5302 DD 21 1C 52  	LD IX, GETBYT
 758+ 5306 CD 59 01     	CALL CALBAS
 759+ 5309 F5               PUSH AF
 760+ 530A 3C               INC A
 761+ 530B 4F               LD C,A
 762+ 530C 3A 97 4F         LD A,(ANIMDEFNUM)
 763+ 530F B9               CP C
 764+ 5310 DA 97 69         JP C,SUBSCRIPT_OUT_OF_RANGE
 765+ 5313              	; comma
 766+ 5313 CD 7F 69     	CALL CHKCHAR
 767+ 5316 2C           	DB ','
 768+ 5317              	; get cyclic flag
 769+ 5317 DD 21 1C 52  	LD IX, GETBYT
 770+ 531B CD 59 01         CALL CALBAS
 771+ 531E F5           	PUSH AF
 772+ 531F              	; ending )
 773+ 531F CD 7F 69     	CALL CHKCHAR
 774+ 5322 29           	DB ')'
 775+ 5323              .ENTRY:
 776+ 5323 E5               PUSH HL
 777+ 5324 DD E1            POP IX
 778+ 5326 D9               EXX
 779+ 5327 D1               POP DE ; cyclic
 780+ 5328 C1               POP BC ; animation definition id
 781+ 5329 E1               POP HL ; sprite number
 782+ 532A D9               EXX
 783+ 532B F1               POP AF ; sprite animation id
 784+ 532C CD BE 4F         CALL GETnthSPRANIM
 785+ 532F E5               PUSH HL
 786+ 5330 FD E1            POP IY
 787+ 5332 D9               EXX
 788+ 5333 FD 74 00         LD (IY),H
 789+ 5336 FD 70 04         LD (IY+4),B
 790+ 5339 FD 72 05         LD (IY+5),D
 791+ 533C                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 792+ 533C                  ; following will do preparation for ANIMSTEP situation
 793+ 533C                  ; current item set to above limit and timer to 1
 794+ 533C                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 795+ 533C FD 36 03 FF      LD (IY+3),255
 796+ 5340 FD 36 01 01      LD (IY+1),1
 797+ 5344 FD 36 02 00      LD (IY+2),0
 798+ 5348                  ; mark as sprite animation
 799+ 5348 FD 36 07 00      LD (IY+7),0
 800+ 534C DD E5            PUSH IX
 801+ 534E E1               POP HL
 802+ 534F C9               RET
 803+ 5350              ; *******************************************************************************************************
 804+ 5350               ENDIF
 805+ 5350
 806+ 5350               IF (DEFUSR_EXTENSION == 1)
 807+ 5350              ; *******************************************************************************************************
 808+ 5350              ; same as ANIMSPRITE but for DEFUSR approach
 809+ 5350              ; input IX=pointer to input array, real data from +2
 810+ 5350              ; +02 = ID
 811+ 5350              ; +04 = sprite number
 812+ 5350              ; +06 = animation definition id
 813+ 5350              ; +08 = cyclic flag
 814+ 5350              ANIMSPRITE_DEFUSR:
 815+ 5350 DD 4E 02         LD C,(IX+2)
 816+ 5353 0C               INC C
 817+ 5354 3A 9A 4F         LD A,(ANIMSPRNUM)
 818+ 5357 B9               CP C
 819+ 5358 D8               RET C ; invalid id
 820+ 5359              	; get sprite number
 821+ 5359 DD 7E 04         LD A,(IX+4)
 822+ 535C FE 20            CP 32
 823+ 535E D0               RET NC ; invalid sprite id
 824+ 535F DD 46 06         LD B,(IX+6)
 825+ 5362 04               INC B
 826+ 5363 3A 97 4F         LD A,(ANIMDEFNUM)
 827+ 5366 B8               CP B
 828+ 5367 D8               RET C ; invalid animation definition id
 829+ 5368 79               LD A,C
 830+ 5369 3D               DEC A
 831+ 536A CD BE 4F         CALL GETnthSPRANIM
 832+ 536D E5               PUSH HL
 833+ 536E DD 7E 04         LD A,(IX+4)
 834+ 5371 77               LD (HL),A ; +0
 835+ 5372 23               INC HL
 836+ 5373 36 01            LD (HL),1 ; +1
 837+ 5375 23               INC HL
 838+ 5376 36 00            LD (HL),0 ; +2
 839+ 5378 23               INC HL
 840+ 5379 36 FF            LD (HL),255 ; +3
 841+ 537B 23               INC HL
 842+ 537C 05               DEC B
 843+ 537D 70               LD (HL),B ; +4
 844+ 537E 23               INC HL
 845+ 537F DD 7E 08         LD A,(IX+8) ; +5
 846+ 5382 77               LD (HL),A
 847+ 5383 23               INC HL
 848+ 5384 23               INC HL
 849+ 5385 36 00            LD (HL),0 ; +7
 850+ 5387 C9               RET
 851+ 5388              ; *******************************************************************************************************
 852+ 5388               ENDIF
 853+ 5388
 854+ 5388
 855+ 5388               IF (BASIC_EXTENSION == 1)
 856+ 5388              ; *******************************************************************************************************
 857+ 5388              ; function to handle CALL ANIMCHAR basic extension
 858+ 5388              ; ANIMCHAR ( BYTE id,
 859+ 5388              ;            INT character number 0-767,
 860+ 5388              ;            BYTE animation_definition_id,
 861+ 5388              ;            BYTE cyclic_flag )
 862+ 5388              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 863+ 5388              ANIMCHAR:
 864+ 5388                  ; opening (
 865+ 5388 CD 7F 69     	CALL CHKCHAR
 866+ 538B 28           	DB '('
 867+ 538C              	; get sprite animation id
 868+ 538C DD 21 1C 52  	LD IX, GETBYT
 869+ 5390 CD 59 01     	CALL CALBAS
 870+ 5393 F5               PUSH AF
 871+ 5394 3C               INC A
 872+ 5395 4F               LD C,A
 873+ 5396 3A 9A 4F         LD A,(ANIMSPRNUM)
 874+ 5399 B9               CP C
 875+ 539A DA 97 69         JP C,SUBSCRIPT_OUT_OF_RANGE
 876+ 539D              	; comma
 877+ 539D CD 7F 69     	CALL CHKCHAR
 878+ 53A0 2C           	DB ','
 879+ 53A1              	; get character number
 880+ 53A1 DD 21 2F 54  	LD IX, FRMQNT
 881+ 53A5 CD 59 01     	CALL CALBAS
 882+ 53A8 D5               PUSH DE
 883+ 53A9                  ; check if out of bounds
 884+ 53A9 7A               LD A,D
 885+ 53AA FE 03            CP 3
 886+ 53AC D2 97 69         JP NC, SUBSCRIPT_OUT_OF_RANGE
 887+ 53AF              	; comma
 888+ 53AF CD 7F 69     	CALL CHKCHAR
 889+ 53B2 2C           	DB ','
 890+ 53B3              	; get animation definition id
 891+ 53B3 DD 21 1C 52  	LD IX, GETBYT
 892+ 53B7 CD 59 01     	CALL CALBAS
 893+ 53BA F5               PUSH AF
 894+ 53BB 3C               INC A
 895+ 53BC 4F               LD C,A
 896+ 53BD 3A 97 4F         LD A,(ANIMDEFNUM)
 897+ 53C0 B9               CP C
 898+ 53C1 DA 97 69         JP C,SUBSCRIPT_OUT_OF_RANGE
 899+ 53C4              	; comma
 900+ 53C4 CD 7F 69     	CALL CHKCHAR
 901+ 53C7 2C           	DB ','
 902+ 53C8              	; get cyclic flag
 903+ 53C8 DD 21 1C 52  	LD IX, GETBYT
 904+ 53CC CD 59 01         CALL CALBAS
 905+ 53CF F5           	PUSH AF
 906+ 53D0              	; ending )
 907+ 53D0 CD 7F 69     	CALL CHKCHAR
 908+ 53D3 29           	DB ')'
 909+ 53D4              .ENTRY:
 910+ 53D4 E5               PUSH HL
 911+ 53D5 DD E1            POP IX
 912+ 53D7 D9               EXX
 913+ 53D8 D1               POP DE ; cyclic
 914+ 53D9 C1               POP BC ; animation definition id
 915+ 53DA E1               POP HL ; character number
 916+ 53DB D9               EXX
 917+ 53DC F1               POP AF ; sprite animation id
 918+ 53DD CD BE 4F         CALL GETnthSPRANIM
 919+ 53E0 E5               PUSH HL
 920+ 53E1 FD E1            POP IY
 921+ 53E3 D9               EXX
 922+ 53E4 FD 75 00         LD (IY),L
 923+ 53E7 24               INC H ; save character bank+1
 924+ 53E8 FD 74 07         LD (IY+7),H
 925+ 53EB FD 70 04         LD (IY+4),B
 926+ 53EE FD 72 05         LD (IY+5),D
 927+ 53F1                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 928+ 53F1                  ; following will do preparation for ANIMSTEP situation
 929+ 53F1                  ; current item set to above limit and timer to 1
 930+ 53F1                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 931+ 53F1 FD 36 03 FF      LD (IY+3),255
 932+ 53F5 FD 36 01 01      LD (IY+1),1
 933+ 53F9 FD 36 02 00      LD (IY+2),0
 934+ 53FD DD E5            PUSH IX
 935+ 53FF E1               POP HL
 936+ 5400 C9               RET
 937+ 5401              ; *******************************************************************************************************
 938+ 5401               ENDIF
 939+ 5401
 940+ 5401               IF (DEFUSR_EXTENSION == 1)
 941+ 5401              ; *******************************************************************************************************
 942+ 5401              ; same as ANIMCHAR but for DEFUSR approach
 943+ 5401              ; input IX=pointer to input array, real data from +2
 944+ 5401              ; +02 = ID
 945+ 5401              ; +04 = character number
 946+ 5401              ; +06 = animation definition id
 947+ 5401              ; +08 = cyclic flag
 948+ 5401              ANIMCHAR_DEFUSR:
 949+ 5401 DD 4E 02         LD C,(IX+2)
 950+ 5404 0C               INC C
 951+ 5405 3A 9A 4F         LD A,(ANIMSPRNUM)
 952+ 5408 B9               CP C
 953+ 5409 D8               RET C ; invalid id
 954+ 540A              	; get sprite number
 955+ 540A DD 7E 05         LD A,(IX+5)
 956+ 540D FE 03            CP 3
 957+ 540F D0               RET NC ; invalid character (>767)
 958+ 5410 DD 46 06         LD B,(IX+6)
 959+ 5413 04               INC B
 960+ 5414 3A 97 4F         LD A,(ANIMDEFNUM)
 961+ 5417 B8               CP B
 962+ 5418 D8               RET C ; invalid animation definition id
 963+ 5419 79               LD A,C
 964+ 541A 3D               DEC A
 965+ 541B CD BE 4F         CALL GETnthSPRANIM
 966+ 541E E5               PUSH HL
 967+ 541F DD 7E 04         LD A,(IX+4)
 968+ 5422 77               LD (HL),A ; +0
 969+ 5423 23               INC HL
 970+ 5424 36 01            LD (HL),1 ; +1
 971+ 5426 23               INC HL
 972+ 5427 36 00            LD (HL),0 ; +2
 973+ 5429 23               INC HL
 974+ 542A 36 FF            LD (HL),255 ; +3
 975+ 542C 23               INC HL
 976+ 542D 05               DEC B
 977+ 542E 70               LD (HL),B ; +4
 978+ 542F 23               INC HL
 979+ 5430 DD 7E 08         LD A,(IX+8) ; +5
 980+ 5433 77               LD (HL),A
 981+ 5434 23               INC HL
 982+ 5435 23               INC HL
 983+ 5436 DD 7E 05         LD A,(IX+5)
 984+ 5439 3C               INC A
 985+ 543A 77               LD (HL),A ; +7
 986+ 543B C9               RET
 987+ 543C              ; *******************************************************************************************************
 988+ 543C               ENDIF
 989+ 543C
 990+ 543C               IF (DEFUSR_EXTENSION == 1)
 991+ 543C              ; *******************************************************************************************************
 992+ 543C              ; same as MAXAUTOSGAMS but for DEFUSR approach
 993+ 543C              ; input IX=pointer to input array, real data from +2
 994+ 543C              ; +2 = number
 995+ 543C              MAXAUTOSGAMS_DEFUSR:
 996+ 543C DD 7E 02         LD A,(IX+2)
 997+ 543F 18 11            JR MAXAUTOSGAMS.COMMON
 998+ 5441              ; *******************************************************************************************************
 999+ 5441               ENDIF
1000+ 5441
1001+ 5441              ; *******************************************************************************************************
1002+ 5441              ; function to handle CALL MAXAUTOSGAMS basic extension
1003+ 5441              ; MAXAUTOSGAMS (BYTE number)
1004+ 5441              ; sets new number and moves memory buffers as needed
1005+ 5441              MAXAUTOSGAMS:
1006+ 5441               IF (BASIC_EXTENSION == 1)
1007+ 5441              	; opening (
1008+ 5441 CD 7F 69     	CALL CHKCHAR
1009+ 5444 28           	DB '('
1010+ 5445              	; get value
1011+ 5445 DD 21 1C 52  	LD IX, GETBYT
1012+ 5449 CD 59 01     	CALL CALBAS
1013+ 544C F5               PUSH AF
1014+ 544D              	; ending )
1015+ 544D CD 7F 69     	CALL CHKCHAR
1016+ 5450 29           	DB ')'
1017+ 5451 F1               POP AF
1018+ 5452               ENDIF
1019+ 5452              .COMMON:
1020+ 5452 F3               DI
1021+ 5453              	; save position
1022+ 5453 E5           	PUSH HL
1023+ 5454              .ENTRY:
1024+ 5454 47               LD B,A
1025+ 5455 3A 9D 4F         LD A,(AUTOSGAMNUM)
1026+ 5458 90               SUB B
1027+ 5459 CA 21 50         JP Z, MAXANIMITEMS.EXIT; same value as before
1028+ 545C FD 21 10 40      LD IY,FREEMEMPTR
1029+ 5460 FA 6C 54         JP M, .INCREASE
1030+ 5463                  ; new value is lower than previous one
1031+ 5463 CD 8D 54         CALL .SIZEDIFF
1032+ 5466 CD 5E 50         CALL MAXANIMITEMS.DECREASE_COMMON
1033+ 5469 C3 21 50         JP MAXANIMITEMS.EXIT
1034+ 546C              .INCREASE:
1035+ 546C ED 44            NEG
1036+ 546E F5               PUSH AF; save difference for later to set active flag to 0 of new entires
1037+ 546F CD 8D 54         CALL .SIZEDIFF
1038+ 5472 CD 8A 50         CALL MAXANIMITEMS.INCREASE_COMMON
1039+ 5475 AF               XOR A
1040+ 5476 ED 42            SBC HL,BC ; location of new stuff
1041+ 5478 F1               POP AF
1042+ 5479 C5               PUSH BC
1043+ 547A 47               LD B,A
1044+ 547B 11 18 00         LD DE,24
1045+ 547E E5               PUSH HL
1046+ 547F DD E1            POP IX
1047+ 5481              .L1:
1048+ 5481 DD 36 13 00      LD (IX+19),0 ; active flag
1049+ 5485 DD 19            ADD IX,DE
1050+ 5487 10 F8            DJNZ .L1
1051+ 5489 C1               POP BC
1052+ 548A C3 21 50         JP MAXANIMITEMS.EXIT
1053+ 548D              .SIZEDIFF:
1054+ 548D 26 00            LD H,0
1055+ 548F 6F               LD L,A
1056+ 5490 CD 6D 68         CALL HLx8
1057+ 5493 54               LD D,H
1058+ 5494 5D               LD E,L
1059+ 5495 29               ADD HL,HL
1060+ 5496 19               ADD HL,DE
1061+ 5497 78               LD A,B
1062+ 5498 32 9D 4F         LD (AUTOSGAMNUM),A
1063+ 549B 44               LD B,H
1064+ 549C 4D               LD C,L
1065+ 549D C9               RET ; BC=size difference in bytes
1066+ 549E              ; *******************************************************************************************************
1067+ 549E
1068+ 549E               IF (BASIC_EXTENSION == 1)
1069+ 549E              ; *******************************************************************************************************
1070+ 549E              ; function to handle CALL AUTOSGAMDEF basic extension
1071+ 549E              ; AUTOSGAMDEF ( BYTE id,
1072+ 549E              ;               INT VARIABLE x, INT VARIABLE y,
1073+ 549E              ;               INT minimum, INT maximum, INT delta,
1074+ 549E              ;               INT direction =0 horizontal,
1075+ 549E              ;               INT ticks,
1076+ 549E              ;               BYTE sprite_group_count,
1077+ 549E              ;               INT[2][sprite_group_count] VARIABLE sprite_group,
1078+ 549E              ;               BYTE item_number,
1079+ 549E              ;               INT[] VARIABLE sprite_animations_negative_direction,
1080+ 549E              ;               INT[] VARIABLE sprite_animations_positive_direction
1081+ 549E              AUTOSGAMDEF:
1082+ 549E                  ; opening (
1083+ 549E CD 7F 69     	CALL CHKCHAR
1084+ 54A1 28           	DB '('
1085+ 54A2              	; get sprite animation id
1086+ 54A2 DD 21 1C 52  	LD IX, GETBYT
1087+ 54A6 CD 59 01     	CALL CALBAS
1088+ 54A9 F5               PUSH AF
1089+ 54AA 3C               INC A
1090+ 54AB 4F               LD C,A
1091+ 54AC 3A 9D 4F         LD A,(AUTOSGAMNUM)
1092+ 54AF B9               CP C
1093+ 54B0 DA 97 69         JP C,SUBSCRIPT_OUT_OF_RANGE
1094+ 54B3 F1               POP AF
1095+ 54B4 E5               PUSH HL
1096+ 54B5 CD CA 4F         CALL GETnthAUTOSGAM
1097+ 54B8 22 6C 66         LD (BLIT_TMP),HL ; for later
1098+ 54BB E1               POP HL
1099+ 54BC              	; comma
1100+ 54BC CD 7F 69     	CALL CHKCHAR
1101+ 54BF 2C           	DB ','
1102+ 54C0              	; get address of the X coordinate variable
1103+ 54C0 DD 21 A4 5E  	LD IX, PTRGET
1104+ 54C4 CD 59 01     	CALL CALBAS
1105+ 54C7 DD 2A 6C 66  	LD IX,(BLIT_TMP)
1106+ 54CB DD 73 00         LD (IX+0),E
1107+ 54CE DD 72 01         LD (IX+1),D
1108+ 54D1              	; comma
1109+ 54D1 CD 7F 69     	CALL CHKCHAR
1110+ 54D4 2C           	DB ','
1111+ 54D5              	; get address of the Y coordinate variable
1112+ 54D5 DD 21 A4 5E  	LD IX, PTRGET
1113+ 54D9 CD 59 01     	CALL CALBAS
1114+ 54DC DD 2A 6C 66  	LD IX,(BLIT_TMP)
1115+ 54E0 DD 73 02         LD (IX+2),E
1116+ 54E3 DD 72 03         LD (IX+3),D
1117+ 54E6              	; comma
1118+ 54E6 CD 7F 69     	CALL CHKCHAR
1119+ 54E9 2C           	DB ','
1120+ 54EA              	; get minimum value
1121+ 54EA DD 21 2F 54  	LD IX, FRMQNT
1122+ 54EE CD 59 01     	CALL CALBAS
1123+ 54F1 DD 2A 6C 66  	LD IX,(BLIT_TMP)
1124+ 54F5 DD 73 04         LD (IX+4),E
1125+ 54F8 DD 72 05         LD (IX+5),D
1126+ 54FB              	; comma
1127+ 54FB CD 7F 69     	CALL CHKCHAR
1128+ 54FE 2C           	DB ','
1129+ 54FF              	; get maximum value
1130+ 54FF DD 21 2F 54  	LD IX, FRMQNT
1131+ 5503 CD 59 01     	CALL CALBAS
1132+ 5506 DD 2A 6C 66  	LD IX,(BLIT_TMP)
1133+ 550A DD 73 06         LD (IX+6),E
1134+ 550D DD 72 07         LD (IX+7),D
1135+ 5510              	; comma
1136+ 5510 CD 7F 69     	CALL CHKCHAR
1137+ 5513 2C           	DB ','
1138+ 5514              	; get delta value
1139+ 5514 DD 21 2F 54  	LD IX, FRMQNT
1140+ 5518 CD 59 01     	CALL CALBAS
1141+ 551B DD 2A 6C 66  	LD IX,(BLIT_TMP)
1142+ 551F DD 73 08         LD (IX+8),E
1143+ 5522 DD 72 09         LD (IX+9),D
1144+ 5525              	; comma
1145+ 5525 CD 7F 69     	CALL CHKCHAR
1146+ 5528 2C           	DB ','
1147+ 5529              	; get direction value
1148+ 5529 DD 21 2F 54  	LD IX, FRMQNT
1149+ 552D CD 59 01     	CALL CALBAS
1150+ 5530 DD 2A 6C 66  	LD IX,(BLIT_TMP)
1151+ 5534 DD 73 0A         LD (IX+10),E
1152+ 5537              	; comma
1153+ 5537 CD 7F 69     	CALL CHKCHAR
1154+ 553A 2C           	DB ','
1155+ 553B              	; get ticks value
1156+ 553B DD 21 2F 54  	LD IX, FRMQNT
1157+ 553F CD 59 01     	CALL CALBAS
1158+ 5542 DD 2A 6C 66  	LD IX,(BLIT_TMP)
1159+ 5546 DD 73 14         LD (IX+20),E
1160+ 5549 DD 72 15         LD (IX+21),D
1161+ 554C              	; comma
1162+ 554C CD 7F 69     	CALL CHKCHAR
1163+ 554F 2C           	DB ','
1164+ 5550              	; get sprite group count
1165+ 5550 DD 21 1C 52  	LD IX, GETBYT
1166+ 5554 CD 59 01     	CALL CALBAS
1167+ 5557 B7               OR A
1168+ 5558 CA 97 69         JP Z,SUBSCRIPT_OUT_OF_RANGE
1169+ 555B DD 2A 6C 66  	LD IX,(BLIT_TMP)
1170+ 555F DD 77 0B         LD (IX+11),A
1171+ 5562              	; comma
1172+ 5562 CD 7F 69     	CALL CHKCHAR
1173+ 5565 2C           	DB ','
1174+ 5566              	; get sprite group definition array data pointer
1175+ 5566 DD 2A 6C 66  	LD IX,(BLIT_TMP)
1176+ 556A DD 5E 0B         LD E,(IX+11)
1177+ 556D 16 03        	LD D,3
1178+ 556F 3E 02        	LD A,2
1179+ 5571 47           	LD B,A
1180+ 5572 CD AC 69     	CALL GET_BASIC_ARRAY_DATA_POINTER
1181+ 5575 DD 2A 6C 66  	LD IX,(BLIT_TMP)
1182+ 5579 DD 71 0C     	LD (IX+12),C
1183+ 557C DD 70 0D         LD (IX+13),B
1184+ 557F              	; comma
1185+ 557F CD 7F 69     	CALL CHKCHAR
1186+ 5582 2C           	DB ','
1187+ 5583              	; get sprite animation array size
1188+ 5583 DD 21 1C 52  	LD IX,GETBYT
1189+ 5587 CD 59 01     	CALL CALBAS
1190+ 558A DD 2A 6C 66  	LD IX,(BLIT_TMP)
1191+ 558E DD 77 0E         LD (IX+14),A
1192+ 5591 B7               OR A
1193+ 5592 CA 97 69         JP Z,SUBSCRIPT_OUT_OF_RANGE
1194+ 5595              	; comma
1195+ 5595 CD 7F 69     	CALL CHKCHAR
1196+ 5598 2C           	DB ','
1197+ 5599                  ; get array pointer for negative direction
1198+ 5599 DD 2A 6C 66  	LD IX,(BLIT_TMP)
1199+ 559D DD 56 0E         LD D,(IX+14)
1200+ 55A0 3E 02            LD A,2
1201+ 55A2 06 01            LD B,1
1202+ 55A4 CD AC 69         CALL GET_BASIC_ARRAY_DATA_POINTER
1203+ 55A7 DD 2A 6C 66  	LD IX,(BLIT_TMP)
1204+ 55AB DD 71 0F         LD (IX+15),C
1205+ 55AE DD 70 10         LD (IX+16),B
1206+ 55B1              	; comma
1207+ 55B1 CD 7F 69     	CALL CHKCHAR
1208+ 55B4 2C           	DB ','
1209+ 55B5                  ; get array pointer for positive direction
1210+ 55B5 DD 2A 6C 66  	LD IX,(BLIT_TMP)
1211+ 55B9 DD 56 0E         LD D,(IX+14)
1212+ 55BC 3E 02            LD A,2
1213+ 55BE 06 01            LD B,1
1214+ 55C0 CD AC 69         CALL GET_BASIC_ARRAY_DATA_POINTER
1215+ 55C3 DD 2A 6C 66  	LD IX,(BLIT_TMP)
1216+ 55C7 DD 71 11         LD (IX+17),C
1217+ 55CA DD 70 12         LD (IX+18),B
1218+ 55CD              	; ending )
1219+ 55CD CD 7F 69     	CALL CHKCHAR
1220+ 55D0 29           	DB ')'
1221+ 55D1 C9               RET
1222+ 55D2              ; *******************************************************************************************************
1223+ 55D2               ENDIF
1224+ 55D2
1225+ 55D2               IF (DEFUSR_EXTENSION == 1)
1226+ 55D2              ; *******************************************************************************************************
1227+ 55D2              ; same as AUTOSGAMDEF but for DEFUSR approach
1228+ 55D2              ; input IX=pointer to input array, real data from +2
1229+ 55D2              ; +02 = ID
1230+ 55D2              ; +04 = pointer to X variable
1231+ 55D2              ; +06 = pointer to Y variable
1232+ 55D2              ; +08 = minimum
1233+ 55D2              ; +10 = maximum
1234+ 55D2              ; +12 = delta
1235+ 55D2              ; +14 = direction
1236+ 55D2              ; +16 = ticks
1237+ 55D2              ; +18 = sprite group count
1238+ 55D2              ; +20 = sprite group array pointer
1239+ 55D2              ; +22 = item number
1240+ 55D2              ; +24 = sprite animations negative direction array pointer
1241+ 55D2              ; +26 = sprite animations positive direction array pointer
1242+ 55D2              AUTOSGAMDEF_DEFUSR:
1243+ 55D2 DD 4E 02         LD C,(IX+2)
1244+ 55D5 0C               INC C
1245+ 55D6 3A 9D 4F         LD A,(AUTOSGAMNUM)
1246+ 55D9 B9               CP C
1247+ 55DA D8               RET C ; invalid id
1248+ 55DB 79               LD A,C
1249+ 55DC 3D               DEC A
1250+ 55DD CD CA 4F         CALL GETnthAUTOSGAM
1251+ 55E0 E5               PUSH HL
1252+ 55E1 FD E1            POP IY
1253+ 55E3                  ; X variable
1254+ 55E3 DD 7E 04         LD A,(IX+4)
1255+ 55E6 FD 77 00         LD (IY+0),A
1256+ 55E9 DD 7E 05         LD A,(IX+5)
1257+ 55EC FD 77 01         LD (IY+1),A
1258+ 55EF              	; Y variable
1259+ 55EF DD 7E 06         LD A,(IX+6)
1260+ 55F2 FD 77 02         LD (IY+2),A
1261+ 55F5 DD 7E 07         LD A,(IX+7)
1262+ 55F8 FD 77 03         LD (IY+3),A
1263+ 55FB              	; get minimum value
1264+ 55FB DD 7E 08         LD A,(IX+8)
1265+ 55FE FD 77 04         LD (IY+4),A
1266+ 5601 DD 7E 09         LD A,(IX+9)
1267+ 5604 FD 77 05         LD (IY+5),A
1268+ 5607              	; get maximum value
1269+ 5607 DD 7E 0A         LD A,(IX+10)
1270+ 560A FD 77 06         LD (IY+6),A
1271+ 560D DD 7E 0B         LD A,(IX+11)
1272+ 5610 FD 77 07         LD (IY+7),A
1273+ 5613              	; get delta value
1274+ 5613 DD 7E 0C         LD A,(IX+12)
1275+ 5616 FD 77 08         LD (IY+8),A
1276+ 5619 DD 7E 0D         LD A,(IX+13)
1277+ 561C FD 77 09         LD (IY+9),A
1278+ 561F              	; get direction value
1279+ 561F DD 7E 0E         LD A,(IX+14)
1280+ 5622 FD 77 0A         LD (IY+10),A
1281+ 5625              	; get ticks value
1282+ 5625 DD 7E 10         LD A,(IX+16)
1283+ 5628 FD 77 14         LD (IY+20),A
1284+ 562B DD 7E 11         LD A,(IX+17)
1285+ 562E FD 77 15         LD (IY+21),A
1286+ 5631              	; get sprite group count
1287+ 5631 DD 7E 12         LD A,(IX+18)
1288+ 5634 FD 77 0B         LD (IY+11),A
1289+ 5637              	; get sprite group definition array data pointer
1290+ 5637 DD 7E 14         LD A,(IX+20)
1291+ 563A FD 77 0C         LD (IY+12),A
1292+ 563D DD 7E 15         LD A,(IX+21)
1293+ 5640 FD 77 0D         LD (IY+13),A
1294+ 5643              	; get sprite animation array size
1295+ 5643 DD 7E 16         LD A,(IX+22)
1296+ 5646 FD 77 0E         LD (IY+14),A
1297+ 5649                  ; get array pointer for negative direction
1298+ 5649 DD 7E 18         LD A,(IX+24)
1299+ 564C FD 77 0F         LD (IY+15),A
1300+ 564F DD 7E 19         LD A,(IX+25)
1301+ 5652 FD 77 10         LD (IY+16),A
1302+ 5655                  ; get array pointer for positive direction
1303+ 5655 DD 7E 1A         LD A,(IX+26)
1304+ 5658 FD 77 11         LD (IY+17),A
1305+ 565B DD 7E 1B         LD A,(IX+27)
1306+ 565E FD 77 12         LD (IY+18),A
1307+ 5661              ; *******************************************************************************************************
1308+ 5661               ENDIF
1309+ 5661
1310+ 5661               IF (BASIC_EXTENSION == 1)
1311+ 5661              ; *******************************************************************************************************
1312+ 5661              ; function to handle CALL AUTOSGAMSTART basic extension
1313+ 5661              ; AUTOSGAMSTART ( BYTE id )
1314+ 5661              AUTOSGAMSTART:
1315+ 5661 3E 01            LD A,1
1316+ 5663              .COMMON:
1317+ 5663 32 8F 56         LD (.SETVALUE+3),A
1318+ 5666                  ; opening (
1319+ 5666 CD 7F 69     	CALL CHKCHAR
1320+ 5669 28           	DB '('
1321+ 566A              	; get sprite animation id
1322+ 566A DD 21 1C 52  	LD IX, GETBYT
1323+ 566E CD 59 01     	CALL CALBAS
1324+ 5671 F5               PUSH AF
1325+ 5672 3C               INC A
1326+ 5673 4F               LD C,A
1327+ 5674 3A 9D 4F         LD A,(AUTOSGAMNUM)
1328+ 5677 B9               CP C
1329+ 5678 DA 97 69         JP C,SUBSCRIPT_OUT_OF_RANGE
1330+ 567B F1               POP AF
1331+ 567C E5               PUSH HL
1332+ 567D CD CA 4F         CALL GETnthAUTOSGAM
1333+ 5680 E5               PUSH HL
1334+ 5681 DD E1            POP IX
1335+ 5683 E1               POP HL
1336+ 5684 DD E5            PUSH IX
1337+ 5686              	; ending )
1338+ 5686 CD 7F 69     	CALL CHKCHAR
1339+ 5689 29           	DB ')'
1340+ 568A
1341+ 568A                  ; so syntax is fine
1342+ 568A DD E1            POP IX
1343+ 568C              .SETVALUE:
1344+ 568C DD 36 13 01      LD (IX+19),1 ; active flag
1345+ 5690                  ; set initial timer
1346+ 5690 DD 7E 14         LD A,(IX+20)
1347+ 5693 DD 77 16         LD (IX+22),A
1348+ 5696 DD 7E 15         LD A,(IX+21)
1349+ 5699 DD 77 17         LD (IX+23),A
1350+ 569C C9               RET
1351+ 569D              ; *******************************************************************************************************
1352+ 569D
1353+ 569D              ; *******************************************************************************************************
1354+ 569D              ; function to handle CALL AUTOSGAMSTOP basic extension
1355+ 569D              ; AUTOSGAMSTOP ( BYTE id )
1356+ 569D              AUTOSGAMSTOP:
1357+ 569D AF               XOR A
1358+ 569E 18 C3            JR AUTOSGAMSTART.COMMON
1359+ 56A0              ; *******************************************************************************************************
1360+ 56A0               ENDIF
1361+ 56A0
1362+ 56A0               IF (DEFUSR_EXTENSION == 1)
1363+ 56A0              ; *******************************************************************************************************
1364+ 56A0              ; function to handle CALL AUTOSGAMSTART basic extension in DEFUSR mode
1365+ 56A0              ; input IX=pointer to input array, real data from +2
1366+ 56A0              ; +2 = source address
1367+ 56A0              AUTOSGAMSTART_DEFUSR:
1368+ 56A0 3E 01            LD A,1
1369+ 56A2              .COMMON:
1370+ 56A2 32 B9 56         LD (.SETVALUE+3),A
1371+ 56A5 DD 4E 02         LD C,(IX+2)
1372+ 56A8 0C               INC C
1373+ 56A9 3A 9D 4F         LD A,(AUTOSGAMNUM)
1374+ 56AC B9               CP C
1375+ 56AD D8               RET C ; invalid id
1376+ 56AE 79               LD A,C
1377+ 56AF 3D               DEC A
1378+ 56B0 CD CA 4F         CALL GETnthAUTOSGAM
1379+ 56B3 E5               PUSH HL
1380+ 56B4 DD E1            POP IX
1381+ 56B6              .SETVALUE:
1382+ 56B6 DD 36 13 01      LD (IX+19),1 ; active flag
1383+ 56BA                  ; set initial timer
1384+ 56BA DD 7E 14         LD A,(IX+20)
1385+ 56BD DD 77 16         LD (IX+22),A
1386+ 56C0 DD 7E 15         LD A,(IX+21)
1387+ 56C3 DD 77 17         LD (IX+23),A
1388+ 56C6 C9               RET
1389+ 56C7              ; *******************************************************************************************************
1390+ 56C7
1391+ 56C7              ; *******************************************************************************************************
1392+ 56C7              ; function to handle CALL AUTOSGAMSTOP basic extension in DEFUSR mode
1393+ 56C7              ; input IX=pointer to input array, real data from +2
1394+ 56C7              ; +2 = source address
1395+ 56C7              AUTOSGAMSTOP_DEFUSR:
1396+ 56C7 AF               XOR A
1397+ 56C8 18 D8            JR AUTOSGAMSTART_DEFUSR.COMMON
1398+ 56CA              ; *******************************************************************************************************
1399+ 56CA               ENDIF
1400+ 56CA
1401+ 56CA               IF (BASIC_EXTENSION == 1)
1402+ 56CA              ; *******************************************************************************************************
1403+ 56CA              ; function to handle CALL ANIMSTEP basic extension
1404+ 56CA              ; two forms
1405+ 56CA              ; ANIMSTEP ( BYTE id )
1406+ 56CA              ; or
1407+ 56CA              ; ANIMSTEP ( BYTE item_number,
1408+ 56CA              ;            INT[] sprite_animations )
1409+ 56CA              ANIMSTEP:
1410+ 56CA 11 49 57         LD DE,ANIMSTARTSTOP_COMMON.STEP
1411+ 56CD 18 08            JR ANIMSTARTSTOP_COMMON
1412+ 56CF              ; *******************************************************************************************************
1413+ 56CF              ; *******************************************************************************************************
1414+ 56CF              ; function to handle CALL ANIMSTART basic extension
1415+ 56CF              ; two forms
1416+ 56CF              ; ANIMSTART ( BYTE id )
1417+ 56CF              ; or
1418+ 56CF              ; ANIMSTART ( BYTE item_number,
1419+ 56CF              ;             INT[] sprite_animations )
1420+ 56CF              ; sets active flag to 1
1421+ 56CF              ANIMSTART:
1422+ 56CF 11 37 57         LD DE,ANIMSTARTSTOP_COMMON.START
1423+ 56D2 18 03            JR ANIMSTARTSTOP_COMMON
1424+ 56D4              ; *******************************************************************************************************
1425+ 56D4              ; *******************************************************************************************************
1426+ 56D4              ; function to handle CALL ANIMSTOP basic extension
1427+ 56D4              ; two forms
1428+ 56D4              ; ANIMSTOP ( BYTE id )
1429+ 56D4              ; or
1430+ 56D4              ; ANIMSTOP ( BYTE item_number,
1431+ 56D4              ;            INT[] sprite_animations )
1432+ 56D4              ; sets active flag to 0
1433+ 56D4              ANIMSTOP:
1434+ 56D4 11 44 57         LD DE,ANIMSTARTSTOP_COMMON.STOP
1435+ 56D7              ; *******************************************************************************************************
1436+ 56D7              ANIMSTARTSTOP_COMMON:
1437+ 56D7 ED 53 35 57      LD (ANIMSTARTSTOP_COMMON.FN+1),DE
1438+ 56DB                  ; opening (
1439+ 56DB CD 7F 69     	CALL CHKCHAR
1440+ 56DE 28           	DB '('
1441+ 56DF              	; get sprite animation id or array size
1442+ 56DF DD 21 1C 52  	LD IX,GETBYT
1443+ 56E3 CD 59 01     	CALL CALBAS
1444+ 56E6 F5               PUSH AF
1445+ 56E7                  ; check if comma present
1446+ 56E7 CD 89 69         CALL GETPREVCHAR
1447+ 56EA 23               INC HL
1448+ 56EB FE 2C            CP ','
1449+ 56ED 28 0E            JR Z,.L1
1450+ 56EF FE 29            CP ')'
1451+ 56F1 C2 A3 69         JP NZ,SYNTAX_ERROR
1452+ 56F4                  ; ok so single argument variant
1453+ 56F4 F1               POP AF
1454+ 56F5 E5               PUSH HL
1455+ 56F6 F3               DI
1456+ 56F7 CD 23 57         CALL .SETVALUE
1457+ 56FA FB               EI
1458+ 56FB E1               POP HL
1459+ 56FC C9               RET
1460+ 56FD              .L1:
1461+ 56FD                  ; get array pointer
1462+ 56FD D1               POP DE
1463+ 56FE D5               PUSH DE
1464+ 56FF 3E 02            LD A,2
1465+ 5701 06 01            LD B,1
1466+ 5703 CD AC 69         CALL GET_BASIC_ARRAY_DATA_POINTER
1467+ 5706 C5               PUSH BC
1468+ 5707              	; ending )
1469+ 5707 CD 7F 69     	CALL CHKCHAR
1470+ 570A 29           	DB ')'
1471+ 570B D1               POP DE ; array pointer
1472+ 570C C1               POP BC ; number of items
1473+ 570D 78               LD A,B
1474+ 570E B7               OR A
1475+ 570F CA 97 69         JP Z,SUBSCRIPT_OUT_OF_RANGE
1476+ 5712 E5               PUSH HL
1477+ 5713 F3               DI
1478+ 5714              .L2:
1479+ 5714 C5               PUSH BC
1480+ 5715 1A               LD A,(DE)
1481+ 5716 13          > INC DE
1481+ 5717 13          > INC DE
1482+ 5718 D5               PUSH DE
1483+ 5719 CD 23 57         CALL .SETVALUE
1484+ 571C D1               POP DE
1485+ 571D C1               POP BC
1486+ 571E 10 F4            DJNZ .L2
1487+ 5720 FB               EI
1488+ 5721 E1               POP HL
1489+ 5722 C9               RET
1490+ 5723
1491+ 5723              .SETVALUE:
1492+ 5723 47               LD B,A
1493+ 5724 3C               INC A
1494+ 5725 4F               LD C,A
1495+ 5726 3A 9A 4F         LD A,(ANIMSPRNUM)
1496+ 5729 B9               CP C
1497+ 572A DA 97 69         JP C,SUBSCRIPT_OUT_OF_RANGE
1498+ 572D 78               LD A,B
1499+ 572E CD BE 4F         CALL GETnthSPRANIM
1500+ 5731 E5               PUSH HL
1501+ 5732 DD E1            POP IX
1502+ 5734              .FN:
1503+ 5734 C3 00 00         JP 0
1504+ 5737              .START:
1505+ 5737 DD 36 06 01      LD (IX+6),1 ; active flag
1506+ 573B DD 36 03 00      LD (IX+3),0 ; current item
1507+ 573F 06 00            LD B,0 ; setup timer
1508+ 5741 C3 30 58         JP SETUP_ANIM_STEP
1509+ 5744              .STOP:
1510+ 5744 DD 36 06 00      LD (IX+6),0 ; active flag
1511+ 5748 C9               RET
1512+ 5749              .STEP:
1513+ 5749 06 00            LD B,0
1514+ 574B C3 D4 57         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1515+ 574E              ; *******************************************************************************************************
1516+ 574E               ENDIF
1517+ 574E
1518+ 574E               IF (DEFUSR_EXTENSION == 1)
1519+ 574E              ; *******************************************************************************************************
1520+ 574E              ; helper function to locate single animation and execute operation
1521+ 574E              ; needs to have jump set to a correct function
1522+ 574E              ; input A=animation item
1523+ 574E              ANIM_SETVALUE:
1524+ 574E 47               LD B,A
1525+ 574F 3C               INC A
1526+ 5750 4F               LD C,A
1527+ 5751 3A 9A 4F         LD A,(ANIMSPRNUM)
1528+ 5754 B9               CP C
1529+ 5755 D8               RET C ; out of range, so do nothing
1530+ 5756 78               LD A,B
1531+ 5757 CD BE 4F         CALL GETnthSPRANIM
1532+ 575A E5               PUSH HL
1533+ 575B DD E1            POP IX
1534+ 575D              .FN:
1535+ 575D C3 00 00         JP 0
1536+ 5760              ; *******************************************************************************************************
1537+ 5760
1538+ 5760              ; *******************************************************************************************************
1539+ 5760              ; helper function to set values of multiple animations
1540+ 5760              ; needs to have jump set to a correct function
1541+ 5760              ; input B=number of animation item
1542+ 5760              ; input DE=animation item array
1543+ 5760              ANIM_LIST_SETVALUE:
1544+ 5760 F3               DI
1545+ 5761 C5               PUSH BC
1546+ 5762 1A               LD A,(DE)
1547+ 5763 13          > INC DE
1547+ 5764 13          > INC DE
1548+ 5765 D5               PUSH DE
1549+ 5766 CD 4E 57         CALL ANIM_SETVALUE
1550+ 5769 D1               POP DE
1551+ 576A C1               POP BC
1552+ 576B 10 F3            DJNZ ANIM_LIST_SETVALUE
1553+ 576D FB               EI
1554+ 576E C9               RET
1555+ 576F              ; *******************************************************************************************************
1556+ 576F
1557+ 576F              ; *******************************************************************************************************
1558+ 576F              ; function to handle single item ANIMSTEP in DEFUSR mode
1559+ 576F              ; input IX=pointer to input array, real data from +2
1560+ 576F              ; +2 = animation id
1561+ 576F              ANIMSTEP_SINGLE_DEFUSR:
1562+ 576F 21 7A 57         LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1563+ 5772              .L1:
1564+ 5772 22 5E 57         LD (ANIM_SETVALUE.FN+1),HL
1565+ 5775 DD 7E 02         LD A,(IX+2)
1566+ 5778 18 D4            JR ANIM_SETVALUE
1567+ 577A              .STEP:
1568+ 577A 06 00            LD B,0
1569+ 577C C3 D4 57         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1570+ 577F              ; *******************************************************************************************************
1571+ 577F
1572+ 577F              ; *******************************************************************************************************
1573+ 577F              ; function to handle multi item ANIMSTEP in DEFUSR mode
1574+ 577F              ; input IX=pointer to input array, real data from +2
1575+ 577F              ; +2 = list size
1576+ 577F              ; +4 = array pointer holding items
1577+ 577F              ANIMSTEP_MULTI_DEFUSR:
1578+ 577F 21 7A 57         LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1579+ 5782              .L1:
1580+ 5782 22 5E 57         LD (ANIM_SETVALUE.FN+1),HL
1581+ 5785 DD 46 02         LD B,(IX+2)
1582+ 5788 DD 5E 04         LD E,(IX+4)
1583+ 578B DD 56 05         LD D,(IX+5)
1584+ 578E 18 D0            JR ANIM_LIST_SETVALUE
1585+ 5790              ; *******************************************************************************************************
1586+ 5790
1587+ 5790              ; *******************************************************************************************************
1588+ 5790              ; function to handle single item ANIMSTART in DEFUSR mode
1589+ 5790              ; input IX=pointer to input array, real data from +2
1590+ 5790              ; +2 = animation id
1591+ 5790              ANIMSTART_SINGLE_DEFUSR:
1592+ 5790 21 95 57         LD HL,ANIMSTART_SINGLE_DEFUSR.START
1593+ 5793 18 DD            JR ANIMSTEP_SINGLE_DEFUSR.L1
1594+ 5795              .START:
1595+ 5795 DD 36 06 01      LD (IX+6),1 ; active flag
1596+ 5799 DD 36 03 00      LD (IX+3),0 ; current item
1597+ 579D 06 00            LD B,0 ; setup timer
1598+ 579F C3 30 58         JP SETUP_ANIM_STEP
1599+ 57A2              ; *******************************************************************************************************
1600+ 57A2
1601+ 57A2              ; *******************************************************************************************************
1602+ 57A2              ; function to handle multi item ANIMSTART in DEFUSR mode
1603+ 57A2              ; input IX=pointer to input array, real data from +2
1604+ 57A2              ; +2 = list size
1605+ 57A2              ; +4 = array pointer holding items
1606+ 57A2              ANIMSTART_MULTI_DEFUSR:
1607+ 57A2 21 95 57         LD HL,ANIMSTART_SINGLE_DEFUSR.START
1608+ 57A5 18 DB            JR ANIMSTEP_MULTI_DEFUSR.L1
1609+ 57A7              ; *******************************************************************************************************
1610+ 57A7
1611+ 57A7              ; *******************************************************************************************************
1612+ 57A7              ; function to handle single item ANIMSTOP in DEFUSR mode
1613+ 57A7              ; input IX=pointer to input array, real data from +2
1614+ 57A7              ; +2 = animation id
1615+ 57A7              ANIMSTOP_SINGLE_DEFUSR:
1616+ 57A7 21 AC 57         LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1617+ 57AA 18 C6            JR ANIMSTEP_SINGLE_DEFUSR.L1
1618+ 57AC              .STOP:
1619+ 57AC DD 36 06 00      LD (IX+6),0 ; active flag
1620+ 57B0 C9               RET
1621+ 57B1              ; *******************************************************************************************************
1622+ 57B1
1623+ 57B1              ; *******************************************************************************************************
1624+ 57B1              ; function to handle multi item ANIMSTOP in DEFUSR mode
1625+ 57B1              ; input IX=pointer to input array, real data from +2
1626+ 57B1              ; +2 = list size
1627+ 57B1              ; +4 = array pointer holding items
1628+ 57B1              ANIMSTOP_MULTI_DEFUSR:
1629+ 57B1 21 AC 57         LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1630+ 57B4 18 CC            JR ANIMSTEP_MULTI_DEFUSR.L1
1631+ 57B6              ; *******************************************************************************************************
1632+ 57B6               ENDIF
1633+ 57B6
1634+ 57B6              ; *******************************************************************************************************
1635+ 57B6              ; function processes animations during vblank period
1636+ 57B6              PROCESS_ANIMATIONS:
1637+ 57B6 3A 9A 4F         LD A,(ANIMSPRNUM)
1638+ 57B9 B7               OR A
1639+ 57BA C8               RET Z; no animations defined
1640+ 57BB 47               LD B,A
1641+ 57BC DD 2A 9B 4F      LD IX,(ANIMSPRPTR)
1642+ 57C0              .L1:
1643+ 57C0 C5               PUSH BC
1644+ 57C1 06 00            LD B,0 ; normal mode, change on timer expiry only
1645+ 57C3 CD CF 57         CALL PROCESS_SINGLE_ANIMATION
1646+ 57C6 11 08 00         LD DE,8
1647+ 57C9 DD 19            ADD IX,DE
1648+ 57CB C1               POP BC
1649+ 57CC 10 F2            DJNZ .L1
1650+ 57CE C9               RET
1651+ 57CF              ; *******************************************************************************************************
1652+ 57CF
1653+ 57CF              ; *******************************************************************************************************
1654+ 57CF              ; processes single sprite animation
1655+ 57CF              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
1656+ 57CF              ; on timer expiry goes to next animation item
1657+ 57CF              ; input IX=sprite animation pointer
1658+ 57CF              ; input B=1 force mode, activate animation action regardless of expired timer
1659+ 57CF              PROCESS_SINGLE_ANIMATION:
1660+ 57CF DD 7E 06         LD A,(IX+6); active
1661+ 57D2 B7               OR A
1662+ 57D3 C8               RET Z ; inactive animation
1663+ 57D4              .INACTIVE_TOO:
1664+ 57D4 DD 6E 01         LD L,(IX+1)
1665+ 57D7 DD 66 02         LD H,(IX+2) ; HL=end time
1666+ 57DA 2B               DEC HL
1667+ 57DB DD 75 01         LD (IX+1),L
1668+ 57DE DD 74 02         LD (IX+2),H
1669+ 57E1 7D               LD A,L
1670+ 57E2 B4               OR H
1671+ 57E3 28 06            JR Z,.STEP
1672+ 57E5 05               DEC B
1673+ 57E6 04               INC B
1674+ 57E7 C8               RET Z ; not forced mode, return
1675+ 57E8 C3 30 58         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
1676+ 57EB              .STEP:
1677+ 57EB 06 00            LD B,0; setup timer
1678+ 57ED DD 34 03         INC (IX+3) ; current animation item
1679+ 57F0 C3 30 58         JP SETUP_ANIM_STEP
1680+ 57F3              ; *******************************************************************************************************
1681+ 57F3
1682+ 57F3              ; *******************************************************************************************************
1683+ 57F3              ; function will setup sprite animation after current item change
1684+ 57F3              ; input A=current animation definition
1685+ 57F3              ; input IX=pointer to sprite animation
1686+ 57F3              ; input B=1 skip timer setup
1687+ 57F3              ; output IY=pointer to animation item
1688+ 57F3              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
1689+ 57F3              ; basically sets new end time for current animation
1690+ 57F3              INIT_CURRENT_ANIMATION:
1691+ 57F3 CD B2 4F         CALL GETnthANIMDEF
1692+ 57F6 DD 7E 03         LD A,(IX+3) ; current animation item
1693+ 57F9 BE               CP (HL) ; number of animation items in the animation definition
1694+ 57FA 38 0A            JR C,.L3 ; last item not reached
1695+ 57FC                  ; last item reached
1696+ 57FC DD 7E 05         LD A,(IX+5) ; cyclic flag
1697+ 57FF B7               OR A
1698+ 5800 28 2C            JR Z,.ERROR ; non-cyclic animation
1699+ 5802                  ; cyclic animation, restart
1700+ 5802 DD 36 03 00      LD (IX+3),0; current item
1701+ 5806              .L3:
1702+ 5806                  ; HL = animation definition
1703+ 5806 23               INC HL ; skip animation definition size field
1704+ 5807 16 00            LD D,0
1705+ 5809 DD 5E 03         LD E,(IX+3); current item
1706+ 580C 19               ADD HL,DE
1707+ 580D 4E               LD C,(HL) ; current animation item
1708+ 580E 0C               INC C
1709+ 580F 3A 94 4F         LD A,(ANIMITEMNUM)
1710+ 5812 B9               CP C
1711+ 5813 38 19            JR C,.ERROR ; invalid animation item, stop animation
1712+ 5815 0D               DEC C
1713+ 5816 79               LD A,C
1714+ 5817 CD A9 4F         CALL GETnthANIMITEM
1715+ 581A E5               PUSH HL
1716+ 581B FD E1            POP IY ; IY=animation item
1717+ 581D 05               DEC B
1718+ 581E 28 0C            JR Z,.EXIT
1719+ 5820 FD 5E 01         LD E,(IY+1)
1720+ 5823 FD 56 02         LD D,(IY+2) ; duration
1721+ 5826 DD 73 01         LD (IX+1),E
1722+ 5829 DD 72 02         LD (IX+2),D
1723+ 582C              .EXIT:
1724+ 582C AF               XOR A
1725+ 582D C9               RET
1726+ 582E              .ERROR:
1727+ 582E 37               SCF
1728+ 582F C9               RET
1729+ 5830              ; *******************************************************************************************************
1730+ 5830
1731+ 5830              ; *******************************************************************************************************
1732+ 5830              ; function will display currect item and set up expiry time
1733+ 5830              ; it will also stop the animation if expired
1734+ 5830              ; sets sprite update flag if any changes in sprite data made
1735+ 5830              ; input IX=current sprite animation
1736+ 5830              ; input B=1 skip timer setup
1737+ 5830              SETUP_ANIM_STEP:
1738+ 5830 DD 4E 04         LD C,(IX+4) ; animation definition ID
1739+ 5833 0C               INC C
1740+ 5834 3A 97 4F         LD A,(ANIMDEFNUM)
1741+ 5837 B9               CP C
1742+ 5838 30 05            JR NC,.L2
1743+ 583A                  ; given animation item is outside of bounds, deactivate animation
1744+ 583A              .STOPANIM:
1745+ 583A DD 36 06 00      LD (IX+6),0
1746+ 583E C9               RET
1747+ 583F              .L2:
1748+ 583F 0D               DEC C
1749+ 5840 79               LD A,C
1750+ 5841 CD F3 57         CALL INIT_CURRENT_ANIMATION
1751+ 5844 38 F4            JR C, .STOPANIM
1752+ 5846 FD 7E 00         LD A,(IY) ; type of animation item
1753+ 5849 B7               OR A
1754+ 584A 28 44            JR Z,.L4 ; change pattern and/or color
1755+ 584C              .PAT:
1756+ 584C                  ; change pattern definition
1757+ 584C                  ; check if sprite or character
1758+ 584C DD 7E 07         LD A,(IX+7)
1759+ 584F B7               OR A
1760+ 5850 20 58            JR NZ,.CHAR
1761+ 5852 DD 7E 00         LD A,(IX) ; sprite number
1762+ 5855 CD 89 4D         CALL GETnthSPRATTR
1763+ 5858 23          > INC HL ; skip y and x
1763+ 5859 23          > INC HL
1763+ 585A 23          > INC HL
1763+ 585B 23          > INC HL
1764+ 585C 7E               LD A,(HL); current pattern
1765+ 585D 26 00            LD H,0
1766+ 585F 6F               LD L,A
1767+ 5860 3A E0 F3         LD A,(REG1SAV)
1768+ 5863 E6 02            AND 2
1769+ 5865 20 07            JR NZ,.L6
1770+ 5867                  ; 8x8 sprite
1771+ 5867 CD 6D 68         CALL HLx8
1772+ 586A 06 08            LD B,8
1773+ 586C 18 05            JR .L5
1774+ 586E              .L6:
1775+ 586E CD 6B 68         CALL HLx32
1776+ 5871 06 20            LD B,32
1777+ 5873              .L5:
1778+ 5873 3A AF FC         LD A,(SCRMOD)
1779+ 5876 3D               DEC A
1780+ 5877 20 06            JR NZ,.L10
1781+ 5879 ED 5B C5 F3      LD DE,(T32PAT)
1782+ 587D 18 04            JR .L7
1783+ 587F              .L10:
1784+ 587F ED 5B CF F3      LD DE,(GRPPAT)
1785+ 5883              .L7:
1786+ 5883 19               ADD HL,DE
1787+ 5884 CD 58 68         CALL SETWRT_LOCAL
1788+ 5887 FD 6E 03         LD L,(IY+3)
1789+ 588A FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
1790+ 588D C3 63 68         JP BBYTECOPY
1791+ 5890              .L4:
1792+ 5890                  ; change pattern and color in sprite attributes table
1793+ 5890 DD 7E 00         LD A,(IX) ; sprite number
1794+ 5893 CD 89 4D         CALL GETnthSPRATTR
1795+ 5896 23          > INC HL ; skip y and x
1795+ 5897 23          > INC HL
1795+ 5898 23          > INC HL
1795+ 5899 23          > INC HL
1796+ 589A FD 7E 03         LD A,(IY+3) ; new pattern
1797+ 589D 77               LD (HL),A
1798+ 589E 23          > INC HL
1798+ 589F 23          > INC HL
1799+ 58A0 FD 7E 04         LD A,(IY+4) ; new color
1800+ 58A3 77               LD (HL),A
1801+ 58A4 2A 80 4D         LD HL,(SPRATR_UPDATE_FLAG)
1802+ 58A7 36 01            LD (HL),1
1803+ 58A9 C9               RET
1804+ 58AA              .CHAR:
1805+ 58AA DD 6E 00         LD L,(IX)
1806+ 58AD 3D               DEC A
1807+ 58AE 67               LD H,A
1808+ 58AF CD 6D 68         CALL HLx8
1809+ 58B2 3A AF FC         LD A,(SCRMOD)
1810+ 58B5 3D               DEC A
1811+ 58B6 20 06            JR NZ,.L8
1812+ 58B8 ED 5B C1 F3      LD DE,(T32CGP)
1813+ 58BC 18 04            JR .L9
1814+ 58BE              .L8:
1815+ 58BE ED 5B CB F3      LD DE,(GRPCGP)
1816+ 58C2              .L9:
1817+ 58C2 06 08            LD B,8
1818+ 58C4 18 BD            JR .L7
1819+ 58C6              ; *******************************************************************************************************
1820+ 58C6
# file closed: asm\ANIMATION.asm
 134  58C6               INCLUDE "SGAM.asm"
# file opened: asm\SGAM.asm
   1+ 58C6              ; Sprite Group Animate and Move
   2+ 58C6
   3+ 58C6              ; *******************************************************************************************************
   4+ 58C6              ; shared function to process a list of animations
   5+ 58C6              ; input B=list size
   6+ 58C6              ; input DE=list pointer
   7+ 58C6              SGAM_PROCESS_ANIM_LIST:
   8+ 58C6 21 D9 58         LD HL,.STEP
   9+ 58C9 22 35 57         LD (ANIMSTARTSTOP_COMMON.FN+1),HL
  10+ 58CC              .L1:
  11+ 58CC C5               PUSH BC
  12+ 58CD 1A               LD A,(DE)
  13+ 58CE 13          > INC DE
  13+ 58CF 13          > INC DE
  14+ 58D0 D5               PUSH DE
  15+ 58D1 CD 23 57         CALL ANIMSTARTSTOP_COMMON.SETVALUE
  16+ 58D4 D1               POP DE
  17+ 58D5 C1               POP BC
  18+ 58D6 10 F4            DJNZ .L1
  19+ 58D8 C9           	RET
  20+ 58D9              .STEP:
  21+ 58D9 06 01            LD B,1
  22+ 58DB C3 D4 57         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
  23+ 58DE              ; *******************************************************************************************************
  24+ 58DE
  25+ 58DE               IF (BASIC_EXTENSION == 1)
  26+ 58DE              ; *******************************************************************************************************
  27+ 58DE              ; function to handle CALL SGAM basic extension
  28+ 58DE              ; sets position of a group of sprites as described in SPRGRPMOV
  29+ 58DE              ; and manually animate a list of animations
  30+ 58DE              ; _SGAM ( INT x,
  31+ 58DE              ;	      INT y,
  32+ 58DE              ;		  BYTE count,
  33+ 58DE              ;		  INT[2][count] data_ptr,
  34+ 58DE              ;         BYTE item_number,
  35+ 58DE              ;         INT[] sprite_animations )
  36+ 58DE              ; will put ram in page 0 also, page 1 is already there
  37+ 58DE              SGAM:
  38+ 58DE 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
  39+ 58E1 B7           	OR A
  40+ 58E2 CA 9F 69     	JP Z,ILLEGAL_FUNCTION
  41+ 58E5              	; opening (
  42+ 58E5 CD 7F 69     	CALL CHKCHAR
  43+ 58E8 28           	DB '('
  44+ 58E9              	; get x
  45+ 58E9 DD 21 2F 54  	LD IX, FRMQNT
  46+ 58ED CD 59 01     	CALL CALBAS
  47+ 58F0 ED 53 70 66  	LD (BLIT_STRUCT),DE
  48+ 58F4              	; comma
  49+ 58F4 CD 7F 69     	CALL CHKCHAR
  50+ 58F7 2C           	DB ','
  51+ 58F8              	; get y
  52+ 58F8 DD 21 2F 54  	LD IX, FRMQNT
  53+ 58FC CD 59 01     	CALL CALBAS
  54+ 58FF ED 53 72 66  	LD (BLIT_STRUCT+2),DE
  55+ 5903              	; comma
  56+ 5903 CD 7F 69     	CALL CHKCHAR
  57+ 5906 2C           	DB ','
  58+ 5907              	; get count
  59+ 5907 DD 21 1C 52  	LD IX, GETBYT
  60+ 590B CD 59 01     	CALL CALBAS
  61+ 590E B7               OR A
  62+ 590F CA 97 69         JP Z,SUBSCRIPT_OUT_OF_RANGE
  63+ 5912 32 74 66     	LD (BLIT_STRUCT+4),A
  64+ 5915              	; comma
  65+ 5915 CD 7F 69     	CALL CHKCHAR
  66+ 5918 2C           	DB ','
  67+ 5919              	; get sprite group definition array data pointer
  68+ 5919 3A 74 66         LD A,(BLIT_STRUCT+4)
  69+ 591C 5F           	LD E,A
  70+ 591D 16 03        	LD D,3
  71+ 591F 3E 02        	LD A,2
  72+ 5921 47           	LD B,A
  73+ 5922 CD AC 69     	CALL GET_BASIC_ARRAY_DATA_POINTER
  74+ 5925 ED 43 75 66  	LD (BLIT_STRUCT+5),BC
  75+ 5929              	; comma
  76+ 5929 CD 7F 69     	CALL CHKCHAR
  77+ 592C 2C           	DB ','
  78+ 592D              	; get sprite animation array size
  79+ 592D DD 21 1C 52  	LD IX,GETBYT
  80+ 5931 CD 59 01     	CALL CALBAS
  81+ 5934 32 77 66         LD (BLIT_STRUCT+7),A
  82+ 5937 B7               OR A
  83+ 5938 CA 97 69         JP Z,SUBSCRIPT_OUT_OF_RANGE
  84+ 593B              	; comma
  85+ 593B CD 7F 69     	CALL CHKCHAR
  86+ 593E 2C           	DB ','
  87+ 593F                  ; get array pointer
  88+ 593F 3A 77 66         LD A,(BLIT_STRUCT+7)
  89+ 5942 57               LD D,A
  90+ 5943 3E 02            LD A,2
  91+ 5945 06 01            LD B,1
  92+ 5947 CD AC 69         CALL GET_BASIC_ARRAY_DATA_POINTER
  93+ 594A ED 43 78 66      LD (BLIT_STRUCT+8),BC
  94+ 594E              	; ending )
  95+ 594E CD 7F 69     	CALL CHKCHAR
  96+ 5951 29           	DB ')'
  97+ 5952              .ENTRY:
  98+ 5952 E5               PUSH HL
  99+ 5953 F3               DI
 100+ 5954
 101+ 5954              	; enable page 0
 102+ 5954 FD 21 5B 59  	LD IY, .RET
 103+ 5958 C3 31 69     	JP ENABLE_PAGE0
 104+ 595B              .RET:
 105+ 595B D9               EXX
 106+ 595C ED 5B 70 66      LD DE,(BLIT_STRUCT) ; initial x
 107+ 5960 ED 4B 72 66      LD BC,(BLIT_STRUCT+2) ; initial y
 108+ 5964 D9               EXX
 109+ 5965 2A 75 66         LD HL,(BLIT_STRUCT+5) ; pointer to data
 110+ 5968 3A 74 66         LD A,(BLIT_STRUCT+4) ; number of entries
 111+ 596B 47               LD B,A
 112+ 596C CD FD 4E         CALL SPR_UPDATE_LOC
 113+ 596F
 114+ 596F 3A 77 66         LD A,(BLIT_STRUCT+7) ; anim number
 115+ 5972 47               LD B,A
 116+ 5973 ED 5B 78 66      LD DE,(BLIT_STRUCT+8) ; anim list
 117+ 5977 CD C6 58     	CALL SGAM_PROCESS_ANIM_LIST
 118+ 597A
 119+ 597A D1               POP DE
 120+ 597B C1               POP BC
 121+ 597C CD A8 68         CALL RESTORE_PAGE_INFO
 122+ 597F FB               EI
 123+ 5980 E1               POP HL
 124+ 5981 C9               RET
 125+ 5982              ; *******************************************************************************************************
 126+ 5982               ENDIF
 127+ 5982
 128+ 5982               IF (DEFUSR_EXTENSION == 1)
 129+ 5982              ; *******************************************************************************************************
 130+ 5982              ; same as SGAM but for DEFUSR approach
 131+ 5982              ; input IX=pointer to input array, real data from +2
 132+ 5982              ; +02 = X
 133+ 5982              ; +04 = Y
 134+ 5982              ; +06 = count
 135+ 5982              ; +08 = data pointer
 136+ 5982              ; +10 = anim number
 137+ 5982              ; +12 = sprite animations
 138+ 5982              SGAM_DEFUSR:
 139+ 5982              	; enable page 0
 140+ 5982 F3           	DI
 141+ 5983 FD 21 8A 59  	LD IY, .RET
 142+ 5987 C3 31 69     	JP ENABLE_PAGE0
 143+ 598A              .RET:
 144+ 598A FB           	EI
 145+ 598B D9               EXX
 146+ 598C DD 5E 02     	LD E,(IX+2)
 147+ 598F DD 56 03     	LD D,(IX+3) ; initial x
 148+ 5992 DD 4E 04     	LD C,(IX+4)
 149+ 5995 DD 46 05     	LD B,(IX+5) ; initial y
 150+ 5998 D9               EXX
 151+ 5999 DD 6E 08     	LD L,(IX+8)
 152+ 599C DD 66 09     	LD H,(IX+9) ; pointer to data
 153+ 599F DD 46 06         LD B,(IX+6) ; count
 154+ 59A2 DD E5        	PUSH IX
 155+ 59A4 CD FD 4E         CALL SPR_UPDATE_LOC
 156+ 59A7 DD E1        	POP IX
 157+ 59A9 DD 46 0A         LD B,(IX+10) ; anim number
 158+ 59AC DD 5E 0C     	LD E,(IX+12)
 159+ 59AF DD 56 0D     	LD D,(IX+13)
 160+ 59B2 CD C6 58     	CALL SGAM_PROCESS_ANIM_LIST
 161+ 59B5
 162+ 59B5 D1               POP DE
 163+ 59B6 C1               POP BC
 164+ 59B7 C3 A8 68         JP RESTORE_PAGE_INFO
 165+ 59BA              ; *******************************************************************************************************
 166+ 59BA               ENDIF
 167+ 59BA
 168+ 59BA              ; *******************************************************************************************************
 169+ 59BA              ; handles automatic move and animate sprite groups during interrupt
 170+ 59BA              PROCESS_AUTOSGAMS:
 171+ 59BA 3A 9D 4F     	LD A,(AUTOSGAMNUM)
 172+ 59BD B7           	OR A
 173+ 59BE C8           	RET Z
 174+ 59BF 47           	LD B,A
 175+ 59C0 DD 2A 9E 4F  	LD IX,(AUTOSGAMPTR)
 176+ 59C4              .L1:
 177+ 59C4 C5           	PUSH BC
 178+ 59C5 DD 7E 13     	LD A,(IX+19) ; active flag
 179+ 59C8 B7           	OR A
 180+ 59C9 28 28        	JR Z,.LOOPEND
 181+ 59CB              	; active, check timer
 182+ 59CB DD 6E 16     	LD L,(IX+22)
 183+ 59CE DD 66 17     	LD H,(IX+23) ; timer
 184+ 59D1 2B           	DEC HL
 185+ 59D2 7C           	LD A,H
 186+ 59D3 B5           	OR L
 187+ 59D4 28 08        	JR Z,.L2
 188+ 59D6              	; not expired
 189+ 59D6 DD 75 16     	LD (IX+22),L
 190+ 59D9 DD 74 17     	LD (IX+23),H
 191+ 59DC 18 15        	JR .LOOPEND
 192+ 59DE              .L2:
 193+ 59DE              	; expired, process
 194+ 59DE
 195+ 59DE                  ; set initial timer
 196+ 59DE DD 7E 14         LD A,(IX+20)
 197+ 59E1 DD 77 16         LD (IX+22),A
 198+ 59E4 DD 7E 15         LD A,(IX+21)
 199+ 59E7 DD 77 17         LD (IX+23),A
 200+ 59EA
 201+ 59EA CD FC 59     	CALL .MOVE
 202+ 59ED CD 67 5A     	CALL .UPDATELOC
 203+ 59F0 CD 8C 5A     	CALL .PROCESS_ANIM_LIST
 204+ 59F3
 205+ 59F3              .LOOPEND:
 206+ 59F3 11 18 00     	LD DE,24
 207+ 59F6 DD 19        	ADD IX,DE
 208+ 59F8 C1           	POP BC
 209+ 59F9 10 C9        	DJNZ .L1
 210+ 59FB C9           	RET
 211+ 59FC
 212+ 59FC              .MOVE:
 213+ 59FC              	; process movement
 214+ 59FC DD 7E 0A     	LD A,(IX+10) ; direction
 215+ 59FF B7           	OR A
 216+ 5A00 28 08        	JR Z, .MOVE_L1
 217+ 5A02              	; vertical
 218+ 5A02 DD 6E 02     	LD L,(IX+2)
 219+ 5A05 DD 66 03     	LD H,(IX+3) ; vertical variable pointer
 220+ 5A08 18 06        	JR .MOVE_L2
 221+ 5A0A              .MOVE_L1:
 222+ 5A0A              	; horizontal
 223+ 5A0A DD 6E 00     	LD L,(IX+0)
 224+ 5A0D DD 66 01     	LD H,(IX+1) ; horizontal variable pointer
 225+ 5A10              .MOVE_L2:
 226+ 5A10 E5           	PUSH HL
 227+ 5A11 FD E1        	POP IY
 228+ 5A13 FD 6E 00     	LD L,(IY+0)
 229+ 5A16 FD 66 01     	LD H,(IY+1)
 230+ 5A19 DD 5E 08     	LD E,(IX+8)
 231+ 5A1C DD 56 09     	LD D,(IX+9) ; delta value
 232+ 5A1F 19           	ADD HL,DE
 233+ 5A20 E5           	PUSH HL
 234+ 5A21 DD 5E 04     	LD E,(IX+4)
 235+ 5A24 DD 56 05     	LD D,(IX+5) ; minimum value
 236+ 5A27 A7           	AND A
 237+ 5A28 ED 52        	SBC HL,DE
 238+ 5A2A FA 44 5A     	JP M,.MOVE_L3 ; below minimum
 239+ 5A2D E1           	POP HL
 240+ 5A2E E5           	PUSH HL
 241+ 5A2F DD 5E 06     	LD E,(IX+6)
 242+ 5A32 DD 56 07     	LD D,(IX+7) ; maximum value
 243+ 5A35 EB           	EX DE,HL
 244+ 5A36 A7           	AND A
 245+ 5A37 ED 52        	SBC HL,DE
 246+ 5A39 FA 4C 5A     	JP M,.MOVE_L4 ; above maximum
 247+ 5A3C E1           	POP HL
 248+ 5A3D              	; within bounds
 249+ 5A3D              .MOVE_L5:
 250+ 5A3D FD 75 00     	LD (IY+0),L
 251+ 5A40 FD 74 01     	LD (IY+1),H
 252+ 5A43 C9           	RET
 253+ 5A44              .MOVE_L3:
 254+ 5A44 E1           	POP HL
 255+ 5A45 CD 58 5A     	CALL .INVERSE_DELTA
 256+ 5A48 6B           	LD L,E
 257+ 5A49 62           	LD H,D
 258+ 5A4A 18 F1        	JR .MOVE_L5
 259+ 5A4C              .MOVE_L4:
 260+ 5A4C E1           	POP HL
 261+ 5A4D CD 58 5A     	CALL .INVERSE_DELTA
 262+ 5A50 DD 6E 06     	LD L,(IX+6)
 263+ 5A53 DD 66 07     	LD H,(IX+7) ; maximum
 264+ 5A56 18 E5        	JR .MOVE_L5
 265+ 5A58              .INVERSE_DELTA:
 266+ 5A58 AF           	XOR A
 267+ 5A59 DD 96 08     	SUB (IX+8)
 268+ 5A5C DD 77 08     	LD (IX+8),A
 269+ 5A5F 9F           	SBC A,A
 270+ 5A60 DD 96 09     	SUB (IX+9)
 271+ 5A63 DD 77 09     	LD (IX+9),A
 272+ 5A66 C9           	RET
 273+ 5A67
 274+ 5A67              .UPDATELOC:
 275+ 5A67 DD E5        	PUSH IX
 276+ 5A69 D9           	EXX
 277+ 5A6A DD 6E 00     	LD L,(IX+0)
 278+ 5A6D DD 66 01     	LD H,(IX+1)
 279+ 5A70 5E           	LD E,(HL)
 280+ 5A71 23           	INC HL
 281+ 5A72 56           	LD D,(HL)
 282+ 5A73 DD 6E 02     	LD L,(IX+2)
 283+ 5A76 DD 66 03     	LD H,(IX+3)
 284+ 5A79 4E           	LD C,(HL)
 285+ 5A7A 23           	INC HL
 286+ 5A7B 46           	LD B,(HL)
 287+ 5A7C D9           	EXX
 288+ 5A7D DD 6E 0C     	LD L,(IX+12)
 289+ 5A80 DD 66 0D     	LD H,(IX+13) ; pointer to sprite group data
 290+ 5A83 DD 46 0B     	LD B,(IX+11) ; sprite group size
 291+ 5A86 CD FD 4E     	CALL SPR_UPDATE_LOC
 292+ 5A89 DD E1        	POP IX
 293+ 5A8B C9           	RET
 294+ 5A8C
 295+ 5A8C              .PROCESS_ANIM_LIST:
 296+ 5A8C DD E5        	PUSH IX
 297+ 5A8E DD 46 0E         LD B,(IX+14) ; anim list size
 298+ 5A91 DD CB 09 7E  	BIT 7,(IX+9)
 299+ 5A95 28 08        	JR Z,.PROCESS_ANIM_LIST_L1
 300+ 5A97              	; negative direction
 301+ 5A97 DD 5E 0F     	LD E,(IX+15)
 302+ 5A9A DD 56 10     	LD D,(IX+16)
 303+ 5A9D 18 06        	JR .PROCESS_ANIM_LIST_L2
 304+ 5A9F              .PROCESS_ANIM_LIST_L1:
 305+ 5A9F              	; positive direction
 306+ 5A9F DD 5E 11     	LD E,(IX+17)
 307+ 5AA2 DD 56 12     	LD D,(IX+18)
 308+ 5AA5              .PROCESS_ANIM_LIST_L2:
 309+ 5AA5 CD C6 58     	CALL SGAM_PROCESS_ANIM_LIST
 310+ 5AA8 DD E1        	POP IX
 311+ 5AAA C9           	RET
 312+ 5AAB              ; *******************************************************************************************************
 313+ 5AAB
# file closed: asm\SGAM.asm
 135  5AAB               ENDIF
 136  5AAB
 137  5AAB               IF (RAM_CMDS == 1)
 138  5AAB               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
   1+ 5AAB               IF (BASIC_EXTENSION == 1)
   2+ 5AAB              ; *******************************************************************************************************
   3+ 5AAB              ; function to handle CALL MEMCPY basic extension
   4+ 5AAB              ; _MEMCPY ( INT source,
   5+ 5AAB              ;			INT destination,
   6+ 5AAB              ;			INT count,
   7+ 5AAB              ; will put ram in page 0 also, page 1 is already there
   8+ 5AAB              MEMCPY:
   9+ 5AAB              	; opening (
  10+ 5AAB CD 7F 69     	CALL CHKCHAR
  11+ 5AAE 28           	DB '('
  12+ 5AAF              	; get source address
  13+ 5AAF DD 21 2F 54  	LD IX, FRMQNT
  14+ 5AB3 CD 59 01     	CALL CALBAS
  15+ 5AB6 D5           	PUSH DE
  16+ 5AB7              	; comma
  17+ 5AB7 CD 7F 69     	CALL CHKCHAR
  18+ 5ABA 2C           	DB ','
  19+ 5ABB              	; get destination address
  20+ 5ABB DD 21 2F 54  	LD IX, FRMQNT
  21+ 5ABF CD 59 01     	CALL CALBAS
  22+ 5AC2 D5           	PUSH DE
  23+ 5AC3              	; comma
  24+ 5AC3 CD 7F 69     	CALL CHKCHAR
  25+ 5AC6 2C           	DB ','
  26+ 5AC7              	; get length
  27+ 5AC7 DD 21 2F 54  	LD IX, FRMQNT
  28+ 5ACB CD 59 01     	CALL CALBAS
  29+ 5ACE D5           	PUSH DE
  30+ 5ACF              	; ending )
  31+ 5ACF CD 7F 69     	CALL CHKCHAR
  32+ 5AD2 29           	DB ')'
  33+ 5AD3
  34+ 5AD3              	; save position
  35+ 5AD3 E5           	PUSH HL
  36+ 5AD4 DD E1        	POP IX
  37+ 5AD6
  38+ 5AD6 C1           	POP BC ; count
  39+ 5AD7 D1           	POP DE ; destination
  40+ 5AD8 E1           	POP HL ; source
  41+ 5AD9 D9           	EXX
  42+ 5ADA              	; enable page 0
  43+ 5ADA F3           	DI
  44+ 5ADB FD 21 E2 5A  	LD IY, .RET
  45+ 5ADF C3 31 69     	JP ENABLE_PAGE0
  46+ 5AE2              .RET:
  47+ 5AE2 FB           	EI
  48+ 5AE3 D9           	EXX
  49+ 5AE4 ED B0        	LDIR
  50+ 5AE6 D1               POP DE
  51+ 5AE7 C1               POP BC
  52+ 5AE8 CD A8 68         CALL RESTORE_PAGE_INFO
  53+ 5AEB DD E5        	PUSH IX
  54+ 5AED E1           	POP HL
  55+ 5AEE C9           	RET
  56+ 5AEF              ; *******************************************************************************************************
  57+ 5AEF               ENDIF
  58+ 5AEF
  59+ 5AEF               IF (DEFUSR_EXTENSION == 1)
  60+ 5AEF              ; *******************************************************************************************************
  61+ 5AEF              ; same as MEMCPY but for DEFUSR approach
  62+ 5AEF              ; input IX=pointer to input array, real data from +2
  63+ 5AEF              ; +2 = source address
  64+ 5AEF              ; +4 = destination address
  65+ 5AEF              ; +6 = lenght
  66+ 5AEF              MEMCPY_DEFUSR:
  67+ 5AEF              	; enable page 0
  68+ 5AEF F3           	DI
  69+ 5AF0 FD 21 F7 5A  	LD IY, .RET
  70+ 5AF4 C3 31 69     	JP ENABLE_PAGE0
  71+ 5AF7              .RET:
  72+ 5AF7 FB           	EI
  73+ 5AF8 DD 6E 02     	LD L,(IX+2)
  74+ 5AFB DD 66 03     	LD H,(IX+3)
  75+ 5AFE DD 5E 04     	LD E,(IX+4)
  76+ 5B01 DD 56 05     	LD D,(IX+5)
  77+ 5B04 DD 4E 06     	LD C,(IX+6)
  78+ 5B07 DD 46 07     	LD B,(IX+7)
  79+ 5B0A ED B0        	LDIR
  80+ 5B0C D1               POP DE
  81+ 5B0D C1               POP BC
  82+ 5B0E C3 A8 68         JP RESTORE_PAGE_INFO
  83+ 5B11              ; *******************************************************************************************************
  84+ 5B11               ENDIF
  85+ 5B11
  86+ 5B11              ; *******************************************************************************************************
  87+ 5B11              ; function to handle CALL FILRAM basic extension
  88+ 5B11              ; FILRAM ( INT start address,
  89+ 5B11              ;		   INT count,
  90+ 5B11              ;		   BYTE value )
  91+ 5B11              ; will put ram in page 0 also, page 1 is already there
  92+ 5B11              FILRAM:
  93+ 5B11              	; opening (
  94+ 5B11 CD 7F 69     	CALL CHKCHAR
  95+ 5B14 28           	DB '('
  96+ 5B15              	; get start address
  97+ 5B15 DD 21 2F 54  	LD IX, FRMQNT
  98+ 5B19 CD 59 01     	CALL CALBAS
  99+ 5B1C D5           	PUSH DE
 100+ 5B1D              	; comma
 101+ 5B1D CD 7F 69     	CALL CHKCHAR
 102+ 5B20 2C           	DB ','
 103+ 5B21              	; get count
 104+ 5B21 DD 21 2F 54  	LD IX, FRMQNT
 105+ 5B25 CD 59 01     	CALL CALBAS
 106+ 5B28 D5           	PUSH DE
 107+ 5B29              	; comma
 108+ 5B29 CD 7F 69     	CALL CHKCHAR
 109+ 5B2C 2C           	DB ','
 110+ 5B2D              	; get value
 111+ 5B2D DD 21 1C 52  	LD IX, GETBYT
 112+ 5B31 CD 59 01     	CALL CALBAS
 113+ 5B34 F5           	PUSH AF
 114+ 5B35              	; ending )
 115+ 5B35 CD 7F 69     	CALL CHKCHAR
 116+ 5B38 29           	DB ')'
 117+ 5B39
 118+ 5B39              	; save position
 119+ 5B39 E5           	PUSH HL
 120+ 5B3A DD E1        	POP IX
 121+ 5B3C
 122+ 5B3C D1           	POP DE ; actually AF
 123+ 5B3D C1           	POP BC ; count
 124+ 5B3E E1           	POP HL ; start address
 125+ 5B3F 78           	LD A, B
 126+ 5B40 B1           	OR C
 127+ 5B41 28 13        	JR Z, .EXIT ; 0 bytes to fill, skip
 128+ 5B43 D9           	EXX
 129+ 5B44              	; enable page 0
 130+ 5B44 F3           	DI
 131+ 5B45 FD 21 4C 5B  	LD IY, .RET
 132+ 5B49 C3 31 69     	JP ENABLE_PAGE0
 133+ 5B4C              .RET:
 134+ 5B4C FB           	EI
 135+ 5B4D D9           	EXX
 136+ 5B4E CD 5A 5B     	CALL .FILLVALUE
 137+ 5B51 D1               POP DE
 138+ 5B52 C1               POP BC
 139+ 5B53 CD A8 68         CALL RESTORE_PAGE_INFO
 140+ 5B56              .EXIT:
 141+ 5B56 DD E5        	PUSH IX
 142+ 5B58 E1           	POP HL
 143+ 5B59 C9           	RET
 144+ 5B5A
 145+ 5B5A              .FILLVALUE:
 146+ 5B5A 72               LD (HL), D
 147+ 5B5B 54               LD D, H
 148+ 5B5C 5D               LD E, L
 149+ 5B5D 13               INC DE
 150+ 5B5E 0B               DEC BC
 151+ 5B5F 78           	LD A,B
 152+ 5B60 B1           	OR C
 153+ 5B61 C8           	RET Z ; if count was 1
 154+ 5B62 ED B0            LDIR
 155+ 5B64 C9               RET
 156+ 5B65              ; *******************************************************************************************************
 157+ 5B65
# file closed: asm\MEMORY.asm
 139  5B65               ENDIF
 140  5B65
 141  5B65               IF (SOUND_CMDS == 1)
 142  5B65               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
   1+ 5B65              MUSIC_INIT_STATUS:
   2+ 5B65 00            DB 0
   3+ 5B66              SFX_INIT_STATUS:
   4+ 5B66 00            DB 0
   5+ 5B67              SOUND_ENABLED:
   6+ 5B67 00            DB 0
   7+ 5B68
   8+ 5B68              ; *******************************************************************************************************
   9+ 5B68              ; function to handle CALL SNDPLYINIT basic extension
  10+ 5B68              ; initializes sound player
  11+ 5B68              ; _SNDPLYINIT ( INT music_offset,
  12+ 5B68              ;				INT sfx_offset, can be -1 if no SFX
  13+ 5B68              ; will put ram in page 0 also, page 1 is already there
  14+ 5B68              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
  15+ 5B68              SNDPLYINIT:
  16+ 5B68              	; opening (
  17+ 5B68 CD 7F 69     	CALL CHKCHAR
  18+ 5B6B 28           	DB '('
  19+ 5B6C              	; get music address
  20+ 5B6C DD 21 2F 54  	LD IX, FRMQNT
  21+ 5B70 CD 59 01     	CALL CALBAS
  22+ 5B73 D5           	PUSH DE
  23+ 5B74              	; comma
  24+ 5B74 CD 7F 69     	CALL CHKCHAR
  25+ 5B77 2C           	DB ','
  26+ 5B78              	; get sfx address
  27+ 5B78 DD 21 2F 54  	LD IX, FRMQNT
  28+ 5B7C CD 59 01     	CALL CALBAS
  29+ 5B7F D5           	PUSH DE
  30+ 5B80              	; ending )
  31+ 5B80 CD 7F 69     	CALL CHKCHAR
  32+ 5B83 29           	DB ')'
  33+ 5B84
  34+ 5B84                  ; save position in BASIC text
  35+ 5B84 44           	LD B, H
  36+ 5B85 4D           	LD C, L
  37+ 5B86
  38+ 5B86              	; pop LDIR parameters and store away for later
  39+ 5B86 D1           	POP DE ; sfx address
  40+ 5B87 E1           	POP HL ; music address
  41+ 5B88 C5           	PUSH BC ; basic text location
  42+ 5B89 D9           	EXX
  43+ 5B8A FD 21 91 5B  	LD IY, .RET
  44+ 5B8E C3 31 69     	JP ENABLE_PAGE0
  45+ 5B91              .RET:
  46+ 5B91 D9           	EXX
  47+ 5B92
  48+ 5B92 D5           	PUSH DE
  49+ 5B93 AF           	XOR A
  50+ 5B94              	; HL = music location
  51+ 5B94 CD 65 41     	CALL PLY_AKG_INIT
  52+ 5B97 3E 01        	LD A, 1
  53+ 5B99 32 65 5B     	LD (MUSIC_INIT_STATUS), A
  54+ 5B9C
  55+ 5B9C E1           	POP HL ; SFX
  56+ 5B9D              	; check if SFX address -1
  57+ 5B9D 23           	INC HL
  58+ 5B9E 7D           	LD A, L
  59+ 5B9F B4           	OR H
  60+ 5BA0 28 09        	JR Z,.L1
  61+ 5BA2 2B           	DEC HL
  62+ 5BA3 CD 20 40     	CALL PLY_AKG_INITSOUNDEFFECTS
  63+ 5BA6 3E 01        	LD A, 1
  64+ 5BA8 32 66 5B     	LD (SFX_INIT_STATUS), A
  65+ 5BAB              .L1:
  66+ 5BAB D1               POP DE
  67+ 5BAC C1               POP BC
  68+ 5BAD CD A8 68         CALL RESTORE_PAGE_INFO
  69+ 5BB0
  70+ 5BB0 E1           	POP HL
  71+ 5BB1 C9           	RET
  72+ 5BB2              ; *******************************************************************************************************
  73+ 5BB2
  74+ 5BB2              ; *******************************************************************************************************
  75+ 5BB2              ; function to handle CALL SNDPLYON basic extension
  76+ 5BB2              ; enables sound player
  77+ 5BB2              ; _SNDPLYON
  78+ 5BB2              ; sets SOUND_ENABLED variable to 1 if init call was done
  79+ 5BB2              ; if not throws out of data error
  80+ 5BB2              SNDPLYON:
  81+ 5BB2 3A 65 5B     	LD A, (MUSIC_INIT_STATUS)
  82+ 5BB5 B7           	OR A
  83+ 5BB6 20 05        	JR NZ, .L1
  84+ 5BB8              	; player not initialized, throw error
  85+ 5BB8 1E 04        	LD E, 04 ; Out of DATA
  86+ 5BBA C3 A5 69     	JP THROW_ERROR
  87+ 5BBD              .L1:
  88+ 5BBD 32 67 5B     	LD (SOUND_ENABLED), A
  89+ 5BC0              	; disable key click
  90+ 5BC0 AF           	XOR A
  91+ 5BC1 32 DB F3     	LD (CLIKSW), A
  92+ 5BC4 C9           	RET
  93+ 5BC5              ; *******************************************************************************************************
  94+ 5BC5
  95+ 5BC5              ; *******************************************************************************************************
  96+ 5BC5              ; function to handle CALL SNDPLYOFF basic extension
  97+ 5BC5              ; disables sound player
  98+ 5BC5              ; _SNDPLYOFF
  99+ 5BC5              ; sets SOUND_ENABLED variable to 0
 100+ 5BC5              ; calls AKG to stop music and SFX on all channels if initialized
 101+ 5BC5              SNDPLYOFF:
 102+ 5BC5 3A 67 5B     	LD A, (SOUND_ENABLED)
 103+ 5BC8 B7           	OR A
 104+ 5BC9 C8           	RET Z ; already stopped
 105+ 5BCA AF           	XOR A
 106+ 5BCB 32 67 5B     	LD (SOUND_ENABLED), A
 107+ 5BCE E5           	PUSH HL
 108+ 5BCF CD 24 42     	CALL PLY_AKG_STOP
 109+ 5BD2 3A 66 5B     	LD A, (SFX_INIT_STATUS)
 110+ 5BD5 B7           	OR A
 111+ 5BD6 28 0E        	JR Z, .EXIT ; SFX not in use
 112+ 5BD8 AF           	XOR A
 113+ 5BD9 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 114+ 5BDC 3E 01        	LD A, 1
 115+ 5BDE CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 116+ 5BE1 3E 02        	LD A, 2
 117+ 5BE3 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 118+ 5BE6              .EXIT:
 119+ 5BE6 E1           	POP HL
 120+ 5BE7 C9           	RET
 121+ 5BE8              ; *******************************************************************************************************
 122+ 5BE8
 123+ 5BE8               IF (BASIC_EXTENSION == 1)
 124+ 5BE8              ; *******************************************************************************************************
 125+ 5BE8              ; function to handle CALL SNDSFX basic extension
 126+ 5BE8              ; plays a sound effect
 127+ 5BE8              ; _SNDSFX ( BYTE sfx_number, >0
 128+ 5BE8              ;			BYTE channel, = 0,1 or 2
 129+ 5BE8              ;			BYTE inverted_volume = 0-16, 0 being full volume
 130+ 5BE8              ; will put ram in page 0 also, page 1 is already there
 131+ 5BE8              ; if sound off throws illegal function call
 132+ 5BE8              ; if sfx not initialized, throws out of data
 133+ 5BE8              SNDSFX:
 134+ 5BE8              	; opening (
 135+ 5BE8 CD 7F 69     	CALL CHKCHAR
 136+ 5BEB 28           	DB '('
 137+ 5BEC              	; get sfx_number
 138+ 5BEC DD 21 1C 52  	LD IX, GETBYT
 139+ 5BF0 CD 59 01     	CALL CALBAS
 140+ 5BF3 D5           	PUSH DE
 141+ 5BF4              	; comma
 142+ 5BF4 CD 7F 69     	CALL CHKCHAR
 143+ 5BF7 2C           	DB ','
 144+ 5BF8              	; get sfx address
 145+ 5BF8 DD 21 1C 52  	LD IX, GETBYT
 146+ 5BFC CD 59 01     	CALL CALBAS
 147+ 5BFF D5           	PUSH DE
 148+ 5C00              	; comma
 149+ 5C00 CD 7F 69     	CALL CHKCHAR
 150+ 5C03 2C           	DB ','
 151+ 5C04              	; get inverted volume
 152+ 5C04 DD 21 1C 52  	LD IX, GETBYT
 153+ 5C08 CD 59 01     	CALL CALBAS
 154+ 5C0B D5           	PUSH DE
 155+ 5C0C              	; ending )
 156+ 5C0C CD 7F 69     	CALL CHKCHAR
 157+ 5C0F 29           	DB ')'
 158+ 5C10
 159+ 5C10 3A 67 5B     	LD A, (SOUND_ENABLED)
 160+ 5C13 B7           	OR A
 161+ 5C14 20 05        	JR NZ, .L1
 162+ 5C16              	; sound disabled, throw illegal function call
 163+ 5C16 1E 05        	LD E, 5
 164+ 5C18 C3 A5 69     	JP THROW_ERROR
 165+ 5C1B              .L1:
 166+ 5C1B 3A 66 5B     	LD A, (SFX_INIT_STATUS)
 167+ 5C1E B7           	OR A
 168+ 5C1F 20 05        	JR NZ, .L2
 169+ 5C21              	; sfx data not initialized, throw out of data
 170+ 5C21 1E 04        	LD E, 4
 171+ 5C23 C3 A5 69     	JP THROW_ERROR
 172+ 5C26              .L2:
 173+ 5C26              	; pop  parameters and store away for later
 174+ 5C26 D1           	POP DE ; inverted volume
 175+ 5C27 43           	LD B, E
 176+ 5C28 D1           	POP DE ; channel
 177+ 5C29 4B           	LD C, E
 178+ 5C2A D1           	POP DE
 179+ 5C2B 7B           	LD A, E
 180+ 5C2C 08           	EX AF, AF'
 181+ 5C2D E5           	PUSH HL ; basic text location
 182+ 5C2E D9           	EXX
 183+ 5C2F FD 21 36 5C  	LD IY, .RET
 184+ 5C33 C3 31 69     	JP ENABLE_PAGE0
 185+ 5C36              .RET:
 186+ 5C36 D9           	EXX
 187+ 5C37 08           	EX AF, AF'
 188+ 5C38 CD 24 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
 189+ 5C3B
 190+ 5C3B D1               POP DE
 191+ 5C3C C1               POP BC
 192+ 5C3D CD A8 68         CALL RESTORE_PAGE_INFO
 193+ 5C40
 194+ 5C40 E1           	POP HL
 195+ 5C41 C9           	RET
 196+ 5C42              ; *******************************************************************************************************
 197+ 5C42               ENDIF
 198+ 5C42
 199+ 5C42               IF (DEFUSR_EXTENSION == 1)
 200+ 5C42              ; *******************************************************************************************************
 201+ 5C42              ; same as SNDSFX but for DEFUSR approach
 202+ 5C42              ; input IX=pointer to input array, real data from +2
 203+ 5C42              ; +2 = SFX number
 204+ 5C42              ; +4 = channel
 205+ 5C42              ; +6 = volume
 206+ 5C42              SNDSFX_DEFUSR:
 207+ 5C42 3A 67 5B     	LD A, (SOUND_ENABLED)
 208+ 5C45 B7           	OR A
 209+ 5C46 C8           	RET Z ; sound disabled, just exit
 210+ 5C47 3A 66 5B     	LD A, (SFX_INIT_STATUS)
 211+ 5C4A B7           	OR A
 212+ 5C4B C8           	RET Z ; sfx data not initialized, just exit
 213+ 5C4C F3           	DI
 214+ 5C4D FD 21 54 5C  	LD IY, .RET
 215+ 5C51 C3 31 69     	JP ENABLE_PAGE0
 216+ 5C54              .RET:
 217+ 5C54 FB           	EI
 218+ 5C55 DD 7E 02     	LD A,(IX+2) ; SFX number
 219+ 5C58 DD 4E 04     	LD C,(IX+4) ; channel
 220+ 5C5B DD 46 06     	LD B,(IX+6) ; volume
 221+ 5C5E CD 24 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
 222+ 5C61 D1               POP DE
 223+ 5C62 C1               POP BC
 224+ 5C63 C3 A8 68         JP RESTORE_PAGE_INFO
 225+ 5C66              ; *******************************************************************************************************
 226+ 5C66               ENDIF
# file closed: asm\SOUND.asm
 143  5C66               ENDIF
 144  5C66
 145  5C66               IF (VRAM_CMDS == 1)
 146  5C66               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
   1+ 5C66              ; *******************************************************************************************************
   2+ 5C66              ; function to handle CALL FILVRM basic extension
   3+ 5C66              ; FILVRM ( INT offset,
   4+ 5C66              ;		   INT count,
   5+ 5C66              ;		   BYTE value,
   6+ 5C66              ;		   BYTE wait_vsync) >0 = true
   7+ 5C66              ; wait_vsync will issue HALT before copying
   8+ 5C66              FILVRM:
   9+ 5C66              	; opening (
  10+ 5C66 CD 7F 69     	CALL CHKCHAR
  11+ 5C69 28           	DB '('
  12+ 5C6A              	; get offset address
  13+ 5C6A DD 21 2F 54  	LD IX, FRMQNT
  14+ 5C6E CD 59 01     	CALL CALBAS
  15+ 5C71 D5           	PUSH DE
  16+ 5C72              	; comma
  17+ 5C72 CD 7F 69     	CALL CHKCHAR
  18+ 5C75 2C           	DB ','
  19+ 5C76              	; get count
  20+ 5C76 DD 21 2F 54  	LD IX, FRMQNT
  21+ 5C7A CD 59 01     	CALL CALBAS
  22+ 5C7D D5           	PUSH DE
  23+ 5C7E              	; comma
  24+ 5C7E CD 7F 69     	CALL CHKCHAR
  25+ 5C81 2C           	DB ','
  26+ 5C82              	; get value
  27+ 5C82 DD 21 1C 52  	LD IX, GETBYT
  28+ 5C86 CD 59 01     	CALL CALBAS
  29+ 5C89 F5           	PUSH AF
  30+ 5C8A              	; comma
  31+ 5C8A CD 7F 69     	CALL CHKCHAR
  32+ 5C8D 2C           	DB ','
  33+ 5C8E              	; get vsync wait
  34+ 5C8E DD 21 1C 52  	LD IX, GETBYT
  35+ 5C92 CD 59 01     	CALL CALBAS
  36+ 5C95 F5           	PUSH AF
  37+ 5C96              	; ending )
  38+ 5C96 CD 7F 69     	CALL CHKCHAR
  39+ 5C99 29           	DB ')'
  40+ 5C9A
  41+ 5C9A              	; save position
  42+ 5C9A E5           	PUSH HL
  43+ 5C9B DD E1        	POP IX
  44+ 5C9D
  45+ 5C9D              	; syntax ok
  46+ 5C9D              	; wait for vsync if needed
  47+ 5C9D F1           	POP AF
  48+ 5C9E B7           	OR A
  49+ 5C9F 28 01        	JR Z, .L1
  50+ 5CA1 76           	HALT
  51+ 5CA2
  52+ 5CA2              .L1:
  53+ 5CA2 3E 01        	LD A,1
  54+ 5CA4 32 81 66     	LD (VRAM_UPDATE_IN_PROGRESS),A
  55+ 5CA7 F1               POP AF ; value
  56+ 5CA8 C1               POP BC ; count
  57+ 5CA9 E1               POP HL ; offset
  58+ 5CAA CD 56 00         CALL BIOS_FILVRM
  59+ 5CAD AF           	XOR A
  60+ 5CAE 32 81 66     	LD (VRAM_UPDATE_IN_PROGRESS),A
  61+ 5CB1
  62+ 5CB1              .L3:
  63+ 5CB1 DD E5        	PUSH IX
  64+ 5CB3 E1           	POP HL
  65+ 5CB4 C9           	RET
  66+ 5CB5              ; *******************************************************************************************************
  67+ 5CB5
  68+ 5CB5               IF (BASIC_EXTENSION == 1)
  69+ 5CB5              ; *******************************************************************************************************
  70+ 5CB5              ; function to handle CALL MEMVRM basic extension
  71+ 5CB5              ; copies from RAM to VRAM
  72+ 5CB5              ; _MEMVRM ( INT source,
  73+ 5CB5              ;			INT destination,
  74+ 5CB5              ;			INT count,
  75+ 5CB5              ;			BYTE wait_vsync) >0 = true
  76+ 5CB5              ; will put ram in page 0 also, page 1 is already there
  77+ 5CB5              ; wait_vsync will issue HALT before copying
  78+ 5CB5              MEMVRM:
  79+ 5CB5              	; opening (
  80+ 5CB5 CD 7F 69     	CALL CHKCHAR
  81+ 5CB8 28           	DB '('
  82+ 5CB9              	; get source address
  83+ 5CB9 DD 21 2F 54  	LD IX, FRMQNT
  84+ 5CBD CD 59 01     	CALL CALBAS
  85+ 5CC0 D5           	PUSH DE
  86+ 5CC1              	; comma
  87+ 5CC1 CD 7F 69     	CALL CHKCHAR
  88+ 5CC4 2C           	DB ','
  89+ 5CC5              	; get destination address
  90+ 5CC5 DD 21 2F 54  	LD IX, FRMQNT
  91+ 5CC9 CD 59 01     	CALL CALBAS
  92+ 5CCC D5           	PUSH DE
  93+ 5CCD              	; comma
  94+ 5CCD CD 7F 69     	CALL CHKCHAR
  95+ 5CD0 2C           	DB ','
  96+ 5CD1              	; get length
  97+ 5CD1 DD 21 2F 54  	LD IX, FRMQNT
  98+ 5CD5 CD 59 01     	CALL CALBAS
  99+ 5CD8 D5           	PUSH DE
 100+ 5CD9              	; comma
 101+ 5CD9 CD 7F 69     	CALL CHKCHAR
 102+ 5CDC 2C           	DB ','
 103+ 5CDD              	; get vsync wait
 104+ 5CDD DD 21 1C 52  	LD IX, GETBYT
 105+ 5CE1 CD 59 01     	CALL CALBAS
 106+ 5CE4 F5           	PUSH AF
 107+ 5CE5              	; ending )
 108+ 5CE5 CD 7F 69     	CALL CHKCHAR
 109+ 5CE8 29           	DB ')'
 110+ 5CE9
 111+ 5CE9                  ; save position in BASIC text
 112+ 5CE9 E5           	PUSH HL
 113+ 5CEA DD E1        	POP IX
 114+ 5CEC
 115+ 5CEC F1           	POP AF ; wait vsync
 116+ 5CED B7           	OR A
 117+ 5CEE 28 01        	JR Z, .L1
 118+ 5CF0 76           	HALT
 119+ 5CF1              .L1:
 120+ 5CF1 F3           	DI
 121+ 5CF2              	; pop LDIR parameters and store away for later
 122+ 5CF2 C1           	POP BC ; count
 123+ 5CF3 D1           	POP DE ; vram destination
 124+ 5CF4 E1           	POP HL ; ram source
 125+ 5CF5 D9           	EXX
 126+ 5CF6 FD 21 FD 5C   	LD IY, .RET
 127+ 5CFA C3 31 69     	JP ENABLE_PAGE0
 128+ 5CFD              .RET:
 129+ 5CFD FB           	EI
 130+ 5CFE D9           	EXX
 131+ 5CFF CD 35 5D     	CALL VRAM_LDIRVM
 132+ 5D02 D1               POP DE
 133+ 5D03 C1               POP BC
 134+ 5D04 CD A8 68         CALL RESTORE_PAGE_INFO
 135+ 5D07 DD E5        	PUSH IX
 136+ 5D09 E1           	POP HL
 137+ 5D0A C9           	RET
 138+ 5D0B              ; *******************************************************************************************************
 139+ 5D0B               ENDIF
 140+ 5D0B
 141+ 5D0B               IF (DEFUSR_EXTENSION == 1)
 142+ 5D0B              ; *******************************************************************************************************
 143+ 5D0B              ; same as MEMVRM but for DEFUSR approach
 144+ 5D0B              ; input IX=pointer to input array, real data from +2
 145+ 5D0B              ; +2 = source address
 146+ 5D0B              ; +4 = destination address
 147+ 5D0B              ; +6 = lenght
 148+ 5D0B              ; +8 = vsync wait flag
 149+ 5D0B              MEMVRM_DEFUSR:
 150+ 5D0B DD 7E 08     	LD A,(IX+8)
 151+ 5D0E B7           	OR A
 152+ 5D0F 28 01        	JR Z,.L0
 153+ 5D11 76           	HALT
 154+ 5D12              .L0:
 155+ 5D12              	; enable page 0
 156+ 5D12 F3           	DI
 157+ 5D13 FD 21 1A 5D  	LD IY, .RET
 158+ 5D17 C3 31 69     	JP ENABLE_PAGE0
 159+ 5D1A              .RET:
 160+ 5D1A FB           	EI
 161+ 5D1B DD 6E 02     	LD L,(IX+2)
 162+ 5D1E DD 66 03     	LD H,(IX+3)
 163+ 5D21 DD 5E 04     	LD E,(IX+4)
 164+ 5D24 DD 56 05     	LD D,(IX+5)
 165+ 5D27 DD 4E 06     	LD C,(IX+6)
 166+ 5D2A DD 46 07     	LD B,(IX+7)
 167+ 5D2D CD 35 5D     	CALL VRAM_LDIRVM
 168+ 5D30 D1               POP DE
 169+ 5D31 C1               POP BC
 170+ 5D32 C3 A8 68         JP RESTORE_PAGE_INFO
 171+ 5D35              ; *******************************************************************************************************
 172+ 5D35               ENDIF
 173+ 5D35
 174+ 5D35               IF (BASIC_EXTENSION + DEFUSR_EXTENSION > 0)
 175+ 5D35              ; *******************************************************************************************************
 176+ 5D35              ; common code to copy from memory to VRAM
 177+ 5D35              ; input HL=RAM source
 178+ 5D35              ; input DE=VRAM destination
 179+ 5D35              ; BC=count
 180+ 5D35              VRAM_LDIRVM:
 181+ 5D35 3E 01        	LD A,1
 182+ 5D37 32 81 66     	LD (VRAM_UPDATE_IN_PROGRESS),A
 183+ 5D3A EB           	EX DE, HL
 184+ 5D3B F3           	DI
 185+ 5D3C CD 58 68     	CALL SETWRT_LOCAL
 186+ 5D3F FB           	EI
 187+ 5D40 EB           	EX DE, HL
 188+ 5D41 78           	LD A, B
 189+ 5D42 B7           	OR A
 190+ 5D43 28 0D        	JR Z, .L3
 191+ 5D45 C5           	PUSH BC
 192+ 5D46 0E 98        	LD C, #98
 193+ 5D48              .L2:
 194+ 5D48 50           	LD D, B
 195+ 5D49 06 00        	LD B, 0
 196+ 5D4B CD 65 68     	CALL BBYTECOPY_NO_C
 197+ 5D4E 42           	LD B, D
 198+ 5D4F 10 F7        	DJNZ .L2
 199+ 5D51 C1           	POP BC
 200+ 5D52              .L3:
 201+ 5D52 79           	LD A, C
 202+ 5D53 B7           	OR A
 203+ 5D54 28 04        	JR Z,.L4
 204+ 5D56 41           	LD B, C
 205+ 5D57 CD 63 68     	CALL BBYTECOPY
 206+ 5D5A              .L4:
 207+ 5D5A AF           	XOR A
 208+ 5D5B 32 81 66     	LD (VRAM_UPDATE_IN_PROGRESS),A
 209+ 5D5E C9           	RET
 210+ 5D5F              ; *******************************************************************************************************
 211+ 5D5F               ENDIF
 212+ 5D5F
 213+ 5D5F              ; *******************************************************************************************************
 214+ 5D5F              ; function to handle CALL VRMMEM basic extension
 215+ 5D5F              ; copies from RAM to VRAM
 216+ 5D5F              ; _VRMMEM ( INT source,
 217+ 5D5F              ;			INT destination,
 218+ 5D5F              ;			INT count
 219+ 5D5F              ; will put ram in page 0 also, page 1 is already there
 220+ 5D5F              VRMMEM:
 221+ 5D5F              	; opening (
 222+ 5D5F CD 7F 69     	CALL CHKCHAR
 223+ 5D62 28           	DB '('
 224+ 5D63              	; get source address
 225+ 5D63 DD 21 2F 54  	LD IX, FRMQNT
 226+ 5D67 CD 59 01     	CALL CALBAS
 227+ 5D6A D5           	PUSH DE
 228+ 5D6B              	; comma
 229+ 5D6B CD 7F 69     	CALL CHKCHAR
 230+ 5D6E 2C           	DB ','
 231+ 5D6F              	; get destination address
 232+ 5D6F DD 21 2F 54  	LD IX, FRMQNT
 233+ 5D73 CD 59 01     	CALL CALBAS
 234+ 5D76 D5           	PUSH DE
 235+ 5D77              	; comma
 236+ 5D77 CD 7F 69     	CALL CHKCHAR
 237+ 5D7A 2C           	DB ','
 238+ 5D7B              	; get length
 239+ 5D7B DD 21 2F 54  	LD IX, FRMQNT
 240+ 5D7F CD 59 01     	CALL CALBAS
 241+ 5D82 D5           	PUSH DE
 242+ 5D83              	; ending )
 243+ 5D83 CD 7F 69     	CALL CHKCHAR
 244+ 5D86 29           	DB ')'
 245+ 5D87
 246+ 5D87                  ; save position in BASIC text
 247+ 5D87 E5           	PUSH HL
 248+ 5D88 DD E1        	POP IX
 249+ 5D8A
 250+ 5D8A C1           	POP BC ; count
 251+ 5D8B D1           	POP DE ; destination
 252+ 5D8C E1           	POP HL ; source
 253+ 5D8D D9           	EXX
 254+ 5D8E FD 21 96 5D  	LD IY, .RET
 255+ 5D92 F3           	DI
 256+ 5D93 C3 31 69     	JP ENABLE_PAGE0
 257+ 5D96              .RET:
 258+ 5D96 FB           	EI
 259+ 5D97 D9           	EXX
 260+ 5D98 3E 01        	LD A,1
 261+ 5D9A 32 81 66     	LD (VRAM_UPDATE_IN_PROGRESS),A
 262+ 5D9D CD AD 5D     	CALL .LDIRMV
 263+ 5DA0 AF           	XOR A
 264+ 5DA1 32 81 66     	LD (VRAM_UPDATE_IN_PROGRESS),A
 265+ 5DA4 D1               POP DE
 266+ 5DA5 C1               POP BC
 267+ 5DA6 CD A8 68         CALL RESTORE_PAGE_INFO
 268+ 5DA9 DD E5        	PUSH IX
 269+ 5DAB E1           	POP HL
 270+ 5DAC C9           	RET
 271+ 5DAD
 272+ 5DAD              .LDIRMV:
 273+ 5DAD              	; set VRAM address *exactly* as in ROM, otherwise corruption
 274+ 5DAD 7D           	LD	A, L
 275+ 5DAE F3           	DI
 276+ 5DAF D3 99        	OUT	(099H), A
 277+ 5DB1 7C           	LD	A, H
 278+ 5DB2 E6 3F        	AND	03FH
 279+ 5DB4 D3 99        	OUT	(099H), A
 280+ 5DB6 FB           	EI
 281+ 5DB7              	;EX (SP), HL
 282+ 5DB7              	;EX (SP), HL
 283+ 5DB7              	;NOP
 284+ 5DB7              	;NOP
 285+ 5DB7              .L4:
 286+ 5DB7 DB 98            IN A, (#98)
 287+ 5DB9 12           	LD (DE), A
 288+ 5DBA 13               INC DE
 289+ 5DBB 0B               DEC BC
 290+ 5DBC 79               LD A, C
 291+ 5DBD B0               OR B
 292+ 5DBE 20 F7            JR NZ, .L4
 293+ 5DC0 C9               RET
 294+ 5DC1              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
 147  5DC1               ENDIF
 148  5DC1
 149  5DC1               IF (GENCAL_CMD == 1)
 150  5DC1               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
   1+ 5DC1              ; *******************************************************************************************************
   2+ 5DC1              ; function to handle CALL GENCAL basic extension
   3+ 5DC1              ; GENCAL ( INT fn_addr, = address of the function to call
   4+ 5DC1              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
   5+ 5DC1              ; output values of registers will also be stored at reg_list_ptr
   6+ 5DC1              GENCAL:
   7+ 5DC1              	; opening (
   8+ 5DC1 CD 7F 69     	CALL CHKCHAR
   9+ 5DC4 28           	DB '('
  10+ 5DC5              	; get function address
  11+ 5DC5 DD 21 2F 54  	LD IX, FRMQNT
  12+ 5DC9 CD 59 01     	CALL CALBAS
  13+ 5DCC D5           	PUSH DE
  14+ 5DCD              	; comma
  15+ 5DCD CD 7F 69     	CALL CHKCHAR
  16+ 5DD0 2C           	DB ','
  17+ 5DD1              	; get pointer to register list
  18+ 5DD1 3E 02            LD A,2
  19+ 5DD3 06 01            LD B,1
  20+ 5DD5 11 00 05         LD DE,#0500
  21+ 5DD8 CD AC 69         CALL GET_BASIC_ARRAY_DATA_POINTER
  22+ 5DDB C5           	PUSH BC
  23+ 5DDC              	; ending )
  24+ 5DDC CD 7F 69     	CALL CHKCHAR
  25+ 5DDF 29           	DB ')'
  26+ 5DE0
  27+ 5DE0              	; save BASIC token position
  28+ 5DE0 E5           	PUSH HL
  29+ 5DE1 D9               EXX
  30+ 5DE2 E1           	POP HL ; HL'=next basic token
  31+ 5DE3 D9               EXX
  32+ 5DE4
  33+ 5DE4 E1               POP HL ; get pointer to register values
  34+ 5DE5 F3           	DI
  35+ 5DE6 ED 73 70 66      LD (BLIT_STRUCT), SP
  36+ 5DEA F9               LD SP, HL
  37+ 5DEB F1               POP AF
  38+ 5DEC C1               POP BC
  39+ 5DED D1               POP DE
  40+ 5DEE E1               POP HL
  41+ 5DEF DD E1            POP IX
  42+ 5DF1 FD E1            POP IY
  43+ 5DF3 D9               EXX
  44+ 5DF4 ED 73 72 66      LD (BLIT_STRUCT+2), SP
  45+ 5DF8 ED 7B 70 66      LD SP, (BLIT_STRUCT)
  46+ 5DFC FB               EI
  47+ 5DFD D1               POP DE ; get function to call
  48+ 5DFE E5               PUSH HL
  49+ 5DFF CD 1A 5E         CALL .EXXDECALL
  50+ 5E02 F3               DI
  51+ 5E03 ED 73 70 66      LD (BLIT_STRUCT), SP
  52+ 5E07 ED 7B 72 66      LD SP, (BLIT_STRUCT+2)
  53+ 5E0B FD E5            PUSH IY
  54+ 5E0D DD E5            PUSH IX
  55+ 5E0F E5               PUSH HL
  56+ 5E10 D5               PUSH DE
  57+ 5E11 C5               PUSH BC
  58+ 5E12 F5               PUSH AF
  59+ 5E13 ED 7B 70 66      LD SP, (BLIT_STRUCT)
  60+ 5E17 FB               EI
  61+ 5E18 E1               POP HL
  62+ 5E19 C9           	RET
  63+ 5E1A
  64+ 5E1A              .EXXDECALL:
  65+ 5E1A D5               PUSH DE
  66+ 5E1B D9               EXX
  67+ 5E1C C9               RET
  68+ 5E1D              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
 151  5E1D               ENDIF
 152  5E1D
 153  5E1D               IF (BOX_CMDS == 1)
 154  5E1D               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
   1+ 5E1D              ; *******************************************************************************************************
   2+ 5E1D              ; generic function to implement rectangle data copy
   3+ 5E1D              ; should be modified to call appropriate function for memory or vram
   4+ 5E1D              ; input IX=pointer to following structure
   5+ 5E1D              ; +00 source data pointer
   6+ 5E1D              ; +02 num bytes in a row
   7+ 5E1D              ; +04 number of rows
   8+ 5E1D              ; +06 source add-to value till next row
   9+ 5E1D              ; +08 destination address
  10+ 5E1D              ; +10 destination add-to value till next row
  11+ 5E1D              ; modifies AF, BC, DE, HL
  12+ 5E1D              RECTANGLE_COPY:
  13+ 5E1D DD 6E 00     	LD L, (IX+0)
  14+ 5E20 DD 66 01     	LD H, (IX+1) ; source address
  15+ 5E23 DD 5E 08     	LD E, (IX+8)
  16+ 5E26 DD 56 09     	LD D, (IX+9) ; destination
  17+ 5E29 DD 46 04     	LD B, (IX+4) ; row number
  18+ 5E2C              .L1:
  19+ 5E2C C5           	PUSH BC
  20+ 5E2D E5           		PUSH HL
  21+ 5E2E D5           			PUSH DE
  22+ 5E2F DD 4E 02     				LD C, (IX+2)
  23+ 5E32 DD 46 03     				LD B, (IX+3) ; num bytes in a row
  24+ 5E35              .CALL1:
  25+ 5E35 CD 00 00     				CALL 0 ; set destination address from DE
  26+ 5E38              .CALL2:
  27+ 5E38 CD 00 00     				CALL 0 ; copy data fn
  28+ 5E3B E1           			POP HL
  29+ 5E3C DD 4E 0A     			LD C, (IX+10)
  30+ 5E3F DD 46 0B     			LD B, (IX+11) ; destination add-to
  31+ 5E42 09           			ADD HL, BC
  32+ 5E43 EB           			EX DE, HL
  33+ 5E44 E1           		POP HL
  34+ 5E45 DD 4E 06     		LD C, (IX+6)
  35+ 5E48 DD 46 07     		LD B, (IX+7) ; src add-to
  36+ 5E4B 09           		ADD HL, BC
  37+ 5E4C C1           	POP BC
  38+ 5E4D 10 DD        	DJNZ .L1
  39+ 5E4F C9           	RET
  40+ 5E50              ; *******************************************************************************************************
  41+ 5E50
  42+ 5E50               IF (BASIC_EXTENSION == 1)
  43+ 5E50              ; *******************************************************************************************************
  44+ 5E50              ; function to handle CALL BOXMEMCPY basic extension
  45+ 5E50              ; copies data with window like boundaries within ram
  46+ 5E50              ; BOXMEMCPY ( INT source data pointer,
  47+ 5E50              ;			  INT source number of bytes in a row,
  48+ 5E50              ;			  INT number of rows,
  49+ 5E50              ;			  INT source add-to value till next row,
  50+ 5E50              ; 			  INT destination pointer,
  51+ 5E50              ;			  INT destination add-to value till next row )
  52+ 5E50              ; request_data_ptr described in RECTANGLE_COPY
  53+ 5E50              ; will put ram in page 0 also, page 1 is already there
  54+ 5E50              BOXMEMCPY:
  55+ 5E50 11 67 5E     	LD DE,BOXMEMCPY_COMMON
  56+ 5E53 ED 53 E0 5E  	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
  57+ 5E57 C3 7A 5E     	JP BOX_EXTENSION_PARAMS_COMMON
  58+ 5E5A               ENDIF
  59+ 5E5A
  60+ 5E5A               IF (DEFUSR_EXTENSION == 1)
  61+ 5E5A              ; *******************************************************************************************************
  62+ 5E5A              ; same as BOXMEMCPY but for DEFUSR approach
  63+ 5E5A              ; input IX=pointer to input array, real data from +2
  64+ 5E5A              ; +02 = source data pointer
  65+ 5E5A              ; +04 = source number of bytes in a row
  66+ 5E5A              ; +06 = number of rows
  67+ 5E5A              ; +08 = source add-to value till next row
  68+ 5E5A              ; +10 = destination pointer
  69+ 5E5A              ; +12 = destination add-to value till next row
  70+ 5E5A              BOXMEMCPY_DEFUSR:
  71+ 5E5A 21 67 5E     	LD HL,BOXMEMCPY_COMMON
  72+ 5E5D 22 E0 5E     	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
  73+ 5E60 DD 23        	INC IX
  74+ 5E62 DD 23        	INC IX
  75+ 5E64 C3 DC 5E     	JP BOXCOMMON_DEFUSR
  76+ 5E67               ENDIF
  77+ 5E67
  78+ 5E67              BOXMEMCPY_COMMON:
  79+ 5E67 FB           	EI
  80+ 5E68              	; set RAM functions to call
  81+ 5E68 21 00 00     	LD HL, 0
  82+ 5E6B 22 35 5E     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
  83+ 5E6E 22 37 5E     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
  84+ 5E71 21 ED B0     	LD HL, #B0ED ; LDIR
  85+ 5E74 22 39 5E     	LD (RECTANGLE_COPY.CALL1+4), HL
  86+ 5E77 C3 E5 5E     	JP BOXCOMMON_DEFUSR.CALL
  87+ 5E7A              ; *******************************************************************************************************
  88+ 5E7A
  89+ 5E7A               IF (BASIC_EXTENSION == 1)
  90+ 5E7A              ; *******************************************************************************************************
  91+ 5E7A              ; common parts of BOX commands to load parameters
  92+ 5E7A              BOX_EXTENSION_PARAMS_COMMON:
  93+ 5E7A              	; opening (
  94+ 5E7A CD 7F 69     	CALL CHKCHAR
  95+ 5E7D 28           	DB '('
  96+ 5E7E              	; get source data pointer
  97+ 5E7E DD 21 2F 54  	LD IX, FRMQNT
  98+ 5E82 CD 59 01     	CALL CALBAS
  99+ 5E85 ED 53 70 66  	LD (BLIT_STRUCT+0), DE
 100+ 5E89              	; comma
 101+ 5E89 CD 7F 69     	CALL CHKCHAR
 102+ 5E8C 2C           	DB ','
 103+ 5E8D              	; source number of bytes in a row
 104+ 5E8D DD 21 2F 54  	LD IX, FRMQNT
 105+ 5E91 CD 59 01     	CALL CALBAS
 106+ 5E94 ED 53 72 66  	LD (BLIT_STRUCT+2), DE
 107+ 5E98              	; comma
 108+ 5E98 CD 7F 69     	CALL CHKCHAR
 109+ 5E9B 2C           	DB ','
 110+ 5E9C              	; number of rows
 111+ 5E9C DD 21 2F 54  	LD IX, FRMQNT
 112+ 5EA0 CD 59 01     	CALL CALBAS
 113+ 5EA3 ED 53 74 66  	LD (BLIT_STRUCT+4), DE
 114+ 5EA7              	; comma
 115+ 5EA7 CD 7F 69     	CALL CHKCHAR
 116+ 5EAA 2C           	DB ','
 117+ 5EAB              	; source add-to value till next row
 118+ 5EAB DD 21 2F 54  	LD IX, FRMQNT
 119+ 5EAF CD 59 01     	CALL CALBAS
 120+ 5EB2 ED 53 76 66  	LD (BLIT_STRUCT+6), DE
 121+ 5EB6              	; comma
 122+ 5EB6 CD 7F 69     	CALL CHKCHAR
 123+ 5EB9 2C           	DB ','
 124+ 5EBA              	; destination pointer
 125+ 5EBA DD 21 2F 54  	LD IX, FRMQNT
 126+ 5EBE CD 59 01     	CALL CALBAS
 127+ 5EC1 ED 53 78 66  	LD (BLIT_STRUCT+8), DE
 128+ 5EC5              	; comma
 129+ 5EC5 CD 7F 69     	CALL CHKCHAR
 130+ 5EC8 2C           	DB ','
 131+ 5EC9              	; destination add-to value till next row
 132+ 5EC9 DD 21 2F 54  	LD IX, FRMQNT
 133+ 5ECD CD 59 01     	CALL CALBAS
 134+ 5ED0 ED 53 7A 66  	LD (BLIT_STRUCT+10), DE
 135+ 5ED4              	; ending )
 136+ 5ED4 CD 7F 69     	CALL CHKCHAR
 137+ 5ED7 29           	DB ')'
 138+ 5ED8 DD 21 70 66  	LD IX,BLIT_STRUCT
 139+ 5EDC               ENDIF
 140+ 5EDC              BOXCOMMON_DEFUSR:
 141+ 5EDC E5           	PUSH HL ; save position in BASIC buffer
 142+ 5EDD F3           	DI
 143+ 5EDE              .ADDR:
 144+ 5EDE FD 21 00 00  	LD IY, 0 ; modified by code
 145+ 5EE2 C3 31 69     	JP ENABLE_PAGE0
 146+ 5EE5              .CALL:
 147+ 5EE5 CD 1D 5E     	CALL RECTANGLE_COPY
 148+ 5EE8 AF           	XOR A
 149+ 5EE9 32 81 66     	LD (VRAM_UPDATE_IN_PROGRESS),A
 150+ 5EEC
 151+ 5EEC D1               POP DE
 152+ 5EED C1               POP BC
 153+ 5EEE CD A8 68         CALL RESTORE_PAGE_INFO
 154+ 5EF1
 155+ 5EF1 E1           	POP HL
 156+ 5EF2 C9           	RET
 157+ 5EF3              ; *******************************************************************************************************
 158+ 5EF3
 159+ 5EF3               IF (BASIC_EXTENSION == 1)
 160+ 5EF3              ; *******************************************************************************************************
 161+ 5EF3              ; function to handle CALL BOXMEMVRM basic extension
 162+ 5EF3              ; copies data with window like boundaries from ram to Vram
 163+ 5EF3              ; BOXMEMVRM ( INT source data pointer,
 164+ 5EF3              ;			  INT source number of bytes in a row,
 165+ 5EF3              ;			  INT number of rows,
 166+ 5EF3              ;			  INT source add-to value till next row,
 167+ 5EF3              ; 			  INT destination pointer,
 168+ 5EF3              ;			  INT destination add-to value till next row )
 169+ 5EF3              ; request_data_ptr described in RECTANGLE_COPY
 170+ 5EF3              ; will put ram in page 0 also, page 1 is already there
 171+ 5EF3              BOXMEMVRM:
 172+ 5EF3 11 0A 5F     	LD DE,BOXMEMVRM_COMMON
 173+ 5EF6 ED 53 E0 5E  	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
 174+ 5EFA C3 7A 5E     	JP BOX_EXTENSION_PARAMS_COMMON
 175+ 5EFD               ENDIF
 176+ 5EFD
 177+ 5EFD               IF (DEFUSR_EXTENSION == 1)
 178+ 5EFD              ; *******************************************************************************************************
 179+ 5EFD              ; same as BOXMEMVRM but for DEFUSR approach
 180+ 5EFD              ; input IX=pointer to input array, real data from +2
 181+ 5EFD              ; +02 = source data pointer
 182+ 5EFD              ; +04 = source number of bytes in a row
 183+ 5EFD              ; +06 = number of rows
 184+ 5EFD              ; +08 = source add-to value till next row
 185+ 5EFD              ; +10 = destination pointer
 186+ 5EFD              ; +12 = destination add-to value till next row
 187+ 5EFD              BOXMEMVRM_DEFUSR:
 188+ 5EFD 21 0A 5F     	LD HL,BOXMEMVRM_COMMON
 189+ 5F00 22 E0 5E     	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
 190+ 5F03 DD 23        	INC IX
 191+ 5F05 DD 23        	INC IX
 192+ 5F07 C3 DC 5E     	JP BOXCOMMON_DEFUSR
 193+ 5F0A               ENDIF
 194+ 5F0A
 195+ 5F0A              BOXMEMVRM_COMMON:
 196+ 5F0A FB           	EI
 197+ 5F0B              	; set RAM functions to call
 198+ 5F0B 21 25 5F     	LD HL, .SETDEST
 199+ 5F0E 22 36 5E     	LD (RECTANGLE_COPY.CALL1+1), HL
 200+ 5F11 21 2D 5F     	LD HL, .COPYDATA
 201+ 5F14 22 39 5E     	LD (RECTANGLE_COPY.CALL2+1), HL
 202+ 5F17 3E CD        	LD A, #CD ; CALL
 203+ 5F19 32 35 5E     	LD (RECTANGLE_COPY.CALL1), A
 204+ 5F1C 32 38 5E     	LD (RECTANGLE_COPY.CALL2), A
 205+ 5F1F              	;LD A,1
 206+ 5F1F 32 81 66     	LD (VRAM_UPDATE_IN_PROGRESS),A
 207+ 5F22 C3 E5 5E     	JP BOXCOMMON_DEFUSR.CALL
 208+ 5F25              .SETDEST:
 209+ 5F25 EB           	EX DE, HL
 210+ 5F26 F3           	DI
 211+ 5F27 CD 58 68     	CALL SETWRT_LOCAL
 212+ 5F2A FB           	EI
 213+ 5F2B EB           	EX DE, HL
 214+ 5F2C C9           	RET
 215+ 5F2D              .COPYDATA:
 216+ 5F2D 41           	LD B, C
 217+ 5F2E C3 63 68     	JP BBYTECOPY
 218+ 5F31              ; *******************************************************************************************************
# file closed: asm\BOX.asm
 155  5F31               ENDIF
 156  5F31
 157  5F31               IF (BLIT_CMDS == 1)
 158  5F31               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
   1+ 5F31              ; *******************************************************************************************************
   2+ 5F31              ; function rotates mask and data of several characters and applies to background data
   3+ 5F31              ; this handles x-shift from 0 to 4
   4+ 5F31              ; contains self-modifying code that is set-up from external function
   5+ 5F31              ; input HL=pointer to mask data
   6+ 5F31              ; input HL'=pointer to character data
   7+ 5F31              ; input DE=output buffer containing background data
   8+ 5F31              ; input BC=DE+8
   9+ 5F31              ; input A=number of characters to process
  10+ 5F31              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  11+ 5F31              SHIFT04:
  12+ 5F31 08           	EX AF, AF'
  13+ 5F32 7E           	LD A, (HL) ; get mask
  14+ 5F33 D9           	EXX
  15+ 5F34 57           	LD D, A
  16+ 5F35 1E FF        	LD E, #FF
  17+ 5F37 37           	SCF
  18+ 5F38              .M1:
  19+ 5F38 18 FE        	JR .M1 ; this is self-modifying part
  20+ 5F3A CB 1A        	RR D
  21+ 5F3C CB 1B        	RR E
  22+ 5F3E CB 1A        	RR D
  23+ 5F40 CB 1B        	RR E
  24+ 5F42 CB 1A        	RR D
  25+ 5F44 CB 1B        	RR E
  26+ 5F46 CB 1A        	RR D
  27+ 5F48 CB 1B        	RR E
  28+ 5F4A
  29+ 5F4A 46           	LD B, (HL) ; get data
  30+ 5F4B 0E 00        	LD C, 0
  31+ 5F4D              .M2:
  32+ 5F4D 18 FE        	JR .M2 ; also self-modifying part
  33+ 5F4F CB 38        	SRL B
  34+ 5F51 CB 19        	RR C
  35+ 5F53 CB 38        	SRL B
  36+ 5F55 CB 19        	RR C
  37+ 5F57 CB 38        	SRL B
  38+ 5F59 CB 19        	RR C
  39+ 5F5B CB 38        	SRL B
  40+ 5F5D CB 19        	RR C
  41+ 5F5F
  42+ 5F5F D9           	EXX
  43+ 5F60 1A           	LD A, (DE) ; background
  44+ 5F61 D9           	EXX
  45+ 5F62 A2           	AND D
  46+ 5F63 B0           	OR B
  47+ 5F64 D9           	EXX
  48+ 5F65 12           	LD (DE), A
  49+ 5F66
  50+ 5F66 0A           	LD A, (BC)
  51+ 5F67 D9           	EXX
  52+ 5F68 A3           	AND E
  53+ 5F69 B1           	OR C
  54+ 5F6A 23           	INC HL
  55+ 5F6B D9           	EXX
  56+ 5F6C 02           	LD (BC), A
  57+ 5F6D
  58+ 5F6D 23           	INC HL
  59+ 5F6E 13           	INC DE
  60+ 5F6F 03           	INC BC
  61+ 5F70
  62+ 5F70 08           	EX AF, AF'
  63+ 5F71 3D           	DEC A
  64+ 5F72 C2 31 5F     	JP NZ, SHIFT04
  65+ 5F75 C9           	RET
  66+ 5F76              ; *******************************************************************************************************
  67+ 5F76
  68+ 5F76              ; *******************************************************************************************************
  69+ 5F76              ; function rotates mask and data of several characters and applies to background data
  70+ 5F76              ; this handles x-shift from 5 to 8
  71+ 5F76              ; contains self-modifying code that is set-up from external function
  72+ 5F76              ; input HL=pointer to mask data
  73+ 5F76              ; input HL'=pointer to character data
  74+ 5F76              ; input DE=output buffer containing background data
  75+ 5F76              ; input BC=DE+8
  76+ 5F76              ; input A=number of characters to process
  77+ 5F76              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  78+ 5F76              SHIFT58:
  79+ 5F76 08           	EX AF, AF'
  80+ 5F77 7E           	LD A, (HL) ; get mask
  81+ 5F78 D9           	EXX
  82+ 5F79 57           	LD D, A
  83+ 5F7A 1E FF        	LD E, #FF
  84+ 5F7C 37           	SCF
  85+ 5F7D              .M1:
  86+ 5F7D 18 FE        	JR .M1 ; this is self-modifying part
  87+ 5F7F CB 12        	RL D
  88+ 5F81 CB 13        	RL E
  89+ 5F83 CB 12        	RL D
  90+ 5F85 CB 13        	RL E
  91+ 5F87 CB 12        	RL D
  92+ 5F89 CB 13        	RL E
  93+ 5F8B
  94+ 5F8B 46           	LD B, (HL)
  95+ 5F8C 0E 00        	LD C, 0
  96+ 5F8E              .M2:
  97+ 5F8E 18 FE        	JR .M2 ; also self-modifying part
  98+ 5F90 CB 20        	SLA B
  99+ 5F92 CB 11        	RL C
 100+ 5F94 CB 20        	SLA B
 101+ 5F96 CB 11        	RL C
 102+ 5F98 CB 20        	SLA B
 103+ 5F9A CB 11        	RL C
 104+ 5F9C
 105+ 5F9C D9           	EXX
 106+ 5F9D 1A           	LD A, (DE) ; background
 107+ 5F9E D9           	EXX
 108+ 5F9F A3           	AND E
 109+ 5FA0 B1           	OR C
 110+ 5FA1 D9           	EXX
 111+ 5FA2 12           	LD (DE), A
 112+ 5FA3
 113+ 5FA3 0A           	LD A, (BC)
 114+ 5FA4 D9           	EXX
 115+ 5FA5 A2           	AND D
 116+ 5FA6 B0           	OR B
 117+ 5FA7 23           	INC HL
 118+ 5FA8 D9           	EXX
 119+ 5FA9 02           	LD (BC), A
 120+ 5FAA
 121+ 5FAA 23           	INC HL
 122+ 5FAB 13           	INC DE
 123+ 5FAC 03           	INC BC
 124+ 5FAD
 125+ 5FAD 08           	EX AF, AF'
 126+ 5FAE 3D           	DEC A
 127+ 5FAF C2 76 5F     	JP NZ, SHIFT58
 128+ 5FB2 C9           	RET
 129+ 5FB3              ; *******************************************************************************************************
 130+ 5FB3
 131+ 5FB3              ; *******************************************************************************************************
 132+ 5FB3              ; routine that shifts one row of characters
 133+ 5FB3              ; contains self-modifying code that is set-up from external function
 134+ 5FB3              ; input HL=pointer to mask data
 135+ 5FB3              ; input HL'=pointer to character data
 136+ 5FB3              ; input DE=output buffer containing background data
 137+ 5FB3              ; input A=number of characters to process
 138+ 5FB3              ; input IX=pointer to structure describing input data
 139+ 5FB3              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 140+ 5FB3              SHIFT_ROW:
 141+ 5FB3 F5           	PUSH AF
 142+ 5FB4 ED 53 6C 66  		LD (BLIT_TMP1), DE
 143+ 5FB8 E5           		PUSH HL
 144+ 5FB9 CD FC 5F     			CALL .ADDYSHIFT
 145+ 5FBC E1           		POP HL
 146+ 5FBD ED 53 6E 66  		LD (BLIT_TMP2), DE ; DE+vertical shift
 147+ 5FC1              .L1:
 148+ 5FC1 3E 08        		LD A, 8
 149+ 5FC3 DD 96 02     		SUB (IX+2) ; y shift
 150+ 5FC6              .CALL1:
 151+ 5FC6 CD 00 00     		CALL 0
 152+ 5FC9 DD 7E 02     		LD A, (IX+2); y shift
 153+ 5FCC B7           		OR A
 154+ 5FCD 28 26        		JR Z, .DONE
 155+ 5FCF ED 5B 6C 66  		LD DE, (BLIT_TMP1)
 156+ 5FD3 E5           		PUSH HL
 157+ 5FD4 CD 0A 60     			CALL .DETONEXTROW
 158+ 5FD7 E1           		POP HL
 159+ 5FD8              .CALL2:
 160+ 5FD8 CD 00 00     		CALL 0
 161+ 5FDB ED 5B 6C 66  		LD DE, (BLIT_TMP1)
 162+ 5FDF E5           		PUSH HL
 163+ 5FE0 CD 04 60     			CALL .ADD8
 164+ 5FE3 E1           		POP HL
 165+ 5FE4 ED 53 6C 66  		LD (BLIT_TMP1), DE
 166+ 5FE8 ED 5B 6E 66  		LD DE, (BLIT_TMP2)
 167+ 5FEC E5           		PUSH HL
 168+ 5FED CD 04 60     			CALL .ADD8
 169+ 5FF0 E1           		POP HL
 170+ 5FF1 ED 53 6E 66  		LD (BLIT_TMP2), DE ; DE+vertical shift
 171+ 5FF5              .DONE:
 172+ 5FF5 F1           	POP AF
 173+ 5FF6 3D           	DEC A
 174+ 5FF7 C8           	RET Z
 175+ 5FF8 F5           	PUSH AF
 176+ 5FF9 C3 C1 5F     	JP .L1
 177+ 5FFC              .ADDYSHIFT:
 178+ 5FFC EB           	EX DE, HL
 179+ 5FFD 16 00        	LD D, 0
 180+ 5FFF DD 5E 02     	LD E, (IX+2); y shift
 181+ 6002 18 0C        	JR .MOVDEBC
 182+ 6004              .ADD8:
 183+ 6004 21 08 00     	LD HL, 8
 184+ 6007 C3 10 60     	JP .MOVDEBC
 185+ 600A              .DETONEXTROW:
 186+ 600A DD 6E 06     	LD L, (IX+6)
 187+ 600D DD 66 07     	LD H, (IX+7) ; bkg add to value
 188+ 6010              .MOVDEBC:
 189+ 6010 19           	ADD HL, DE
 190+ 6011 54           	LD D, H
 191+ 6012 5D           	LD E, L
 192+ 6013 01 08 00     	LD BC, 8
 193+ 6016 09           	ADD HL, BC
 194+ 6017 44           	LD B, H
 195+ 6018 4D           	LD C, L
 196+ 6019 C9           	RET
 197+ 601A              ; *******************************************************************************************************
 198+ 601A
 199+ 601A              ; *******************************************************************************************************
 200+ 601A              ; function rotates mask and character data and applies it to background
 201+ 601A              ; input IX=pointer to structure describing input data
 202+ 601A              ; +0  DW horizontal shift count 0-7 (low byte used)
 203+ 601A              ; +2  DW vertical shift count 0-7 (low byte used)
 204+ 601A              ; +4  DW background data start;
 205+ 601A              ; +6  DW background add to value to next row of background data
 206+ 601A              ; +8  DW mask data start;
 207+ 601A              ; +10  DW character data start;
 208+ 601A              ; +12 DW character&mask add to value to next row of data
 209+ 601A              ; +14 DW columns (low byte used)
 210+ 601A              ; +16 DW rows (low byte used)
 211+ 601A              SHIFT_MERGE_CHARACTER:
 212+ 601A DD 7E 00     	LD A, (IX) ; shift
 213+ 601D FE 05        	CP 5
 214+ 601F 38 25        	JR C, .RIGHT
 215+ 6021              	; shifts 5-7, use rotate towards left 1-3
 216+ 6021 21 76 5F     	LD HL, SHIFT58
 217+ 6024 22 C7 5F     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 218+ 6027 22 D9 5F     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 219+ 602A D6 05        	SUB 5
 220+ 602C 28 0D        	JR Z, .L1
 221+ 602E 87           	ADD A, A
 222+ 602F 87           	ADD A, A
 223+ 6030 67           	LD H, A
 224+ 6031 2E 18        	LD L, #18 ; JR opcode
 225+ 6033 22 7D 5F     	LD (SHIFT58.M1), HL
 226+ 6036 22 8E 5F     	LD (SHIFT58.M2), HL
 227+ 6039 18 32        	JR .DO
 228+ 603B              .L1:
 229+ 603B 21 00 00     	LD HL, 0 ; 2xNOP opcode
 230+ 603E 22 7D 5F     	LD (SHIFT58.M1), HL
 231+ 6041 22 8E 5F     	LD (SHIFT58.M2), HL
 232+ 6044 18 27        	JR .DO
 233+ 6046              .RIGHT:
 234+ 6046              	; shifts 0-4, rotate towards right
 235+ 6046 21 31 5F     	LD HL, SHIFT04
 236+ 6049 22 C7 5F     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 237+ 604C 22 D9 5F     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 238+ 604F FE 04        	CP 4
 239+ 6051 28 11        	JR Z, .R1
 240+ 6053 D6 04        	SUB 4
 241+ 6055 ED 44        	NEG
 242+ 6057 87           	ADD A, A
 243+ 6058 87           	ADD A, A
 244+ 6059 67           	LD H, A
 245+ 605A 2E 18        	LD L, #18 ; JR opcode
 246+ 605C 22 38 5F     	LD (SHIFT04.M1), HL
 247+ 605F 22 4D 5F     	LD (SHIFT04.M2), HL
 248+ 6062 18 09        	JR .DO
 249+ 6064              .R1:
 250+ 6064 21 00 00     	LD HL, 0 ; 2xNOP opcode
 251+ 6067 22 38 5F     	LD (SHIFT04.M1), HL
 252+ 606A 22 4D 5F     	LD (SHIFT04.M2), HL
 253+ 606D              .DO:
 254+ 606D DD 46 10     	LD B, (IX+16) ; rows
 255+ 6070 DD 6E 08     	LD L, (IX+8)
 256+ 6073 DD 66 09     	LD H, (IX+9) ; mask data
 257+ 6076 DD 5E 04     	LD E, (IX+4)
 258+ 6079 DD 56 05     	LD D, (IX+5) ; background data
 259+ 607C D9           	EXX
 260+ 607D DD 6E 0A     	LD L, (IX+10)
 261+ 6080 DD 66 0B     	LD H, (IX+11) ; character data
 262+ 6083 D9           	EXX
 263+ 6084              .LOOP:
 264+ 6084 C5           	PUSH BC
 265+ 6085 E5           		PUSH HL
 266+ 6086 D5           			PUSH DE
 267+ 6087 D9           				EXX
 268+ 6088 E5           				PUSH HL
 269+ 6089 D9           					EXX
 270+ 608A DD 7E 0E     					LD A, (IX+14) ; columns
 271+ 608D              .CALL:
 272+ 608D CD B3 5F     					CALL SHIFT_ROW
 273+ 6090 E1           				POP HL
 274+ 6091 DD 5E 0C     				LD E, (IX+12)
 275+ 6094 DD 56 0D     				LD D, (IX+13) ; char data to next row
 276+ 6097 19           				ADD HL, DE
 277+ 6098 D9           				EXX
 278+ 6099 E1           			POP HL
 279+ 609A DD 5E 06     			LD E, (IX+6)
 280+ 609D DD 56 07     			LD D, (IX+7) ; background to next row
 281+ 60A0 19           			ADD HL, DE
 282+ 60A1 EB           			EX DE, HL
 283+ 60A2 E1           		POP HL
 284+ 60A3 DD 4E 0C     		LD C, (IX+12)
 285+ 60A6 DD 46 0D     		LD B, (IX+13) ; char data to next row
 286+ 60A9 09           		ADD HL, BC
 287+ 60AA C1           	POP BC
 288+ 60AB 10 D7        	DJNZ .LOOP
 289+ 60AD C9           	RET
 290+ 60AE              ; *******************************************************************************************************
 291+ 60AE
 292+ 60AE              ; *******************************************************************************************************
 293+ 60AE              ; helper function DE \ 8
 294+ 60AE              DEdiv8:
 295+ 60AE 7B           	LD A,E
 296+ 60AF CB 2A        	SRA D
 297+ 60B1 CB 1F            RR  A
 298+ 60B3 CB 2A            SRA D
 299+ 60B5 CB 1F            RR  A
 300+ 60B7 CB 2A            SRA D
 301+ 60B9 CB 1F            RR  A
 302+ 60BB C9           	RET
 303+ 60BC              ; *******************************************************************************************************
 304+ 60BC
 305+ 60BC               IF (DEFUSR_EXTENSION == 1)
 306+ 60BC              ; *******************************************************************************************************
 307+ 60BC              ; function to handle BLIT basic extension through DEFUSR call in RAW format
 308+ 60BC              ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 309+ 60BC              ; +2  DW horizontal shift count 0-7 (low byte used)
 310+ 60BC              ; +4  DW vertical shift count 0-7 (low byte used)
 311+ 60BC              ; +6  DW background data start;
 312+ 60BC              ; +8  DW background add to value to next row of background data
 313+ 60BC              ; +10  DW mask data start;
 314+ 60BC              ; +12  DW character data start;
 315+ 60BC              ; +14 DW character&mask add to value to next row of data
 316+ 60BC              ; +16 DW columns (low byte used)
 317+ 60BC              ; +18 DW rows (low byte used)
 318+ 60BC              ; will put ram in page 0 also, page 1 is already there
 319+ 60BC              ;BLIT_DEFUSR:
 320+ 60BC              ;	DI
 321+ 60BC              ;	LD IY, .RET
 322+ 60BC              ;	JP ENABLE_PAGE0
 323+ 60BC              ;.RET:
 324+ 60BC              ;	EI
 325+ 60BC              ;	INC IX
 326+ 60BC              ;	INC IX
 327+ 60BC              ;	CALL SHIFT_MERGE_CHARACTER
 328+ 60BC              ;
 329+ 60BC              ;   POP DE
 330+ 60BC              ;    POP BC
 331+ 60BC              ;    JP RESTORE_PAGE_INFO
 332+ 60BC              ; *******************************************************************************************************
 333+ 60BC
 334+ 60BC              ; *******************************************************************************************************
 335+ 60BC              ; function to handle CALL BLIT basic extension in DEFUSR form
 336+ 60BC              ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 337+ 60BC              ; +02 x
 338+ 60BC              ; +04 y
 339+ 60BC              ; +06 char_data_pointer
 340+ 60BC              ; +08 mask_data_pointer
 341+ 60BC              ; +10 width
 342+ 60BC              ; +12 height
 343+ 60BC              ; +14 background_pointer
 344+ 60BC              ; +16 background_width
 345+ 60BC              ; BLIT ( INT x,
 346+ 60BC              ;		 INT y,
 347+ 60BC              ;		 INT char_data_pointer,
 348+ 60BC              ;		 INT mask_data_pointer,
 349+ 60BC              ;		 INT width (in characters),
 350+ 60BC              ;		 INT height (in characters),
 351+ 60BC              ;		 INT background_pointer (top left),
 352+ 60BC              ;		 INT background_width (in characters),
 353+ 60BC              BLIT_DEFUSR:
 354+ 60BC DD 5E 02     	LD E,(IX+2)
 355+ 60BF DD 56 03     	LD D,(IX+3)
 356+ 60C2 7B           	LD A,E
 357+ 60C3 E6 07        	AND 7
 358+ 60C5 32 70 66     	LD (BLIT_STRUCT+0),A
 359+ 60C8 CD AE 60     	CALL DEdiv8
 360+ 60CB 32 6C 66     	LD (BLIT_TMP+0),A
 361+ 60CE DD 5E 04     	LD E,(IX+4)
 362+ 60D1 DD 56 05     	LD D,(IX+5)
 363+ 60D4 7B           	LD A,E
 364+ 60D5 E6 07        	AND 7
 365+ 60D7 32 72 66     	LD (BLIT_STRUCT+2),A
 366+ 60DA CD AE 60     	CALL DEdiv8
 367+ 60DD 32 6D 66     	LD (BLIT_TMP+1),A
 368+ 60E0 DD 6E 06     	LD L,(IX+6)
 369+ 60E3 DD 66 07     	LD H,(IX+7)
 370+ 60E6 22 7A 66     	LD (BLIT_STRUCT+10),HL
 371+ 60E9 DD 6E 08     	LD L,(IX+8)
 372+ 60EC DD 66 09     	LD H,(IX+9)
 373+ 60EF 22 78 66     	LD (BLIT_STRUCT+8),HL
 374+ 60F2 DD 7E 0A     	LD A,(IX+10)
 375+ 60F5 32 7E 66     	LD (BLIT_STRUCT+14),A
 376+ 60F8 DD 7E 0C     	LD A,(IX+12)
 377+ 60FB 32 80 66     	LD (BLIT_STRUCT+16),A
 378+ 60FE DD 6E 0E     	LD L,(IX+14)
 379+ 6101 DD 66 0F     	LD H,(IX+15)
 380+ 6104 22 74 66     	LD (BLIT_STRUCT+4),HL
 381+ 6107              	;LD A,(IX+16)
 382+ 6107              	;LD (BLIT_TMP+2),A
 383+ 6107
 384+ 6107              	; calculate char&mask add to value
 385+ 6107 26 00        	LD H,0
 386+ 6109 3A 7E 66     	LD A,(BLIT_STRUCT+14)
 387+ 610C 6F           	LD L,A
 388+ 610D CD 6D 68     	CALL HLx8
 389+ 6110 22 7C 66     	LD (BLIT_STRUCT+12),HL
 390+ 6113              	; calculate background add to value
 391+ 6113 26 00        	LD H,0
 392+ 6115 DD 6E 10     	LD L,(IX+16)
 393+ 6118 CD 6D 68     	CALL HLx8
 394+ 611B 22 76 66     	LD (BLIT_STRUCT+6),HL
 395+ 611E              	; calculate pointer to background location
 396+ 611E 21 00 00     	LD HL,0
 397+ 6121 3A 6D 66     	LD A,(BLIT_TMP+1)
 398+ 6124 B7           	OR A
 399+ 6125 28 08        	JR Z, .L1
 400+ 6127 47           	LD B,A
 401+ 6128 ED 5B 76 66  	LD DE,(BLIT_STRUCT+6)
 402+ 612C              .L0:
 403+ 612C 19           	ADD HL, DE
 404+ 612D 10 FD        	DJNZ .L0
 405+ 612F              .L1:
 406+ 612F EB           	EX DE,HL
 407+ 6130 26 00        	LD H,0
 408+ 6132 3A 6C 66     	LD A,(BLIT_TMP+0)
 409+ 6135 6F           	LD L,A
 410+ 6136 CD 6D 68     	CALL HLx8
 411+ 6139 19           	ADD HL,DE
 412+ 613A ED 5B 74 66  	LD DE,(BLIT_STRUCT+4)
 413+ 613E 19           	ADD HL,DE
 414+ 613F 22 74 66     	LD (BLIT_STRUCT+4),HL
 415+ 6142
 416+ 6142 F3           	DI
 417+ 6143 FD 21 4A 61  	LD IY, .RET
 418+ 6147 C3 31 69     	JP ENABLE_PAGE0
 419+ 614A              .RET:
 420+ 614A FB           	EI
 421+ 614B DD 21 70 66  	LD IX, BLIT_STRUCT
 422+ 614F CD 1A 60     	CALL SHIFT_MERGE_CHARACTER
 423+ 6152
 424+ 6152 D1               POP DE
 425+ 6153 C1               POP BC
 426+ 6154 C3 A8 68         JP RESTORE_PAGE_INFO
 427+ 6157              ; *******************************************************************************************************
 428+ 6157               ENDIF
 429+ 6157
 430+ 6157               IF (BASIC_EXTENSION == 1)
 431+ 6157              ; *******************************************************************************************************
 432+ 6157              ; function to handle CALL BLIT basic extension
 433+ 6157              ; rotates 1-bit character drawing horizontally with mask and character data and
 434+ 6157              ; fuses with background data and applies vertical shift too
 435+ 6157              ; in form without pointers
 436+ 6157              ; BLIT ( INT x,
 437+ 6157              ;		 INT y,
 438+ 6157              ;		 INT char_data_pointer,
 439+ 6157              ;		 INT mask_data_pointer,
 440+ 6157              ;		 INT width (in characters),
 441+ 6157              ;		 INT height (in characters),
 442+ 6157              ;		 INT background_pointer (top left),
 443+ 6157              ;		 INT background_width (in characters),
 444+ 6157              ; will put ram in page 0 also, page 1 is already there
 445+ 6157              BLIT:
 446+ 6157              	; opening (
 447+ 6157 CD 7F 69     	CALL CHKCHAR
 448+ 615A 28           	DB '('
 449+ 615B              	; get x coordinate
 450+ 615B DD 21 2F 54  	LD IX, FRMQNT
 451+ 615F CD 59 01     	CALL CALBAS
 452+ 6162 7B           	LD A, E
 453+ 6163 E6 07        	AND 7
 454+ 6165 32 70 66     	LD (BLIT_STRUCT+0), A
 455+ 6168 CD AE 60     	CALL DEdiv8
 456+ 616B 32 6C 66     	LD (BLIT_TMP+0),A
 457+ 616E              	; comma
 458+ 616E CD 7F 69     	CALL CHKCHAR
 459+ 6171 2C           	DB ','
 460+ 6172              	; get y coordinate
 461+ 6172 DD 21 2F 54  	LD IX, FRMQNT
 462+ 6176 CD 59 01     	CALL CALBAS
 463+ 6179 7B           	LD A, E
 464+ 617A E6 07        	AND 7
 465+ 617C 32 72 66     	LD (BLIT_STRUCT+2), A
 466+ 617F CD AE 60     	CALL DEdiv8
 467+ 6182 32 6D 66     	LD (BLIT_TMP+1),A
 468+ 6185              	; comma
 469+ 6185 CD 7F 69     	CALL CHKCHAR
 470+ 6188 2C           	DB ','
 471+ 6189              	; get char data pointer
 472+ 6189 DD 21 2F 54  	LD IX, FRMQNT
 473+ 618D CD 59 01     	CALL CALBAS
 474+ 6190 ED 53 7A 66  	LD (BLIT_STRUCT+10), DE
 475+ 6194              	; comma
 476+ 6194 CD 7F 69     	CALL CHKCHAR
 477+ 6197 2C           	DB ','
 478+ 6198              	; get mask data pointer
 479+ 6198 DD 21 2F 54  	LD IX, FRMQNT
 480+ 619C CD 59 01     	CALL CALBAS
 481+ 619F ED 53 78 66  	LD (BLIT_STRUCT+8), DE
 482+ 61A3              	; comma
 483+ 61A3 CD 7F 69     	CALL CHKCHAR
 484+ 61A6 2C           	DB ','
 485+ 61A7              	; get width
 486+ 61A7 DD 21 2F 54  	LD IX, FRMQNT
 487+ 61AB CD 59 01     	CALL CALBAS
 488+ 61AE 7B           	LD A, E
 489+ 61AF 32 7E 66     	LD (BLIT_STRUCT+14), A
 490+ 61B2              	; comma
 491+ 61B2 CD 7F 69     	CALL CHKCHAR
 492+ 61B5 2C           	DB ','
 493+ 61B6              	; get height
 494+ 61B6 DD 21 2F 54  	LD IX, FRMQNT
 495+ 61BA CD 59 01     	CALL CALBAS
 496+ 61BD 7B           	LD A, E
 497+ 61BE 32 80 66     	LD (BLIT_STRUCT+16), A
 498+ 61C1              	; comma
 499+ 61C1 CD 7F 69     	CALL CHKCHAR
 500+ 61C4 2C           	DB ','
 501+ 61C5              	; get background pointer
 502+ 61C5 DD 21 2F 54  	LD IX, FRMQNT
 503+ 61C9 CD 59 01     	CALL CALBAS
 504+ 61CC ED 53 74 66  	LD (BLIT_STRUCT+4), DE
 505+ 61D0              	; comma
 506+ 61D0 CD 7F 69     	CALL CHKCHAR
 507+ 61D3 2C           	DB ','
 508+ 61D4              	; get background width
 509+ 61D4 DD 21 2F 54  	LD IX, FRMQNT
 510+ 61D8 CD 59 01     	CALL CALBAS
 511+ 61DB 7B           	LD A, E
 512+ 61DC 32 6E 66     	LD (BLIT_TMP+2), A
 513+ 61DF              	; ending )
 514+ 61DF CD 7F 69     	CALL CHKCHAR
 515+ 61E2 29           	DB ')'
 516+ 61E3
 517+ 61E3 E5           	PUSH HL ; save position in BASIC buffer
 518+ 61E4
 519+ 61E4              	; calculate char&mask add to value
 520+ 61E4 26 00        	LD H, 0
 521+ 61E6 3A 7E 66     	LD A, (BLIT_STRUCT+14)
 522+ 61E9 6F           	LD L, A
 523+ 61EA CD 6D 68     	CALL HLx8
 524+ 61ED 22 7C 66     	LD (BLIT_STRUCT+12), HL
 525+ 61F0              	; calculate background add to value
 526+ 61F0 26 00        	LD H, 0
 527+ 61F2 3A 6E 66     	LD A, (BLIT_TMP+2)
 528+ 61F5 6F           	LD L, A
 529+ 61F6 CD 6D 68     	CALL HLx8
 530+ 61F9 22 76 66     	LD (BLIT_STRUCT+6), HL
 531+ 61FC              	; calculate pointer to background location
 532+ 61FC 21 00 00     	LD HL, 0
 533+ 61FF 3A 6D 66     	LD A,(BLIT_TMP+1)
 534+ 6202 B7           	OR A
 535+ 6203 28 08        	JR Z, .L1
 536+ 6205 47           	LD B,A
 537+ 6206 ED 5B 76 66  	LD DE,(BLIT_STRUCT+6)
 538+ 620A              .L0:
 539+ 620A 19           	ADD HL, DE
 540+ 620B 10 FD        	DJNZ .L0
 541+ 620D              .L1:
 542+ 620D EB           	EX DE,HL
 543+ 620E 26 00        	LD H,0
 544+ 6210 3A 6C 66     	LD A,(BLIT_TMP+0)
 545+ 6213 6F           	LD L,A
 546+ 6214 CD 6D 68     	CALL HLx8
 547+ 6217 19           	ADD HL,DE
 548+ 6218 ED 5B 74 66  	LD DE,(BLIT_STRUCT+4)
 549+ 621C 19           	ADD HL,DE
 550+ 621D 22 74 66     	LD (BLIT_STRUCT+4),HL
 551+ 6220
 552+ 6220 F3           	DI
 553+ 6221 FD 21 28 62  	LD IY, .RET
 554+ 6225 C3 31 69     	JP ENABLE_PAGE0
 555+ 6228              .RET:
 556+ 6228 FB           	EI
 557+ 6229 DD 21 70 66  	LD IX, BLIT_STRUCT
 558+ 622D CD 1A 60     	CALL SHIFT_MERGE_CHARACTER
 559+ 6230
 560+ 6230 D1               POP DE
 561+ 6231 C1               POP BC
 562+ 6232 CD A8 68         CALL RESTORE_PAGE_INFO
 563+ 6235
 564+ 6235 E1           	POP HL
 565+ 6236 C9           	RET
 566+ 6237              ; *******************************************************************************************************
 567+ 6237               ENDIF
# file closed: asm\BLIT.asm
 159  6237               ENDIF
 160  6237
 161  6237               IF (TILE_CMDS == 1)
 162  6237               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
   1+ 6237              ; *******************************************************************************************************
   2+ 6237              ; generic function to implement tiling
   3+ 6237              ; should be modified to call appropriate function for memory or vram
   4+ 6237              ; input IX=pointer to following structure
   5+ 6237              ; +00 tile_data_ptr
   6+ 6237              ; +02 tile_rows
   7+ 6237              ; +04 tile_columns
   8+ 6237              ; +06 destination_address
   9+ 6237              ; +08 dest_to_next_row_add_to_value
  10+ 6237              ; +10 num_horizontal_tiles
  11+ 6237              ; +12 num_vertical_tiles
  12+ 6237              ; modifies AF, BC, DE, HL
  13+ 6237              TILE:
  14+ 6237 DD 6E 06     	LD L, (IX+6)
  15+ 623A DD 66 07     	LD H, (IX+7) ; destination address
  16+ 623D 22 6C 66     	LD (TILETMP1), HL
  17+ 6240 DD 46 0C     	LD B, (IX+12) ; vertical tile number
  18+ 6243              .L1:
  19+ 6243 C5           	PUSH BC
  20+ 6244 DD 6E 00     		LD L, (IX+0)
  21+ 6247 DD 66 01     		LD H, (IX+1) ; tile address
  22+ 624A 22 6E 66     		LD (TILETMP2), HL
  23+ 624D DD 46 02     		LD B, (IX+2) ; tile rows
  24+ 6250              .L2:
  25+ 6250 C5           		PUSH BC
  26+ 6251 CD 00 00     .CALL1:		CALL 0
  27+ 6254 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
  28+ 6257              .L3:
  29+ 6257 C5           			PUSH BC
  30+ 6258 2A 6E 66     				LD HL, (TILETMP2)
  31+ 625B DD 46 04     				LD B, (IX+4) ; tile columns
  32+ 625E              .L4:
  33+ 625E C5           				PUSH BC
  34+ 625F              .CALL2:
  35+ 625F CD 00 00     					CALL 0
  36+ 6262 C1           				POP BC
  37+ 6263 10 F9        				DJNZ .L4
  38+ 6265 C1           			POP BC
  39+ 6266 10 EF        			DJNZ .L3
  40+ 6268 22 6E 66     			LD (TILETMP2), HL
  41+ 626B 2A 6C 66     			LD HL, (TILETMP1)
  42+ 626E DD 5E 08     			LD E, (IX+8)
  43+ 6271 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
  44+ 6274 19           			ADD HL, DE
  45+ 6275 22 6C 66     			LD (TILETMP1), HL
  46+ 6278 C1           		POP BC
  47+ 6279 10 D5        		DJNZ .L2
  48+ 627B C1           	POP BC
  49+ 627C 10 C5        	DJNZ .L1
  50+ 627E C9           	RET
  51+ 627F              ; *******************************************************************************************************
  52+ 627F
  53+ 627F               IFNDEF CMDS_WITH_PARAMETERS
  54+ 627F ~            ; *******************************************************************************************************
  55+ 627F ~            ; function to handle CALL TILERAM basic extension
  56+ 627F ~            ; fills memory with tiles
  57+ 627F ~            ; TILERAM ( INT request_data_ptr )
  58+ 627F ~            ; request_data_ptr described in TILE
  59+ 627F ~            ; will put ram in page 0 also, page 1 is already there
  60+ 627F ~            TILERAM:
  61+ 627F ~            	; opening (
  62+ 627F ~            	CALL CHKCHAR
  63+ 627F ~            	DB '('
  64+ 627F ~            	; get pointer to request struct
  65+ 627F ~            	LD IX, FRMQNT
  66+ 627F ~            	CALL CALBAS
  67+ 627F ~            	PUSH DE
  68+ 627F ~            	; ending )
  69+ 627F ~            	CALL CHKCHAR
  70+ 627F ~            	DB ')'
  71+ 627F ~
  72+ 627F ~            	POP IX ; pointer to request struct
  73+ 627F ~
  74+ 627F ~            	PUSH HL ; save position in BASIC buffer
  75+ 627F ~            	DI
  76+ 627F ~            	LD IY, .RET
  77+ 627F ~            	JP ENABLE_PAGE0
  78+ 627F ~            .RET:
  79+ 627F ~            	EI
  80+ 627F ~            	; set RAM functions to call
  81+ 627F ~            	LD HL, .TILECOPY
  82+ 627F ~            	LD (TILE.CALL2+1), HL
  83+ 627F ~            	LD HL, .SETDESTROW
  84+ 627F ~            	LD (TILE.CALL1+1), HL
  85+ 627F ~            	LD A,1
  86+ 627F ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  87+ 627F ~            	CALL TILE
  88+ 627F ~            	XOR A
  89+ 627F ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  90+ 627F ~
  91+ 627F ~                POP DE
  92+ 627F ~                POP BC
  93+ 627F ~                CALL RESTORE_PAGE_INFO
  94+ 627F ~
  95+ 627F ~            	POP HL
  96+ 627F ~            	RET
  97+ 627F ~            .TILECOPY:
  98+ 627F ~            	.8 LDI
  99+ 627F ~            	RET
 100+ 627F ~            .SETDESTROW:
 101+ 627F ~            	LD DE, (TILETMP1)
 102+ 627F ~            	RET
 103+ 627F ~            ; *******************************************************************************************************
 104+ 627F               ENDIF
 105+ 627F
 106+ 627F               IFDEF CMDS_WITH_PARAMETERS
 107+ 627F              ; *******************************************************************************************************
 108+ 627F              ; function to handle CALL TILERAM basic extension
 109+ 627F              ; fills memory with tiles
 110+ 627F              ; TILERAM ( INT tile_data_pointer,
 111+ 627F              ;			INT tile_columns,
 112+ 627F              ;			INT tile_rows,
 113+ 627F              ;			INT destination_pointer,
 114+ 627F              ;			INT destination_columns,
 115+ 627F              ;			INT destination_rows,
 116+ 627F              ;			INT destination_begin_column,
 117+ 627F              ;			INT destination_begin_row,
 118+ 627F              ;			INT number_of_tiles_horizontally,
 119+ 627F              ;			INT	number_of_tiles_vertically )
 120+ 627F              ; will put ram in page 0 also, page 1 is already there
 121+ 627F              TILERAM:
 122+ 627F              	; opening (
 123+ 627F CD 7F 69     	CALL CHKCHAR
 124+ 6282 28           	DB '('
 125+ 6283              	; get tile data pointer coordinate
 126+ 6283 DD 21 2F 54  	LD IX, FRMQNT
 127+ 6287 CD 59 01     	CALL CALBAS
 128+ 628A ED 53 70 66  	LD (BLIT_STRUCT+0), DE
 129+ 628E              	; comma
 130+ 628E CD 7F 69     	CALL CHKCHAR
 131+ 6291 2C           	DB ','
 132+ 6292              	; get tile columns
 133+ 6292 DD 21 2F 54  	LD IX, FRMQNT
 134+ 6296 CD 59 01     	CALL CALBAS
 135+ 6299 ED 53 74 66  	LD (BLIT_STRUCT+4), DE
 136+ 629D              	; comma
 137+ 629D CD 7F 69     	CALL CHKCHAR
 138+ 62A0 2C           	DB ','
 139+ 62A1              	; get tile columns
 140+ 62A1 DD 21 2F 54  	LD IX, FRMQNT
 141+ 62A5 CD 59 01     	CALL CALBAS
 142+ 62A8 ED 53 72 66  	LD (BLIT_STRUCT+2), DE
 143+ 62AC              	; comma
 144+ 62AC CD 7F 69     	CALL CHKCHAR
 145+ 62AF 2C           	DB ','
 146+ 62B0              	; get destintion pointer
 147+ 62B0 DD 21 2F 54  	LD IX, FRMQNT
 148+ 62B4 CD 59 01     	CALL CALBAS
 149+ 62B7 ED 53 76 66  	LD (BLIT_STRUCT+6), DE
 150+ 62BB              	; comma
 151+ 62BB CD 7F 69     	CALL CHKCHAR
 152+ 62BE 2C           	DB ','
 153+ 62BF              	; get destination columns
 154+ 62BF DD 21 2F 54  	LD IX, FRMQNT
 155+ 62C3 CD 59 01     	CALL CALBAS
 156+ 62C6 7B           	LD A, E
 157+ 62C7 32 6C 66     	LD (BLIT_TMP+0), A
 158+ 62CA              	; comma
 159+ 62CA CD 7F 69     	CALL CHKCHAR
 160+ 62CD 2C           	DB ','
 161+ 62CE              	; get destination rows
 162+ 62CE DD 21 2F 54  	LD IX, FRMQNT
 163+ 62D2 CD 59 01     	CALL CALBAS
 164+ 62D5 7B           	LD A, E
 165+ 62D6 32 6D 66     	LD (BLIT_TMP+1), A
 166+ 62D9              	; comma
 167+ 62D9 CD 7F 69     	CALL CHKCHAR
 168+ 62DC 2C           	DB ','
 169+ 62DD              	; get destination begin column
 170+ 62DD DD 21 2F 54  	LD IX, FRMQNT
 171+ 62E1 CD 59 01     	CALL CALBAS
 172+ 62E4 7B           	LD A, E
 173+ 62E5 32 6E 66     	LD (BLIT_TMP+2), A
 174+ 62E8              	; comma
 175+ 62E8 CD 7F 69     	CALL CHKCHAR
 176+ 62EB 2C           	DB ','
 177+ 62EC              	; get destination begin row
 178+ 62EC DD 21 2F 54  	LD IX, FRMQNT
 179+ 62F0 CD 59 01     	CALL CALBAS
 180+ 62F3 7B           	LD A, E
 181+ 62F4 32 6F 66     	LD (BLIT_TMP+3), A
 182+ 62F7              	; comma
 183+ 62F7 CD 7F 69     	CALL CHKCHAR
 184+ 62FA 2C           	DB ','
 185+ 62FB              	; get number of tiles horizontally
 186+ 62FB DD 21 2F 54  	LD IX, FRMQNT
 187+ 62FF CD 59 01     	CALL CALBAS
 188+ 6302 ED 53 7A 66  	LD (BLIT_STRUCT+10), DE
 189+ 6306              	; comma
 190+ 6306 CD 7F 69     	CALL CHKCHAR
 191+ 6309 2C           	DB ','
 192+ 630A              	; get number of tiles vertically
 193+ 630A DD 21 2F 54  	LD IX, FRMQNT
 194+ 630E CD 59 01     	CALL CALBAS
 195+ 6311 ED 53 7C 66  	LD (BLIT_STRUCT+12), DE
 196+ 6315              	; ending )
 197+ 6315 CD 7F 69     	CALL CHKCHAR
 198+ 6318 29           	DB ')'
 199+ 6319
 200+ 6319 E5           	PUSH HL ; save position in BASIC buffer
 201+ 631A
 202+ 631A              	; calculate destination add to value
 203+ 631A 26 00        	LD H, 0
 204+ 631C 3A 6C 66     	LD A, (BLIT_TMP+0)
 205+ 631F 6F           	LD L, A
 206+ 6320 CD 6D 68     	CALL HLx8
 207+ 6323 22 78 66     	LD (BLIT_STRUCT+8), HL
 208+ 6326              	; calculate pointer to background location
 209+ 6326 21 00 00     	LD HL, 0
 210+ 6329 3A 6F 66     	LD A,(BLIT_TMP+3)
 211+ 632C B7           	OR A
 212+ 632D 28 08        	JR Z, .L1
 213+ 632F 47           	LD B,A
 214+ 6330 ED 5B 78 66  	LD DE,(BLIT_STRUCT+8)
 215+ 6334              .L0:
 216+ 6334 19           	ADD HL, DE
 217+ 6335 10 FD        	DJNZ .L0
 218+ 6337              .L1:
 219+ 6337 EB           	EX DE,HL
 220+ 6338 26 00        	LD H,0
 221+ 633A 3A 6E 66     	LD A,(BLIT_TMP+2)
 222+ 633D 6F           	LD L,A
 223+ 633E CD 6D 68     	CALL HLx8
 224+ 6341 19           	ADD HL,DE
 225+ 6342 ED 5B 76 66  	LD DE,(BLIT_STRUCT+6)
 226+ 6346 19           	ADD HL,DE
 227+ 6347 22 76 66     	LD (BLIT_STRUCT+6),HL
 228+ 634A F3           	DI
 229+ 634B FD 21 52 63  	LD IY, .RET
 230+ 634F C3 31 69     	JP ENABLE_PAGE0
 231+ 6352              .RET:
 232+ 6352 FB           	EI
 233+ 6353              	; set RAM functions to call
 234+ 6353 21 6D 63     	LD HL, .TILECOPY
 235+ 6356 22 60 62     	LD (TILE.CALL2+1), HL
 236+ 6359 21 7E 63     	LD HL, .SETDESTROW
 237+ 635C 22 52 62     	LD (TILE.CALL1+1), HL
 238+ 635F DD 21 70 66  	LD IX,BLIT_STRUCT
 239+ 6363 CD 37 62     	CALL TILE
 240+ 6366
 241+ 6366 D1               POP DE
 242+ 6367 C1               POP BC
 243+ 6368 CD A8 68         CALL RESTORE_PAGE_INFO
 244+ 636B
 245+ 636B E1           	POP HL
 246+ 636C C9           	RET
 247+ 636D              .TILECOPY:
 248+ 636D ED A0       > LDI
 248+ 636F ED A0       > LDI
 248+ 6371 ED A0       > LDI
 248+ 6373 ED A0       > LDI
 248+ 6375 ED A0       > LDI
 248+ 6377 ED A0       > LDI
 248+ 6379 ED A0       > LDI
 248+ 637B ED A0       > LDI
 249+ 637D C9           	RET
 250+ 637E              .SETDESTROW:
 251+ 637E ED 5B 6C 66  	LD DE, (TILETMP1)
 252+ 6382 C9           	RET
 253+ 6383              ; *******************************************************************************************************
 254+ 6383               ENDIF
 255+ 6383
 256+ 6383               IFDEF CMDS_WITH_PARAMETERS
 257+ 6383              ; *******************************************************************************************************
 258+ 6383              ; function to handle CALL TILEVRM basic extension
 259+ 6383              ; fills vram with tiles
 260+ 6383              ; TILEVRM ( INT tile_data_pointer,
 261+ 6383              ;			INT tile_columns,
 262+ 6383              ;			INT tile_rows,
 263+ 6383              ;			INT destination_begin_column,
 264+ 6383              ;			INT destination_begin_row,
 265+ 6383              ;			INT number_of_tiles_horizontally,
 266+ 6383              ;			INT	number_of_tiles_vertically )
 267+ 6383              ; will put ram in page 0 also, page 1 is already there
 268+ 6383              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
 269+ 6383              TILEVRM:
 270+ 6383              	; opening (
 271+ 6383 CD 7F 69     	CALL CHKCHAR
 272+ 6386 28           	DB '('
 273+ 6387              	; get tile data pointer coordinate
 274+ 6387 DD 21 2F 54  	LD IX, FRMQNT
 275+ 638B CD 59 01     	CALL CALBAS
 276+ 638E ED 53 70 66  	LD (BLIT_STRUCT+0), DE
 277+ 6392              	; comma
 278+ 6392 CD 7F 69     	CALL CHKCHAR
 279+ 6395 2C           	DB ','
 280+ 6396              	; get tile columns
 281+ 6396 DD 21 2F 54  	LD IX, FRMQNT
 282+ 639A CD 59 01     	CALL CALBAS
 283+ 639D ED 53 74 66  	LD (BLIT_STRUCT+4), DE
 284+ 63A1              	; comma
 285+ 63A1 CD 7F 69     	CALL CHKCHAR
 286+ 63A4 2C           	DB ','
 287+ 63A5              	; get tile columns
 288+ 63A5 DD 21 2F 54  	LD IX, FRMQNT
 289+ 63A9 CD 59 01     	CALL CALBAS
 290+ 63AC ED 53 72 66  	LD (BLIT_STRUCT+2), DE
 291+ 63B0              	; comma
 292+ 63B0 CD 7F 69     	CALL CHKCHAR
 293+ 63B3 2C           	DB ','
 294+ 63B4              	; get destination begin column
 295+ 63B4 DD 21 2F 54  	LD IX, FRMQNT
 296+ 63B8 CD 59 01     	CALL CALBAS
 297+ 63BB 7B           	LD A, E
 298+ 63BC 32 6E 66     	LD (BLIT_TMP+2), A
 299+ 63BF              	; comma
 300+ 63BF CD 7F 69     	CALL CHKCHAR
 301+ 63C2 2C           	DB ','
 302+ 63C3              	; get destination begin row
 303+ 63C3 DD 21 2F 54  	LD IX, FRMQNT
 304+ 63C7 CD 59 01     	CALL CALBAS
 305+ 63CA 7B           	LD A, E
 306+ 63CB 32 6F 66     	LD (BLIT_TMP+3), A
 307+ 63CE              	; comma
 308+ 63CE CD 7F 69     	CALL CHKCHAR
 309+ 63D1 2C           	DB ','
 310+ 63D2              	; get number of tiles horizontally
 311+ 63D2 DD 21 2F 54  	LD IX, FRMQNT
 312+ 63D6 CD 59 01     	CALL CALBAS
 313+ 63D9 ED 53 7A 66  	LD (BLIT_STRUCT+10), DE
 314+ 63DD              	; comma
 315+ 63DD CD 7F 69     	CALL CHKCHAR
 316+ 63E0 2C           	DB ','
 317+ 63E1              	; get number of tiles vertically
 318+ 63E1 DD 21 2F 54  	LD IX, FRMQNT
 319+ 63E5 CD 59 01     	CALL CALBAS
 320+ 63E8 ED 53 7C 66  	LD (BLIT_STRUCT+12), DE
 321+ 63EC              	; ending )
 322+ 63EC CD 7F 69     	CALL CHKCHAR
 323+ 63EF 29           	DB ')'
 324+ 63F0
 325+ 63F0 E5           	PUSH HL ; save position in BASIC buffer
 326+ 63F1
 327+ 63F1              	; calculate destination add to value
 328+ 63F1 21 00 01     	LD HL, 256
 329+ 63F4 22 78 66     	LD (BLIT_STRUCT+8), HL
 330+ 63F7              	; calculate pointer to background location
 331+ 63F7 3A 6F 66     	LD A,(BLIT_TMP+3)
 332+ 63FA 67           	LD H,A
 333+ 63FB 2E 00        	LD L,0
 334+ 63FD EB           	EX DE,HL
 335+ 63FE 26 00        	LD H,0
 336+ 6400 3A 6E 66     	LD A,(BLIT_TMP+2)
 337+ 6403 6F           	LD L,A
 338+ 6404 CD 6D 68     	CALL HLx8
 339+ 6407 19           	ADD HL,DE
 340+ 6408 ED 5B CB F3  	LD DE,(GRPCGP)
 341+ 640C 19           	ADD HL,DE
 342+ 640D 22 76 66     	LD (BLIT_STRUCT+6),HL
 343+ 6410 F3           	DI
 344+ 6411 FD 21 18 64  	LD IY, .RET
 345+ 6415 C3 31 69     	JP ENABLE_PAGE0
 346+ 6418              .RET:
 347+ 6418 FB           	EI
 348+ 6419              	; set RAM functions to call
 349+ 6419 21 33 64     	LD HL, .TILECOPY
 350+ 641C 22 60 62     	LD (TILE.CALL2+1), HL
 351+ 641F 21 39 64     	LD HL, .SETDESTROW
 352+ 6422 22 52 62     	LD (TILE.CALL1+1), HL
 353+ 6425 DD 21 70 66  	LD IX,BLIT_STRUCT
 354+ 6429 CD 37 62     	CALL TILE
 355+ 642C
 356+ 642C D1               POP DE
 357+ 642D C1               POP BC
 358+ 642E CD A8 68         CALL RESTORE_PAGE_INFO
 359+ 6431
 360+ 6431 E1           	POP HL
 361+ 6432 C9           	RET
 362+ 6433              .TILECOPY:
 363+ 6433 01 98 08     	LD BC, #0898
 364+ 6436 C3 65 68     	JP BBYTECOPY_NO_C
 365+ 6439              .SETDESTROW:
 366+ 6439 2A 6C 66     	LD HL, (TILETMP1)
 367+ 643C F3           	DI
 368+ 643D CD 58 68     	CALL SETWRT_LOCAL
 369+ 6440 FB           	EI
 370+ 6441 C9           	RET
 371+ 6442              ; *******************************************************************************************************
 372+ 6442               ENDIF
 373+ 6442
 374+ 6442               IFNDEF CMDS_WITH_PARAMETERS
 375+ 6442 ~            ; *******************************************************************************************************
 376+ 6442 ~            ; function to handle CALL TILEVRM basic extension
 377+ 6442 ~            ; fills vram with tiles
 378+ 6442 ~            ; TILEVRM ( INT request_data_ptr )
 379+ 6442 ~            ; request_data_ptr described in TILE
 380+ 6442 ~            ; will put ram in page 0 also, page 1 is already there
 381+ 6442 ~            TILEVRM:
 382+ 6442 ~            	; opening (
 383+ 6442 ~            	CALL CHKCHAR
 384+ 6442 ~            	DB '('
 385+ 6442 ~            	; get pointer to request struct
 386+ 6442 ~            	LD IX, FRMQNT
 387+ 6442 ~            	CALL CALBAS
 388+ 6442 ~            	PUSH DE
 389+ 6442 ~            	; ending )
 390+ 6442 ~            	CALL CHKCHAR
 391+ 6442 ~            	DB ')'
 392+ 6442 ~
 393+ 6442 ~            	POP IX ; pointer to request struct
 394+ 6442 ~
 395+ 6442 ~            	PUSH HL ; save position in BASIC buffer
 396+ 6442 ~            	DI
 397+ 6442 ~            	LD IY, .RET
 398+ 6442 ~            	JP ENABLE_PAGE0
 399+ 6442 ~            .RET:
 400+ 6442 ~            	EI
 401+ 6442 ~            	; set RAM functions to call
 402+ 6442 ~            	LD HL, .TILECOPY
 403+ 6442 ~            	LD (TILE.CALL2+1), HL
 404+ 6442 ~            	LD HL, .SETDESTROW
 405+ 6442 ~            	LD (TILE.CALL1+1), HL
 406+ 6442 ~            	CALL TILE
 407+ 6442 ~
 408+ 6442 ~                POP DE
 409+ 6442 ~                POP BC
 410+ 6442 ~                CALL RESTORE_PAGE_INFO
 411+ 6442 ~
 412+ 6442 ~            	POP HL
 413+ 6442 ~            	RET
 414+ 6442 ~            .TILECOPY:
 415+ 6442 ~            	LD BC, #0898
 416+ 6442 ~            	JP BBYTECOPY_NO_C
 417+ 6442 ~            .SETDESTROW:
 418+ 6442 ~            	LD HL, (TILETMP1)
 419+ 6442 ~            	DI
 420+ 6442 ~            	CALL SETWRT_LOCAL
 421+ 6442 ~            	EI
 422+ 6442 ~            	RET
 423+ 6442 ~            ; *******************************************************************************************************
 424+ 6442               ENDIF
# file closed: asm\TILE.asm
 163  6442               ENDIF
 164  6442
 165  6442               IF (COLL_CMD == 1)
 166  6442               INCLUDE "COLLISION.asm"
# file opened: asm\COLLISION.asm
   1+ 6442              ; generic collision checking routines
   2+ 6442              ; in BASIC we use rectangle structure array DIM R%(7,n) of the format
   3+ 6442              ; R%(0,n) is active flag, <>0 active / 0 skipped in checks
   4+ 6442              ; R%(1,n) is either upper left x coordinate or sprite id (0-31) depending on R(7,n)
   5+ 6442              ; R%(2,n) is either upper left y coordinate or unused depending on R(7,n)
   6+ 6442              ; R%(3,n) x offset where rectangle begins
   7+ 6442              ; R%(4,n) y offset where rectangle begins
   8+ 6442              ; R%(5,n) is width
   9+ 6442              ; R%(6,n) is height
  10+ 6442              ; R%(7,0) is type, 0=generic where R%(1,0) contains x coordinate
  11+ 6442              ;                  <>0 sprite where R%(1,0) contains sprite id
  12+ 6442              ; for type sprite, upper left coordinates are taken from sprite attribute array
  13+ 6442
  14+ 6442              ; ************************************************************************************************
  15+ 6442              ; quick test if HL<=DE<=HL+BC
  16+ 6442              ; input BC=width, DE=x, HL=min
  17+ 6442              ; if not true flag C set
  18+ 6442              ; modifies AF
  19+ 6442              GENERIC_INNER_CHECK:
  20+ 6442 E5               PUSH HL
  21+ 6443 D5               PUSH DE
  22+ 6444 EB               EX DE,HL
  23+ 6445 A7               AND A
  24+ 6446 ED 52            SBC HL, DE
  25+ 6448 FA 56 64         JP M, .GENERIC_INNER_CHECK_NOT
  26+ 644B A7               AND A
  27+ 644C ED 42            SBC HL, BC
  28+ 644E 28 03            JR Z, .L2
  29+ 6450 F2 56 64         JP P, .GENERIC_INNER_CHECK_NOT
  30+ 6453              .L2:
  31+ 6453 A7               AND A
  32+ 6454 18 01            JR .EXIT
  33+ 6456              .GENERIC_INNER_CHECK_NOT:
  34+ 6456 37               SCF
  35+ 6457              .EXIT:
  36+ 6457 D1               POP DE
  37+ 6458 E1               POP HL
  38+ 6459 C9               RET
  39+ 645A              ; ************************************************************************************************
  40+ 645A
  41+ 645A              ; ************************************************************************************************
  42+ 645A              ; function to check if rectangles are overlapping
  43+ 645A              ; input IX=IY=pointer to struct
  44+ 645A              ;  +00 active flag
  45+ 645A              ;  +02 x coordinate
  46+ 645A              ;  +04 y coordinate
  47+ 645A              ;  +06 x offset where rectangle begins
  48+ 645A              ;  +08 y offset where rectangle begins
  49+ 645A              ;  +10 width
  50+ 645A              ;  +12 height
  51+ 645A              ; where IY is used to read +2 and +4, and IX to read +6, +8, +10 and +12
  52+ 645A              ; this is a hack to allow location being taken from sprite attributes table
  53+ 645A              ; input BLIT_STRUCT data
  54+ 645A              ;  +00 x coordinate
  55+ 645A              ;  +02 y coordinate
  56+ 645A              ;  +04 width
  57+ 645A              ;  +06 height
  58+ 645A              ; returns CF=1 if not overlapping, CF=0 if overlapping
  59+ 645A              RECTANGLE_OVERLAP_CHECK:
  60+ 645A                  ; first check which rectangle is higher
  61+ 645A DD 6E 0C         LD L,(IX+12)
  62+ 645D DD 66 0D         LD H,(IX+13)
  63+ 6460 ED 5B 76 66      LD DE,(BLIT_STRUCT+6)
  64+ 6464 A7               AND A
  65+ 6465 ED 52            SBC HL,DE
  66+ 6467 FD 6E 04         LD L,(IY+4)
  67+ 646A FD 66 05         LD H,(IY+5)
  68+ 646D DD 5E 08         LD E,(IX+8)
  69+ 6470 DD 56 09         LD D,(IX+9)
  70+ 6473 FA 93 64         JP M,.L1
  71+ 6476                  ; equally high or IX defined one higher
  72+ 6476                  ; check upper boundary
  73+ 6476 19               ADD HL,DE
  74+ 6477 ED 5B 72 66      LD DE,(BLIT_STRUCT+2)
  75+ 647B DD 4E 0C         LD C,(IX+12)
  76+ 647E DD 46 0D         LD B,(IX+13)
  77+ 6481 CD 42 64         CALL GENERIC_INNER_CHECK
  78+ 6484 30 29            JR NC,.INSIDE
  79+ 6486                  ; check lower boundary
  80+ 6486 E5               PUSH HL
  81+ 6487 2A 76 66         LD HL,(BLIT_STRUCT+6)
  82+ 648A 19               ADD HL,DE
  83+ 648B EB               EX DE,HL
  84+ 648C E1               POP HL
  85+ 648D CD 42 64         CALL GENERIC_INNER_CHECK
  86+ 6490 30 1D            JR NC,.INSIDE
  87+ 6492 C9               RET ; not overlapping
  88+ 6493              .L1:
  89+ 6493                  ; rectangle defined in BLIT_STRUCT is higher
  90+ 6493 19               ADD HL,DE
  91+ 6494 EB               EX DE,HL
  92+ 6495 2A 72 66         LD HL,(BLIT_STRUCT+2)
  93+ 6498 ED 4B 76 66      LD BC,(BLIT_STRUCT+6)
  94+ 649C CD 42 64         CALL GENERIC_INNER_CHECK
  95+ 649F 30 0E            JR NC,.INSIDE
  96+ 64A1 E5               PUSH HL
  97+ 64A2 DD 6E 0C         LD L,(IX+12)
  98+ 64A5 DD 66 0D         LD H,(IX+13)
  99+ 64A8 19               ADD HL,DE
 100+ 64A9 EB               EX DE,HL
 101+ 64AA E1               POP HL
 102+ 64AB CD 42 64         CALL GENERIC_INNER_CHECK
 103+ 64AE D8               RET C
 104+ 64AF              .INSIDE:
 105+ 64AF                  ; check x coordinate
 106+ 64AF                  ; first check which rectangle is wider
 107+ 64AF DD 6E 0A         LD L,(IX+10)
 108+ 64B2 DD 66 0B         LD H,(IX+11)
 109+ 64B5 ED 5B 74 66      LD DE,(BLIT_STRUCT+4)
 110+ 64B9 A7               AND A
 111+ 64BA ED 52            SBC HL,DE
 112+ 64BC FD 6E 02         LD L,(IY+2)
 113+ 64BF FD 66 03         LD H,(IY+3)
 114+ 64C2 DD 5E 06         LD E,(IX+6)
 115+ 64C5 DD 56 07         LD D,(IX+7)
 116+ 64C8 FA E4 64         JP M,.L2
 117+ 64CB                  ; equally wide or IX defined one wider
 118+ 64CB                  ; check left boundary
 119+ 64CB 19               ADD HL,DE
 120+ 64CC ED 5B 70 66      LD DE,(BLIT_STRUCT+0)
 121+ 64D0 DD 4E 0A         LD C,(IX+10)
 122+ 64D3 DD 46 0B         LD B,(IX+11)
 123+ 64D6 CD 42 64         CALL GENERIC_INNER_CHECK
 124+ 64D9 D0               RET NC ; overlap
 125+ 64DA                  ; check right boundary
 126+ 64DA E5               PUSH HL
 127+ 64DB 2A 74 66         LD HL,(BLIT_STRUCT+4)
 128+ 64DE 19               ADD HL,DE
 129+ 64DF EB               EX DE,HL
 130+ 64E0 E1               POP HL
 131+ 64E1 C3 42 64         JP GENERIC_INNER_CHECK ; CF and result set by fn call
 132+ 64E4              .L2:
 133+ 64E4                  ; rectangle defined in BLIT_STRUCT is higher
 134+ 64E4 19               ADD HL,DE
 135+ 64E5 EB               EX DE,HL
 136+ 64E6 2A 70 66         LD HL,(BLIT_STRUCT+0)
 137+ 64E9 ED 4B 74 66      LD BC,(BLIT_STRUCT+4)
 138+ 64ED CD 42 64         CALL GENERIC_INNER_CHECK
 139+ 64F0 D0               RET NC ; overlap
 140+ 64F1 E5               PUSH HL
 141+ 64F2 DD 6E 0A         LD L,(IX+10)
 142+ 64F5 DD 66 0B         LD H,(IX+11)
 143+ 64F8 19               ADD HL,DE
 144+ 64F9 EB               EX DE,HL
 145+ 64FA E1               POP HL
 146+ 64FB C3 42 64         JP GENERIC_INNER_CHECK
 147+ 64FE              ; ************************************************************************************************
 148+ 64FE
 149+ 64FE              ; ************************************************************************************************
 150+ 64FE              ; function tries to find rectangle overlap and returns an index if found
 151+ 64FE              ; input BLIT_STRUCT data
 152+ 64FE              ;  +00 x coordinate
 153+ 64FE              ;  +02 y coordinate
 154+ 64FE              ;  +04 width
 155+ 64FE              ;  +06 height
 156+ 64FE              ;  +08 number of items in a list, described under RECTANGLE_OVERLAP_CHECK
 157+ 64FE              ;  +09 pointer to first element of R%(7,n)
 158+ 64FE              ;  +11 pointer to INT result variable
 159+ 64FE              ; returns CF=1 if not overlapping
 160+ 64FE              ; returns A=list index and CF=0 if overlapping
 161+ 64FE              FIND_OVERLAP:
 162+ 64FE 3A 78 66         LD A,(BLIT_STRUCT+8)
 163+ 6501 47               LD B,A
 164+ 6502 DD 2A 79 66      LD IX,(BLIT_STRUCT+9)
 165+ 6506              .L1:
 166+ 6506 C5               PUSH BC
 167+ 6507                  ; check active flag
 168+ 6507 DD 7E 00         LD A,(IX)
 169+ 650A DD B6 01         OR (IX+1)
 170+ 650D 28 18            JR Z,.NEXT
 171+ 650F                  ; check type
 172+ 650F DD 7E 0E         LD A,(IX+14)
 173+ 6512 DD B6 0F         OR (IX+15)
 174+ 6515 20 1A            JR NZ,.L2
 175+ 6517 DD E5            PUSH IX
 176+ 6519 FD E1            POP IY
 177+ 651B              .L3:
 178+ 651B CD 5A 64         CALL RECTANGLE_OVERLAP_CHECK
 179+ 651E 38 07            JR C,.NEXT
 180+ 6520                  ; found
 181+ 6520 C1               POP BC
 182+ 6521 3A 78 66         LD A,(BLIT_STRUCT+8)
 183+ 6524 90               SUB B
 184+ 6525 A7               AND A
 185+ 6526 C9               RET
 186+ 6527              .NEXT:
 187+ 6527 11 10 00         LD DE,16
 188+ 652A DD 19            ADD IX,DE
 189+ 652C C1               POP BC
 190+ 652D 10 D7            DJNZ .L1
 191+ 652F 37               SCF
 192+ 6530 C9               RET
 193+ 6531              .L2:
 194+ 6531                  ; sprite, need to build a temporary data struct since x and y values are inversed
 195+ 6531                  ; at BLIT_STRUCT+13
 196+ 6531 DD 7E 02         LD A,(IX+2) ; sprite ID
 197+ 6534 CD 89 4D         CALL GETnthSPRATTR
 198+ 6537 FD 21 7B 66      LD IY,BLIT_STRUCT+11
 199+ 653B 7E               LD A,(HL)
 200+ 653C FD 77 04         LD (IY+4),A
 201+ 653F 23               INC HL
 202+ 6540 7E               LD A,(HL)
 203+ 6541 FD 77 05         LD (IY+5),A
 204+ 6544 23               INC HL
 205+ 6545 7E               LD A,(HL)
 206+ 6546 FD 77 02         LD (IY+2),A
 207+ 6549 23               INC HL
 208+ 654A 7E               LD A,(HL)
 209+ 654B FD 77 03         LD (IY+3),A
 210+ 654E 18 CB            JR .L3
 211+ 6550              ; ************************************************************************************************
 212+ 6550
 213+ 6550               IF (BASIC_EXTENSION == 1)
 214+ 6550              ; ************************************************************************************************
 215+ 6550              ; function to handle CALL COLL basic extension
 216+ 6550              ; checks for collision between player and other rectangles
 217+ 6550              ; COLL ( INT result variable,
 218+ 6550              ;	     INT player x value,
 219+ 6550              ;	     INT player y value,
 220+ 6550              ;	     INT player width,
 221+ 6550              ;	     INT player height,
 222+ 6550              ;	     INT number of items in a list,
 223+ 6550              ;		 INT[6][n] rectangle struct )
 224+ 6550              ; will fill result variable with index or -1 if no collision
 225+ 6550              ; rectangle struct described under RECTANGLE_OVERLAP_CHECK
 226+ 6550              COLL:
 227+ 6550              	; opening (
 228+ 6550 CD 7F 69     	CALL CHKCHAR
 229+ 6553 28           	DB '('
 230+ 6554              	; get address of result variable
 231+ 6554 DD 21 A4 5E  	LD IX, PTRGET
 232+ 6558 CD 59 01     	CALL CALBAS
 233+ 655B ED 53 7B 66  	LD (BLIT_STRUCT+11),DE
 234+ 655F              	; comma
 235+ 655F CD 7F 69     	CALL CHKCHAR
 236+ 6562 2C           	DB ','
 237+ 6563              	; get x
 238+ 6563 DD 21 2F 54  	LD IX, FRMQNT
 239+ 6567 CD 59 01     	CALL CALBAS
 240+ 656A ED 53 70 66  	LD (BLIT_STRUCT+0),DE
 241+ 656E              	; comma
 242+ 656E CD 7F 69     	CALL CHKCHAR
 243+ 6571 2C           	DB ','
 244+ 6572              	; get y
 245+ 6572 DD 21 2F 54  	LD IX, FRMQNT
 246+ 6576 CD 59 01     	CALL CALBAS
 247+ 6579 ED 53 72 66  	LD (BLIT_STRUCT+2),DE
 248+ 657D              	; comma
 249+ 657D CD 7F 69     	CALL CHKCHAR
 250+ 6580 2C           	DB ','
 251+ 6581              	; get width
 252+ 6581 DD 21 2F 54  	LD IX, FRMQNT
 253+ 6585 CD 59 01     	CALL CALBAS
 254+ 6588 ED 53 74 66  	LD (BLIT_STRUCT+4),DE
 255+ 658C              	; comma
 256+ 658C CD 7F 69     	CALL CHKCHAR
 257+ 658F 2C           	DB ','
 258+ 6590              	; get height
 259+ 6590 DD 21 2F 54  	LD IX, FRMQNT
 260+ 6594 CD 59 01     	CALL CALBAS
 261+ 6597 ED 53 76 66  	LD (BLIT_STRUCT+6),DE
 262+ 659B              	; comma
 263+ 659B CD 7F 69     	CALL CHKCHAR
 264+ 659E 2C           	DB ','
 265+ 659F              	; get number of items in a list
 266+ 659F DD 21 1C 52  	LD IX, GETBYT
 267+ 65A3 CD 59 01     	CALL CALBAS
 268+ 65A6 32 78 66     	LD (BLIT_STRUCT+8),A
 269+ 65A9              	; comma
 270+ 65A9 CD 7F 69     	CALL CHKCHAR
 271+ 65AC 2C           	DB ','
 272+ 65AD              	; get address of rectangle structure array DIM R%(7,n)
 273+ 65AD 3A 78 66     	LD A,(BLIT_STRUCT+8)
 274+ 65B0 5F               LD E,A
 275+ 65B1 3E 02            LD A,2
 276+ 65B3 47           	LD B,A
 277+ 65B4 16 07        	LD D,7
 278+ 65B6 CD AC 69     	CALL GET_BASIC_ARRAY_DATA_POINTER
 279+ 65B9 ED 43 79 66  	LD (BLIT_STRUCT+9),BC
 280+ 65BD              	; ending )
 281+ 65BD CD 7F 69     	CALL CHKCHAR
 282+ 65C0 29           	DB ')'
 283+ 65C1
 284+ 65C1 E5               PUSH HL
 285+ 65C2 CD FE 64         CALL FIND_OVERLAP
 286+ 65C5 2A 7B 66         LD HL,(BLIT_STRUCT+11)
 287+ 65C8 38 06            JR C,.NOTFOUND
 288+ 65CA 77               LD (HL),A
 289+ 65CB 23               INC HL
 290+ 65CC 36 00            LD (HL),0
 291+ 65CE E1               POP HL
 292+ 65CF C9               RET
 293+ 65D0              .NOTFOUND:
 294+ 65D0 36 FF            LD (HL),#FF
 295+ 65D2 23               INC HL
 296+ 65D3 36 FF            LD (HL),#FF
 297+ 65D5 E1               POP HL
 298+ 65D6 C9               RET
 299+ 65D7              ; ************************************************************************************************
 300+ 65D7               ENDIF
 301+ 65D7
 302+ 65D7               IF (DEFUSR_EXTENSION == 1)
 303+ 65D7              ; *******************************************************************************************************
 304+ 65D7              ; same as COLL but for DEFUSR approach
 305+ 65D7              ; input IX=pointer to input array, real data from +2
 306+ 65D7              ; +02 = pointer to result variable
 307+ 65D7              ; +04 = player X
 308+ 65D7              ; +06 = player Y
 309+ 65D7              ; +08 = player width
 310+ 65D7              ; +10 = player height
 311+ 65D7              ; +12 = number of list items
 312+ 65D7              ; +14 = pointer to list of collidable objects
 313+ 65D7              COLL_DEFUSR:
 314+ 65D7 DD E5            PUSH IX
 315+ 65D9 E1               POP HL
 316+ 65DA 23          > INC HL ; skip over to player x
 316+ 65DB 23          > INC HL
 316+ 65DC 23          > INC HL
 316+ 65DD 23          > INC HL
 317+ 65DE 11 70 66         LD DE,BLIT_STRUCT
 318+ 65E1 01 09 00         LD BC,9
 319+ 65E4 ED B0            LDIR ; copy over x,y,w,h,list item number
 320+ 65E6 DD 7E 0E         LD A,(IX+14)
 321+ 65E9 32 79 66         LD (BLIT_STRUCT+9),A
 322+ 65EC DD 7E 0F         LD A,(IX+15)
 323+ 65EF 32 7A 66         LD (BLIT_STRUCT+10),A ; address to collidable objects array
 324+ 65F2 DD 7E 02         LD A,(IX+2)
 325+ 65F5 32 7B 66         LD (BLIT_STRUCT+11),A
 326+ 65F8 DD 7E 03         LD A,(IX+3)
 327+ 65FB 32 7C 66         LD (BLIT_STRUCT+12),A ; address to results variable
 328+ 65FE DD E5            PUSH IX
 329+ 6600 CD FE 64         CALL FIND_OVERLAP
 330+ 6603 DD E1            POP IX
 331+ 6605 DD 6E 02         LD L,(IX+2)
 332+ 6608 DD 66 03         LD H,(IX+3)
 333+ 660B 38 05            JR C,.NOTFOUND
 334+ 660D 77               LD (HL),A
 335+ 660E 23               INC HL
 336+ 660F 36 00            LD (HL),0
 337+ 6611 C9               RET
 338+ 6612              .NOTFOUND:
 339+ 6612 36 FF            LD (HL),#FF
 340+ 6614 23               INC HL
 341+ 6615 36 FF            LD (HL),#FF
 342+ 6617 C9               RET
 343+ 6618              ; *******************************************************************************************************
 344+ 6618               ENDIF
 345+ 6618
# file closed: asm\COLLISION.asm
 167  6618               ENDIF
 168  6618
 169  6618               IF (DEFUSR_EXTENSION == 1)
 170  6618               INCLUDE "DEFUSR.asm"
# file opened: asm\DEFUSR.asm
   1+ 6618              ; entry function that handles call using CALLF
   2+ 6618              ; pointer to data structure is expected at DAC+2
   3+ 6618              ; first entry must be function id followed by function specific parameters
   4+ 6618
   5+ 6618              DEFUSR_TABLE_ENTRIES    EQU 29
   6+ 6618
   7+ 6618              DEFUSR_JUMP_TABLE:
   8+ 6618               IF (SPRITE_CMDS == 1)
   9+ 6618 B5 4E         DW SPRENABLE_DEFUSR        ; 0
  10+ 661A               ELSE
  11+ 661A ~             DW NOACTION_DEFUSR
  12+ 661A               ENDIF
  13+ 661A
  14+ 661A               IF (SPRITE_CMDS == 1)
  15+ 661A D5 4E         DW SPRDISABLE_DEFUSR        ; 1
  16+ 661C               ELSE
  17+ 661C ~             DW NOACTION_DEFUSR
  18+ 661C               ENDIF
  19+ 661C
  20+ 661C               IF (RAM_CMDS == 1)
  21+ 661C EF 5A         DW MEMCPY_DEFUSR           ; 2
  22+ 661E               ELSE
  23+ 661E ~             DW NOACTION_DEFUSR
  24+ 661E               ENDIF
  25+ 661E
  26+ 661E               IF (VRAM_CMDS == 1)        ; 3
  27+ 661E 0B 5D         DW MEMVRM_DEFUSR
  28+ 6620               ELSE
  29+ 6620 ~             DW NOACTION_DEFUSR
  30+ 6620               ENDIF
  31+ 6620
  32+ 6620               IF (BLIT_CMDS == 1)        ; 4
  33+ 6620 BC 60         DW BLIT_DEFUSR
  34+ 6622               ELSE
  35+ 6622 ~             DW NOACTION_DEFUSR
  36+ 6622               ENDIF
  37+ 6622
  38+ 6622               IF (ANIM_CMDS == 1)        ; 5
  39+ 6622 82 59         DW SGAM_DEFUSR
  40+ 6624               ELSE
  41+ 6624 ~             DW NOACTION_DEFUSR
  42+ 6624               ENDIF
  43+ 6624
  44+ 6624               IF (SPRITE_CMDS == 1)
  45+ 6624 7A 4F         DW SPRGRPMOV_DEFUSR        ; 6
  46+ 6626               ELSE
  47+ 6626 ~             DW NOACTION_DEFUSR
  48+ 6626               ENDIF
  49+ 6626
  50+ 6626               IF (COLL_CMD == 1)
  51+ 6626 D7 65         DW COLL_DEFUSR             ; 7
  52+ 6628               ELSE
  53+ 6628 ~             DW NOACTION_DEFUSR
  54+ 6628               ENDIF
  55+ 6628
  56+ 6628               IF (SOUND_CMDS == 1)
  57+ 6628 42 5C         DW SNDSFX_DEFUSR             ; 8
  58+ 662A               ELSE
  59+ 662A ~             DW NOACTION_DEFUSR
  60+ 662A               ENDIF
  61+ 662A
  62+ 662A               IF (ANIM_CMDS == 1)
  63+ 662A 6F 57         DW ANIMSTEP_SINGLE_DEFUSR      ; 9
  64+ 662C 7F 57         DW ANIMSTEP_MULTI_DEFUSR       ; 10
  65+ 662E 90 57         DW ANIMSTART_SINGLE_DEFUSR     ; 11
  66+ 6630 A2 57         DW ANIMSTART_MULTI_DEFUSR      ; 12
  67+ 6632 A7 57         DW ANIMSTOP_SINGLE_DEFUSR      ; 13
  68+ 6634 B1 57         DW ANIMSTOP_MULTI_DEFUSR       ; 14
  69+ 6636               ELSE
  70+ 6636 ~             DW NOACTION_DEFUSR
  71+ 6636 ~             DW NOACTION_DEFUSR
  72+ 6636 ~             DW NOACTION_DEFUSR
  73+ 6636 ~             DW NOACTION_DEFUSR
  74+ 6636 ~             DW NOACTION_DEFUSR
  75+ 6636 ~             DW NOACTION_DEFUSR
  76+ 6636               ENDIF
  77+ 6636
  78+ 6636               IF (BOX_CMDS == 1)
  79+ 6636 5A 5E         DW BOXMEMCPY_DEFUSR            ; 15
  80+ 6638 FD 5E         DW BOXMEMVRM_DEFUSR            ; 16
  81+ 663A               ELSE
  82+ 663A ~             DW NOACTION_DEFUSR
  83+ 663A ~             DW NOACTION_DEFUSR
  84+ 663A               ENDIF
  85+ 663A
  86+ 663A               IF (ANIM_CMDS == 1)
  87+ 663A DA 4F         DW MAXANIMITEMS_DEFUSR         ; 17
  88+ 663C B9 51         DW MAXANIMDEFS_DEFUSR          ; 18
  89+ 663E 7A 52         DW MAXANIMSPRS_DEFUSR          ; 19
  90+ 6640 3C 54         DW MAXAUTOSGAMS_DEFUSR         ; 20
  91+ 6642 16 51         DW ANIMITEMPAT_DEFUSR          ; 21
  92+ 6644 94 51         DW ANIMITEMPTR_DEFUSR          ; 22
  93+ 6646 54 52         DW ANIMDEF_DEFUSR              ; 23
  94+ 6648 50 53         DW ANIMSPRITE_DEFUSR           ; 24
  95+ 664A 01 54         DW ANIMCHAR_DEFUSR             ; 25
  96+ 664C D2 55         DW AUTOSGAMDEF_DEFUSR          ; 26
  97+ 664E A0 56         DW AUTOSGAMSTART_DEFUSR        ; 27
  98+ 6650 C7 56         DW AUTOSGAMSTOP_DEFUSR         ; 28
  99+ 6652               ELSE
 100+ 6652 ~             DW NOACTION_DEFUSR
 101+ 6652 ~             DW NOACTION_DEFUSR
 102+ 6652 ~             DW NOACTION_DEFUSR
 103+ 6652 ~             DW NOACTION_DEFUSR
 104+ 6652 ~             DW NOACTION_DEFUSR
 105+ 6652 ~             DW NOACTION_DEFUSR
 106+ 6652 ~             DW NOACTION_DEFUSR
 107+ 6652 ~             DW NOACTION_DEFUSR
 108+ 6652 ~             DW NOACTION_DEFUSR
 109+ 6652 ~             DW NOACTION_DEFUSR
 110+ 6652 ~             DW NOACTION_DEFUSR
 111+ 6652 ~             DW NOACTION_DEFUSR
 112+ 6652               ENDIF
 113+ 6652
 114+ 6652              DEFUSR_ENTRY:
 115+ 6652 FB               EI
 116+ 6653 DD 2A F8 F7      LD IX,(DAC+2)
 117+ 6657 DD 7E 00         LD A,(IX)
 118+ 665A FE 1D            CP DEFUSR_TABLE_ENTRIES
 119+ 665C D0               RET NC ; return if an undefined function requested
 120+ 665D 26 00            LD H,0
 121+ 665F 6F               LD L,A
 122+ 6660 29               ADD HL,HL
 123+ 6661 11 18 66         LD DE,DEFUSR_JUMP_TABLE
 124+ 6664 19               ADD HL,DE
 125+ 6665 EB               EX DE,HL
 126+ 6666 1A               LD A,(DE)
 127+ 6667 6F               LD L,A
 128+ 6668 13               INC DE
 129+ 6669 1A               LD A,(DE)
 130+ 666A 67               LD H,A
 131+ 666B E9               JP (HL) ; call function with IX=pointer to data array
 132+ 666C
# file closed: asm\DEFUSR.asm
 171  666C               ENDIF
 172  666C
 173  666C              ; temp variables for BLIT, TILE functions
 174  666C               IF (BLIT_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS + COLL_CMD > 0)
 175  666C              BLIT_TMP:
 176  666C              TILETMP1:
 177  666C              BLIT_TMP1:
 178  666C 00 00         DW 0
 179  666E              TILETMP2:
 180  666E              BLIT_TMP2:
 181  666E 00 00         DW 0
 182  6670                IFDEF CMDS_WITH_PARAMETERS
 183  6670              BLIT_STRUCT:
 184  6670 00 00 00...   DS 17
 185  6674                ENDIF
 186  6674               ENDIF
 187  6681
 188  6681               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 189  6681              VRAM_UPDATE_IN_PROGRESS:
 190  6681 00            DB 0
 191  6682               ENDIF
 192  6682
 193  6682              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 194  6682              ; per starting letter, if no commands with this letter, NULL value
 195  6682              CMDS:
 196  6682 C0 67        	DW CMDS_A ; always present due to ARTINFO
 197  6684               IF (BLIT_CMDS + BOX_CMDS > 0) && (BASIC_EXTENSION == 1)
 198  6684 83 67            DW CMDS_B ; B
 199  6686               ELSE
 200  6686 ~            	DW 0
 201  6686               ENDIF
 202  6686               IF (COLL_CMD == 1) && (BASIC_EXTENSION == 1)
 203  6686 B8 67        	DW CMDS_C ;
 204  6688               ELSE
 205  6688 ~                DW 0 ; C
 206  6688               ENDIF
 207  6688 00 00            DW 0 ; D
 208  668A 00 00            DW 0 ; E
 209  668C               IF (VRAM_CMDS + RAM_CMDS > 0) && (BASIC_EXTENSION == 1)
 210  668C 03 67            DW CMDS_F; F
 211  668E               ELSE
 212  668E ~            	DW 0
 213  668E               ENDIF
 214  668E               IF (GENCAL_CMD > 0) && (BASIC_EXTENSION == 1)
 215  668E 16 67            DW CMDS_G; G
 216  6690               ELSE
 217  6690 ~            	DW 0
 218  6690               ENDIF
 219  6690 00 00            DW 0 ; H
 220  6692 00 00            DW 0 ; I
 221  6694 00 00            DW 0 ; J
 222  6696 00 00            DW 0 ; K
 223  6698 00 00            DW 0 ; L
 224  669A               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0) && (BASIC_EXTENSION == 1)
 225  669A B6 66            DW CMDS_M ; M
 226  669C               ELSE
 227  669C ~            	DW 0
 228  669C               ENDIF
 229  669C 00 00            DW 0 ; N
 230  669E 00 00            DW 0 ; O
 231  66A0 00 00            DW 0 ; P
 232  66A2 00 00            DW 0 ; Q
 233  66A4 00 00            DW 0 ; R
 234  66A6               IF (SOUND_CMDS + SPRITE_CMDS > 0) && (BASIC_EXTENSION == 1)
 235  66A6 2A 67            DW CMDS_S ; S
 236  66A8               ELSE
 237  66A8 ~            	DW 0
 238  66A8               ENDIF
 239  66A8               IF (TILE_CMDS > 0) && (BASIC_EXTENSION == 1)
 240  66A8 A3 67            DW CMDS_T ; T
 241  66AA               ELSE
 242  66AA ~            	DW 0
 243  66AA               ENDIF
 244  66AA 00 00            DW 0 ; U
 245  66AC               IF (VRAM_CMDS > 0) && (BASIC_EXTENSION == 1)
 246  66AC 20 67            DW CMDS_V ; V
 247  66AE               ELSE
 248  66AE ~            	DW 0
 249  66AE               ENDIF
 250  66AE 00 00            DW 0 ; W
 251  66B0 00 00            DW 0 ; X
 252  66B2 00 00            DW 0 ; Y
 253  66B4 00 00            DW 0 ; Z
 254  66B6
 255  66B6               IF (BASIC_EXTENSION == 1)
 256  66B6              CMDS_M:
 257  66B6               IF (VRAM_CMDS == 1)
 258  66B6 4D 45 4D 56      DB "MEMVRM", 0
 258  66BA 52 4D 00
 259  66BD B5 5C            DW MEMVRM
 260  66BF               ENDIF
 261  66BF               IF (RAM_CMDS == 1)
 262  66BF 4D 45 4D 43  	DB "MEMCPY", 0
 262  66C3 50 59 00
 263  66C6 AB 5A        	DW MEMCPY
 264  66C8               ENDIF
 265  66C8               IF (ANIM_CMDS == 1)
 266  66C8 4D 41 58 41  	DB "MAXANIMITEMS",0
 266  66CC 4E 49 4D 49
 266  66D0 54 45 4D 53
 266  66D4 00
 267  66D5 DF 4F        	DW MAXANIMITEMS
 268  66D7 4D 41 58 41  	DB "MAXANIMDEFS",0
 268  66DB 4E 49 4D 44
 268  66DF 45 46 53 00
 269  66E3 BE 51        	DW MAXANIMDEFS
 270  66E5 4D 41 58 41  	DB "MAXANIMSPRS",0
 270  66E9 4E 49 4D 53
 270  66ED 50 52 53 00
 271  66F1 7F 52        	DW MAXANIMSPRS
 272  66F3 4D 41 58 41     DB "MAXAUTOSGAMS",0
 272  66F7 55 54 4F 53
 272  66FB 47 41 4D 53
 272  66FF 00
 273  6700 41 54           DW MAXAUTOSGAMS
 274  6702               ENDIF
 275  6702               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 276  6702 00           	DB 0
 277  6703               ENDIF
 278  6703              CMDS_F:
 279  6703               IF (VRAM_CMDS == 1)
 280  6703 46 49 4C 56      DB "FILVRM", 0
 280  6707 52 4D 00
 281  670A 66 5C            DW FILVRM
 282  670C               ENDIF
 283  670C               IF (RAM_CMDS == 1)
 284  670C 46 49 4C 52      DB "FILRAM", 0
 284  6710 41 4D 00
 285  6713 11 5B            DW FILRAM
 286  6715               ENDIF
 287  6715               IF (VRAM_CMDS + RAM_CMDS > 0)
 288  6715 00               DB 0
 289  6716               ENDIF
 290  6716              CMDS_G:
 291  6716               IF (GENCAL_CMD == 1)
 292  6716 47 45 4E 43      DB "GENCAL", 0
 292  671A 41 4C 00
 293  671D C1 5D            DW GENCAL
 294  671F               ENDIF
 295  671F               IF (GENCAL_CMD > 0)
 296  671F 00           	DB	0
 297  6720               ENDIF
 298  6720              CMDS_V:
 299  6720               IF (VRAM_CMDS == 1)
 300  6720 56 52 4D 4D  	DB "VRMMEM", 0
 300  6724 45 4D 00
 301  6727 5F 5D        	DW VRMMEM
 302  6729               ENDIF
 303  6729               IF (VRAM_CMDS > 0)
 304  6729 00           	DB 0
 305  672A               ENDIF
 306  672A              CMDS_S:
 307  672A               IF (SPRITE_CMDS + ANIM_CMDS > 0)
 308  672A 53 47 41 4D      DB "SGAM",0
 308  672E 00
 309  672F DE 58            DW SGAM
 310  6731               ENDIF
 311  6731               IF (SPRITE_CMDS == 1)
 312  6731 53 50 52 47  	DB "SPRGRPMOV", 0
 312  6735 52 50 4D 4F
 312  6739 56 00
 313  673B 18 4F        	DW SPRGRPMOV
 314  673D               ENDIF
 315  673D               IF (SOUND_CMDS == 1)
 316  673D 53 4E 44 53  	DB "SNDSFX", 0
 316  6741 46 58 00
 317  6744 E8 5B        	DW SNDSFX
 318  6746 53 4E 44 50  	DB "SNDPLYON", 0
 318  674A 4C 59 4F 4E
 318  674E 00
 319  674F B2 5B        	DW SNDPLYON
 320  6751 53 4E 44 50  	DB "SNDPLYOFF", 0
 320  6755 4C 59 4F 46
 320  6759 46 00
 321  675B C5 5B        	DW SNDPLYOFF
 322  675D 53 4E 44 50  	DB "SNDPLYINI", 0
 322  6761 4C 59 49 4E
 322  6765 49 00
 323  6767 68 5B        	DW SNDPLYINIT
 324  6769               ENDIF
 325  6769               IF (SPRITE_CMDS == 1)
 326  6769 53 50 52 45  	DB "SPRENABLE", 0
 326  676D 4E 41 42 4C
 326  6771 45 00
 327  6773 6E 4E        	DW SPRENABLE
 328  6775 53 50 52 44  	DB "SPRDISABLE", 0
 328  6779 49 53 41 42
 328  677D 4C 45 00
 329  6780 D5 4E        	DW SPRDISABLE
 330  6782               ENDIF
 331  6782               IF (SOUND_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 332  6782 00           	DB 0
 333  6783               ENDIF
 334  6783              CMDS_B:
 335  6783               IF (BLIT_CMDS == 1)
 336  6783 42 4C 49 54  	DB "BLIT", 0
 336  6787 00
 337  6788 57 61        	DW BLIT
 338  678A               ENDIF
 339  678A               IF (BOX_CMDS == 1)
 340  678A 42 4F 58 4D  	DB "BOXMEMCPY", 0
 340  678E 45 4D 43 50
 340  6792 59 00
 341  6794 50 5E        	DW BOXMEMCPY
 342  6796 42 4F 58 4D  	DB "BOXMEMVRM", 0
 342  679A 45 4D 56 52
 342  679E 4D 00
 343  67A0 F3 5E        	DW BOXMEMVRM
 344  67A2               ENDIF
 345  67A2               IF (BLIT_CMDS + BOX_CMDS > 0)
 346  67A2 00           	DB 0
 347  67A3               ENDIF
 348  67A3              CMDS_T:
 349  67A3               IF (TILE_CMDS == 1)
 350  67A3 54 49 4C 45  	DB "TILERAM", 0
 350  67A7 52 41 4D 00
 351  67AB 7F 62        	DW TILERAM
 352  67AD 54 49 4C 45  	DB "TILEVRM", 0
 352  67B1 56 52 4D 00
 353  67B5 83 63        	DW TILEVRM
 354  67B7               ENDIF
 355  67B7               IF (TILE_CMDS > 0)
 356  67B7 00           	DB 0
 357  67B8               ENDIF
 358  67B8              CMDS_C:
 359  67B8               IF (COLL_CMD == 1)
 360  67B8 43 4F 4C 4C      DB "COLL", 0
 360  67BC 00
 361  67BD 50 65            DW COLL
 362  67BF               ENDIF
 363  67BF               IF (COLL_CMD > 0)
 364  67BF 00           	DB	0
 365  67C0               ENDIF
 366  67C0              CMDS_A:
 367  67C0               IF (ANIM_CMDS == 1)
 368  67C0 41 4E 49 4D     DB "ANIMSTEP",0
 368  67C4 53 54 45 50
 368  67C8 00
 369  67C9 CA 56           DW ANIMSTEP
 370  67CB 41 4E 49 4D  	DB "ANIMSTART",0
 370  67CF 53 54 41 52
 370  67D3 54 00
 371  67D5 CF 56        	DW ANIMSTART
 372  67D7 41 4E 49 4D  	DB "ANIMSTOP",0
 372  67DB 53 54 4F 50
 372  67DF 00
 373  67E0 D4 56        	DW ANIMSTOP
 374  67E2 41 4E 49 4D  	DB "ANIMITEMPAT",0
 374  67E6 49 54 45 4D
 374  67EA 50 41 54 00
 375  67EE B0 50        	DW ANIMITEMPAT
 376  67F0 41 4E 49 4D  	DB "ANIMITEMPTR",0
 376  67F4 49 54 45 4D
 376  67F8 50 54 52 00
 377  67FC 3B 51        	DW ANIMITEMPTR_CMD
 378  67FE 41 4E 49 4D  	DB "ANIMDEF",0
 378  6802 44 45 46 00
 379  6806 01 52        	DW ANIMDEF
 380  6808 41 4E 49 4D  	DB "ANIMSPRITE",0
 380  680C 53 50 52 49
 380  6810 54 45 00
 381  6813 D8 52        	DW ANIMSPRITE
 382  6815 41 4E 49 4D     DB "ANIMCHAR",0
 382  6819 43 48 41 52
 382  681D 00
 383  681E 88 53           DW ANIMCHAR
 384  6820 41 55 54 4F     DB "AUTOSGAMDEF",0
 384  6824 53 47 41 4D
 384  6828 44 45 46 00
 385  682C 9E 54           DW AUTOSGAMDEF
 386  682E 41 55 54 4F     DB "AUTOSGAMSTART",0
 386  6832 53 47 41 4D
 386  6836 53 54 41 52
 386  683A 54 00
 387  683C 61 56           DW AUTOSGAMSTART
 388  683E 41 55 54 4F     DB "AUTOSGAMSTOP",0
 388  6842 53 47 41 4D
 388  6846 53 54 4F 50
 388  684A 00
 389  684B 9D 56           DW AUTOSGAMSTOP
 390  684D               ENDIF
 391  684D 41 52 54 49     DB "ARTINFO",0
 391  6851 4E 46 4F 00
 392  6855 E1 69           DW ARTINFO
 393  6857 00           	DB 0
 394  6858               ELSE
 395  6858 ~            CMDS_A:
 396  6858 ~             DB "ARTINFO",0
 397  6858 ~             DW ARTINFO
 398  6858 ~             DB 0
 399  6858               ENDIF
 400  6858
 401  6858
 402  6858               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 403  6858              ; ****************************************************************************************************
 404  6858              ; function sets VRAM address
 405  6858              ; input HL=address
 406  6858              ; modifies AF
 407  6858              SETWRT_LOCAL:
 408  6858 7D           	LD	A, L
 409  6859 D3 99        	OUT	(099H), A
 410  685B 7C           	LD	A, H
 411  685C E6 3F        	AND	03FH
 412  685E F6 40        	OR	040H
 413  6860 D3 99        	OUT	(099H), A
 414  6862 C9           	RET
 415  6863              ; ****************************************************************************************************
 416  6863               ENDIF
 417  6863
 418  6863               IF (VRAM_CMDS + TILE_CMDS > 0)
 419  6863              ; ****************************************************************************************************
 420  6863              ; function copies data from RAM to VRAM
 421  6863              ; input HL=address in RAM
 422  6863              ; input B=count
 423  6863              ; modifies AF, BC, HL
 424  6863              BBYTECOPY:
 425  6863 0E 98        	LD C,#98
 426  6865              BBYTECOPY_NO_C:
 427  6865 ED A3        	OUTI
 428  6867 C2 65 68     	JP	NZ, BBYTECOPY_NO_C
 429  686A C9           	RET
 430  686B              ; ****************************************************************************************************
 431  686B               ENDIF
 432  686B
 433  686B              ; ****************************************************************************************************
 434  686B              ; function multiplies HL by 32
 435  686B              HLx32:
 436  686B 29           	ADD HL,HL
 437  686C              ; ****************************************************************************************************
 438  686C              ; function multiplies HL by 16
 439  686C              HLx16:
 440  686C 29           	ADD HL,HL
 441  686D              ; ****************************************************************************************************
 442  686D              ; function multiplies HL by 8
 443  686D              HLx8:
 444  686D 29          > ADD HL, HL
 444  686E 29          > ADD HL, HL
 444  686F 29          > ADD HL, HL
 445  6870 C9           	RET
 446  6871              ; ****************************************************************************************************
 447  6871
 448  6871              ; ****************************************************************************************************
 449  6871              ; function gets slot and subslot data for specific page
 450  6871              ; input A=page (0, 1 or 2)
 451  6871              ; output B = 0A8H register value
 452  6871              ; output D = 0 is no subslots, 1 if yes
 453  6871              ; output C = 0A8H value when page 3 slot equals to requested page slot
 454  6871              ; output E = subslot value if present
 455  6871              ; modifies AF, BC, DE, HL
 456  6871              GET_PAGE_INFO:
 457  6871 6F               LD L, A
 458  6872 C6 C1            ADD A, low (EXPTBL)
 459  6874 32 7E 68         LD (GET_PAGE_INFO_L1+1), A
 460  6877 DB A8            IN A, (0A8H)
 461  6879 47               LD B, A
 462  687A E6 3F            AND 03FH
 463  687C 4F               LD C, A
 464  687D              GET_PAGE_INFO_L1:
 465  687D 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 466  6880 E6 80            AND 080H
 467  6882 28 1B            JR Z, GET_PAGE_INFO_L2
 468  6884                  ; expanded
 469  6884 2D               DEC L
 470  6885 FA A4 68         JP M, GET_PAGE_INFO_L3
 471  6888 2D               DEC L
 472  6889 FA A2 68         JP M, GET_PAGE_INFO_L4
 473  688C                  ; page 2
 474  688C 07               RLCA
 475  688D 07               RLCA
 476  688E              GET_PAGE_INFO_L5:
 477  688E E6 C0            AND 0C0H
 478  6890 B1               OR C
 479  6891 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 480  6893 4F               LD C, A
 481  6894 3A FF FF         LD A, (0FFFFH)
 482  6897 2F               CPL
 483  6898 5F               LD E, A
 484  6899 16 01            LD D, 1
 485  689B 78               LD A, B ; return stack
 486  689C D3 A8            OUT (0A8H), A
 487  689E C9               RET
 488  689F              GET_PAGE_INFO_L2:
 489  689F                  ; not expanded
 490  689F 16 00            LD D, 0
 491  68A1 C9               RET
 492  68A2              GET_PAGE_INFO_L4:
 493  68A2                  ; page 1
 494  68A2 0F               RRCA
 495  68A3 0F               RRCA
 496  68A4              GET_PAGE_INFO_L3:
 497  68A4                  ; page 0
 498  68A4 0F               RRCA
 499  68A5 0F               RRCA
 500  68A6 18 E6            JR GET_PAGE_INFO_L5
 501  68A8              ; ****************************************************************************************************
 502  68A8
 503  68A8              ; ****************************************************************************************************
 504  68A8              ; function returns original slot and subslot info
 505  68A8              ; input B = 0A8H register value
 506  68A8              ; input D = 0 is no subslots, 1 if yes
 507  68A8              ; input C = 0A8H value when page 3 slot equals to requested page slot
 508  68A8              ; input E = subslot value if present
 509  68A8              ; modifies AF, disables interrupts
 510  68A8              RESTORE_PAGE_INFO:
 511  68A8 7A              LD A, D
 512  68A9 B7              OR A
 513  68AA 28 08           JR Z, RESTORE_PAGE_INFO_L1
 514  68AC 79              LD A, C
 515  68AD F3           	DI
 516  68AE D3 A8           OUT (0A8H), A
 517  68B0 7B              LD A, E
 518  68B1 32 FF FF        LD (0FFFFH), A
 519  68B4              RESTORE_PAGE_INFO_L1:
 520  68B4 78              LD A, B
 521  68B5 D3 A8           OUT (0A8H), A
 522  68B7              NOACTION_DEFUSR: ; just a safe RET for use when DEFUSR table has an empty entry
 523  68B7 C9              RET
 524  68B8              ; ****************************************************************************************************
 525  68B8
 526  68B8              ; *******************************************************************************************************
 527  68B8              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 528  68B8              ; INPUT:  A = SLOT ID: EXXXSSPP
 529  68B8              ; E = EXPANDED FLAG
 530  68B8              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 531  68B8              ; PP = PRIMARY SLOT NUMBER
 532  68B8              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 533  68B8              ; CHANGES: AF, BC, DE
 534  68B8
 535  68B8              LOCAL_ENASLT:
 536  68B8 CD D8 68         CALL L0353
 537  68BB FA C5 68         JP M, L0340
 538  68BE DB A8            IN A, (0A8H)
 539  68C0 A1               AND C
 540  68C1 B0               OR B
 541  68C2 D3 A8            OUT (0A8H), A
 542  68C4 C9               RET
 543  68C5              L0340:
 544  68C5 E5               PUSH HL
 545  68C6 CD FD 68         CALL L0378
 546  68C9 4F               LD C, A
 547  68CA 06 00            LD B, 0
 548  68CC 7D               LD A, L
 549  68CD A4               AND H
 550  68CE B2               OR D
 551  68CF 21 C5 FC         LD HL, 0FCC5H
 552  68D2 09               ADD HL, BC
 553  68D3 77               LD (HL), A
 554  68D4 E1               POP HL
 555  68D5 79               LD A, C
 556  68D6 18 E0            JR LOCAL_ENASLT
 557  68D8              L0353:
 558  68D8 F3               DI
 559  68D9 F5               PUSH AF
 560  68DA 7C               LD A, H
 561  68DB 07               RLCA
 562  68DC 07               RLCA
 563  68DD E6 03            AND 3
 564  68DF 5F               LD E, A
 565  68E0 3E C0            LD A, 0C0H
 566  68E2              L035D:
 567  68E2 07               RLCA
 568  68E3 07               RLCA
 569  68E4 1D               DEC E
 570  68E5 F2 E2 68         JP P, L035D
 571  68E8 5F               LD E, A
 572  68E9 2F               CPL
 573  68EA 4F               LD C, A
 574  68EB F1               POP AF
 575  68EC F5               PUSH AF
 576  68ED E6 03            AND 3
 577  68EF 3C               INC A
 578  68F0 47               LD B, A
 579  68F1 3E AB            LD A, 0ABH
 580  68F3              L036E:
 581  68F3 C6 55            ADD A, 055H
 582  68F5 10 FC            DJNZ L036E
 583  68F7 57               LD D, A
 584  68F8 A3               AND E
 585  68F9 47               LD B, A
 586  68FA F1               POP AF
 587  68FB A7               AND A
 588  68FC C9               RET
 589  68FD              L0378:
 590  68FD F5               PUSH AF
 591  68FE 7A               LD A, D
 592  68FF E6 C0            AND 0C0H
 593  6901 4F               LD C, A
 594  6902 F1               POP AF
 595  6903 F5               PUSH AF
 596  6904 57               LD D, A
 597  6905 DB A8            IN A, (0A8H)
 598  6907 47               LD B, A
 599  6908 E6 3F            AND 03FH
 600  690A B1               OR C
 601  690B D3 A8            OUT (0A8H), A
 602  690D 7A               LD A, D
 603  690E 0F               RRCA
 604  690F 0F               RRCA
 605  6910 E6 03            AND 3
 606  6912 57               LD D, A
 607  6913 3E AB            LD A, 0ABH
 608  6915              L0390:
 609  6915 C6 55            ADD A, 055H
 610  6917 15               DEC D
 611  6918 F2 15 69         JP P, L0390
 612  691B A3               AND E
 613  691C 57               LD D, A
 614  691D 7B               LD A, E
 615  691E 2F               CPL
 616  691F 67               LD H, A
 617  6920 3A FF FF         LD A, (0FFFFH)
 618  6923 2F               CPL
 619  6924 6F               LD L, A
 620  6925 A4               AND H
 621  6926 B2               OR D
 622  6927 32 FF FF         LD (0FFFFH), A
 623  692A 78               LD A, B
 624  692B D3 A8            OUT (0A8H), A
 625  692D F1               POP AF
 626  692E E6 03            AND 3
 627  6930 C9               RET
 628  6931              ; *******************************************************************************************************
 629  6931
 630  6931              ; *******************************************************************************************************
 631  6931              ; some common code to activate page 0 and place values needed to restore original page on stack
 632  6931              ; input IY=return address
 633  6931              ENABLE_PAGE0:
 634  6931 AF              XOR A
 635  6932 CD 71 68        CALL GET_PAGE_INFO
 636  6935 C5              PUSH BC
 637  6936 D5              PUSH DE
 638  6937 3A 41 F3        LD A, (RAMAD0)
 639  693A 26 00           LD H, 0
 640  693C CD B8 68        CALL LOCAL_ENASLT
 641  693F FD E9        	JP (IY)
 642  6941              ; *******************************************************************************************************
 643  6941
 644  6941              ; General BASIC CALL-instruction handler
 645  6941              CALLHAND:
 646  6941 FB              EI
 647  6942 E5           	PUSH HL
 648  6943 21 82 66     	LD	HL, CMDS ; pointer table based on starting letter
 649  6946 3A 89 FD        LD A, (PROCNM)
 650  6949 D6 41           SUB 'A'
 651  694B 87              ADD A, A
 652  694C 16 00           LD D, 0
 653  694E 5F              LD E, A
 654  694F 19              ADD HL, DE
 655  6950 5E              LD E, (HL)
 656  6951 23              INC HL
 657  6952 56              LD D, (HL)
 658  6953 7A              LD A, D
 659  6954 B3              OR E
 660  6955 28 23           JR Z, .CMDNOTRECOGNIZED
 661  6957 EB              EX DE, HL
 662  6958              .CHKCMD:
 663  6958 11 89 FD     	LD	DE, PROCNM
 664  695B              .LOOP:
 665  695B 1A              LD	A,(DE)
 666  695C BE           	CP	(HL)
 667  695D 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 668  695F 13           	INC	DE
 669  6960 23           	INC	HL
 670  6961 A7           	AND	A
 671  6962 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 672  6964 5E           	LD	E,(HL)
 673  6965 23           	INC	HL
 674  6966 56           	LD	D,(HL)
 675  6967 E1           	POP	HL		; routine address
 676  6968 CD 89 69     	CALL	GETPREVCHAR
 677  696B CD 7D 69     	CALL	.CALLDE		; Call routine
 678  696E A7           	AND	A
 679  696F C9           	RET
 680  6970
 681  6970              .TONEXTCMD:
 682  6970 0E FF        	LD	C,0FFH
 683  6972 AF           	XOR	A
 684  6973 ED B1        	CPIR			; Skip to end of instruction name
 685  6975 23           	INC	HL
 686  6976 23           	INC	HL		; Skip address
 687  6977 BE           	CP	(HL)
 688  6978 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 689  697A              .CMDNOTRECOGNIZED:
 690  697A E1           	POP	HL
 691  697B 37              SCF
 692  697C C9           	RET
 693  697D
 694  697D              .CALLDE:
 695  697D D5           	PUSH	DE
 696  697E C9           	RET
 697  697F
 698  697F              ;---------------------------
 699  697F
 700  697F              ;GETSTRPNT:
 701  697F              ; OUT:
 702  697F              ; HL = String Address
 703  697F              ; B  = Lenght
 704  697F              ;        LD      HL,(USR)
 705  697F              ;        LD      B,(HL)
 706  697F              ;        INC     HL
 707  697F              ;        LD      E,(HL)
 708  697F              ;        INC     HL
 709  697F              ;        LD      D,(HL)
 710  697F              ;        EX      DE,HL
 711  697F              ;        RET
 712  697F
 713  697F              ;EVALTXTPARAM:
 714  697F              ;	CALL	CHKCHAR
 715  697F              ;	DEFB	"("             ; Check for (
 716  697F              ;	LD	IX,FRMEVL
 717  697F              ;	CALL	CALBAS		; Evaluate expression
 718  697F              ;       LD      A,(VALTYP)
 719  697F              ;        CP      3               ; Text type?
 720  697F              ;        JP      NZ,TYPE_MISMATCH
 721  697F              ;        PUSH	HL
 722  697F              ;        LD	IX,FRESTR         ; Free the temporary string
 723  697F              ;        CALL	CALBAS
 724  697F              ;        POP	HL
 725  697F              ;	CALL	CHKCHAR
 726  697F              ;	DEFB	")"             ; Check for )
 727  697F              ;        RET
 728  697F
 729  697F
 730  697F              CHKCHAR:
 731  697F CD 89 69     	CALL	GETPREVCHAR	; Get previous basic char
 732  6982 E3           	EX	(SP),HL
 733  6983 BE           	CP	(HL) 	        ; Check if good char
 734  6984 20 1D        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 735  6986 23           	INC	HL
 736  6987 E3           	EX	(SP),HL
 737  6988 23           	INC	HL		; Get next basic char
 738  6989
 739  6989              GETPREVCHAR:
 740  6989 2B           	DEC HL
 741  698A DD 21 66 46  	LD	IX,CHRGTR
 742  698E CD 59 01     	CALL CALBAS
 743  6991 FB              EI
 744  6992 C9              RET
 745  6993
 746  6993
 747  6993              TYPE_MISMATCH:
 748  6993 1E 0D            LD E, 13 ; Type mismatch
 749  6995 18 0E            JR THROW_ERROR
 750  6997              SUBSCRIPT_OUT_OF_RANGE:
 751  6997 1E 09            LD E,9 ; subscript out of range
 752  6999 18 0A        	JR THROW_ERROR
 753  699B              OVERFLOW:
 754  699B 1E 06        	LD E,6
 755  699D 18 06        	JR THROW_ERROR
 756  699F              ILLEGAL_FUNCTION:
 757  699F 1E 05            LD E, 5 ; illegal function call
 758  69A1 18 02            JR THROW_ERROR
 759  69A3              SYNTAX_ERROR:
 760  69A3 1E 02            LD E, 2 ; Syntax error
 761  69A5              THROW_ERROR:
 762  69A5 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 763  69A9 C3 59 01     	JP	CALBAS
 764  69AC
 765  69AC              ;---------------------------
 766  69AC
 767  69AC               IF (BASIC_EXTENSION == 1)
 768  69AC              ; *******************************************************************************************************
 769  69AC              ; helper function to get pointer to BASIC array data
 770  69AC              ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
 771  69AC              ; input B=dimensions (1 or 2)
 772  69AC              ; input D=minimal first dimension
 773  69AC              ; input E=minimal second dimension, if applicable
 774  69AC              ; returns BC=pointer to first data element
 775  69AC              ; throws BASIC error if invalid type
 776  69AC              GET_BASIC_ARRAY_DATA_POINTER:
 777  69AC D5           	PUSH DE
 778  69AD C5           	PUSH BC
 779  69AE F5           	PUSH AF
 780  69AF 3E 01           LD A,1
 781  69B1 32 A5 F6        LD (SUBFLG),A ; search for arrays only
 782  69B4 DD 21 A4 5E  	LD IX, PTRGET
 783  69B8 CD 59 01     	CALL CALBAS
 784  69BB AF              XOR A
 785  69BC 32 A5 F6        LD (SUBFLG),A ; if not reset will cause syntax errors
 786  69BF 3A 63 F6     	LD A,(VALTYP)
 787  69C2 D1           	POP DE ; required type
 788  69C3 BA           	CP D
 789  69C4 C2 93 69     	JP NZ,TYPE_MISMATCH
 790  69C7 0A           	LD A,(BC)
 791  69C8 03           	INC BC
 792  69C9 D1           	POP DE ; required number of dimensions
 793  69CA BA           	CP D
 794  69CB C2 93 69     	JP NZ,TYPE_MISMATCH
 795  69CE D1           	POP DE ; required minimal array dimensions
 796  69CF 3D           	DEC A
 797  69D0 28 07        	JR Z,.ONE_DIMENSION
 798  69D2              	; 2-dimension array
 799  69D2 0A           	LD A,(BC)
 800  69D3 03          > INC BC
 800  69D4 03          > INC BC
 801  69D5 BB           	CP E
 802  69D6 DA 97 69     	JP C,SUBSCRIPT_OUT_OF_RANGE
 803  69D9              .ONE_DIMENSION:
 804  69D9 0A           	LD A,(BC)
 805  69DA 03          > INC BC
 805  69DB 03          > INC BC
 806  69DC BA           	CP D
 807  69DD DA 97 69     	JP C,SUBSCRIPT_OUT_OF_RANGE
 808  69E0 C9           	RET
 809  69E1              ; *******************************************************************************************************
 810  69E1               ENDIF
 811  69E1
 812  69E1              ; *******************************************************************************************************
 813  69E1              ; function to handle CALL ARTINFO basic extension
 814  69E1              ; returns info about the extension
 815  69E1              ; _ARTINFO ( INT variable version,
 816  69E1              ;			    INT variable build_flags,
 817  69E1              ;			    INT variable free_memory_ptr )
 818  69E1              ; this function is always available and can be used to test if the extension is active
 819  69E1              ARTINFO:
 820  69E1              	; opening (
 821  69E1 CD 7F 69     	CALL CHKCHAR
 822  69E4 28           	DB '('
 823  69E5              	; get address of version variable
 824  69E5 DD 21 A4 5E  	LD IX, PTRGET
 825  69E9 CD 59 01     	CALL CALBAS
 826  69EC 3A 12 40     	LD A,(VERSION)
 827  69EF 12              LD (DE),A
 828  69F0 13              INC DE
 829  69F1 3A 13 40        LD A,(VERSION+1)
 830  69F4 12              LD (DE),A
 831  69F5              	; comma
 832  69F5 CD 7F 69     	CALL CHKCHAR
 833  69F8 2C           	DB ','
 834  69F9              	; get address of build flags variable
 835  69F9 DD 21 A4 5E  	LD IX, PTRGET
 836  69FD CD 59 01     	CALL CALBAS
 837  6A00 E5              PUSH HL
 838  6A01 21 FF 0F        LD HL,SOUND_CMDS+2*RAM_CMDS+4*VRAM_CMDS+8*BLIT_CMDS+16*SPRITE_CMDS+32*GENCAL_CMD+64*TILE_CMDS+128*BOX_CMDS+256*ANIM_CMDS+512*COLL_CMD+1024*BASIC_EXTENSION+2048*DEFUSR_EXTENSION
 839  6A04 EB              EX DE,HL
 840  6A05 73              LD (HL),E
 841  6A06 23              INC HL
 842  6A07 72              LD (HL),D
 843  6A08 E1              POP HL
 844  6A09              	; comma
 845  6A09 CD 7F 69     	CALL CHKCHAR
 846  6A0C 2C           	DB ','
 847  6A0D              	; get address of free memory variable
 848  6A0D DD 21 A4 5E  	LD IX, PTRGET
 849  6A11 CD 59 01     	CALL CALBAS
 850  6A14 3A 10 40     	LD A,(FREEMEMPTR)
 851  6A17 12              LD (DE),A
 852  6A18 13              INC DE
 853  6A19 3A 11 40        LD A,(FREEMEMPTR+1)
 854  6A1C 12              LD (DE),A
 855  6A1D              	; ending )
 856  6A1D CD 7F 69     	CALL CHKCHAR
 857  6A20 29           	DB ')'
 858  6A21 C9           	RET
 859  6A22              ; *******************************************************************************************************
 860  6A22
 861  6A22              EXT_END:
 862  6A22
# file closed: asm\main.asm
