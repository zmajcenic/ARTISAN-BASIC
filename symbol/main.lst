# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		   EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000              COLL_CMD       EQU 1
  14  4000
  15  4000              BASIC_EXTENSION   EQU 1
  16  4000              DEFUSR_EXTENSION  EQU 1
  17  4000
  18  4000               DEFINE CMDS_WITH_PARAMETERS
  19  4000
  20  4000              CHPUT   EQU    #A2
  21  4000              CALBAS  EQU		#159
  22  4000              ERRHAND EQU    #406F
  23  4000              FRMEVL  EQU    #4C64
  24  4000              FRESTR  EQU		#67D0
  25  4000              ; FRMQNT = formula quantificator
  26  4000              ; input HL=pointer to current program expression
  27  4000              ; output HL=next address
  28  4000              ; output DE=integer datum
  29  4000              FRMQNT	EQU		#542F
  30  4000              ; GETBYT = get byte parameter
  31  4000              ; input HL=pointer to current program expression
  32  4000              ; output HL=next address
  33  4000              ; output A=E=byte read
  34  4000              GETBYT		EQU	#521C
  35  4000              CHRGTR  	   EQU   #4666
  36  4000              PTRGET		EQU 	#5EA4
  37  4000              SUBFLG		EQU	#F6A5
  38  4000              SYNCHR		EQU	#558C
  39  4000              VALTYP  	   EQU   #F663
  40  4000              DAC         EQU   #F7F6
  41  4000              USR     	   EQU   #F7F8
  42  4000              PROCNM		EQU	#FD89
  43  4000              BIOS_FILVRM EQU   #0056
  44  4000              CLIKSW		EQU	#F3DB
  45  4000
  46  4000              RAMAD0	   EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  47  4000              RAMAD1	   EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  48  4000              RAMAD2	   EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  49  4000              RAMAD3	   EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  50  4000              EXPTBL	   EQU   #FCC1
  51  4000              SCRMOD	   EQU   #FCAF ; current screen mode
  52  4000              REG1SAV     EQU   #F3E0 ; VDP(1)
  53  4000              JIFFY	      EQU   #FC9E
  54  4000              GRPPAT	   EQU   #F3CF ; SCREEN 2 sprite generator table address
  55  4000              GRPCGP		EQU	#F3CB ; SCREEN 2 pattern generator table address
  56  4000              GRPATR      EQU   #F3CD ; SCREEN 2 sprite attribute table address
  57  4000              T32PAT	   EQU   #F3C5 ; SCREEN 1 sprite generator table address
  58  4000              T32CGP      EQU   #F3C1 ; SCREEN 1 pattern ganarator table address
  59  4000              T32ATR      EQU   #F3C3 ; SCREEN 1 sprite attribute table address
  60  4000
  61  4000              ; BASIC error codes
  62  4000              ;01 NEXT without FOR
  63  4000              ;02 Syntax error
  64  4000              ;03 RETURN without GOSUB
  65  4000              ;04 Out of DATA
  66  4000              ;05 Illegal function call
  67  4000              ;06 Overflow
  68  4000              ;07 Out of memory
  69  4000              ;08 Undefined line number
  70  4000              ;09 Subscript out of range
  71  4000              ;10 Redimensioned array
  72  4000              ;11 Division by zero
  73  4000              ;12 Illegal direct
  74  4000              ;13 Type mismatch
  75  4000              ;14 Out of string space
  76  4000              ;15 String too long
  77  4000              ;16 String formula too complex
  78  4000              ;17 Can't CONTINUE
  79  4000              ;18 Undefined user function
  80  4000              ;19 Device I/O error
  81  4000              ;20 Verify error
  82  4000              ;21 No RESUME
  83  4000              ;22 RESUME without error
  84  4000              ;23 Unprintable error
  85  4000              ;24 Missing operand
  86  4000              ;25 Line buffer overflow
  87  4000              ;50 FIELD overflow
  88  4000              ;51 Internal error
  89  4000              ;52 Bad file number
  90  4000              ;53 File not found
  91  4000              ;54 File already open
  92  4000              ;55 Input past end
  93  4000              ;56 Bad file name
  94  4000              ;57 Direct statement in file
  95  4000              ;58 Sequential I/O only
  96  4000              ;59 File not OPEN
  97  4000
  98  4000
  99  4000               ; simulate cartridge with BASIC extension
 100  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
 100  4004 D5 66 00 00
 100  4008 00 00 00 00
 100  400C 00 00 00 00
 101  4010
 102  4010              ; this location #4010 stores last location used by basic extension
 103  4010              ; free memory after that point
 104  4010              FREEMEMPTR:
 105  4010 75 67         DW EXT_END
 106  4012
 107  4012              ; this location #4012 stores extension version in DAA format
 108  4012              ; first byte is major version and second minor
 109  4012              VERSION:
 110  4012 00 81         DB #00, #81
 111  4014
 112  4014              ; this location #4014 contains a jump to entry point for DEFUSR approach
 113  4014              ; if excluded it contains 3xRET so that sound player can be at aspecific spot
 114  4014               IF (DEFUSR_EXTENSION == 1)
 115  4014 C3 F0 63        JP DEFUSR_ENTRY
 116  4017               ELSE
 117  4017 ~               .3 RET
 118  4017               ENDIF
 119  4017
 120  4017              ; binary included AKG player compiled at #4017
 121  4017               IF (SOUND_CMDS == 1)
 122  4017              	INCBIN "bin/AKG.bin"
 123  4CF3              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF3              MAIN_PLAYER_START EQU 04017H
   2+ 4CF3              PLY_AKG_START EQU 04017H
   3+ 4CF3              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 04020H
   4+ 4CF3              PLY_AKG_INITSOUNDEFFECTS EQU 04020H
   5+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04024H
   6+ 4CF3              PLY_AKG_PLAYSOUNDEFFECT EQU 04024H
   7+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04025H
   8+ 4CF3              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04025H
   9+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 0404CH
  10+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 0404CH
  11+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 0405AH
  12+ 4CF3              PLY_AKG_PSES_PLAY EQU 04093H
  13+ 4CF3              PLY_AKG_PSES_READFIRSTBYTE EQU 0409CH
  14+ 4CF3              PLY_AKG_PSES_S_ENDORLOOP EQU 040B4H
  15+ 4CF3              PLY_AKG_PSES_S_LOOP EQU 040BFH
  16+ 4CF3              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C5H
  17+ 4CF3              PLY_AKG_PSES_NOTREACHED EQU 040D8H
  18+ 4CF3              PLY_AKG_PSES_HARDWAREONLY EQU 040DCH
  19+ 4CF3              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E3H
  20+ 4CF3              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F5H
  21+ 4CF3              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FFH
  22+ 4CF3              PLY_AKG_PSES_H_AFTERRETRIG EQU 04109H
  23+ 4CF3              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411DH
  24+ 4CF3              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 04122H
  25+ 4CF3              PLY_AKG_PSES_READHARDWAREPERIOD EQU 0412AH
  26+ 4CF3              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04135H
  27+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 04141H
  28+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04143H
  29+ 4CF3              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04149H
  30+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414DH
  31+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414DH
  32+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414FH
  33+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414FH
  34+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414FH
  35+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 04150H
  36+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 04151H
  37+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04155H
  38+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04155H
  39+ 4CF3              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04155H
  40+ 4CF3              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415DH
  41+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04165H
  42+ 4CF3              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04165H
  43+ 4CF3              PLY_AKG_INIT EQU 04165H
  44+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04165H
  45+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04193H
  46+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A7H
  47+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B9H
  48+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D8H
  49+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E5H
  50+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL EQU 041EBH
  51+ 4CF3              PLY_AKG_INITTABLE0 EQU 041EEH
  52+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EEH
  53+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04208H
  54+ 4CF3              PLY_AKG_INITTABLE0_END EQU 04208H
  55+ 4CF3              PLY_AKG_INITTABLE1 EQU 04208H
  56+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04208H
  57+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 0420CH
  58+ 4CF3              PLY_AKG_INITTABLE1_END EQU 0420CH
  59+ 4CF3              PLY_AKG_INITTABLEORA EQU 0420CH
  60+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 0420CH
  61+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04224H
  62+ 4CF3              PLY_AKG_INITTABLEORA_END EQU 04224H
  63+ 4CF3              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04224H
  64+ 4CF3              PLY_AKG_STOP EQU 04224H
  65+ 4CF3              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04236H
  66+ 4CF3              PLY_AKG_PLAY EQU 04236H
  67+ 4CF3              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423EH
  68+ 4CF3              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04244H
  69+ 4CF3              PLY_AKG_READLINKER EQU 04249H
  70+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04249H
  71+ 4CF3              PLY_AKG_READLINKER_PTLINKER EQU 04249H
  72+ 4CF3              PLY_AKG_READLINKER_NOLOOP EQU 04254H
  73+ 4CF3              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428DH
  74+ 4CF3              PLY_AKG_READLINE EQU 04290H
  75+ 4CF3              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 04290H
  76+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04296H
  77+ 4CF3              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04296H
  78+ 4CF3              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A3H
  79+ 4CF3              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A7H
  80+ 4CF3              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042AAH
  81+ 4CF3              PLY_AKG_SPEEDTRACK_END EQU 042ADH
  82+ 4CF3              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042ADH
  83+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B3H
  84+ 4CF3              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B3H
  85+ 4CF3              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042C0H
  86+ 4CF3              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C4H
  87+ 4CF3              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C7H
  88+ 4CF3              PLY_AKG_EVENTTRACK_END EQU 042CAH
  89+ 4CF3              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042CAH
  90+ 4CF3              PLY_AKG_CHANNEL1_READTRACK EQU 042D6H
  91+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D6H
  92+ 4CF3              PLY_AKG_CHANNEL1_PTTRACK EQU 042D6H
  93+ 4CF3              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042F1H
  94+ 4CF3              PLY_AKG_CHANNEL1_WAIT EQU 042FCH
  95+ 4CF3              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04303H
  96+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04303H
  97+ 4CF3              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04303H
  98+ 4CF3              PLY_AKG_CHANNEL1_NOTE EQU 0430CH
  99+ 4CF3              PLY_AKG_BASENOTEINDEX EQU 0430CH
 100+ 4CF3              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430EH
 101+ 4CF3              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430EH
 102+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431EH
 103+ 4CF3              PLY_AKG_INSTRUMENTSTABLE EQU 0431EH
 104+ 4CF3              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 04330H
 105+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 04340H
 106+ 4CF3              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04368H
 107+ 4CF3              PLY_AKG_CHANNEL1_READCELLEND EQU 0436BH
 108+ 4CF3              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 0436BH
 109+ 4CF3              PLY_AKG_CHANNEL2_READTRACK EQU 04377H
 110+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04377H
 111+ 4CF3              PLY_AKG_CHANNEL2_PTTRACK EQU 04377H
 112+ 4CF3              PLY_AKG_CHANNEL2_SMALLWAIT EQU 04392H
 113+ 4CF3              PLY_AKG_CHANNEL2_WAIT EQU 0439DH
 114+ 4CF3              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A4H
 115+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A4H
 116+ 4CF3              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A4H
 117+ 4CF3              PLY_AKG_CHANNEL2_NOTE EQU 043ADH
 118+ 4CF3              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043B2H
 119+ 4CF3              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043B2H
 120+ 4CF3              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D4H
 121+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E4H
 122+ 4CF3              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 0440CH
 123+ 4CF3              PLY_AKG_CHANNEL2_READCELLEND EQU 0440FH
 124+ 4CF3              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440FH
 125+ 4CF3              PLY_AKG_CHANNEL3_READTRACK EQU 0441BH
 126+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 0441BH
 127+ 4CF3              PLY_AKG_CHANNEL3_PTTRACK EQU 0441BH
 128+ 4CF3              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04436H
 129+ 4CF3              PLY_AKG_CHANNEL3_WAIT EQU 04441H
 130+ 4CF3              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04448H
 131+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04448H
 132+ 4CF3              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04448H
 133+ 4CF3              PLY_AKG_CHANNEL3_NOTE EQU 04451H
 134+ 4CF3              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04456H
 135+ 4CF3              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04456H
 136+ 4CF3              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04478H
 137+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04488H
 138+ 4CF3              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044B0H
 139+ 4CF3              PLY_AKG_CHANNEL3_READCELLEND EQU 044B3H
 140+ 4CF3              PLY_AKG_CURRENTSPEED EQU 044B3H
 141+ 4CF3              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B5H
 142+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B8H
 143+ 4CF3              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B8H
 144+ 4CF3              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044BBH
 145+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BEH
 146+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BEH
 147+ 4CF3              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044CAH
 148+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044D1H
 149+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D4H
 150+ 4CF3              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044DAH
 151+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DDH
 152+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DDH
 153+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044EBH
 154+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044F0H
 155+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044FBH
 156+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FEH
 157+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FEH
 158+ 4CF3              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 04501H
 159+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04504H
 160+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04504H
 161+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450DH
 162+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04517H
 163+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 0451AH
 164+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 0451AH
 165+ 4CF3              PLY_AKG_CHANNEL1_PITCH EQU 0451AH
 166+ 4CF3              PLY_AKG_CHANNEL1_ISPITCH EQU 0451DH
 167+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 04522H
 168+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACK EQU 04522H
 169+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04526H
 170+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04528H
 171+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 0452AH
 172+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 04531H
 173+ 4CF3              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 04532H
 174+ 4CF3              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04535H
 175+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04535H
 176+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 04551H
 177+ 4CF3              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 04551H
 178+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455EH
 179+ 4CF3              PLY_AKG_CHANNEL1_GLIDEOVER EQU 04562H
 180+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 04572H
 181+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 04572H
 182+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04573H
 183+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04574H
 184+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04576H
 185+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04576H
 186+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04576H
 187+ 4CF3              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04577H
 188+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04578H
 189+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 0457AH
 190+ 4CF3              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 0457AH
 191+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 0457AH
 192+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 0457AH
 193+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 0457AH
 194+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457DH
 195+ 4CF3              PLY_AKG_CHANNEL1_PITCH_END EQU 0457FH
 196+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04587H
 197+ 4CF3              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04587H
 198+ 4CF3              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 0458AH
 199+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458DH
 200+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458DH
 201+ 4CF3              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04599H
 202+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 045A0H
 203+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A3H
 204+ 4CF3              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A9H
 205+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045ACH
 206+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045ACH
 207+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045BAH
 208+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BFH
 209+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045CAH
 210+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CDH
 211+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CDH
 212+ 4CF3              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045D0H
 213+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D3H
 214+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D3H
 215+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045DCH
 216+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E6H
 217+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E9H
 218+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E9H
 219+ 4CF3              PLY_AKG_CHANNEL2_PITCH EQU 045E9H
 220+ 4CF3              PLY_AKG_CHANNEL2_ISPITCH EQU 045ECH
 221+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045F1H
 222+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045F1H
 223+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F5H
 224+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F7H
 225+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F9H
 226+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 04600H
 227+ 4CF3              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 04601H
 228+ 4CF3              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04604H
 229+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04604H
 230+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 04620H
 231+ 4CF3              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 04620H
 232+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462DH
 233+ 4CF3              PLY_AKG_CHANNEL2_GLIDEOVER EQU 04631H
 234+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 04641H
 235+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 04641H
 236+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 04642H
 237+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04643H
 238+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04645H
 239+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04645H
 240+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04645H
 241+ 4CF3              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04646H
 242+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04647H
 243+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04649H
 244+ 4CF3              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04649H
 245+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04649H
 246+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04649H
 247+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04649H
 248+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_END EQU 0464CH
 249+ 4CF3              PLY_AKG_CHANNEL2_PITCH_END EQU 0464EH
 250+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04656H
 251+ 4CF3              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04656H
 252+ 4CF3              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04659H
 253+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 0465CH
 254+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 0465CH
 255+ 4CF3              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04668H
 256+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466FH
 257+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 04672H
 258+ 4CF3              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04678H
 259+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 0467BH
 260+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 0467BH
 261+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04689H
 262+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468EH
 263+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04699H
 264+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 0469CH
 265+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 0469CH
 266+ 4CF3              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469FH
 267+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 046A2H
 268+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE EQU 046A2H
 269+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046ABH
 270+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B5H
 271+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B8H
 272+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B8H
 273+ 4CF3              PLY_AKG_CHANNEL3_PITCH EQU 046B8H
 274+ 4CF3              PLY_AKG_CHANNEL3_ISPITCH EQU 046BBH
 275+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046C0H
 276+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046C0H
 277+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C4H
 278+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C6H
 279+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C8H
 280+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CFH
 281+ 4CF3              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046D0H
 282+ 4CF3              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D3H
 283+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D3H
 284+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046EFH
 285+ 4CF3              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046EFH
 286+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046FCH
 287+ 4CF3              PLY_AKG_CHANNEL3_GLIDEOVER EQU 04700H
 288+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 04710H
 289+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 04710H
 290+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 04711H
 291+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 04712H
 292+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04714H
 293+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04714H
 294+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04714H
 295+ 4CF3              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04715H
 296+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04716H
 297+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04718H
 298+ 4CF3              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04718H
 299+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04718H
 300+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04718H
 301+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04718H
 302+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_END EQU 0471BH
 303+ 4CF3              PLY_AKG_CHANNEL3_PITCH_END EQU 0471DH
 304+ 4CF3              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04729H
 305+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04729H
 306+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04729H
 307+ 4CF3              PLY_AKG_CHANNEL1_TRACKNOTE EQU 0472CH
 308+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472EH
 309+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04734H
 310+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04737H
 311+ 4CF3              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04737H
 312+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 0473AH
 313+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04743H
 314+ 4CF3              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 0474BH
 315+ 4CF3              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04758H
 316+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04758H
 317+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04758H
 318+ 4CF3              PLY_AKG_CHANNEL2_TRACKNOTE EQU 0475BH
 319+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475DH
 320+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04763H
 321+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04766H
 322+ 4CF3              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04766H
 323+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04769H
 324+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 04772H
 325+ 4CF3              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 0477AH
 326+ 4CF3              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04788H
 327+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04788H
 328+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04788H
 329+ 4CF3              PLY_AKG_CHANNEL3_TRACKNOTE EQU 0478BH
 330+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478DH
 331+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04793H
 332+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04796H
 333+ 4CF3              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04796H
 334+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04799H
 335+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 047A2H
 336+ 4CF3              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047AAH
 337+ 4CF3              PLY_AKG_SENDPSGREGISTERS EQU 047B9H
 338+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047C1H
 339+ 4CF3              PLY_AKG_PSGREG01_INSTR EQU 047C1H
 340+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047D1H
 341+ 4CF3              PLY_AKG_PSGREG23_INSTR EQU 047D1H
 342+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047E2H
 343+ 4CF3              PLY_AKG_PSGREG45_INSTR EQU 047E2H
 344+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F3H
 345+ 4CF3              PLY_AKG_PSGREG6_8_INSTR EQU 047F3H
 346+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04804H
 347+ 4CF3              PLY_AKG_PSGREG9_10_INSTR EQU 04804H
 348+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04815H
 349+ 4CF3              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04815H
 350+ 4CF3              PLY_AKG_PSGREG13_OLDVALUE EQU 0482AH
 351+ 4CF3              PLY_AKG_RETRIG EQU 0482CH
 352+ 4CF3              PLY_AKG_PSGREG13_INSTR EQU 0482EH
 353+ 4CF3              PLY_AKG_PSGREG13_END EQU 0483DH
 354+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483DH
 355+ 4CF3              PLY_AKG_SAVESP EQU 0483DH
 356+ 4CF3              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 04841H
 357+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTS EQU 04849H
 358+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04856H
 359+ 4CF3              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04856H
 360+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485EH
 361+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 0486BH
 362+ 4CF3              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 0486BH
 363+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTS EQU 04873H
 364+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487EH
 365+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS EQU 0487EH
 366+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488DH
 367+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488DH
 368+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04894H
 369+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A4H
 370+ 4CF3              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A4H
 371+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048ABH
 372+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048ABH
 373+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048AEH
 374+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B7H
 375+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B7H
 376+ 4CF3              PLY_AKG_READINSTRUMENTCELL EQU 048BDH
 377+ 4CF3              PLY_AKG_NOSOFTNOHARD EQU 048CAH
 378+ 4CF3              PLY_AKG_NSNH_NONOISE EQU 048DFH
 379+ 4CF3              PLY_AKG_SOFT EQU 048E2H
 380+ 4CF3              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E9H
 381+ 4CF3              PLY_AKG_S_NOTSIMPLE EQU 048F1H
 382+ 4CF3              PLY_AKG_S_AFTERSIMPLETEST EQU 048F4H
 383+ 4CF3              PLY_AKG_HARDTOSOFT EQU 04901H
 384+ 4CF3              PLY_AKG_HS_JUMPRATIO EQU 0490CH
 385+ 4CF3              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04939H
 386+ 4CF3              PLY_AKG_ENDWITHOUTLOOP EQU 0493BH
 387+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 0493BH
 388+ 4CF3              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 0493BH
 389+ 4CF3              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04943H
 390+ 4CF3              PLY_AKG_SH_JUMPRATIO EQU 04950H
 391+ 4CF3              PLY_AKG_SH_JUMPRATIOEND EQU 04971H
 392+ 4CF3              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 04980H
 393+ 4CF3              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04986H
 394+ 4CF3              PLY_AKG_H_OR_ENDWITHLOOP EQU 049A0H
 395+ 4CF3              PLY_AKG_H_RETRIGEND EQU 049B2H
 396+ 4CF3              PLY_AKG_H_AFTERRETRIG EQU 049B3H
 397+ 4CF3              PLY_AKG_ENDWITHLOOP EQU 049C5H
 398+ 4CF3              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049CCH
 399+ 4CF3              PLY_AKG_S_OR_H_NEXTBYTE EQU 049E2H
 400+ 4CF3              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049F0H
 401+ 4CF3              PLY_AKG_S_OR_H_AFTERPITCH EQU 04A00H
 402+ 4CF3              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0EH
 403+ 4CF3              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1DH
 404+ 4CF3              PLY_AKG_SHOHS_RETRIGEND EQU 04A2CH
 405+ 4CF3              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2DH
 406+ 4CF3              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3FH
 407+ 4CF3              PLY_AKG_EFFECTTABLE EQU 04A4DH
 408+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4DH
 409+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A71H
 410+ 4CF3              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A71H
 411+ 4CF3              PLY_AKG_EFFECT_RESET EQU 04A74H
 412+ 4CF3              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A76H
 413+ 4CF3              PLY_AKG_EFFECT_VOLUME EQU 04A91H
 414+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9DH
 415+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA3H
 416+ 4CF3              PLY_AKG_ARPEGGIOSTABLE EQU 04AA3H
 417+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04ACAH
 418+ 4CF3              PLY_AKG_EFFECT_PITCHTABLE EQU 04AD1H
 419+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD7H
 420+ 4CF3              PLY_AKG_PITCHESTABLE EQU 04AD7H
 421+ 4CF3              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFEH
 422+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B05H
 423+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B16H
 424+ 4CF3              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1DH
 425+ 4CF3              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2DH
 426+ 4CF3              PLY_AKG_EFFECT_PITCHUP EQU 04B42H
 427+ 4CF3              PLY_AKG_EFFECT_PITCHSTOP EQU 04B54H
 428+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B5BH
 429+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B85H
 430+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B85H
 431+ 4CF3              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9EH
 432+ 4CF3              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9EH
 433+ 4CF3              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BB0H
 434+ 4CF3              PLY_AKG_EFFECT_LEGATO EQU 04BC6H
 435+ 4CF3              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BDAH
 436+ 4CF3              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BE2H
 437+ 4CF3              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BEAH
 438+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BF2H
 439+ 4CF3              PLY_AKG_EVENT EQU 04BF2H
 440+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF3H
 441+ 4CF3              PLY_AKG_PERIODTABLE EQU 04BF3H
 442+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF3H
 443+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF3H
 444+ 4CF3              PLY_AKG_PERIODTABLE_END EQU 04CF3H
 445+ 4CF3              PLY_AKG_END EQU 04CF3H
 446+ 4CF3              MAIN_PLAYER_END EQU 04CF3H
 447+ 4CF3              TESTEREND EQU 04CF3H
 448+ 4CF3
# file closed: ./symbol/AKG.sym
 124  4CF3               ENDIF
 125  4CF3
 126  4CF3               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
   1+ 4CF3              ORIG.HTIMI:
   2+ 4CF3 00 00 00 00  	DB 0, 0, 0, 0, 0
   2+ 4CF7 00
   3+ 4CF8               EXPORT ORIG.HTIMI
   4+ 4CF8
   5+ 4CF8              ; *******************************************************************************************************
   6+ 4CF8              ; interrupt handler when page 0 enabled
   7+ 4CF8              ; we are here only if one of the extended basic commands have paged in page 0
   8+ 4CF8              ; which means we arrived from BASIC so page 2 is already good
   9+ 4CF8              VBLANK:
  10+ 4CF8              	EXPORT VBLANK
  11+ 4CF8
  12+ 4CF8 F5               PUSH AF
  13+ 4CF9              	; is VDP originator ?
  14+ 4CF9 DB 99        	IN	A, (099H)
  15+ 4CFB A7           	AND	A
  16+ 4CFC F2 23 4D     	JP P, .EXIT
  17+ 4CFF
  18+ 4CFF               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  19+ 4CFF C5               PUSH BC
  20+ 4D00 D5               PUSH DE
  21+ 4D01 E5               PUSH HL
  22+ 4D02 08               EX AF, AF'
  23+ 4D03 D9               EXX
  24+ 4D04 F5               PUSH AF
  25+ 4D05 C5               PUSH BC
  26+ 4D06 D5               PUSH DE
  27+ 4D07 E5               PUSH HL
  28+ 4D08 DD E5            PUSH IX
  29+ 4D0A FD E5            PUSH IY
  30+ 4D0C
  31+ 4D0C               IF (SPRITE_CMDS == 1)
  32+ 4D0C CD 5D 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  33+ 4D0F               ENDIF
  34+ 4D0F
  35+ 4D0F               IF (SOUND_CMDS == 1)
  36+ 4D0F 3A C1 59     	LD A, (SOUND_ENABLED)
  37+ 4D12 B7           	OR A
  38+ 4D13 C4 36 42     	CALL NZ,PLY_AKG_PLAY
  39+ 4D16               ENDIF
  40+ 4D16
  41+ 4D16                  ; increase JIFFY
  42+ 4D16                  ;LD HL,(JIFFY)
  43+ 4D16                  ;INC HL
  44+ 4D16                  ;LD (JIFFY),HL
  45+ 4D16
  46+ 4D16 FD E1            POP IY
  47+ 4D18 DD E1            POP IX
  48+ 4D1A E1               POP HL
  49+ 4D1B D1               POP DE
  50+ 4D1C C1               POP BC
  51+ 4D1D F1               POP AF
  52+ 4D1E 08               EX AF, AF'
  53+ 4D1F D9               EXX
  54+ 4D20 E1               POP HL
  55+ 4D21 D1               POP DE
  56+ 4D22 C1               POP BC
  57+ 4D23               ENDIF
  58+ 4D23
  59+ 4D23              .EXIT:
  60+ 4D23 F1           	POP AF
  61+ 4D24 FB           	EI
  62+ 4D25 ED 4D        	RETI
  63+ 4D27              ; *******************************************************************************************************
  64+ 4D27
  65+ 4D27              ; *******************************************************************************************************
  66+ 4D27              ; H.TIMI function
  67+ 4D27              ; we can end up here from anywhere so page in both page 0 and 2
  68+ 4D27              MBGE_HTIMI:
  69+ 4D27               EXPORT MBGE_HTIMI
  70+ 4D27
  71+ 4D27               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  72+ 4D27
  73+ 4D27 F5           	PUSH AF
  74+ 4D28
  75+ 4D28              	; enable page 2
  76+ 4D28 3E 02            LD A, 2
  77+ 4D2A CD 05 66         CALL GET_PAGE_INFO
  78+ 4D2D C5               PUSH BC
  79+ 4D2E D5               PUSH DE
  80+ 4D2F 3A 43 F3         LD A, (RAMAD2)
  81+ 4D32 26 80            LD H, 080H
  82+ 4D34 CD 4C 66         CALL LOCAL_ENASLT
  83+ 4D37              	; enable page 0
  84+ 4D37 AF               XOR A
  85+ 4D38 CD 05 66         CALL GET_PAGE_INFO
  86+ 4D3B C5               PUSH BC
  87+ 4D3C D5               PUSH DE
  88+ 4D3D 3A 41 F3         LD A, (RAMAD0)
  89+ 4D40 26 00            LD H, 0
  90+ 4D42 CD 4C 66         CALL LOCAL_ENASLT
  91+ 4D45
  92+ 4D45               IF (SPRITE_CMDS == 1)
  93+ 4D45 CD 5D 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  94+ 4D48               ENDIF
  95+ 4D48
  96+ 4D48               IF (SOUND_CMDS == 1)
  97+ 4D48 3A C1 59     	LD A, (SOUND_ENABLED)
  98+ 4D4B B7           	OR A
  99+ 4D4C C4 36 42     	CALL NZ,PLY_AKG_PLAY
 100+ 4D4F               ENDIF
 101+ 4D4F
 102+ 4D4F              	; restore page 0
 103+ 4D4F D1               POP DE
 104+ 4D50 C1               POP BC
 105+ 4D51 CD 3C 66         CALL RESTORE_PAGE_INFO
 106+ 4D54              	; restore page 2
 107+ 4D54 D1               POP DE
 108+ 4D55 C1               POP BC
 109+ 4D56 CD 3C 66         CALL RESTORE_PAGE_INFO
 110+ 4D59
 111+ 4D59 F1           	POP AF
 112+ 4D5A               ENDIF
 113+ 4D5A C3 F3 4C     	JP ORIG.HTIMI
 114+ 4D5D              ; *******************************************************************************************************
 115+ 4D5D
 116+ 4D5D              ; *******************************************************************************************************
 117+ 4D5D              ; function checks if the sprite system is initialized and what screen mode we are running
 118+ 4D5D              ; also checks if some VRAM modifying command is running
 119+ 4D5D              ; when that checks out calls sprite updates and animation processing
 120+ 4D5D              ; if in an unsupported mode disables sprite handling
 121+ 4D5D              PROCESS_SPRITES_AND_ANIMATIONS:
 122+ 4D5D              	; check if initialized
 123+ 4D5D 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
 124+ 4D60 B7           	OR A
 125+ 4D61 C8           	RET Z
 126+ 4D62              	; check screen mode
 127+ 4D62 3A AF FC     	LD A, (SCRMOD)
 128+ 4D65 3D           	DEC A
 129+ 4D66 28 08        	JR Z, .L0 ; screen 1
 130+ 4D68 3D           	DEC A
 131+ 4D69 28 05            JR Z, .L0 ; screen 2
 132+ 4D6B              	; unsupported screen mode, disable
 133+ 4D6B AF               XOR A
 134+ 4D6C 32 7F 4D         LD (SPRATR_INIT_STATUS),A
 135+ 4D6F C9               RET
 136+ 4D70              .L0:
 137+ 4D70                  ; check if anyone else is working with VRAM
 138+ 4D70 3A 1F 64         LD A,(VRAM_UPDATE_IN_PROGRESS)
 139+ 4D73 B7               OR A
 140+ 4D74 C0               RET NZ
 141+ 4D75
 142+ 4D75 CD 95 4D         CALL SPRATR_UPDATE
 143+ 4D78
 144+ 4D78               IF (ANIM_CMDS == 1)
 145+ 4D78 CD 09 56         CALL PROCESS_ANIMATIONS
 146+ 4D7B CD 0D 58         CALL PROCESS_AUTOSGAMS
 147+ 4D7E               ENDIF
 148+ 4D7E C9               RET
 149+ 4D7F              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
 127  4D7F
 128  4D7F               IF (SPRITE_CMDS == 1)
 129  4D7F               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4D7F              ; commands and variables related to sprites
   2+ 4D7F
   3+ 4D7F              SPRATR_INIT_STATUS:
   4+ 4D7F 00            DB 0
   5+ 4D80              SPRATR_UPDATE_FLAG:
   6+ 4D80 00 00         DW 0
   7+ 4D82              SPRATR_DATA:
   8+ 4D82 00 00         DW 0
   9+ 4D84              SPRFLICKER_ENABLED:
  10+ 4D84 00            DB 0
  11+ 4D85              ; to support sprite flicker
  12+ 4D85              FLICKER:
  13+ 4D85 00            DB 0
  14+ 4D86              NUM_SPRITES_HANDLED:
  15+ 4D86 20            DB 32
  16+ 4D87
  17+ 4D87              ; to temporarily store stack pointer
  18+ 4D87              TMPSP:
  19+ 4D87 00 00         DW 0
  20+ 4D89
  21+ 4D89              ; *******************************************************************************************************
  22+ 4D89              ; helper function gets pointer to n-th entry in sprite attributes
  23+ 4D89              ; changes HL,DE
  24+ 4D89              GETnthSPRATTR:
  25+ 4D89 26 00            LD H,0
  26+ 4D8B 6F               LD L,A
  27+ 4D8C CD 01 66         CALL HLx8
  28+ 4D8F ED 5B 82 4D      LD DE,(SPRATR_DATA)
  29+ 4D93 19               ADD HL,DE
  30+ 4D94 C9               RET
  31+ 4D95              ; *******************************************************************************************************
  32+ 4D95
  33+ 4D95              ; *******************************************************************************************************
  34+ 4D95              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  35+ 4D95              ; struct {
  36+ 4D95              ; DW y
  37+ 4D95              ; DW x
  38+ 4D95              ; DW pattern (0-63)
  39+ 4D95              ; DW color
  40+ 4D95              ; } [32]
  41+ 4D95              ; will hide sprites whose location is outside of visible area
  42+ 4D95              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  43+ 4D95              ; modifies AF, AF', BC, DE, HL, IX
  44+ 4D95              SPRATR_UPDATE:
  45+ 4D95              	; check if update requested
  46+ 4D95 2A 80 4D     	LD HL, (SPRATR_UPDATE_FLAG)
  47+ 4D98 7E           	LD A, (HL)
  48+ 4D99 B7           	OR A
  49+ 4D9A C8           	RET Z
  50+ 4D9B
  51+ 4D9B DD 21 86 4D  	LD IX,NUM_SPRITES_HANDLED
  52+ 4D9F DD 46 00     	LD B, (IX) ; sprite number
  53+ 4DA2 0E 98        	LD C, #98 ; register for vdp data output
  54+ 4DA4              	; set VDP address
  55+ 4DA4 3A AF FC         LD A,(SCRMOD)
  56+ 4DA7 3D               DEC A
  57+ 4DA8 20 05            JR NZ,.L4
  58+ 4DAA 2A C3 F3         LD HL, (T32ATR)
  59+ 4DAD 18 03            JR .L5
  60+ 4DAF              .L4:
  61+ 4DAF 2A CD F3         LD HL, (GRPATR)
  62+ 4DB2              .L5:
  63+ 4DB2 3A 84 4D     	LD A, (SPRFLICKER_ENABLED)
  64+ 4DB5 B7           	OR A
  65+ 4DB6 28 03        	JR Z, .L3
  66+ 4DB8 3A 85 4D     	LD A, (FLICKER)
  67+ 4DBB              .L3:
  68+ 4DBB 5F           	LD E, A
  69+ 4DBC 08           	EX AF, AF'
  70+ 4DBD 7B           	LD A, E
  71+ 4DBE 87           	ADD A, A
  72+ 4DBF 87           	ADD A, A
  73+ 4DC0 16 00        	LD D, 0
  74+ 4DC2 5F           	LD E, A
  75+ 4DC3 19           	ADD HL, DE
  76+ 4DC4 CD EC 65     	CALL SETWRT_LOCAL
  77+ 4DC7 ED 73 87 4D  	LD (TMPSP), SP
  78+ 4DCB ED 7B 82 4D  	LD SP, (SPRATR_DATA)
  79+ 4DCF
  80+ 4DCF              .LOOP:
  81+ 4DCF E1           	POP HL
  82+ 4DD0 24           	INC H
  83+ 4DD1 28 0D        	JR Z, .L1 ; negative number between -256 and -1
  84+ 4DD3 25           	DEC H
  85+ 4DD4 20 15        	JR NZ, .OUT3 ; sprite vertically can't be visible
  86+ 4DD6 7D           	LD A, L
  87+ 4DD7 FE C0        	CP 192
  88+ 4DD9 30 10        	JR NC, .OUT3
  89+ 4DDB 3D           	DEC A ; due to VDP rule that top of screen is -1
  90+ 4DDC 57           	LD D, A
  91+ 4DDD C3 04 4E     	JP .X
  92+ 4DE0              .L1:
  93+ 4DE0 7D           	LD A, L
  94+ 4DE1 C6 10        	ADD 16
  95+ 4DE3 FA EB 4D     	JP M, .OUT3 ; below -16
  96+ 4DE6 2D           	DEC L ; due to VDP rule that top of screen is -1
  97+ 4DE7 55           	LD D, L
  98+ 4DE8 C3 04 4E     	JP .X
  99+ 4DEB              .OUT3:
 100+ 4DEB E1           	POP HL ; skip x value
 101+ 4DEC              .OUT2:
 102+ 4DEC E1           	POP HL ; skip pattern
 103+ 4DED E1           	POP HL ; skip color
 104+ 4DEE 3E D1        	LD A, #D1
 105+ 4DF0 ED 79        	OUT (C), A ; sprite hidden
 106+ 4DF2 00          > NOP
 106+ 4DF3 00          > NOP
 106+ 4DF4 00          > NOP
 107+ 4DF5 ED 79        	OUT (C), A ; value unimportant
 108+ 4DF7 00          > NOP
 108+ 4DF8 00          > NOP
 108+ 4DF9 00          > NOP
 109+ 4DFA ED 79        	OUT (C), A ; value unimportant
 110+ 4DFC 00          > NOP
 110+ 4DFD 00          > NOP
 110+ 4DFE 00          > NOP
 111+ 4DFF ED 79        	OUT (C), A ; value unimportant
 112+ 4E01 C3 2F 4E     	JP .NEXT
 113+ 4E04              .X:
 114+ 4E04 E1           	POP HL
 115+ 4E05 24           	INC H
 116+ 4E06 28 08        	JR Z, .L2
 117+ 4E08 25           	DEC H
 118+ 4E09 20 E1        	JR NZ, .OUT2
 119+ 4E0B 1E 00        	LD E, 0 ; EC bit
 120+ 4E0D C3 19 4E     	JP .XY
 121+ 4E10              .L2:
 122+ 4E10 7D           	LD A, L
 123+ 4E11 C6 20        	ADD 32
 124+ 4E13 FA EC 4D     	JP M, .OUT2
 125+ 4E16 6F           	LD L, A
 126+ 4E17 1E 80        	LD E, #80
 127+ 4E19              .XY:
 128+ 4E19 ED 51        	OUT (C), D
 129+ 4E1B 3A E0 F3     	LD A, (REG1SAV)
 130+ 4E1E E6 02        	AND 2
 131+ 4E20 ED 69        	OUT (C), L
 132+ 4E22 E1           	POP HL ; pattern
 133+ 4E23 7D           	LD A, L
 134+ 4E24 28 02        	JR Z, .SMALLSPRITES
 135+ 4E26 87           	ADD A, A
 136+ 4E27 87           	ADD A, A ; needs to go at 4x
 137+ 4E28              .SMALLSPRITES:
 138+ 4E28 D3 98        	OUT (#98), A
 139+ 4E2A E1           	POP HL ; color
 140+ 4E2B 7D           	LD A, L
 141+ 4E2C B3           	OR E
 142+ 4E2D D3 98        	OUT (#98), A
 143+ 4E2F              .NEXT:
 144+ 4E2F 08           	EX AF, AF'
 145+ 4E30 3C           	INC A ; increase current sprite
 146+ 4E31 DD BE 00     	CP (IX) ; compare to maximum handled
 147+ 4E34 C2 54 4E     	JP NZ, .NEXT2 ; continue if not over
 148+ 4E37 AF           	XOR A ; back to zero
 149+ 4E38 08           	EX AF, AF'
 150+ 4E39 3A AF FC         LD A,(SCRMOD)
 151+ 4E3C 3D               DEC A
 152+ 4E3D 20 05            JR NZ,.L6
 153+ 4E3F 2A C3 F3         LD HL, (T32ATR)
 154+ 4E42 18 03            JR .L7
 155+ 4E44              .L6:
 156+ 4E44 2A CD F3         LD HL, (GRPATR)
 157+ 4E47              .L7:
 158+ 4E47              	; CALL SETWRT_LOCAL not allowed as SP modified
 159+ 4E47 7D           	LD	A, L
 160+ 4E48 D3 99        	OUT	(099H), A
 161+ 4E4A 7C           	LD	A, H
 162+ 4E4B E6 3F        	AND	03FH
 163+ 4E4D F6 40        	OR	040H
 164+ 4E4F D3 99        	OUT	(099H), A
 165+ 4E51 C3 55 4E     	JP .NEXT3
 166+ 4E54              .NEXT2:
 167+ 4E54 08           	EX AF, AF'
 168+ 4E55              .NEXT3:
 169+ 4E55 05           	DEC B
 170+ 4E56 C2 CF 4D     	JP NZ, .LOOP
 171+ 4E59 08           	EX AF, AF'
 172+ 4E5A 3C           	INC A ; increase flicker to start at the next one on next vblank
 173+ 4E5B DD BE 00     	CP (IX)
 174+ 4E5E 20 01        	JR NZ,.L8
 175+ 4E60 AF           	XOR A
 176+ 4E61              .L8:
 177+ 4E61 32 85 4D     	LD (FLICKER), A
 178+ 4E64
 179+ 4E64 ED 7B 87 4D  	LD SP, (TMPSP)
 180+ 4E68 2A 80 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 181+ 4E6B 36 00        	LD (HL), 0 ; zero out update flag
 182+ 4E6D C9           	RET
 183+ 4E6E              ; *******************************************************************************************************
 184+ 4E6E
 185+ 4E6E               IF (BASIC_EXTENSION == 1)
 186+ 4E6E              ; *******************************************************************************************************
 187+ 4E6E              ; function to handle CALL SPRENABLE basic extension
 188+ 4E6E              ; initializes sprites handler
 189+ 4E6E              ; _SPRENABLE ( INT[3][31] variable sprites_attributes,
 190+ 4E6E              ;			   INT variable update_variable,
 191+ 4E6E              ;			   BYTE sprite_flicker_enabled,
 192+ 4E6E              ;			   BYTE num_sprites_handled )
 193+ 4E6E              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA, SPRFLICKER_ENABLED and NUM_SPRITES_HANDLED
 194+ 4E6E              SPRENABLE:
 195+ 4E6E              	; opening (
 196+ 4E6E CD 13 67     	CALL CHKCHAR
 197+ 4E71 28           	DB '('
 198+ 4E72              	; get address of sprite attribute table DIM SA%(3,31)
 199+ 4E72 3E 02        	LD A,2
 200+ 4E74 06 02        	LD B,2
 201+ 4E76 11 20 04     	LD DE,#0420
 202+ 4E79 CD 40 67     	CALL GET_BASIC_ARRAY_DATA_POINTER
 203+ 4E7C ED 43 82 4D  	LD (SPRATR_DATA), BC
 204+ 4E80              	; comma
 205+ 4E80 CD 13 67     	CALL CHKCHAR
 206+ 4E83 2C           	DB ','
 207+ 4E84              	; get address of sprite update flag
 208+ 4E84 DD 21 A4 5E  	LD IX, PTRGET
 209+ 4E88 CD 59 01     	CALL CALBAS
 210+ 4E8B ED 53 80 4D  	LD (SPRATR_UPDATE_FLAG), DE
 211+ 4E8F              	; comma
 212+ 4E8F CD 13 67     	CALL CHKCHAR
 213+ 4E92 2C           	DB ','
 214+ 4E93              	; get flicker enabled flag
 215+ 4E93 DD 21 1C 52  	LD IX, GETBYT
 216+ 4E97 CD 59 01     	CALL CALBAS
 217+ 4E9A 32 84 4D     	LD (SPRFLICKER_ENABLED), A
 218+ 4E9D              	; comma
 219+ 4E9D CD 13 67     	CALL CHKCHAR
 220+ 4EA0 2C           	DB ','
 221+ 4EA1              	; get number of handled sprites
 222+ 4EA1 DD 21 1C 52  	LD IX, GETBYT
 223+ 4EA5 CD 59 01     	CALL CALBAS
 224+ 4EA8 32 86 4D     	LD (NUM_SPRITES_HANDLED),A
 225+ 4EAB              	; ending )
 226+ 4EAB CD 13 67     	CALL CHKCHAR
 227+ 4EAE 29           	DB ')'
 228+ 4EAF              .L0:
 229+ 4EAF 3E 01        	LD A, 1
 230+ 4EB1 32 7F 4D     	LD (SPRATR_INIT_STATUS), A
 231+ 4EB4 C9           	RET
 232+ 4EB5              ; *******************************************************************************************************
 233+ 4EB5               ENDIF
 234+ 4EB5
 235+ 4EB5               IF (DEFUSR_EXTENSION == 1)
 236+ 4EB5              ; same as SPRENABLE but for DEFUSR approach
 237+ 4EB5              ; input IX=pointer to input array, real data from +2
 238+ 4EB5              ; +2 = pointer to sprite attributes array data
 239+ 4EB5              ; +4 = pointer to sprite update variable
 240+ 4EB5              ; +6 = flicker flag
 241+ 4EB5              ; +8 = number of sprites to handle
 242+ 4EB5              SPRENABLE_DEFUSR:
 243+ 4EB5 DD 6E 02     	LD L,(IX+2)
 244+ 4EB8 DD 66 03     	LD H,(IX+3)
 245+ 4EBB 22 82 4D     	LD (SPRATR_DATA),HL
 246+ 4EBE DD 6E 04     	LD L,(IX+4)
 247+ 4EC1 DD 66 05     	LD H,(IX+5)
 248+ 4EC4 22 80 4D     	LD (SPRATR_UPDATE_FLAG),HL
 249+ 4EC7 DD 7E 06     	LD A,(IX+6)
 250+ 4ECA 32 84 4D     	LD (SPRFLICKER_ENABLED),A
 251+ 4ECD DD 7E 08     	LD A,(IX+8)
 252+ 4ED0 32 86 4D     	LD (NUM_SPRITES_HANDLED),A
 253+ 4ED3               IF (BASIC_EXTENSION == 1)
 254+ 4ED3 18 DA        	JR SPRENABLE.L0
 255+ 4ED5               ELSE
 256+ 4ED5 ~            	LD A, 1
 257+ 4ED5 ~            	LD (SPRATR_INIT_STATUS), A
 258+ 4ED5 ~            	RET
 259+ 4ED5               ENDIF
 260+ 4ED5               ENDIF
 261+ 4ED5
 262+ 4ED5               IF (DEFUSR_EXTENSION + BASIC_EXTENSION > 0)
 263+ 4ED5              ; *******************************************************************************************************
 264+ 4ED5              ; function to handle CALL SPRDISABLE basic extension
 265+ 4ED5              ; disables sprites handling
 266+ 4ED5              ; _SPRDISABLE
 267+ 4ED5              ; resets variable SPRATR_INIT_STATUS
 268+ 4ED5              SPRDISABLE:
 269+ 4ED5              SPRDISABLE_DEFUSR:
 270+ 4ED5 AF           	XOR A
 271+ 4ED6 32 7F 4D     	LD (SPRATR_INIT_STATUS), A
 272+ 4ED9 C9           	RET
 273+ 4EDA              ; *******************************************************************************************************
 274+ 4EDA               ENDIF
 275+ 4EDA
 276+ 4EDA              ; *******************************************************************************************************
 277+ 4EDA              ; function to handle CALL SPRSET basic extension
 278+ 4EDA              ; sets position, and optionally pattern and color of sprite
 279+ 4EDA              ; _SPRSET ( BYTE sprite_num , valid 0-31
 280+ 4EDA              ;			INT x,
 281+ 4EDA              ;			INT y,
 282+ 4EDA              ;			INT pattern, valid 0-63, otherwise ignored
 283+ 4EDA              ;			INT color, valid 0-15, otherwise ignored
 284+ 4EDA              ;SPRSET:
 285+ 4EDA              ;	LD A, (SPRATR_INIT_STATUS)
 286+ 4EDA              ;	OR A
 287+ 4EDA              ;	JR NZ, .L1
 288+ 4EDA              ;	LD E, 5 ; illegal function call
 289+ 4EDA              ;	JP THROW_ERROR
 290+ 4EDA              ;.L1:
 291+ 4EDA              ;	; opening (
 292+ 4EDA              ;	CALL CHKCHAR
 293+ 4EDA              ;	DB '('
 294+ 4EDA              ;	; get sprite number
 295+ 4EDA              ;	LD IX, GETBYT
 296+ 4EDA              ;	CALL CALBAS
 297+ 4EDA              ;	PUSH AF
 298+ 4EDA              ;	; comma
 299+ 4EDA              ;	CALL CHKCHAR
 300+ 4EDA              ;	DB ','
 301+ 4EDA              ;	; get x
 302+ 4EDA              ;	LD IX, FRMQNT
 303+ 4EDA              ;	CALL CALBAS
 304+ 4EDA              ;	PUSH DE
 305+ 4EDA              ;	; comma
 306+ 4EDA              ;	CALL CHKCHAR
 307+ 4EDA              ;	DB ','
 308+ 4EDA              ;	; get y
 309+ 4EDA              ;	LD IX, FRMQNT
 310+ 4EDA              ;	CALL CALBAS
 311+ 4EDA              ;	PUSH DE
 312+ 4EDA              ;	; comma
 313+ 4EDA              ;	CALL CHKCHAR
 314+ 4EDA              ;	DB ','
 315+ 4EDA              ;	; get pattern
 316+ 4EDA              ;	LD IX, FRMQNT
 317+ 4EDA              ;	CALL CALBAS
 318+ 4EDA              ;	PUSH DE
 319+ 4EDA              ;	; comma
 320+ 4EDA              ;	CALL CHKCHAR
 321+ 4EDA              ;	DB ','
 322+ 4EDA              ;	; get color
 323+ 4EDA              ;	LD IX, FRMQNT
 324+ 4EDA              ;	CALL CALBAS
 325+ 4EDA              ;	PUSH DE
 326+ 4EDA              ;	; ending )
 327+ 4EDA              ;	CALL CHKCHAR
 328+ 4EDA              ;	DB ')'
 329+ 4EDA              ;
 330+ 4EDA              ;   ; save position in BASIC text
 331+ 4EDA              ;	PUSH HL
 332+ 4EDA              ;	POP IX
 333+ 4EDA              ;
 334+ 4EDA              ;	POP BC ; color
 335+ 4EDA              ;	POP DE ; pattern
 336+ 4EDA              ;	EXX
 337+ 4EDA              ;	POP BC ; y
 338+ 4EDA              ;	POP DE ; x
 339+ 4EDA              ;	POP AF ; sprite number
 340+ 4EDA              ;	CP 32
 341+ 4EDA              ;	JR C, .L2
 342+ 4EDA              ;	LD E, 5 ; illegal function call
 343+ 4EDA              ;	JP THROW_ERROR
 344+ 4EDA              ;.L2:
 345+ 4EDA              ;	; find location in sprite attributes table
 346+ 4EDA              ;	PUSH DE
 347+ 4EDA              ;	CALL GETnthSPRATTR
 348+ 4EDA              ;	POP DE
 349+ 4EDA              ;	DI
 350+ 4EDA              ;	; set y
 351+ 4EDA              ;	LD (HL), C
 352+ 4EDA              ;	INC HL
 353+ 4EDA              ;	LD (HL), B
 354+ 4EDA              ;	INC HL
 355+ 4EDA              ;	; set x
 356+ 4EDA              ;	LD (HL), E
 357+ 4EDA              ;	INC HL
 358+ 4EDA              ;	LD (HL), D
 359+ 4EDA              ;	INC HL
 360+ 4EDA              ;	PUSH HL
 361+ 4EDA              ;	EXX
 362+ 4EDA              ;	POP HL
 363+ 4EDA              ;	; check if 0<=pattern<64
 364+ 4EDA              ;	LD A, D
 365+ 4EDA              ;	OR A
 366+ 4EDA              ;	JR NZ, .L3
 367+ 4EDA              ;	LD A, E
 368+ 4EDA              ;	CP 64
 369+ 4EDA              ;	JR NC, .L3
 370+ 4EDA              ;	; set pattern
 371+ 4EDA              ;	;ADD A, A
 372+ 4EDA              ;	;ADD A, A
 373+ 4EDA              ;	;ADD A, A
 374+ 4EDA              ;	LD (HL), A
 375+ 4EDA              ;	INC HL
 376+ 4EDA              ;	LD (HL), D
 377+ 4EDA              ;	INC HL
 378+ 4EDA              ;	JR .L4
 379+ 4EDA              ;.L3:
 380+ 4EDA              ;	; skip pattern
 381+ 4EDA              ;	.2 INC HL
 382+ 4EDA              ;.L4:
 383+ 4EDA              ;	; check if 0<=color<16
 384+ 4EDA              ;	LD A, B
 385+ 4EDA              ;	OR A
 386+ 4EDA              ;	JR NZ, .L5
 387+ 4EDA              ;	LD A, C
 388+ 4EDA              ;	CP 16
 389+ 4EDA              ;	JR NC, .L5
 390+ 4EDA              ;	; set color
 391+ 4EDA              ;	LD (HL), C
 392+ 4EDA              ;	INC HL
 393+ 4EDA              ;	LD (HL), B
 394+ 4EDA              ;
 395+ 4EDA              ;.L5:
 396+ 4EDA              ;	EI
 397+ 4EDA              ;	PUSH IX
 398+ 4EDA              ;	POP HL
 399+ 4EDA              ;	RET
 400+ 4EDA              ; *******************************************************************************************************
 401+ 4EDA
 402+ 4EDA              ; *******************************************************************************************************
 403+ 4EDA              ; function sets sprite location based on initial coordinates and offset provided
 404+ 4EDA              ; input A=sprite number in SPRATR_DATA , 0-31
 405+ 4EDA              ; input DE=initial x
 406+ 4EDA              ; input BC=initial y
 407+ 4EDA              ; input IY=location where delta y,x are located
 408+ 4EDA              ; modifies AF, HL, IX
 409+ 4EDA              SPRSET_DELTA_POS:
 410+ 4EDA D5           	PUSH DE
 411+ 4EDB CD 89 4D     	CALL GETnthSPRATTR
 412+ 4EDE E5           	PUSH HL
 413+ 4EDF DD E1        	POP IX
 414+ 4EE1 D1           	POP DE
 415+ 4EE2              	; IX=sprite's y location
 416+ 4EE2 FD 6E 00     	LD L, (IY)
 417+ 4EE5 FD 66 01     	LD H, (IY+1)
 418+ 4EE8 09           	ADD HL, BC
 419+ 4EE9 DD 75 00     	LD (IX), L
 420+ 4EEC DD 74 01     	LD (IX+1), H
 421+ 4EEF FD 6E 02     	LD L, (IY+2)
 422+ 4EF2 FD 66 03     	LD H, (IY+3)
 423+ 4EF5 19           	ADD HL, DE
 424+ 4EF6 DD 75 02     	LD (IX+2), L
 425+ 4EF9 DD 74 03     	LD (IX+3), H
 426+ 4EFC C9           	RET
 427+ 4EFD              ; *******************************************************************************************************
 428+ 4EFD
 429+ 4EFD              ; *******************************************************************************************************
 430+ 4EFD              ; helper function to set new locations for a set of sprites
 431+ 4EFD              ; input B=number of sprites
 432+ 4EFD              ; HL=pointer to list of sprites and offsets
 433+ 4EFD              SPR_UPDATE_LOC:
 434+ 4EFD 3E 01        	LD A,1
 435+ 4EFF 32 1F 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 436+ 4F02 7E           	LD A, (HL)
 437+ 4F03 23           	INC HL
 438+ 4F04 23           	INC HL
 439+ 4F05 E5           	PUSH HL
 440+ 4F06 FD E1        	POP IY
 441+ 4F08 D9           	EXX
 442+ 4F09 CD DA 4E     	CALL SPRSET_DELTA_POS
 443+ 4F0C D9           	EXX
 444+ 4F0D 23          > INC HL
 444+ 4F0E 23          > INC HL
 444+ 4F0F 23          > INC HL
 444+ 4F10 23          > INC HL
 445+ 4F11 10 EA        	DJNZ SPR_UPDATE_LOC
 446+ 4F13 AF           	XOR A
 447+ 4F14 32 1F 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 448+ 4F17 C9           	RET
 449+ 4F18              ; *******************************************************************************************************
 450+ 4F18
 451+ 4F18               IF (BASIC_EXTENSION == 1)
 452+ 4F18              ; *******************************************************************************************************
 453+ 4F18              ; function to handle CALL SPRGRPMOV basic extension
 454+ 4F18              ; sets position of a group of sprites described with
 455+ 4F18              ; { int sprite_num, int delta_y, int delta_x } [count]
 456+ 4F18              ; _SPRGRPMOV ( INT x,
 457+ 4F18              ;			   INT y,
 458+ 4F18              ;			   BYTE count,
 459+ 4F18              ;			   INT[2][count] data_ptr
 460+ 4F18              SPRGRPMOV:
 461+ 4F18 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
 462+ 4F1B B7           	OR A
 463+ 4F1C CA 33 67     	JP Z,ILLEGAL_FUNCTION
 464+ 4F1F              	; opening (
 465+ 4F1F CD 13 67     	CALL CHKCHAR
 466+ 4F22 28           	DB '('
 467+ 4F23              	; get x
 468+ 4F23 DD 21 2F 54  	LD IX, FRMQNT
 469+ 4F27 CD 59 01     	CALL CALBAS
 470+ 4F2A ED 53 0E 64  	LD (BLIT_STRUCT),DE
 471+ 4F2E              	; comma
 472+ 4F2E CD 13 67     	CALL CHKCHAR
 473+ 4F31 2C           	DB ','
 474+ 4F32              	; get y
 475+ 4F32 DD 21 2F 54  	LD IX, FRMQNT
 476+ 4F36 CD 59 01     	CALL CALBAS
 477+ 4F39 ED 53 10 64  	LD (BLIT_STRUCT+2),DE
 478+ 4F3D              	; comma
 479+ 4F3D CD 13 67     	CALL CHKCHAR
 480+ 4F40 2C           	DB ','
 481+ 4F41              	; get count
 482+ 4F41 DD 21 1C 52  	LD IX, GETBYT
 483+ 4F45 CD 59 01     	CALL CALBAS
 484+ 4F48 32 12 64     	LD (BLIT_STRUCT+4),A
 485+ 4F4B              	; comma
 486+ 4F4B CD 13 67     	CALL CHKCHAR
 487+ 4F4E 2C           	DB ','
 488+ 4F4F              	; get sprite group definition array data pointer
 489+ 4F4F 3A 12 64     	LD A,(BLIT_STRUCT+4)
 490+ 4F52 5F           	LD E,A
 491+ 4F53 16 03        	LD D,3
 492+ 4F55 3E 02        	LD A,2
 493+ 4F57 47           	LD B,A
 494+ 4F58 CD 40 67     	CALL GET_BASIC_ARRAY_DATA_POINTER
 495+ 4F5B ED 43 13 64  	LD (BLIT_STRUCT+5),BC
 496+ 4F5F              	; ending )
 497+ 4F5F CD 13 67     	CALL CHKCHAR
 498+ 4F62 29           	DB ')'
 499+ 4F63
 500+ 4F63 E5           	PUSH HL
 501+ 4F64
 502+ 4F64 D9               EXX
 503+ 4F65 ED 5B 0E 64      LD DE,(BLIT_STRUCT) ; initial x
 504+ 4F69 ED 4B 10 64      LD BC,(BLIT_STRUCT+2) ; initial y
 505+ 4F6D D9               EXX
 506+ 4F6E 2A 13 64         LD HL,(BLIT_STRUCT+5) ; pointer to data
 507+ 4F71 3A 12 64         LD A,(BLIT_STRUCT+4) ; number of entries
 508+ 4F74 47               LD B,A
 509+ 4F75 CD FD 4E     	CALL SPR_UPDATE_LOC
 510+ 4F78
 511+ 4F78 E1           	POP HL
 512+ 4F79 C9           	RET
 513+ 4F7A              ; *******************************************************************************************************
 514+ 4F7A               ENDIF
 515+ 4F7A
 516+ 4F7A               IF (DEFUSR_EXTENSION == 1)
 517+ 4F7A              ; *******************************************************************************************************
 518+ 4F7A              ; same as SPRGRPMOV but for DEFUSR approach
 519+ 4F7A              ; input IX=pointer to input array, real data from +2
 520+ 4F7A              ; +2 = X
 521+ 4F7A              ; +4 = Y
 522+ 4F7A              ; +6 = count
 523+ 4F7A              ; +8 = data pointer
 524+ 4F7A              SPRGRPMOV_DEFUSR:
 525+ 4F7A D9               EXX
 526+ 4F7B DD 5E 02     	LD E,(IX+2)
 527+ 4F7E DD 56 03     	LD D,(IX+3) ; initial x
 528+ 4F81 DD 4E 04     	LD C,(IX+4)
 529+ 4F84 DD 46 05     	LD B,(IX+5) ; initial y
 530+ 4F87 D9               EXX
 531+ 4F88 DD 6E 08     	LD L,(IX+8)
 532+ 4F8B DD 66 09     	LD H,(IX+9) ; pointer to data
 533+ 4F8E DD 46 06         LD B,(IX+6) ; count
 534+ 4F91 C3 FD 4E         JP SPR_UPDATE_LOC
 535+ 4F94              ; *******************************************************************************************************
 536+ 4F94               ENDIF
# file closed: asm\SPRITES.asm
 130  4F94               ENDIF
 131  4F94
 132  4F94               IF (ANIM_CMDS == 1)
 133  4F94               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4F94              ; sprite animation routines
   2+ 4F94
   3+ 4F94              ; number of animation items and pointer
   4+ 4F94              ANIMITEMNUM:
   5+ 4F94 00            DB 0
   6+ 4F95              ANIMITEMPTR:
   7+ 4F95 75 67         DW EXT_END
   8+ 4F97              ; number of animation definitions and pointer
   9+ 4F97              ANIMDEFNUM:
  10+ 4F97 00            DB 0
  11+ 4F98              ANIMDEFPTR:
  12+ 4F98 75 67         DW EXT_END
  13+ 4F9A              ; number of links between sprite and animation definitions
  14+ 4F9A              ANIMSPRNUM:
  15+ 4F9A 00            DB 0
  16+ 4F9B              ANIMSPRPTR:
  17+ 4F9B 75 67         DW EXT_END
  18+ 4F9D              ; number of automatic sprite group move and animate structures
  19+ 4F9D              AUTOSGAMNUM:
  20+ 4F9D 00            DB 0
  21+ 4F9E              AUTOSGAMPTR:
  22+ 4F9E 75 67         DW EXT_END
  23+ 4FA0
  24+ 4FA0              ; ANIMATION ITEM
  25+ 4FA0              ; byte type = [0 - pattern and color change
  26+ 4FA0              ;              1 - pattern definition change ]
  27+ 4FA0              ; word ticks - number of ticks to hold this state
  28+ 4FA0              ; for type = 0
  29+ 4FA0              ;   byte pattern;
  30+ 4FA0              ;   byte color;
  31+ 4FA0              ; for type = 1
  32+ 4FA0              ;   work data_pointer;
  33+ 4FA0              ; total size = 5b
  34+ 4FA0
  35+ 4FA0              ; ANIMATION DEFINITION
  36+ 4FA0              ; byte number of items 1-15
  37+ 4FA0              ; byte[15] anim_item;
  38+ 4FA0              ; total size = 16b
  39+ 4FA0
  40+ 4FA0              ; SPRITE/CHAR ANIMATION
  41+ 4FA0              ; +00 byte sprite/char number;
  42+ 4FA0              ; +01 word time;
  43+ 4FA0              ; +03 byte current item;
  44+ 4FA0              ; +04 byte animation definition;
  45+ 4FA0              ; +05 byte cyclic;
  46+ 4FA0              ; +06 byte active;
  47+ 4FA0              ; +07 byte 0=sprite, 1-3 character bank
  48+ 4FA0              ; total size = 8b
  49+ 4FA0
  50+ 4FA0              ; AUTOMATIC SPRITE GROUP MOVE AND ANIMATE structure
  51+ 4FA0              ; +00 pointer to X variable
  52+ 4FA0              ; +02 pointer to Y variable
  53+ 4FA0              ; +04 minimum value
  54+ 4FA0              ; +06 maximal value
  55+ 4FA0              ; +08 delta value
  56+ 4FA0              ; +10 direction 0=horizontal, <>0 = vertical
  57+ 4FA0              ; +11 sprite group size
  58+ 4FA0              ; +12 sprite group pointer
  59+ 4FA0              ; +14 animation list size
  60+ 4FA0              ; +15 animation list pointer for negative delta values
  61+ 4FA0              ; +17 animation list pointer for positive delta values
  62+ 4FA0              ; +19 active flag
  63+ 4FA0              ; +20 ticks for movement
  64+ 4FA0              ; +22 timer
  65+ 4FA0              ; total = 24b
  66+ 4FA0
  67+ 4FA0              ; *******************************************************************************************************
  68+ 4FA0              ; helper function HL=A*5
  69+ 4FA0              ; changes HL,DE
  70+ 4FA0              Ax5:
  71+ 4FA0 26 00            LD H,0
  72+ 4FA2 6F               LD L,A
  73+ 4FA3 54               LD D,H
  74+ 4FA4 5D               LD E,L
  75+ 4FA5 29               ADD HL,HL
  76+ 4FA6 29               ADD HL,HL
  77+ 4FA7 19               ADD HL,DE
  78+ 4FA8 C9               RET
  79+ 4FA9              ; *******************************************************************************************************
  80+ 4FA9
  81+ 4FA9              ; *******************************************************************************************************
  82+ 4FA9              ; helper function gets pointer to n-th animation item
  83+ 4FA9              ; changes HL,DE
  84+ 4FA9              GETnthANIMITEM:
  85+ 4FA9 CD A0 4F         CALL Ax5
  86+ 4FAC ED 5B 95 4F      LD DE,(ANIMITEMPTR)
  87+ 4FB0 19               ADD HL,DE
  88+ 4FB1 C9               RET
  89+ 4FB2              ; *******************************************************************************************************
  90+ 4FB2
  91+ 4FB2              ; *******************************************************************************************************
  92+ 4FB2              ; helper function gets pointer to n-th entry in animation definition
  93+ 4FB2              ; changes HL,DE
  94+ 4FB2              GETnthANIMDEF:
  95+ 4FB2 26 00            LD H,0
  96+ 4FB4 6F               LD L,A
  97+ 4FB5 CD 00 66         CALL HLx16
  98+ 4FB8 ED 5B 98 4F      LD DE,(ANIMDEFPTR)
  99+ 4FBC 19               ADD HL,DE
 100+ 4FBD C9               RET
 101+ 4FBE              ; *******************************************************************************************************
 102+ 4FBE
 103+ 4FBE              ; *******************************************************************************************************
 104+ 4FBE              ; helper function gets pointer to n-th entry in sprite animation
 105+ 4FBE              ; changes HL,DE
 106+ 4FBE              GETnthSPRANIM:
 107+ 4FBE 26 00            LD H,0
 108+ 4FC0 6F               LD L,A
 109+ 4FC1 CD 01 66         CALL HLx8
 110+ 4FC4 ED 5B 9B 4F      LD DE,(ANIMSPRPTR)
 111+ 4FC8 19               ADD HL,DE
 112+ 4FC9 C9               RET
 113+ 4FCA              ; *******************************************************************************************************
 114+ 4FCA
 115+ 4FCA              ; *******************************************************************************************************
 116+ 4FCA              ; helper function gets pointer to n-th entry in autosgam table
 117+ 4FCA              ; changes HL,DE
 118+ 4FCA              GETnthAUTOSGAM:
 119+ 4FCA 26 00            LD H,0
 120+ 4FCC 6F               LD L,A
 121+ 4FCD CD 01 66         CALL HLx8
 122+ 4FD0 54               LD D,H
 123+ 4FD1 5D               LD E,L
 124+ 4FD2 29               ADD HL,HL
 125+ 4FD3 19               ADD HL,DE
 126+ 4FD4 ED 5B 9E 4F      LD DE,(AUTOSGAMPTR)
 127+ 4FD8 19               ADD HL,DE
 128+ 4FD9 C9               RET
 129+ 4FDA              ; *******************************************************************************************************
 130+ 4FDA
 131+ 4FDA              ; *******************************************************************************************************
 132+ 4FDA              ; function to handle CALL MAXANIMITEMS basic extension
 133+ 4FDA              ; MAXANIMITEMS (BYTE number)
 134+ 4FDA              ; sets new number and moves memory buffers as needed
 135+ 4FDA              MAXANIMITEMS:
 136+ 4FDA              	; opening (
 137+ 4FDA CD 13 67     	CALL CHKCHAR
 138+ 4FDD 28           	DB '('
 139+ 4FDE              	; get value
 140+ 4FDE DD 21 1C 52  	LD IX, GETBYT
 141+ 4FE2 CD 59 01     	CALL CALBAS
 142+ 4FE5 F5               PUSH AF
 143+ 4FE6              	; ending )
 144+ 4FE6 CD 13 67     	CALL CHKCHAR
 145+ 4FE9 29           	DB ')'
 146+ 4FEA F1               POP AF
 147+ 4FEB F3               DI
 148+ 4FEC              	; save position
 149+ 4FEC E5           	PUSH HL
 150+ 4FED              .ENTRY:
 151+ 4FED 47               LD B,A
 152+ 4FEE 3A 94 4F         LD A,(ANIMITEMNUM)
 153+ 4FF1 90               SUB B
 154+ 4FF2 28 28            JR Z, .EXIT; same value as before
 155+ 4FF4 FD 21 98 4F      LD IY,ANIMDEFPTR
 156+ 4FF8 FA 1F 50         JP M, .INCREASE
 157+ 4FFB                  ; new value is lower than previous one
 158+ 4FFB CD 3E 50         CALL .SIZEDIFF
 159+ 4FFE CD 59 50         CALL .DECREASE_COMMON
 160+ 5001 2A 9B 4F         LD HL,(ANIMSPRPTR)
 161+ 5004 AF               XOR A
 162+ 5005 ED 42            SBC HL,BC
 163+ 5007 22 9B 4F         LD (ANIMSPRPTR),HL
 164+ 500A              .E1:
 165+ 500A 2A 9E 4F         LD HL,(AUTOSGAMPTR)
 166+ 500D AF               XOR A
 167+ 500E ED 42            SBC HL,BC
 168+ 5010 22 9E 4F         LD (AUTOSGAMPTR),HL
 169+ 5013              .E3:
 170+ 5013 2A 10 40         LD HL,(FREEMEMPTR)
 171+ 5016 AF               XOR A
 172+ 5017 ED 42            SBC HL,BC
 173+ 5019 22 10 40         LD (FREEMEMPTR),HL
 174+ 501C              .EXIT:
 175+ 501C FB               EI
 176+ 501D E1           	POP HL
 177+ 501E C9           	RET
 178+ 501F              .INCREASE:
 179+ 501F ED 44            NEG
 180+ 5021 CD 3E 50         CALL .SIZEDIFF
 181+ 5024 CD 85 50         CALL .INCREASE_COMMON
 182+ 5027 2A 9B 4F         LD HL,(ANIMSPRPTR)
 183+ 502A 09               ADD HL,BC
 184+ 502B 22 9B 4F         LD (ANIMSPRPTR),HL
 185+ 502E              .E2:
 186+ 502E 2A 9E 4F         LD HL,(AUTOSGAMPTR)
 187+ 5031 09               ADD HL,BC
 188+ 5032 22 9E 4F         LD (AUTOSGAMPTR),HL
 189+ 5035              .E4:
 190+ 5035 2A 10 40         LD HL,(FREEMEMPTR)
 191+ 5038 09               ADD HL,BC
 192+ 5039 22 10 40         LD (FREEMEMPTR),HL
 193+ 503C 18 DE            JR .EXIT
 194+ 503E              .SIZEDIFF:
 195+ 503E CD A0 4F         CALL Ax5
 196+ 5041 78               LD A,B
 197+ 5042 32 94 4F         LD (ANIMITEMNUM),A
 198+ 5045 44               LD B,H
 199+ 5046 4D               LD C,L
 200+ 5047 C9               RET ; BC=size difference in bytes
 201+ 5048              .SIZETOMOVE:
 202+ 5048 D5               PUSH DE
 203+ 5049 2A 10 40         LD HL,(FREEMEMPTR)
 204+ 504C FD 5E 00         LD E,(IY)
 205+ 504F FD 56 01         LD D,(IY+1)
 206+ 5052 AF               XOR A
 207+ 5053 ED 52            SBC HL,DE
 208+ 5055 44               LD B,H
 209+ 5056 4D               LD C,L
 210+ 5057 D1               POP DE
 211+ 5058 C9               RET
 212+ 5059              .DECREASE_COMMON:
 213+ 5059 FD 6E 00         LD L,(IY)
 214+ 505C FD 66 01         LD H,(IY+1)
 215+ 505F AF               XOR A
 216+ 5060 ED 42            SBC HL,BC
 217+ 5062 EB               EX DE,HL
 218+ 5063 C5               PUSH BC
 219+ 5064 CD 48 50         CALL .SIZETOMOVE
 220+ 5067 F3               DI
 221+ 5068 78               LD A,B
 222+ 5069 B1               OR C
 223+ 506A 28 08            JR Z,.L1
 224+ 506C FD 6E 00         LD L,(IY)
 225+ 506F FD 66 01         LD H,(IY+1)
 226+ 5072 ED B0            LDIR
 227+ 5074              .L1:
 228+ 5074 C1               POP BC
 229+ 5075 FD 6E 00         LD L,(IY)
 230+ 5078 FD 66 01         LD H,(IY+1)
 231+ 507B AF               XOR A
 232+ 507C ED 42            SBC HL,BC
 233+ 507E FD 75 00         LD (IY),L
 234+ 5081 FD 74 01         LD (IY+1),H
 235+ 5084 C9               RET
 236+ 5085              .INCREASE_COMMON:
 237+ 5085 2A 10 40         LD HL,(FREEMEMPTR)
 238+ 5088 2B               DEC HL
 239+ 5089 AF               XOR A
 240+ 508A ED 42            SBC HL,BC
 241+ 508C EB               EX DE,HL
 242+ 508D C5               PUSH BC
 243+ 508E CD 48 50         CALL .SIZETOMOVE
 244+ 5091 F3               DI
 245+ 5092 78               LD A,B
 246+ 5093 B1               OR C
 247+ 5094 28 06            JR Z,.L2
 248+ 5096 2A 10 40         LD HL,(FREEMEMPTR)
 249+ 5099 2B               DEC HL
 250+ 509A ED B8            LDDR
 251+ 509C              .L2:
 252+ 509C C1               POP BC
 253+ 509D FD 6E 00         LD L,(IY)
 254+ 50A0 FD 66 01         LD H,(IY+1)
 255+ 50A3 09               ADD HL,BC
 256+ 50A4 FD 75 00         LD (IY),L
 257+ 50A7 FD 74 01         LD (IY+1),H
 258+ 50AA C9               RET
 259+ 50AB              ; *******************************************************************************************************
 260+ 50AB
 261+ 50AB              ; *******************************************************************************************************
 262+ 50AB              ; function to handle CALL ANIMITEMPAT basic extension
 263+ 50AB              ; ANIMITEMPAT ( BYTE id,
 264+ 50AB              ;               INT ticks >0,
 265+ 50AB              ;               BYTE pattern,
 266+ 50AB              ;               BYTE color )
 267+ 50AB              ; fills animation item data, returns an error if ID out of bounds
 268+ 50AB              ANIMITEMPAT:
 269+ 50AB                  ; opening (
 270+ 50AB CD 13 67     	CALL CHKCHAR
 271+ 50AE 28           	DB '('
 272+ 50AF              	; get id
 273+ 50AF DD 21 1C 52  	LD IX, GETBYT
 274+ 50B3 CD 59 01     	CALL CALBAS
 275+ 50B6 F5               PUSH AF
 276+ 50B7                  ; check if out of bounds
 277+ 50B7 3C               INC A
 278+ 50B8 4F               LD C,A
 279+ 50B9 3A 94 4F         LD A,(ANIMITEMNUM)
 280+ 50BC B9               CP C
 281+ 50BD DA 2B 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 282+ 50C0              	; comma
 283+ 50C0 CD 13 67     	CALL CHKCHAR
 284+ 50C3 2C           	DB ','
 285+ 50C4              	; get ticks
 286+ 50C4 DD 21 2F 54  	LD IX, FRMQNT
 287+ 50C8 CD 59 01     	CALL CALBAS
 288+ 50CB 7A               LD A,D
 289+ 50CC B3               OR E
 290+ 50CD CA 2F 67         JP Z, OVERFLOW
 291+ 50D0 D5           	PUSH DE
 292+ 50D1              	; comma
 293+ 50D1 CD 13 67     	CALL CHKCHAR
 294+ 50D4 2C           	DB ','
 295+ 50D5              	; get pattern
 296+ 50D5 DD 21 1C 52  	LD IX, GETBYT
 297+ 50D9 CD 59 01     	CALL CALBAS
 298+ 50DC F5               PUSH AF
 299+ 50DD              	; comma
 300+ 50DD CD 13 67     	CALL CHKCHAR
 301+ 50E0 2C           	DB ','
 302+ 50E1              	; get color
 303+ 50E1 DD 21 1C 52  	LD IX, GETBYT
 304+ 50E5 CD 59 01     	CALL CALBAS
 305+ 50E8 F5               PUSH AF
 306+ 50E9              	; ending )
 307+ 50E9 CD 13 67     	CALL CHKCHAR
 308+ 50EC 29           	DB ')'
 309+ 50ED              .ENTRY:
 310+ 50ED E5               PUSH HL
 311+ 50EE DD E1            POP IX
 312+ 50F0 D9               EXX
 313+ 50F1 C1               POP BC ; color
 314+ 50F2 D1               POP DE ; pattern
 315+ 50F3 E1               POP HL ; ticks
 316+ 50F4 D9               EXX
 317+ 50F5 F1               POP AF
 318+ 50F6 CD A9 4F         CALL GETnthANIMITEM
 319+ 50F9 E5               PUSH HL
 320+ 50FA FD E1            POP IY
 321+ 50FC D9               EXX
 322+ 50FD FD 36 00 00      LD (IY),0 ; type=0
 323+ 5101 FD 75 01         LD (IY+1),L
 324+ 5104 FD 74 02         LD (IY+2),H
 325+ 5107 FD 72 03         LD (IY+3),D
 326+ 510A FD 70 04         LD (IY+4),B
 327+ 510D
 328+ 510D DD E5            PUSH IX
 329+ 510F E1               POP HL
 330+ 5110 C9               RET
 331+ 5111              ; *******************************************************************************************************
 332+ 5111
 333+ 5111              ; *******************************************************************************************************
 334+ 5111              ; function to handle CALL ANIMITEMPTR basic extension
 335+ 5111              ; ANIMITEMPTR ( BYTE id,
 336+ 5111              ;               INT ticks,
 337+ 5111              ;               INT pointer,
 338+ 5111              ; fills animation item data, returns an error if ID out of bounds
 339+ 5111              ANIMITEMPTR_CMD:
 340+ 5111                  ; opening (
 341+ 5111 CD 13 67     	CALL CHKCHAR
 342+ 5114 28           	DB '('
 343+ 5115              	; get id
 344+ 5115 DD 21 1C 52  	LD IX, GETBYT
 345+ 5119 CD 59 01     	CALL CALBAS
 346+ 511C F5               PUSH AF
 347+ 511D                  ; check if out of bounds
 348+ 511D 3C               INC A
 349+ 511E 4F               LD C,A
 350+ 511F 3A 94 4F         LD A,(ANIMITEMNUM)
 351+ 5122 B9               CP C
 352+ 5123 DA 2B 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 353+ 5126              	; comma
 354+ 5126 CD 13 67     	CALL CHKCHAR
 355+ 5129 2C           	DB ','
 356+ 512A              	; get ticks
 357+ 512A DD 21 2F 54  	LD IX, FRMQNT
 358+ 512E CD 59 01     	CALL CALBAS
 359+ 5131 7A               LD A,D
 360+ 5132 B3               OR E
 361+ 5133 CA 2F 67         JP Z,OVERFLOW
 362+ 5136 D5           	PUSH DE
 363+ 5137              	; comma
 364+ 5137 CD 13 67     	CALL CHKCHAR
 365+ 513A 2C           	DB ','
 366+ 513B              	; get pointer
 367+ 513B DD 21 2F 54  	LD IX, FRMQNT
 368+ 513F CD 59 01     	CALL CALBAS
 369+ 5142 D5           	PUSH DE
 370+ 5143              	; ending )
 371+ 5143 CD 13 67     	CALL CHKCHAR
 372+ 5146 29           	DB ')'
 373+ 5147              .ENTRY:
 374+ 5147 E5               PUSH HL
 375+ 5148 DD E1            POP IX
 376+ 514A D9               EXX
 377+ 514B D1               POP DE ; pointer
 378+ 514C E1               POP HL ; ticks
 379+ 514D D9               EXX
 380+ 514E F1               POP AF
 381+ 514F CD A9 4F         CALL GETnthANIMITEM
 382+ 5152 E5               PUSH HL
 383+ 5153 FD E1            POP IY
 384+ 5155 D9               EXX
 385+ 5156 FD 36 00 01      LD (IY),1 ; type=1
 386+ 515A FD 75 01         LD (IY+1),L
 387+ 515D FD 74 02         LD (IY+2),H
 388+ 5160 FD 73 03         LD (IY+3),E
 389+ 5163 FD 72 04         LD (IY+4),D
 390+ 5166
 391+ 5166 DD E5            PUSH IX
 392+ 5168 E1               POP HL
 393+ 5169 C9               RET
 394+ 516A              ; *******************************************************************************************************
 395+ 516A
 396+ 516A              ; *******************************************************************************************************
 397+ 516A              ; function to handle CALL MAXANIMDEFS basic extension
 398+ 516A              ; MAXANIMDEFS (BYTE number)
 399+ 516A              ; sets new number and moves memory buffers as needed
 400+ 516A              MAXANIMDEFS:
 401+ 516A              	; opening (
 402+ 516A CD 13 67     	CALL CHKCHAR
 403+ 516D 28           	DB '('
 404+ 516E              	; get value
 405+ 516E DD 21 1C 52  	LD IX, GETBYT
 406+ 5172 CD 59 01     	CALL CALBAS
 407+ 5175 F5               PUSH AF
 408+ 5176              	; ending )
 409+ 5176 CD 13 67     	CALL CHKCHAR
 410+ 5179 29           	DB ')'
 411+ 517A F1               POP AF
 412+ 517B F3               DI
 413+ 517C              	; save position
 414+ 517C E5           	PUSH HL
 415+ 517D              .ENTRY:
 416+ 517D 47               LD B,A
 417+ 517E 3A 97 4F         LD A,(ANIMDEFNUM)
 418+ 5181 90               SUB B
 419+ 5182 CA 1C 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 420+ 5185 FD 21 9B 4F      LD IY,ANIMSPRPTR
 421+ 5189 FA 95 51         JP M, .INCREASE
 422+ 518C                  ; new value is lower than previous one
 423+ 518C CD A0 51         CALL .SIZEDIFF
 424+ 518F CD 59 50         CALL MAXANIMITEMS.DECREASE_COMMON
 425+ 5192 C3 0A 50         JP MAXANIMITEMS.E1
 426+ 5195              .INCREASE:
 427+ 5195 ED 44            NEG
 428+ 5197 CD A0 51         CALL .SIZEDIFF
 429+ 519A CD 85 50         CALL MAXANIMITEMS.INCREASE_COMMON
 430+ 519D C3 2E 50         JP MAXANIMITEMS.E2
 431+ 51A0              .SIZEDIFF:
 432+ 51A0 26 00            LD H,0
 433+ 51A2 6F               LD L,A
 434+ 51A3 CD 00 66         CALL HLx16
 435+ 51A6 78               LD A,B
 436+ 51A7 32 97 4F         LD (ANIMDEFNUM),A
 437+ 51AA 44               LD B,H
 438+ 51AB 4D               LD C,L
 439+ 51AC C9               RET ; BC=size difference in bytes
 440+ 51AD              ; *******************************************************************************************************
 441+ 51AD
 442+ 51AD              ; *******************************************************************************************************
 443+ 51AD              ; function to handle CALL ANIMDEF basic extension
 444+ 51AD              ; ANIMITEMPAT ( BYTE id,
 445+ 51AD              ;               BYTE size,
 446+ 51AD              ;               INT[] list )
 447+ 51AD              ; fills animation definition data, returns an error if out of bounds, or invalid type
 448+ 51AD              ANIMDEF:
 449+ 51AD                  ; opening (
 450+ 51AD CD 13 67     	CALL CHKCHAR
 451+ 51B0 28           	DB '('
 452+ 51B1              	; get id
 453+ 51B1 DD 21 1C 52  	LD IX, GETBYT
 454+ 51B5 CD 59 01     	CALL CALBAS
 455+ 51B8 F5               PUSH AF
 456+ 51B9                  ; check if out of bounds
 457+ 51B9 3C               INC A
 458+ 51BA 4F               LD C,A
 459+ 51BB 3A 97 4F         LD A,(ANIMDEFNUM)
 460+ 51BE B9               CP C
 461+ 51BF DA 2B 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 462+ 51C2              	; comma
 463+ 51C2 CD 13 67     	CALL CHKCHAR
 464+ 51C5 2C           	DB ','
 465+ 51C6              	; get size
 466+ 51C6 DD 21 1C 52  	LD IX, GETBYT
 467+ 51CA CD 59 01     	CALL CALBAS
 468+ 51CD FE 10            CP 16
 469+ 51CF D2 2F 67         JP NC, OVERFLOW
 470+ 51D2 B7               OR A
 471+ 51D3 CA 2F 67         JP Z, OVERFLOW
 472+ 51D6 F5           	PUSH AF
 473+ 51D7              	; comma
 474+ 51D7 CD 13 67     	CALL CHKCHAR
 475+ 51DA 2C           	DB ','
 476+ 51DB              	; get pointer to a list of animation items in integer array format
 477+ 51DB                  ; get array pointer
 478+ 51DB D1               POP DE
 479+ 51DC D5               PUSH DE
 480+ 51DD 3E 02            LD A,2
 481+ 51DF 06 01            LD B,1
 482+ 51E1 CD 40 67         CALL GET_BASIC_ARRAY_DATA_POINTER
 483+ 51E4 C5               PUSH BC
 484+ 51E5              	; ending )
 485+ 51E5 CD 13 67     	CALL CHKCHAR
 486+ 51E8 29           	DB ')'
 487+ 51E9              .ENTRY:
 488+ 51E9 E5               PUSH HL
 489+ 51EA DD E1            POP IX
 490+ 51EC D1               POP DE ; pointer to INT array
 491+ 51ED C1               POP BC ; B=item number
 492+ 51EE F1               POP AF ; id
 493+ 51EF D5               PUSH DE
 494+ 51F0 CD B2 4F         CALL GETnthANIMDEF
 495+ 51F3 D1               POP DE
 496+ 51F4 70               LD (HL),B
 497+ 51F5              .L1:
 498+ 51F5 23               INC HL
 499+ 51F6 1A               LD A,(DE)
 500+ 51F7 13          > INC DE
 500+ 51F8 13          > INC DE
 501+ 51F9 77               LD (HL),A
 502+ 51FA 10 F9            DJNZ .L1
 503+ 51FC DD E5            PUSH IX
 504+ 51FE E1               POP HL
 505+ 51FF C9               RET
 506+ 5200              ; *******************************************************************************************************
 507+ 5200
 508+ 5200              ; *******************************************************************************************************
 509+ 5200              ; function to handle CALL MAXANIMSPRS basic extension
 510+ 5200              ; MAXANIMSPRS (BYTE number)
 511+ 5200              ; sets new number and moves memory buffers as needed
 512+ 5200              MAXANIMSPRS:
 513+ 5200              	; opening (
 514+ 5200 CD 13 67     	CALL CHKCHAR
 515+ 5203 28           	DB '('
 516+ 5204              	; get value
 517+ 5204 DD 21 1C 52  	LD IX, GETBYT
 518+ 5208 CD 59 01     	CALL CALBAS
 519+ 520B F5               PUSH AF
 520+ 520C              	; ending )
 521+ 520C CD 13 67     	CALL CHKCHAR
 522+ 520F 29           	DB ')'
 523+ 5210 F1               POP AF
 524+ 5211 F3               DI
 525+ 5212              	; save position
 526+ 5212 E5           	PUSH HL
 527+ 5213              .ENTRY:
 528+ 5213 47               LD B,A
 529+ 5214 3A 9A 4F         LD A,(ANIMSPRNUM)
 530+ 5217 90               SUB B
 531+ 5218 CA 1C 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 532+ 521B FD 21 9E 4F      LD IY,AUTOSGAMPTR
 533+ 521F FA 2B 52         JP M, .INCREASE
 534+ 5222                  ; new value is lower than previous one
 535+ 5222 CD 4C 52         CALL .SIZEDIFF
 536+ 5225 CD 59 50         CALL MAXANIMITEMS.DECREASE_COMMON
 537+ 5228 C3 13 50         JP MAXANIMITEMS.E3
 538+ 522B              .INCREASE:
 539+ 522B ED 44            NEG
 540+ 522D F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 541+ 522E CD 4C 52         CALL .SIZEDIFF
 542+ 5231 CD 85 50         CALL MAXANIMITEMS.INCREASE_COMMON
 543+ 5234 AF               XOR A
 544+ 5235 ED 42            SBC HL,BC ; location of new stuff
 545+ 5237 F1               POP AF
 546+ 5238 C5               PUSH BC
 547+ 5239 47               LD B,A
 548+ 523A 11 08 00         LD DE,8
 549+ 523D E5               PUSH HL
 550+ 523E DD E1            POP IX
 551+ 5240              .L1:
 552+ 5240 DD 36 06 00      LD (IX+6),0 ; active flag
 553+ 5244 DD 19            ADD IX,DE
 554+ 5246 10 F8            DJNZ .L1
 555+ 5248 C1               POP BC
 556+ 5249 C3 35 50         JP MAXANIMITEMS.E4
 557+ 524C              .SIZEDIFF:
 558+ 524C 26 00            LD H,0
 559+ 524E 6F               LD L,A
 560+ 524F CD 01 66         CALL HLx8
 561+ 5252 78               LD A,B
 562+ 5253 32 9A 4F         LD (ANIMSPRNUM),A
 563+ 5256 44               LD B,H
 564+ 5257 4D               LD C,L
 565+ 5258 C9               RET ; BC=size difference in bytes
 566+ 5259              ; *******************************************************************************************************
 567+ 5259
 568+ 5259              ; *******************************************************************************************************
 569+ 5259              ; function to handle CALL ANIMSPRITE basic extension
 570+ 5259              ; ANIMSPRITE ( BYTE id,
 571+ 5259              ;              BYTE sprite_number,
 572+ 5259              ;              BYTE animation_definition_id,
 573+ 5259              ;              BYTE cyclic_flag )
 574+ 5259              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 575+ 5259              ANIMSPRITE:
 576+ 5259                  ; opening (
 577+ 5259 CD 13 67     	CALL CHKCHAR
 578+ 525C 28           	DB '('
 579+ 525D              	; get sprite animation id
 580+ 525D DD 21 1C 52  	LD IX, GETBYT
 581+ 5261 CD 59 01     	CALL CALBAS
 582+ 5264 F5               PUSH AF
 583+ 5265 3C               INC A
 584+ 5266 4F               LD C,A
 585+ 5267 3A 9A 4F         LD A,(ANIMSPRNUM)
 586+ 526A B9               CP C
 587+ 526B DA 2B 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 588+ 526E              	; comma
 589+ 526E CD 13 67     	CALL CHKCHAR
 590+ 5271 2C           	DB ','
 591+ 5272              	; get sprite number
 592+ 5272 DD 21 1C 52  	LD IX, GETBYT
 593+ 5276 CD 59 01     	CALL CALBAS
 594+ 5279 F5               PUSH AF
 595+ 527A                  ; check if out of bounds
 596+ 527A FE 20            CP 32
 597+ 527C D2 2B 67         JP NC, SUBSCRIPT_OUT_OF_RANGE
 598+ 527F              	; comma
 599+ 527F CD 13 67     	CALL CHKCHAR
 600+ 5282 2C           	DB ','
 601+ 5283              	; get animation definition id
 602+ 5283 DD 21 1C 52  	LD IX, GETBYT
 603+ 5287 CD 59 01     	CALL CALBAS
 604+ 528A F5               PUSH AF
 605+ 528B 3C               INC A
 606+ 528C 4F               LD C,A
 607+ 528D 3A 97 4F         LD A,(ANIMDEFNUM)
 608+ 5290 B9               CP C
 609+ 5291 DA 2B 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 610+ 5294              	; comma
 611+ 5294 CD 13 67     	CALL CHKCHAR
 612+ 5297 2C           	DB ','
 613+ 5298              	; get cyclic flag
 614+ 5298 DD 21 1C 52  	LD IX, GETBYT
 615+ 529C CD 59 01         CALL CALBAS
 616+ 529F F5           	PUSH AF
 617+ 52A0              	; ending )
 618+ 52A0 CD 13 67     	CALL CHKCHAR
 619+ 52A3 29           	DB ')'
 620+ 52A4              .ENTRY:
 621+ 52A4 E5               PUSH HL
 622+ 52A5 DD E1            POP IX
 623+ 52A7 D9               EXX
 624+ 52A8 D1               POP DE ; cyclic
 625+ 52A9 C1               POP BC ; animation definition id
 626+ 52AA E1               POP HL ; sprite number
 627+ 52AB D9               EXX
 628+ 52AC F1               POP AF ; sprite animation id
 629+ 52AD CD BE 4F         CALL GETnthSPRANIM
 630+ 52B0 E5               PUSH HL
 631+ 52B1 FD E1            POP IY
 632+ 52B3 D9               EXX
 633+ 52B4 FD 74 00         LD (IY),H
 634+ 52B7 FD 70 04         LD (IY+4),B
 635+ 52BA FD 72 05         LD (IY+5),D
 636+ 52BD                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 637+ 52BD                  ; following will do preparation for ANIMSTEP situation
 638+ 52BD                  ; current item set to above limit and timer to 1
 639+ 52BD                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 640+ 52BD FD 36 03 FF      LD (IY+3),255
 641+ 52C1 FD 36 01 01      LD (IY+1),1
 642+ 52C5 FD 36 02 00      LD (IY+2),0
 643+ 52C9                  ; mark as sprite animation
 644+ 52C9 FD 36 07 00      LD (IY+7),0
 645+ 52CD DD E5            PUSH IX
 646+ 52CF E1               POP HL
 647+ 52D0 C9               RET
 648+ 52D1              ; *******************************************************************************************************
 649+ 52D1
 650+ 52D1              ; *******************************************************************************************************
 651+ 52D1              ; function to handle CALL ANIMCHAR basic extension
 652+ 52D1              ; ANIMCHAR ( BYTE id,
 653+ 52D1              ;            INT character number 0-767,
 654+ 52D1              ;            BYTE animation_definition_id,
 655+ 52D1              ;            BYTE cyclic_flag )
 656+ 52D1              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 657+ 52D1              ANIMCHAR:
 658+ 52D1                  ; opening (
 659+ 52D1 CD 13 67     	CALL CHKCHAR
 660+ 52D4 28           	DB '('
 661+ 52D5              	; get sprite animation id
 662+ 52D5 DD 21 1C 52  	LD IX, GETBYT
 663+ 52D9 CD 59 01     	CALL CALBAS
 664+ 52DC F5               PUSH AF
 665+ 52DD 3C               INC A
 666+ 52DE 4F               LD C,A
 667+ 52DF 3A 9A 4F         LD A,(ANIMSPRNUM)
 668+ 52E2 B9               CP C
 669+ 52E3 DA 2B 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 670+ 52E6              	; comma
 671+ 52E6 CD 13 67     	CALL CHKCHAR
 672+ 52E9 2C           	DB ','
 673+ 52EA              	; get character number
 674+ 52EA DD 21 2F 54  	LD IX, FRMQNT
 675+ 52EE CD 59 01     	CALL CALBAS
 676+ 52F1 D5               PUSH DE
 677+ 52F2                  ; check if out of bounds
 678+ 52F2 7A               LD A,D
 679+ 52F3 FE 03            CP 3
 680+ 52F5 D2 2B 67         JP NC, SUBSCRIPT_OUT_OF_RANGE
 681+ 52F8              	; comma
 682+ 52F8 CD 13 67     	CALL CHKCHAR
 683+ 52FB 2C           	DB ','
 684+ 52FC              	; get animation definition id
 685+ 52FC DD 21 1C 52  	LD IX, GETBYT
 686+ 5300 CD 59 01     	CALL CALBAS
 687+ 5303 F5               PUSH AF
 688+ 5304 3C               INC A
 689+ 5305 4F               LD C,A
 690+ 5306 3A 97 4F         LD A,(ANIMDEFNUM)
 691+ 5309 B9               CP C
 692+ 530A DA 2B 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 693+ 530D              	; comma
 694+ 530D CD 13 67     	CALL CHKCHAR
 695+ 5310 2C           	DB ','
 696+ 5311              	; get cyclic flag
 697+ 5311 DD 21 1C 52  	LD IX, GETBYT
 698+ 5315 CD 59 01         CALL CALBAS
 699+ 5318 F5           	PUSH AF
 700+ 5319              	; ending )
 701+ 5319 CD 13 67     	CALL CHKCHAR
 702+ 531C 29           	DB ')'
 703+ 531D              .ENTRY:
 704+ 531D E5               PUSH HL
 705+ 531E DD E1            POP IX
 706+ 5320 D9               EXX
 707+ 5321 D1               POP DE ; cyclic
 708+ 5322 C1               POP BC ; animation definition id
 709+ 5323 E1               POP HL ; character number
 710+ 5324 D9               EXX
 711+ 5325 F1               POP AF ; sprite animation id
 712+ 5326 CD BE 4F         CALL GETnthSPRANIM
 713+ 5329 E5               PUSH HL
 714+ 532A FD E1            POP IY
 715+ 532C D9               EXX
 716+ 532D FD 75 00         LD (IY),L
 717+ 5330 24               INC H ; save character bank+1
 718+ 5331 FD 74 07         LD (IY+7),H
 719+ 5334 FD 70 04         LD (IY+4),B
 720+ 5337 FD 72 05         LD (IY+5),D
 721+ 533A                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 722+ 533A                  ; following will do preparation for ANIMSTEP situation
 723+ 533A                  ; current item set to above limit and timer to 1
 724+ 533A                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 725+ 533A FD 36 03 FF      LD (IY+3),255
 726+ 533E FD 36 01 01      LD (IY+1),1
 727+ 5342 FD 36 02 00      LD (IY+2),0
 728+ 5346 DD E5            PUSH IX
 729+ 5348 E1               POP HL
 730+ 5349 C9               RET
 731+ 534A              ; *******************************************************************************************************
 732+ 534A
 733+ 534A              ; *******************************************************************************************************
 734+ 534A              ; function to handle CALL MAXAUTOSGAMS basic extension
 735+ 534A              ; MAXAUTOSGAMS (BYTE number)
 736+ 534A              ; sets new number and moves memory buffers as needed
 737+ 534A              MAXAUTOSGAMS:
 738+ 534A              	; opening (
 739+ 534A CD 13 67     	CALL CHKCHAR
 740+ 534D 28           	DB '('
 741+ 534E              	; get value
 742+ 534E DD 21 1C 52  	LD IX, GETBYT
 743+ 5352 CD 59 01     	CALL CALBAS
 744+ 5355 F5               PUSH AF
 745+ 5356              	; ending )
 746+ 5356 CD 13 67     	CALL CHKCHAR
 747+ 5359 29           	DB ')'
 748+ 535A F1               POP AF
 749+ 535B F3               DI
 750+ 535C              	; save position
 751+ 535C E5           	PUSH HL
 752+ 535D              .ENTRY:
 753+ 535D 47               LD B,A
 754+ 535E 3A 9D 4F         LD A,(AUTOSGAMNUM)
 755+ 5361 90               SUB B
 756+ 5362 CA 1C 50         JP Z, MAXANIMITEMS.EXIT; same value as before
 757+ 5365 FD 21 10 40      LD IY,FREEMEMPTR
 758+ 5369 FA 75 53         JP M, .INCREASE
 759+ 536C                  ; new value is lower than previous one
 760+ 536C CD 96 53         CALL .SIZEDIFF
 761+ 536F CD 59 50         CALL MAXANIMITEMS.DECREASE_COMMON
 762+ 5372 C3 1C 50         JP MAXANIMITEMS.EXIT
 763+ 5375              .INCREASE:
 764+ 5375 ED 44            NEG
 765+ 5377 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 766+ 5378 CD 96 53         CALL .SIZEDIFF
 767+ 537B CD 85 50         CALL MAXANIMITEMS.INCREASE_COMMON
 768+ 537E AF               XOR A
 769+ 537F ED 42            SBC HL,BC ; location of new stuff
 770+ 5381 F1               POP AF
 771+ 5382 C5               PUSH BC
 772+ 5383 47               LD B,A
 773+ 5384 11 18 00         LD DE,24
 774+ 5387 E5               PUSH HL
 775+ 5388 DD E1            POP IX
 776+ 538A              .L1:
 777+ 538A DD 36 13 00      LD (IX+19),0 ; active flag
 778+ 538E DD 19            ADD IX,DE
 779+ 5390 10 F8            DJNZ .L1
 780+ 5392 C1               POP BC
 781+ 5393 C3 1C 50         JP MAXANIMITEMS.EXIT
 782+ 5396              .SIZEDIFF:
 783+ 5396 26 00            LD H,0
 784+ 5398 6F               LD L,A
 785+ 5399 CD 01 66         CALL HLx8
 786+ 539C 54               LD D,H
 787+ 539D 5D               LD E,L
 788+ 539E 29               ADD HL,HL
 789+ 539F 19               ADD HL,DE
 790+ 53A0 78               LD A,B
 791+ 53A1 32 9D 4F         LD (AUTOSGAMNUM),A
 792+ 53A4 44               LD B,H
 793+ 53A5 4D               LD C,L
 794+ 53A6 C9               RET ; BC=size difference in bytes
 795+ 53A7              ; *******************************************************************************************************
 796+ 53A7
 797+ 53A7              ; *******************************************************************************************************
 798+ 53A7              ; function to handle CALL AUTOSGAMDEF basic extension
 799+ 53A7              ; AUTOSGAMDEF ( BYTE id,
 800+ 53A7              ;               INT VARIABLE x, INT VARIABLE y,
 801+ 53A7              ;               INT minimum, INT maximum, INT delta,
 802+ 53A7              ;               INT direction =0 horizontal,
 803+ 53A7              ;               INT ticks,
 804+ 53A7              ;               BYTE sprite_group_count,
 805+ 53A7              ;               INT[2][sprite_group_count] VARIABLE sprite_group,
 806+ 53A7              ;               BYTE item_number,
 807+ 53A7              ;               INT[] VARIABLE sprite_animations_negative_direction,
 808+ 53A7              ;               INT[] VARIABLE sprite_animations_positive_direction
 809+ 53A7              AUTOSGAMDEF:
 810+ 53A7                  ; opening (
 811+ 53A7 CD 13 67     	CALL CHKCHAR
 812+ 53AA 28           	DB '('
 813+ 53AB              	; get sprite animation id
 814+ 53AB DD 21 1C 52  	LD IX, GETBYT
 815+ 53AF CD 59 01     	CALL CALBAS
 816+ 53B2 F5               PUSH AF
 817+ 53B3 3C               INC A
 818+ 53B4 4F               LD C,A
 819+ 53B5 3A 9D 4F         LD A,(AUTOSGAMNUM)
 820+ 53B8 B9               CP C
 821+ 53B9 DA 2B 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 822+ 53BC F1               POP AF
 823+ 53BD E5               PUSH HL
 824+ 53BE CD CA 4F         CALL GETnthAUTOSGAM
 825+ 53C1 22 0A 64         LD (BLIT_TMP),HL ; for later
 826+ 53C4 E1               POP HL
 827+ 53C5              	; comma
 828+ 53C5 CD 13 67     	CALL CHKCHAR
 829+ 53C8 2C           	DB ','
 830+ 53C9              	; get address of the X coordinate variable
 831+ 53C9 DD 21 A4 5E  	LD IX, PTRGET
 832+ 53CD CD 59 01     	CALL CALBAS
 833+ 53D0 DD 2A 0A 64  	LD IX,(BLIT_TMP)
 834+ 53D4 DD 73 00         LD (IX+0),E
 835+ 53D7 DD 72 01         LD (IX+1),D
 836+ 53DA              	; comma
 837+ 53DA CD 13 67     	CALL CHKCHAR
 838+ 53DD 2C           	DB ','
 839+ 53DE              	; get address of the Y coordinate variable
 840+ 53DE DD 21 A4 5E  	LD IX, PTRGET
 841+ 53E2 CD 59 01     	CALL CALBAS
 842+ 53E5 DD 2A 0A 64  	LD IX,(BLIT_TMP)
 843+ 53E9 DD 73 02         LD (IX+2),E
 844+ 53EC DD 72 03         LD (IX+3),D
 845+ 53EF              	; comma
 846+ 53EF CD 13 67     	CALL CHKCHAR
 847+ 53F2 2C           	DB ','
 848+ 53F3              	; get minimum value
 849+ 53F3 DD 21 2F 54  	LD IX, FRMQNT
 850+ 53F7 CD 59 01     	CALL CALBAS
 851+ 53FA DD 2A 0A 64  	LD IX,(BLIT_TMP)
 852+ 53FE DD 73 04         LD (IX+4),E
 853+ 5401 DD 72 05         LD (IX+5),D
 854+ 5404              	; comma
 855+ 5404 CD 13 67     	CALL CHKCHAR
 856+ 5407 2C           	DB ','
 857+ 5408              	; get maximum value
 858+ 5408 DD 21 2F 54  	LD IX, FRMQNT
 859+ 540C CD 59 01     	CALL CALBAS
 860+ 540F DD 2A 0A 64  	LD IX,(BLIT_TMP)
 861+ 5413 DD 73 06         LD (IX+6),E
 862+ 5416 DD 72 07         LD (IX+7),D
 863+ 5419              	; comma
 864+ 5419 CD 13 67     	CALL CHKCHAR
 865+ 541C 2C           	DB ','
 866+ 541D              	; get delta value
 867+ 541D DD 21 2F 54  	LD IX, FRMQNT
 868+ 5421 CD 59 01     	CALL CALBAS
 869+ 5424 DD 2A 0A 64  	LD IX,(BLIT_TMP)
 870+ 5428 DD 73 08         LD (IX+8),E
 871+ 542B DD 72 09         LD (IX+9),D
 872+ 542E              	; comma
 873+ 542E CD 13 67     	CALL CHKCHAR
 874+ 5431 2C           	DB ','
 875+ 5432              	; get direction value
 876+ 5432 DD 21 2F 54  	LD IX, FRMQNT
 877+ 5436 CD 59 01     	CALL CALBAS
 878+ 5439 DD 2A 0A 64  	LD IX,(BLIT_TMP)
 879+ 543D DD 73 0A         LD (IX+10),E
 880+ 5440 DD 72 0B         LD (IX+11),D
 881+ 5443              	; comma
 882+ 5443 CD 13 67     	CALL CHKCHAR
 883+ 5446 2C           	DB ','
 884+ 5447              	; get ticks value
 885+ 5447 DD 21 2F 54  	LD IX, FRMQNT
 886+ 544B CD 59 01     	CALL CALBAS
 887+ 544E DD 2A 0A 64  	LD IX,(BLIT_TMP)
 888+ 5452 DD 73 14         LD (IX+20),E
 889+ 5455 DD 72 15         LD (IX+21),D
 890+ 5458              	; comma
 891+ 5458 CD 13 67     	CALL CHKCHAR
 892+ 545B 2C           	DB ','
 893+ 545C              	; get sprite group count
 894+ 545C DD 21 1C 52  	LD IX, GETBYT
 895+ 5460 CD 59 01     	CALL CALBAS
 896+ 5463 B7               OR A
 897+ 5464 CA 2B 67         JP Z,SUBSCRIPT_OUT_OF_RANGE
 898+ 5467 DD 2A 0A 64  	LD IX,(BLIT_TMP)
 899+ 546B DD 77 0B         LD (IX+11),A
 900+ 546E              	; comma
 901+ 546E CD 13 67     	CALL CHKCHAR
 902+ 5471 2C           	DB ','
 903+ 5472              	; get sprite group definition array data pointer
 904+ 5472 DD 2A 0A 64  	LD IX,(BLIT_TMP)
 905+ 5476 DD 5E 0B         LD E,(IX+11)
 906+ 5479 16 03        	LD D,3
 907+ 547B 3E 02        	LD A,2
 908+ 547D 47           	LD B,A
 909+ 547E CD 40 67     	CALL GET_BASIC_ARRAY_DATA_POINTER
 910+ 5481 DD 2A 0A 64  	LD IX,(BLIT_TMP)
 911+ 5485 DD 71 0C     	LD (IX+12),C
 912+ 5488 DD 70 0D         LD (IX+13),B
 913+ 548B              	; comma
 914+ 548B CD 13 67     	CALL CHKCHAR
 915+ 548E 2C           	DB ','
 916+ 548F              	; get sprite animation array size
 917+ 548F DD 21 1C 52  	LD IX,GETBYT
 918+ 5493 CD 59 01     	CALL CALBAS
 919+ 5496 DD 2A 0A 64  	LD IX,(BLIT_TMP)
 920+ 549A DD 77 0E         LD (IX+14),A
 921+ 549D B7               OR A
 922+ 549E CA 2B 67         JP Z,SUBSCRIPT_OUT_OF_RANGE
 923+ 54A1              	; comma
 924+ 54A1 CD 13 67     	CALL CHKCHAR
 925+ 54A4 2C           	DB ','
 926+ 54A5                  ; get array pointer for negative direction
 927+ 54A5 DD 2A 0A 64  	LD IX,(BLIT_TMP)
 928+ 54A9 DD 56 0E         LD D,(IX+14)
 929+ 54AC 3E 02            LD A,2
 930+ 54AE 06 01            LD B,1
 931+ 54B0 CD 40 67         CALL GET_BASIC_ARRAY_DATA_POINTER
 932+ 54B3 DD 2A 0A 64  	LD IX,(BLIT_TMP)
 933+ 54B7 DD 71 0F         LD (IX+15),C
 934+ 54BA DD 70 10         LD (IX+16),B
 935+ 54BD              	; comma
 936+ 54BD CD 13 67     	CALL CHKCHAR
 937+ 54C0 2C           	DB ','
 938+ 54C1                  ; get array pointer for positive direction
 939+ 54C1 DD 2A 0A 64  	LD IX,(BLIT_TMP)
 940+ 54C5 DD 56 0E         LD D,(IX+14)
 941+ 54C8 3E 02            LD A,2
 942+ 54CA 06 01            LD B,1
 943+ 54CC CD 40 67         CALL GET_BASIC_ARRAY_DATA_POINTER
 944+ 54CF DD 2A 0A 64  	LD IX,(BLIT_TMP)
 945+ 54D3 DD 71 11         LD (IX+17),C
 946+ 54D6 DD 70 12         LD (IX+18),B
 947+ 54D9              	; ending )
 948+ 54D9 CD 13 67     	CALL CHKCHAR
 949+ 54DC 29           	DB ')'
 950+ 54DD C9               RET
 951+ 54DE              ; *******************************************************************************************************
 952+ 54DE
 953+ 54DE              ; *******************************************************************************************************
 954+ 54DE              ; function to handle CALL AUTOSGAMSTART basic extension
 955+ 54DE              ; AUTOSGAMSTART ( BYTE id )
 956+ 54DE              AUTOSGAMSTART:
 957+ 54DE 3E 01            LD A,1
 958+ 54E0              .COMMON:
 959+ 54E0 32 0C 55         LD (.SETVALUE+3),A
 960+ 54E3                  ; opening (
 961+ 54E3 CD 13 67     	CALL CHKCHAR
 962+ 54E6 28           	DB '('
 963+ 54E7              	; get sprite animation id
 964+ 54E7 DD 21 1C 52  	LD IX, GETBYT
 965+ 54EB CD 59 01     	CALL CALBAS
 966+ 54EE F5               PUSH AF
 967+ 54EF 3C               INC A
 968+ 54F0 4F               LD C,A
 969+ 54F1 3A 9D 4F         LD A,(AUTOSGAMNUM)
 970+ 54F4 B9               CP C
 971+ 54F5 DA 2B 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 972+ 54F8 F1               POP AF
 973+ 54F9 E5               PUSH HL
 974+ 54FA CD CA 4F         CALL GETnthAUTOSGAM
 975+ 54FD E5               PUSH HL
 976+ 54FE DD E1            POP IX
 977+ 5500 E1               POP HL
 978+ 5501 DD E5            PUSH IX
 979+ 5503              	; ending )
 980+ 5503 CD 13 67     	CALL CHKCHAR
 981+ 5506 29           	DB ')'
 982+ 5507
 983+ 5507                  ; so syntax is fine
 984+ 5507 DD E1            POP IX
 985+ 5509              .SETVALUE:
 986+ 5509 DD 36 13 01      LD (IX+19),1 ; active flag
 987+ 550D                  ; set initial timer
 988+ 550D DD 7E 14         LD A,(IX+20)
 989+ 5510 DD 77 16         LD (IX+22),A
 990+ 5513 DD 7E 15         LD A,(IX+21)
 991+ 5516 DD 77 17         LD (IX+23),A
 992+ 5519 C9               RET
 993+ 551A              ; *******************************************************************************************************
 994+ 551A
 995+ 551A              ; *******************************************************************************************************
 996+ 551A              ; function to handle CALL AUTOSGAMSTOP basic extension
 997+ 551A              ; AUTOSGAMSTOP ( BYTE id )
 998+ 551A              AUTOSGAMSTOP:
 999+ 551A AF               XOR A
1000+ 551B 18 C3            JR AUTOSGAMSTART.COMMON
1001+ 551D              ; *******************************************************************************************************
1002+ 551D
1003+ 551D               IF (BASIC_EXTENSION == 1)
1004+ 551D              ; *******************************************************************************************************
1005+ 551D              ; function to handle CALL ANIMSTEP basic extension
1006+ 551D              ; two forms
1007+ 551D              ; ANIMSTEP ( BYTE id )
1008+ 551D              ; or
1009+ 551D              ; ANIMSTEP ( BYTE item_number,
1010+ 551D              ;            INT[] sprite_animations )
1011+ 551D              ANIMSTEP:
1012+ 551D 11 9C 55         LD DE,ANIMSTARTSTOP_COMMON.STEP
1013+ 5520 18 08            JR ANIMSTARTSTOP_COMMON
1014+ 5522              ; *******************************************************************************************************
1015+ 5522              ; *******************************************************************************************************
1016+ 5522              ; function to handle CALL ANIMSTART basic extension
1017+ 5522              ; two forms
1018+ 5522              ; ANIMSTART ( BYTE id )
1019+ 5522              ; or
1020+ 5522              ; ANIMSTART ( BYTE item_number,
1021+ 5522              ;             INT[] sprite_animations )
1022+ 5522              ; sets active flag to 1
1023+ 5522              ANIMSTART:
1024+ 5522 11 8A 55         LD DE,ANIMSTARTSTOP_COMMON.START
1025+ 5525 18 03            JR ANIMSTARTSTOP_COMMON
1026+ 5527              ; *******************************************************************************************************
1027+ 5527              ; *******************************************************************************************************
1028+ 5527              ; function to handle CALL ANIMSTOP basic extension
1029+ 5527              ; two forms
1030+ 5527              ; ANIMSTOP ( BYTE id )
1031+ 5527              ; or
1032+ 5527              ; ANIMSTOP ( BYTE item_number,
1033+ 5527              ;            INT[] sprite_animations )
1034+ 5527              ; sets active flag to 0
1035+ 5527              ANIMSTOP:
1036+ 5527 11 97 55         LD DE,ANIMSTARTSTOP_COMMON.STOP
1037+ 552A              ; *******************************************************************************************************
1038+ 552A              ANIMSTARTSTOP_COMMON:
1039+ 552A ED 53 88 55      LD (ANIMSTARTSTOP_COMMON.FN+1),DE
1040+ 552E                  ; opening (
1041+ 552E CD 13 67     	CALL CHKCHAR
1042+ 5531 28           	DB '('
1043+ 5532              	; get sprite animation id or array size
1044+ 5532 DD 21 1C 52  	LD IX,GETBYT
1045+ 5536 CD 59 01     	CALL CALBAS
1046+ 5539 F5               PUSH AF
1047+ 553A                  ; check if comma present
1048+ 553A CD 1D 67         CALL GETPREVCHAR
1049+ 553D 23               INC HL
1050+ 553E FE 2C            CP ','
1051+ 5540 28 0E            JR Z,.L1
1052+ 5542 FE 29            CP ')'
1053+ 5544 C2 37 67         JP NZ,SYNTAX_ERROR
1054+ 5547                  ; ok so single argument variant
1055+ 5547 F1               POP AF
1056+ 5548 E5               PUSH HL
1057+ 5549 F3               DI
1058+ 554A CD 76 55         CALL .SETVALUE
1059+ 554D FB               EI
1060+ 554E E1               POP HL
1061+ 554F C9               RET
1062+ 5550              .L1:
1063+ 5550                  ; get array pointer
1064+ 5550 D1               POP DE
1065+ 5551 D5               PUSH DE
1066+ 5552 3E 02            LD A,2
1067+ 5554 06 01            LD B,1
1068+ 5556 CD 40 67         CALL GET_BASIC_ARRAY_DATA_POINTER
1069+ 5559 C5               PUSH BC
1070+ 555A              	; ending )
1071+ 555A CD 13 67     	CALL CHKCHAR
1072+ 555D 29           	DB ')'
1073+ 555E D1               POP DE ; array pointer
1074+ 555F C1               POP BC ; number of items
1075+ 5560 78               LD A,B
1076+ 5561 B7               OR A
1077+ 5562 CA 2B 67         JP Z,SUBSCRIPT_OUT_OF_RANGE
1078+ 5565 E5               PUSH HL
1079+ 5566 F3               DI
1080+ 5567              .L2:
1081+ 5567 C5               PUSH BC
1082+ 5568 1A               LD A,(DE)
1083+ 5569 13          > INC DE
1083+ 556A 13          > INC DE
1084+ 556B D5               PUSH DE
1085+ 556C CD 76 55         CALL .SETVALUE
1086+ 556F D1               POP DE
1087+ 5570 C1               POP BC
1088+ 5571 10 F4            DJNZ .L2
1089+ 5573 FB               EI
1090+ 5574 E1               POP HL
1091+ 5575 C9               RET
1092+ 5576
1093+ 5576              .SETVALUE:
1094+ 5576 47               LD B,A
1095+ 5577 3C               INC A
1096+ 5578 4F               LD C,A
1097+ 5579 3A 9A 4F         LD A,(ANIMSPRNUM)
1098+ 557C B9               CP C
1099+ 557D DA 2B 67         JP C,SUBSCRIPT_OUT_OF_RANGE
1100+ 5580 78               LD A,B
1101+ 5581 CD BE 4F         CALL GETnthSPRANIM
1102+ 5584 E5               PUSH HL
1103+ 5585 DD E1            POP IX
1104+ 5587              .FN:
1105+ 5587 C3 00 00         JP 0
1106+ 558A              .START:
1107+ 558A DD 36 06 01      LD (IX+6),1 ; active flag
1108+ 558E DD 36 03 00      LD (IX+3),0 ; current item
1109+ 5592 06 00            LD B,0 ; setup timer
1110+ 5594 C3 83 56         JP SETUP_ANIM_STEP
1111+ 5597              .STOP:
1112+ 5597 DD 36 06 00      LD (IX+6),0 ; active flag
1113+ 559B C9               RET
1114+ 559C              .STEP:
1115+ 559C 06 00            LD B,0
1116+ 559E C3 27 56         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1117+ 55A1              ; *******************************************************************************************************
1118+ 55A1               ENDIF
1119+ 55A1
1120+ 55A1               IF (DEFUSR_EXTENSION == 1)
1121+ 55A1              ; *******************************************************************************************************
1122+ 55A1              ; helper function to locate single animation and execute operation
1123+ 55A1              ; needs to have jump set to a correct function
1124+ 55A1              ; input A=animation item
1125+ 55A1              ANIM_SETVALUE:
1126+ 55A1 47               LD B,A
1127+ 55A2 3C               INC A
1128+ 55A3 4F               LD C,A
1129+ 55A4 3A 9A 4F         LD A,(ANIMSPRNUM)
1130+ 55A7 B9               CP C
1131+ 55A8 D8               RET C ; out of range, so do nothing
1132+ 55A9 78               LD A,B
1133+ 55AA CD BE 4F         CALL GETnthSPRANIM
1134+ 55AD E5               PUSH HL
1135+ 55AE DD E1            POP IX
1136+ 55B0              .FN:
1137+ 55B0 C3 00 00         JP 0
1138+ 55B3              ; *******************************************************************************************************
1139+ 55B3
1140+ 55B3              ; *******************************************************************************************************
1141+ 55B3              ; helper function to set values of multiple animations
1142+ 55B3              ; needs to have jump set to a correct function
1143+ 55B3              ; input B=number of animation item
1144+ 55B3              ; input DE=animation item array
1145+ 55B3              ANIM_LIST_SETVALUE:
1146+ 55B3 F3               DI
1147+ 55B4 C5               PUSH BC
1148+ 55B5 1A               LD A,(DE)
1149+ 55B6 13          > INC DE
1149+ 55B7 13          > INC DE
1150+ 55B8 D5               PUSH DE
1151+ 55B9 CD A1 55         CALL ANIM_SETVALUE
1152+ 55BC D1               POP DE
1153+ 55BD C1               POP BC
1154+ 55BE 10 F3            DJNZ ANIM_LIST_SETVALUE
1155+ 55C0 FB               EI
1156+ 55C1 C9               RET
1157+ 55C2              ; *******************************************************************************************************
1158+ 55C2
1159+ 55C2              ; *******************************************************************************************************
1160+ 55C2              ; function to handle single item ANIMSTEP in DEFUSR mode
1161+ 55C2              ; input IX=pointer to input array, real data from +2
1162+ 55C2              ; +2 = animation id
1163+ 55C2              ANIMSTEP_SINGLE_DEFUSR:
1164+ 55C2 21 CD 55         LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1165+ 55C5              .L1:
1166+ 55C5 22 B1 55         LD (ANIM_SETVALUE.FN+1),HL
1167+ 55C8 DD 7E 02         LD A,(IX+2)
1168+ 55CB 18 D4            JR ANIM_SETVALUE
1169+ 55CD              .STEP:
1170+ 55CD 06 00            LD B,0
1171+ 55CF C3 27 56         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1172+ 55D2              ; *******************************************************************************************************
1173+ 55D2
1174+ 55D2              ; *******************************************************************************************************
1175+ 55D2              ; function to handle multi item ANIMSTEP in DEFUSR mode
1176+ 55D2              ; input IX=pointer to input array, real data from +2
1177+ 55D2              ; +2 = list size
1178+ 55D2              ; +4 = array pointer holding items
1179+ 55D2              ANIMSTEP_MULTI_DEFUSR:
1180+ 55D2 21 CD 55         LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1181+ 55D5              .L1:
1182+ 55D5 22 B1 55         LD (ANIM_SETVALUE.FN+1),HL
1183+ 55D8 DD 46 02         LD B,(IX+2)
1184+ 55DB DD 5E 04         LD E,(IX+4)
1185+ 55DE DD 56 05         LD D,(IX+5)
1186+ 55E1 18 D0            JR ANIM_LIST_SETVALUE
1187+ 55E3              ; *******************************************************************************************************
1188+ 55E3
1189+ 55E3              ; *******************************************************************************************************
1190+ 55E3              ; function to handle single item ANIMSTART in DEFUSR mode
1191+ 55E3              ; input IX=pointer to input array, real data from +2
1192+ 55E3              ; +2 = animation id
1193+ 55E3              ANIMSTART_SINGLE_DEFUSR:
1194+ 55E3 21 E8 55         LD HL,ANIMSTART_SINGLE_DEFUSR.START
1195+ 55E6 18 DD            JR ANIMSTEP_SINGLE_DEFUSR.L1
1196+ 55E8              .START:
1197+ 55E8 DD 36 06 01      LD (IX+6),1 ; active flag
1198+ 55EC DD 36 03 00      LD (IX+3),0 ; current item
1199+ 55F0 06 00            LD B,0 ; setup timer
1200+ 55F2 C3 83 56         JP SETUP_ANIM_STEP
1201+ 55F5              ; *******************************************************************************************************
1202+ 55F5
1203+ 55F5              ; *******************************************************************************************************
1204+ 55F5              ; function to handle multi item ANIMSTART in DEFUSR mode
1205+ 55F5              ; input IX=pointer to input array, real data from +2
1206+ 55F5              ; +2 = list size
1207+ 55F5              ; +4 = array pointer holding items
1208+ 55F5              ANIMSTART_MULTI_DEFUSR:
1209+ 55F5 21 E8 55         LD HL,ANIMSTART_SINGLE_DEFUSR.START
1210+ 55F8 18 DB            JR ANIMSTEP_MULTI_DEFUSR.L1
1211+ 55FA              ; *******************************************************************************************************
1212+ 55FA
1213+ 55FA              ; *******************************************************************************************************
1214+ 55FA              ; function to handle single item ANIMSTOP in DEFUSR mode
1215+ 55FA              ; input IX=pointer to input array, real data from +2
1216+ 55FA              ; +2 = animation id
1217+ 55FA              ANIMSTOP_SINGLE_DEFUSR:
1218+ 55FA 21 FF 55         LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1219+ 55FD 18 C6            JR ANIMSTEP_SINGLE_DEFUSR.L1
1220+ 55FF              .STOP:
1221+ 55FF DD 36 06 00      LD (IX+6),0 ; active flag
1222+ 5603 C9               RET
1223+ 5604              ; *******************************************************************************************************
1224+ 5604
1225+ 5604              ; *******************************************************************************************************
1226+ 5604              ; function to handle multi item ANIMSTOP in DEFUSR mode
1227+ 5604              ; input IX=pointer to input array, real data from +2
1228+ 5604              ; +2 = list size
1229+ 5604              ; +4 = array pointer holding items
1230+ 5604              ANIMSTOP_MULTI_DEFUSR:
1231+ 5604 21 FF 55         LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1232+ 5607 18 CC            JR ANIMSTEP_MULTI_DEFUSR.L1
1233+ 5609              ; *******************************************************************************************************
1234+ 5609               ENDIF
1235+ 5609
1236+ 5609              ; *******************************************************************************************************
1237+ 5609              ; function processes animations during vblank period
1238+ 5609              PROCESS_ANIMATIONS:
1239+ 5609 3A 9A 4F         LD A,(ANIMSPRNUM)
1240+ 560C B7               OR A
1241+ 560D C8               RET Z; no animations defined
1242+ 560E 47               LD B,A
1243+ 560F DD 2A 9B 4F      LD IX,(ANIMSPRPTR)
1244+ 5613              .L1:
1245+ 5613 C5               PUSH BC
1246+ 5614 06 00            LD B,0 ; normal mode, change on timer expiry only
1247+ 5616 CD 22 56         CALL PROCESS_SINGLE_ANIMATION
1248+ 5619 11 08 00         LD DE,8
1249+ 561C DD 19            ADD IX,DE
1250+ 561E C1               POP BC
1251+ 561F 10 F2            DJNZ .L1
1252+ 5621 C9               RET
1253+ 5622              ; *******************************************************************************************************
1254+ 5622
1255+ 5622              ; *******************************************************************************************************
1256+ 5622              ; processes single sprite animation
1257+ 5622              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
1258+ 5622              ; on timer expiry goes to next animation item
1259+ 5622              ; input IX=sprite animation pointer
1260+ 5622              ; input B=1 force mode, activate animation action regardless of expired timer
1261+ 5622              PROCESS_SINGLE_ANIMATION:
1262+ 5622 DD 7E 06         LD A,(IX+6); active
1263+ 5625 B7               OR A
1264+ 5626 C8               RET Z ; inactive animation
1265+ 5627              .INACTIVE_TOO:
1266+ 5627 DD 6E 01         LD L,(IX+1)
1267+ 562A DD 66 02         LD H,(IX+2) ; HL=end time
1268+ 562D 2B               DEC HL
1269+ 562E DD 75 01         LD (IX+1),L
1270+ 5631 DD 74 02         LD (IX+2),H
1271+ 5634 7D               LD A,L
1272+ 5635 B4               OR H
1273+ 5636 28 06            JR Z,.STEP
1274+ 5638 05               DEC B
1275+ 5639 04               INC B
1276+ 563A C8               RET Z ; not forced mode, return
1277+ 563B C3 83 56         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
1278+ 563E              .STEP:
1279+ 563E 06 00            LD B,0; setup timer
1280+ 5640 DD 34 03         INC (IX+3) ; current animation item
1281+ 5643 C3 83 56         JP SETUP_ANIM_STEP
1282+ 5646              ; *******************************************************************************************************
1283+ 5646
1284+ 5646              ; *******************************************************************************************************
1285+ 5646              ; function will setup sprite animation after current item change
1286+ 5646              ; input A=current animation definition
1287+ 5646              ; input IX=pointer to sprite animation
1288+ 5646              ; input B=1 skip timer setup
1289+ 5646              ; output IY=pointer to animation item
1290+ 5646              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
1291+ 5646              ; basically sets new end time for current animation
1292+ 5646              INIT_CURRENT_ANIMATION:
1293+ 5646 CD B2 4F         CALL GETnthANIMDEF
1294+ 5649 DD 7E 03         LD A,(IX+3) ; current animation item
1295+ 564C BE               CP (HL) ; number of animation items in the animation definition
1296+ 564D 38 0A            JR C,.L3 ; last item not reached
1297+ 564F                  ; last item reached
1298+ 564F DD 7E 05         LD A,(IX+5) ; cyclic flag
1299+ 5652 B7               OR A
1300+ 5653 28 2C            JR Z,.ERROR ; non-cyclic animation
1301+ 5655                  ; cyclic animation, restart
1302+ 5655 DD 36 03 00      LD (IX+3),0; current item
1303+ 5659              .L3:
1304+ 5659                  ; HL = animation definition
1305+ 5659 23               INC HL ; skip animation definition size field
1306+ 565A 16 00            LD D,0
1307+ 565C DD 5E 03         LD E,(IX+3); current item
1308+ 565F 19               ADD HL,DE
1309+ 5660 4E               LD C,(HL) ; current animation item
1310+ 5661 0C               INC C
1311+ 5662 3A 94 4F         LD A,(ANIMITEMNUM)
1312+ 5665 B9               CP C
1313+ 5666 38 19            JR C,.ERROR ; invalid animation item, stop animation
1314+ 5668 0D               DEC C
1315+ 5669 79               LD A,C
1316+ 566A CD A9 4F         CALL GETnthANIMITEM
1317+ 566D E5               PUSH HL
1318+ 566E FD E1            POP IY ; IY=animation item
1319+ 5670 05               DEC B
1320+ 5671 28 0C            JR Z,.EXIT
1321+ 5673 FD 5E 01         LD E,(IY+1)
1322+ 5676 FD 56 02         LD D,(IY+2) ; duration
1323+ 5679 DD 73 01         LD (IX+1),E
1324+ 567C DD 72 02         LD (IX+2),D
1325+ 567F              .EXIT:
1326+ 567F AF               XOR A
1327+ 5680 C9               RET
1328+ 5681              .ERROR:
1329+ 5681 37               SCF
1330+ 5682 C9               RET
1331+ 5683              ; *******************************************************************************************************
1332+ 5683
1333+ 5683              ; *******************************************************************************************************
1334+ 5683              ; function will display currect item and set up expiry time
1335+ 5683              ; it will also stop the animation if expired
1336+ 5683              ; sets sprite update flag if any changes in sprite data made
1337+ 5683              ; input IX=current sprite animation
1338+ 5683              ; input B=1 skip timer setup
1339+ 5683              SETUP_ANIM_STEP:
1340+ 5683 DD 4E 04         LD C,(IX+4) ; animation definition ID
1341+ 5686 0C               INC C
1342+ 5687 3A 97 4F         LD A,(ANIMDEFNUM)
1343+ 568A B9               CP C
1344+ 568B 30 05            JR NC,.L2
1345+ 568D                  ; given animation item is outside of bounds, deactivate animation
1346+ 568D              .STOPANIM:
1347+ 568D DD 36 06 00      LD (IX+6),0
1348+ 5691 C9               RET
1349+ 5692              .L2:
1350+ 5692 0D               DEC C
1351+ 5693 79               LD A,C
1352+ 5694 CD 46 56         CALL INIT_CURRENT_ANIMATION
1353+ 5697 38 F4            JR C, .STOPANIM
1354+ 5699 FD 7E 00         LD A,(IY) ; type of animation item
1355+ 569C B7               OR A
1356+ 569D 28 44            JR Z,.L4 ; change pattern and/or color
1357+ 569F              .PAT:
1358+ 569F                  ; change pattern definition
1359+ 569F                  ; check if sprite or character
1360+ 569F DD 7E 07         LD A,(IX+7)
1361+ 56A2 B7               OR A
1362+ 56A3 20 58            JR NZ,.CHAR
1363+ 56A5 DD 7E 00         LD A,(IX) ; sprite number
1364+ 56A8 CD 89 4D         CALL GETnthSPRATTR
1365+ 56AB 23          > INC HL ; skip y and x
1365+ 56AC 23          > INC HL
1365+ 56AD 23          > INC HL
1365+ 56AE 23          > INC HL
1366+ 56AF 7E               LD A,(HL); current pattern
1367+ 56B0 26 00            LD H,0
1368+ 56B2 6F               LD L,A
1369+ 56B3 3A E0 F3         LD A,(REG1SAV)
1370+ 56B6 E6 02            AND 2
1371+ 56B8 20 07            JR NZ,.L6
1372+ 56BA                  ; 8x8 sprite
1373+ 56BA CD 01 66         CALL HLx8
1374+ 56BD 06 08            LD B,8
1375+ 56BF 18 05            JR .L5
1376+ 56C1              .L6:
1377+ 56C1 CD FF 65         CALL HLx32
1378+ 56C4 06 20            LD B,32
1379+ 56C6              .L5:
1380+ 56C6 3A AF FC         LD A,(SCRMOD)
1381+ 56C9 3D               DEC A
1382+ 56CA 20 06            JR NZ,.L10
1383+ 56CC ED 5B C5 F3      LD DE,(T32PAT)
1384+ 56D0 18 04            JR .L7
1385+ 56D2              .L10:
1386+ 56D2 ED 5B CF F3      LD DE,(GRPPAT)
1387+ 56D6              .L7:
1388+ 56D6 19               ADD HL,DE
1389+ 56D7 CD EC 65         CALL SETWRT_LOCAL
1390+ 56DA FD 6E 03         LD L,(IY+3)
1391+ 56DD FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
1392+ 56E0 C3 F7 65         JP BBYTECOPY
1393+ 56E3              .L4:
1394+ 56E3                  ; change pattern and color in sprite attributes table
1395+ 56E3 DD 7E 00         LD A,(IX) ; sprite number
1396+ 56E6 CD 89 4D         CALL GETnthSPRATTR
1397+ 56E9 23          > INC HL ; skip y and x
1397+ 56EA 23          > INC HL
1397+ 56EB 23          > INC HL
1397+ 56EC 23          > INC HL
1398+ 56ED FD 7E 03         LD A,(IY+3) ; new pattern
1399+ 56F0 77               LD (HL),A
1400+ 56F1 23          > INC HL
1400+ 56F2 23          > INC HL
1401+ 56F3 FD 7E 04         LD A,(IY+4) ; new color
1402+ 56F6 77               LD (HL),A
1403+ 56F7 2A 80 4D         LD HL,(SPRATR_UPDATE_FLAG)
1404+ 56FA 36 01            LD (HL),1
1405+ 56FC C9               RET
1406+ 56FD              .CHAR:
1407+ 56FD DD 6E 00         LD L,(IX)
1408+ 5700 3D               DEC A
1409+ 5701 67               LD H,A
1410+ 5702 CD 01 66         CALL HLx8
1411+ 5705 3A AF FC         LD A,(SCRMOD)
1412+ 5708 3D               DEC A
1413+ 5709 20 06            JR NZ,.L8
1414+ 570B ED 5B C1 F3      LD DE,(T32CGP)
1415+ 570F 18 04            JR .L9
1416+ 5711              .L8:
1417+ 5711 ED 5B CB F3      LD DE,(GRPCGP)
1418+ 5715              .L9:
1419+ 5715 06 08            LD B,8
1420+ 5717 18 BD            JR .L7
1421+ 5719              ; *******************************************************************************************************
1422+ 5719
# file closed: asm\ANIMATION.asm
 134  5719               INCLUDE "SGAM.asm"
# file opened: asm\SGAM.asm
   1+ 5719              ; Sprite Group Animate and Move
   2+ 5719
   3+ 5719              ; *******************************************************************************************************
   4+ 5719              ; shared function to process a list of animations
   5+ 5719              ; input B=list size
   6+ 5719              ; input DE=list pointer
   7+ 5719              SGAM_PROCESS_ANIM_LIST:
   8+ 5719 21 2C 57         LD HL,.STEP
   9+ 571C 22 88 55         LD (ANIMSTARTSTOP_COMMON.FN+1),HL
  10+ 571F              .L1:
  11+ 571F C5               PUSH BC
  12+ 5720 1A               LD A,(DE)
  13+ 5721 13          > INC DE
  13+ 5722 13          > INC DE
  14+ 5723 D5               PUSH DE
  15+ 5724 CD 76 55         CALL ANIMSTARTSTOP_COMMON.SETVALUE
  16+ 5727 D1               POP DE
  17+ 5728 C1               POP BC
  18+ 5729 10 F4            DJNZ .L1
  19+ 572B C9           	RET
  20+ 572C              .STEP:
  21+ 572C 06 01            LD B,1
  22+ 572E C3 27 56         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
  23+ 5731              ; *******************************************************************************************************
  24+ 5731
  25+ 5731               IF (BASIC_EXTENSION == 1)
  26+ 5731              ; *******************************************************************************************************
  27+ 5731              ; function to handle CALL SGAM basic extension
  28+ 5731              ; sets position of a group of sprites as described in SPRGRPMOV
  29+ 5731              ; and manually animate a list of animations
  30+ 5731              ; _SGAM ( INT x,
  31+ 5731              ;	      INT y,
  32+ 5731              ;		  BYTE count,
  33+ 5731              ;		  INT[2][count] data_ptr,
  34+ 5731              ;         BYTE item_number,
  35+ 5731              ;         INT[] sprite_animations )
  36+ 5731              ; will put ram in page 0 also, page 1 is already there
  37+ 5731              SGAM:
  38+ 5731 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
  39+ 5734 B7           	OR A
  40+ 5735 CA 33 67     	JP Z,ILLEGAL_FUNCTION
  41+ 5738              	; opening (
  42+ 5738 CD 13 67     	CALL CHKCHAR
  43+ 573B 28           	DB '('
  44+ 573C              	; get x
  45+ 573C DD 21 2F 54  	LD IX, FRMQNT
  46+ 5740 CD 59 01     	CALL CALBAS
  47+ 5743 ED 53 0E 64  	LD (BLIT_STRUCT),DE
  48+ 5747              	; comma
  49+ 5747 CD 13 67     	CALL CHKCHAR
  50+ 574A 2C           	DB ','
  51+ 574B              	; get y
  52+ 574B DD 21 2F 54  	LD IX, FRMQNT
  53+ 574F CD 59 01     	CALL CALBAS
  54+ 5752 ED 53 10 64  	LD (BLIT_STRUCT+2),DE
  55+ 5756              	; comma
  56+ 5756 CD 13 67     	CALL CHKCHAR
  57+ 5759 2C           	DB ','
  58+ 575A              	; get count
  59+ 575A DD 21 1C 52  	LD IX, GETBYT
  60+ 575E CD 59 01     	CALL CALBAS
  61+ 5761 B7               OR A
  62+ 5762 CA 2B 67         JP Z,SUBSCRIPT_OUT_OF_RANGE
  63+ 5765 32 12 64     	LD (BLIT_STRUCT+4),A
  64+ 5768              	; comma
  65+ 5768 CD 13 67     	CALL CHKCHAR
  66+ 576B 2C           	DB ','
  67+ 576C              	; get sprite group definition array data pointer
  68+ 576C 3A 12 64         LD A,(BLIT_STRUCT+4)
  69+ 576F 5F           	LD E,A
  70+ 5770 16 03        	LD D,3
  71+ 5772 3E 02        	LD A,2
  72+ 5774 47           	LD B,A
  73+ 5775 CD 40 67     	CALL GET_BASIC_ARRAY_DATA_POINTER
  74+ 5778 ED 43 13 64  	LD (BLIT_STRUCT+5),BC
  75+ 577C              	; comma
  76+ 577C CD 13 67     	CALL CHKCHAR
  77+ 577F 2C           	DB ','
  78+ 5780              	; get sprite animation array size
  79+ 5780 DD 21 1C 52  	LD IX,GETBYT
  80+ 5784 CD 59 01     	CALL CALBAS
  81+ 5787 32 15 64         LD (BLIT_STRUCT+7),A
  82+ 578A B7               OR A
  83+ 578B CA 2B 67         JP Z,SUBSCRIPT_OUT_OF_RANGE
  84+ 578E              	; comma
  85+ 578E CD 13 67     	CALL CHKCHAR
  86+ 5791 2C           	DB ','
  87+ 5792                  ; get array pointer
  88+ 5792 3A 15 64         LD A,(BLIT_STRUCT+7)
  89+ 5795 57               LD D,A
  90+ 5796 3E 02            LD A,2
  91+ 5798 06 01            LD B,1
  92+ 579A CD 40 67         CALL GET_BASIC_ARRAY_DATA_POINTER
  93+ 579D ED 43 16 64      LD (BLIT_STRUCT+8),BC
  94+ 57A1              	; ending )
  95+ 57A1 CD 13 67     	CALL CHKCHAR
  96+ 57A4 29           	DB ')'
  97+ 57A5              .ENTRY:
  98+ 57A5 E5               PUSH HL
  99+ 57A6 F3               DI
 100+ 57A7
 101+ 57A7              	; enable page 0
 102+ 57A7 FD 21 AE 57  	LD IY, .RET
 103+ 57AB C3 C5 66     	JP ENABLE_PAGE0
 104+ 57AE              .RET:
 105+ 57AE D9               EXX
 106+ 57AF ED 5B 0E 64      LD DE,(BLIT_STRUCT) ; initial x
 107+ 57B3 ED 4B 10 64      LD BC,(BLIT_STRUCT+2) ; initial y
 108+ 57B7 D9               EXX
 109+ 57B8 2A 13 64         LD HL,(BLIT_STRUCT+5) ; pointer to data
 110+ 57BB 3A 12 64         LD A,(BLIT_STRUCT+4) ; number of entries
 111+ 57BE 47               LD B,A
 112+ 57BF CD FD 4E         CALL SPR_UPDATE_LOC
 113+ 57C2
 114+ 57C2 3A 15 64         LD A,(BLIT_STRUCT+7) ; anim number
 115+ 57C5 47               LD B,A
 116+ 57C6 ED 5B 16 64      LD DE,(BLIT_STRUCT+8) ; anim list
 117+ 57CA CD 19 57     	CALL SGAM_PROCESS_ANIM_LIST
 118+ 57CD
 119+ 57CD D1               POP DE
 120+ 57CE C1               POP BC
 121+ 57CF CD 3C 66         CALL RESTORE_PAGE_INFO
 122+ 57D2 FB               EI
 123+ 57D3 E1               POP HL
 124+ 57D4 C9               RET
 125+ 57D5              ; *******************************************************************************************************
 126+ 57D5               ENDIF
 127+ 57D5
 128+ 57D5               IF (DEFUSR_EXTENSION == 1)
 129+ 57D5              ; *******************************************************************************************************
 130+ 57D5              ; same as SGAM but for DEFUSR approach
 131+ 57D5              ; input IX=pointer to input array, real data from +2
 132+ 57D5              ; +02 = X
 133+ 57D5              ; +04 = Y
 134+ 57D5              ; +06 = count
 135+ 57D5              ; +08 = data pointer
 136+ 57D5              ; +10 = anim number
 137+ 57D5              ; +12 = sprite animations
 138+ 57D5              SGAM_DEFUSR:
 139+ 57D5              	; enable page 0
 140+ 57D5 F3           	DI
 141+ 57D6 FD 21 DD 57  	LD IY, .RET
 142+ 57DA C3 C5 66     	JP ENABLE_PAGE0
 143+ 57DD              .RET:
 144+ 57DD FB           	EI
 145+ 57DE D9               EXX
 146+ 57DF DD 5E 02     	LD E,(IX+2)
 147+ 57E2 DD 56 03     	LD D,(IX+3) ; initial x
 148+ 57E5 DD 4E 04     	LD C,(IX+4)
 149+ 57E8 DD 46 05     	LD B,(IX+5) ; initial y
 150+ 57EB D9               EXX
 151+ 57EC DD 6E 08     	LD L,(IX+8)
 152+ 57EF DD 66 09     	LD H,(IX+9) ; pointer to data
 153+ 57F2 DD 46 06         LD B,(IX+6) ; count
 154+ 57F5 DD E5        	PUSH IX
 155+ 57F7 CD FD 4E         CALL SPR_UPDATE_LOC
 156+ 57FA DD E1        	POP IX
 157+ 57FC DD 46 0A         LD B,(IX+10) ; anim number
 158+ 57FF DD 5E 0C     	LD E,(IX+12)
 159+ 5802 DD 56 0D     	LD D,(IX+13)
 160+ 5805 CD 19 57     	CALL SGAM_PROCESS_ANIM_LIST
 161+ 5808
 162+ 5808 D1               POP DE
 163+ 5809 C1               POP BC
 164+ 580A C3 3C 66         JP RESTORE_PAGE_INFO
 165+ 580D              ; *******************************************************************************************************
 166+ 580D               ENDIF
 167+ 580D
 168+ 580D              ; *******************************************************************************************************
 169+ 580D              ; handles automatic move and animate sprite groups during interrupt
 170+ 580D              PROCESS_AUTOSGAMS:
 171+ 580D 3A 9D 4F     	LD A,(AUTOSGAMNUM)
 172+ 5810 B7           	OR A
 173+ 5811 C8           	RET Z
 174+ 5812 47           	LD B,A
 175+ 5813 DD 2A 9E 4F  	LD IX,(AUTOSGAMPTR)
 176+ 5817              .L1:
 177+ 5817 C5           	PUSH BC
 178+ 5818 DD 7E 13     	LD A,(IX+19) ; active flag
 179+ 581B B7           	OR A
 180+ 581C 28 28        	JR Z,.LOOPEND
 181+ 581E              	; active, check timer
 182+ 581E DD 6E 16     	LD L,(IX+22)
 183+ 5821 DD 66 17     	LD H,(IX+23) ; timer
 184+ 5824 2B           	DEC HL
 185+ 5825 7C           	LD A,H
 186+ 5826 B5           	OR L
 187+ 5827 28 08        	JR Z,.L2
 188+ 5829              	; not expired
 189+ 5829 DD 75 16     	LD (IX+22),L
 190+ 582C DD 74 17     	LD (IX+23),H
 191+ 582F 18 15        	JR .LOOPEND
 192+ 5831              .L2:
 193+ 5831              	; expired, process
 194+ 5831
 195+ 5831                  ; set initial timer
 196+ 5831 DD 7E 14         LD A,(IX+20)
 197+ 5834 DD 77 16         LD (IX+22),A
 198+ 5837 DD 7E 15         LD A,(IX+21)
 199+ 583A DD 77 17         LD (IX+23),A
 200+ 583D
 201+ 583D CD 4F 58     	CALL .MOVE
 202+ 5840 CD BA 58     	CALL .UPDATELOC
 203+ 5843 CD DF 58     	CALL .PROCESS_ANIM_LIST
 204+ 5846
 205+ 5846              .LOOPEND:
 206+ 5846 11 18 00     	LD DE,24
 207+ 5849 DD 19        	ADD IX,DE
 208+ 584B C1           	POP BC
 209+ 584C 10 C9        	DJNZ .L1
 210+ 584E C9           	RET
 211+ 584F
 212+ 584F              .MOVE:
 213+ 584F              	; process movement
 214+ 584F DD 7E 0A     	LD A,(IX+10) ; direction
 215+ 5852 B7           	OR A
 216+ 5853 28 08        	JR Z, .MOVE_L1
 217+ 5855              	; vertical
 218+ 5855 DD 6E 02     	LD L,(IX+2)
 219+ 5858 DD 66 03     	LD H,(IX+3) ; vertical variable pointer
 220+ 585B 18 06        	JR .MOVE_L2
 221+ 585D              .MOVE_L1:
 222+ 585D              	; horizontal
 223+ 585D DD 6E 00     	LD L,(IX+0)
 224+ 5860 DD 66 01     	LD H,(IX+1) ; horizontal variable pointer
 225+ 5863              .MOVE_L2:
 226+ 5863 E5           	PUSH HL
 227+ 5864 FD E1        	POP IY
 228+ 5866 FD 6E 00     	LD L,(IY+0)
 229+ 5869 FD 66 01     	LD H,(IY+1)
 230+ 586C DD 5E 08     	LD E,(IX+8)
 231+ 586F DD 56 09     	LD D,(IX+9) ; delta value
 232+ 5872 19           	ADD HL,DE
 233+ 5873 E5           	PUSH HL
 234+ 5874 DD 5E 04     	LD E,(IX+4)
 235+ 5877 DD 56 05     	LD D,(IX+5) ; minimum value
 236+ 587A A7           	AND A
 237+ 587B ED 52        	SBC HL,DE
 238+ 587D FA 97 58     	JP M,.MOVE_L3 ; below minimum
 239+ 5880 E1           	POP HL
 240+ 5881 E5           	PUSH HL
 241+ 5882 DD 5E 06     	LD E,(IX+6)
 242+ 5885 DD 56 07     	LD D,(IX+7) ; maximum value
 243+ 5888 EB           	EX DE,HL
 244+ 5889 A7           	AND A
 245+ 588A ED 52        	SBC HL,DE
 246+ 588C FA 9F 58     	JP M,.MOVE_L4 ; above maximum
 247+ 588F E1           	POP HL
 248+ 5890              	; within bounds
 249+ 5890              .MOVE_L5:
 250+ 5890 FD 75 00     	LD (IY+0),L
 251+ 5893 FD 74 01     	LD (IY+1),H
 252+ 5896 C9           	RET
 253+ 5897              .MOVE_L3:
 254+ 5897 E1           	POP HL
 255+ 5898 CD AB 58     	CALL .INVERSE_DELTA
 256+ 589B 6B           	LD L,E
 257+ 589C 62           	LD H,D
 258+ 589D 18 F1        	JR .MOVE_L5
 259+ 589F              .MOVE_L4:
 260+ 589F E1           	POP HL
 261+ 58A0 CD AB 58     	CALL .INVERSE_DELTA
 262+ 58A3 DD 6E 06     	LD L,(IX+6)
 263+ 58A6 DD 66 07     	LD H,(IX+7) ; maximum
 264+ 58A9 18 E5        	JR .MOVE_L5
 265+ 58AB              .INVERSE_DELTA:
 266+ 58AB AF           	XOR A
 267+ 58AC DD 96 08     	SUB (IX+8)
 268+ 58AF DD 77 08     	LD (IX+8),A
 269+ 58B2 9F           	SBC A,A
 270+ 58B3 DD 96 09     	SUB (IX+9)
 271+ 58B6 DD 77 09     	LD (IX+9),A
 272+ 58B9 C9           	RET
 273+ 58BA
 274+ 58BA              .UPDATELOC:
 275+ 58BA DD E5        	PUSH IX
 276+ 58BC D9           	EXX
 277+ 58BD DD 6E 00     	LD L,(IX+0)
 278+ 58C0 DD 66 01     	LD H,(IX+1)
 279+ 58C3 5E           	LD E,(HL)
 280+ 58C4 23           	INC HL
 281+ 58C5 56           	LD D,(HL)
 282+ 58C6 DD 6E 02     	LD L,(IX+2)
 283+ 58C9 DD 66 03     	LD H,(IX+3)
 284+ 58CC 4E           	LD C,(HL)
 285+ 58CD 23           	INC HL
 286+ 58CE 46           	LD B,(HL)
 287+ 58CF D9           	EXX
 288+ 58D0 DD 6E 0C     	LD L,(IX+12)
 289+ 58D3 DD 66 0D     	LD H,(IX+13) ; pointer to sprite group data
 290+ 58D6 DD 46 0B     	LD B,(IX+11) ; sprite group size
 291+ 58D9 CD FD 4E     	CALL SPR_UPDATE_LOC
 292+ 58DC DD E1        	POP IX
 293+ 58DE C9           	RET
 294+ 58DF
 295+ 58DF              .PROCESS_ANIM_LIST:
 296+ 58DF DD E5        	PUSH IX
 297+ 58E1 DD 46 0E         LD B,(IX+14) ; anim list size
 298+ 58E4 DD CB 09 7E  	BIT 7,(IX+9)
 299+ 58E8 28 08        	JR Z,.PROCESS_ANIM_LIST_L1
 300+ 58EA              	; negative direction
 301+ 58EA DD 5E 0F     	LD E,(IX+15)
 302+ 58ED DD 56 10     	LD D,(IX+16)
 303+ 58F0 18 06        	JR .PROCESS_ANIM_LIST_L2
 304+ 58F2              .PROCESS_ANIM_LIST_L1:
 305+ 58F2              	; positive direction
 306+ 58F2 DD 5E 11     	LD E,(IX+17)
 307+ 58F5 DD 56 12     	LD D,(IX+18)
 308+ 58F8              .PROCESS_ANIM_LIST_L2:
 309+ 58F8 CD 19 57     	CALL SGAM_PROCESS_ANIM_LIST
 310+ 58FB DD E1        	POP IX
 311+ 58FD C9           	RET
 312+ 58FE              ; *******************************************************************************************************
 313+ 58FE
# file closed: asm\SGAM.asm
 135  58FE               ENDIF
 136  58FE
 137  58FE               IF (RAM_CMDS == 1)
 138  58FE               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
   1+ 58FE               IF (BASIC_EXTENSION == 1)
   2+ 58FE              ; *******************************************************************************************************
   3+ 58FE              ; function to handle CALL MEMCPY basic extension
   4+ 58FE              ; _MEMCPY ( INT source,
   5+ 58FE              ;			INT destination,
   6+ 58FE              ;			INT count,
   7+ 58FE              ; will put ram in page 0 also, page 1 is already there
   8+ 58FE              MEMCPY:
   9+ 58FE              	; opening (
  10+ 58FE CD 13 67     	CALL CHKCHAR
  11+ 5901 28           	DB '('
  12+ 5902              	; get source address
  13+ 5902 DD 21 2F 54  	LD IX, FRMQNT
  14+ 5906 CD 59 01     	CALL CALBAS
  15+ 5909 D5           	PUSH DE
  16+ 590A              	; comma
  17+ 590A CD 13 67     	CALL CHKCHAR
  18+ 590D 2C           	DB ','
  19+ 590E              	; get destination address
  20+ 590E DD 21 2F 54  	LD IX, FRMQNT
  21+ 5912 CD 59 01     	CALL CALBAS
  22+ 5915 D5           	PUSH DE
  23+ 5916              	; comma
  24+ 5916 CD 13 67     	CALL CHKCHAR
  25+ 5919 2C           	DB ','
  26+ 591A              	; get length
  27+ 591A DD 21 2F 54  	LD IX, FRMQNT
  28+ 591E CD 59 01     	CALL CALBAS
  29+ 5921 D5           	PUSH DE
  30+ 5922              	; ending )
  31+ 5922 CD 13 67     	CALL CHKCHAR
  32+ 5925 29           	DB ')'
  33+ 5926
  34+ 5926              	; save position
  35+ 5926 E5           	PUSH HL
  36+ 5927 DD E1        	POP IX
  37+ 5929
  38+ 5929 C1           	POP BC ; count
  39+ 592A D1           	POP DE ; destination
  40+ 592B E1           	POP HL ; source
  41+ 592C D9           	EXX
  42+ 592D              	; enable page 0
  43+ 592D F3           	DI
  44+ 592E FD 21 35 59  	LD IY, .RET
  45+ 5932 C3 C5 66     	JP ENABLE_PAGE0
  46+ 5935              .RET:
  47+ 5935 FB           	EI
  48+ 5936 D9           	EXX
  49+ 5937 ED B0        	LDIR
  50+ 5939 D1               POP DE
  51+ 593A C1               POP BC
  52+ 593B CD 3C 66         CALL RESTORE_PAGE_INFO
  53+ 593E DD E5        	PUSH IX
  54+ 5940 E1           	POP HL
  55+ 5941 C9           	RET
  56+ 5942              ; *******************************************************************************************************
  57+ 5942               ENDIF
  58+ 5942
  59+ 5942               IF (DEFUSR_EXTENSION == 1)
  60+ 5942              ; *******************************************************************************************************
  61+ 5942              ; same as MEMCPY but for DEFUSR approach
  62+ 5942              ; input IX=pointer to input array, real data from +2
  63+ 5942              ; +2 = source address
  64+ 5942              ; +4 = destination address
  65+ 5942              ; +6 = lenght
  66+ 5942              MEMCPY_DEFUSR:
  67+ 5942              	; enable page 0
  68+ 5942 F3           	DI
  69+ 5943 FD 21 4A 59  	LD IY, .RET
  70+ 5947 C3 C5 66     	JP ENABLE_PAGE0
  71+ 594A              .RET:
  72+ 594A FB           	EI
  73+ 594B DD 6E 02     	LD L,(IX+2)
  74+ 594E DD 66 03     	LD H,(IX+3)
  75+ 5951 DD 5E 04     	LD E,(IX+4)
  76+ 5954 DD 56 05     	LD D,(IX+5)
  77+ 5957 DD 4E 06     	LD C,(IX+6)
  78+ 595A DD 46 07     	LD B,(IX+7)
  79+ 595D ED B0        	LDIR
  80+ 595F D1               POP DE
  81+ 5960 C1               POP BC
  82+ 5961 C3 3C 66         JP RESTORE_PAGE_INFO
  83+ 5964              ; *******************************************************************************************************
  84+ 5964               ENDIF
  85+ 5964
  86+ 5964              ; *******************************************************************************************************
  87+ 5964              ; function to handle CALL FILRAM basic extension
  88+ 5964              ; FILRAM ( INT start address,
  89+ 5964              ;		   INT count,
  90+ 5964              ;		   BYTE value )
  91+ 5964              ; will put ram in page 0 also, page 1 is already there
  92+ 5964              FILRAM:
  93+ 5964              	; opening (
  94+ 5964 CD 13 67     	CALL CHKCHAR
  95+ 5967 28           	DB '('
  96+ 5968              	; get start address
  97+ 5968 DD 21 2F 54  	LD IX, FRMQNT
  98+ 596C CD 59 01     	CALL CALBAS
  99+ 596F D5           	PUSH DE
 100+ 5970              	; comma
 101+ 5970 CD 13 67     	CALL CHKCHAR
 102+ 5973 2C           	DB ','
 103+ 5974              	; get count
 104+ 5974 DD 21 2F 54  	LD IX, FRMQNT
 105+ 5978 CD 59 01     	CALL CALBAS
 106+ 597B D5           	PUSH DE
 107+ 597C              	; comma
 108+ 597C CD 13 67     	CALL CHKCHAR
 109+ 597F 2C           	DB ','
 110+ 5980              	; get value
 111+ 5980 DD 21 1C 52  	LD IX, GETBYT
 112+ 5984 CD 59 01     	CALL CALBAS
 113+ 5987 F5           	PUSH AF
 114+ 5988              	; ending )
 115+ 5988 CD 13 67     	CALL CHKCHAR
 116+ 598B 29           	DB ')'
 117+ 598C
 118+ 598C              	; save position
 119+ 598C E5           	PUSH HL
 120+ 598D DD E1        	POP IX
 121+ 598F
 122+ 598F D1           	POP DE ; actually AF
 123+ 5990 C1           	POP BC ; count
 124+ 5991 E1           	POP HL ; start address
 125+ 5992 78           	LD A, B
 126+ 5993 B7           	OR A
 127+ 5994 20 0A        	JR NZ, .L1 ; >=256 bytes to fill
 128+ 5996 B1           	OR C
 129+ 5997 28 1A        	JR Z, .EXIT ; 0 bytes to fill, skip
 130+ 5999 79           	LD A, C
 131+ 599A 3D           	DEC A
 132+ 599B 20 03        	JR NZ, .L1 ; ; >1 byte to fill
 133+ 599D              	; one byte to fill
 134+ 599D 72           	LD (HL), D
 135+ 599E 18 13        	JR .EXIT
 136+ 59A0              .L1:
 137+ 59A0 D9           	EXX
 138+ 59A1              	; enable page 0
 139+ 59A1 F3           	DI
 140+ 59A2 FD 21 A9 59  	LD IY, .RET
 141+ 59A6 C3 C5 66     	JP ENABLE_PAGE0
 142+ 59A9              .RET:
 143+ 59A9 FB           	EI
 144+ 59AA D9           	EXX
 145+ 59AB CD B7 59     	CALL .FILLVALUE
 146+ 59AE D1               POP DE
 147+ 59AF C1               POP BC
 148+ 59B0 CD 3C 66         CALL RESTORE_PAGE_INFO
 149+ 59B3              .EXIT:
 150+ 59B3 DD E5        	PUSH IX
 151+ 59B5 E1           	POP HL
 152+ 59B6 C9           	RET
 153+ 59B7
 154+ 59B7              .FILLVALUE:
 155+ 59B7 72               LD (HL), D
 156+ 59B8 54               LD D, H
 157+ 59B9 5D               LD E, L
 158+ 59BA 13               INC DE
 159+ 59BB 0B               DEC BC
 160+ 59BC ED B0            LDIR
 161+ 59BE C9               RET
 162+ 59BF              ; *******************************************************************************************************
 163+ 59BF
# file closed: asm\MEMORY.asm
 139  59BF               ENDIF
 140  59BF
 141  59BF               IF (SOUND_CMDS == 1)
 142  59BF               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
   1+ 59BF              MUSIC_INIT_STATUS:
   2+ 59BF 00            DB 0
   3+ 59C0              SFX_INIT_STATUS:
   4+ 59C0 00            DB 0
   5+ 59C1              SOUND_ENABLED:
   6+ 59C1 00            DB 0
   7+ 59C2
   8+ 59C2              ; *******************************************************************************************************
   9+ 59C2              ; function to handle CALL SNDPLYINIT basic extension
  10+ 59C2              ; initializes sound player
  11+ 59C2              ; _SNDPLYINIT ( INT music_offset,
  12+ 59C2              ;				INT sfx_offset, can be -1 if no SFX
  13+ 59C2              ; will put ram in page 0 also, page 1 is already there
  14+ 59C2              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
  15+ 59C2              SNDPLYINIT:
  16+ 59C2              	; opening (
  17+ 59C2 CD 13 67     	CALL CHKCHAR
  18+ 59C5 28           	DB '('
  19+ 59C6              	; get music address
  20+ 59C6 DD 21 2F 54  	LD IX, FRMQNT
  21+ 59CA CD 59 01     	CALL CALBAS
  22+ 59CD D5           	PUSH DE
  23+ 59CE              	; comma
  24+ 59CE CD 13 67     	CALL CHKCHAR
  25+ 59D1 2C           	DB ','
  26+ 59D2              	; get sfx address
  27+ 59D2 DD 21 2F 54  	LD IX, FRMQNT
  28+ 59D6 CD 59 01     	CALL CALBAS
  29+ 59D9 D5           	PUSH DE
  30+ 59DA              	; ending )
  31+ 59DA CD 13 67     	CALL CHKCHAR
  32+ 59DD 29           	DB ')'
  33+ 59DE
  34+ 59DE                  ; save position in BASIC text
  35+ 59DE 44           	LD B, H
  36+ 59DF 4D           	LD C, L
  37+ 59E0
  38+ 59E0              	; pop LDIR parameters and store away for later
  39+ 59E0 D1           	POP DE ; sfx address
  40+ 59E1 E1           	POP HL ; music address
  41+ 59E2 C5           	PUSH BC ; basic text location
  42+ 59E3 D9           	EXX
  43+ 59E4 FD 21 EB 59  	LD IY, .RET
  44+ 59E8 C3 C5 66     	JP ENABLE_PAGE0
  45+ 59EB              .RET:
  46+ 59EB D9           	EXX
  47+ 59EC
  48+ 59EC D5           	PUSH DE
  49+ 59ED AF           	XOR A
  50+ 59EE              	; HL = music location
  51+ 59EE CD 65 41     	CALL PLY_AKG_INIT
  52+ 59F1 3E 01        	LD A, 1
  53+ 59F3 32 BF 59     	LD (MUSIC_INIT_STATUS), A
  54+ 59F6
  55+ 59F6 E1           	POP HL ; SFX
  56+ 59F7              	; check if SFX address -1
  57+ 59F7 23           	INC HL
  58+ 59F8 7D           	LD A, L
  59+ 59F9 B4           	OR H
  60+ 59FA 28 09        	JR Z,.L1
  61+ 59FC 2B           	DEC HL
  62+ 59FD CD 20 40     	CALL PLY_AKG_INITSOUNDEFFECTS
  63+ 5A00 3E 01        	LD A, 1
  64+ 5A02 32 C0 59     	LD (SFX_INIT_STATUS), A
  65+ 5A05              .L1:
  66+ 5A05 D1               POP DE
  67+ 5A06 C1               POP BC
  68+ 5A07 CD 3C 66         CALL RESTORE_PAGE_INFO
  69+ 5A0A
  70+ 5A0A E1           	POP HL
  71+ 5A0B C9           	RET
  72+ 5A0C              ; *******************************************************************************************************
  73+ 5A0C
  74+ 5A0C              ; *******************************************************************************************************
  75+ 5A0C              ; function to handle CALL SNDPLYON basic extension
  76+ 5A0C              ; enables sound player
  77+ 5A0C              ; _SNDPLYON
  78+ 5A0C              ; sets SOUND_ENABLED variable to 1 if init call was done
  79+ 5A0C              ; if not throws out of data error
  80+ 5A0C              SNDPLYON:
  81+ 5A0C 3A BF 59     	LD A, (MUSIC_INIT_STATUS)
  82+ 5A0F B7           	OR A
  83+ 5A10 20 05        	JR NZ, .L1
  84+ 5A12              	; player not initialized, throw error
  85+ 5A12 1E 04        	LD E, 04 ; Out of DATA
  86+ 5A14 C3 39 67     	JP THROW_ERROR
  87+ 5A17              .L1:
  88+ 5A17 32 C1 59     	LD (SOUND_ENABLED), A
  89+ 5A1A              	; disable key click
  90+ 5A1A AF           	XOR A
  91+ 5A1B 32 DB F3     	LD (CLIKSW), A
  92+ 5A1E C9           	RET
  93+ 5A1F              ; *******************************************************************************************************
  94+ 5A1F
  95+ 5A1F              ; *******************************************************************************************************
  96+ 5A1F              ; function to handle CALL SNDPLYOFF basic extension
  97+ 5A1F              ; disables sound player
  98+ 5A1F              ; _SNDPLYOFF
  99+ 5A1F              ; sets SOUND_ENABLED variable to 0
 100+ 5A1F              ; calls AKG to stop music and SFX on all channels if initialized
 101+ 5A1F              SNDPLYOFF:
 102+ 5A1F 3A C1 59     	LD A, (SOUND_ENABLED)
 103+ 5A22 B7           	OR A
 104+ 5A23 C8           	RET Z ; already stopped
 105+ 5A24 AF           	XOR A
 106+ 5A25 32 C1 59     	LD (SOUND_ENABLED), A
 107+ 5A28 E5           	PUSH HL
 108+ 5A29 CD 24 42     	CALL PLY_AKG_STOP
 109+ 5A2C 3A C0 59     	LD A, (SFX_INIT_STATUS)
 110+ 5A2F B7           	OR A
 111+ 5A30 28 0E        	JR Z, .EXIT ; SFX not in use
 112+ 5A32 AF           	XOR A
 113+ 5A33 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 114+ 5A36 3E 01        	LD A, 1
 115+ 5A38 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 116+ 5A3B 3E 02        	LD A, 2
 117+ 5A3D CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 118+ 5A40              .EXIT:
 119+ 5A40 E1           	POP HL
 120+ 5A41 C9           	RET
 121+ 5A42              ; *******************************************************************************************************
 122+ 5A42
 123+ 5A42               IF (BASIC_EXTENSION == 1)
 124+ 5A42              ; *******************************************************************************************************
 125+ 5A42              ; function to handle CALL SNDSFX basic extension
 126+ 5A42              ; plays a sound effect
 127+ 5A42              ; _SNDSFX ( BYTE sfx_number, >0
 128+ 5A42              ;			BYTE channel, = 0,1 or 2
 129+ 5A42              ;			BYTE inverted_volume = 0-16, 0 being full volume
 130+ 5A42              ; will put ram in page 0 also, page 1 is already there
 131+ 5A42              ; if sound off throws illegal function call
 132+ 5A42              ; if sfx not initialized, throws out of data
 133+ 5A42              SNDSFX:
 134+ 5A42              	; opening (
 135+ 5A42 CD 13 67     	CALL CHKCHAR
 136+ 5A45 28           	DB '('
 137+ 5A46              	; get sfx_number
 138+ 5A46 DD 21 1C 52  	LD IX, GETBYT
 139+ 5A4A CD 59 01     	CALL CALBAS
 140+ 5A4D D5           	PUSH DE
 141+ 5A4E              	; comma
 142+ 5A4E CD 13 67     	CALL CHKCHAR
 143+ 5A51 2C           	DB ','
 144+ 5A52              	; get sfx address
 145+ 5A52 DD 21 1C 52  	LD IX, GETBYT
 146+ 5A56 CD 59 01     	CALL CALBAS
 147+ 5A59 D5           	PUSH DE
 148+ 5A5A              	; comma
 149+ 5A5A CD 13 67     	CALL CHKCHAR
 150+ 5A5D 2C           	DB ','
 151+ 5A5E              	; get inverted volume
 152+ 5A5E DD 21 1C 52  	LD IX, GETBYT
 153+ 5A62 CD 59 01     	CALL CALBAS
 154+ 5A65 D5           	PUSH DE
 155+ 5A66              	; ending )
 156+ 5A66 CD 13 67     	CALL CHKCHAR
 157+ 5A69 29           	DB ')'
 158+ 5A6A
 159+ 5A6A 3A C1 59     	LD A, (SOUND_ENABLED)
 160+ 5A6D B7           	OR A
 161+ 5A6E 20 05        	JR NZ, .L1
 162+ 5A70              	; sound disabled, throw illegal function call
 163+ 5A70 1E 05        	LD E, 5
 164+ 5A72 C3 39 67     	JP THROW_ERROR
 165+ 5A75              .L1:
 166+ 5A75 3A C0 59     	LD A, (SFX_INIT_STATUS)
 167+ 5A78 B7           	OR A
 168+ 5A79 20 05        	JR NZ, .L2
 169+ 5A7B              	; sfx data not initialized, throw out of data
 170+ 5A7B 1E 04        	LD E, 4
 171+ 5A7D C3 39 67     	JP THROW_ERROR
 172+ 5A80              .L2:
 173+ 5A80              	; pop  parameters and store away for later
 174+ 5A80 D1           	POP DE ; inverted volume
 175+ 5A81 43           	LD B, E
 176+ 5A82 D1           	POP DE ; channel
 177+ 5A83 4B           	LD C, E
 178+ 5A84 D1           	POP DE
 179+ 5A85 7B           	LD A, E
 180+ 5A86 08           	EX AF, AF'
 181+ 5A87 E5           	PUSH HL ; basic text location
 182+ 5A88 D9           	EXX
 183+ 5A89 FD 21 90 5A  	LD IY, .RET
 184+ 5A8D C3 C5 66     	JP ENABLE_PAGE0
 185+ 5A90              .RET:
 186+ 5A90 D9           	EXX
 187+ 5A91 08           	EX AF, AF'
 188+ 5A92 CD 24 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
 189+ 5A95
 190+ 5A95 D1               POP DE
 191+ 5A96 C1               POP BC
 192+ 5A97 CD 3C 66         CALL RESTORE_PAGE_INFO
 193+ 5A9A
 194+ 5A9A E1           	POP HL
 195+ 5A9B C9           	RET
 196+ 5A9C              ; *******************************************************************************************************
 197+ 5A9C               ENDIF
 198+ 5A9C
 199+ 5A9C               IF (DEFUSR_EXTENSION == 1)
 200+ 5A9C              ; *******************************************************************************************************
 201+ 5A9C              ; same as SNDSFX but for DEFUSR approach
 202+ 5A9C              ; input IX=pointer to input array, real data from +2
 203+ 5A9C              ; +2 = SFX number
 204+ 5A9C              ; +4 = channel
 205+ 5A9C              ; +6 = volume
 206+ 5A9C              SNDSFX_DEFUSR:
 207+ 5A9C 3A C1 59     	LD A, (SOUND_ENABLED)
 208+ 5A9F B7           	OR A
 209+ 5AA0 C8           	RET Z ; sound disabled, just exit
 210+ 5AA1 3A C0 59     	LD A, (SFX_INIT_STATUS)
 211+ 5AA4 B7           	OR A
 212+ 5AA5 C8           	RET Z ; sfx data not initialized, just exit
 213+ 5AA6 F3           	DI
 214+ 5AA7 FD 21 AE 5A  	LD IY, .RET
 215+ 5AAB C3 C5 66     	JP ENABLE_PAGE0
 216+ 5AAE              .RET:
 217+ 5AAE FB           	EI
 218+ 5AAF DD 7E 02     	LD A,(IX+2) ; SFX number
 219+ 5AB2 DD 4E 04     	LD C,(IX+4) ; channel
 220+ 5AB5 DD 46 06     	LD B,(IX+6) ; volume
 221+ 5AB8 CD 24 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
 222+ 5ABB D1               POP DE
 223+ 5ABC C1               POP BC
 224+ 5ABD C3 3C 66         JP RESTORE_PAGE_INFO
 225+ 5AC0              ; *******************************************************************************************************
 226+ 5AC0               ENDIF
# file closed: asm\SOUND.asm
 143  5AC0               ENDIF
 144  5AC0
 145  5AC0               IF (VRAM_CMDS == 1)
 146  5AC0               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
   1+ 5AC0              ; *******************************************************************************************************
   2+ 5AC0              ; function to handle CALL FILVRM basic extension
   3+ 5AC0              ; FILVRM ( INT offset,
   4+ 5AC0              ;		   INT count,
   5+ 5AC0              ;		   BYTE value,
   6+ 5AC0              ;		   BYTE wait_vsync) >0 = true
   7+ 5AC0              ; wait_vsync will issue HALT before copying
   8+ 5AC0              FILVRM:
   9+ 5AC0              	; opening (
  10+ 5AC0 CD 13 67     	CALL CHKCHAR
  11+ 5AC3 28           	DB '('
  12+ 5AC4              	; get offset address
  13+ 5AC4 DD 21 2F 54  	LD IX, FRMQNT
  14+ 5AC8 CD 59 01     	CALL CALBAS
  15+ 5ACB D5           	PUSH DE
  16+ 5ACC              	; comma
  17+ 5ACC CD 13 67     	CALL CHKCHAR
  18+ 5ACF 2C           	DB ','
  19+ 5AD0              	; get count
  20+ 5AD0 DD 21 2F 54  	LD IX, FRMQNT
  21+ 5AD4 CD 59 01     	CALL CALBAS
  22+ 5AD7 D5           	PUSH DE
  23+ 5AD8              	; comma
  24+ 5AD8 CD 13 67     	CALL CHKCHAR
  25+ 5ADB 2C           	DB ','
  26+ 5ADC              	; get value
  27+ 5ADC DD 21 1C 52  	LD IX, GETBYT
  28+ 5AE0 CD 59 01     	CALL CALBAS
  29+ 5AE3 F5           	PUSH AF
  30+ 5AE4              	; comma
  31+ 5AE4 CD 13 67     	CALL CHKCHAR
  32+ 5AE7 2C           	DB ','
  33+ 5AE8              	; get vsync wait
  34+ 5AE8 DD 21 1C 52  	LD IX, GETBYT
  35+ 5AEC CD 59 01     	CALL CALBAS
  36+ 5AEF F5           	PUSH AF
  37+ 5AF0              	; ending )
  38+ 5AF0 CD 13 67     	CALL CHKCHAR
  39+ 5AF3 29           	DB ')'
  40+ 5AF4
  41+ 5AF4              	; save position
  42+ 5AF4 E5           	PUSH HL
  43+ 5AF5 DD E1        	POP IX
  44+ 5AF7
  45+ 5AF7              	; syntax ok
  46+ 5AF7              	; wait for vsync if needed
  47+ 5AF7 F1           	POP AF
  48+ 5AF8 B7           	OR A
  49+ 5AF9 28 01        	JR Z, .L1
  50+ 5AFB 76           	HALT
  51+ 5AFC
  52+ 5AFC              .L1:
  53+ 5AFC 3E 01        	LD A,1
  54+ 5AFE 32 1F 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
  55+ 5B01 F1               POP AF ; value
  56+ 5B02 C1               POP BC ; count
  57+ 5B03 E1               POP HL ; offset
  58+ 5B04 CD 56 00         CALL BIOS_FILVRM
  59+ 5B07 AF           	XOR A
  60+ 5B08 32 1F 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
  61+ 5B0B
  62+ 5B0B              .L3:
  63+ 5B0B DD E5        	PUSH IX
  64+ 5B0D E1           	POP HL
  65+ 5B0E C9           	RET
  66+ 5B0F              ; *******************************************************************************************************
  67+ 5B0F
  68+ 5B0F               IF (BASIC_EXTENSION == 1)
  69+ 5B0F              ; *******************************************************************************************************
  70+ 5B0F              ; function to handle CALL MEMVRM basic extension
  71+ 5B0F              ; copies from RAM to VRAM
  72+ 5B0F              ; _MEMVRM ( INT source,
  73+ 5B0F              ;			INT destination,
  74+ 5B0F              ;			INT count,
  75+ 5B0F              ;			BYTE wait_vsync) >0 = true
  76+ 5B0F              ; will put ram in page 0 also, page 1 is already there
  77+ 5B0F              ; wait_vsync will issue HALT before copying
  78+ 5B0F              MEMVRM:
  79+ 5B0F              	; opening (
  80+ 5B0F CD 13 67     	CALL CHKCHAR
  81+ 5B12 28           	DB '('
  82+ 5B13              	; get source address
  83+ 5B13 DD 21 2F 54  	LD IX, FRMQNT
  84+ 5B17 CD 59 01     	CALL CALBAS
  85+ 5B1A D5           	PUSH DE
  86+ 5B1B              	; comma
  87+ 5B1B CD 13 67     	CALL CHKCHAR
  88+ 5B1E 2C           	DB ','
  89+ 5B1F              	; get destination address
  90+ 5B1F DD 21 2F 54  	LD IX, FRMQNT
  91+ 5B23 CD 59 01     	CALL CALBAS
  92+ 5B26 D5           	PUSH DE
  93+ 5B27              	; comma
  94+ 5B27 CD 13 67     	CALL CHKCHAR
  95+ 5B2A 2C           	DB ','
  96+ 5B2B              	; get length
  97+ 5B2B DD 21 2F 54  	LD IX, FRMQNT
  98+ 5B2F CD 59 01     	CALL CALBAS
  99+ 5B32 D5           	PUSH DE
 100+ 5B33              	; comma
 101+ 5B33 CD 13 67     	CALL CHKCHAR
 102+ 5B36 2C           	DB ','
 103+ 5B37              	; get vsync wait
 104+ 5B37 DD 21 1C 52  	LD IX, GETBYT
 105+ 5B3B CD 59 01     	CALL CALBAS
 106+ 5B3E F5           	PUSH AF
 107+ 5B3F              	; ending )
 108+ 5B3F CD 13 67     	CALL CHKCHAR
 109+ 5B42 29           	DB ')'
 110+ 5B43
 111+ 5B43                  ; save position in BASIC text
 112+ 5B43 E5           	PUSH HL
 113+ 5B44 DD E1        	POP IX
 114+ 5B46
 115+ 5B46 F1           	POP AF ; wait vsync
 116+ 5B47 B7           	OR A
 117+ 5B48 28 01        	JR Z, .L1
 118+ 5B4A 76           	HALT
 119+ 5B4B              .L1:
 120+ 5B4B F3           	DI
 121+ 5B4C              	; pop LDIR parameters and store away for later
 122+ 5B4C C1           	POP BC ; count
 123+ 5B4D D1           	POP DE ; vram destination
 124+ 5B4E E1           	POP HL ; ram source
 125+ 5B4F D9           	EXX
 126+ 5B50 FD 21 57 5B   	LD IY, .RET
 127+ 5B54 C3 C5 66     	JP ENABLE_PAGE0
 128+ 5B57              .RET:
 129+ 5B57 FB           	EI
 130+ 5B58 D9           	EXX
 131+ 5B59 CD 8F 5B     	CALL VRAM_LDIRVM
 132+ 5B5C D1               POP DE
 133+ 5B5D C1               POP BC
 134+ 5B5E CD 3C 66         CALL RESTORE_PAGE_INFO
 135+ 5B61 DD E5        	PUSH IX
 136+ 5B63 E1           	POP HL
 137+ 5B64 C9           	RET
 138+ 5B65              ; *******************************************************************************************************
 139+ 5B65               ENDIF
 140+ 5B65
 141+ 5B65               IF (DEFUSR_EXTENSION == 1)
 142+ 5B65              ; *******************************************************************************************************
 143+ 5B65              ; same as MEMVRM but for DEFUSR approach
 144+ 5B65              ; input IX=pointer to input array, real data from +2
 145+ 5B65              ; +2 = source address
 146+ 5B65              ; +4 = destination address
 147+ 5B65              ; +6 = lenght
 148+ 5B65              ; +8 = vsync wait flag
 149+ 5B65              MEMVRM_DEFUSR:
 150+ 5B65 DD 7E 08     	LD A,(IX+8)
 151+ 5B68 B7           	OR A
 152+ 5B69 28 01        	JR Z,.L0
 153+ 5B6B 76           	HALT
 154+ 5B6C              .L0:
 155+ 5B6C              	; enable page 0
 156+ 5B6C F3           	DI
 157+ 5B6D FD 21 74 5B  	LD IY, .RET
 158+ 5B71 C3 C5 66     	JP ENABLE_PAGE0
 159+ 5B74              .RET:
 160+ 5B74 FB           	EI
 161+ 5B75 DD 6E 02     	LD L,(IX+2)
 162+ 5B78 DD 66 03     	LD H,(IX+3)
 163+ 5B7B DD 5E 04     	LD E,(IX+4)
 164+ 5B7E DD 56 05     	LD D,(IX+5)
 165+ 5B81 DD 4E 06     	LD C,(IX+6)
 166+ 5B84 DD 46 07     	LD B,(IX+7)
 167+ 5B87 CD 8F 5B     	CALL VRAM_LDIRVM
 168+ 5B8A D1               POP DE
 169+ 5B8B C1               POP BC
 170+ 5B8C C3 3C 66         JP RESTORE_PAGE_INFO
 171+ 5B8F              ; *******************************************************************************************************
 172+ 5B8F               ENDIF
 173+ 5B8F
 174+ 5B8F               IF (BASIC_EXTENSION + DEFUSR_EXTENSION > 0)
 175+ 5B8F              ; *******************************************************************************************************
 176+ 5B8F              ; common code to copy from memory to VRAM
 177+ 5B8F              ; input HL=RAM source
 178+ 5B8F              ; input DE=VRAM destination
 179+ 5B8F              ; BC=count
 180+ 5B8F              VRAM_LDIRVM:
 181+ 5B8F 3E 01        	LD A,1
 182+ 5B91 32 1F 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 183+ 5B94 EB           	EX DE, HL
 184+ 5B95 F3           	DI
 185+ 5B96 CD EC 65     	CALL SETWRT_LOCAL
 186+ 5B99 FB           	EI
 187+ 5B9A EB           	EX DE, HL
 188+ 5B9B 78           	LD A, B
 189+ 5B9C B7           	OR A
 190+ 5B9D 28 0D        	JR Z, .L3
 191+ 5B9F C5           	PUSH BC
 192+ 5BA0 0E 98        	LD C, #98
 193+ 5BA2              .L2:
 194+ 5BA2 50           	LD D, B
 195+ 5BA3 06 00        	LD B, 0
 196+ 5BA5 CD F9 65     	CALL BBYTECOPY_NO_C
 197+ 5BA8 42           	LD B, D
 198+ 5BA9 10 F7        	DJNZ .L2
 199+ 5BAB C1           	POP BC
 200+ 5BAC              .L3:
 201+ 5BAC 79           	LD A, C
 202+ 5BAD B7           	OR A
 203+ 5BAE 28 04        	JR Z,.L4
 204+ 5BB0 41           	LD B, C
 205+ 5BB1 CD F7 65     	CALL BBYTECOPY
 206+ 5BB4              .L4:
 207+ 5BB4 AF           	XOR A
 208+ 5BB5 32 1F 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 209+ 5BB8 C9           	RET
 210+ 5BB9              ; *******************************************************************************************************
 211+ 5BB9               ENDIF
 212+ 5BB9
 213+ 5BB9              ; *******************************************************************************************************
 214+ 5BB9              ; function to handle CALL VRMMEM basic extension
 215+ 5BB9              ; copies from RAM to VRAM
 216+ 5BB9              ; _VRMMEM ( INT source,
 217+ 5BB9              ;			INT destination,
 218+ 5BB9              ;			INT count
 219+ 5BB9              ; will put ram in page 0 also, page 1 is already there
 220+ 5BB9              VRMMEM:
 221+ 5BB9              	; opening (
 222+ 5BB9 CD 13 67     	CALL CHKCHAR
 223+ 5BBC 28           	DB '('
 224+ 5BBD              	; get source address
 225+ 5BBD DD 21 2F 54  	LD IX, FRMQNT
 226+ 5BC1 CD 59 01     	CALL CALBAS
 227+ 5BC4 D5           	PUSH DE
 228+ 5BC5              	; comma
 229+ 5BC5 CD 13 67     	CALL CHKCHAR
 230+ 5BC8 2C           	DB ','
 231+ 5BC9              	; get destination address
 232+ 5BC9 DD 21 2F 54  	LD IX, FRMQNT
 233+ 5BCD CD 59 01     	CALL CALBAS
 234+ 5BD0 D5           	PUSH DE
 235+ 5BD1              	; comma
 236+ 5BD1 CD 13 67     	CALL CHKCHAR
 237+ 5BD4 2C           	DB ','
 238+ 5BD5              	; get length
 239+ 5BD5 DD 21 2F 54  	LD IX, FRMQNT
 240+ 5BD9 CD 59 01     	CALL CALBAS
 241+ 5BDC D5           	PUSH DE
 242+ 5BDD              	; ending )
 243+ 5BDD CD 13 67     	CALL CHKCHAR
 244+ 5BE0 29           	DB ')'
 245+ 5BE1
 246+ 5BE1                  ; save position in BASIC text
 247+ 5BE1 E5           	PUSH HL
 248+ 5BE2 DD E1        	POP IX
 249+ 5BE4
 250+ 5BE4 C1           	POP BC ; count
 251+ 5BE5 D1           	POP DE ; destination
 252+ 5BE6 E1           	POP HL ; source
 253+ 5BE7 D9           	EXX
 254+ 5BE8 FD 21 F0 5B  	LD IY, .RET
 255+ 5BEC F3           	DI
 256+ 5BED C3 C5 66     	JP ENABLE_PAGE0
 257+ 5BF0              .RET:
 258+ 5BF0 FB           	EI
 259+ 5BF1 D9           	EXX
 260+ 5BF2 3E 01        	LD A,1
 261+ 5BF4 32 1F 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 262+ 5BF7 CD 07 5C     	CALL .LDIRMV
 263+ 5BFA AF           	XOR A
 264+ 5BFB 32 1F 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 265+ 5BFE D1               POP DE
 266+ 5BFF C1               POP BC
 267+ 5C00 CD 3C 66         CALL RESTORE_PAGE_INFO
 268+ 5C03 DD E5        	PUSH IX
 269+ 5C05 E1           	POP HL
 270+ 5C06 C9           	RET
 271+ 5C07
 272+ 5C07              .LDIRMV:
 273+ 5C07              	; set VRAM address *exactly* as in ROM, otherwise corruption
 274+ 5C07 7D           	LD	A, L
 275+ 5C08 F3           	DI
 276+ 5C09 D3 99        	OUT	(099H), A
 277+ 5C0B 7C           	LD	A, H
 278+ 5C0C E6 3F        	AND	03FH
 279+ 5C0E D3 99        	OUT	(099H), A
 280+ 5C10 FB           	EI
 281+ 5C11              	;EX (SP), HL
 282+ 5C11              	;EX (SP), HL
 283+ 5C11              	;NOP
 284+ 5C11              	;NOP
 285+ 5C11              .L4:
 286+ 5C11 DB 98            IN A, (#98)
 287+ 5C13 12           	LD (DE), A
 288+ 5C14 13               INC DE
 289+ 5C15 0B               DEC BC
 290+ 5C16 79               LD A, C
 291+ 5C17 B0               OR B
 292+ 5C18 20 F7            JR NZ, .L4
 293+ 5C1A C9               RET
 294+ 5C1B              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
 147  5C1B               ENDIF
 148  5C1B
 149  5C1B               IF (GENCAL_CMD == 1)
 150  5C1B               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
   1+ 5C1B              ; *******************************************************************************************************
   2+ 5C1B              ; function to handle CALL GENCAL basic extension
   3+ 5C1B              ; GENCAL ( INT fn_addr, = address of the function to call
   4+ 5C1B              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
   5+ 5C1B              ; output values of registers will also be stored at reg_list_ptr
   6+ 5C1B              GENCAL:
   7+ 5C1B              	; opening (
   8+ 5C1B CD 13 67     	CALL CHKCHAR
   9+ 5C1E 28           	DB '('
  10+ 5C1F              	; get function address
  11+ 5C1F DD 21 2F 54  	LD IX, FRMQNT
  12+ 5C23 CD 59 01     	CALL CALBAS
  13+ 5C26 D5           	PUSH DE
  14+ 5C27              	; comma
  15+ 5C27 CD 13 67     	CALL CHKCHAR
  16+ 5C2A 2C           	DB ','
  17+ 5C2B              	; get pointer to register list
  18+ 5C2B 3E 02            LD A,2
  19+ 5C2D 06 01            LD B,1
  20+ 5C2F 11 00 05         LD DE,#0500
  21+ 5C32 CD 40 67         CALL GET_BASIC_ARRAY_DATA_POINTER
  22+ 5C35 C5           	PUSH BC
  23+ 5C36              	; ending )
  24+ 5C36 CD 13 67     	CALL CHKCHAR
  25+ 5C39 29           	DB ')'
  26+ 5C3A
  27+ 5C3A              	; save BASIC token position
  28+ 5C3A E5           	PUSH HL
  29+ 5C3B D9               EXX
  30+ 5C3C E1           	POP HL ; HL'=next basic token
  31+ 5C3D D9               EXX
  32+ 5C3E
  33+ 5C3E E1               POP HL ; get pointer to register values
  34+ 5C3F F3           	DI
  35+ 5C40 ED 73 0E 64      LD (BLIT_STRUCT), SP
  36+ 5C44 F9               LD SP, HL
  37+ 5C45 F1               POP AF
  38+ 5C46 C1               POP BC
  39+ 5C47 D1               POP DE
  40+ 5C48 E1               POP HL
  41+ 5C49 DD E1            POP IX
  42+ 5C4B FD E1            POP IY
  43+ 5C4D D9               EXX
  44+ 5C4E ED 73 10 64      LD (BLIT_STRUCT+2), SP
  45+ 5C52 ED 7B 0E 64      LD SP, (BLIT_STRUCT)
  46+ 5C56 FB               EI
  47+ 5C57 D1               POP DE ; get function to call
  48+ 5C58 E5               PUSH HL
  49+ 5C59 CD 74 5C         CALL .EXXDECALL
  50+ 5C5C F3               DI
  51+ 5C5D ED 73 0E 64      LD (BLIT_STRUCT), SP
  52+ 5C61 ED 7B 10 64      LD SP, (BLIT_STRUCT+2)
  53+ 5C65 FD E5            PUSH IY
  54+ 5C67 DD E5            PUSH IX
  55+ 5C69 E5               PUSH HL
  56+ 5C6A D5               PUSH DE
  57+ 5C6B C5               PUSH BC
  58+ 5C6C F5               PUSH AF
  59+ 5C6D ED 7B 0E 64      LD SP, (BLIT_STRUCT)
  60+ 5C71 FB               EI
  61+ 5C72 E1               POP HL
  62+ 5C73 C9           	RET
  63+ 5C74
  64+ 5C74              .EXXDECALL:
  65+ 5C74 D5               PUSH DE
  66+ 5C75 D9               EXX
  67+ 5C76 C9               RET
  68+ 5C77              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
 151  5C77               ENDIF
 152  5C77
 153  5C77               IF (BOX_CMDS == 1)
 154  5C77               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
   1+ 5C77              ; *******************************************************************************************************
   2+ 5C77              ; generic function to implement rectangle data copy
   3+ 5C77              ; should be modified to call appropriate function for memory or vram
   4+ 5C77              ; input IX=pointer to following structure
   5+ 5C77              ; +00 source data pointer
   6+ 5C77              ; +02 num bytes in a row
   7+ 5C77              ; +04 number of rows
   8+ 5C77              ; +06 source add-to value till next row
   9+ 5C77              ; +08 destination address
  10+ 5C77              ; +10 destination add-to value till next row
  11+ 5C77              ; modifies AF, BC, DE, HL
  12+ 5C77              RECTANGLE_COPY:
  13+ 5C77 DD 6E 00     	LD L, (IX+0)
  14+ 5C7A DD 66 01     	LD H, (IX+1) ; source address
  15+ 5C7D DD 5E 08     	LD E, (IX+8)
  16+ 5C80 DD 56 09     	LD D, (IX+9) ; destination
  17+ 5C83 DD 46 04     	LD B, (IX+4) ; row number
  18+ 5C86              .L1:
  19+ 5C86 C5           	PUSH BC
  20+ 5C87 E5           		PUSH HL
  21+ 5C88 D5           			PUSH DE
  22+ 5C89 DD 4E 02     				LD C, (IX+2)
  23+ 5C8C DD 46 03     				LD B, (IX+3) ; num bytes in a row
  24+ 5C8F              .CALL1:
  25+ 5C8F CD 00 00     				CALL 0 ; set destination address from DE
  26+ 5C92              .CALL2:
  27+ 5C92 CD 00 00     				CALL 0 ; copy data fn
  28+ 5C95 E1           			POP HL
  29+ 5C96 DD 4E 0A     			LD C, (IX+10)
  30+ 5C99 DD 46 0B     			LD B, (IX+11) ; destination add-to
  31+ 5C9C 09           			ADD HL, BC
  32+ 5C9D EB           			EX DE, HL
  33+ 5C9E E1           		POP HL
  34+ 5C9F DD 4E 06     		LD C, (IX+6)
  35+ 5CA2 DD 46 07     		LD B, (IX+7) ; src add-to
  36+ 5CA5 09           		ADD HL, BC
  37+ 5CA6 C1           	POP BC
  38+ 5CA7 10 DD        	DJNZ .L1
  39+ 5CA9 C9           	RET
  40+ 5CAA              ; *******************************************************************************************************
  41+ 5CAA
  42+ 5CAA              ; *******************************************************************************************************
  43+ 5CAA              ; function to handle CALL BOXMEMCPY basic extension
  44+ 5CAA              ; copies data with window like boundaries within ram
  45+ 5CAA              ; BOXMEMCPY ( INT source data pointer,
  46+ 5CAA              ;			  INT source number of bytes in a row,
  47+ 5CAA              ;			  INT number of rows,
  48+ 5CAA              ;			  INT source add-to value till next row,
  49+ 5CAA              ; 			  INT destination pointer,
  50+ 5CAA              ;			  INT destination add-to value till next row )
  51+ 5CAA              ; request_data_ptr described in RECTANGLE_COPY
  52+ 5CAA              ; will put ram in page 0 also, page 1 is already there
  53+ 5CAA              BOXMEMCPY:
  54+ 5CAA 11 B4 5C     	LD DE,BOXMEMCPY.RET
  55+ 5CAD ED 53 29 5D  	LD (BOXCOMMON.ADDR+2), DE
  56+ 5CB1 C3 C7 5C     	JP BOXCOMMON
  57+ 5CB4              .RET:
  58+ 5CB4 FB           	EI
  59+ 5CB5              	; set RAM functions to call
  60+ 5CB5 21 00 00     	LD HL, 0
  61+ 5CB8 22 8F 5C     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
  62+ 5CBB 22 91 5C     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
  63+ 5CBE 21 ED B0     	LD HL, #B0ED ; LDIR
  64+ 5CC1 22 93 5C     	LD (RECTANGLE_COPY.CALL1+4), HL
  65+ 5CC4 C3 2E 5D     	JP BOXCOMMON.CALL
  66+ 5CC7              ; *******************************************************************************************************
  67+ 5CC7
  68+ 5CC7              ; *******************************************************************************************************
  69+ 5CC7              ; common parts of BOX commands
  70+ 5CC7              BOXCOMMON:
  71+ 5CC7              	; opening (
  72+ 5CC7 CD 13 67     	CALL CHKCHAR
  73+ 5CCA 28           	DB '('
  74+ 5CCB              	; get source data pointer
  75+ 5CCB DD 21 2F 54  	LD IX, FRMQNT
  76+ 5CCF CD 59 01     	CALL CALBAS
  77+ 5CD2 ED 53 0E 64  	LD (BLIT_STRUCT+0), DE
  78+ 5CD6              	; comma
  79+ 5CD6 CD 13 67     	CALL CHKCHAR
  80+ 5CD9 2C           	DB ','
  81+ 5CDA              	; source number of bytes in a row
  82+ 5CDA DD 21 2F 54  	LD IX, FRMQNT
  83+ 5CDE CD 59 01     	CALL CALBAS
  84+ 5CE1 ED 53 10 64  	LD (BLIT_STRUCT+2), DE
  85+ 5CE5              	; comma
  86+ 5CE5 CD 13 67     	CALL CHKCHAR
  87+ 5CE8 2C           	DB ','
  88+ 5CE9              	; number of rows
  89+ 5CE9 DD 21 2F 54  	LD IX, FRMQNT
  90+ 5CED CD 59 01     	CALL CALBAS
  91+ 5CF0 ED 53 12 64  	LD (BLIT_STRUCT+4), DE
  92+ 5CF4              	; comma
  93+ 5CF4 CD 13 67     	CALL CHKCHAR
  94+ 5CF7 2C           	DB ','
  95+ 5CF8              	; source add-to value till next row
  96+ 5CF8 DD 21 2F 54  	LD IX, FRMQNT
  97+ 5CFC CD 59 01     	CALL CALBAS
  98+ 5CFF ED 53 14 64  	LD (BLIT_STRUCT+6), DE
  99+ 5D03              	; comma
 100+ 5D03 CD 13 67     	CALL CHKCHAR
 101+ 5D06 2C           	DB ','
 102+ 5D07              	; destination pointer
 103+ 5D07 DD 21 2F 54  	LD IX, FRMQNT
 104+ 5D0B CD 59 01     	CALL CALBAS
 105+ 5D0E ED 53 16 64  	LD (BLIT_STRUCT+8), DE
 106+ 5D12              	; comma
 107+ 5D12 CD 13 67     	CALL CHKCHAR
 108+ 5D15 2C           	DB ','
 109+ 5D16              	; destination add-to value till next row
 110+ 5D16 DD 21 2F 54  	LD IX, FRMQNT
 111+ 5D1A CD 59 01     	CALL CALBAS
 112+ 5D1D ED 53 18 64  	LD (BLIT_STRUCT+10), DE
 113+ 5D21              	; ending )
 114+ 5D21 CD 13 67     	CALL CHKCHAR
 115+ 5D24 29           	DB ')'
 116+ 5D25
 117+ 5D25 E5           	PUSH HL ; save position in BASIC buffer
 118+ 5D26 F3           	DI
 119+ 5D27              .ADDR:
 120+ 5D27 FD 21 00 00  	LD IY, 0
 121+ 5D2B C3 C5 66     	JP ENABLE_PAGE0
 122+ 5D2E              .CALL:
 123+ 5D2E DD 21 0E 64  	LD IX,BLIT_STRUCT
 124+ 5D32 CD 77 5C     	CALL RECTANGLE_COPY
 125+ 5D35 AF           	XOR A
 126+ 5D36 32 1F 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 127+ 5D39
 128+ 5D39 D1               POP DE
 129+ 5D3A C1               POP BC
 130+ 5D3B CD 3C 66         CALL RESTORE_PAGE_INFO
 131+ 5D3E
 132+ 5D3E E1           	POP HL
 133+ 5D3F C9           	RET
 134+ 5D40              ; *******************************************************************************************************
 135+ 5D40
 136+ 5D40              ; *******************************************************************************************************
 137+ 5D40              ; function to handle CALL BOXMEMVRM basic extension
 138+ 5D40              ; copies data with window like boundaries from ram to Vram
 139+ 5D40              ; BOXMEMVRM ( INT source data pointer,
 140+ 5D40              ;			  INT source number of bytes in a row,
 141+ 5D40              ;			  INT number of rows,
 142+ 5D40              ;			  INT source add-to value till next row,
 143+ 5D40              ; 			  INT destination pointer,
 144+ 5D40              ;			  INT destination add-to value till next row )
 145+ 5D40              ; request_data_ptr described in RECTANGLE_COPY
 146+ 5D40              ; will put ram in page 0 also, page 1 is already there
 147+ 5D40              BOXMEMVRM:
 148+ 5D40 11 4A 5D     	LD DE,BOXMEMVRM.RET
 149+ 5D43 ED 53 29 5D  	LD (BOXCOMMON.ADDR+2), DE
 150+ 5D47 C3 C7 5C     	JP BOXCOMMON
 151+ 5D4A              .RET:
 152+ 5D4A FB           	EI
 153+ 5D4B              	; set RAM functions to call
 154+ 5D4B 21 65 5D     	LD HL, .SETDEST
 155+ 5D4E 22 90 5C     	LD (RECTANGLE_COPY.CALL1+1), HL
 156+ 5D51 21 6D 5D     	LD HL, .COPYDATA
 157+ 5D54 22 93 5C     	LD (RECTANGLE_COPY.CALL2+1), HL
 158+ 5D57 3E CD        	LD A, #CD ; CALL
 159+ 5D59 32 8F 5C     	LD (RECTANGLE_COPY.CALL1), A
 160+ 5D5C 32 92 5C     	LD (RECTANGLE_COPY.CALL2), A
 161+ 5D5F              	;LD A,1
 162+ 5D5F 32 1F 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 163+ 5D62 C3 2E 5D     	JP BOXCOMMON.CALL
 164+ 5D65              .SETDEST:
 165+ 5D65 EB           	EX DE, HL
 166+ 5D66 F3           	DI
 167+ 5D67 CD EC 65     	CALL SETWRT_LOCAL
 168+ 5D6A FB           	EI
 169+ 5D6B EB           	EX DE, HL
 170+ 5D6C C9           	RET
 171+ 5D6D              .COPYDATA:
 172+ 5D6D 41           	LD B, C
 173+ 5D6E C3 F7 65     	JP BBYTECOPY
 174+ 5D71              ; *******************************************************************************************************
# file closed: asm\BOX.asm
 155  5D71               ENDIF
 156  5D71
 157  5D71               IF (BLIT_CMDS == 1)
 158  5D71               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
   1+ 5D71              ; *******************************************************************************************************
   2+ 5D71              ; function rotates mask and data of several characters and applies to background data
   3+ 5D71              ; this handles x-shift from 0 to 4
   4+ 5D71              ; contains self-modifying code that is set-up from external function
   5+ 5D71              ; input HL=pointer to mask data
   6+ 5D71              ; input HL'=pointer to character data
   7+ 5D71              ; input DE=output buffer containing background data
   8+ 5D71              ; input BC=DE+8
   9+ 5D71              ; input A=number of characters to process
  10+ 5D71              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  11+ 5D71              SHIFT04:
  12+ 5D71 08           	EX AF, AF'
  13+ 5D72 7E           	LD A, (HL) ; get mask
  14+ 5D73 D9           	EXX
  15+ 5D74 57           	LD D, A
  16+ 5D75 1E FF        	LD E, #FF
  17+ 5D77 37           	SCF
  18+ 5D78              .M1:
  19+ 5D78 18 FE        	JR .M1 ; this is self-modifying part
  20+ 5D7A CB 1A        	RR D
  21+ 5D7C CB 1B        	RR E
  22+ 5D7E CB 1A        	RR D
  23+ 5D80 CB 1B        	RR E
  24+ 5D82 CB 1A        	RR D
  25+ 5D84 CB 1B        	RR E
  26+ 5D86 CB 1A        	RR D
  27+ 5D88 CB 1B        	RR E
  28+ 5D8A
  29+ 5D8A 46           	LD B, (HL) ; get data
  30+ 5D8B 0E 00        	LD C, 0
  31+ 5D8D              .M2:
  32+ 5D8D 18 FE        	JR .M2 ; also self-modifying part
  33+ 5D8F CB 38        	SRL B
  34+ 5D91 CB 19        	RR C
  35+ 5D93 CB 38        	SRL B
  36+ 5D95 CB 19        	RR C
  37+ 5D97 CB 38        	SRL B
  38+ 5D99 CB 19        	RR C
  39+ 5D9B CB 38        	SRL B
  40+ 5D9D CB 19        	RR C
  41+ 5D9F
  42+ 5D9F D9           	EXX
  43+ 5DA0 1A           	LD A, (DE) ; background
  44+ 5DA1 D9           	EXX
  45+ 5DA2 A2           	AND D
  46+ 5DA3 B0           	OR B
  47+ 5DA4 D9           	EXX
  48+ 5DA5 12           	LD (DE), A
  49+ 5DA6
  50+ 5DA6 0A           	LD A, (BC)
  51+ 5DA7 D9           	EXX
  52+ 5DA8 A3           	AND E
  53+ 5DA9 B1           	OR C
  54+ 5DAA 23           	INC HL
  55+ 5DAB D9           	EXX
  56+ 5DAC 02           	LD (BC), A
  57+ 5DAD
  58+ 5DAD 23           	INC HL
  59+ 5DAE 13           	INC DE
  60+ 5DAF 03           	INC BC
  61+ 5DB0
  62+ 5DB0 08           	EX AF, AF'
  63+ 5DB1 3D           	DEC A
  64+ 5DB2 C2 71 5D     	JP NZ, SHIFT04
  65+ 5DB5 C9           	RET
  66+ 5DB6              ; *******************************************************************************************************
  67+ 5DB6
  68+ 5DB6              ; *******************************************************************************************************
  69+ 5DB6              ; function rotates mask and data of several characters and applies to background data
  70+ 5DB6              ; this handles x-shift from 5 to 8
  71+ 5DB6              ; contains self-modifying code that is set-up from external function
  72+ 5DB6              ; input HL=pointer to mask data
  73+ 5DB6              ; input HL'=pointer to character data
  74+ 5DB6              ; input DE=output buffer containing background data
  75+ 5DB6              ; input BC=DE+8
  76+ 5DB6              ; input A=number of characters to process
  77+ 5DB6              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  78+ 5DB6              SHIFT58:
  79+ 5DB6 08           	EX AF, AF'
  80+ 5DB7 7E           	LD A, (HL) ; get mask
  81+ 5DB8 D9           	EXX
  82+ 5DB9 57           	LD D, A
  83+ 5DBA 1E FF        	LD E, #FF
  84+ 5DBC 37           	SCF
  85+ 5DBD              .M1:
  86+ 5DBD 18 FE        	JR .M1 ; this is self-modifying part
  87+ 5DBF CB 12        	RL D
  88+ 5DC1 CB 13        	RL E
  89+ 5DC3 CB 12        	RL D
  90+ 5DC5 CB 13        	RL E
  91+ 5DC7 CB 12        	RL D
  92+ 5DC9 CB 13        	RL E
  93+ 5DCB
  94+ 5DCB 46           	LD B, (HL)
  95+ 5DCC 0E 00        	LD C, 0
  96+ 5DCE              .M2:
  97+ 5DCE 18 FE        	JR .M2 ; also self-modifying part
  98+ 5DD0 CB 20        	SLA B
  99+ 5DD2 CB 11        	RL C
 100+ 5DD4 CB 20        	SLA B
 101+ 5DD6 CB 11        	RL C
 102+ 5DD8 CB 20        	SLA B
 103+ 5DDA CB 11        	RL C
 104+ 5DDC
 105+ 5DDC D9           	EXX
 106+ 5DDD 1A           	LD A, (DE) ; background
 107+ 5DDE D9           	EXX
 108+ 5DDF A3           	AND E
 109+ 5DE0 B1           	OR C
 110+ 5DE1 D9           	EXX
 111+ 5DE2 12           	LD (DE), A
 112+ 5DE3
 113+ 5DE3 0A           	LD A, (BC)
 114+ 5DE4 D9           	EXX
 115+ 5DE5 A2           	AND D
 116+ 5DE6 B0           	OR B
 117+ 5DE7 23           	INC HL
 118+ 5DE8 D9           	EXX
 119+ 5DE9 02           	LD (BC), A
 120+ 5DEA
 121+ 5DEA 23           	INC HL
 122+ 5DEB 13           	INC DE
 123+ 5DEC 03           	INC BC
 124+ 5DED
 125+ 5DED 08           	EX AF, AF'
 126+ 5DEE 3D           	DEC A
 127+ 5DEF C2 B6 5D     	JP NZ, SHIFT58
 128+ 5DF2 C9           	RET
 129+ 5DF3              ; *******************************************************************************************************
 130+ 5DF3
 131+ 5DF3              ; *******************************************************************************************************
 132+ 5DF3              ; routine that shifts one row of characters
 133+ 5DF3              ; contains self-modifying code that is set-up from external function
 134+ 5DF3              ; input HL=pointer to mask data
 135+ 5DF3              ; input HL'=pointer to character data
 136+ 5DF3              ; input DE=output buffer containing background data
 137+ 5DF3              ; input A=number of characters to process
 138+ 5DF3              ; input IX=pointer to structure describing input data
 139+ 5DF3              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 140+ 5DF3              SHIFT_ROW:
 141+ 5DF3 F5           	PUSH AF
 142+ 5DF4 ED 53 0A 64  		LD (BLIT_TMP1), DE
 143+ 5DF8 E5           		PUSH HL
 144+ 5DF9 CD 3C 5E     			CALL .ADDYSHIFT
 145+ 5DFC E1           		POP HL
 146+ 5DFD ED 53 0C 64  		LD (BLIT_TMP2), DE ; DE+vertical shift
 147+ 5E01              .L1:
 148+ 5E01 3E 08        		LD A, 8
 149+ 5E03 DD 96 02     		SUB (IX+2) ; y shift
 150+ 5E06              .CALL1:
 151+ 5E06 CD 00 00     		CALL 0
 152+ 5E09 DD 7E 02     		LD A, (IX+2); y shift
 153+ 5E0C B7           		OR A
 154+ 5E0D 28 26        		JR Z, .DONE
 155+ 5E0F ED 5B 0A 64  		LD DE, (BLIT_TMP1)
 156+ 5E13 E5           		PUSH HL
 157+ 5E14 CD 4A 5E     			CALL .DETONEXTROW
 158+ 5E17 E1           		POP HL
 159+ 5E18              .CALL2:
 160+ 5E18 CD 00 00     		CALL 0
 161+ 5E1B ED 5B 0A 64  		LD DE, (BLIT_TMP1)
 162+ 5E1F E5           		PUSH HL
 163+ 5E20 CD 44 5E     			CALL .ADD8
 164+ 5E23 E1           		POP HL
 165+ 5E24 ED 53 0A 64  		LD (BLIT_TMP1), DE
 166+ 5E28 ED 5B 0C 64  		LD DE, (BLIT_TMP2)
 167+ 5E2C E5           		PUSH HL
 168+ 5E2D CD 44 5E     			CALL .ADD8
 169+ 5E30 E1           		POP HL
 170+ 5E31 ED 53 0C 64  		LD (BLIT_TMP2), DE ; DE+vertical shift
 171+ 5E35              .DONE:
 172+ 5E35 F1           	POP AF
 173+ 5E36 3D           	DEC A
 174+ 5E37 C8           	RET Z
 175+ 5E38 F5           	PUSH AF
 176+ 5E39 C3 01 5E     	JP .L1
 177+ 5E3C              .ADDYSHIFT:
 178+ 5E3C EB           	EX DE, HL
 179+ 5E3D 16 00        	LD D, 0
 180+ 5E3F DD 5E 02     	LD E, (IX+2); y shift
 181+ 5E42 18 0C        	JR .MOVDEBC
 182+ 5E44              .ADD8:
 183+ 5E44 21 08 00     	LD HL, 8
 184+ 5E47 C3 50 5E     	JP .MOVDEBC
 185+ 5E4A              .DETONEXTROW:
 186+ 5E4A DD 6E 06     	LD L, (IX+6)
 187+ 5E4D DD 66 07     	LD H, (IX+7) ; bkg add to value
 188+ 5E50              .MOVDEBC:
 189+ 5E50 19           	ADD HL, DE
 190+ 5E51 54           	LD D, H
 191+ 5E52 5D           	LD E, L
 192+ 5E53 01 08 00     	LD BC, 8
 193+ 5E56 09           	ADD HL, BC
 194+ 5E57 44           	LD B, H
 195+ 5E58 4D           	LD C, L
 196+ 5E59 C9           	RET
 197+ 5E5A              ; *******************************************************************************************************
 198+ 5E5A
 199+ 5E5A              ; *******************************************************************************************************
 200+ 5E5A              ; function rotates mask and character data and applies it to background
 201+ 5E5A              ; input IX=pointer to structure describing input data
 202+ 5E5A              ; +0  DW horizontal shift count 0-7 (low byte used)
 203+ 5E5A              ; +2  DW vertical shift count 0-7 (low byte used)
 204+ 5E5A              ; +4  DW background data start;
 205+ 5E5A              ; +6  DW background add to value to next row of background data
 206+ 5E5A              ; +8  DW mask data start;
 207+ 5E5A              ; +10  DW character data start;
 208+ 5E5A              ; +12 DW character&mask add to value to next row of data
 209+ 5E5A              ; +14 DW columns (low byte used)
 210+ 5E5A              ; +16 DW rows (low byte used)
 211+ 5E5A              SHIFT_MERGE_CHARACTER:
 212+ 5E5A DD 7E 00     	LD A, (IX) ; shift
 213+ 5E5D FE 05        	CP 5
 214+ 5E5F 38 25        	JR C, .RIGHT
 215+ 5E61              	; shifts 5-7, use rotate towards left 1-3
 216+ 5E61 21 B6 5D     	LD HL, SHIFT58
 217+ 5E64 22 07 5E     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 218+ 5E67 22 19 5E     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 219+ 5E6A D6 05        	SUB 5
 220+ 5E6C 28 0D        	JR Z, .L1
 221+ 5E6E 87           	ADD A, A
 222+ 5E6F 87           	ADD A, A
 223+ 5E70 67           	LD H, A
 224+ 5E71 2E 18        	LD L, #18 ; JR opcode
 225+ 5E73 22 BD 5D     	LD (SHIFT58.M1), HL
 226+ 5E76 22 CE 5D     	LD (SHIFT58.M2), HL
 227+ 5E79 18 32        	JR .DO
 228+ 5E7B              .L1:
 229+ 5E7B 21 00 00     	LD HL, 0 ; 2xNOP opcode
 230+ 5E7E 22 BD 5D     	LD (SHIFT58.M1), HL
 231+ 5E81 22 CE 5D     	LD (SHIFT58.M2), HL
 232+ 5E84 18 27        	JR .DO
 233+ 5E86              .RIGHT:
 234+ 5E86              	; shifts 0-4, rotate towards right
 235+ 5E86 21 71 5D     	LD HL, SHIFT04
 236+ 5E89 22 07 5E     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 237+ 5E8C 22 19 5E     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 238+ 5E8F FE 04        	CP 4
 239+ 5E91 28 11        	JR Z, .R1
 240+ 5E93 D6 04        	SUB 4
 241+ 5E95 ED 44        	NEG
 242+ 5E97 87           	ADD A, A
 243+ 5E98 87           	ADD A, A
 244+ 5E99 67           	LD H, A
 245+ 5E9A 2E 18        	LD L, #18 ; JR opcode
 246+ 5E9C 22 78 5D     	LD (SHIFT04.M1), HL
 247+ 5E9F 22 8D 5D     	LD (SHIFT04.M2), HL
 248+ 5EA2 18 09        	JR .DO
 249+ 5EA4              .R1:
 250+ 5EA4 21 00 00     	LD HL, 0 ; 2xNOP opcode
 251+ 5EA7 22 78 5D     	LD (SHIFT04.M1), HL
 252+ 5EAA 22 8D 5D     	LD (SHIFT04.M2), HL
 253+ 5EAD              .DO:
 254+ 5EAD DD 46 10     	LD B, (IX+16) ; rows
 255+ 5EB0 DD 6E 08     	LD L, (IX+8)
 256+ 5EB3 DD 66 09     	LD H, (IX+9) ; mask data
 257+ 5EB6 DD 5E 04     	LD E, (IX+4)
 258+ 5EB9 DD 56 05     	LD D, (IX+5) ; background data
 259+ 5EBC D9           	EXX
 260+ 5EBD DD 6E 0A     	LD L, (IX+10)
 261+ 5EC0 DD 66 0B     	LD H, (IX+11) ; character data
 262+ 5EC3 D9           	EXX
 263+ 5EC4              .LOOP:
 264+ 5EC4 C5           	PUSH BC
 265+ 5EC5 E5           		PUSH HL
 266+ 5EC6 D5           			PUSH DE
 267+ 5EC7 D9           				EXX
 268+ 5EC8 E5           				PUSH HL
 269+ 5EC9 D9           					EXX
 270+ 5ECA DD 7E 0E     					LD A, (IX+14) ; columns
 271+ 5ECD              .CALL:
 272+ 5ECD CD F3 5D     					CALL SHIFT_ROW
 273+ 5ED0 E1           				POP HL
 274+ 5ED1 DD 5E 0C     				LD E, (IX+12)
 275+ 5ED4 DD 56 0D     				LD D, (IX+13) ; char data to next row
 276+ 5ED7 19           				ADD HL, DE
 277+ 5ED8 D9           				EXX
 278+ 5ED9 E1           			POP HL
 279+ 5EDA DD 5E 06     			LD E, (IX+6)
 280+ 5EDD DD 56 07     			LD D, (IX+7) ; background to next row
 281+ 5EE0 19           			ADD HL, DE
 282+ 5EE1 EB           			EX DE, HL
 283+ 5EE2 E1           		POP HL
 284+ 5EE3 DD 4E 0C     		LD C, (IX+12)
 285+ 5EE6 DD 46 0D     		LD B, (IX+13) ; char data to next row
 286+ 5EE9 09           		ADD HL, BC
 287+ 5EEA C1           	POP BC
 288+ 5EEB 10 D7        	DJNZ .LOOP
 289+ 5EED C9           	RET
 290+ 5EEE              ; *******************************************************************************************************
 291+ 5EEE
 292+ 5EEE               IF (DEFUSR_EXTENSION == 1)
 293+ 5EEE              ; *******************************************************************************************************
 294+ 5EEE              ; function to handle BLIT basic extension through DEFUSR call
 295+ 5EEE              ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 296+ 5EEE              ; +2  DW horizontal shift count 0-7 (low byte used)
 297+ 5EEE              ; +4  DW vertical shift count 0-7 (low byte used)
 298+ 5EEE              ; +6  DW background data start;
 299+ 5EEE              ; +8  DW background add to value to next row of background data
 300+ 5EEE              ; +10  DW mask data start;
 301+ 5EEE              ; +12  DW character data start;
 302+ 5EEE              ; +14 DW character&mask add to value to next row of data
 303+ 5EEE              ; +16 DW columns (low byte used)
 304+ 5EEE              ; +18 DW rows (low byte used)
 305+ 5EEE              ; will put ram in page 0 also, page 1 is already there
 306+ 5EEE              BLIT_DEFUSR:
 307+ 5EEE F3           	DI
 308+ 5EEF FD 21 F6 5E  	LD IY, .RET
 309+ 5EF3 C3 C5 66     	JP ENABLE_PAGE0
 310+ 5EF6              .RET:
 311+ 5EF6 FB           	EI
 312+ 5EF7 DD 23        	INC IX
 313+ 5EF9 DD 23        	INC IX
 314+ 5EFB CD 5A 5E     	CALL SHIFT_MERGE_CHARACTER
 315+ 5EFE
 316+ 5EFE D1               POP DE
 317+ 5EFF C1               POP BC
 318+ 5F00 C3 3C 66         JP RESTORE_PAGE_INFO
 319+ 5F03              ; *******************************************************************************************************
 320+ 5F03               ENDIF
 321+ 5F03
 322+ 5F03               IF (BASIC_EXTENSION == 1)
 323+ 5F03              ; *******************************************************************************************************
 324+ 5F03              ; function to handle CALL BLIT basic extension
 325+ 5F03              ; rotates 1-bit character drawing horizontally with mask and character data and
 326+ 5F03              ; fuses with background data and applies vertical shift too
 327+ 5F03              ; in form without pointers
 328+ 5F03              ; BLIT ( INT x,
 329+ 5F03              ;		 INT y,
 330+ 5F03              ;		 INT char_data_pointer,
 331+ 5F03              ;		 INT mask_data_pointer,
 332+ 5F03              ;		 INT width (in characters),
 333+ 5F03              ;		 INT height (in characters),
 334+ 5F03              ;		 INT background_pointer (top left),
 335+ 5F03              ;		 INT background_width (in characters),
 336+ 5F03              ; will put ram in page 0 also, page 1 is already there
 337+ 5F03              BLIT:
 338+ 5F03              	; opening (
 339+ 5F03 CD 13 67     	CALL CHKCHAR
 340+ 5F06 28           	DB '('
 341+ 5F07              	; get x coordinate
 342+ 5F07 DD 21 2F 54  	LD IX, FRMQNT
 343+ 5F0B CD 59 01     	CALL CALBAS
 344+ 5F0E 7B           	LD A, E
 345+ 5F0F E6 07        	AND 7
 346+ 5F11 32 0E 64     	LD (BLIT_STRUCT+0), A
 347+ 5F14 CD E3 5F     	CALL .DAdiv8
 348+ 5F17 32 0A 64     	LD (BLIT_TMP+0),A
 349+ 5F1A              	; comma
 350+ 5F1A CD 13 67     	CALL CHKCHAR
 351+ 5F1D 2C           	DB ','
 352+ 5F1E              	; get y coordinate
 353+ 5F1E DD 21 2F 54  	LD IX, FRMQNT
 354+ 5F22 CD 59 01     	CALL CALBAS
 355+ 5F25 7B           	LD A, E
 356+ 5F26 E6 07        	AND 7
 357+ 5F28 32 10 64     	LD (BLIT_STRUCT+2), A
 358+ 5F2B CD E3 5F     	CALL .DAdiv8
 359+ 5F2E 32 0B 64     	LD (BLIT_TMP+1),A
 360+ 5F31              	; comma
 361+ 5F31 CD 13 67     	CALL CHKCHAR
 362+ 5F34 2C           	DB ','
 363+ 5F35              	; get char data pointer
 364+ 5F35 DD 21 2F 54  	LD IX, FRMQNT
 365+ 5F39 CD 59 01     	CALL CALBAS
 366+ 5F3C ED 53 18 64  	LD (BLIT_STRUCT+10), DE
 367+ 5F40              	; comma
 368+ 5F40 CD 13 67     	CALL CHKCHAR
 369+ 5F43 2C           	DB ','
 370+ 5F44              	; get mask data pointer
 371+ 5F44 DD 21 2F 54  	LD IX, FRMQNT
 372+ 5F48 CD 59 01     	CALL CALBAS
 373+ 5F4B ED 53 16 64  	LD (BLIT_STRUCT+8), DE
 374+ 5F4F              	; comma
 375+ 5F4F CD 13 67     	CALL CHKCHAR
 376+ 5F52 2C           	DB ','
 377+ 5F53              	; get width
 378+ 5F53 DD 21 2F 54  	LD IX, FRMQNT
 379+ 5F57 CD 59 01     	CALL CALBAS
 380+ 5F5A 7B           	LD A, E
 381+ 5F5B 32 1C 64     	LD (BLIT_STRUCT+14), A
 382+ 5F5E              	; comma
 383+ 5F5E CD 13 67     	CALL CHKCHAR
 384+ 5F61 2C           	DB ','
 385+ 5F62              	; get height
 386+ 5F62 DD 21 2F 54  	LD IX, FRMQNT
 387+ 5F66 CD 59 01     	CALL CALBAS
 388+ 5F69 7B           	LD A, E
 389+ 5F6A 32 1E 64     	LD (BLIT_STRUCT+16), A
 390+ 5F6D              	; comma
 391+ 5F6D CD 13 67     	CALL CHKCHAR
 392+ 5F70 2C           	DB ','
 393+ 5F71              	; get background pointer
 394+ 5F71 DD 21 2F 54  	LD IX, FRMQNT
 395+ 5F75 CD 59 01     	CALL CALBAS
 396+ 5F78 ED 53 12 64  	LD (BLIT_STRUCT+4), DE
 397+ 5F7C              	; comma
 398+ 5F7C CD 13 67     	CALL CHKCHAR
 399+ 5F7F 2C           	DB ','
 400+ 5F80              	; get background width
 401+ 5F80 DD 21 2F 54  	LD IX, FRMQNT
 402+ 5F84 CD 59 01     	CALL CALBAS
 403+ 5F87 7B           	LD A, E
 404+ 5F88 32 0C 64     	LD (BLIT_TMP+2), A
 405+ 5F8B              	; ending )
 406+ 5F8B CD 13 67     	CALL CHKCHAR
 407+ 5F8E 29           	DB ')'
 408+ 5F8F
 409+ 5F8F E5           	PUSH HL ; save position in BASIC buffer
 410+ 5F90
 411+ 5F90              	; calculate char&mask add to value
 412+ 5F90 26 00        	LD H, 0
 413+ 5F92 3A 1C 64     	LD A, (BLIT_STRUCT+14)
 414+ 5F95 6F           	LD L, A
 415+ 5F96 CD 01 66     	CALL HLx8
 416+ 5F99 22 1A 64     	LD (BLIT_STRUCT+12), HL
 417+ 5F9C              	; calculate background add to value
 418+ 5F9C 26 00        	LD H, 0
 419+ 5F9E 3A 0C 64     	LD A, (BLIT_TMP+2)
 420+ 5FA1 6F           	LD L, A
 421+ 5FA2 CD 01 66     	CALL HLx8
 422+ 5FA5 22 14 64     	LD (BLIT_STRUCT+6), HL
 423+ 5FA8              	; calculate pointer to background location
 424+ 5FA8 21 00 00     	LD HL, 0
 425+ 5FAB 3A 0B 64     	LD A,(BLIT_TMP+1)
 426+ 5FAE B7           	OR A
 427+ 5FAF 28 08        	JR Z, .L1
 428+ 5FB1 47           	LD B,A
 429+ 5FB2 ED 5B 14 64  	LD DE,(BLIT_STRUCT+6)
 430+ 5FB6              .L0:
 431+ 5FB6 19           	ADD HL, DE
 432+ 5FB7 10 FD        	DJNZ .L0
 433+ 5FB9              .L1:
 434+ 5FB9 EB           	EX DE,HL
 435+ 5FBA 26 00        	LD H,0
 436+ 5FBC 3A 0A 64     	LD A,(BLIT_TMP+0)
 437+ 5FBF 6F           	LD L,A
 438+ 5FC0 CD 01 66     	CALL HLx8
 439+ 5FC3 19           	ADD HL,DE
 440+ 5FC4 ED 5B 12 64  	LD DE,(BLIT_STRUCT+4)
 441+ 5FC8 19           	ADD HL,DE
 442+ 5FC9 22 12 64     	LD (BLIT_STRUCT+4),HL
 443+ 5FCC
 444+ 5FCC F3           	DI
 445+ 5FCD FD 21 D4 5F  	LD IY, .RET
 446+ 5FD1 C3 C5 66     	JP ENABLE_PAGE0
 447+ 5FD4              .RET:
 448+ 5FD4 FB           	EI
 449+ 5FD5 DD 21 0E 64  	LD IX, BLIT_STRUCT
 450+ 5FD9 CD 5A 5E     	CALL SHIFT_MERGE_CHARACTER
 451+ 5FDC
 452+ 5FDC D1               POP DE
 453+ 5FDD C1               POP BC
 454+ 5FDE CD 3C 66         CALL RESTORE_PAGE_INFO
 455+ 5FE1
 456+ 5FE1 E1           	POP HL
 457+ 5FE2 C9           	RET
 458+ 5FE3              .DAdiv8:
 459+ 5FE3 7B           	LD A,E
 460+ 5FE4 CB 2A        	SRA D
 461+ 5FE6 CB 1F            RR  A
 462+ 5FE8 CB 2A            SRA D
 463+ 5FEA CB 1F            RR  A
 464+ 5FEC CB 2A            SRA D
 465+ 5FEE CB 1F            RR  A
 466+ 5FF0 C9           	RET
 467+ 5FF1              ; *******************************************************************************************************
 468+ 5FF1               ENDIF
# file closed: asm\BLIT.asm
 159  5FF1               ENDIF
 160  5FF1
 161  5FF1               IF (TILE_CMDS == 1)
 162  5FF1               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
   1+ 5FF1              ; *******************************************************************************************************
   2+ 5FF1              ; generic function to implement tiling
   3+ 5FF1              ; should be modified to call appropriate function for memory or vram
   4+ 5FF1              ; input IX=pointer to following structure
   5+ 5FF1              ; +00 tile_data_ptr
   6+ 5FF1              ; +02 tile_rows
   7+ 5FF1              ; +04 tile_columns
   8+ 5FF1              ; +06 destination_address
   9+ 5FF1              ; +08 dest_to_next_row_add_to_value
  10+ 5FF1              ; +10 num_horizontal_tiles
  11+ 5FF1              ; +12 num_vertical_tiles
  12+ 5FF1              ; modifies AF, BC, DE, HL
  13+ 5FF1              TILE:
  14+ 5FF1 DD 6E 06     	LD L, (IX+6)
  15+ 5FF4 DD 66 07     	LD H, (IX+7) ; destination address
  16+ 5FF7 22 0A 64     	LD (TILETMP1), HL
  17+ 5FFA DD 46 0C     	LD B, (IX+12) ; vertical tile number
  18+ 5FFD              .L1:
  19+ 5FFD C5           	PUSH BC
  20+ 5FFE DD 6E 00     		LD L, (IX+0)
  21+ 6001 DD 66 01     		LD H, (IX+1) ; tile address
  22+ 6004 22 0C 64     		LD (TILETMP2), HL
  23+ 6007 DD 46 02     		LD B, (IX+2) ; tile rows
  24+ 600A              .L2:
  25+ 600A C5           		PUSH BC
  26+ 600B CD 00 00     .CALL1:		CALL 0
  27+ 600E DD 46 0A     			LD B, (IX+10) ; horizontal tile num
  28+ 6011              .L3:
  29+ 6011 C5           			PUSH BC
  30+ 6012 2A 0C 64     				LD HL, (TILETMP2)
  31+ 6015 DD 46 04     				LD B, (IX+4) ; tile columns
  32+ 6018              .L4:
  33+ 6018 C5           				PUSH BC
  34+ 6019              .CALL2:
  35+ 6019 CD 00 00     					CALL 0
  36+ 601C C1           				POP BC
  37+ 601D 10 F9        				DJNZ .L4
  38+ 601F C1           			POP BC
  39+ 6020 10 EF        			DJNZ .L3
  40+ 6022 22 0C 64     			LD (TILETMP2), HL
  41+ 6025 2A 0A 64     			LD HL, (TILETMP1)
  42+ 6028 DD 5E 08     			LD E, (IX+8)
  43+ 602B DD 56 09     			LD D, (IX+9) ; add to value for dest next row
  44+ 602E 19           			ADD HL, DE
  45+ 602F 22 0A 64     			LD (TILETMP1), HL
  46+ 6032 C1           		POP BC
  47+ 6033 10 D5        		DJNZ .L2
  48+ 6035 C1           	POP BC
  49+ 6036 10 C5        	DJNZ .L1
  50+ 6038 C9           	RET
  51+ 6039              ; *******************************************************************************************************
  52+ 6039
  53+ 6039               IFNDEF CMDS_WITH_PARAMETERS
  54+ 6039 ~            ; *******************************************************************************************************
  55+ 6039 ~            ; function to handle CALL TILERAM basic extension
  56+ 6039 ~            ; fills memory with tiles
  57+ 6039 ~            ; TILERAM ( INT request_data_ptr )
  58+ 6039 ~            ; request_data_ptr described in TILE
  59+ 6039 ~            ; will put ram in page 0 also, page 1 is already there
  60+ 6039 ~            TILERAM:
  61+ 6039 ~            	; opening (
  62+ 6039 ~            	CALL CHKCHAR
  63+ 6039 ~            	DB '('
  64+ 6039 ~            	; get pointer to request struct
  65+ 6039 ~            	LD IX, FRMQNT
  66+ 6039 ~            	CALL CALBAS
  67+ 6039 ~            	PUSH DE
  68+ 6039 ~            	; ending )
  69+ 6039 ~            	CALL CHKCHAR
  70+ 6039 ~            	DB ')'
  71+ 6039 ~
  72+ 6039 ~            	POP IX ; pointer to request struct
  73+ 6039 ~
  74+ 6039 ~            	PUSH HL ; save position in BASIC buffer
  75+ 6039 ~            	DI
  76+ 6039 ~            	LD IY, .RET
  77+ 6039 ~            	JP ENABLE_PAGE0
  78+ 6039 ~            .RET:
  79+ 6039 ~            	EI
  80+ 6039 ~            	; set RAM functions to call
  81+ 6039 ~            	LD HL, .TILECOPY
  82+ 6039 ~            	LD (TILE.CALL2+1), HL
  83+ 6039 ~            	LD HL, .SETDESTROW
  84+ 6039 ~            	LD (TILE.CALL1+1), HL
  85+ 6039 ~            	LD A,1
  86+ 6039 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  87+ 6039 ~            	CALL TILE
  88+ 6039 ~            	XOR A
  89+ 6039 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  90+ 6039 ~
  91+ 6039 ~                POP DE
  92+ 6039 ~                POP BC
  93+ 6039 ~                CALL RESTORE_PAGE_INFO
  94+ 6039 ~
  95+ 6039 ~            	POP HL
  96+ 6039 ~            	RET
  97+ 6039 ~            .TILECOPY:
  98+ 6039 ~            	.8 LDI
  99+ 6039 ~            	RET
 100+ 6039 ~            .SETDESTROW:
 101+ 6039 ~            	LD DE, (TILETMP1)
 102+ 6039 ~            	RET
 103+ 6039 ~            ; *******************************************************************************************************
 104+ 6039               ENDIF
 105+ 6039
 106+ 6039               IFDEF CMDS_WITH_PARAMETERS
 107+ 6039              ; *******************************************************************************************************
 108+ 6039              ; function to handle CALL TILERAM basic extension
 109+ 6039              ; fills memory with tiles
 110+ 6039              ; TILERAM ( INT tile_data_pointer,
 111+ 6039              ;			INT tile_columns,
 112+ 6039              ;			INT tile_rows,
 113+ 6039              ;			INT destination_pointer,
 114+ 6039              ;			INT destination_columns,
 115+ 6039              ;			INT destination_rows,
 116+ 6039              ;			INT destination_begin_column,
 117+ 6039              ;			INT destination_begin_row,
 118+ 6039              ;			INT number_of_tiles_horizontally,
 119+ 6039              ;			INT	number_of_tiles_vertically )
 120+ 6039              ; will put ram in page 0 also, page 1 is already there
 121+ 6039              TILERAM:
 122+ 6039              	; opening (
 123+ 6039 CD 13 67     	CALL CHKCHAR
 124+ 603C 28           	DB '('
 125+ 603D              	; get tile data pointer coordinate
 126+ 603D DD 21 2F 54  	LD IX, FRMQNT
 127+ 6041 CD 59 01     	CALL CALBAS
 128+ 6044 ED 53 0E 64  	LD (BLIT_STRUCT+0), DE
 129+ 6048              	; comma
 130+ 6048 CD 13 67     	CALL CHKCHAR
 131+ 604B 2C           	DB ','
 132+ 604C              	; get tile columns
 133+ 604C DD 21 2F 54  	LD IX, FRMQNT
 134+ 6050 CD 59 01     	CALL CALBAS
 135+ 6053 ED 53 12 64  	LD (BLIT_STRUCT+4), DE
 136+ 6057              	; comma
 137+ 6057 CD 13 67     	CALL CHKCHAR
 138+ 605A 2C           	DB ','
 139+ 605B              	; get tile columns
 140+ 605B DD 21 2F 54  	LD IX, FRMQNT
 141+ 605F CD 59 01     	CALL CALBAS
 142+ 6062 ED 53 10 64  	LD (BLIT_STRUCT+2), DE
 143+ 6066              	; comma
 144+ 6066 CD 13 67     	CALL CHKCHAR
 145+ 6069 2C           	DB ','
 146+ 606A              	; get destintion pointer
 147+ 606A DD 21 2F 54  	LD IX, FRMQNT
 148+ 606E CD 59 01     	CALL CALBAS
 149+ 6071 ED 53 14 64  	LD (BLIT_STRUCT+6), DE
 150+ 6075              	; comma
 151+ 6075 CD 13 67     	CALL CHKCHAR
 152+ 6078 2C           	DB ','
 153+ 6079              	; get destination columns
 154+ 6079 DD 21 2F 54  	LD IX, FRMQNT
 155+ 607D CD 59 01     	CALL CALBAS
 156+ 6080 7B           	LD A, E
 157+ 6081 32 0A 64     	LD (BLIT_TMP+0), A
 158+ 6084              	; comma
 159+ 6084 CD 13 67     	CALL CHKCHAR
 160+ 6087 2C           	DB ','
 161+ 6088              	; get destination rows
 162+ 6088 DD 21 2F 54  	LD IX, FRMQNT
 163+ 608C CD 59 01     	CALL CALBAS
 164+ 608F 7B           	LD A, E
 165+ 6090 32 0B 64     	LD (BLIT_TMP+1), A
 166+ 6093              	; comma
 167+ 6093 CD 13 67     	CALL CHKCHAR
 168+ 6096 2C           	DB ','
 169+ 6097              	; get destination begin column
 170+ 6097 DD 21 2F 54  	LD IX, FRMQNT
 171+ 609B CD 59 01     	CALL CALBAS
 172+ 609E 7B           	LD A, E
 173+ 609F 32 0C 64     	LD (BLIT_TMP+2), A
 174+ 60A2              	; comma
 175+ 60A2 CD 13 67     	CALL CHKCHAR
 176+ 60A5 2C           	DB ','
 177+ 60A6              	; get destination begin row
 178+ 60A6 DD 21 2F 54  	LD IX, FRMQNT
 179+ 60AA CD 59 01     	CALL CALBAS
 180+ 60AD 7B           	LD A, E
 181+ 60AE 32 0D 64     	LD (BLIT_TMP+3), A
 182+ 60B1              	; comma
 183+ 60B1 CD 13 67     	CALL CHKCHAR
 184+ 60B4 2C           	DB ','
 185+ 60B5              	; get number of tiles horizontally
 186+ 60B5 DD 21 2F 54  	LD IX, FRMQNT
 187+ 60B9 CD 59 01     	CALL CALBAS
 188+ 60BC ED 53 18 64  	LD (BLIT_STRUCT+10), DE
 189+ 60C0              	; comma
 190+ 60C0 CD 13 67     	CALL CHKCHAR
 191+ 60C3 2C           	DB ','
 192+ 60C4              	; get number of tiles vertically
 193+ 60C4 DD 21 2F 54  	LD IX, FRMQNT
 194+ 60C8 CD 59 01     	CALL CALBAS
 195+ 60CB ED 53 1A 64  	LD (BLIT_STRUCT+12), DE
 196+ 60CF              	; ending )
 197+ 60CF CD 13 67     	CALL CHKCHAR
 198+ 60D2 29           	DB ')'
 199+ 60D3
 200+ 60D3 E5           	PUSH HL ; save position in BASIC buffer
 201+ 60D4
 202+ 60D4              	; calculate destination add to value
 203+ 60D4 26 00        	LD H, 0
 204+ 60D6 3A 0A 64     	LD A, (BLIT_TMP+0)
 205+ 60D9 6F           	LD L, A
 206+ 60DA CD 01 66     	CALL HLx8
 207+ 60DD 22 16 64     	LD (BLIT_STRUCT+8), HL
 208+ 60E0              	; calculate pointer to background location
 209+ 60E0 21 00 00     	LD HL, 0
 210+ 60E3 3A 0D 64     	LD A,(BLIT_TMP+3)
 211+ 60E6 B7           	OR A
 212+ 60E7 28 08        	JR Z, .L1
 213+ 60E9 47           	LD B,A
 214+ 60EA ED 5B 16 64  	LD DE,(BLIT_STRUCT+8)
 215+ 60EE              .L0:
 216+ 60EE 19           	ADD HL, DE
 217+ 60EF 10 FD        	DJNZ .L0
 218+ 60F1              .L1:
 219+ 60F1 EB           	EX DE,HL
 220+ 60F2 26 00        	LD H,0
 221+ 60F4 3A 0C 64     	LD A,(BLIT_TMP+2)
 222+ 60F7 6F           	LD L,A
 223+ 60F8 CD 01 66     	CALL HLx8
 224+ 60FB 19           	ADD HL,DE
 225+ 60FC ED 5B 14 64  	LD DE,(BLIT_STRUCT+6)
 226+ 6100 19           	ADD HL,DE
 227+ 6101 22 14 64     	LD (BLIT_STRUCT+6),HL
 228+ 6104 F3           	DI
 229+ 6105 FD 21 0C 61  	LD IY, .RET
 230+ 6109 C3 C5 66     	JP ENABLE_PAGE0
 231+ 610C              .RET:
 232+ 610C FB           	EI
 233+ 610D              	; set RAM functions to call
 234+ 610D 21 27 61     	LD HL, .TILECOPY
 235+ 6110 22 1A 60     	LD (TILE.CALL2+1), HL
 236+ 6113 21 38 61     	LD HL, .SETDESTROW
 237+ 6116 22 0C 60     	LD (TILE.CALL1+1), HL
 238+ 6119 DD 21 0E 64  	LD IX,BLIT_STRUCT
 239+ 611D CD F1 5F     	CALL TILE
 240+ 6120
 241+ 6120 D1               POP DE
 242+ 6121 C1               POP BC
 243+ 6122 CD 3C 66         CALL RESTORE_PAGE_INFO
 244+ 6125
 245+ 6125 E1           	POP HL
 246+ 6126 C9           	RET
 247+ 6127              .TILECOPY:
 248+ 6127 ED A0       > LDI
 248+ 6129 ED A0       > LDI
 248+ 612B ED A0       > LDI
 248+ 612D ED A0       > LDI
 248+ 612F ED A0       > LDI
 248+ 6131 ED A0       > LDI
 248+ 6133 ED A0       > LDI
 248+ 6135 ED A0       > LDI
 249+ 6137 C9           	RET
 250+ 6138              .SETDESTROW:
 251+ 6138 ED 5B 0A 64  	LD DE, (TILETMP1)
 252+ 613C C9           	RET
 253+ 613D              ; *******************************************************************************************************
 254+ 613D               ENDIF
 255+ 613D
 256+ 613D               IFDEF CMDS_WITH_PARAMETERS
 257+ 613D              ; *******************************************************************************************************
 258+ 613D              ; function to handle CALL TILEVRM basic extension
 259+ 613D              ; fills vram with tiles
 260+ 613D              ; TILEVRM ( INT tile_data_pointer,
 261+ 613D              ;			INT tile_columns,
 262+ 613D              ;			INT tile_rows,
 263+ 613D              ;			INT destination_begin_column,
 264+ 613D              ;			INT destination_begin_row,
 265+ 613D              ;			INT number_of_tiles_horizontally,
 266+ 613D              ;			INT	number_of_tiles_vertically )
 267+ 613D              ; will put ram in page 0 also, page 1 is already there
 268+ 613D              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
 269+ 613D              TILEVRM:
 270+ 613D              	; opening (
 271+ 613D CD 13 67     	CALL CHKCHAR
 272+ 6140 28           	DB '('
 273+ 6141              	; get tile data pointer coordinate
 274+ 6141 DD 21 2F 54  	LD IX, FRMQNT
 275+ 6145 CD 59 01     	CALL CALBAS
 276+ 6148 ED 53 0E 64  	LD (BLIT_STRUCT+0), DE
 277+ 614C              	; comma
 278+ 614C CD 13 67     	CALL CHKCHAR
 279+ 614F 2C           	DB ','
 280+ 6150              	; get tile columns
 281+ 6150 DD 21 2F 54  	LD IX, FRMQNT
 282+ 6154 CD 59 01     	CALL CALBAS
 283+ 6157 ED 53 12 64  	LD (BLIT_STRUCT+4), DE
 284+ 615B              	; comma
 285+ 615B CD 13 67     	CALL CHKCHAR
 286+ 615E 2C           	DB ','
 287+ 615F              	; get tile columns
 288+ 615F DD 21 2F 54  	LD IX, FRMQNT
 289+ 6163 CD 59 01     	CALL CALBAS
 290+ 6166 ED 53 10 64  	LD (BLIT_STRUCT+2), DE
 291+ 616A              	; comma
 292+ 616A CD 13 67     	CALL CHKCHAR
 293+ 616D 2C           	DB ','
 294+ 616E              	; get destination begin column
 295+ 616E DD 21 2F 54  	LD IX, FRMQNT
 296+ 6172 CD 59 01     	CALL CALBAS
 297+ 6175 7B           	LD A, E
 298+ 6176 32 0C 64     	LD (BLIT_TMP+2), A
 299+ 6179              	; comma
 300+ 6179 CD 13 67     	CALL CHKCHAR
 301+ 617C 2C           	DB ','
 302+ 617D              	; get destination begin row
 303+ 617D DD 21 2F 54  	LD IX, FRMQNT
 304+ 6181 CD 59 01     	CALL CALBAS
 305+ 6184 7B           	LD A, E
 306+ 6185 32 0D 64     	LD (BLIT_TMP+3), A
 307+ 6188              	; comma
 308+ 6188 CD 13 67     	CALL CHKCHAR
 309+ 618B 2C           	DB ','
 310+ 618C              	; get number of tiles horizontally
 311+ 618C DD 21 2F 54  	LD IX, FRMQNT
 312+ 6190 CD 59 01     	CALL CALBAS
 313+ 6193 ED 53 18 64  	LD (BLIT_STRUCT+10), DE
 314+ 6197              	; comma
 315+ 6197 CD 13 67     	CALL CHKCHAR
 316+ 619A 2C           	DB ','
 317+ 619B              	; get number of tiles vertically
 318+ 619B DD 21 2F 54  	LD IX, FRMQNT
 319+ 619F CD 59 01     	CALL CALBAS
 320+ 61A2 ED 53 1A 64  	LD (BLIT_STRUCT+12), DE
 321+ 61A6              	; ending )
 322+ 61A6 CD 13 67     	CALL CHKCHAR
 323+ 61A9 29           	DB ')'
 324+ 61AA
 325+ 61AA E5           	PUSH HL ; save position in BASIC buffer
 326+ 61AB
 327+ 61AB              	; calculate destination add to value
 328+ 61AB 21 00 01     	LD HL, 256
 329+ 61AE 22 16 64     	LD (BLIT_STRUCT+8), HL
 330+ 61B1              	; calculate pointer to background location
 331+ 61B1 3A 0D 64     	LD A,(BLIT_TMP+3)
 332+ 61B4 67           	LD H,A
 333+ 61B5 2E 00        	LD L,0
 334+ 61B7 EB           	EX DE,HL
 335+ 61B8 26 00        	LD H,0
 336+ 61BA 3A 0C 64     	LD A,(BLIT_TMP+2)
 337+ 61BD 6F           	LD L,A
 338+ 61BE CD 01 66     	CALL HLx8
 339+ 61C1 19           	ADD HL,DE
 340+ 61C2 ED 5B CB F3  	LD DE,(GRPCGP)
 341+ 61C6 19           	ADD HL,DE
 342+ 61C7 22 14 64     	LD (BLIT_STRUCT+6),HL
 343+ 61CA F3           	DI
 344+ 61CB FD 21 D2 61  	LD IY, .RET
 345+ 61CF C3 C5 66     	JP ENABLE_PAGE0
 346+ 61D2              .RET:
 347+ 61D2 FB           	EI
 348+ 61D3              	; set RAM functions to call
 349+ 61D3 21 ED 61     	LD HL, .TILECOPY
 350+ 61D6 22 1A 60     	LD (TILE.CALL2+1), HL
 351+ 61D9 21 F3 61     	LD HL, .SETDESTROW
 352+ 61DC 22 0C 60     	LD (TILE.CALL1+1), HL
 353+ 61DF DD 21 0E 64  	LD IX,BLIT_STRUCT
 354+ 61E3 CD F1 5F     	CALL TILE
 355+ 61E6
 356+ 61E6 D1               POP DE
 357+ 61E7 C1               POP BC
 358+ 61E8 CD 3C 66         CALL RESTORE_PAGE_INFO
 359+ 61EB
 360+ 61EB E1           	POP HL
 361+ 61EC C9           	RET
 362+ 61ED              .TILECOPY:
 363+ 61ED 01 98 08     	LD BC, #0898
 364+ 61F0 C3 F9 65     	JP BBYTECOPY_NO_C
 365+ 61F3              .SETDESTROW:
 366+ 61F3 2A 0A 64     	LD HL, (TILETMP1)
 367+ 61F6 F3           	DI
 368+ 61F7 CD EC 65     	CALL SETWRT_LOCAL
 369+ 61FA FB           	EI
 370+ 61FB C9           	RET
 371+ 61FC              ; *******************************************************************************************************
 372+ 61FC               ENDIF
 373+ 61FC
 374+ 61FC               IFNDEF CMDS_WITH_PARAMETERS
 375+ 61FC ~            ; *******************************************************************************************************
 376+ 61FC ~            ; function to handle CALL TILEVRM basic extension
 377+ 61FC ~            ; fills vram with tiles
 378+ 61FC ~            ; TILEVRM ( INT request_data_ptr )
 379+ 61FC ~            ; request_data_ptr described in TILE
 380+ 61FC ~            ; will put ram in page 0 also, page 1 is already there
 381+ 61FC ~            TILEVRM:
 382+ 61FC ~            	; opening (
 383+ 61FC ~            	CALL CHKCHAR
 384+ 61FC ~            	DB '('
 385+ 61FC ~            	; get pointer to request struct
 386+ 61FC ~            	LD IX, FRMQNT
 387+ 61FC ~            	CALL CALBAS
 388+ 61FC ~            	PUSH DE
 389+ 61FC ~            	; ending )
 390+ 61FC ~            	CALL CHKCHAR
 391+ 61FC ~            	DB ')'
 392+ 61FC ~
 393+ 61FC ~            	POP IX ; pointer to request struct
 394+ 61FC ~
 395+ 61FC ~            	PUSH HL ; save position in BASIC buffer
 396+ 61FC ~            	DI
 397+ 61FC ~            	LD IY, .RET
 398+ 61FC ~            	JP ENABLE_PAGE0
 399+ 61FC ~            .RET:
 400+ 61FC ~            	EI
 401+ 61FC ~            	; set RAM functions to call
 402+ 61FC ~            	LD HL, .TILECOPY
 403+ 61FC ~            	LD (TILE.CALL2+1), HL
 404+ 61FC ~            	LD HL, .SETDESTROW
 405+ 61FC ~            	LD (TILE.CALL1+1), HL
 406+ 61FC ~            	CALL TILE
 407+ 61FC ~
 408+ 61FC ~                POP DE
 409+ 61FC ~                POP BC
 410+ 61FC ~                CALL RESTORE_PAGE_INFO
 411+ 61FC ~
 412+ 61FC ~            	POP HL
 413+ 61FC ~            	RET
 414+ 61FC ~            .TILECOPY:
 415+ 61FC ~            	LD BC, #0898
 416+ 61FC ~            	JP BBYTECOPY_NO_C
 417+ 61FC ~            .SETDESTROW:
 418+ 61FC ~            	LD HL, (TILETMP1)
 419+ 61FC ~            	DI
 420+ 61FC ~            	CALL SETWRT_LOCAL
 421+ 61FC ~            	EI
 422+ 61FC ~            	RET
 423+ 61FC ~            ; *******************************************************************************************************
 424+ 61FC               ENDIF
# file closed: asm\TILE.asm
 163  61FC               ENDIF
 164  61FC
 165  61FC               IF (COLL_CMD == 1)
 166  61FC               INCLUDE "COLLISION.asm"
# file opened: asm\COLLISION.asm
   1+ 61FC              ; generic collision checking routines
   2+ 61FC              ; in BASIC we use rectangle structure array DIM R%(7,n) of the format
   3+ 61FC              ; R%(0,n) is active flag, <>0 active / 0 skipped in checks
   4+ 61FC              ; R%(1,n) is either upper left x coordinate or sprite id (0-31) depending on R(7,n)
   5+ 61FC              ; R%(2,n) is either upper left y coordinate or unused depending on R(7,n)
   6+ 61FC              ; R%(3,n) x offset where rectangle begins
   7+ 61FC              ; R%(4,n) y offset where rectangle begins
   8+ 61FC              ; R%(5,n) is width
   9+ 61FC              ; R%(6,n) is height
  10+ 61FC              ; R%(7,0) is type, 0=generic where R%(1,0) contains x coordinate
  11+ 61FC              ;                  <>0 sprite where R%(1,0) contains sprite id
  12+ 61FC              ; for type sprite, upper left coordinates are taken from sprite attribute array
  13+ 61FC
  14+ 61FC              ; ************************************************************************************************
  15+ 61FC              ; quick test if HL<=DE<=HL+BC
  16+ 61FC              ; input BC=width, DE=x, HL=min
  17+ 61FC              ; if not true flag C set
  18+ 61FC              ; modifies AF
  19+ 61FC              GENERIC_INNER_CHECK:
  20+ 61FC E5               PUSH HL
  21+ 61FD D5               PUSH DE
  22+ 61FE EB               EX DE,HL
  23+ 61FF A7               AND A
  24+ 6200 ED 52            SBC HL, DE
  25+ 6202 FA 10 62         JP M, .GENERIC_INNER_CHECK_NOT
  26+ 6205 A7               AND A
  27+ 6206 ED 42            SBC HL, BC
  28+ 6208 28 03            JR Z, .L2
  29+ 620A F2 10 62         JP P, .GENERIC_INNER_CHECK_NOT
  30+ 620D              .L2:
  31+ 620D A7               AND A
  32+ 620E 18 01            JR .EXIT
  33+ 6210              .GENERIC_INNER_CHECK_NOT:
  34+ 6210 37               SCF
  35+ 6211              .EXIT:
  36+ 6211 D1               POP DE
  37+ 6212 E1               POP HL
  38+ 6213 C9               RET
  39+ 6214              ; ************************************************************************************************
  40+ 6214
  41+ 6214              ; ************************************************************************************************
  42+ 6214              ; function to check if rectangles are overlapping
  43+ 6214              ; input IX=IY=pointer to struct
  44+ 6214              ;  +00 active flag
  45+ 6214              ;  +02 x coordinate
  46+ 6214              ;  +04 y coordinate
  47+ 6214              ;  +06 x offset where rectangle begins
  48+ 6214              ;  +08 y offset where rectangle begins
  49+ 6214              ;  +10 width
  50+ 6214              ;  +12 height
  51+ 6214              ; where IY is used to read +2 and +4, and IX to read +6, +8, +10 and +12
  52+ 6214              ; this is a hack to allow location being taken from sprite attributes table
  53+ 6214              ; input BLIT_STRUCT data
  54+ 6214              ;  +00 x coordinate
  55+ 6214              ;  +02 y coordinate
  56+ 6214              ;  +04 width
  57+ 6214              ;  +06 height
  58+ 6214              ; returns CF=1 if not overlapping, CF=0 if overlapping
  59+ 6214              RECTANGLE_OVERLAP_CHECK:
  60+ 6214                  ; first check which rectangle is higher
  61+ 6214 DD 6E 0C         LD L,(IX+12)
  62+ 6217 DD 66 0D         LD H,(IX+13)
  63+ 621A ED 5B 14 64      LD DE,(BLIT_STRUCT+6)
  64+ 621E A7               AND A
  65+ 621F ED 52            SBC HL,DE
  66+ 6221 FD 6E 04         LD L,(IY+4)
  67+ 6224 FD 66 05         LD H,(IY+5)
  68+ 6227 DD 5E 08         LD E,(IX+8)
  69+ 622A DD 56 09         LD D,(IX+9)
  70+ 622D FA 4D 62         JP M,.L1
  71+ 6230                  ; equally high or IX defined one higher
  72+ 6230                  ; check upper boundary
  73+ 6230 19               ADD HL,DE
  74+ 6231 ED 5B 10 64      LD DE,(BLIT_STRUCT+2)
  75+ 6235 DD 4E 0C         LD C,(IX+12)
  76+ 6238 DD 46 0D         LD B,(IX+13)
  77+ 623B CD FC 61         CALL GENERIC_INNER_CHECK
  78+ 623E 30 29            JR NC,.INSIDE
  79+ 6240                  ; check lower boundary
  80+ 6240 E5               PUSH HL
  81+ 6241 2A 14 64         LD HL,(BLIT_STRUCT+6)
  82+ 6244 19               ADD HL,DE
  83+ 6245 EB               EX DE,HL
  84+ 6246 E1               POP HL
  85+ 6247 CD FC 61         CALL GENERIC_INNER_CHECK
  86+ 624A 30 1D            JR NC,.INSIDE
  87+ 624C C9               RET ; not overlapping
  88+ 624D              .L1:
  89+ 624D                  ; rectangle defined in BLIT_STRUCT is higher
  90+ 624D 19               ADD HL,DE
  91+ 624E EB               EX DE,HL
  92+ 624F 2A 10 64         LD HL,(BLIT_STRUCT+2)
  93+ 6252 ED 4B 14 64      LD BC,(BLIT_STRUCT+6)
  94+ 6256 CD FC 61         CALL GENERIC_INNER_CHECK
  95+ 6259 30 0E            JR NC,.INSIDE
  96+ 625B E5               PUSH HL
  97+ 625C DD 6E 0C         LD L,(IX+12)
  98+ 625F DD 66 0D         LD H,(IX+13)
  99+ 6262 19               ADD HL,DE
 100+ 6263 EB               EX DE,HL
 101+ 6264 E1               POP HL
 102+ 6265 CD FC 61         CALL GENERIC_INNER_CHECK
 103+ 6268 D8               RET C
 104+ 6269              .INSIDE:
 105+ 6269                  ; check x coordinate
 106+ 6269                  ; first check which rectangle is wider
 107+ 6269 DD 6E 0A         LD L,(IX+10)
 108+ 626C DD 66 0B         LD H,(IX+11)
 109+ 626F ED 5B 12 64      LD DE,(BLIT_STRUCT+4)
 110+ 6273 A7               AND A
 111+ 6274 ED 52            SBC HL,DE
 112+ 6276 FD 6E 02         LD L,(IY+2)
 113+ 6279 FD 66 03         LD H,(IY+3)
 114+ 627C DD 5E 06         LD E,(IX+6)
 115+ 627F DD 56 07         LD D,(IX+7)
 116+ 6282 FA 9E 62         JP M,.L2
 117+ 6285                  ; equally wide or IX defined one wider
 118+ 6285                  ; check left boundary
 119+ 6285 19               ADD HL,DE
 120+ 6286 ED 5B 0E 64      LD DE,(BLIT_STRUCT+0)
 121+ 628A DD 4E 0A         LD C,(IX+10)
 122+ 628D DD 46 0B         LD B,(IX+11)
 123+ 6290 CD FC 61         CALL GENERIC_INNER_CHECK
 124+ 6293 D0               RET NC ; overlap
 125+ 6294                  ; check right boundary
 126+ 6294 E5               PUSH HL
 127+ 6295 2A 12 64         LD HL,(BLIT_STRUCT+4)
 128+ 6298 19               ADD HL,DE
 129+ 6299 EB               EX DE,HL
 130+ 629A E1               POP HL
 131+ 629B C3 FC 61         JP GENERIC_INNER_CHECK ; CF and result set by fn call
 132+ 629E              .L2:
 133+ 629E                  ; rectangle defined in BLIT_STRUCT is higher
 134+ 629E 19               ADD HL,DE
 135+ 629F EB               EX DE,HL
 136+ 62A0 2A 0E 64         LD HL,(BLIT_STRUCT+0)
 137+ 62A3 ED 4B 12 64      LD BC,(BLIT_STRUCT+4)
 138+ 62A7 CD FC 61         CALL GENERIC_INNER_CHECK
 139+ 62AA D0               RET NC ; overlap
 140+ 62AB E5               PUSH HL
 141+ 62AC DD 6E 0A         LD L,(IX+10)
 142+ 62AF DD 66 0B         LD H,(IX+11)
 143+ 62B2 19               ADD HL,DE
 144+ 62B3 EB               EX DE,HL
 145+ 62B4 E1               POP HL
 146+ 62B5 C3 FC 61         JP GENERIC_INNER_CHECK
 147+ 62B8              ; ************************************************************************************************
 148+ 62B8
 149+ 62B8              ; ************************************************************************************************
 150+ 62B8              ; function tries to find rectangle overlap and returns an index if found
 151+ 62B8              ; input BLIT_STRUCT data
 152+ 62B8              ;  +00 x coordinate
 153+ 62B8              ;  +02 y coordinate
 154+ 62B8              ;  +04 width
 155+ 62B8              ;  +06 height
 156+ 62B8              ;  +08 number of items in a list, described under RECTANGLE_OVERLAP_CHECK
 157+ 62B8              ;  +09 pointer to first element of R%(7,n)
 158+ 62B8              ;  +11 pointer to INT result variable
 159+ 62B8              ; returns CF=1 if not overlapping
 160+ 62B8              ; returns A=list index and CF=0 if overlapping
 161+ 62B8              FIND_OVERLAP:
 162+ 62B8 3A 16 64         LD A,(BLIT_STRUCT+8)
 163+ 62BB 47               LD B,A
 164+ 62BC DD 2A 17 64      LD IX,(BLIT_STRUCT+9)
 165+ 62C0              .L1:
 166+ 62C0 C5               PUSH BC
 167+ 62C1                  ; check active flag
 168+ 62C1 DD 7E 00         LD A,(IX)
 169+ 62C4 DD B6 01         OR (IX+1)
 170+ 62C7 28 18            JR Z,.NEXT
 171+ 62C9                  ; check type
 172+ 62C9 DD 7E 0E         LD A,(IX+14)
 173+ 62CC DD B6 0F         OR (IX+15)
 174+ 62CF 20 1A            JR NZ,.L2
 175+ 62D1 DD E5            PUSH IX
 176+ 62D3 FD E1            POP IY
 177+ 62D5              .L3:
 178+ 62D5 CD 14 62         CALL RECTANGLE_OVERLAP_CHECK
 179+ 62D8 38 07            JR C,.NEXT
 180+ 62DA                  ; found
 181+ 62DA C1               POP BC
 182+ 62DB 3A 16 64         LD A,(BLIT_STRUCT+8)
 183+ 62DE 90               SUB B
 184+ 62DF A7               AND A
 185+ 62E0 C9               RET
 186+ 62E1              .NEXT:
 187+ 62E1 11 10 00         LD DE,16
 188+ 62E4 DD 19            ADD IX,DE
 189+ 62E6 C1               POP BC
 190+ 62E7 10 D7            DJNZ .L1
 191+ 62E9 37               SCF
 192+ 62EA C9               RET
 193+ 62EB              .L2:
 194+ 62EB                  ; sprite, need to build a temporary data struct since x and y values are inversed
 195+ 62EB                  ; at BLIT_STRUCT+13
 196+ 62EB DD 7E 02         LD A,(IX+2) ; sprite ID
 197+ 62EE CD 89 4D         CALL GETnthSPRATTR
 198+ 62F1 FD 21 19 64      LD IY,BLIT_STRUCT+11
 199+ 62F5 7E               LD A,(HL)
 200+ 62F6 FD 77 04         LD (IY+4),A
 201+ 62F9 23               INC HL
 202+ 62FA 7E               LD A,(HL)
 203+ 62FB FD 77 05         LD (IY+5),A
 204+ 62FE 23               INC HL
 205+ 62FF 7E               LD A,(HL)
 206+ 6300 FD 77 02         LD (IY+2),A
 207+ 6303 23               INC HL
 208+ 6304 7E               LD A,(HL)
 209+ 6305 FD 77 03         LD (IY+3),A
 210+ 6308 18 CB            JR .L3
 211+ 630A              ; ************************************************************************************************
 212+ 630A
 213+ 630A               IF (BASIC_EXTENSION == 1)
 214+ 630A              ; ************************************************************************************************
 215+ 630A              ; function to handle CALL COLL basic extension
 216+ 630A              ; checks for collision between player and other rectangles
 217+ 630A              ; COLL ( INT result variable,
 218+ 630A              ;	     INT player x value,
 219+ 630A              ;	     INT player y value,
 220+ 630A              ;	     INT player width,
 221+ 630A              ;	     INT player height,
 222+ 630A              ;	     INT number of items in a list,
 223+ 630A              ;		 INT[6][n] rectangle struct )
 224+ 630A              ; will fill result variable with index or -1 if no collision
 225+ 630A              ; rectangle struct described under RECTANGLE_OVERLAP_CHECK
 226+ 630A              COLL:
 227+ 630A              	; opening (
 228+ 630A CD 13 67     	CALL CHKCHAR
 229+ 630D 28           	DB '('
 230+ 630E              	; get address of result variable
 231+ 630E DD 21 A4 5E  	LD IX, PTRGET
 232+ 6312 CD 59 01     	CALL CALBAS
 233+ 6315 ED 53 19 64  	LD (BLIT_STRUCT+11),DE
 234+ 6319              	; comma
 235+ 6319 CD 13 67     	CALL CHKCHAR
 236+ 631C 2C           	DB ','
 237+ 631D              	; get x
 238+ 631D DD 21 2F 54  	LD IX, FRMQNT
 239+ 6321 CD 59 01     	CALL CALBAS
 240+ 6324 ED 53 0E 64  	LD (BLIT_STRUCT+0),DE
 241+ 6328              	; comma
 242+ 6328 CD 13 67     	CALL CHKCHAR
 243+ 632B 2C           	DB ','
 244+ 632C              	; get y
 245+ 632C DD 21 2F 54  	LD IX, FRMQNT
 246+ 6330 CD 59 01     	CALL CALBAS
 247+ 6333 ED 53 10 64  	LD (BLIT_STRUCT+2),DE
 248+ 6337              	; comma
 249+ 6337 CD 13 67     	CALL CHKCHAR
 250+ 633A 2C           	DB ','
 251+ 633B              	; get width
 252+ 633B DD 21 2F 54  	LD IX, FRMQNT
 253+ 633F CD 59 01     	CALL CALBAS
 254+ 6342 ED 53 12 64  	LD (BLIT_STRUCT+4),DE
 255+ 6346              	; comma
 256+ 6346 CD 13 67     	CALL CHKCHAR
 257+ 6349 2C           	DB ','
 258+ 634A              	; get height
 259+ 634A DD 21 2F 54  	LD IX, FRMQNT
 260+ 634E CD 59 01     	CALL CALBAS
 261+ 6351 ED 53 14 64  	LD (BLIT_STRUCT+6),DE
 262+ 6355              	; comma
 263+ 6355 CD 13 67     	CALL CHKCHAR
 264+ 6358 2C           	DB ','
 265+ 6359              	; get number of items in a list
 266+ 6359 DD 21 1C 52  	LD IX, GETBYT
 267+ 635D CD 59 01     	CALL CALBAS
 268+ 6360 32 16 64     	LD (BLIT_STRUCT+8),A
 269+ 6363              	; comma
 270+ 6363 CD 13 67     	CALL CHKCHAR
 271+ 6366 2C           	DB ','
 272+ 6367              	; get address of rectangle structure array DIM R%(7,n)
 273+ 6367 3A 16 64     	LD A,(BLIT_STRUCT+8)
 274+ 636A 5F               LD E,A
 275+ 636B 3E 02            LD A,2
 276+ 636D 47           	LD B,A
 277+ 636E 16 07        	LD D,7
 278+ 6370 CD 40 67     	CALL GET_BASIC_ARRAY_DATA_POINTER
 279+ 6373 ED 43 17 64  	LD (BLIT_STRUCT+9),BC
 280+ 6377              	; ending )
 281+ 6377 CD 13 67     	CALL CHKCHAR
 282+ 637A 29           	DB ')'
 283+ 637B
 284+ 637B E5               PUSH HL
 285+ 637C CD B8 62         CALL FIND_OVERLAP
 286+ 637F 2A 19 64         LD HL,(BLIT_STRUCT+11)
 287+ 6382 38 06            JR C,.NOTFOUND
 288+ 6384 77               LD (HL),A
 289+ 6385 23               INC HL
 290+ 6386 36 00            LD (HL),0
 291+ 6388 E1               POP HL
 292+ 6389 C9               RET
 293+ 638A              .NOTFOUND:
 294+ 638A 36 FF            LD (HL),#FF
 295+ 638C 23               INC HL
 296+ 638D 36 FF            LD (HL),#FF
 297+ 638F E1               POP HL
 298+ 6390 C9               RET
 299+ 6391              ; ************************************************************************************************
 300+ 6391               ENDIF
 301+ 6391
 302+ 6391               IF (DEFUSR_EXTENSION == 1)
 303+ 6391              ; *******************************************************************************************************
 304+ 6391              ; same as COLL but for DEFUSR approach
 305+ 6391              ; input IX=pointer to input array, real data from +2
 306+ 6391              ; +02 = pointer to result variable
 307+ 6391              ; +04 = player X
 308+ 6391              ; +06 = player Y
 309+ 6391              ; +08 = player width
 310+ 6391              ; +10 = player height
 311+ 6391              ; +12 = number of list items
 312+ 6391              ; +14 = pointer to list of collidable objects
 313+ 6391              COLL_DEFUSR:
 314+ 6391 DD E5            PUSH IX
 315+ 6393 E1               POP HL
 316+ 6394 23          > INC HL ; skip over to player x
 316+ 6395 23          > INC HL
 316+ 6396 23          > INC HL
 316+ 6397 23          > INC HL
 317+ 6398 11 0E 64         LD DE,BLIT_STRUCT
 318+ 639B 01 09 00         LD BC,9
 319+ 639E ED B0            LDIR ; copy over x,y,w,h,list item number
 320+ 63A0 DD 7E 0E         LD A,(IX+14)
 321+ 63A3 32 17 64         LD (BLIT_STRUCT+9),A
 322+ 63A6 DD 7E 0F         LD A,(IX+15)
 323+ 63A9 32 18 64         LD (BLIT_STRUCT+10),A ; address to collidable objects array
 324+ 63AC DD 7E 02         LD A,(IX+2)
 325+ 63AF 32 19 64         LD (BLIT_STRUCT+11),A
 326+ 63B2 DD 7E 03         LD A,(IX+3)
 327+ 63B5 32 1A 64         LD (BLIT_STRUCT+12),A ; address to results variable
 328+ 63B8 DD E5            PUSH IX
 329+ 63BA CD B8 62         CALL FIND_OVERLAP
 330+ 63BD DD E1            POP IX
 331+ 63BF DD 6E 02         LD L,(IX+2)
 332+ 63C2 DD 66 03         LD H,(IX+3)
 333+ 63C5 38 05            JR C,.NOTFOUND
 334+ 63C7 77               LD (HL),A
 335+ 63C8 23               INC HL
 336+ 63C9 36 00            LD (HL),0
 337+ 63CB C9               RET
 338+ 63CC              .NOTFOUND:
 339+ 63CC 36 FF            LD (HL),#FF
 340+ 63CE 23               INC HL
 341+ 63CF 36 FF            LD (HL),#FF
 342+ 63D1 C9               RET
 343+ 63D2              ; *******************************************************************************************************
 344+ 63D2               ENDIF
 345+ 63D2
# file closed: asm\COLLISION.asm
 167  63D2               ENDIF
 168  63D2
 169  63D2               IF (DEFUSR_EXTENSION == 1)
 170  63D2               INCLUDE "DEFUSR.asm"
# file opened: asm\DEFUSR.asm
   1+ 63D2              ; entry function that handles call using CALLF
   2+ 63D2              ; pointer to data structure is expected at DAC+2
   3+ 63D2              ; first entry must be function id followed by function specific parameters
   4+ 63D2
   5+ 63D2              DEFUSR_TABLE_ENTRIES    EQU 15
   6+ 63D2
   7+ 63D2              DEFUSR_JUMP_TABLE:
   8+ 63D2               IF (SPRITE_CMDS == 1)
   9+ 63D2 B5 4E         DW SPRENABLE_DEFUSR        ; 0
  10+ 63D4               ELSE
  11+ 63D4 ~             DW NOACTION_DEFUSR
  12+ 63D4               ENDIF
  13+ 63D4
  14+ 63D4               IF (SPRITE_CMDS == 1)
  15+ 63D4 D5 4E         DW SPRDISABLE_DEFUSR        ; 1
  16+ 63D6               ELSE
  17+ 63D6 ~             DW NOACTION_DEFUSR
  18+ 63D6               ENDIF
  19+ 63D6
  20+ 63D6               IF (RAM_CMDS == 1)
  21+ 63D6 42 59         DW MEMCPY_DEFUSR           ; 2
  22+ 63D8               ELSE
  23+ 63D8 ~             DW NOACTION_DEFUSR
  24+ 63D8               ENDIF
  25+ 63D8
  26+ 63D8               IF (VRAM_CMDS == 1)        ; 3
  27+ 63D8 65 5B         DW MEMVRM_DEFUSR
  28+ 63DA               ELSE
  29+ 63DA ~             DW NOACTION_DEFUSR
  30+ 63DA               ENDIF
  31+ 63DA
  32+ 63DA               IF (BLIT_CMDS == 1)        ; 4
  33+ 63DA EE 5E         DW BLIT_DEFUSR
  34+ 63DC               ELSE
  35+ 63DC ~             DW NOACTION_DEFUSR
  36+ 63DC               ENDIF
  37+ 63DC
  38+ 63DC               IF (ANIM_CMDS == 1)        ; 5
  39+ 63DC D5 57         DW SGAM_DEFUSR
  40+ 63DE               ELSE
  41+ 63DE ~             DW NOACTION_DEFUSR
  42+ 63DE               ENDIF
  43+ 63DE
  44+ 63DE               IF (SPRITE_CMDS == 1)
  45+ 63DE 7A 4F         DW SPRGRPMOV_DEFUSR        ; 6
  46+ 63E0               ELSE
  47+ 63E0 ~             DW NOACTION_DEFUSR
  48+ 63E0               ENDIF
  49+ 63E0
  50+ 63E0               IF (COLL_CMD == 1)
  51+ 63E0 91 63         DW COLL_DEFUSR             ; 7
  52+ 63E2               ELSE
  53+ 63E2 ~             DW NOACTION_DEFUSR
  54+ 63E2               ENDIF
  55+ 63E2
  56+ 63E2               IF (SOUND_CMDS == 1)
  57+ 63E2 9C 5A         DW SNDSFX_DEFUSR             ; 8
  58+ 63E4               ELSE
  59+ 63E4 ~             DW NOACTION_DEFUSR
  60+ 63E4               ENDIF
  61+ 63E4
  62+ 63E4               IF (ANIM_CMDS == 1)
  63+ 63E4 C2 55         DW ANIMSTEP_SINGLE_DEFUSR      ; 9
  64+ 63E6 D2 55         DW ANIMSTEP_MULTI_DEFUSR       ; 10
  65+ 63E8 E3 55         DW ANIMSTART_SINGLE_DEFUSR     ; 11
  66+ 63EA F5 55         DW ANIMSTART_MULTI_DEFUSR      ; 12
  67+ 63EC FA 55         DW ANIMSTOP_SINGLE_DEFUSR      ; 13
  68+ 63EE 04 56         DW ANIMSTOP_MULTI_DEFUSR       ; 14
  69+ 63F0               ELSE
  70+ 63F0 ~             DW NOACTION_DEFUSR
  71+ 63F0 ~             DW NOACTION_DEFUSR
  72+ 63F0 ~             DW NOACTION_DEFUSR
  73+ 63F0 ~             DW NOACTION_DEFUSR
  74+ 63F0 ~             DW NOACTION_DEFUSR
  75+ 63F0 ~             DW NOACTION_DEFUSR
  76+ 63F0               ENDIF
  77+ 63F0
  78+ 63F0              DEFUSR_ENTRY:
  79+ 63F0 FB               EI
  80+ 63F1 DD 2A F8 F7      LD IX,(DAC+2)
  81+ 63F5 DD 7E 00         LD A,(IX)
  82+ 63F8 FE 0F            CP DEFUSR_TABLE_ENTRIES
  83+ 63FA D0               RET NC ; return if an undefined function requested
  84+ 63FB 26 00            LD H,0
  85+ 63FD 6F               LD L,A
  86+ 63FE 29               ADD HL,HL
  87+ 63FF 11 D2 63         LD DE,DEFUSR_JUMP_TABLE
  88+ 6402 19               ADD HL,DE
  89+ 6403 EB               EX DE,HL
  90+ 6404 1A               LD A,(DE)
  91+ 6405 6F               LD L,A
  92+ 6406 13               INC DE
  93+ 6407 1A               LD A,(DE)
  94+ 6408 67               LD H,A
  95+ 6409 E9               JP (HL) ; call function with IX=pointer to data array
  96+ 640A
# file closed: asm\DEFUSR.asm
 171  640A               ENDIF
 172  640A
 173  640A              ; temp variables for BLIT, TILE functions
 174  640A               IF (BLIT_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS + COLL_CMD > 0)
 175  640A              BLIT_TMP:
 176  640A              TILETMP1:
 177  640A              BLIT_TMP1:
 178  640A 00 00         DW 0
 179  640C              TILETMP2:
 180  640C              BLIT_TMP2:
 181  640C 00 00         DW 0
 182  640E                IFDEF CMDS_WITH_PARAMETERS
 183  640E              BLIT_STRUCT:
 184  640E 00 00 00...   DS 17
 185  6412                ENDIF
 186  6412               ENDIF
 187  641F
 188  641F               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 189  641F              VRAM_UPDATE_IN_PROGRESS:
 190  641F 00            DB 0
 191  6420               ENDIF
 192  6420
 193  6420              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 194  6420              ; per starting letter, if no commands with this letter, NULL value
 195  6420              CMDS:
 196  6420               IF (ANIM_CMDS == 1)
 197  6420 56 65        	DW CMDS_A ;
 198  6422               ELSE
 199  6422 ~                DW 0 ; A
 200  6422               ENDIF
 201  6422               IF (BLIT_CMDS + BOX_CMDS > 0)
 202  6422 21 65            DW CMDS_B ; B
 203  6424               ELSE
 204  6424 ~            	DW 0
 205  6424               ENDIF
 206  6424               IF (COLL_CMD == 1)
 207  6424 E4 65        	DW CMDS_C ;
 208  6426               ELSE
 209  6426 ~                DW 0 ; C
 210  6426               ENDIF
 211  6426 00 00            DW 0 ; D
 212  6428 00 00            DW 0 ; E
 213  642A               IF (VRAM_CMDS + RAM_CMDS > 0)
 214  642A A1 64            DW CMDS_F; F
 215  642C               ELSE
 216  642C ~            	DW 0
 217  642C               ENDIF
 218  642C               IF (GENCAL_CMD > 0)
 219  642C B4 64            DW CMDS_G; G
 220  642E               ELSE
 221  642E ~            	DW 0
 222  642E               ENDIF
 223  642E 00 00            DW 0 ; H
 224  6430 00 00            DW 0 ; I
 225  6432 00 00            DW 0 ; J
 226  6434 00 00            DW 0 ; K
 227  6436 00 00            DW 0 ; L
 228  6438               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 229  6438 54 64            DW CMDS_M ; M
 230  643A               ELSE
 231  643A ~            	DW 0
 232  643A               ENDIF
 233  643A 00 00            DW 0 ; N
 234  643C 00 00            DW 0 ; O
 235  643E 00 00            DW 0 ; P
 236  6440 00 00            DW 0 ; Q
 237  6442 00 00            DW 0 ; R
 238  6444               IF (SOUND_CMDS + SPRITE_CMDS > 0)
 239  6444 C8 64            DW CMDS_S ; S
 240  6446               ELSE
 241  6446 ~            	DW 0
 242  6446               ENDIF
 243  6446               IF (TILE_CMDS > 0)
 244  6446 41 65            DW CMDS_T ; T
 245  6448               ELSE
 246  6448 ~            	DW 0
 247  6448               ENDIF
 248  6448 00 00            DW 0 ; U
 249  644A               IF (VRAM_CMDS > 0)
 250  644A BE 64            DW CMDS_V ; V
 251  644C               ELSE
 252  644C ~            	DW 0
 253  644C               ENDIF
 254  644C 00 00            DW 0 ; W
 255  644E 00 00            DW 0 ; X
 256  6450 00 00            DW 0 ; Y
 257  6452 00 00            DW 0 ; Z
 258  6454
 259  6454              CMDS_M:
 260  6454               IF (VRAM_CMDS == 1)
 261  6454 4D 45 4D 56      DB "MEMVRM", 0
 261  6458 52 4D 00
 262  645B 0F 5B            DW MEMVRM
 263  645D               ENDIF
 264  645D               IF (RAM_CMDS == 1)
 265  645D 4D 45 4D 43  	DB "MEMCPY", 0
 265  6461 50 59 00
 266  6464 FE 58        	DW MEMCPY
 267  6466               ENDIF
 268  6466               IF (ANIM_CMDS == 1)
 269  6466 4D 41 58 41  	DB "MAXANIMITEMS",0
 269  646A 4E 49 4D 49
 269  646E 54 45 4D 53
 269  6472 00
 270  6473 DA 4F        	DW MAXANIMITEMS
 271  6475 4D 41 58 41  	DB "MAXANIMDEFS",0
 271  6479 4E 49 4D 44
 271  647D 45 46 53 00
 272  6481 6A 51        	DW MAXANIMDEFS
 273  6483 4D 41 58 41  	DB "MAXANIMSPRS",0
 273  6487 4E 49 4D 53
 273  648B 50 52 53 00
 274  648F 00 52        	DW MAXANIMSPRS
 275  6491 4D 41 58 41     DB "MAXAUTOSGAMS",0
 275  6495 55 54 4F 53
 275  6499 47 41 4D 53
 275  649D 00
 276  649E 4A 53           DW MAXAUTOSGAMS
 277  64A0               ENDIF
 278  64A0               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 279  64A0 00           	DB 0
 280  64A1               ENDIF
 281  64A1              CMDS_F:
 282  64A1               IF (VRAM_CMDS == 1)
 283  64A1 46 49 4C 56      DB "FILVRM", 0
 283  64A5 52 4D 00
 284  64A8 C0 5A            DW FILVRM
 285  64AA               ENDIF
 286  64AA               IF (RAM_CMDS == 1)
 287  64AA 46 49 4C 52      DB "FILRAM", 0
 287  64AE 41 4D 00
 288  64B1 64 59            DW FILRAM
 289  64B3               ENDIF
 290  64B3               IF (VRAM_CMDS + RAM_CMDS > 0)
 291  64B3 00               DB 0
 292  64B4               ENDIF
 293  64B4              CMDS_G:
 294  64B4               IF (GENCAL_CMD == 1)
 295  64B4 47 45 4E 43      DB "GENCAL", 0
 295  64B8 41 4C 00
 296  64BB 1B 5C            DW GENCAL
 297  64BD               ENDIF
 298  64BD               IF (GENCAL_CMD > 0)
 299  64BD 00           	DB	0
 300  64BE               ENDIF
 301  64BE              CMDS_V:
 302  64BE               IF (VRAM_CMDS == 1)
 303  64BE 56 52 4D 4D  	DB "VRMMEM", 0
 303  64C2 45 4D 00
 304  64C5 B9 5B        	DW VRMMEM
 305  64C7               ENDIF
 306  64C7               IF (VRAM_CMDS > 0)
 307  64C7 00           	DB 0
 308  64C8               ENDIF
 309  64C8              CMDS_S:
 310  64C8               IF (SPRITE_CMDS + ANIM_CMDS > 0)
 311  64C8 53 47 41 4D      DB "SGAM",0
 311  64CC 00
 312  64CD 31 57            DW SGAM
 313  64CF               ENDIF
 314  64CF               IF (SPRITE_CMDS == 1)
 315  64CF 53 50 52 47  	DB "SPRGRPMOV", 0
 315  64D3 52 50 4D 4F
 315  64D7 56 00
 316  64D9 18 4F        	DW SPRGRPMOV
 317  64DB               ENDIF
 318  64DB               IF (SOUND_CMDS == 1)
 319  64DB 53 4E 44 53  	DB "SNDSFX", 0
 319  64DF 46 58 00
 320  64E2 42 5A        	DW SNDSFX
 321  64E4 53 4E 44 50  	DB "SNDPLYON", 0
 321  64E8 4C 59 4F 4E
 321  64EC 00
 322  64ED 0C 5A        	DW SNDPLYON
 323  64EF 53 4E 44 50  	DB "SNDPLYOFF", 0
 323  64F3 4C 59 4F 46
 323  64F7 46 00
 324  64F9 1F 5A        	DW SNDPLYOFF
 325  64FB 53 4E 44 50  	DB "SNDPLYINI", 0
 325  64FF 4C 59 49 4E
 325  6503 49 00
 326  6505 C2 59        	DW SNDPLYINIT
 327  6507               ENDIF
 328  6507               IF (SPRITE_CMDS == 1)
 329  6507 53 50 52 45  	DB "SPRENABLE", 0
 329  650B 4E 41 42 4C
 329  650F 45 00
 330  6511 6E 4E        	DW SPRENABLE
 331  6513 53 50 52 44  	DB "SPRDISABLE", 0
 331  6517 49 53 41 42
 331  651B 4C 45 00
 332  651E D5 4E        	DW SPRDISABLE
 333  6520               ENDIF
 334  6520               IF (SOUND_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 335  6520 00           	DB 0
 336  6521               ENDIF
 337  6521              CMDS_B:
 338  6521               IF (BLIT_CMDS == 1)
 339  6521 42 4C 49 54  	DB "BLIT", 0
 339  6525 00
 340  6526 03 5F        	DW BLIT
 341  6528               ENDIF
 342  6528               IF (BOX_CMDS == 1)
 343  6528 42 4F 58 4D  	DB "BOXMEMCPY", 0
 343  652C 45 4D 43 50
 343  6530 59 00
 344  6532 AA 5C        	DW BOXMEMCPY
 345  6534 42 4F 58 4D  	DB "BOXMEMVRM", 0
 345  6538 45 4D 56 52
 345  653C 4D 00
 346  653E 40 5D        	DW BOXMEMVRM
 347  6540               ENDIF
 348  6540               IF (BLIT_CMDS + BOX_CMDS > 0)
 349  6540 00           	DB 0
 350  6541               ENDIF
 351  6541              CMDS_T:
 352  6541               IF (TILE_CMDS == 1)
 353  6541 54 49 4C 45  	DB "TILERAM", 0
 353  6545 52 41 4D 00
 354  6549 39 60        	DW TILERAM
 355  654B 54 49 4C 45  	DB "TILEVRM", 0
 355  654F 56 52 4D 00
 356  6553 3D 61        	DW TILEVRM
 357  6555               ENDIF
 358  6555               IF (TILE_CMDS > 0)
 359  6555 00           	DB 0
 360  6556               ENDIF
 361  6556              CMDS_A:
 362  6556               IF (ANIM_CMDS == 1)
 363  6556 41 4E 49 4D     DB "ANIMSTEP",0
 363  655A 53 54 45 50
 363  655E 00
 364  655F 1D 55           DW ANIMSTEP
 365  6561 41 4E 49 4D  	DB "ANIMSTART",0
 365  6565 53 54 41 52
 365  6569 54 00
 366  656B 22 55        	DW ANIMSTART
 367  656D 41 4E 49 4D  	DB "ANIMSTOP",0
 367  6571 53 54 4F 50
 367  6575 00
 368  6576 27 55        	DW ANIMSTOP
 369  6578 41 4E 49 4D  	DB "ANIMITEMPAT",0
 369  657C 49 54 45 4D
 369  6580 50 41 54 00
 370  6584 AB 50        	DW ANIMITEMPAT
 371  6586 41 4E 49 4D  	DB "ANIMITEMPTR",0
 371  658A 49 54 45 4D
 371  658E 50 54 52 00
 372  6592 11 51        	DW ANIMITEMPTR_CMD
 373  6594 41 4E 49 4D  	DB "ANIMDEF",0
 373  6598 44 45 46 00
 374  659C AD 51        	DW ANIMDEF
 375  659E 41 4E 49 4D  	DB "ANIMSPRITE",0
 375  65A2 53 50 52 49
 375  65A6 54 45 00
 376  65A9 59 52        	DW ANIMSPRITE
 377  65AB 41 4E 49 4D     DB "ANIMCHAR",0
 377  65AF 43 48 41 52
 377  65B3 00
 378  65B4 D1 52           DW ANIMCHAR
 379  65B6 41 55 54 4F     DB "AUTOSGAMDEF",0
 379  65BA 53 47 41 4D
 379  65BE 44 45 46 00
 380  65C2 A7 53           DW AUTOSGAMDEF
 381  65C4 41 55 54 4F     DB "AUTOSGAMSTART",0
 381  65C8 53 47 41 4D
 381  65CC 53 54 41 52
 381  65D0 54 00
 382  65D2 DE 54           DW AUTOSGAMSTART
 383  65D4 41 55 54 4F     DB "AUTOSGAMSTOP",0
 383  65D8 53 47 41 4D
 383  65DC 53 54 4F 50
 383  65E0 00
 384  65E1 1A 55           DW AUTOSGAMSTOP
 385  65E3 00           	DB 0
 386  65E4               ENDIF
 387  65E4              CMDS_C:
 388  65E4               IF (COLL_CMD == 1)
 389  65E4 43 4F 4C 4C      DB "COLL", 0
 389  65E8 00
 390  65E9 0A 63            DW COLL
 391  65EB               ENDIF
 392  65EB               IF (COLL_CMD > 0)
 393  65EB 00           	DB	0
 394  65EC               ENDIF
 395  65EC
 396  65EC               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 397  65EC              ; ****************************************************************************************************
 398  65EC              ; function sets VRAM address
 399  65EC              ; input HL=address
 400  65EC              ; modifies AF
 401  65EC              SETWRT_LOCAL:
 402  65EC 7D           	LD	A, L
 403  65ED D3 99        	OUT	(099H), A
 404  65EF 7C           	LD	A, H
 405  65F0 E6 3F        	AND	03FH
 406  65F2 F6 40        	OR	040H
 407  65F4 D3 99        	OUT	(099H), A
 408  65F6 C9           	RET
 409  65F7              ; ****************************************************************************************************
 410  65F7               ENDIF
 411  65F7
 412  65F7               IF (VRAM_CMDS + TILE_CMDS > 0)
 413  65F7              ; ****************************************************************************************************
 414  65F7              ; function copies data from RAM to VRAM
 415  65F7              ; input HL=address in RAM
 416  65F7              ; input B=count
 417  65F7              ; modifies AF, BC, HL
 418  65F7              BBYTECOPY:
 419  65F7 0E 98        	LD C,#98
 420  65F9              BBYTECOPY_NO_C:
 421  65F9 ED A3        	OUTI
 422  65FB C2 F9 65     	JP	NZ, BBYTECOPY_NO_C
 423  65FE C9           	RET
 424  65FF              ; ****************************************************************************************************
 425  65FF               ENDIF
 426  65FF
 427  65FF              ; ****************************************************************************************************
 428  65FF              ; function multiplies HL by 32
 429  65FF              HLx32:
 430  65FF 29           	ADD HL,HL
 431  6600              ; ****************************************************************************************************
 432  6600              ; function multiplies HL by 16
 433  6600              HLx16:
 434  6600 29           	ADD HL,HL
 435  6601              ; ****************************************************************************************************
 436  6601              ; function multiplies HL by 8
 437  6601              HLx8:
 438  6601 29          > ADD HL, HL
 438  6602 29          > ADD HL, HL
 438  6603 29          > ADD HL, HL
 439  6604 C9           	RET
 440  6605              ; ****************************************************************************************************
 441  6605
 442  6605              ; ****************************************************************************************************
 443  6605              ; function gets slot and subslot data for specific page
 444  6605              ; input A=page (0, 1 or 2)
 445  6605              ; output B = 0A8H register value
 446  6605              ; output D = 0 is no subslots, 1 if yes
 447  6605              ; output C = 0A8H value when page 3 slot equals to requested page slot
 448  6605              ; output E = subslot value if present
 449  6605              ; modifies AF, BC, DE, HL
 450  6605              GET_PAGE_INFO:
 451  6605 6F               LD L, A
 452  6606 C6 C1            ADD A, low (EXPTBL)
 453  6608 32 12 66         LD (GET_PAGE_INFO_L1+1), A
 454  660B DB A8            IN A, (0A8H)
 455  660D 47               LD B, A
 456  660E E6 3F            AND 03FH
 457  6610 4F               LD C, A
 458  6611              GET_PAGE_INFO_L1:
 459  6611 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 460  6614 E6 80            AND 080H
 461  6616 28 1B            JR Z, GET_PAGE_INFO_L2
 462  6618                  ; expanded
 463  6618 2D               DEC L
 464  6619 FA 38 66         JP M, GET_PAGE_INFO_L3
 465  661C 2D               DEC L
 466  661D FA 36 66         JP M, GET_PAGE_INFO_L4
 467  6620                  ; page 2
 468  6620 07               RLCA
 469  6621 07               RLCA
 470  6622              GET_PAGE_INFO_L5:
 471  6622 E6 C0            AND 0C0H
 472  6624 B1               OR C
 473  6625 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 474  6627 4F               LD C, A
 475  6628 3A FF FF         LD A, (0FFFFH)
 476  662B 2F               CPL
 477  662C 5F               LD E, A
 478  662D 16 01            LD D, 1
 479  662F 78               LD A, B ; return stack
 480  6630 D3 A8            OUT (0A8H), A
 481  6632 C9               RET
 482  6633              GET_PAGE_INFO_L2:
 483  6633                  ; not expanded
 484  6633 16 00            LD D, 0
 485  6635 C9               RET
 486  6636              GET_PAGE_INFO_L4:
 487  6636                  ; page 1
 488  6636 0F               RRCA
 489  6637 0F               RRCA
 490  6638              GET_PAGE_INFO_L3:
 491  6638                  ; page 0
 492  6638 0F               RRCA
 493  6639 0F               RRCA
 494  663A 18 E6            JR GET_PAGE_INFO_L5
 495  663C              ; ****************************************************************************************************
 496  663C
 497  663C              ; ****************************************************************************************************
 498  663C              ; function returns original slot and subslot info
 499  663C              ; input B = 0A8H register value
 500  663C              ; input D = 0 is no subslots, 1 if yes
 501  663C              ; input C = 0A8H value when page 3 slot equals to requested page slot
 502  663C              ; input E = subslot value if present
 503  663C              ; modifies AF, disables interrupts
 504  663C              RESTORE_PAGE_INFO:
 505  663C 7A              LD A, D
 506  663D B7              OR A
 507  663E 28 08           JR Z, RESTORE_PAGE_INFO_L1
 508  6640 79              LD A, C
 509  6641 F3           	DI
 510  6642 D3 A8           OUT (0A8H), A
 511  6644 7B              LD A, E
 512  6645 32 FF FF        LD (0FFFFH), A
 513  6648              RESTORE_PAGE_INFO_L1:
 514  6648 78              LD A, B
 515  6649 D3 A8           OUT (0A8H), A
 516  664B              NOACTION_DEFUSR: ; just a safe RET for use when DEFUSR table has an empty entry
 517  664B C9              RET
 518  664C              ; ****************************************************************************************************
 519  664C
 520  664C              ; *******************************************************************************************************
 521  664C              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 522  664C              ; INPUT:  A = SLOT ID: EXXXSSPP
 523  664C              ; E = EXPANDED FLAG
 524  664C              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 525  664C              ; PP = PRIMARY SLOT NUMBER
 526  664C              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 527  664C              ; CHANGES: AF, BC, DE
 528  664C
 529  664C              LOCAL_ENASLT:
 530  664C CD 6C 66         CALL L0353
 531  664F FA 59 66         JP M, L0340
 532  6652 DB A8            IN A, (0A8H)
 533  6654 A1               AND C
 534  6655 B0               OR B
 535  6656 D3 A8            OUT (0A8H), A
 536  6658 C9               RET
 537  6659              L0340:
 538  6659 E5               PUSH HL
 539  665A CD 91 66         CALL L0378
 540  665D 4F               LD C, A
 541  665E 06 00            LD B, 0
 542  6660 7D               LD A, L
 543  6661 A4               AND H
 544  6662 B2               OR D
 545  6663 21 C5 FC         LD HL, 0FCC5H
 546  6666 09               ADD HL, BC
 547  6667 77               LD (HL), A
 548  6668 E1               POP HL
 549  6669 79               LD A, C
 550  666A 18 E0            JR LOCAL_ENASLT
 551  666C              L0353:
 552  666C F3               DI
 553  666D F5               PUSH AF
 554  666E 7C               LD A, H
 555  666F 07               RLCA
 556  6670 07               RLCA
 557  6671 E6 03            AND 3
 558  6673 5F               LD E, A
 559  6674 3E C0            LD A, 0C0H
 560  6676              L035D:
 561  6676 07               RLCA
 562  6677 07               RLCA
 563  6678 1D               DEC E
 564  6679 F2 76 66         JP P, L035D
 565  667C 5F               LD E, A
 566  667D 2F               CPL
 567  667E 4F               LD C, A
 568  667F F1               POP AF
 569  6680 F5               PUSH AF
 570  6681 E6 03            AND 3
 571  6683 3C               INC A
 572  6684 47               LD B, A
 573  6685 3E AB            LD A, 0ABH
 574  6687              L036E:
 575  6687 C6 55            ADD A, 055H
 576  6689 10 FC            DJNZ L036E
 577  668B 57               LD D, A
 578  668C A3               AND E
 579  668D 47               LD B, A
 580  668E F1               POP AF
 581  668F A7               AND A
 582  6690 C9               RET
 583  6691              L0378:
 584  6691 F5               PUSH AF
 585  6692 7A               LD A, D
 586  6693 E6 C0            AND 0C0H
 587  6695 4F               LD C, A
 588  6696 F1               POP AF
 589  6697 F5               PUSH AF
 590  6698 57               LD D, A
 591  6699 DB A8            IN A, (0A8H)
 592  669B 47               LD B, A
 593  669C E6 3F            AND 03FH
 594  669E B1               OR C
 595  669F D3 A8            OUT (0A8H), A
 596  66A1 7A               LD A, D
 597  66A2 0F               RRCA
 598  66A3 0F               RRCA
 599  66A4 E6 03            AND 3
 600  66A6 57               LD D, A
 601  66A7 3E AB            LD A, 0ABH
 602  66A9              L0390:
 603  66A9 C6 55            ADD A, 055H
 604  66AB 15               DEC D
 605  66AC F2 A9 66         JP P, L0390
 606  66AF A3               AND E
 607  66B0 57               LD D, A
 608  66B1 7B               LD A, E
 609  66B2 2F               CPL
 610  66B3 67               LD H, A
 611  66B4 3A FF FF         LD A, (0FFFFH)
 612  66B7 2F               CPL
 613  66B8 6F               LD L, A
 614  66B9 A4               AND H
 615  66BA B2               OR D
 616  66BB 32 FF FF         LD (0FFFFH), A
 617  66BE 78               LD A, B
 618  66BF D3 A8            OUT (0A8H), A
 619  66C1 F1               POP AF
 620  66C2 E6 03            AND 3
 621  66C4 C9               RET
 622  66C5              ; *******************************************************************************************************
 623  66C5
 624  66C5              ; *******************************************************************************************************
 625  66C5              ; some common code to activate page 0 and place values needed to restore original page on stack
 626  66C5              ; input IY=return address
 627  66C5              ENABLE_PAGE0:
 628  66C5 AF              XOR A
 629  66C6 CD 05 66        CALL GET_PAGE_INFO
 630  66C9 C5              PUSH BC
 631  66CA D5              PUSH DE
 632  66CB 3A 41 F3        LD A, (RAMAD0)
 633  66CE 26 00           LD H, 0
 634  66D0 CD 4C 66        CALL LOCAL_ENASLT
 635  66D3 FD E9        	JP (IY)
 636  66D5              ; *******************************************************************************************************
 637  66D5
 638  66D5              ; General BASIC CALL-instruction handler
 639  66D5              CALLHAND:
 640  66D5 FB              EI
 641  66D6 E5           	PUSH HL
 642  66D7 21 20 64     	LD	HL, CMDS ; pointer table based on starting letter
 643  66DA 3A 89 FD        LD A, (PROCNM)
 644  66DD D6 41           SUB 'A'
 645  66DF 87              ADD A, A
 646  66E0 16 00           LD D, 0
 647  66E2 5F              LD E, A
 648  66E3 19              ADD HL, DE
 649  66E4 5E              LD E, (HL)
 650  66E5 23              INC HL
 651  66E6 56              LD D, (HL)
 652  66E7 7A              LD A, D
 653  66E8 B3              OR E
 654  66E9 28 23           JR Z, .CMDNOTRECOGNIZED
 655  66EB EB              EX DE, HL
 656  66EC              .CHKCMD:
 657  66EC 11 89 FD     	LD	DE, PROCNM
 658  66EF              .LOOP:
 659  66EF 1A              LD	A,(DE)
 660  66F0 BE           	CP	(HL)
 661  66F1 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 662  66F3 13           	INC	DE
 663  66F4 23           	INC	HL
 664  66F5 A7           	AND	A
 665  66F6 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 666  66F8 5E           	LD	E,(HL)
 667  66F9 23           	INC	HL
 668  66FA 56           	LD	D,(HL)
 669  66FB E1           	POP	HL		; routine address
 670  66FC CD 1D 67     	CALL	GETPREVCHAR
 671  66FF CD 11 67     	CALL	.CALLDE		; Call routine
 672  6702 A7           	AND	A
 673  6703 C9           	RET
 674  6704
 675  6704              .TONEXTCMD:
 676  6704 0E FF        	LD	C,0FFH
 677  6706 AF           	XOR	A
 678  6707 ED B1        	CPIR			; Skip to end of instruction name
 679  6709 23           	INC	HL
 680  670A 23           	INC	HL		; Skip address
 681  670B BE           	CP	(HL)
 682  670C 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 683  670E              .CMDNOTRECOGNIZED:
 684  670E E1           	POP	HL
 685  670F 37              SCF
 686  6710 C9           	RET
 687  6711
 688  6711              .CALLDE:
 689  6711 D5           	PUSH	DE
 690  6712 C9           	RET
 691  6713
 692  6713              ;---------------------------
 693  6713
 694  6713              ;GETSTRPNT:
 695  6713              ; OUT:
 696  6713              ; HL = String Address
 697  6713              ; B  = Lenght
 698  6713              ;        LD      HL,(USR)
 699  6713              ;        LD      B,(HL)
 700  6713              ;        INC     HL
 701  6713              ;        LD      E,(HL)
 702  6713              ;        INC     HL
 703  6713              ;        LD      D,(HL)
 704  6713              ;        EX      DE,HL
 705  6713              ;        RET
 706  6713
 707  6713              ;EVALTXTPARAM:
 708  6713              ;	CALL	CHKCHAR
 709  6713              ;	DEFB	"("             ; Check for (
 710  6713              ;	LD	IX,FRMEVL
 711  6713              ;	CALL	CALBAS		; Evaluate expression
 712  6713              ;       LD      A,(VALTYP)
 713  6713              ;        CP      3               ; Text type?
 714  6713              ;        JP      NZ,TYPE_MISMATCH
 715  6713              ;        PUSH	HL
 716  6713              ;        LD	IX,FRESTR         ; Free the temporary string
 717  6713              ;        CALL	CALBAS
 718  6713              ;        POP	HL
 719  6713              ;	CALL	CHKCHAR
 720  6713              ;	DEFB	")"             ; Check for )
 721  6713              ;        RET
 722  6713
 723  6713
 724  6713              CHKCHAR:
 725  6713 CD 1D 67     	CALL	GETPREVCHAR	; Get previous basic char
 726  6716 E3           	EX	(SP),HL
 727  6717 BE           	CP	(HL) 	        ; Check if good char
 728  6718 20 1D        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 729  671A 23           	INC	HL
 730  671B E3           	EX	(SP),HL
 731  671C 23           	INC	HL		; Get next basic char
 732  671D
 733  671D              GETPREVCHAR:
 734  671D 2B           	DEC HL
 735  671E DD 21 66 46  	LD	IX,CHRGTR
 736  6722 CD 59 01     	CALL CALBAS
 737  6725 FB              EI
 738  6726 C9              RET
 739  6727
 740  6727
 741  6727              TYPE_MISMATCH:
 742  6727 1E 0D            LD E, 13 ; Type mismatch
 743  6729 18 0E            JR THROW_ERROR
 744  672B              SUBSCRIPT_OUT_OF_RANGE:
 745  672B 1E 09            LD E,9 ; subscript out of range
 746  672D 18 0A        	JR THROW_ERROR
 747  672F              OVERFLOW:
 748  672F 1E 06        	LD E,6
 749  6731 18 06        	JR THROW_ERROR
 750  6733              ILLEGAL_FUNCTION:
 751  6733 1E 05            LD E, 5 ; illegal function call
 752  6735 18 02            JR THROW_ERROR
 753  6737              SYNTAX_ERROR:
 754  6737 1E 02            LD E, 2 ; Syntax error
 755  6739              THROW_ERROR:
 756  6739 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 757  673D C3 59 01     	JP	CALBAS
 758  6740
 759  6740              ;---------------------------
 760  6740
 761  6740              ; *******************************************************************************************************
 762  6740              ; helper function to get pointer to BASIC array data
 763  6740              ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
 764  6740              ; input B=dimensions (1 or 2)
 765  6740              ; input D=minimal first dimension
 766  6740              ; input E=minimal second dimension, if applicable
 767  6740              ; returns BC=pointer to first data element
 768  6740              ; throws BASIC error if invalid type
 769  6740              GET_BASIC_ARRAY_DATA_POINTER:
 770  6740 D5           	PUSH DE
 771  6741 C5           	PUSH BC
 772  6742 F5           	PUSH AF
 773  6743 3E 01           LD A,1
 774  6745 32 A5 F6        LD (SUBFLG),A ; search for arrays only
 775  6748 DD 21 A4 5E  	LD IX, PTRGET
 776  674C CD 59 01     	CALL CALBAS
 777  674F AF              XOR A
 778  6750 32 A5 F6        LD (SUBFLG),A ; if not reset will cause syntax errors
 779  6753 3A 63 F6     	LD A,(VALTYP)
 780  6756 D1           	POP DE ; required type
 781  6757 BA           	CP D
 782  6758 C2 27 67     	JP NZ,TYPE_MISMATCH
 783  675B 0A           	LD A,(BC)
 784  675C 03           	INC BC
 785  675D D1           	POP DE ; required number of dimensions
 786  675E BA           	CP D
 787  675F C2 27 67     	JP NZ,TYPE_MISMATCH
 788  6762 D1           	POP DE ; required minimal array dimensions
 789  6763 3D           	DEC A
 790  6764 28 07        	JR Z,.ONE_DIMENSION
 791  6766              	; 2-dimension array
 792  6766 0A           	LD A,(BC)
 793  6767 03          > INC BC
 793  6768 03          > INC BC
 794  6769 BB           	CP E
 795  676A DA 2B 67     	JP C,SUBSCRIPT_OUT_OF_RANGE
 796  676D              .ONE_DIMENSION:
 797  676D 0A           	LD A,(BC)
 798  676E 03          > INC BC
 798  676F 03          > INC BC
 799  6770 BA           	CP D
 800  6771 DA 2B 67     	JP C,SUBSCRIPT_OUT_OF_RANGE
 801  6774 C9           	RET
 802  6775              ; *******************************************************************************************************
 803  6775
 804  6775              EXT_END:
 805  6775
# file closed: asm\main.asm
