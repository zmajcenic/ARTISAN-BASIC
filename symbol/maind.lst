# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		   EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000              COLL_CMD       EQU 1
  14  4000
  15  4000              ; what to compile, provided in sjasmplus command line
  16  4000              ;BASIC_EXTENSION   EQU 1
  17  4000              ;DEFUSR_EXTENSION  EQU 0
  18  4000
  19  4000              CHPUT   EQU    #A2
  20  4000              CALBAS  EQU		#159
  21  4000              ERRHAND EQU    #406F
  22  4000              FRMEVL  EQU    #4C64
  23  4000              FRESTR  EQU		#67D0
  24  4000              ; FRMQNT = formula quantificator
  25  4000              ; input HL=pointer to current program expression
  26  4000              ; output HL=next address
  27  4000              ; output DE=integer datum
  28  4000              FRMQNT	EQU		#542F
  29  4000              ; GETBYT = get byte parameter
  30  4000              ; input HL=pointer to current program expression
  31  4000              ; output HL=next address
  32  4000              ; output A=E=byte read
  33  4000              GETBYT		EQU	#521C
  34  4000              CHRGTR  	   EQU   #4666
  35  4000              PTRGET		EQU 	#5EA4
  36  4000              SUBFLG		EQU	#F6A5
  37  4000              SYNCHR		EQU	#558C
  38  4000              VALTYP  	   EQU   #F663
  39  4000              DAC         EQU   #F7F6
  40  4000              USR     	   EQU   #F7F8
  41  4000              PROCNM		EQU	#FD89
  42  4000              BIOS_FILVRM EQU   #0056
  43  4000              CLIKSW		EQU	#F3DB
  44  4000
  45  4000              RAMAD0	   EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  46  4000              RAMAD1	   EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  47  4000              RAMAD2	   EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  48  4000              RAMAD3	   EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  49  4000              EXPTBL	   EQU   #FCC1
  50  4000              SCRMOD	   EQU   #FCAF ; current screen mode
  51  4000              REG1SAV     EQU   #F3E0 ; VDP(1)
  52  4000              JIFFY	      EQU   #FC9E
  53  4000              GRPPAT	   EQU   #F3CF ; SCREEN 2 sprite generator table address
  54  4000              GRPCGP		EQU	#F3CB ; SCREEN 2 pattern generator table address
  55  4000              GRPATR      EQU   #F3CD ; SCREEN 2 sprite attribute table address
  56  4000              T32PAT	   EQU   #F3C5 ; SCREEN 1 sprite generator table address
  57  4000              T32CGP      EQU   #F3C1 ; SCREEN 1 pattern ganarator table address
  58  4000              T32ATR      EQU   #F3C3 ; SCREEN 1 sprite attribute table address
  59  4000
  60  4000              ; BASIC error codes
  61  4000              ;01 NEXT without FOR
  62  4000              ;02 Syntax error
  63  4000              ;03 RETURN without GOSUB
  64  4000              ;04 Out of DATA
  65  4000              ;05 Illegal function call
  66  4000              ;06 Overflow
  67  4000              ;07 Out of memory
  68  4000              ;08 Undefined line number
  69  4000              ;09 Subscript out of range
  70  4000              ;10 Redimensioned array
  71  4000              ;11 Division by zero
  72  4000              ;12 Illegal direct
  73  4000              ;13 Type mismatch
  74  4000              ;14 Out of string space
  75  4000              ;15 String too long
  76  4000              ;16 String formula too complex
  77  4000              ;17 Can't CONTINUE
  78  4000              ;18 Undefined user function
  79  4000              ;19 Device I/O error
  80  4000              ;20 Verify error
  81  4000              ;21 No RESUME
  82  4000              ;22 RESUME without error
  83  4000              ;23 Unprintable error
  84  4000              ;24 Missing operand
  85  4000              ;25 Line buffer overflow
  86  4000              ;50 FIELD overflow
  87  4000              ;51 Internal error
  88  4000              ;52 Bad file number
  89  4000              ;53 File not found
  90  4000              ;54 File already open
  91  4000              ;55 Input past end
  92  4000              ;56 Bad file name
  93  4000              ;57 Direct statement in file
  94  4000              ;58 Sequential I/O only
  95  4000              ;59 File not OPEN
  96  4000
  97  4000
  98  4000               ; simulate cartridge with BASIC extension
  99  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  99  4004 45 5E 00 00
  99  4008 00 00 00 00
  99  400C 00 00 00 00
 100  4010
 101  4010              ; this location #4010 stores last location used by basic extension
 102  4010              ; free memory after that point
 103  4010              FREEMEMPTR:
 104  4010 F1 5E         DW EXT_END
 105  4012
 106  4012              ; this location #4012 stores extension version in DAA format
 107  4012              ; first byte is major version and second minor
 108  4012              VERSION:
 109  4012 00 90         DB #00, #90
 110  4014
 111  4014              ; this location #4014 contains a jump to entry point for DEFUSR approach
 112  4014              ; if excluded it contains 3xRET so that sound player can be at aspecific spot
 113  4014               IF (1 == 1)
 114  4014 C3 EC 5C        JP DEFUSR_ENTRY
 115  4017               ELSE
 116  4017 ~               .3 RET
 117  4017               ENDIF
 118  4017
 119  4017              ; binary included AKG player compiled at #4017
 120  4017               IF (SOUND_CMDS == 1)
 121  4017              	INCBIN "bin/AKG.bin"
 122  4CF3              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF3              MAIN_PLAYER_START EQU 04017H
   2+ 4CF3              PLY_AKG_START EQU 04017H
   3+ 4CF3              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 04020H
   4+ 4CF3              PLY_AKG_INITSOUNDEFFECTS EQU 04020H
   5+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04024H
   6+ 4CF3              PLY_AKG_PLAYSOUNDEFFECT EQU 04024H
   7+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04025H
   8+ 4CF3              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04025H
   9+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 0404CH
  10+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 0404CH
  11+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 0405AH
  12+ 4CF3              PLY_AKG_PSES_PLAY EQU 04093H
  13+ 4CF3              PLY_AKG_PSES_READFIRSTBYTE EQU 0409CH
  14+ 4CF3              PLY_AKG_PSES_S_ENDORLOOP EQU 040B4H
  15+ 4CF3              PLY_AKG_PSES_S_LOOP EQU 040BFH
  16+ 4CF3              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C5H
  17+ 4CF3              PLY_AKG_PSES_NOTREACHED EQU 040D8H
  18+ 4CF3              PLY_AKG_PSES_HARDWAREONLY EQU 040DCH
  19+ 4CF3              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E3H
  20+ 4CF3              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F5H
  21+ 4CF3              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FFH
  22+ 4CF3              PLY_AKG_PSES_H_AFTERRETRIG EQU 04109H
  23+ 4CF3              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411DH
  24+ 4CF3              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 04122H
  25+ 4CF3              PLY_AKG_PSES_READHARDWAREPERIOD EQU 0412AH
  26+ 4CF3              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04135H
  27+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 04141H
  28+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04143H
  29+ 4CF3              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04149H
  30+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414DH
  31+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414DH
  32+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414FH
  33+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414FH
  34+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414FH
  35+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 04150H
  36+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 04151H
  37+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04155H
  38+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04155H
  39+ 4CF3              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04155H
  40+ 4CF3              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415DH
  41+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04165H
  42+ 4CF3              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04165H
  43+ 4CF3              PLY_AKG_INIT EQU 04165H
  44+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04165H
  45+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04193H
  46+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A7H
  47+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B9H
  48+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D8H
  49+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E5H
  50+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL EQU 041EBH
  51+ 4CF3              PLY_AKG_INITTABLE0 EQU 041EEH
  52+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EEH
  53+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04208H
  54+ 4CF3              PLY_AKG_INITTABLE0_END EQU 04208H
  55+ 4CF3              PLY_AKG_INITTABLE1 EQU 04208H
  56+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04208H
  57+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 0420CH
  58+ 4CF3              PLY_AKG_INITTABLE1_END EQU 0420CH
  59+ 4CF3              PLY_AKG_INITTABLEORA EQU 0420CH
  60+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 0420CH
  61+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04224H
  62+ 4CF3              PLY_AKG_INITTABLEORA_END EQU 04224H
  63+ 4CF3              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04224H
  64+ 4CF3              PLY_AKG_STOP EQU 04224H
  65+ 4CF3              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04236H
  66+ 4CF3              PLY_AKG_PLAY EQU 04236H
  67+ 4CF3              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423EH
  68+ 4CF3              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04244H
  69+ 4CF3              PLY_AKG_READLINKER EQU 04249H
  70+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04249H
  71+ 4CF3              PLY_AKG_READLINKER_PTLINKER EQU 04249H
  72+ 4CF3              PLY_AKG_READLINKER_NOLOOP EQU 04254H
  73+ 4CF3              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428DH
  74+ 4CF3              PLY_AKG_READLINE EQU 04290H
  75+ 4CF3              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 04290H
  76+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04296H
  77+ 4CF3              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04296H
  78+ 4CF3              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A3H
  79+ 4CF3              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A7H
  80+ 4CF3              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042AAH
  81+ 4CF3              PLY_AKG_SPEEDTRACK_END EQU 042ADH
  82+ 4CF3              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042ADH
  83+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B3H
  84+ 4CF3              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B3H
  85+ 4CF3              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042C0H
  86+ 4CF3              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C4H
  87+ 4CF3              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C7H
  88+ 4CF3              PLY_AKG_EVENTTRACK_END EQU 042CAH
  89+ 4CF3              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042CAH
  90+ 4CF3              PLY_AKG_CHANNEL1_READTRACK EQU 042D6H
  91+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D6H
  92+ 4CF3              PLY_AKG_CHANNEL1_PTTRACK EQU 042D6H
  93+ 4CF3              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042F1H
  94+ 4CF3              PLY_AKG_CHANNEL1_WAIT EQU 042FCH
  95+ 4CF3              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04303H
  96+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04303H
  97+ 4CF3              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04303H
  98+ 4CF3              PLY_AKG_CHANNEL1_NOTE EQU 0430CH
  99+ 4CF3              PLY_AKG_BASENOTEINDEX EQU 0430CH
 100+ 4CF3              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430EH
 101+ 4CF3              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430EH
 102+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431EH
 103+ 4CF3              PLY_AKG_INSTRUMENTSTABLE EQU 0431EH
 104+ 4CF3              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 04330H
 105+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 04340H
 106+ 4CF3              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04368H
 107+ 4CF3              PLY_AKG_CHANNEL1_READCELLEND EQU 0436BH
 108+ 4CF3              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 0436BH
 109+ 4CF3              PLY_AKG_CHANNEL2_READTRACK EQU 04377H
 110+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04377H
 111+ 4CF3              PLY_AKG_CHANNEL2_PTTRACK EQU 04377H
 112+ 4CF3              PLY_AKG_CHANNEL2_SMALLWAIT EQU 04392H
 113+ 4CF3              PLY_AKG_CHANNEL2_WAIT EQU 0439DH
 114+ 4CF3              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A4H
 115+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A4H
 116+ 4CF3              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A4H
 117+ 4CF3              PLY_AKG_CHANNEL2_NOTE EQU 043ADH
 118+ 4CF3              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043B2H
 119+ 4CF3              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043B2H
 120+ 4CF3              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D4H
 121+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E4H
 122+ 4CF3              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 0440CH
 123+ 4CF3              PLY_AKG_CHANNEL2_READCELLEND EQU 0440FH
 124+ 4CF3              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440FH
 125+ 4CF3              PLY_AKG_CHANNEL3_READTRACK EQU 0441BH
 126+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 0441BH
 127+ 4CF3              PLY_AKG_CHANNEL3_PTTRACK EQU 0441BH
 128+ 4CF3              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04436H
 129+ 4CF3              PLY_AKG_CHANNEL3_WAIT EQU 04441H
 130+ 4CF3              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04448H
 131+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04448H
 132+ 4CF3              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04448H
 133+ 4CF3              PLY_AKG_CHANNEL3_NOTE EQU 04451H
 134+ 4CF3              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04456H
 135+ 4CF3              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04456H
 136+ 4CF3              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04478H
 137+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04488H
 138+ 4CF3              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044B0H
 139+ 4CF3              PLY_AKG_CHANNEL3_READCELLEND EQU 044B3H
 140+ 4CF3              PLY_AKG_CURRENTSPEED EQU 044B3H
 141+ 4CF3              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B5H
 142+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B8H
 143+ 4CF3              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B8H
 144+ 4CF3              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044BBH
 145+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BEH
 146+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BEH
 147+ 4CF3              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044CAH
 148+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044D1H
 149+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D4H
 150+ 4CF3              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044DAH
 151+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DDH
 152+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DDH
 153+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044EBH
 154+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044F0H
 155+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044FBH
 156+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FEH
 157+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FEH
 158+ 4CF3              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 04501H
 159+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04504H
 160+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04504H
 161+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450DH
 162+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04517H
 163+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 0451AH
 164+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 0451AH
 165+ 4CF3              PLY_AKG_CHANNEL1_PITCH EQU 0451AH
 166+ 4CF3              PLY_AKG_CHANNEL1_ISPITCH EQU 0451DH
 167+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 04522H
 168+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACK EQU 04522H
 169+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04526H
 170+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04528H
 171+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 0452AH
 172+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 04531H
 173+ 4CF3              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 04532H
 174+ 4CF3              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04535H
 175+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04535H
 176+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 04551H
 177+ 4CF3              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 04551H
 178+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455EH
 179+ 4CF3              PLY_AKG_CHANNEL1_GLIDEOVER EQU 04562H
 180+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 04572H
 181+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 04572H
 182+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04573H
 183+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04574H
 184+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04576H
 185+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04576H
 186+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04576H
 187+ 4CF3              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04577H
 188+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04578H
 189+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 0457AH
 190+ 4CF3              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 0457AH
 191+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 0457AH
 192+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 0457AH
 193+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 0457AH
 194+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457DH
 195+ 4CF3              PLY_AKG_CHANNEL1_PITCH_END EQU 0457FH
 196+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04587H
 197+ 4CF3              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04587H
 198+ 4CF3              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 0458AH
 199+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458DH
 200+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458DH
 201+ 4CF3              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04599H
 202+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 045A0H
 203+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A3H
 204+ 4CF3              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A9H
 205+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045ACH
 206+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045ACH
 207+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045BAH
 208+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BFH
 209+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045CAH
 210+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CDH
 211+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CDH
 212+ 4CF3              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045D0H
 213+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D3H
 214+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D3H
 215+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045DCH
 216+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E6H
 217+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E9H
 218+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E9H
 219+ 4CF3              PLY_AKG_CHANNEL2_PITCH EQU 045E9H
 220+ 4CF3              PLY_AKG_CHANNEL2_ISPITCH EQU 045ECH
 221+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045F1H
 222+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045F1H
 223+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F5H
 224+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F7H
 225+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F9H
 226+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 04600H
 227+ 4CF3              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 04601H
 228+ 4CF3              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04604H
 229+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04604H
 230+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 04620H
 231+ 4CF3              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 04620H
 232+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462DH
 233+ 4CF3              PLY_AKG_CHANNEL2_GLIDEOVER EQU 04631H
 234+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 04641H
 235+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 04641H
 236+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 04642H
 237+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04643H
 238+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04645H
 239+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04645H
 240+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04645H
 241+ 4CF3              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04646H
 242+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04647H
 243+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04649H
 244+ 4CF3              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04649H
 245+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04649H
 246+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04649H
 247+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04649H
 248+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_END EQU 0464CH
 249+ 4CF3              PLY_AKG_CHANNEL2_PITCH_END EQU 0464EH
 250+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04656H
 251+ 4CF3              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04656H
 252+ 4CF3              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04659H
 253+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 0465CH
 254+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 0465CH
 255+ 4CF3              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04668H
 256+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466FH
 257+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 04672H
 258+ 4CF3              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04678H
 259+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 0467BH
 260+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 0467BH
 261+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04689H
 262+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468EH
 263+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04699H
 264+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 0469CH
 265+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 0469CH
 266+ 4CF3              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469FH
 267+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 046A2H
 268+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE EQU 046A2H
 269+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046ABH
 270+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B5H
 271+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B8H
 272+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B8H
 273+ 4CF3              PLY_AKG_CHANNEL3_PITCH EQU 046B8H
 274+ 4CF3              PLY_AKG_CHANNEL3_ISPITCH EQU 046BBH
 275+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046C0H
 276+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046C0H
 277+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C4H
 278+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C6H
 279+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C8H
 280+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CFH
 281+ 4CF3              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046D0H
 282+ 4CF3              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D3H
 283+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D3H
 284+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046EFH
 285+ 4CF3              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046EFH
 286+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046FCH
 287+ 4CF3              PLY_AKG_CHANNEL3_GLIDEOVER EQU 04700H
 288+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 04710H
 289+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 04710H
 290+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 04711H
 291+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 04712H
 292+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04714H
 293+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04714H
 294+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04714H
 295+ 4CF3              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04715H
 296+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04716H
 297+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04718H
 298+ 4CF3              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04718H
 299+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04718H
 300+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04718H
 301+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04718H
 302+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_END EQU 0471BH
 303+ 4CF3              PLY_AKG_CHANNEL3_PITCH_END EQU 0471DH
 304+ 4CF3              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04729H
 305+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04729H
 306+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04729H
 307+ 4CF3              PLY_AKG_CHANNEL1_TRACKNOTE EQU 0472CH
 308+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472EH
 309+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04734H
 310+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04737H
 311+ 4CF3              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04737H
 312+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 0473AH
 313+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04743H
 314+ 4CF3              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 0474BH
 315+ 4CF3              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04758H
 316+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04758H
 317+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04758H
 318+ 4CF3              PLY_AKG_CHANNEL2_TRACKNOTE EQU 0475BH
 319+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475DH
 320+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04763H
 321+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04766H
 322+ 4CF3              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04766H
 323+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04769H
 324+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 04772H
 325+ 4CF3              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 0477AH
 326+ 4CF3              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04788H
 327+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04788H
 328+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04788H
 329+ 4CF3              PLY_AKG_CHANNEL3_TRACKNOTE EQU 0478BH
 330+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478DH
 331+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04793H
 332+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04796H
 333+ 4CF3              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04796H
 334+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04799H
 335+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 047A2H
 336+ 4CF3              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047AAH
 337+ 4CF3              PLY_AKG_SENDPSGREGISTERS EQU 047B9H
 338+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047C1H
 339+ 4CF3              PLY_AKG_PSGREG01_INSTR EQU 047C1H
 340+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047D1H
 341+ 4CF3              PLY_AKG_PSGREG23_INSTR EQU 047D1H
 342+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047E2H
 343+ 4CF3              PLY_AKG_PSGREG45_INSTR EQU 047E2H
 344+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F3H
 345+ 4CF3              PLY_AKG_PSGREG6_8_INSTR EQU 047F3H
 346+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04804H
 347+ 4CF3              PLY_AKG_PSGREG9_10_INSTR EQU 04804H
 348+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04815H
 349+ 4CF3              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04815H
 350+ 4CF3              PLY_AKG_PSGREG13_OLDVALUE EQU 0482AH
 351+ 4CF3              PLY_AKG_RETRIG EQU 0482CH
 352+ 4CF3              PLY_AKG_PSGREG13_INSTR EQU 0482EH
 353+ 4CF3              PLY_AKG_PSGREG13_END EQU 0483DH
 354+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483DH
 355+ 4CF3              PLY_AKG_SAVESP EQU 0483DH
 356+ 4CF3              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 04841H
 357+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTS EQU 04849H
 358+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04856H
 359+ 4CF3              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04856H
 360+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485EH
 361+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 0486BH
 362+ 4CF3              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 0486BH
 363+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTS EQU 04873H
 364+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487EH
 365+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS EQU 0487EH
 366+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488DH
 367+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488DH
 368+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04894H
 369+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A4H
 370+ 4CF3              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A4H
 371+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048ABH
 372+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048ABH
 373+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048AEH
 374+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B7H
 375+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B7H
 376+ 4CF3              PLY_AKG_READINSTRUMENTCELL EQU 048BDH
 377+ 4CF3              PLY_AKG_NOSOFTNOHARD EQU 048CAH
 378+ 4CF3              PLY_AKG_NSNH_NONOISE EQU 048DFH
 379+ 4CF3              PLY_AKG_SOFT EQU 048E2H
 380+ 4CF3              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E9H
 381+ 4CF3              PLY_AKG_S_NOTSIMPLE EQU 048F1H
 382+ 4CF3              PLY_AKG_S_AFTERSIMPLETEST EQU 048F4H
 383+ 4CF3              PLY_AKG_HARDTOSOFT EQU 04901H
 384+ 4CF3              PLY_AKG_HS_JUMPRATIO EQU 0490CH
 385+ 4CF3              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04939H
 386+ 4CF3              PLY_AKG_ENDWITHOUTLOOP EQU 0493BH
 387+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 0493BH
 388+ 4CF3              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 0493BH
 389+ 4CF3              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04943H
 390+ 4CF3              PLY_AKG_SH_JUMPRATIO EQU 04950H
 391+ 4CF3              PLY_AKG_SH_JUMPRATIOEND EQU 04971H
 392+ 4CF3              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 04980H
 393+ 4CF3              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04986H
 394+ 4CF3              PLY_AKG_H_OR_ENDWITHLOOP EQU 049A0H
 395+ 4CF3              PLY_AKG_H_RETRIGEND EQU 049B2H
 396+ 4CF3              PLY_AKG_H_AFTERRETRIG EQU 049B3H
 397+ 4CF3              PLY_AKG_ENDWITHLOOP EQU 049C5H
 398+ 4CF3              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049CCH
 399+ 4CF3              PLY_AKG_S_OR_H_NEXTBYTE EQU 049E2H
 400+ 4CF3              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049F0H
 401+ 4CF3              PLY_AKG_S_OR_H_AFTERPITCH EQU 04A00H
 402+ 4CF3              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0EH
 403+ 4CF3              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1DH
 404+ 4CF3              PLY_AKG_SHOHS_RETRIGEND EQU 04A2CH
 405+ 4CF3              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2DH
 406+ 4CF3              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3FH
 407+ 4CF3              PLY_AKG_EFFECTTABLE EQU 04A4DH
 408+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4DH
 409+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A71H
 410+ 4CF3              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A71H
 411+ 4CF3              PLY_AKG_EFFECT_RESET EQU 04A74H
 412+ 4CF3              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A76H
 413+ 4CF3              PLY_AKG_EFFECT_VOLUME EQU 04A91H
 414+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9DH
 415+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA3H
 416+ 4CF3              PLY_AKG_ARPEGGIOSTABLE EQU 04AA3H
 417+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04ACAH
 418+ 4CF3              PLY_AKG_EFFECT_PITCHTABLE EQU 04AD1H
 419+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD7H
 420+ 4CF3              PLY_AKG_PITCHESTABLE EQU 04AD7H
 421+ 4CF3              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFEH
 422+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B05H
 423+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B16H
 424+ 4CF3              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1DH
 425+ 4CF3              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2DH
 426+ 4CF3              PLY_AKG_EFFECT_PITCHUP EQU 04B42H
 427+ 4CF3              PLY_AKG_EFFECT_PITCHSTOP EQU 04B54H
 428+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B5BH
 429+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B85H
 430+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B85H
 431+ 4CF3              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9EH
 432+ 4CF3              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9EH
 433+ 4CF3              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BB0H
 434+ 4CF3              PLY_AKG_EFFECT_LEGATO EQU 04BC6H
 435+ 4CF3              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BDAH
 436+ 4CF3              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BE2H
 437+ 4CF3              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BEAH
 438+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BF2H
 439+ 4CF3              PLY_AKG_EVENT EQU 04BF2H
 440+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF3H
 441+ 4CF3              PLY_AKG_PERIODTABLE EQU 04BF3H
 442+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF3H
 443+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF3H
 444+ 4CF3              PLY_AKG_PERIODTABLE_END EQU 04CF3H
 445+ 4CF3              PLY_AKG_END EQU 04CF3H
 446+ 4CF3              MAIN_PLAYER_END EQU 04CF3H
 447+ 4CF3              TESTEREND EQU 04CF3H
 448+ 4CF3
# file closed: ./symbol/AKG.sym
 123  4CF3               ENDIF
 124  4CF3
 125  4CF3               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
   1+ 4CF3              ORIG.HTIMI:
   2+ 4CF3 00 00 00 00  	DB 0, 0, 0, 0, 0
   2+ 4CF7 00
   3+ 4CF8               EXPORT ORIG.HTIMI
   4+ 4CF8
   5+ 4CF8              ; *******************************************************************************************************
   6+ 4CF8              ; interrupt handler when page 0 enabled
   7+ 4CF8              ; we are here only if one of the extended basic commands have paged in page 0
   8+ 4CF8              ; which means we arrived from BASIC so page 2 is already good
   9+ 4CF8              VBLANK:
  10+ 4CF8              	EXPORT VBLANK
  11+ 4CF8
  12+ 4CF8 F5               PUSH AF
  13+ 4CF9              	; is VDP originator ?
  14+ 4CF9 DB 99        	IN	A, (099H)
  15+ 4CFB A7           	AND	A
  16+ 4CFC F2 23 4D     	JP P, .EXIT
  17+ 4CFF
  18+ 4CFF               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  19+ 4CFF C5               PUSH BC
  20+ 4D00 D5               PUSH DE
  21+ 4D01 E5               PUSH HL
  22+ 4D02 08               EX AF, AF'
  23+ 4D03 D9               EXX
  24+ 4D04 F5               PUSH AF
  25+ 4D05 C5               PUSH BC
  26+ 4D06 D5               PUSH DE
  27+ 4D07 E5               PUSH HL
  28+ 4D08 DD E5            PUSH IX
  29+ 4D0A FD E5            PUSH IY
  30+ 4D0C
  31+ 4D0C               IF (SPRITE_CMDS == 1)
  32+ 4D0C CD 5D 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  33+ 4D0F               ENDIF
  34+ 4D0F
  35+ 4D0F               IF (SOUND_CMDS == 1)
  36+ 4D0F 3A 73 55     	LD A, (SOUND_ENABLED)
  37+ 4D12 B7           	OR A
  38+ 4D13 C4 36 42     	CALL NZ,PLY_AKG_PLAY
  39+ 4D16               ENDIF
  40+ 4D16
  41+ 4D16                  ; increase JIFFY
  42+ 4D16                  ;LD HL,(JIFFY)
  43+ 4D16                  ;INC HL
  44+ 4D16                  ;LD (JIFFY),HL
  45+ 4D16
  46+ 4D16 FD E1            POP IY
  47+ 4D18 DD E1            POP IX
  48+ 4D1A E1               POP HL
  49+ 4D1B D1               POP DE
  50+ 4D1C C1               POP BC
  51+ 4D1D F1               POP AF
  52+ 4D1E 08               EX AF, AF'
  53+ 4D1F D9               EXX
  54+ 4D20 E1               POP HL
  55+ 4D21 D1               POP DE
  56+ 4D22 C1               POP BC
  57+ 4D23               ENDIF
  58+ 4D23
  59+ 4D23              .EXIT:
  60+ 4D23 F1           	POP AF
  61+ 4D24 FB           	EI
  62+ 4D25 ED 4D        	RETI
  63+ 4D27              ; *******************************************************************************************************
  64+ 4D27
  65+ 4D27              ; *******************************************************************************************************
  66+ 4D27              ; H.TIMI function
  67+ 4D27              ; we can end up here from anywhere so page in both page 0 and 2
  68+ 4D27              MBGE_HTIMI:
  69+ 4D27               EXPORT MBGE_HTIMI
  70+ 4D27
  71+ 4D27               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  72+ 4D27
  73+ 4D27 F5           	PUSH AF
  74+ 4D28
  75+ 4D28              	; enable page 2
  76+ 4D28 3E 02            LD A, 2
  77+ 4D2A CD 74 5D         CALL GET_PAGE_INFO
  78+ 4D2D C5               PUSH BC
  79+ 4D2E D5               PUSH DE
  80+ 4D2F 3A 43 F3         LD A, (RAMAD2)
  81+ 4D32 26 80            LD H, 080H
  82+ 4D34 CD BB 5D         CALL LOCAL_ENASLT
  83+ 4D37              	; enable page 0
  84+ 4D37 AF               XOR A
  85+ 4D38 CD 74 5D         CALL GET_PAGE_INFO
  86+ 4D3B C5               PUSH BC
  87+ 4D3C D5               PUSH DE
  88+ 4D3D 3A 41 F3         LD A, (RAMAD0)
  89+ 4D40 26 00            LD H, 0
  90+ 4D42 CD BB 5D         CALL LOCAL_ENASLT
  91+ 4D45
  92+ 4D45               IF (SPRITE_CMDS == 1)
  93+ 4D45 CD 5D 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  94+ 4D48               ENDIF
  95+ 4D48
  96+ 4D48               IF (SOUND_CMDS == 1)
  97+ 4D48 3A 73 55     	LD A, (SOUND_ENABLED)
  98+ 4D4B B7           	OR A
  99+ 4D4C C4 36 42     	CALL NZ,PLY_AKG_PLAY
 100+ 4D4F               ENDIF
 101+ 4D4F
 102+ 4D4F              	; restore page 0
 103+ 4D4F D1               POP DE
 104+ 4D50 C1               POP BC
 105+ 4D51 CD AB 5D         CALL RESTORE_PAGE_INFO
 106+ 4D54              	; restore page 2
 107+ 4D54 D1               POP DE
 108+ 4D55 C1               POP BC
 109+ 4D56 CD AB 5D         CALL RESTORE_PAGE_INFO
 110+ 4D59
 111+ 4D59 F1           	POP AF
 112+ 4D5A               ENDIF
 113+ 4D5A C3 F3 4C     	JP ORIG.HTIMI
 114+ 4D5D              ; *******************************************************************************************************
 115+ 4D5D
 116+ 4D5D              ; *******************************************************************************************************
 117+ 4D5D              ; function checks if the sprite system is initialized and what screen mode we are running
 118+ 4D5D              ; also checks if some VRAM modifying command is running
 119+ 4D5D              ; when that checks out calls sprite updates and animation processing
 120+ 4D5D              ; if in an unsupported mode disables sprite handling
 121+ 4D5D              PROCESS_SPRITES_AND_ANIMATIONS:
 122+ 4D5D              	; check if initialized
 123+ 4D5D 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
 124+ 4D60 B7           	OR A
 125+ 4D61 C8           	RET Z
 126+ 4D62              	; check screen mode
 127+ 4D62 3A AF FC     	LD A, (SCRMOD)
 128+ 4D65 3D           	DEC A
 129+ 4D66 28 08        	JR Z, .L0 ; screen 1
 130+ 4D68 3D           	DEC A
 131+ 4D69 28 05            JR Z, .L0 ; screen 2
 132+ 4D6B              	; unsupported screen mode, disable
 133+ 4D6B AF               XOR A
 134+ 4D6C 32 7F 4D         LD (SPRATR_INIT_STATUS),A
 135+ 4D6F C9               RET
 136+ 4D70              .L0:
 137+ 4D70                  ; check if anyone else is working with VRAM
 138+ 4D70 3A 1B 5D         LD A,(VRAM_UPDATE_IN_PROGRESS)
 139+ 4D73 B7               OR A
 140+ 4D74 C0               RET NZ
 141+ 4D75
 142+ 4D75 CD 95 4D         CALL SPRATR_UPDATE
 143+ 4D78
 144+ 4D78               IF (ANIM_CMDS == 1)
 145+ 4D78 CD D2 52         CALL PROCESS_ANIMATIONS
 146+ 4D7B CD 31 54         CALL PROCESS_AUTOSGAMS
 147+ 4D7E               ENDIF
 148+ 4D7E C9               RET
 149+ 4D7F              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
 126  4D7F
 127  4D7F               IF (SPRITE_CMDS == 1)
 128  4D7F               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4D7F              ; commands and variables related to sprites
   2+ 4D7F
   3+ 4D7F              SPRATR_INIT_STATUS:
   4+ 4D7F 00            DB 0
   5+ 4D80              SPRATR_UPDATE_FLAG:
   6+ 4D80 00 00         DW 0
   7+ 4D82              SPRATR_DATA:
   8+ 4D82 00 00         DW 0
   9+ 4D84              SPRFLICKER_ENABLED:
  10+ 4D84 00            DB 0
  11+ 4D85              ; to support sprite flicker
  12+ 4D85              FLICKER:
  13+ 4D85 00            DB 0
  14+ 4D86              NUM_SPRITES_HANDLED:
  15+ 4D86 20            DB 32
  16+ 4D87
  17+ 4D87              ; to temporarily store stack pointer
  18+ 4D87              TMPSP:
  19+ 4D87 00 00         DW 0
  20+ 4D89
  21+ 4D89              ; *******************************************************************************************************
  22+ 4D89              ; helper function gets pointer to n-th entry in sprite attributes
  23+ 4D89              ; changes HL,DE
  24+ 4D89              GETnthSPRATTR:
  25+ 4D89 26 00            LD H,0
  26+ 4D8B 6F               LD L,A
  27+ 4D8C CD 70 5D         CALL HLx8
  28+ 4D8F ED 5B 82 4D      LD DE,(SPRATR_DATA)
  29+ 4D93 19               ADD HL,DE
  30+ 4D94 C9               RET
  31+ 4D95              ; *******************************************************************************************************
  32+ 4D95
  33+ 4D95              ; *******************************************************************************************************
  34+ 4D95              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  35+ 4D95              ; struct {
  36+ 4D95              ; DW y
  37+ 4D95              ; DW x
  38+ 4D95              ; DW pattern (0-63)
  39+ 4D95              ; DW color
  40+ 4D95              ; } [32]
  41+ 4D95              ; will hide sprites whose location is outside of visible area
  42+ 4D95              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  43+ 4D95              ; modifies AF, AF', BC, DE, HL, IX
  44+ 4D95              SPRATR_UPDATE:
  45+ 4D95              	; check if update requested
  46+ 4D95 2A 80 4D     	LD HL, (SPRATR_UPDATE_FLAG)
  47+ 4D98 7E           	LD A, (HL)
  48+ 4D99 B7           	OR A
  49+ 4D9A C8           	RET Z
  50+ 4D9B
  51+ 4D9B DD 21 86 4D  	LD IX,NUM_SPRITES_HANDLED
  52+ 4D9F DD 46 00     	LD B, (IX) ; sprite number
  53+ 4DA2 0E 98        	LD C, #98 ; register for vdp data output
  54+ 4DA4              	; set VDP address
  55+ 4DA4 3A AF FC         LD A,(SCRMOD)
  56+ 4DA7 3D               DEC A
  57+ 4DA8 20 05            JR NZ,.L4
  58+ 4DAA 2A C3 F3         LD HL, (T32ATR)
  59+ 4DAD 18 03            JR .L5
  60+ 4DAF              .L4:
  61+ 4DAF 2A CD F3         LD HL, (GRPATR)
  62+ 4DB2              .L5:
  63+ 4DB2 3A 84 4D     	LD A, (SPRFLICKER_ENABLED)
  64+ 4DB5 B7           	OR A
  65+ 4DB6 28 03        	JR Z, .L3
  66+ 4DB8 3A 85 4D     	LD A, (FLICKER)
  67+ 4DBB              .L3:
  68+ 4DBB 5F           	LD E, A
  69+ 4DBC 08           	EX AF, AF'
  70+ 4DBD 7B           	LD A, E
  71+ 4DBE 87           	ADD A, A
  72+ 4DBF 87           	ADD A, A
  73+ 4DC0 16 00        	LD D, 0
  74+ 4DC2 5F           	LD E, A
  75+ 4DC3 19           	ADD HL, DE
  76+ 4DC4 CD 5B 5D     	CALL SETWRT_LOCAL
  77+ 4DC7 ED 73 87 4D  	LD (TMPSP), SP
  78+ 4DCB ED 7B 82 4D  	LD SP, (SPRATR_DATA)
  79+ 4DCF
  80+ 4DCF              .LOOP:
  81+ 4DCF E1           	POP HL
  82+ 4DD0 24           	INC H
  83+ 4DD1 28 0D        	JR Z, .L1 ; negative number between -256 and -1
  84+ 4DD3 25           	DEC H
  85+ 4DD4 20 15        	JR NZ, .OUT3 ; sprite vertically can't be visible
  86+ 4DD6 7D           	LD A, L
  87+ 4DD7 FE C0        	CP 192
  88+ 4DD9 30 10        	JR NC, .OUT3
  89+ 4DDB 3D           	DEC A ; due to VDP rule that top of screen is -1
  90+ 4DDC 57           	LD D, A
  91+ 4DDD C3 04 4E     	JP .X
  92+ 4DE0              .L1:
  93+ 4DE0 7D           	LD A, L
  94+ 4DE1 C6 10        	ADD 16
  95+ 4DE3 FA EB 4D     	JP M, .OUT3 ; below -16
  96+ 4DE6 2D           	DEC L ; due to VDP rule that top of screen is -1
  97+ 4DE7 55           	LD D, L
  98+ 4DE8 C3 04 4E     	JP .X
  99+ 4DEB              .OUT3:
 100+ 4DEB E1           	POP HL ; skip x value
 101+ 4DEC              .OUT2:
 102+ 4DEC E1           	POP HL ; skip pattern
 103+ 4DED E1           	POP HL ; skip color
 104+ 4DEE 3E D1        	LD A, #D1
 105+ 4DF0 ED 79        	OUT (C), A ; sprite hidden
 106+ 4DF2 00          > NOP
 106+ 4DF3 00          > NOP
 106+ 4DF4 00          > NOP
 107+ 4DF5 ED 79        	OUT (C), A ; value unimportant
 108+ 4DF7 00          > NOP
 108+ 4DF8 00          > NOP
 108+ 4DF9 00          > NOP
 109+ 4DFA ED 79        	OUT (C), A ; value unimportant
 110+ 4DFC 00          > NOP
 110+ 4DFD 00          > NOP
 110+ 4DFE 00          > NOP
 111+ 4DFF ED 79        	OUT (C), A ; value unimportant
 112+ 4E01 C3 2F 4E     	JP .NEXT
 113+ 4E04              .X:
 114+ 4E04 E1           	POP HL
 115+ 4E05 24           	INC H
 116+ 4E06 28 08        	JR Z, .L2
 117+ 4E08 25           	DEC H
 118+ 4E09 20 E1        	JR NZ, .OUT2
 119+ 4E0B 1E 00        	LD E, 0 ; EC bit
 120+ 4E0D C3 19 4E     	JP .XY
 121+ 4E10              .L2:
 122+ 4E10 7D           	LD A, L
 123+ 4E11 C6 20        	ADD 32
 124+ 4E13 FA EC 4D     	JP M, .OUT2
 125+ 4E16 6F           	LD L, A
 126+ 4E17 1E 80        	LD E, #80
 127+ 4E19              .XY:
 128+ 4E19 ED 51        	OUT (C), D
 129+ 4E1B 3A E0 F3     	LD A, (REG1SAV)
 130+ 4E1E E6 02        	AND 2
 131+ 4E20 ED 69        	OUT (C), L
 132+ 4E22 E1           	POP HL ; pattern
 133+ 4E23 7D           	LD A, L
 134+ 4E24 28 02        	JR Z, .SMALLSPRITES
 135+ 4E26 87           	ADD A, A
 136+ 4E27 87           	ADD A, A ; needs to go at 4x
 137+ 4E28              .SMALLSPRITES:
 138+ 4E28 D3 98        	OUT (#98), A
 139+ 4E2A E1           	POP HL ; color
 140+ 4E2B 7D           	LD A, L
 141+ 4E2C B3           	OR E
 142+ 4E2D D3 98        	OUT (#98), A
 143+ 4E2F              .NEXT:
 144+ 4E2F 08           	EX AF, AF'
 145+ 4E30 3C           	INC A ; increase current sprite
 146+ 4E31 DD BE 00     	CP (IX) ; compare to maximum handled
 147+ 4E34 C2 54 4E     	JP NZ, .NEXT2 ; continue if not over
 148+ 4E37 AF           	XOR A ; back to zero
 149+ 4E38 08           	EX AF, AF'
 150+ 4E39 3A AF FC         LD A,(SCRMOD)
 151+ 4E3C 3D               DEC A
 152+ 4E3D 20 05            JR NZ,.L6
 153+ 4E3F 2A C3 F3         LD HL, (T32ATR)
 154+ 4E42 18 03            JR .L7
 155+ 4E44              .L6:
 156+ 4E44 2A CD F3         LD HL, (GRPATR)
 157+ 4E47              .L7:
 158+ 4E47              	; CALL SETWRT_LOCAL not allowed as SP modified
 159+ 4E47 7D           	LD	A, L
 160+ 4E48 D3 99        	OUT	(099H), A
 161+ 4E4A 7C           	LD	A, H
 162+ 4E4B E6 3F        	AND	03FH
 163+ 4E4D F6 40        	OR	040H
 164+ 4E4F D3 99        	OUT	(099H), A
 165+ 4E51 C3 55 4E     	JP .NEXT3
 166+ 4E54              .NEXT2:
 167+ 4E54 08           	EX AF, AF'
 168+ 4E55              .NEXT3:
 169+ 4E55 05           	DEC B
 170+ 4E56 C2 CF 4D     	JP NZ, .LOOP
 171+ 4E59 08           	EX AF, AF'
 172+ 4E5A 3C           	INC A ; increase flicker to start at the next one on next vblank
 173+ 4E5B DD BE 00     	CP (IX)
 174+ 4E5E 20 01        	JR NZ,.L8
 175+ 4E60 AF           	XOR A
 176+ 4E61              .L8:
 177+ 4E61 32 85 4D     	LD (FLICKER), A
 178+ 4E64
 179+ 4E64 ED 7B 87 4D  	LD SP, (TMPSP)
 180+ 4E68 2A 80 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 181+ 4E6B 36 00        	LD (HL), 0 ; zero out update flag
 182+ 4E6D C9           	RET
 183+ 4E6E              ; *******************************************************************************************************
 184+ 4E6E
 185+ 4E6E               IF (0 == 1)
 186+ 4E6E ~            ; *******************************************************************************************************
 187+ 4E6E ~            ; function to handle CALL SPRENABLE basic extension
 188+ 4E6E ~            ; initializes sprites handler
 189+ 4E6E ~            ; _SPRENABLE ( INT[3][31] variable sprites_attributes,
 190+ 4E6E ~            ;			   INT variable update_variable,
 191+ 4E6E ~            ;			   BYTE sprite_flicker_enabled,
 192+ 4E6E ~            ;			   BYTE num_sprites_handled )
 193+ 4E6E ~            ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA, SPRFLICKER_ENABLED and NUM_SPRITES_HANDLED
 194+ 4E6E ~            SPRENABLE:
 195+ 4E6E ~            	; opening (
 196+ 4E6E ~            	CALL CHKCHAR
 197+ 4E6E ~            	DB '('
 198+ 4E6E ~            	; get address of sprite attribute table DIM SA%(3,31)
 199+ 4E6E ~            	LD A,2
 200+ 4E6E ~            	LD B,2
 201+ 4E6E ~            	LD DE,#0420
 202+ 4E6E ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
 203+ 4E6E ~            	LD (SPRATR_DATA), BC
 204+ 4E6E ~            	; comma
 205+ 4E6E ~            	CALL CHKCHAR
 206+ 4E6E ~            	DB ','
 207+ 4E6E ~            	; get address of sprite update flag
 208+ 4E6E ~            	LD IX, PTRGET
 209+ 4E6E ~            	CALL CALBAS
 210+ 4E6E ~            	LD (SPRATR_UPDATE_FLAG), DE
 211+ 4E6E ~            	; comma
 212+ 4E6E ~            	CALL CHKCHAR
 213+ 4E6E ~            	DB ','
 214+ 4E6E ~            	; get flicker enabled flag
 215+ 4E6E ~            	LD IX, GETBYT
 216+ 4E6E ~            	CALL CALBAS
 217+ 4E6E ~            	LD (SPRFLICKER_ENABLED), A
 218+ 4E6E ~            	; comma
 219+ 4E6E ~            	CALL CHKCHAR
 220+ 4E6E ~            	DB ','
 221+ 4E6E ~            	; get number of handled sprites
 222+ 4E6E ~            	LD IX, GETBYT
 223+ 4E6E ~            	CALL CALBAS
 224+ 4E6E ~            	LD (NUM_SPRITES_HANDLED),A
 225+ 4E6E ~            	; ending )
 226+ 4E6E ~            	CALL CHKCHAR
 227+ 4E6E ~            	DB ')'
 228+ 4E6E ~            .L0:
 229+ 4E6E ~            	LD A, 1
 230+ 4E6E ~            	LD (SPRATR_INIT_STATUS), A
 231+ 4E6E ~            	RET
 232+ 4E6E ~            ; *******************************************************************************************************
 233+ 4E6E               ENDIF
 234+ 4E6E
 235+ 4E6E               IF (1 == 1)
 236+ 4E6E              ; same as SPRENABLE but for DEFUSR approach
 237+ 4E6E              ; input IX=pointer to input array, real data from +2
 238+ 4E6E              ; +2 = pointer to sprite attributes array data
 239+ 4E6E              ; +4 = pointer to sprite update variable
 240+ 4E6E              ; +6 = flicker flag
 241+ 4E6E              ; +8 = number of sprites to handle
 242+ 4E6E              SPRENABLE_DEFUSR:
 243+ 4E6E DD 6E 02     	LD L,(IX+2)
 244+ 4E71 DD 66 03     	LD H,(IX+3)
 245+ 4E74 22 82 4D     	LD (SPRATR_DATA),HL
 246+ 4E77 DD 6E 04     	LD L,(IX+4)
 247+ 4E7A DD 66 05     	LD H,(IX+5)
 248+ 4E7D 22 80 4D     	LD (SPRATR_UPDATE_FLAG),HL
 249+ 4E80 DD 7E 06     	LD A,(IX+6)
 250+ 4E83 32 84 4D     	LD (SPRFLICKER_ENABLED),A
 251+ 4E86 DD 7E 08     	LD A,(IX+8)
 252+ 4E89 32 86 4D     	LD (NUM_SPRITES_HANDLED),A
 253+ 4E8C               IF (0 == 1)
 254+ 4E8C ~            	JR SPRENABLE.L0
 255+ 4E8C               ELSE
 256+ 4E8C 3E 01        	LD A, 1
 257+ 4E8E 32 7F 4D     	LD (SPRATR_INIT_STATUS), A
 258+ 4E91 C9           	RET
 259+ 4E92               ENDIF
 260+ 4E92               ENDIF
 261+ 4E92
 262+ 4E92               IF (1 + 0 > 0)
 263+ 4E92              ; *******************************************************************************************************
 264+ 4E92              ; function to handle CALL SPRDISABLE basic extension
 265+ 4E92              ; disables sprites handling
 266+ 4E92              ; _SPRDISABLE
 267+ 4E92              ; resets variable SPRATR_INIT_STATUS
 268+ 4E92              SPRDISABLE:
 269+ 4E92              SPRDISABLE_DEFUSR:
 270+ 4E92 AF           	XOR A
 271+ 4E93 32 7F 4D     	LD (SPRATR_INIT_STATUS), A
 272+ 4E96 C9           	RET
 273+ 4E97              ; *******************************************************************************************************
 274+ 4E97               ENDIF
 275+ 4E97
 276+ 4E97              ; *******************************************************************************************************
 277+ 4E97              ; function to handle CALL SPRSET basic extension
 278+ 4E97              ; sets position, and optionally pattern and color of sprite
 279+ 4E97              ; _SPRSET ( BYTE sprite_num , valid 0-31
 280+ 4E97              ;			INT x,
 281+ 4E97              ;			INT y,
 282+ 4E97              ;			INT pattern, valid 0-63, otherwise ignored
 283+ 4E97              ;			INT color, valid 0-15, otherwise ignored
 284+ 4E97              ;SPRSET:
 285+ 4E97              ;	LD A, (SPRATR_INIT_STATUS)
 286+ 4E97              ;	OR A
 287+ 4E97              ;	JR NZ, .L1
 288+ 4E97              ;	LD E, 5 ; illegal function call
 289+ 4E97              ;	JP THROW_ERROR
 290+ 4E97              ;.L1:
 291+ 4E97              ;	; opening (
 292+ 4E97              ;	CALL CHKCHAR
 293+ 4E97              ;	DB '('
 294+ 4E97              ;	; get sprite number
 295+ 4E97              ;	LD IX, GETBYT
 296+ 4E97              ;	CALL CALBAS
 297+ 4E97              ;	PUSH AF
 298+ 4E97              ;	; comma
 299+ 4E97              ;	CALL CHKCHAR
 300+ 4E97              ;	DB ','
 301+ 4E97              ;	; get x
 302+ 4E97              ;	LD IX, FRMQNT
 303+ 4E97              ;	CALL CALBAS
 304+ 4E97              ;	PUSH DE
 305+ 4E97              ;	; comma
 306+ 4E97              ;	CALL CHKCHAR
 307+ 4E97              ;	DB ','
 308+ 4E97              ;	; get y
 309+ 4E97              ;	LD IX, FRMQNT
 310+ 4E97              ;	CALL CALBAS
 311+ 4E97              ;	PUSH DE
 312+ 4E97              ;	; comma
 313+ 4E97              ;	CALL CHKCHAR
 314+ 4E97              ;	DB ','
 315+ 4E97              ;	; get pattern
 316+ 4E97              ;	LD IX, FRMQNT
 317+ 4E97              ;	CALL CALBAS
 318+ 4E97              ;	PUSH DE
 319+ 4E97              ;	; comma
 320+ 4E97              ;	CALL CHKCHAR
 321+ 4E97              ;	DB ','
 322+ 4E97              ;	; get color
 323+ 4E97              ;	LD IX, FRMQNT
 324+ 4E97              ;	CALL CALBAS
 325+ 4E97              ;	PUSH DE
 326+ 4E97              ;	; ending )
 327+ 4E97              ;	CALL CHKCHAR
 328+ 4E97              ;	DB ')'
 329+ 4E97              ;
 330+ 4E97              ;   ; save position in BASIC text
 331+ 4E97              ;	PUSH HL
 332+ 4E97              ;	POP IX
 333+ 4E97              ;
 334+ 4E97              ;	POP BC ; color
 335+ 4E97              ;	POP DE ; pattern
 336+ 4E97              ;	EXX
 337+ 4E97              ;	POP BC ; y
 338+ 4E97              ;	POP DE ; x
 339+ 4E97              ;	POP AF ; sprite number
 340+ 4E97              ;	CP 32
 341+ 4E97              ;	JR C, .L2
 342+ 4E97              ;	LD E, 5 ; illegal function call
 343+ 4E97              ;	JP THROW_ERROR
 344+ 4E97              ;.L2:
 345+ 4E97              ;	; find location in sprite attributes table
 346+ 4E97              ;	PUSH DE
 347+ 4E97              ;	CALL GETnthSPRATTR
 348+ 4E97              ;	POP DE
 349+ 4E97              ;	DI
 350+ 4E97              ;	; set y
 351+ 4E97              ;	LD (HL), C
 352+ 4E97              ;	INC HL
 353+ 4E97              ;	LD (HL), B
 354+ 4E97              ;	INC HL
 355+ 4E97              ;	; set x
 356+ 4E97              ;	LD (HL), E
 357+ 4E97              ;	INC HL
 358+ 4E97              ;	LD (HL), D
 359+ 4E97              ;	INC HL
 360+ 4E97              ;	PUSH HL
 361+ 4E97              ;	EXX
 362+ 4E97              ;	POP HL
 363+ 4E97              ;	; check if 0<=pattern<64
 364+ 4E97              ;	LD A, D
 365+ 4E97              ;	OR A
 366+ 4E97              ;	JR NZ, .L3
 367+ 4E97              ;	LD A, E
 368+ 4E97              ;	CP 64
 369+ 4E97              ;	JR NC, .L3
 370+ 4E97              ;	; set pattern
 371+ 4E97              ;	;ADD A, A
 372+ 4E97              ;	;ADD A, A
 373+ 4E97              ;	;ADD A, A
 374+ 4E97              ;	LD (HL), A
 375+ 4E97              ;	INC HL
 376+ 4E97              ;	LD (HL), D
 377+ 4E97              ;	INC HL
 378+ 4E97              ;	JR .L4
 379+ 4E97              ;.L3:
 380+ 4E97              ;	; skip pattern
 381+ 4E97              ;	.2 INC HL
 382+ 4E97              ;.L4:
 383+ 4E97              ;	; check if 0<=color<16
 384+ 4E97              ;	LD A, B
 385+ 4E97              ;	OR A
 386+ 4E97              ;	JR NZ, .L5
 387+ 4E97              ;	LD A, C
 388+ 4E97              ;	CP 16
 389+ 4E97              ;	JR NC, .L5
 390+ 4E97              ;	; set color
 391+ 4E97              ;	LD (HL), C
 392+ 4E97              ;	INC HL
 393+ 4E97              ;	LD (HL), B
 394+ 4E97              ;
 395+ 4E97              ;.L5:
 396+ 4E97              ;	EI
 397+ 4E97              ;	PUSH IX
 398+ 4E97              ;	POP HL
 399+ 4E97              ;	RET
 400+ 4E97              ; *******************************************************************************************************
 401+ 4E97
 402+ 4E97              ; *******************************************************************************************************
 403+ 4E97              ; function sets sprite location based on initial coordinates and offset provided
 404+ 4E97              ; input A=sprite number in SPRATR_DATA , 0-31
 405+ 4E97              ; input DE=initial x
 406+ 4E97              ; input BC=initial y
 407+ 4E97              ; input IY=location where delta y,x are located
 408+ 4E97              ; modifies AF, HL, IX
 409+ 4E97              SPRSET_DELTA_POS:
 410+ 4E97 D5           	PUSH DE
 411+ 4E98 CD 89 4D     	CALL GETnthSPRATTR
 412+ 4E9B E5           	PUSH HL
 413+ 4E9C DD E1        	POP IX
 414+ 4E9E D1           	POP DE
 415+ 4E9F              	; IX=sprite's y location
 416+ 4E9F FD 6E 00     	LD L, (IY)
 417+ 4EA2 FD 66 01     	LD H, (IY+1)
 418+ 4EA5 09           	ADD HL, BC
 419+ 4EA6 DD 75 00     	LD (IX), L
 420+ 4EA9 DD 74 01     	LD (IX+1), H
 421+ 4EAC FD 6E 02     	LD L, (IY+2)
 422+ 4EAF FD 66 03     	LD H, (IY+3)
 423+ 4EB2 19           	ADD HL, DE
 424+ 4EB3 DD 75 02     	LD (IX+2), L
 425+ 4EB6 DD 74 03     	LD (IX+3), H
 426+ 4EB9 C9           	RET
 427+ 4EBA              ; *******************************************************************************************************
 428+ 4EBA
 429+ 4EBA              ; *******************************************************************************************************
 430+ 4EBA              ; helper function to set new locations for a set of sprites
 431+ 4EBA              ; input B=number of sprites
 432+ 4EBA              ; HL=pointer to list of sprites and offsets
 433+ 4EBA              SPR_UPDATE_LOC:
 434+ 4EBA 3E 01        	LD A,1
 435+ 4EBC 32 1B 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 436+ 4EBF 7E           	LD A, (HL)
 437+ 4EC0 23           	INC HL
 438+ 4EC1 23           	INC HL
 439+ 4EC2 E5           	PUSH HL
 440+ 4EC3 FD E1        	POP IY
 441+ 4EC5 D9           	EXX
 442+ 4EC6 CD 97 4E     	CALL SPRSET_DELTA_POS
 443+ 4EC9 D9           	EXX
 444+ 4ECA 23          > INC HL
 444+ 4ECB 23          > INC HL
 444+ 4ECC 23          > INC HL
 444+ 4ECD 23          > INC HL
 445+ 4ECE 10 EA        	DJNZ SPR_UPDATE_LOC
 446+ 4ED0 AF           	XOR A
 447+ 4ED1 32 1B 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 448+ 4ED4 C9           	RET
 449+ 4ED5              ; *******************************************************************************************************
 450+ 4ED5
 451+ 4ED5               IF (0 == 1)
 452+ 4ED5 ~            ; *******************************************************************************************************
 453+ 4ED5 ~            ; function to handle CALL SPRGRPMOV basic extension
 454+ 4ED5 ~            ; sets position of a group of sprites described with
 455+ 4ED5 ~            ; { int sprite_num, int delta_y, int delta_x } [count]
 456+ 4ED5 ~            ; _SPRGRPMOV ( INT x,
 457+ 4ED5 ~            ;			   INT y,
 458+ 4ED5 ~            ;			   BYTE count,
 459+ 4ED5 ~            ;			   INT[2][count] data_ptr
 460+ 4ED5 ~            SPRGRPMOV:
 461+ 4ED5 ~            	LD A, (SPRATR_INIT_STATUS)
 462+ 4ED5 ~            	OR A
 463+ 4ED5 ~            	JP Z,ILLEGAL_FUNCTION
 464+ 4ED5 ~            	; opening (
 465+ 4ED5 ~            	CALL CHKCHAR
 466+ 4ED5 ~            	DB '('
 467+ 4ED5 ~            	; get x
 468+ 4ED5 ~            	LD IX, FRMQNT
 469+ 4ED5 ~            	CALL CALBAS
 470+ 4ED5 ~            	LD (BLIT_STRUCT),DE
 471+ 4ED5 ~            	; comma
 472+ 4ED5 ~            	CALL CHKCHAR
 473+ 4ED5 ~            	DB ','
 474+ 4ED5 ~            	; get y
 475+ 4ED5 ~            	LD IX, FRMQNT
 476+ 4ED5 ~            	CALL CALBAS
 477+ 4ED5 ~            	LD (BLIT_STRUCT+2),DE
 478+ 4ED5 ~            	; comma
 479+ 4ED5 ~            	CALL CHKCHAR
 480+ 4ED5 ~            	DB ','
 481+ 4ED5 ~            	; get count
 482+ 4ED5 ~            	LD IX, GETBYT
 483+ 4ED5 ~            	CALL CALBAS
 484+ 4ED5 ~            	LD (BLIT_STRUCT+4),A
 485+ 4ED5 ~            	; comma
 486+ 4ED5 ~            	CALL CHKCHAR
 487+ 4ED5 ~            	DB ','
 488+ 4ED5 ~            	; get sprite group definition array data pointer
 489+ 4ED5 ~            	LD A,(BLIT_STRUCT+4)
 490+ 4ED5 ~            	LD E,A
 491+ 4ED5 ~            	LD D,3
 492+ 4ED5 ~            	LD A,2
 493+ 4ED5 ~            	LD B,A
 494+ 4ED5 ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
 495+ 4ED5 ~            	LD (BLIT_STRUCT+5),BC
 496+ 4ED5 ~            	; ending )
 497+ 4ED5 ~            	CALL CHKCHAR
 498+ 4ED5 ~            	DB ')'
 499+ 4ED5 ~
 500+ 4ED5 ~            	PUSH HL
 501+ 4ED5 ~
 502+ 4ED5 ~                EXX
 503+ 4ED5 ~                LD DE,(BLIT_STRUCT) ; initial x
 504+ 4ED5 ~                LD BC,(BLIT_STRUCT+2) ; initial y
 505+ 4ED5 ~                EXX
 506+ 4ED5 ~                LD HL,(BLIT_STRUCT+5) ; pointer to data
 507+ 4ED5 ~                LD A,(BLIT_STRUCT+4) ; number of entries
 508+ 4ED5 ~                LD B,A
 509+ 4ED5 ~            	CALL SPR_UPDATE_LOC
 510+ 4ED5 ~
 511+ 4ED5 ~            	POP HL
 512+ 4ED5 ~            	RET
 513+ 4ED5 ~            ; *******************************************************************************************************
 514+ 4ED5               ENDIF
 515+ 4ED5
 516+ 4ED5               IF (1 == 1)
 517+ 4ED5              ; *******************************************************************************************************
 518+ 4ED5              ; same as SPRGRPMOV but for DEFUSR approach
 519+ 4ED5              ; input IX=pointer to input array, real data from +2
 520+ 4ED5              ; +2 = X
 521+ 4ED5              ; +4 = Y
 522+ 4ED5              ; +6 = count
 523+ 4ED5              ; +8 = data pointer
 524+ 4ED5              SPRGRPMOV_DEFUSR:
 525+ 4ED5 D9               EXX
 526+ 4ED6 DD 5E 02     	LD E,(IX+2)
 527+ 4ED9 DD 56 03     	LD D,(IX+3) ; initial x
 528+ 4EDC DD 4E 04     	LD C,(IX+4)
 529+ 4EDF DD 46 05     	LD B,(IX+5) ; initial y
 530+ 4EE2 D9               EXX
 531+ 4EE3 DD 6E 08     	LD L,(IX+8)
 532+ 4EE6 DD 66 09     	LD H,(IX+9) ; pointer to data
 533+ 4EE9 DD 46 06         LD B,(IX+6) ; count
 534+ 4EEC C3 BA 4E         JP SPR_UPDATE_LOC
 535+ 4EEF              ; *******************************************************************************************************
 536+ 4EEF               ENDIF
# file closed: asm\SPRITES.asm
 129  4EEF               ENDIF
 130  4EEF
 131  4EEF               IF (ANIM_CMDS == 1)
 132  4EEF               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4EEF              ; sprite animation routines
   2+ 4EEF
   3+ 4EEF              ; number of animation items and pointer
   4+ 4EEF              ANIMITEMNUM:
   5+ 4EEF 00            DB 0
   6+ 4EF0              ANIMITEMPTR:
   7+ 4EF0 F1 5E         DW EXT_END
   8+ 4EF2              ; number of animation definitions and pointer
   9+ 4EF2              ANIMDEFNUM:
  10+ 4EF2 00            DB 0
  11+ 4EF3              ANIMDEFPTR:
  12+ 4EF3 F1 5E         DW EXT_END
  13+ 4EF5              ; number of links between sprite and animation definitions
  14+ 4EF5              ANIMSPRNUM:
  15+ 4EF5 00            DB 0
  16+ 4EF6              ANIMSPRPTR:
  17+ 4EF6 F1 5E         DW EXT_END
  18+ 4EF8              ; number of automatic sprite group move and animate structures
  19+ 4EF8              AUTOSGAMNUM:
  20+ 4EF8 00            DB 0
  21+ 4EF9              AUTOSGAMPTR:
  22+ 4EF9 F1 5E         DW EXT_END
  23+ 4EFB
  24+ 4EFB              ; ANIMATION ITEM
  25+ 4EFB              ; byte type = [0 - pattern and color change
  26+ 4EFB              ;              1 - pattern definition change ]
  27+ 4EFB              ; word ticks - number of ticks to hold this state
  28+ 4EFB              ; for type = 0
  29+ 4EFB              ;   byte pattern;
  30+ 4EFB              ;   byte color;
  31+ 4EFB              ; for type = 1
  32+ 4EFB              ;   work data_pointer;
  33+ 4EFB              ; total size = 5b
  34+ 4EFB
  35+ 4EFB              ; ANIMATION DEFINITION
  36+ 4EFB              ; byte number of items 1-15
  37+ 4EFB              ; byte[15] anim_item;
  38+ 4EFB              ; total size = 16b
  39+ 4EFB
  40+ 4EFB              ; SPRITE/CHAR ANIMATION
  41+ 4EFB              ; +00 byte sprite/char number;
  42+ 4EFB              ; +01 word time;
  43+ 4EFB              ; +03 byte current item;
  44+ 4EFB              ; +04 byte animation definition;
  45+ 4EFB              ; +05 byte cyclic;
  46+ 4EFB              ; +06 byte active;
  47+ 4EFB              ; +07 byte 0=sprite, 1-3 character bank
  48+ 4EFB              ; total size = 8b
  49+ 4EFB
  50+ 4EFB              ; AUTOMATIC SPRITE GROUP MOVE AND ANIMATE structure
  51+ 4EFB              ; +00 pointer to X variable
  52+ 4EFB              ; +02 pointer to Y variable
  53+ 4EFB              ; +04 minimum value
  54+ 4EFB              ; +06 maximal value
  55+ 4EFB              ; +08 delta value
  56+ 4EFB              ; +10 direction 0=horizontal, <>0 = vertical
  57+ 4EFB              ; +11 sprite group size
  58+ 4EFB              ; +12 sprite group pointer
  59+ 4EFB              ; +14 animation list size
  60+ 4EFB              ; +15 animation list pointer for negative delta values
  61+ 4EFB              ; +17 animation list pointer for positive delta values
  62+ 4EFB              ; +19 active flag
  63+ 4EFB              ; +20 ticks for movement
  64+ 4EFB              ; +22 timer
  65+ 4EFB              ; total = 24b
  66+ 4EFB
  67+ 4EFB              ; *******************************************************************************************************
  68+ 4EFB              ; helper function HL=A*5
  69+ 4EFB              ; changes HL,DE
  70+ 4EFB              Ax5:
  71+ 4EFB 26 00            LD H,0
  72+ 4EFD 6F               LD L,A
  73+ 4EFE 54               LD D,H
  74+ 4EFF 5D               LD E,L
  75+ 4F00 29               ADD HL,HL
  76+ 4F01 29               ADD HL,HL
  77+ 4F02 19               ADD HL,DE
  78+ 4F03 C9               RET
  79+ 4F04              ; *******************************************************************************************************
  80+ 4F04
  81+ 4F04              ; *******************************************************************************************************
  82+ 4F04              ; helper function gets pointer to n-th animation item
  83+ 4F04              ; changes HL,DE
  84+ 4F04              GETnthANIMITEM:
  85+ 4F04 CD FB 4E         CALL Ax5
  86+ 4F07 ED 5B F0 4E      LD DE,(ANIMITEMPTR)
  87+ 4F0B 19               ADD HL,DE
  88+ 4F0C C9               RET
  89+ 4F0D              ; *******************************************************************************************************
  90+ 4F0D
  91+ 4F0D              ; *******************************************************************************************************
  92+ 4F0D              ; helper function gets pointer to n-th entry in animation definition
  93+ 4F0D              ; changes HL,DE
  94+ 4F0D              GETnthANIMDEF:
  95+ 4F0D 26 00            LD H,0
  96+ 4F0F 6F               LD L,A
  97+ 4F10 CD 6F 5D         CALL HLx16
  98+ 4F13 ED 5B F3 4E      LD DE,(ANIMDEFPTR)
  99+ 4F17 19               ADD HL,DE
 100+ 4F18 C9               RET
 101+ 4F19              ; *******************************************************************************************************
 102+ 4F19
 103+ 4F19              ; *******************************************************************************************************
 104+ 4F19              ; helper function gets pointer to n-th entry in sprite animation
 105+ 4F19              ; changes HL,DE
 106+ 4F19              GETnthSPRANIM:
 107+ 4F19 26 00            LD H,0
 108+ 4F1B 6F               LD L,A
 109+ 4F1C CD 70 5D         CALL HLx8
 110+ 4F1F ED 5B F6 4E      LD DE,(ANIMSPRPTR)
 111+ 4F23 19               ADD HL,DE
 112+ 4F24 C9               RET
 113+ 4F25              ; *******************************************************************************************************
 114+ 4F25
 115+ 4F25              ; *******************************************************************************************************
 116+ 4F25              ; helper function gets pointer to n-th entry in autosgam table
 117+ 4F25              ; changes HL,DE
 118+ 4F25              GETnthAUTOSGAM:
 119+ 4F25 26 00            LD H,0
 120+ 4F27 6F               LD L,A
 121+ 4F28 CD 70 5D         CALL HLx8
 122+ 4F2B 54               LD D,H
 123+ 4F2C 5D               LD E,L
 124+ 4F2D 29               ADD HL,HL
 125+ 4F2E 19               ADD HL,DE
 126+ 4F2F ED 5B F9 4E      LD DE,(AUTOSGAMPTR)
 127+ 4F33 19               ADD HL,DE
 128+ 4F34 C9               RET
 129+ 4F35              ; *******************************************************************************************************
 130+ 4F35
 131+ 4F35               IF (1 == 1)
 132+ 4F35              ; *******************************************************************************************************
 133+ 4F35              ; same as MAXIANIMITEMS but for DEFUSR approach
 134+ 4F35              ; input IX=pointer to input array, real data from +2
 135+ 4F35              ; +2 = number
 136+ 4F35              MAXANIMITEMS_DEFUSR:
 137+ 4F35 DD 7E 02         LD A,(IX+2)
 138+ 4F38 18 00            JR MAXANIMITEMS.COMMON
 139+ 4F3A              ; *******************************************************************************************************
 140+ 4F3A               ENDIF
 141+ 4F3A
 142+ 4F3A              ; *******************************************************************************************************
 143+ 4F3A              ; function to handle CALL MAXANIMITEMS basic extension
 144+ 4F3A              ; MAXANIMITEMS (BYTE number)
 145+ 4F3A              ; sets new number and moves memory buffers as needed
 146+ 4F3A              MAXANIMITEMS:
 147+ 4F3A               IF (0 == 1)
 148+ 4F3A ~            	; opening (
 149+ 4F3A ~            	CALL CHKCHAR
 150+ 4F3A ~            	DB '('
 151+ 4F3A ~            	; get value
 152+ 4F3A ~            	LD IX, GETBYT
 153+ 4F3A ~            	CALL CALBAS
 154+ 4F3A ~                PUSH AF
 155+ 4F3A ~            	; ending )
 156+ 4F3A ~            	CALL CHKCHAR
 157+ 4F3A ~            	DB ')'
 158+ 4F3A ~                POP AF
 159+ 4F3A               ENDIF
 160+ 4F3A              .COMMON: ; entry for DEFUSR part, A=number
 161+ 4F3A F3               DI
 162+ 4F3B              	; save position
 163+ 4F3B E5           	PUSH HL
 164+ 4F3C              .ENTRY:
 165+ 4F3C 47               LD B,A
 166+ 4F3D 3A EF 4E         LD A,(ANIMITEMNUM)
 167+ 4F40 90               SUB B
 168+ 4F41 28 28            JR Z, .EXIT; same value as before
 169+ 4F43 FD 21 F3 4E      LD IY,ANIMDEFPTR
 170+ 4F47 FA 6E 4F         JP M, .INCREASE
 171+ 4F4A                  ; new value is lower than previous one
 172+ 4F4A CD 8D 4F         CALL .SIZEDIFF
 173+ 4F4D CD A8 4F         CALL .DECREASE_COMMON
 174+ 4F50 2A F6 4E         LD HL,(ANIMSPRPTR)
 175+ 4F53 AF               XOR A
 176+ 4F54 ED 42            SBC HL,BC
 177+ 4F56 22 F6 4E         LD (ANIMSPRPTR),HL
 178+ 4F59              .E1:
 179+ 4F59 2A F9 4E         LD HL,(AUTOSGAMPTR)
 180+ 4F5C AF               XOR A
 181+ 4F5D ED 42            SBC HL,BC
 182+ 4F5F 22 F9 4E         LD (AUTOSGAMPTR),HL
 183+ 4F62              .E3:
 184+ 4F62 2A 10 40         LD HL,(FREEMEMPTR)
 185+ 4F65 AF               XOR A
 186+ 4F66 ED 42            SBC HL,BC
 187+ 4F68 22 10 40         LD (FREEMEMPTR),HL
 188+ 4F6B              .EXIT:
 189+ 4F6B FB               EI
 190+ 4F6C E1           	POP HL
 191+ 4F6D C9           	RET
 192+ 4F6E              .INCREASE:
 193+ 4F6E ED 44            NEG
 194+ 4F70 CD 8D 4F         CALL .SIZEDIFF
 195+ 4F73 CD D4 4F         CALL .INCREASE_COMMON
 196+ 4F76 2A F6 4E         LD HL,(ANIMSPRPTR)
 197+ 4F79 09               ADD HL,BC
 198+ 4F7A 22 F6 4E         LD (ANIMSPRPTR),HL
 199+ 4F7D              .E2:
 200+ 4F7D 2A F9 4E         LD HL,(AUTOSGAMPTR)
 201+ 4F80 09               ADD HL,BC
 202+ 4F81 22 F9 4E         LD (AUTOSGAMPTR),HL
 203+ 4F84              .E4:
 204+ 4F84 2A 10 40         LD HL,(FREEMEMPTR)
 205+ 4F87 09               ADD HL,BC
 206+ 4F88 22 10 40         LD (FREEMEMPTR),HL
 207+ 4F8B 18 DE            JR .EXIT
 208+ 4F8D              .SIZEDIFF:
 209+ 4F8D CD FB 4E         CALL Ax5
 210+ 4F90 78               LD A,B
 211+ 4F91 32 EF 4E         LD (ANIMITEMNUM),A
 212+ 4F94 44               LD B,H
 213+ 4F95 4D               LD C,L
 214+ 4F96 C9               RET ; BC=size difference in bytes
 215+ 4F97              .SIZETOMOVE:
 216+ 4F97 D5               PUSH DE
 217+ 4F98 2A 10 40         LD HL,(FREEMEMPTR)
 218+ 4F9B FD 5E 00         LD E,(IY)
 219+ 4F9E FD 56 01         LD D,(IY+1)
 220+ 4FA1 AF               XOR A
 221+ 4FA2 ED 52            SBC HL,DE
 222+ 4FA4 44               LD B,H
 223+ 4FA5 4D               LD C,L
 224+ 4FA6 D1               POP DE
 225+ 4FA7 C9               RET
 226+ 4FA8              .DECREASE_COMMON:
 227+ 4FA8 FD 6E 00         LD L,(IY)
 228+ 4FAB FD 66 01         LD H,(IY+1)
 229+ 4FAE AF               XOR A
 230+ 4FAF ED 42            SBC HL,BC
 231+ 4FB1 EB               EX DE,HL
 232+ 4FB2 C5               PUSH BC
 233+ 4FB3 CD 97 4F         CALL .SIZETOMOVE
 234+ 4FB6 F3               DI
 235+ 4FB7 78               LD A,B
 236+ 4FB8 B1               OR C
 237+ 4FB9 28 08            JR Z,.L1
 238+ 4FBB FD 6E 00         LD L,(IY)
 239+ 4FBE FD 66 01         LD H,(IY+1)
 240+ 4FC1 ED B0            LDIR
 241+ 4FC3              .L1:
 242+ 4FC3 C1               POP BC
 243+ 4FC4 FD 6E 00         LD L,(IY)
 244+ 4FC7 FD 66 01         LD H,(IY+1)
 245+ 4FCA AF               XOR A
 246+ 4FCB ED 42            SBC HL,BC
 247+ 4FCD FD 75 00         LD (IY),L
 248+ 4FD0 FD 74 01         LD (IY+1),H
 249+ 4FD3 C9               RET
 250+ 4FD4              .INCREASE_COMMON:
 251+ 4FD4 2A 10 40         LD HL,(FREEMEMPTR)
 252+ 4FD7 2B               DEC HL
 253+ 4FD8 AF               XOR A
 254+ 4FD9 ED 42            SBC HL,BC
 255+ 4FDB EB               EX DE,HL
 256+ 4FDC C5               PUSH BC
 257+ 4FDD CD 97 4F         CALL .SIZETOMOVE
 258+ 4FE0 F3               DI
 259+ 4FE1 78               LD A,B
 260+ 4FE2 B1               OR C
 261+ 4FE3 28 06            JR Z,.L2
 262+ 4FE5 2A 10 40         LD HL,(FREEMEMPTR)
 263+ 4FE8 2B               DEC HL
 264+ 4FE9 ED B8            LDDR
 265+ 4FEB              .L2:
 266+ 4FEB C1               POP BC
 267+ 4FEC FD 6E 00         LD L,(IY)
 268+ 4FEF FD 66 01         LD H,(IY+1)
 269+ 4FF2 09               ADD HL,BC
 270+ 4FF3 FD 75 00         LD (IY),L
 271+ 4FF6 FD 74 01         LD (IY+1),H
 272+ 4FF9 C9               RET
 273+ 4FFA              ; *******************************************************************************************************
 274+ 4FFA
 275+ 4FFA               IF (0 == 1)
 276+ 4FFA ~            ; *******************************************************************************************************
 277+ 4FFA ~            ; function to handle CALL ANIMITEMPAT basic extension
 278+ 4FFA ~            ; ANIMITEMPAT ( BYTE id,
 279+ 4FFA ~            ;               INT ticks >0,
 280+ 4FFA ~            ;               BYTE pattern,
 281+ 4FFA ~            ;               BYTE color )
 282+ 4FFA ~            ; fills animation item data, returns an error if ID out of bounds
 283+ 4FFA ~            ANIMITEMPAT:
 284+ 4FFA ~                ; opening (
 285+ 4FFA ~            	CALL CHKCHAR
 286+ 4FFA ~            	DB '('
 287+ 4FFA ~            	; get id
 288+ 4FFA ~            	LD IX, GETBYT
 289+ 4FFA ~            	CALL CALBAS
 290+ 4FFA ~                PUSH AF
 291+ 4FFA ~                ; check if out of bounds
 292+ 4FFA ~                INC A
 293+ 4FFA ~                LD C,A
 294+ 4FFA ~                LD A,(ANIMITEMNUM)
 295+ 4FFA ~                CP C
 296+ 4FFA ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 297+ 4FFA ~            	; comma
 298+ 4FFA ~            	CALL CHKCHAR
 299+ 4FFA ~            	DB ','
 300+ 4FFA ~            	; get ticks
 301+ 4FFA ~            	LD IX, FRMQNT
 302+ 4FFA ~            	CALL CALBAS
 303+ 4FFA ~                LD A,D
 304+ 4FFA ~                OR E
 305+ 4FFA ~                JP Z, OVERFLOW
 306+ 4FFA ~            	PUSH DE
 307+ 4FFA ~            	; comma
 308+ 4FFA ~            	CALL CHKCHAR
 309+ 4FFA ~            	DB ','
 310+ 4FFA ~            	; get pattern
 311+ 4FFA ~            	LD IX, GETBYT
 312+ 4FFA ~            	CALL CALBAS
 313+ 4FFA ~                PUSH AF
 314+ 4FFA ~            	; comma
 315+ 4FFA ~            	CALL CHKCHAR
 316+ 4FFA ~            	DB ','
 317+ 4FFA ~            	; get color
 318+ 4FFA ~            	LD IX, GETBYT
 319+ 4FFA ~            	CALL CALBAS
 320+ 4FFA ~                PUSH AF
 321+ 4FFA ~            	; ending )
 322+ 4FFA ~            	CALL CHKCHAR
 323+ 4FFA ~            	DB ')'
 324+ 4FFA ~            .ENTRY:
 325+ 4FFA ~                PUSH HL
 326+ 4FFA ~                POP IX
 327+ 4FFA ~                EXX
 328+ 4FFA ~                POP BC ; color
 329+ 4FFA ~                POP DE ; pattern
 330+ 4FFA ~                POP HL ; ticks
 331+ 4FFA ~                EXX
 332+ 4FFA ~                POP AF
 333+ 4FFA ~                CALL GETnthANIMITEM
 334+ 4FFA ~                PUSH HL
 335+ 4FFA ~                POP IY
 336+ 4FFA ~                EXX
 337+ 4FFA ~                LD (IY),0 ; type=0
 338+ 4FFA ~                LD (IY+1),L
 339+ 4FFA ~                LD (IY+2),H
 340+ 4FFA ~                LD (IY+3),D
 341+ 4FFA ~                LD (IY+4),B
 342+ 4FFA ~
 343+ 4FFA ~                PUSH IX
 344+ 4FFA ~                POP HL
 345+ 4FFA ~                RET
 346+ 4FFA ~            ; *******************************************************************************************************
 347+ 4FFA               ENDIF
 348+ 4FFA
 349+ 4FFA               IF (1 == 1)
 350+ 4FFA              ; *******************************************************************************************************
 351+ 4FFA              ; same as ANIMITEMPAT but for DEFUSR approach
 352+ 4FFA              ; input IX=pointer to input array, real data from +2
 353+ 4FFA              ; +02 = ID
 354+ 4FFA              ; +04 = ticks
 355+ 4FFA              ; +06 = pattern
 356+ 4FFA              ; +08 = color
 357+ 4FFA              ANIMITEMPAT_DEFUSR:
 358+ 4FFA                  ; check if out of bounds
 359+ 4FFA DD 4E 02         LD C,(IX+2)
 360+ 4FFD 0C               INC C
 361+ 4FFE 3A EF 4E         LD A,(ANIMITEMNUM)
 362+ 5001 B9               CP C
 363+ 5002 D8               RET C ; out of bounds, prevent memory corruption
 364+ 5003 79               LD A,C
 365+ 5004 3D               DEC A
 366+ 5005 CD 04 4F         CALL GETnthANIMITEM
 367+ 5008 36 00            LD (HL),0 ; type=0
 368+ 500A 23               INC HL
 369+ 500B DD 7E 04         LD A,(IX+4) ; ticks low
 370+ 500E 77               LD (HL),A
 371+ 500F 23               INC HL
 372+ 5010 DD 7E 05         LD A,(IX+5) ; ticks high
 373+ 5013 77               LD (HL),A
 374+ 5014 23               INC HL
 375+ 5015 DD 7E 06         LD A,(IX+6) ; pattern
 376+ 5018 77               LD (HL),A
 377+ 5019 23               INC HL
 378+ 501A DD 7E 08         LD A,(IX+8) ; color
 379+ 501D 77               LD (HL),A
 380+ 501E C9               RET
 381+ 501F              ; *******************************************************************************************************
 382+ 501F               ENDIF
 383+ 501F
 384+ 501F               IF (0 == 1)
 385+ 501F ~            ; *******************************************************************************************************
 386+ 501F ~            ; function to handle CALL ANIMITEMPTR basic extension
 387+ 501F ~            ; ANIMITEMPTR ( BYTE id,
 388+ 501F ~            ;               INT ticks,
 389+ 501F ~            ;               INT pointer,
 390+ 501F ~            ; fills animation item data, returns an error if ID out of bounds
 391+ 501F ~            ANIMITEMPTR_CMD:
 392+ 501F ~                ; opening (
 393+ 501F ~            	CALL CHKCHAR
 394+ 501F ~            	DB '('
 395+ 501F ~            	; get id
 396+ 501F ~            	LD IX, GETBYT
 397+ 501F ~            	CALL CALBAS
 398+ 501F ~                PUSH AF
 399+ 501F ~                ; check if out of bounds
 400+ 501F ~                INC A
 401+ 501F ~                LD C,A
 402+ 501F ~                LD A,(ANIMITEMNUM)
 403+ 501F ~                CP C
 404+ 501F ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 405+ 501F ~            	; comma
 406+ 501F ~            	CALL CHKCHAR
 407+ 501F ~            	DB ','
 408+ 501F ~            	; get ticks
 409+ 501F ~            	LD IX, FRMQNT
 410+ 501F ~            	CALL CALBAS
 411+ 501F ~                LD A,D
 412+ 501F ~                OR E
 413+ 501F ~                JP Z,OVERFLOW
 414+ 501F ~            	PUSH DE
 415+ 501F ~            	; comma
 416+ 501F ~            	CALL CHKCHAR
 417+ 501F ~            	DB ','
 418+ 501F ~            	; get pointer
 419+ 501F ~            	LD IX, FRMQNT
 420+ 501F ~            	CALL CALBAS
 421+ 501F ~            	PUSH DE
 422+ 501F ~            	; ending )
 423+ 501F ~            	CALL CHKCHAR
 424+ 501F ~            	DB ')'
 425+ 501F ~            .ENTRY:
 426+ 501F ~                PUSH HL
 427+ 501F ~                POP IX
 428+ 501F ~                EXX
 429+ 501F ~                POP DE ; pointer
 430+ 501F ~                POP HL ; ticks
 431+ 501F ~                EXX
 432+ 501F ~                POP AF
 433+ 501F ~                CALL GETnthANIMITEM
 434+ 501F ~                PUSH HL
 435+ 501F ~                POP IY
 436+ 501F ~                EXX
 437+ 501F ~                LD (IY),1 ; type=1
 438+ 501F ~                LD (IY+1),L
 439+ 501F ~                LD (IY+2),H
 440+ 501F ~                LD (IY+3),E
 441+ 501F ~                LD (IY+4),D
 442+ 501F ~
 443+ 501F ~                PUSH IX
 444+ 501F ~                POP HL
 445+ 501F ~                RET
 446+ 501F ~            ; *******************************************************************************************************
 447+ 501F               ENDIF
 448+ 501F
 449+ 501F               IF (1 == 1)
 450+ 501F              ; *******************************************************************************************************
 451+ 501F              ; same as ANIMITEMPTR but for DEFUSR approach
 452+ 501F              ; input IX=pointer to input array, real data from +2
 453+ 501F              ; +02 = ID
 454+ 501F              ; +04 = ticks
 455+ 501F              ; +06 = pointer
 456+ 501F              ANIMITEMPTR_DEFUSR:
 457+ 501F                  ; check if out of bounds
 458+ 501F DD 4E 02         LD C,(IX+2)
 459+ 5022 0C               INC C
 460+ 5023 3A EF 4E         LD A,(ANIMITEMNUM)
 461+ 5026 B9               CP C
 462+ 5027 D8               RET C ; out of bounds, prevent memory corruption
 463+ 5028 79               LD A,C
 464+ 5029 3D               DEC A
 465+ 502A CD 04 4F         CALL GETnthANIMITEM
 466+ 502D 36 01            LD (HL),1 ; type=1
 467+ 502F 23               INC HL
 468+ 5030 DD 7E 04         LD A,(IX+4) ; ticks low
 469+ 5033 77               LD (HL),A
 470+ 5034 23               INC HL
 471+ 5035 DD 7E 05         LD A,(IX+5) ; ticks high
 472+ 5038 77               LD (HL),A
 473+ 5039 23               INC HL
 474+ 503A DD 7E 06         LD A,(IX+6) ; pointer low
 475+ 503D 77               LD (HL),A
 476+ 503E 23               INC HL
 477+ 503F DD 7E 07         LD A,(IX+7) ; pointer high
 478+ 5042 77               LD (HL),A
 479+ 5043 C9               RET
 480+ 5044              ; *******************************************************************************************************
 481+ 5044               ENDIF
 482+ 5044
 483+ 5044               IF (1 == 1)
 484+ 5044              ; *******************************************************************************************************
 485+ 5044              ; same as MAXANIMDEFS but for DEFUSR approach
 486+ 5044              ; input IX=pointer to input array, real data from +2
 487+ 5044              ; +2 = number
 488+ 5044              MAXANIMDEFS_DEFUSR:
 489+ 5044 DD 7E 02         LD A,(IX+2)
 490+ 5047 18 00            JR MAXANIMDEFS.COMMON
 491+ 5049              ; *******************************************************************************************************
 492+ 5049               ENDIF
 493+ 5049
 494+ 5049              ; *******************************************************************************************************
 495+ 5049              ; function to handle CALL MAXANIMDEFS basic extension
 496+ 5049              ; MAXANIMDEFS (BYTE number)
 497+ 5049              ; sets new number and moves memory buffers as needed
 498+ 5049              MAXANIMDEFS:
 499+ 5049               IF (0 == 1)
 500+ 5049 ~            	; opening (
 501+ 5049 ~            	CALL CHKCHAR
 502+ 5049 ~            	DB '('
 503+ 5049 ~            	; get value
 504+ 5049 ~            	LD IX, GETBYT
 505+ 5049 ~            	CALL CALBAS
 506+ 5049 ~                PUSH AF
 507+ 5049 ~            	; ending )
 508+ 5049 ~            	CALL CHKCHAR
 509+ 5049 ~            	DB ')'
 510+ 5049 ~                POP AF
 511+ 5049               ENDIF
 512+ 5049              .COMMON:
 513+ 5049 F3               DI
 514+ 504A              	; save position
 515+ 504A E5           	PUSH HL
 516+ 504B              .ENTRY:
 517+ 504B 47               LD B,A
 518+ 504C 3A F2 4E         LD A,(ANIMDEFNUM)
 519+ 504F 90               SUB B
 520+ 5050 CA 6B 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 521+ 5053 FD 21 F6 4E      LD IY,ANIMSPRPTR
 522+ 5057 FA 63 50         JP M, .INCREASE
 523+ 505A                  ; new value is lower than previous one
 524+ 505A CD 6E 50         CALL .SIZEDIFF
 525+ 505D CD A8 4F         CALL MAXANIMITEMS.DECREASE_COMMON
 526+ 5060 C3 59 4F         JP MAXANIMITEMS.E1
 527+ 5063              .INCREASE:
 528+ 5063 ED 44            NEG
 529+ 5065 CD 6E 50         CALL .SIZEDIFF
 530+ 5068 CD D4 4F         CALL MAXANIMITEMS.INCREASE_COMMON
 531+ 506B C3 7D 4F         JP MAXANIMITEMS.E2
 532+ 506E              .SIZEDIFF:
 533+ 506E 26 00            LD H,0
 534+ 5070 6F               LD L,A
 535+ 5071 CD 6F 5D         CALL HLx16
 536+ 5074 78               LD A,B
 537+ 5075 32 F2 4E         LD (ANIMDEFNUM),A
 538+ 5078 44               LD B,H
 539+ 5079 4D               LD C,L
 540+ 507A C9               RET ; BC=size difference in bytes
 541+ 507B              ; *******************************************************************************************************
 542+ 507B
 543+ 507B               IF (0 == 1)
 544+ 507B ~            ; *******************************************************************************************************
 545+ 507B ~            ; function to handle CALL ANIMDEF basic extension
 546+ 507B ~            ; ANIMITEMPAT ( BYTE id,
 547+ 507B ~            ;               BYTE size,
 548+ 507B ~            ;               INT[] list )
 549+ 507B ~            ; fills animation definition data, returns an error if out of bounds, or invalid type
 550+ 507B ~            ANIMDEF:
 551+ 507B ~                ; opening (
 552+ 507B ~            	CALL CHKCHAR
 553+ 507B ~            	DB '('
 554+ 507B ~            	; get id
 555+ 507B ~            	LD IX, GETBYT
 556+ 507B ~            	CALL CALBAS
 557+ 507B ~                PUSH AF
 558+ 507B ~                ; check if out of bounds
 559+ 507B ~                INC A
 560+ 507B ~                LD C,A
 561+ 507B ~                LD A,(ANIMDEFNUM)
 562+ 507B ~                CP C
 563+ 507B ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 564+ 507B ~            	; comma
 565+ 507B ~            	CALL CHKCHAR
 566+ 507B ~            	DB ','
 567+ 507B ~            	; get size
 568+ 507B ~            	LD IX, GETBYT
 569+ 507B ~            	CALL CALBAS
 570+ 507B ~                CP 16
 571+ 507B ~                JP NC, OVERFLOW
 572+ 507B ~                OR A
 573+ 507B ~                JP Z, OVERFLOW
 574+ 507B ~            	PUSH AF
 575+ 507B ~            	; comma
 576+ 507B ~            	CALL CHKCHAR
 577+ 507B ~            	DB ','
 578+ 507B ~            	; get pointer to a list of animation items in integer array format
 579+ 507B ~                ; get array pointer
 580+ 507B ~                POP DE
 581+ 507B ~                PUSH DE
 582+ 507B ~                LD A,2
 583+ 507B ~                LD B,1
 584+ 507B ~                CALL GET_BASIC_ARRAY_DATA_POINTER
 585+ 507B ~                PUSH BC
 586+ 507B ~            	; ending )
 587+ 507B ~            	CALL CHKCHAR
 588+ 507B ~            	DB ')'
 589+ 507B ~            .ENTRY:
 590+ 507B ~                PUSH HL
 591+ 507B ~                POP IX
 592+ 507B ~                POP DE ; pointer to INT array
 593+ 507B ~                POP BC ; B=item number
 594+ 507B ~                POP AF ; id
 595+ 507B ~                PUSH DE
 596+ 507B ~                CALL GETnthANIMDEF
 597+ 507B ~                POP DE
 598+ 507B ~                LD (HL),B
 599+ 507B ~            .L1:
 600+ 507B ~                INC HL
 601+ 507B ~                LD A,(DE)
 602+ 507B ~                .2 INC DE
 603+ 507B ~                LD (HL),A
 604+ 507B ~                DJNZ .L1
 605+ 507B ~                PUSH IX
 606+ 507B ~                POP HL
 607+ 507B ~                RET
 608+ 507B ~            ; *******************************************************************************************************
 609+ 507B               ENDIF
 610+ 507B
 611+ 507B               IF (1 == 1)
 612+ 507B              ; *******************************************************************************************************
 613+ 507B              ; same as ANIMDEF but for DEFUSR approach
 614+ 507B              ; input IX=pointer to input array, real data from +2
 615+ 507B              ; +02 = ID
 616+ 507B              ; +04 = list size
 617+ 507B              ; +06 = list pointer
 618+ 507B              ANIMDEF_DEFUSR:
 619+ 507B                  ; check if out of bounds
 620+ 507B DD 4E 02         LD C,(IX+2)
 621+ 507E 0C               INC C
 622+ 507F 3A F2 4E         LD A,(ANIMDEFNUM)
 623+ 5082 B9               CP C
 624+ 5083 D8               RET C ; invalid id
 625+ 5084              	; get size
 626+ 5084 DD 7E 04         LD A,(IX+4)
 627+ 5087 FE 10            CP 16
 628+ 5089 D0               RET NC ; overflow
 629+ 508A B7               OR A
 630+ 508B C8               RET Z ; ID=0, invalid
 631+ 508C 47               LD B,A
 632+ 508D 79               LD A,C
 633+ 508E 3D               DEC A
 634+ 508F CD 0D 4F         CALL GETnthANIMDEF
 635+ 5092 70               LD (HL),B
 636+ 5093 DD 5E 06         LD E,(IX+6)
 637+ 5096 DD 56 07         LD D,(IX+7)
 638+ 5099              .L1:
 639+ 5099 23               INC HL
 640+ 509A 1A               LD A,(DE)
 641+ 509B 13          > INC DE
 641+ 509C 13          > INC DE
 642+ 509D 77               LD (HL),A
 643+ 509E 10 F9            DJNZ .L1
 644+ 50A0 C9               RET
 645+ 50A1              ; *******************************************************************************************************
 646+ 50A1               ENDIF
 647+ 50A1
 648+ 50A1               IF (1 == 1)
 649+ 50A1              ; *******************************************************************************************************
 650+ 50A1              ; same as MAXANIMSPRS but for DEFUSR approach
 651+ 50A1              ; input IX=pointer to input array, real data from +2
 652+ 50A1              ; +2 = number
 653+ 50A1              MAXANIMSPRS_DEFUSR:
 654+ 50A1 DD 7E 02         LD A,(IX+2)
 655+ 50A4 18 00            JR MAXANIMSPRS.COMMON
 656+ 50A6              ; *******************************************************************************************************
 657+ 50A6               ENDIF
 658+ 50A6
 659+ 50A6              ; *******************************************************************************************************
 660+ 50A6              ; function to handle CALL MAXANIMSPRS basic extension
 661+ 50A6              ; MAXANIMSPRS (BYTE number)
 662+ 50A6              ; sets new number and moves memory buffers as needed
 663+ 50A6              MAXANIMSPRS:
 664+ 50A6               IF (0 == 1)
 665+ 50A6 ~            	; opening (
 666+ 50A6 ~            	CALL CHKCHAR
 667+ 50A6 ~            	DB '('
 668+ 50A6 ~            	; get value
 669+ 50A6 ~            	LD IX, GETBYT
 670+ 50A6 ~            	CALL CALBAS
 671+ 50A6 ~                PUSH AF
 672+ 50A6 ~            	; ending )
 673+ 50A6 ~            	CALL CHKCHAR
 674+ 50A6 ~            	DB ')'
 675+ 50A6 ~                POP AF
 676+ 50A6               ENDIF
 677+ 50A6              .COMMON:
 678+ 50A6 F3               DI
 679+ 50A7              	; save position
 680+ 50A7 E5           	PUSH HL
 681+ 50A8              .ENTRY:
 682+ 50A8 47               LD B,A
 683+ 50A9 3A F5 4E         LD A,(ANIMSPRNUM)
 684+ 50AC 90               SUB B
 685+ 50AD CA 6B 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 686+ 50B0 FD 21 F9 4E      LD IY,AUTOSGAMPTR
 687+ 50B4 FA C0 50         JP M, .INCREASE
 688+ 50B7                  ; new value is lower than previous one
 689+ 50B7 CD E1 50         CALL .SIZEDIFF
 690+ 50BA CD A8 4F         CALL MAXANIMITEMS.DECREASE_COMMON
 691+ 50BD C3 62 4F         JP MAXANIMITEMS.E3
 692+ 50C0              .INCREASE:
 693+ 50C0 ED 44            NEG
 694+ 50C2 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 695+ 50C3 CD E1 50         CALL .SIZEDIFF
 696+ 50C6 CD D4 4F         CALL MAXANIMITEMS.INCREASE_COMMON
 697+ 50C9 AF               XOR A
 698+ 50CA ED 42            SBC HL,BC ; location of new stuff
 699+ 50CC F1               POP AF
 700+ 50CD C5               PUSH BC
 701+ 50CE 47               LD B,A
 702+ 50CF 11 08 00         LD DE,8
 703+ 50D2 E5               PUSH HL
 704+ 50D3 DD E1            POP IX
 705+ 50D5              .L1:
 706+ 50D5 DD 36 06 00      LD (IX+6),0 ; active flag
 707+ 50D9 DD 19            ADD IX,DE
 708+ 50DB 10 F8            DJNZ .L1
 709+ 50DD C1               POP BC
 710+ 50DE C3 84 4F         JP MAXANIMITEMS.E4
 711+ 50E1              .SIZEDIFF:
 712+ 50E1 26 00            LD H,0
 713+ 50E3 6F               LD L,A
 714+ 50E4 CD 70 5D         CALL HLx8
 715+ 50E7 78               LD A,B
 716+ 50E8 32 F5 4E         LD (ANIMSPRNUM),A
 717+ 50EB 44               LD B,H
 718+ 50EC 4D               LD C,L
 719+ 50ED C9               RET ; BC=size difference in bytes
 720+ 50EE              ; *******************************************************************************************************
 721+ 50EE
 722+ 50EE               IF (0 == 1)
 723+ 50EE ~            ; *******************************************************************************************************
 724+ 50EE ~            ; function to handle CALL ANIMSPRITE basic extension
 725+ 50EE ~            ; ANIMSPRITE ( BYTE id,
 726+ 50EE ~            ;              BYTE sprite_number,
 727+ 50EE ~            ;              BYTE animation_definition_id,
 728+ 50EE ~            ;              BYTE cyclic_flag )
 729+ 50EE ~            ; fills sprite animation data, returns an error if out of bounds, or invalid type
 730+ 50EE ~            ANIMSPRITE:
 731+ 50EE ~                ; opening (
 732+ 50EE ~            	CALL CHKCHAR
 733+ 50EE ~            	DB '('
 734+ 50EE ~            	; get sprite animation id
 735+ 50EE ~            	LD IX, GETBYT
 736+ 50EE ~            	CALL CALBAS
 737+ 50EE ~                PUSH AF
 738+ 50EE ~                INC A
 739+ 50EE ~                LD C,A
 740+ 50EE ~                LD A,(ANIMSPRNUM)
 741+ 50EE ~                CP C
 742+ 50EE ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 743+ 50EE ~            	; comma
 744+ 50EE ~            	CALL CHKCHAR
 745+ 50EE ~            	DB ','
 746+ 50EE ~            	; get sprite number
 747+ 50EE ~            	LD IX, GETBYT
 748+ 50EE ~            	CALL CALBAS
 749+ 50EE ~                PUSH AF
 750+ 50EE ~                ; check if out of bounds
 751+ 50EE ~                CP 32
 752+ 50EE ~                JP NC, SUBSCRIPT_OUT_OF_RANGE
 753+ 50EE ~            	; comma
 754+ 50EE ~            	CALL CHKCHAR
 755+ 50EE ~            	DB ','
 756+ 50EE ~            	; get animation definition id
 757+ 50EE ~            	LD IX, GETBYT
 758+ 50EE ~            	CALL CALBAS
 759+ 50EE ~                PUSH AF
 760+ 50EE ~                INC A
 761+ 50EE ~                LD C,A
 762+ 50EE ~                LD A,(ANIMDEFNUM)
 763+ 50EE ~                CP C
 764+ 50EE ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 765+ 50EE ~            	; comma
 766+ 50EE ~            	CALL CHKCHAR
 767+ 50EE ~            	DB ','
 768+ 50EE ~            	; get cyclic flag
 769+ 50EE ~            	LD IX, GETBYT
 770+ 50EE ~                CALL CALBAS
 771+ 50EE ~            	PUSH AF
 772+ 50EE ~            	; ending )
 773+ 50EE ~            	CALL CHKCHAR
 774+ 50EE ~            	DB ')'
 775+ 50EE ~            .ENTRY:
 776+ 50EE ~                PUSH HL
 777+ 50EE ~                POP IX
 778+ 50EE ~                EXX
 779+ 50EE ~                POP DE ; cyclic
 780+ 50EE ~                POP BC ; animation definition id
 781+ 50EE ~                POP HL ; sprite number
 782+ 50EE ~                EXX
 783+ 50EE ~                POP AF ; sprite animation id
 784+ 50EE ~                CALL GETnthSPRANIM
 785+ 50EE ~                PUSH HL
 786+ 50EE ~                POP IY
 787+ 50EE ~                EXX
 788+ 50EE ~                LD (IY),H
 789+ 50EE ~                LD (IY+4),B
 790+ 50EE ~                LD (IY+5),D
 791+ 50EE ~                ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 792+ 50EE ~                ; following will do preparation for ANIMSTEP situation
 793+ 50EE ~                ; current item set to above limit and timer to 1
 794+ 50EE ~                ; any call to ANIMSTEP will switch and setup to first item for cyclic
 795+ 50EE ~                LD (IY+3),255
 796+ 50EE ~                LD (IY+1),1
 797+ 50EE ~                LD (IY+2),0
 798+ 50EE ~                ; mark as sprite animation
 799+ 50EE ~                LD (IY+7),0
 800+ 50EE ~                PUSH IX
 801+ 50EE ~                POP HL
 802+ 50EE ~                RET
 803+ 50EE ~            ; *******************************************************************************************************
 804+ 50EE               ENDIF
 805+ 50EE
 806+ 50EE               IF (1 == 1)
 807+ 50EE              ; *******************************************************************************************************
 808+ 50EE              ; same as ANIMSPRITE but for DEFUSR approach
 809+ 50EE              ; input IX=pointer to input array, real data from +2
 810+ 50EE              ; +02 = ID
 811+ 50EE              ; +04 = sprite number
 812+ 50EE              ; +06 = animation definition id
 813+ 50EE              ; +08 = cyclic flag
 814+ 50EE              ANIMSPRITE_DEFUSR:
 815+ 50EE DD 4E 02         LD C,(IX+2)
 816+ 50F1 0C               INC C
 817+ 50F2 3A F5 4E         LD A,(ANIMSPRNUM)
 818+ 50F5 B9               CP C
 819+ 50F6 D8               RET C ; invalid id
 820+ 50F7              	; get sprite number
 821+ 50F7 DD 7E 04         LD A,(IX+4)
 822+ 50FA FE 20            CP 32
 823+ 50FC D0               RET NC ; invalid sprite id
 824+ 50FD DD 46 06         LD B,(IX+6)
 825+ 5100 04               INC B
 826+ 5101 3A F2 4E         LD A,(ANIMDEFNUM)
 827+ 5104 B8               CP B
 828+ 5105 D8               RET C ; invalid animation definition id
 829+ 5106 79               LD A,C
 830+ 5107 3D               DEC A
 831+ 5108 CD 19 4F         CALL GETnthSPRANIM
 832+ 510B DD 7E 04         LD A,(IX+4)
 833+ 510E 77               LD (HL),A ; +0
 834+ 510F 23               INC HL
 835+ 5110 36 01            LD (HL),1 ; +1
 836+ 5112 23               INC HL
 837+ 5113 36 00            LD (HL),0 ; +2
 838+ 5115 23               INC HL
 839+ 5116 36 FF            LD (HL),255 ; +3
 840+ 5118 23               INC HL
 841+ 5119 05               DEC B
 842+ 511A 70               LD (HL),B ; +4
 843+ 511B 23               INC HL
 844+ 511C DD 7E 08         LD A,(IX+8) ; +5
 845+ 511F 77               LD (HL),A
 846+ 5120 23               INC HL
 847+ 5121 23               INC HL
 848+ 5122 36 00            LD (HL),0 ; +7
 849+ 5124 C9               RET
 850+ 5125              ; *******************************************************************************************************
 851+ 5125               ENDIF
 852+ 5125
 853+ 5125
 854+ 5125               IF (0 == 1)
 855+ 5125 ~            ; *******************************************************************************************************
 856+ 5125 ~            ; function to handle CALL ANIMCHAR basic extension
 857+ 5125 ~            ; ANIMCHAR ( BYTE id,
 858+ 5125 ~            ;            INT character number 0-767,
 859+ 5125 ~            ;            BYTE animation_definition_id,
 860+ 5125 ~            ;            BYTE cyclic_flag )
 861+ 5125 ~            ; fills sprite animation data, returns an error if out of bounds, or invalid type
 862+ 5125 ~            ANIMCHAR:
 863+ 5125 ~                ; opening (
 864+ 5125 ~            	CALL CHKCHAR
 865+ 5125 ~            	DB '('
 866+ 5125 ~            	; get sprite animation id
 867+ 5125 ~            	LD IX, GETBYT
 868+ 5125 ~            	CALL CALBAS
 869+ 5125 ~                PUSH AF
 870+ 5125 ~                INC A
 871+ 5125 ~                LD C,A
 872+ 5125 ~                LD A,(ANIMSPRNUM)
 873+ 5125 ~                CP C
 874+ 5125 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 875+ 5125 ~            	; comma
 876+ 5125 ~            	CALL CHKCHAR
 877+ 5125 ~            	DB ','
 878+ 5125 ~            	; get character number
 879+ 5125 ~            	LD IX, FRMQNT
 880+ 5125 ~            	CALL CALBAS
 881+ 5125 ~                PUSH DE
 882+ 5125 ~                ; check if out of bounds
 883+ 5125 ~                LD A,D
 884+ 5125 ~                CP 3
 885+ 5125 ~                JP NC, SUBSCRIPT_OUT_OF_RANGE
 886+ 5125 ~            	; comma
 887+ 5125 ~            	CALL CHKCHAR
 888+ 5125 ~            	DB ','
 889+ 5125 ~            	; get animation definition id
 890+ 5125 ~            	LD IX, GETBYT
 891+ 5125 ~            	CALL CALBAS
 892+ 5125 ~                PUSH AF
 893+ 5125 ~                INC A
 894+ 5125 ~                LD C,A
 895+ 5125 ~                LD A,(ANIMDEFNUM)
 896+ 5125 ~                CP C
 897+ 5125 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 898+ 5125 ~            	; comma
 899+ 5125 ~            	CALL CHKCHAR
 900+ 5125 ~            	DB ','
 901+ 5125 ~            	; get cyclic flag
 902+ 5125 ~            	LD IX, GETBYT
 903+ 5125 ~                CALL CALBAS
 904+ 5125 ~            	PUSH AF
 905+ 5125 ~            	; ending )
 906+ 5125 ~            	CALL CHKCHAR
 907+ 5125 ~            	DB ')'
 908+ 5125 ~            .ENTRY:
 909+ 5125 ~                PUSH HL
 910+ 5125 ~                POP IX
 911+ 5125 ~                EXX
 912+ 5125 ~                POP DE ; cyclic
 913+ 5125 ~                POP BC ; animation definition id
 914+ 5125 ~                POP HL ; character number
 915+ 5125 ~                EXX
 916+ 5125 ~                POP AF ; sprite animation id
 917+ 5125 ~                CALL GETnthSPRANIM
 918+ 5125 ~                PUSH HL
 919+ 5125 ~                POP IY
 920+ 5125 ~                EXX
 921+ 5125 ~                LD (IY),L
 922+ 5125 ~                INC H ; save character bank+1
 923+ 5125 ~                LD (IY+7),H
 924+ 5125 ~                LD (IY+4),B
 925+ 5125 ~                LD (IY+5),D
 926+ 5125 ~                ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 927+ 5125 ~                ; following will do preparation for ANIMSTEP situation
 928+ 5125 ~                ; current item set to above limit and timer to 1
 929+ 5125 ~                ; any call to ANIMSTEP will switch and setup to first item for cyclic
 930+ 5125 ~                LD (IY+3),255
 931+ 5125 ~                LD (IY+1),1
 932+ 5125 ~                LD (IY+2),0
 933+ 5125 ~                PUSH IX
 934+ 5125 ~                POP HL
 935+ 5125 ~                RET
 936+ 5125 ~            ; *******************************************************************************************************
 937+ 5125               ENDIF
 938+ 5125
 939+ 5125               IF (1 == 1)
 940+ 5125              ; *******************************************************************************************************
 941+ 5125              ; same as ANIMCHAR but for DEFUSR approach
 942+ 5125              ; input IX=pointer to input array, real data from +2
 943+ 5125              ; +02 = ID
 944+ 5125              ; +04 = character number
 945+ 5125              ; +06 = animation definition id
 946+ 5125              ; +08 = cyclic flag
 947+ 5125              ANIMCHAR_DEFUSR:
 948+ 5125 DD 4E 02         LD C,(IX+2)
 949+ 5128 0C               INC C
 950+ 5129 3A F5 4E         LD A,(ANIMSPRNUM)
 951+ 512C B9               CP C
 952+ 512D D8               RET C ; invalid id
 953+ 512E              	; get sprite number
 954+ 512E DD 7E 05         LD A,(IX+5)
 955+ 5131 FE 03            CP 3
 956+ 5133 D0               RET NC ; invalid character (>767)
 957+ 5134 DD 46 06         LD B,(IX+6)
 958+ 5137 04               INC B
 959+ 5138 3A F2 4E         LD A,(ANIMDEFNUM)
 960+ 513B B8               CP B
 961+ 513C D8               RET C ; invalid animation definition id
 962+ 513D 79               LD A,C
 963+ 513E 3D               DEC A
 964+ 513F CD 19 4F         CALL GETnthSPRANIM
 965+ 5142 DD 7E 04         LD A,(IX+4)
 966+ 5145 77               LD (HL),A ; +0
 967+ 5146 23               INC HL
 968+ 5147 36 01            LD (HL),1 ; +1
 969+ 5149 23               INC HL
 970+ 514A 36 00            LD (HL),0 ; +2
 971+ 514C 23               INC HL
 972+ 514D 36 FF            LD (HL),255 ; +3
 973+ 514F 23               INC HL
 974+ 5150 05               DEC B
 975+ 5151 70               LD (HL),B ; +4
 976+ 5152 23               INC HL
 977+ 5153 DD 7E 08         LD A,(IX+8) ; +5
 978+ 5156 77               LD (HL),A
 979+ 5157 23               INC HL
 980+ 5158 23               INC HL
 981+ 5159 DD 7E 05         LD A,(IX+5)
 982+ 515C 3C               INC A
 983+ 515D 77               LD (HL),A ; +7
 984+ 515E C9               RET
 985+ 515F              ; *******************************************************************************************************
 986+ 515F               ENDIF
 987+ 515F
 988+ 515F               IF (1 == 1)
 989+ 515F              ; *******************************************************************************************************
 990+ 515F              ; same as MAXAUTOSGAMS but for DEFUSR approach
 991+ 515F              ; input IX=pointer to input array, real data from +2
 992+ 515F              ; +2 = number
 993+ 515F              MAXAUTOSGAMS_DEFUSR:
 994+ 515F DD 7E 02         LD A,(IX+2)
 995+ 5162 18 00            JR MAXAUTOSGAMS.COMMON
 996+ 5164              ; *******************************************************************************************************
 997+ 5164               ENDIF
 998+ 5164
 999+ 5164              ; *******************************************************************************************************
1000+ 5164              ; function to handle CALL MAXAUTOSGAMS basic extension
1001+ 5164              ; MAXAUTOSGAMS (BYTE number)
1002+ 5164              ; sets new number and moves memory buffers as needed
1003+ 5164              MAXAUTOSGAMS:
1004+ 5164               IF (0 == 1)
1005+ 5164 ~            	; opening (
1006+ 5164 ~            	CALL CHKCHAR
1007+ 5164 ~            	DB '('
1008+ 5164 ~            	; get value
1009+ 5164 ~            	LD IX, GETBYT
1010+ 5164 ~            	CALL CALBAS
1011+ 5164 ~                PUSH AF
1012+ 5164 ~            	; ending )
1013+ 5164 ~            	CALL CHKCHAR
1014+ 5164 ~            	DB ')'
1015+ 5164 ~                POP AF
1016+ 5164               ENDIF
1017+ 5164              .COMMON:
1018+ 5164 F3               DI
1019+ 5165              	; save position
1020+ 5165 E5           	PUSH HL
1021+ 5166              .ENTRY:
1022+ 5166 47               LD B,A
1023+ 5167 3A F8 4E         LD A,(AUTOSGAMNUM)
1024+ 516A 90               SUB B
1025+ 516B CA 6B 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
1026+ 516E FD 21 10 40      LD IY,FREEMEMPTR
1027+ 5172 FA 7E 51         JP M, .INCREASE
1028+ 5175                  ; new value is lower than previous one
1029+ 5175 CD 9F 51         CALL .SIZEDIFF
1030+ 5178 CD A8 4F         CALL MAXANIMITEMS.DECREASE_COMMON
1031+ 517B C3 6B 4F         JP MAXANIMITEMS.EXIT
1032+ 517E              .INCREASE:
1033+ 517E ED 44            NEG
1034+ 5180 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
1035+ 5181 CD 9F 51         CALL .SIZEDIFF
1036+ 5184 CD D4 4F         CALL MAXANIMITEMS.INCREASE_COMMON
1037+ 5187 AF               XOR A
1038+ 5188 ED 42            SBC HL,BC ; location of new stuff
1039+ 518A F1               POP AF
1040+ 518B C5               PUSH BC
1041+ 518C 47               LD B,A
1042+ 518D 11 18 00         LD DE,24
1043+ 5190 E5               PUSH HL
1044+ 5191 DD E1            POP IX
1045+ 5193              .L1:
1046+ 5193 DD 36 13 00      LD (IX+19),0 ; active flag
1047+ 5197 DD 19            ADD IX,DE
1048+ 5199 10 F8            DJNZ .L1
1049+ 519B C1               POP BC
1050+ 519C C3 6B 4F         JP MAXANIMITEMS.EXIT
1051+ 519F              .SIZEDIFF:
1052+ 519F 26 00            LD H,0
1053+ 51A1 6F               LD L,A
1054+ 51A2 CD 70 5D         CALL HLx8
1055+ 51A5 54               LD D,H
1056+ 51A6 5D               LD E,L
1057+ 51A7 29               ADD HL,HL
1058+ 51A8 19               ADD HL,DE
1059+ 51A9 78               LD A,B
1060+ 51AA 32 F8 4E         LD (AUTOSGAMNUM),A
1061+ 51AD 44               LD B,H
1062+ 51AE 4D               LD C,L
1063+ 51AF C9               RET ; BC=size difference in bytes
1064+ 51B0              ; *******************************************************************************************************
1065+ 51B0
1066+ 51B0               IF (0 == 1)
1067+ 51B0 ~            ; *******************************************************************************************************
1068+ 51B0 ~            ; function to handle CALL AUTOSGAMDEF basic extension
1069+ 51B0 ~            ; AUTOSGAMDEF ( BYTE id,
1070+ 51B0 ~            ;               INT VARIABLE x, INT VARIABLE y,
1071+ 51B0 ~            ;               INT minimum, INT maximum, INT delta,
1072+ 51B0 ~            ;               INT direction =0 horizontal,
1073+ 51B0 ~            ;               INT ticks,
1074+ 51B0 ~            ;               BYTE sprite_group_count,
1075+ 51B0 ~            ;               INT[2][sprite_group_count] VARIABLE sprite_group,
1076+ 51B0 ~            ;               BYTE item_number,
1077+ 51B0 ~            ;               INT[] VARIABLE sprite_animations_negative_direction,
1078+ 51B0 ~            ;               INT[] VARIABLE sprite_animations_positive_direction
1079+ 51B0 ~            AUTOSGAMDEF:
1080+ 51B0 ~                ; opening (
1081+ 51B0 ~            	CALL CHKCHAR
1082+ 51B0 ~            	DB '('
1083+ 51B0 ~            	; get sprite animation id
1084+ 51B0 ~            	LD IX, GETBYT
1085+ 51B0 ~            	CALL CALBAS
1086+ 51B0 ~                PUSH AF
1087+ 51B0 ~                INC A
1088+ 51B0 ~                LD C,A
1089+ 51B0 ~                LD A,(AUTOSGAMNUM)
1090+ 51B0 ~                CP C
1091+ 51B0 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
1092+ 51B0 ~                POP AF
1093+ 51B0 ~                PUSH HL
1094+ 51B0 ~                CALL GETnthAUTOSGAM
1095+ 51B0 ~                LD (BLIT_TMP),HL ; for later
1096+ 51B0 ~                POP HL
1097+ 51B0 ~            	; comma
1098+ 51B0 ~            	CALL CHKCHAR
1099+ 51B0 ~            	DB ','
1100+ 51B0 ~            	; get address of the X coordinate variable
1101+ 51B0 ~            	LD IX, PTRGET
1102+ 51B0 ~            	CALL CALBAS
1103+ 51B0 ~            	LD IX,(BLIT_TMP)
1104+ 51B0 ~                LD (IX+0),E
1105+ 51B0 ~                LD (IX+1),D
1106+ 51B0 ~            	; comma
1107+ 51B0 ~            	CALL CHKCHAR
1108+ 51B0 ~            	DB ','
1109+ 51B0 ~            	; get address of the Y coordinate variable
1110+ 51B0 ~            	LD IX, PTRGET
1111+ 51B0 ~            	CALL CALBAS
1112+ 51B0 ~            	LD IX,(BLIT_TMP)
1113+ 51B0 ~                LD (IX+2),E
1114+ 51B0 ~                LD (IX+3),D
1115+ 51B0 ~            	; comma
1116+ 51B0 ~            	CALL CHKCHAR
1117+ 51B0 ~            	DB ','
1118+ 51B0 ~            	; get minimum value
1119+ 51B0 ~            	LD IX, FRMQNT
1120+ 51B0 ~            	CALL CALBAS
1121+ 51B0 ~            	LD IX,(BLIT_TMP)
1122+ 51B0 ~                LD (IX+4),E
1123+ 51B0 ~                LD (IX+5),D
1124+ 51B0 ~            	; comma
1125+ 51B0 ~            	CALL CHKCHAR
1126+ 51B0 ~            	DB ','
1127+ 51B0 ~            	; get maximum value
1128+ 51B0 ~            	LD IX, FRMQNT
1129+ 51B0 ~            	CALL CALBAS
1130+ 51B0 ~            	LD IX,(BLIT_TMP)
1131+ 51B0 ~                LD (IX+6),E
1132+ 51B0 ~                LD (IX+7),D
1133+ 51B0 ~            	; comma
1134+ 51B0 ~            	CALL CHKCHAR
1135+ 51B0 ~            	DB ','
1136+ 51B0 ~            	; get delta value
1137+ 51B0 ~            	LD IX, FRMQNT
1138+ 51B0 ~            	CALL CALBAS
1139+ 51B0 ~            	LD IX,(BLIT_TMP)
1140+ 51B0 ~                LD (IX+8),E
1141+ 51B0 ~                LD (IX+9),D
1142+ 51B0 ~            	; comma
1143+ 51B0 ~            	CALL CHKCHAR
1144+ 51B0 ~            	DB ','
1145+ 51B0 ~            	; get direction value
1146+ 51B0 ~            	LD IX, FRMQNT
1147+ 51B0 ~            	CALL CALBAS
1148+ 51B0 ~            	LD IX,(BLIT_TMP)
1149+ 51B0 ~                LD (IX+10),E
1150+ 51B0 ~            	; comma
1151+ 51B0 ~            	CALL CHKCHAR
1152+ 51B0 ~            	DB ','
1153+ 51B0 ~            	; get ticks value
1154+ 51B0 ~            	LD IX, FRMQNT
1155+ 51B0 ~            	CALL CALBAS
1156+ 51B0 ~            	LD IX,(BLIT_TMP)
1157+ 51B0 ~                LD (IX+20),E
1158+ 51B0 ~                LD (IX+21),D
1159+ 51B0 ~            	; comma
1160+ 51B0 ~            	CALL CHKCHAR
1161+ 51B0 ~            	DB ','
1162+ 51B0 ~            	; get sprite group count
1163+ 51B0 ~            	LD IX, GETBYT
1164+ 51B0 ~            	CALL CALBAS
1165+ 51B0 ~                OR A
1166+ 51B0 ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
1167+ 51B0 ~            	LD IX,(BLIT_TMP)
1168+ 51B0 ~                LD (IX+11),A
1169+ 51B0 ~            	; comma
1170+ 51B0 ~            	CALL CHKCHAR
1171+ 51B0 ~            	DB ','
1172+ 51B0 ~            	; get sprite group definition array data pointer
1173+ 51B0 ~            	LD IX,(BLIT_TMP)
1174+ 51B0 ~                LD E,(IX+11)
1175+ 51B0 ~            	LD D,3
1176+ 51B0 ~            	LD A,2
1177+ 51B0 ~            	LD B,A
1178+ 51B0 ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
1179+ 51B0 ~            	LD IX,(BLIT_TMP)
1180+ 51B0 ~            	LD (IX+12),C
1181+ 51B0 ~                LD (IX+13),B
1182+ 51B0 ~            	; comma
1183+ 51B0 ~            	CALL CHKCHAR
1184+ 51B0 ~            	DB ','
1185+ 51B0 ~            	; get sprite animation array size
1186+ 51B0 ~            	LD IX,GETBYT
1187+ 51B0 ~            	CALL CALBAS
1188+ 51B0 ~            	LD IX,(BLIT_TMP)
1189+ 51B0 ~                LD (IX+14),A
1190+ 51B0 ~                OR A
1191+ 51B0 ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
1192+ 51B0 ~            	; comma
1193+ 51B0 ~            	CALL CHKCHAR
1194+ 51B0 ~            	DB ','
1195+ 51B0 ~                ; get array pointer for negative direction
1196+ 51B0 ~            	LD IX,(BLIT_TMP)
1197+ 51B0 ~                LD D,(IX+14)
1198+ 51B0 ~                LD A,2
1199+ 51B0 ~                LD B,1
1200+ 51B0 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
1201+ 51B0 ~            	LD IX,(BLIT_TMP)
1202+ 51B0 ~                LD (IX+15),C
1203+ 51B0 ~                LD (IX+16),B
1204+ 51B0 ~            	; comma
1205+ 51B0 ~            	CALL CHKCHAR
1206+ 51B0 ~            	DB ','
1207+ 51B0 ~                ; get array pointer for positive direction
1208+ 51B0 ~            	LD IX,(BLIT_TMP)
1209+ 51B0 ~                LD D,(IX+14)
1210+ 51B0 ~                LD A,2
1211+ 51B0 ~                LD B,1
1212+ 51B0 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
1213+ 51B0 ~            	LD IX,(BLIT_TMP)
1214+ 51B0 ~                LD (IX+17),C
1215+ 51B0 ~                LD (IX+18),B
1216+ 51B0 ~            	; ending )
1217+ 51B0 ~            	CALL CHKCHAR
1218+ 51B0 ~            	DB ')'
1219+ 51B0 ~                RET
1220+ 51B0 ~            ; *******************************************************************************************************
1221+ 51B0               ENDIF
1222+ 51B0
1223+ 51B0               IF (1 == 1)
1224+ 51B0              ; *******************************************************************************************************
1225+ 51B0              ; same as AUTOSGAMDEF but for DEFUSR approach
1226+ 51B0              ; input IX=pointer to input array, real data from +2
1227+ 51B0              ; +02 = ID
1228+ 51B0              ; +04 = pointer to X variable
1229+ 51B0              ; +06 = pointer to Y variable
1230+ 51B0              ; +08 = minimum
1231+ 51B0              ; +10 = maximum
1232+ 51B0              ; +12 = delta
1233+ 51B0              ; +14 = direction
1234+ 51B0              ; +16 = ticks
1235+ 51B0              ; +18 = sprite group count
1236+ 51B0              ; +20 = sprite group array pointer
1237+ 51B0              ; +22 = item number
1238+ 51B0              ; +24 = sprite animations negative direction array pointer
1239+ 51B0              ; +26 = sprite animations positive direction array pointer
1240+ 51B0              AUTOSGAMDEF_DEFUSR:
1241+ 51B0 DD 4E 02         LD C,(IX+2)
1242+ 51B3 0C               INC C
1243+ 51B4 3A F8 4E         LD A,(AUTOSGAMNUM)
1244+ 51B7 B9               CP C
1245+ 51B8 D8               RET C ; invalid id
1246+ 51B9 79               LD A,C
1247+ 51BA 3D               DEC A
1248+ 51BB CD 25 4F         CALL GETnthAUTOSGAM
1249+ 51BE E5               PUSH HL
1250+ 51BF FD E1            POP IY
1251+ 51C1                  ; X variable
1252+ 51C1 DD 7E 04         LD A,(IX+4)
1253+ 51C4 FD 77 00         LD (IY+0),A
1254+ 51C7 DD 7E 05         LD A,(IX+5)
1255+ 51CA FD 77 01         LD (IY+1),A
1256+ 51CD              	; Y variable
1257+ 51CD DD 7E 06         LD A,(IX+6)
1258+ 51D0 FD 77 02         LD (IY+2),A
1259+ 51D3 DD 7E 07         LD A,(IX+7)
1260+ 51D6 FD 77 03         LD (IY+3),A
1261+ 51D9              	; get minimum value
1262+ 51D9 DD 7E 08         LD A,(IX+8)
1263+ 51DC FD 77 04         LD (IY+4),A
1264+ 51DF DD 7E 09         LD A,(IX+9)
1265+ 51E2 FD 77 05         LD (IY+5),A
1266+ 51E5              	; get maximum value
1267+ 51E5 DD 7E 0A         LD A,(IX+10)
1268+ 51E8 FD 77 06         LD (IY+6),A
1269+ 51EB DD 7E 0B         LD A,(IX+11)
1270+ 51EE FD 77 07         LD (IY+7),A
1271+ 51F1              	; get delta value
1272+ 51F1 DD 7E 0C         LD A,(IX+12)
1273+ 51F4 FD 77 08         LD (IY+8),A
1274+ 51F7 DD 7E 0D         LD A,(IX+13)
1275+ 51FA FD 77 09         LD (IY+9),A
1276+ 51FD              	; get direction value
1277+ 51FD DD 7E 0E         LD A,(IX+14)
1278+ 5200 FD 77 0A         LD (IY+10),A
1279+ 5203              	; get ticks value
1280+ 5203 DD 7E 10         LD A,(IX+16)
1281+ 5206 FD 77 14         LD (IY+20),A
1282+ 5209 DD 7E 11         LD A,(IX+17)
1283+ 520C FD 77 15         LD (IY+21),A
1284+ 520F              	; get sprite group count
1285+ 520F DD 7E 12         LD A,(IX+18)
1286+ 5212 FD 77 0B         LD (IY+11),A
1287+ 5215              	; get sprite group definition array data pointer
1288+ 5215 DD 7E 14         LD A,(IX+20)
1289+ 5218 FD 77 0C         LD (IY+12),A
1290+ 521B DD 7E 15         LD A,(IX+21)
1291+ 521E FD 77 0D         LD (IY+13),A
1292+ 5221              	; get sprite animation array size
1293+ 5221 DD 7E 16         LD A,(IX+22)
1294+ 5224 FD 77 0E         LD (IY+14),A
1295+ 5227                  ; get array pointer for negative direction
1296+ 5227 DD 7E 18         LD A,(IX+24)
1297+ 522A FD 77 0F         LD (IY+15),A
1298+ 522D DD 7E 19         LD A,(IX+25)
1299+ 5230 FD 77 10         LD (IY+16),A
1300+ 5233                  ; get array pointer for positive direction
1301+ 5233 DD 7E 1A         LD A,(IX+26)
1302+ 5236 FD 77 11         LD (IY+17),A
1303+ 5239 DD 7E 1B         LD A,(IX+27)
1304+ 523C FD 77 12         LD (IY+18),A
1305+ 523F C9               RET
1306+ 5240              ; *******************************************************************************************************
1307+ 5240               ENDIF
1308+ 5240
1309+ 5240               IF (0 == 1)
1310+ 5240 ~            ; *******************************************************************************************************
1311+ 5240 ~            ; function to handle CALL AUTOSGAMSTART basic extension
1312+ 5240 ~            ; AUTOSGAMSTART ( BYTE id )
1313+ 5240 ~            AUTOSGAMSTART:
1314+ 5240 ~                LD A,1
1315+ 5240 ~            .COMMON:
1316+ 5240 ~                LD (.SETVALUE+3),A
1317+ 5240 ~                ; opening (
1318+ 5240 ~            	CALL CHKCHAR
1319+ 5240 ~            	DB '('
1320+ 5240 ~            	; get sprite animation id
1321+ 5240 ~            	LD IX, GETBYT
1322+ 5240 ~            	CALL CALBAS
1323+ 5240 ~                PUSH AF
1324+ 5240 ~                INC A
1325+ 5240 ~                LD C,A
1326+ 5240 ~                LD A,(AUTOSGAMNUM)
1327+ 5240 ~                CP C
1328+ 5240 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
1329+ 5240 ~                POP AF
1330+ 5240 ~                PUSH HL
1331+ 5240 ~                CALL GETnthAUTOSGAM
1332+ 5240 ~                PUSH HL
1333+ 5240 ~                POP IX
1334+ 5240 ~                POP HL
1335+ 5240 ~                PUSH IX
1336+ 5240 ~            	; ending )
1337+ 5240 ~            	CALL CHKCHAR
1338+ 5240 ~            	DB ')'
1339+ 5240 ~
1340+ 5240 ~                ; so syntax is fine
1341+ 5240 ~                POP IX
1342+ 5240 ~            .SETVALUE:
1343+ 5240 ~                LD (IX+19),1 ; active flag
1344+ 5240 ~                ; set initial timer
1345+ 5240 ~                LD A,(IX+20)
1346+ 5240 ~                LD (IX+22),A
1347+ 5240 ~                LD A,(IX+21)
1348+ 5240 ~                LD (IX+23),A
1349+ 5240 ~                RET
1350+ 5240 ~            ; *******************************************************************************************************
1351+ 5240 ~
1352+ 5240 ~            ; *******************************************************************************************************
1353+ 5240 ~            ; function to handle CALL AUTOSGAMSTOP basic extension
1354+ 5240 ~            ; AUTOSGAMSTOP ( BYTE id )
1355+ 5240 ~            AUTOSGAMSTOP:
1356+ 5240 ~                XOR A
1357+ 5240 ~                JR AUTOSGAMSTART.COMMON
1358+ 5240 ~            ; *******************************************************************************************************
1359+ 5240               ENDIF
1360+ 5240
1361+ 5240               IF (1 == 1)
1362+ 5240              ; *******************************************************************************************************
1363+ 5240              ; function to handle CALL AUTOSGAMSTART basic extension in DEFUSR mode
1364+ 5240              ; input IX=pointer to input array, real data from +2
1365+ 5240              ; +2 = source address
1366+ 5240              AUTOSGAMSTART_DEFUSR:
1367+ 5240 3E 01            LD A,1
1368+ 5242              .COMMON:
1369+ 5242 32 59 52         LD (.SETVALUE+3),A
1370+ 5245 DD 4E 02         LD C,(IX+2)
1371+ 5248 0C               INC C
1372+ 5249 3A F8 4E         LD A,(AUTOSGAMNUM)
1373+ 524C B9               CP C
1374+ 524D D8               RET C ; invalid id
1375+ 524E 79               LD A,C
1376+ 524F 3D               DEC A
1377+ 5250 CD 25 4F         CALL GETnthAUTOSGAM
1378+ 5253 E5               PUSH HL
1379+ 5254 DD E1            POP IX
1380+ 5256              .SETVALUE:
1381+ 5256 DD 36 13 01      LD (IX+19),1 ; active flag
1382+ 525A                  ; set initial timer
1383+ 525A DD 7E 14         LD A,(IX+20)
1384+ 525D DD 77 16         LD (IX+22),A
1385+ 5260 DD 7E 15         LD A,(IX+21)
1386+ 5263 DD 77 17         LD (IX+23),A
1387+ 5266 C9               RET
1388+ 5267              ; *******************************************************************************************************
1389+ 5267
1390+ 5267              ; *******************************************************************************************************
1391+ 5267              ; function to handle CALL AUTOSGAMSTOP basic extension in DEFUSR mode
1392+ 5267              ; input IX=pointer to input array, real data from +2
1393+ 5267              ; +2 = source address
1394+ 5267              AUTOSGAMSTOP_DEFUSR:
1395+ 5267 AF               XOR A
1396+ 5268 18 D8            JR AUTOSGAMSTART_DEFUSR.COMMON
1397+ 526A              ; *******************************************************************************************************
1398+ 526A               ENDIF
1399+ 526A
1400+ 526A               IF (0 == 1)
1401+ 526A ~            ; *******************************************************************************************************
1402+ 526A ~            ; function to handle CALL ANIMSTEP basic extension
1403+ 526A ~            ; two forms
1404+ 526A ~            ; ANIMSTEP ( BYTE id )
1405+ 526A ~            ; or
1406+ 526A ~            ; ANIMSTEP ( BYTE item_number,
1407+ 526A ~            ;            INT[] sprite_animations )
1408+ 526A ~            ANIMSTEP:
1409+ 526A ~                LD DE,ANIMSTARTSTOP_COMMON.STEP
1410+ 526A ~                JR ANIMSTARTSTOP_COMMON
1411+ 526A ~            ; *******************************************************************************************************
1412+ 526A ~            ; *******************************************************************************************************
1413+ 526A ~            ; function to handle CALL ANIMSTART basic extension
1414+ 526A ~            ; two forms
1415+ 526A ~            ; ANIMSTART ( BYTE id )
1416+ 526A ~            ; or
1417+ 526A ~            ; ANIMSTART ( BYTE item_number,
1418+ 526A ~            ;             INT[] sprite_animations )
1419+ 526A ~            ; sets active flag to 1
1420+ 526A ~            ANIMSTART:
1421+ 526A ~                LD DE,ANIMSTARTSTOP_COMMON.START
1422+ 526A ~                JR ANIMSTARTSTOP_COMMON
1423+ 526A ~            ; *******************************************************************************************************
1424+ 526A ~            ; *******************************************************************************************************
1425+ 526A ~            ; function to handle CALL ANIMSTOP basic extension
1426+ 526A ~            ; two forms
1427+ 526A ~            ; ANIMSTOP ( BYTE id )
1428+ 526A ~            ; or
1429+ 526A ~            ; ANIMSTOP ( BYTE item_number,
1430+ 526A ~            ;            INT[] sprite_animations )
1431+ 526A ~            ; sets active flag to 0
1432+ 526A ~            ANIMSTOP:
1433+ 526A ~                LD DE,ANIMSTARTSTOP_COMMON.STOP
1434+ 526A ~            ; *******************************************************************************************************
1435+ 526A ~            ANIMSTARTSTOP_COMMON:
1436+ 526A ~                LD (ANIMSTARTSTOP_COMMON.FN+1),DE
1437+ 526A ~                ; opening (
1438+ 526A ~            	CALL CHKCHAR
1439+ 526A ~            	DB '('
1440+ 526A ~            	; get sprite animation id or array size
1441+ 526A ~            	LD IX,GETBYT
1442+ 526A ~            	CALL CALBAS
1443+ 526A ~                PUSH AF
1444+ 526A ~                ; check if comma present
1445+ 526A ~                CALL GETPREVCHAR
1446+ 526A ~                INC HL
1447+ 526A ~                CP ','
1448+ 526A ~                JR Z,.L1
1449+ 526A ~                CP ')'
1450+ 526A ~                JP NZ,SYNTAX_ERROR
1451+ 526A ~                ; ok so single argument variant
1452+ 526A ~                POP AF
1453+ 526A ~                PUSH HL
1454+ 526A ~                DI
1455+ 526A ~                CALL .SETVALUE
1456+ 526A ~                EI
1457+ 526A ~                POP HL
1458+ 526A ~                RET
1459+ 526A ~            .L1:
1460+ 526A ~                ; get array pointer
1461+ 526A ~                POP DE
1462+ 526A ~                PUSH DE
1463+ 526A ~                LD A,2
1464+ 526A ~                LD B,1
1465+ 526A ~                CALL GET_BASIC_ARRAY_DATA_POINTER
1466+ 526A ~                PUSH BC
1467+ 526A ~            	; ending )
1468+ 526A ~            	CALL CHKCHAR
1469+ 526A ~            	DB ')'
1470+ 526A ~                POP DE ; array pointer
1471+ 526A ~                POP BC ; number of items
1472+ 526A ~                LD A,B
1473+ 526A ~                OR A
1474+ 526A ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
1475+ 526A ~                PUSH HL
1476+ 526A ~                DI
1477+ 526A ~            .L2:
1478+ 526A ~                PUSH BC
1479+ 526A ~                LD A,(DE)
1480+ 526A ~                .2 INC DE
1481+ 526A ~                PUSH DE
1482+ 526A ~                CALL .SETVALUE
1483+ 526A ~                POP DE
1484+ 526A ~                POP BC
1485+ 526A ~                DJNZ .L2
1486+ 526A ~                EI
1487+ 526A ~                POP HL
1488+ 526A ~                RET
1489+ 526A ~
1490+ 526A ~            .SETVALUE:
1491+ 526A ~                LD B,A
1492+ 526A ~                INC A
1493+ 526A ~                LD C,A
1494+ 526A ~                LD A,(ANIMSPRNUM)
1495+ 526A ~                CP C
1496+ 526A ~                JP C,SUBSCRIPT_OUT_OF_RANGE
1497+ 526A ~                LD A,B
1498+ 526A ~                CALL GETnthSPRANIM
1499+ 526A ~                PUSH HL
1500+ 526A ~                POP IX
1501+ 526A ~            .FN:
1502+ 526A ~                JP 0
1503+ 526A ~            .START:
1504+ 526A ~                LD (IX+6),1 ; active flag
1505+ 526A ~                LD (IX+3),0 ; current item
1506+ 526A ~                LD B,0 ; setup timer
1507+ 526A ~                JP SETUP_ANIM_STEP
1508+ 526A ~            .STOP:
1509+ 526A ~                LD (IX+6),0 ; active flag
1510+ 526A ~                RET
1511+ 526A ~            .STEP:
1512+ 526A ~                LD B,0
1513+ 526A ~                JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1514+ 526A ~            ; *******************************************************************************************************
1515+ 526A               ENDIF
1516+ 526A
1517+ 526A              ; *******************************************************************************************************
1518+ 526A              ; helper function to locate single animation and execute operation
1519+ 526A              ; needs to have jump set to a correct function
1520+ 526A              ; used by SGAM helper routines so always needed
1521+ 526A              ; input A=animation item
1522+ 526A              ANIM_SETVALUE:
1523+ 526A 47               LD B,A
1524+ 526B 3C               INC A
1525+ 526C 4F               LD C,A
1526+ 526D 3A F5 4E         LD A,(ANIMSPRNUM)
1527+ 5270 B9               CP C
1528+ 5271 D8               RET C ; out of range, so do nothing
1529+ 5272 78               LD A,B
1530+ 5273 CD 19 4F         CALL GETnthSPRANIM
1531+ 5276 E5               PUSH HL
1532+ 5277 DD E1            POP IX
1533+ 5279              .FN:
1534+ 5279 C3 00 00         JP 0
1535+ 527C              ; *******************************************************************************************************
1536+ 527C
1537+ 527C               IF (1 == 1)
1538+ 527C              ; *******************************************************************************************************
1539+ 527C              ; helper function to set values of multiple animations
1540+ 527C              ; needs to have jump set to a correct function
1541+ 527C              ; input B=number of animation item
1542+ 527C              ; input DE=animation item array
1543+ 527C              ANIM_LIST_SETVALUE:
1544+ 527C F3               DI
1545+ 527D C5               PUSH BC
1546+ 527E 1A               LD A,(DE)
1547+ 527F 13          > INC DE
1547+ 5280 13          > INC DE
1548+ 5281 D5               PUSH DE
1549+ 5282 CD 6A 52         CALL ANIM_SETVALUE
1550+ 5285 D1               POP DE
1551+ 5286 C1               POP BC
1552+ 5287 10 F3            DJNZ ANIM_LIST_SETVALUE
1553+ 5289 FB               EI
1554+ 528A C9               RET
1555+ 528B              ; *******************************************************************************************************
1556+ 528B
1557+ 528B              ; *******************************************************************************************************
1558+ 528B              ; function to handle single item ANIMSTEP in DEFUSR mode
1559+ 528B              ; input IX=pointer to input array, real data from +2
1560+ 528B              ; +2 = animation id
1561+ 528B              ANIMSTEP_SINGLE_DEFUSR:
1562+ 528B 21 96 52         LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1563+ 528E              .L1:
1564+ 528E 22 7A 52         LD (ANIM_SETVALUE.FN+1),HL
1565+ 5291 DD 7E 02         LD A,(IX+2)
1566+ 5294 18 D4            JR ANIM_SETVALUE
1567+ 5296              .STEP:
1568+ 5296 06 00            LD B,0
1569+ 5298 C3 F0 52         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1570+ 529B              ; *******************************************************************************************************
1571+ 529B
1572+ 529B              ; *******************************************************************************************************
1573+ 529B              ; function to handle multi item ANIMSTEP in DEFUSR mode
1574+ 529B              ; input IX=pointer to input array, real data from +2
1575+ 529B              ; +2 = list size
1576+ 529B              ; +4 = array pointer holding items
1577+ 529B              ANIMSTEP_MULTI_DEFUSR:
1578+ 529B 21 96 52         LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1579+ 529E              .L1:
1580+ 529E 22 7A 52         LD (ANIM_SETVALUE.FN+1),HL
1581+ 52A1 DD 46 02         LD B,(IX+2)
1582+ 52A4 DD 5E 04         LD E,(IX+4)
1583+ 52A7 DD 56 05         LD D,(IX+5)
1584+ 52AA 18 D0            JR ANIM_LIST_SETVALUE
1585+ 52AC              ; *******************************************************************************************************
1586+ 52AC
1587+ 52AC              ; *******************************************************************************************************
1588+ 52AC              ; function to handle single item ANIMSTART in DEFUSR mode
1589+ 52AC              ; input IX=pointer to input array, real data from +2
1590+ 52AC              ; +2 = animation id
1591+ 52AC              ANIMSTART_SINGLE_DEFUSR:
1592+ 52AC 21 B1 52         LD HL,ANIMSTART_SINGLE_DEFUSR.START
1593+ 52AF 18 DD            JR ANIMSTEP_SINGLE_DEFUSR.L1
1594+ 52B1              .START:
1595+ 52B1 DD 36 06 01      LD (IX+6),1 ; active flag
1596+ 52B5 DD 36 03 00      LD (IX+3),0 ; current item
1597+ 52B9 06 00            LD B,0 ; setup timer
1598+ 52BB C3 4C 53         JP SETUP_ANIM_STEP
1599+ 52BE              ; *******************************************************************************************************
1600+ 52BE
1601+ 52BE              ; *******************************************************************************************************
1602+ 52BE              ; function to handle multi item ANIMSTART in DEFUSR mode
1603+ 52BE              ; input IX=pointer to input array, real data from +2
1604+ 52BE              ; +2 = list size
1605+ 52BE              ; +4 = array pointer holding items
1606+ 52BE              ANIMSTART_MULTI_DEFUSR:
1607+ 52BE 21 B1 52         LD HL,ANIMSTART_SINGLE_DEFUSR.START
1608+ 52C1 18 DB            JR ANIMSTEP_MULTI_DEFUSR.L1
1609+ 52C3              ; *******************************************************************************************************
1610+ 52C3
1611+ 52C3              ; *******************************************************************************************************
1612+ 52C3              ; function to handle single item ANIMSTOP in DEFUSR mode
1613+ 52C3              ; input IX=pointer to input array, real data from +2
1614+ 52C3              ; +2 = animation id
1615+ 52C3              ANIMSTOP_SINGLE_DEFUSR:
1616+ 52C3 21 C8 52         LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1617+ 52C6 18 C6            JR ANIMSTEP_SINGLE_DEFUSR.L1
1618+ 52C8              .STOP:
1619+ 52C8 DD 36 06 00      LD (IX+6),0 ; active flag
1620+ 52CC C9               RET
1621+ 52CD              ; *******************************************************************************************************
1622+ 52CD
1623+ 52CD              ; *******************************************************************************************************
1624+ 52CD              ; function to handle multi item ANIMSTOP in DEFUSR mode
1625+ 52CD              ; input IX=pointer to input array, real data from +2
1626+ 52CD              ; +2 = list size
1627+ 52CD              ; +4 = array pointer holding items
1628+ 52CD              ANIMSTOP_MULTI_DEFUSR:
1629+ 52CD 21 C8 52         LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1630+ 52D0 18 CC            JR ANIMSTEP_MULTI_DEFUSR.L1
1631+ 52D2              ; *******************************************************************************************************
1632+ 52D2               ENDIF
1633+ 52D2
1634+ 52D2              ; *******************************************************************************************************
1635+ 52D2              ; function processes animations during vblank period
1636+ 52D2              PROCESS_ANIMATIONS:
1637+ 52D2 3A F5 4E         LD A,(ANIMSPRNUM)
1638+ 52D5 B7               OR A
1639+ 52D6 C8               RET Z; no animations defined
1640+ 52D7 47               LD B,A
1641+ 52D8 DD 2A F6 4E      LD IX,(ANIMSPRPTR)
1642+ 52DC              .L1:
1643+ 52DC C5               PUSH BC
1644+ 52DD 06 00            LD B,0 ; normal mode, change on timer expiry only
1645+ 52DF CD EB 52         CALL PROCESS_SINGLE_ANIMATION
1646+ 52E2 11 08 00         LD DE,8
1647+ 52E5 DD 19            ADD IX,DE
1648+ 52E7 C1               POP BC
1649+ 52E8 10 F2            DJNZ .L1
1650+ 52EA C9               RET
1651+ 52EB              ; *******************************************************************************************************
1652+ 52EB
1653+ 52EB              ; *******************************************************************************************************
1654+ 52EB              ; processes single sprite animation
1655+ 52EB              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
1656+ 52EB              ; on timer expiry goes to next animation item
1657+ 52EB              ; input IX=sprite animation pointer
1658+ 52EB              ; input B=1 force mode, activate animation action regardless of expired timer
1659+ 52EB              PROCESS_SINGLE_ANIMATION:
1660+ 52EB DD 7E 06         LD A,(IX+6); active
1661+ 52EE B7               OR A
1662+ 52EF C8               RET Z ; inactive animation
1663+ 52F0              .INACTIVE_TOO:
1664+ 52F0 DD 6E 01         LD L,(IX+1)
1665+ 52F3 DD 66 02         LD H,(IX+2) ; HL=end time
1666+ 52F6 2B               DEC HL
1667+ 52F7 DD 75 01         LD (IX+1),L
1668+ 52FA DD 74 02         LD (IX+2),H
1669+ 52FD 7D               LD A,L
1670+ 52FE B4               OR H
1671+ 52FF 28 06            JR Z,.STEP
1672+ 5301 05               DEC B
1673+ 5302 04               INC B
1674+ 5303 C8               RET Z ; not forced mode, return
1675+ 5304 C3 4C 53         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
1676+ 5307              .STEP:
1677+ 5307 06 00            LD B,0; setup timer
1678+ 5309 DD 34 03         INC (IX+3) ; current animation item
1679+ 530C C3 4C 53         JP SETUP_ANIM_STEP
1680+ 530F              ; *******************************************************************************************************
1681+ 530F
1682+ 530F              ; *******************************************************************************************************
1683+ 530F              ; function will setup sprite animation after current item change
1684+ 530F              ; input A=current animation definition
1685+ 530F              ; input IX=pointer to sprite animation
1686+ 530F              ; input B=1 skip timer setup
1687+ 530F              ; output IY=pointer to animation item
1688+ 530F              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
1689+ 530F              ; basically sets new end time for current animation
1690+ 530F              INIT_CURRENT_ANIMATION:
1691+ 530F CD 0D 4F         CALL GETnthANIMDEF
1692+ 5312 DD 7E 03         LD A,(IX+3) ; current animation item
1693+ 5315 BE               CP (HL) ; number of animation items in the animation definition
1694+ 5316 38 0A            JR C,.L3 ; last item not reached
1695+ 5318                  ; last item reached
1696+ 5318 DD 7E 05         LD A,(IX+5) ; cyclic flag
1697+ 531B B7               OR A
1698+ 531C 28 2C            JR Z,.ERROR ; non-cyclic animation
1699+ 531E                  ; cyclic animation, restart
1700+ 531E DD 36 03 00      LD (IX+3),0; current item
1701+ 5322              .L3:
1702+ 5322                  ; HL = animation definition
1703+ 5322 23               INC HL ; skip animation definition size field
1704+ 5323 16 00            LD D,0
1705+ 5325 DD 5E 03         LD E,(IX+3); current item
1706+ 5328 19               ADD HL,DE
1707+ 5329 4E               LD C,(HL) ; current animation item
1708+ 532A 0C               INC C
1709+ 532B 3A EF 4E         LD A,(ANIMITEMNUM)
1710+ 532E B9               CP C
1711+ 532F 38 19            JR C,.ERROR ; invalid animation item, stop animation
1712+ 5331 0D               DEC C
1713+ 5332 79               LD A,C
1714+ 5333 CD 04 4F         CALL GETnthANIMITEM
1715+ 5336 E5               PUSH HL
1716+ 5337 FD E1            POP IY ; IY=animation item
1717+ 5339 05               DEC B
1718+ 533A 28 0C            JR Z,.EXIT
1719+ 533C FD 5E 01         LD E,(IY+1)
1720+ 533F FD 56 02         LD D,(IY+2) ; duration
1721+ 5342 DD 73 01         LD (IX+1),E
1722+ 5345 DD 72 02         LD (IX+2),D
1723+ 5348              .EXIT:
1724+ 5348 AF               XOR A
1725+ 5349 C9               RET
1726+ 534A              .ERROR:
1727+ 534A 37               SCF
1728+ 534B C9               RET
1729+ 534C              ; *******************************************************************************************************
1730+ 534C
1731+ 534C              ; *******************************************************************************************************
1732+ 534C              ; function will display currect item and set up expiry time
1733+ 534C              ; it will also stop the animation if expired
1734+ 534C              ; sets sprite update flag if any changes in sprite data made
1735+ 534C              ; input IX=current sprite animation
1736+ 534C              ; input B=1 skip timer setup
1737+ 534C              SETUP_ANIM_STEP:
1738+ 534C DD 4E 04         LD C,(IX+4) ; animation definition ID
1739+ 534F 0C               INC C
1740+ 5350 3A F2 4E         LD A,(ANIMDEFNUM)
1741+ 5353 B9               CP C
1742+ 5354 30 05            JR NC,.L2
1743+ 5356                  ; given animation item is outside of bounds, deactivate animation
1744+ 5356              .STOPANIM:
1745+ 5356 DD 36 06 00      LD (IX+6),0
1746+ 535A C9               RET
1747+ 535B              .L2:
1748+ 535B 0D               DEC C
1749+ 535C 79               LD A,C
1750+ 535D CD 0F 53         CALL INIT_CURRENT_ANIMATION
1751+ 5360 38 F4            JR C, .STOPANIM
1752+ 5362 FD 7E 00         LD A,(IY) ; type of animation item
1753+ 5365 B7               OR A
1754+ 5366 28 44            JR Z,.L4 ; change pattern and/or color
1755+ 5368              .PAT:
1756+ 5368                  ; change pattern definition
1757+ 5368                  ; check if sprite or character
1758+ 5368 DD 7E 07         LD A,(IX+7)
1759+ 536B B7               OR A
1760+ 536C 20 58            JR NZ,.CHAR
1761+ 536E DD 7E 00         LD A,(IX) ; sprite number
1762+ 5371 CD 89 4D         CALL GETnthSPRATTR
1763+ 5374 23          > INC HL ; skip y and x
1763+ 5375 23          > INC HL
1763+ 5376 23          > INC HL
1763+ 5377 23          > INC HL
1764+ 5378 7E               LD A,(HL); current pattern
1765+ 5379 26 00            LD H,0
1766+ 537B 6F               LD L,A
1767+ 537C 3A E0 F3         LD A,(REG1SAV)
1768+ 537F E6 02            AND 2
1769+ 5381 20 07            JR NZ,.L6
1770+ 5383                  ; 8x8 sprite
1771+ 5383 CD 70 5D         CALL HLx8
1772+ 5386 06 08            LD B,8
1773+ 5388 18 05            JR .L5
1774+ 538A              .L6:
1775+ 538A CD 6E 5D         CALL HLx32
1776+ 538D 06 20            LD B,32
1777+ 538F              .L5:
1778+ 538F 3A AF FC         LD A,(SCRMOD)
1779+ 5392 3D               DEC A
1780+ 5393 20 06            JR NZ,.L10
1781+ 5395 ED 5B C5 F3      LD DE,(T32PAT)
1782+ 5399 18 04            JR .L7
1783+ 539B              .L10:
1784+ 539B ED 5B CF F3      LD DE,(GRPPAT)
1785+ 539F              .L7:
1786+ 539F 19               ADD HL,DE
1787+ 53A0 CD 5B 5D         CALL SETWRT_LOCAL
1788+ 53A3 FD 6E 03         LD L,(IY+3)
1789+ 53A6 FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
1790+ 53A9 C3 66 5D         JP BBYTECOPY
1791+ 53AC              .L4:
1792+ 53AC                  ; change pattern and color in sprite attributes table
1793+ 53AC DD 7E 00         LD A,(IX) ; sprite number
1794+ 53AF CD 89 4D         CALL GETnthSPRATTR
1795+ 53B2 23          > INC HL ; skip y and x
1795+ 53B3 23          > INC HL
1795+ 53B4 23          > INC HL
1795+ 53B5 23          > INC HL
1796+ 53B6 FD 7E 03         LD A,(IY+3) ; new pattern
1797+ 53B9 77               LD (HL),A
1798+ 53BA 23          > INC HL
1798+ 53BB 23          > INC HL
1799+ 53BC FD 7E 04         LD A,(IY+4) ; new color
1800+ 53BF 77               LD (HL),A
1801+ 53C0 2A 80 4D         LD HL,(SPRATR_UPDATE_FLAG)
1802+ 53C3 36 01            LD (HL),1
1803+ 53C5 C9               RET
1804+ 53C6              .CHAR:
1805+ 53C6 DD 6E 00         LD L,(IX)
1806+ 53C9 3D               DEC A
1807+ 53CA 67               LD H,A
1808+ 53CB CD 70 5D         CALL HLx8
1809+ 53CE 3A AF FC         LD A,(SCRMOD)
1810+ 53D1 3D               DEC A
1811+ 53D2 20 06            JR NZ,.L8
1812+ 53D4 ED 5B C1 F3      LD DE,(T32CGP)
1813+ 53D8 18 04            JR .L9
1814+ 53DA              .L8:
1815+ 53DA ED 5B CB F3      LD DE,(GRPCGP)
1816+ 53DE              .L9:
1817+ 53DE 06 08            LD B,8
1818+ 53E0 18 BD            JR .L7
1819+ 53E2              ; *******************************************************************************************************
1820+ 53E2
# file closed: asm\ANIMATION.asm
 133  53E2               INCLUDE "SGAM.asm"
# file opened: asm\SGAM.asm
   1+ 53E2              ; Sprite Group Animate and Move
   2+ 53E2
   3+ 53E2              ; *******************************************************************************************************
   4+ 53E2              ; shared function to process a list of animations
   5+ 53E2              ; input B=list size
   6+ 53E2              ; input DE=list pointer
   7+ 53E2              SGAM_PROCESS_ANIM_LIST:
   8+ 53E2 21 F5 53         LD HL,.STEP
   9+ 53E5 22 7A 52         LD (ANIM_SETVALUE.FN+1),HL
  10+ 53E8              .L1:
  11+ 53E8 C5               PUSH BC
  12+ 53E9 1A               LD A,(DE)
  13+ 53EA 13          > INC DE
  13+ 53EB 13          > INC DE
  14+ 53EC D5               PUSH DE
  15+ 53ED CD 6A 52         CALL ANIM_SETVALUE
  16+ 53F0 D1               POP DE
  17+ 53F1 C1               POP BC
  18+ 53F2 10 F4            DJNZ .L1
  19+ 53F4 C9           	RET
  20+ 53F5              .STEP:
  21+ 53F5 06 01            LD B,1
  22+ 53F7 C3 F0 52         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
  23+ 53FA              ; *******************************************************************************************************
  24+ 53FA
  25+ 53FA               IF (0 == 1)
  26+ 53FA ~            ; *******************************************************************************************************
  27+ 53FA ~            ; function to handle CALL SGAM basic extension
  28+ 53FA ~            ; sets position of a group of sprites as described in SPRGRPMOV
  29+ 53FA ~            ; and manually animate a list of animations
  30+ 53FA ~            ; _SGAM ( INT x,
  31+ 53FA ~            ;	      INT y,
  32+ 53FA ~            ;		  BYTE count,
  33+ 53FA ~            ;		  INT[2][count] data_ptr,
  34+ 53FA ~            ;         BYTE item_number,
  35+ 53FA ~            ;         INT[] sprite_animations )
  36+ 53FA ~            ; will put ram in page 0 also, page 1 is already there
  37+ 53FA ~            SGAM:
  38+ 53FA ~            	LD A, (SPRATR_INIT_STATUS)
  39+ 53FA ~            	OR A
  40+ 53FA ~            	JP Z,ILLEGAL_FUNCTION
  41+ 53FA ~            	; opening (
  42+ 53FA ~            	CALL CHKCHAR
  43+ 53FA ~            	DB '('
  44+ 53FA ~            	; get x
  45+ 53FA ~            	LD IX, FRMQNT
  46+ 53FA ~            	CALL CALBAS
  47+ 53FA ~            	LD (BLIT_STRUCT),DE
  48+ 53FA ~            	; comma
  49+ 53FA ~            	CALL CHKCHAR
  50+ 53FA ~            	DB ','
  51+ 53FA ~            	; get y
  52+ 53FA ~            	LD IX, FRMQNT
  53+ 53FA ~            	CALL CALBAS
  54+ 53FA ~            	LD (BLIT_STRUCT+2),DE
  55+ 53FA ~            	; comma
  56+ 53FA ~            	CALL CHKCHAR
  57+ 53FA ~            	DB ','
  58+ 53FA ~            	; get count
  59+ 53FA ~            	LD IX, GETBYT
  60+ 53FA ~            	CALL CALBAS
  61+ 53FA ~                OR A
  62+ 53FA ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
  63+ 53FA ~            	LD (BLIT_STRUCT+4),A
  64+ 53FA ~            	; comma
  65+ 53FA ~            	CALL CHKCHAR
  66+ 53FA ~            	DB ','
  67+ 53FA ~            	; get sprite group definition array data pointer
  68+ 53FA ~                LD A,(BLIT_STRUCT+4)
  69+ 53FA ~            	LD E,A
  70+ 53FA ~            	LD D,3
  71+ 53FA ~            	LD A,2
  72+ 53FA ~            	LD B,A
  73+ 53FA ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
  74+ 53FA ~            	LD (BLIT_STRUCT+5),BC
  75+ 53FA ~            	; comma
  76+ 53FA ~            	CALL CHKCHAR
  77+ 53FA ~            	DB ','
  78+ 53FA ~            	; get sprite animation array size
  79+ 53FA ~            	LD IX,GETBYT
  80+ 53FA ~            	CALL CALBAS
  81+ 53FA ~                LD (BLIT_STRUCT+7),A
  82+ 53FA ~                OR A
  83+ 53FA ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
  84+ 53FA ~            	; comma
  85+ 53FA ~            	CALL CHKCHAR
  86+ 53FA ~            	DB ','
  87+ 53FA ~                ; get array pointer
  88+ 53FA ~                LD A,(BLIT_STRUCT+7)
  89+ 53FA ~                LD D,A
  90+ 53FA ~                LD A,2
  91+ 53FA ~                LD B,1
  92+ 53FA ~                CALL GET_BASIC_ARRAY_DATA_POINTER
  93+ 53FA ~                LD (BLIT_STRUCT+8),BC
  94+ 53FA ~            	; ending )
  95+ 53FA ~            	CALL CHKCHAR
  96+ 53FA ~            	DB ')'
  97+ 53FA ~            .ENTRY:
  98+ 53FA ~                PUSH HL
  99+ 53FA ~
 100+ 53FA ~            	; enable page 0
 101+ 53FA ~            	LD IY, .RET
 102+ 53FA ~            	JP ENABLE_PAGE0
 103+ 53FA ~            .RET:
 104+ 53FA ~                EXX
 105+ 53FA ~                LD DE,(BLIT_STRUCT) ; initial x
 106+ 53FA ~                LD BC,(BLIT_STRUCT+2) ; initial y
 107+ 53FA ~                EXX
 108+ 53FA ~                LD HL,(BLIT_STRUCT+5) ; pointer to data
 109+ 53FA ~                LD A,(BLIT_STRUCT+4) ; number of entries
 110+ 53FA ~                LD B,A
 111+ 53FA ~                CALL SPR_UPDATE_LOC
 112+ 53FA ~
 113+ 53FA ~                LD A,(BLIT_STRUCT+7) ; anim number
 114+ 53FA ~                LD B,A
 115+ 53FA ~                LD DE,(BLIT_STRUCT+8) ; anim list
 116+ 53FA ~            	CALL SGAM_PROCESS_ANIM_LIST
 117+ 53FA ~
 118+ 53FA ~                POP DE
 119+ 53FA ~                POP BC
 120+ 53FA ~                CALL RESTORE_PAGE_INFO
 121+ 53FA ~                EI
 122+ 53FA ~                POP HL
 123+ 53FA ~                RET
 124+ 53FA ~            ; *******************************************************************************************************
 125+ 53FA               ENDIF
 126+ 53FA
 127+ 53FA               IF (1 == 1)
 128+ 53FA              ; *******************************************************************************************************
 129+ 53FA              ; same as SGAM but for DEFUSR approach
 130+ 53FA              ; input IX=pointer to input array, real data from +2
 131+ 53FA              ; +02 = X
 132+ 53FA              ; +04 = Y
 133+ 53FA              ; +06 = count
 134+ 53FA              ; +08 = data pointer
 135+ 53FA              ; +10 = anim number
 136+ 53FA              ; +12 = sprite animations
 137+ 53FA              SGAM_DEFUSR:
 138+ 53FA              	; enable page 0
 139+ 53FA FD 21 01 54  	LD IY, .RET
 140+ 53FE C3 34 5E     	JP ENABLE_PAGE0
 141+ 5401              .RET:
 142+ 5401 FB           	EI
 143+ 5402 D9               EXX
 144+ 5403 DD 5E 02     	LD E,(IX+2)
 145+ 5406 DD 56 03     	LD D,(IX+3) ; initial x
 146+ 5409 DD 4E 04     	LD C,(IX+4)
 147+ 540C DD 46 05     	LD B,(IX+5) ; initial y
 148+ 540F D9               EXX
 149+ 5410 DD 6E 08     	LD L,(IX+8)
 150+ 5413 DD 66 09     	LD H,(IX+9) ; pointer to data
 151+ 5416 DD 46 06         LD B,(IX+6) ; count
 152+ 5419 DD E5        	PUSH IX
 153+ 541B CD BA 4E         CALL SPR_UPDATE_LOC
 154+ 541E DD E1        	POP IX
 155+ 5420 DD 46 0A         LD B,(IX+10) ; anim number
 156+ 5423 DD 5E 0C     	LD E,(IX+12)
 157+ 5426 DD 56 0D     	LD D,(IX+13)
 158+ 5429 CD E2 53     	CALL SGAM_PROCESS_ANIM_LIST
 159+ 542C
 160+ 542C D1               POP DE
 161+ 542D C1               POP BC
 162+ 542E C3 AB 5D         JP RESTORE_PAGE_INFO
 163+ 5431              ; *******************************************************************************************************
 164+ 5431               ENDIF
 165+ 5431
 166+ 5431              ; *******************************************************************************************************
 167+ 5431              ; handles automatic move and animate sprite groups during interrupt
 168+ 5431              PROCESS_AUTOSGAMS:
 169+ 5431 3A F8 4E     	LD A,(AUTOSGAMNUM)
 170+ 5434 B7           	OR A
 171+ 5435 C8           	RET Z
 172+ 5436 47           	LD B,A
 173+ 5437 DD 2A F9 4E  	LD IX,(AUTOSGAMPTR)
 174+ 543B              .L1:
 175+ 543B C5           	PUSH BC
 176+ 543C DD 7E 13     	LD A,(IX+19) ; active flag
 177+ 543F B7           	OR A
 178+ 5440 28 28        	JR Z,.LOOPEND
 179+ 5442              	; active, check timer
 180+ 5442 DD 6E 16     	LD L,(IX+22)
 181+ 5445 DD 66 17     	LD H,(IX+23) ; timer
 182+ 5448 2B           	DEC HL
 183+ 5449 7C           	LD A,H
 184+ 544A B5           	OR L
 185+ 544B 28 08        	JR Z,.L2
 186+ 544D              	; not expired
 187+ 544D DD 75 16     	LD (IX+22),L
 188+ 5450 DD 74 17     	LD (IX+23),H
 189+ 5453 18 15        	JR .LOOPEND
 190+ 5455              .L2:
 191+ 5455              	; expired, process
 192+ 5455
 193+ 5455                  ; set initial timer
 194+ 5455 DD 7E 14         LD A,(IX+20)
 195+ 5458 DD 77 16         LD (IX+22),A
 196+ 545B DD 7E 15         LD A,(IX+21)
 197+ 545E DD 77 17         LD (IX+23),A
 198+ 5461
 199+ 5461 CD 73 54     	CALL .MOVE
 200+ 5464 CD DE 54     	CALL .UPDATELOC
 201+ 5467 CD 03 55     	CALL .PROCESS_ANIM_LIST
 202+ 546A
 203+ 546A              .LOOPEND:
 204+ 546A 11 18 00     	LD DE,24
 205+ 546D DD 19        	ADD IX,DE
 206+ 546F C1           	POP BC
 207+ 5470 10 C9        	DJNZ .L1
 208+ 5472 C9           	RET
 209+ 5473
 210+ 5473              .MOVE:
 211+ 5473              	; process movement
 212+ 5473 DD 7E 0A     	LD A,(IX+10) ; direction
 213+ 5476 B7           	OR A
 214+ 5477 28 08        	JR Z, .MOVE_L1
 215+ 5479              	; vertical
 216+ 5479 DD 6E 02     	LD L,(IX+2)
 217+ 547C DD 66 03     	LD H,(IX+3) ; vertical variable pointer
 218+ 547F 18 06        	JR .MOVE_L2
 219+ 5481              .MOVE_L1:
 220+ 5481              	; horizontal
 221+ 5481 DD 6E 00     	LD L,(IX+0)
 222+ 5484 DD 66 01     	LD H,(IX+1) ; horizontal variable pointer
 223+ 5487              .MOVE_L2:
 224+ 5487 E5           	PUSH HL
 225+ 5488 FD E1        	POP IY
 226+ 548A FD 6E 00     	LD L,(IY+0)
 227+ 548D FD 66 01     	LD H,(IY+1)
 228+ 5490 DD 5E 08     	LD E,(IX+8)
 229+ 5493 DD 56 09     	LD D,(IX+9) ; delta value
 230+ 5496 19           	ADD HL,DE
 231+ 5497 E5           	PUSH HL
 232+ 5498 DD 5E 04     	LD E,(IX+4)
 233+ 549B DD 56 05     	LD D,(IX+5) ; minimum value
 234+ 549E A7           	AND A
 235+ 549F ED 52        	SBC HL,DE
 236+ 54A1 FA BB 54     	JP M,.MOVE_L3 ; below minimum
 237+ 54A4 E1           	POP HL
 238+ 54A5 E5           	PUSH HL
 239+ 54A6 DD 5E 06     	LD E,(IX+6)
 240+ 54A9 DD 56 07     	LD D,(IX+7) ; maximum value
 241+ 54AC EB           	EX DE,HL
 242+ 54AD A7           	AND A
 243+ 54AE ED 52        	SBC HL,DE
 244+ 54B0 FA C3 54     	JP M,.MOVE_L4 ; above maximum
 245+ 54B3 E1           	POP HL
 246+ 54B4              	; within bounds
 247+ 54B4              .MOVE_L5:
 248+ 54B4 FD 75 00     	LD (IY+0),L
 249+ 54B7 FD 74 01     	LD (IY+1),H
 250+ 54BA C9           	RET
 251+ 54BB              .MOVE_L3:
 252+ 54BB E1           	POP HL
 253+ 54BC CD CF 54     	CALL .INVERSE_DELTA
 254+ 54BF 6B           	LD L,E
 255+ 54C0 62           	LD H,D
 256+ 54C1 18 F1        	JR .MOVE_L5
 257+ 54C3              .MOVE_L4:
 258+ 54C3 E1           	POP HL
 259+ 54C4 CD CF 54     	CALL .INVERSE_DELTA
 260+ 54C7 DD 6E 06     	LD L,(IX+6)
 261+ 54CA DD 66 07     	LD H,(IX+7) ; maximum
 262+ 54CD 18 E5        	JR .MOVE_L5
 263+ 54CF              .INVERSE_DELTA:
 264+ 54CF AF           	XOR A
 265+ 54D0 DD 96 08     	SUB (IX+8)
 266+ 54D3 DD 77 08     	LD (IX+8),A
 267+ 54D6 9F           	SBC A,A
 268+ 54D7 DD 96 09     	SUB (IX+9)
 269+ 54DA DD 77 09     	LD (IX+9),A
 270+ 54DD C9           	RET
 271+ 54DE
 272+ 54DE              .UPDATELOC:
 273+ 54DE DD E5        	PUSH IX
 274+ 54E0 D9           	EXX
 275+ 54E1 DD 6E 00     	LD L,(IX+0)
 276+ 54E4 DD 66 01     	LD H,(IX+1)
 277+ 54E7 5E           	LD E,(HL)
 278+ 54E8 23           	INC HL
 279+ 54E9 56           	LD D,(HL)
 280+ 54EA DD 6E 02     	LD L,(IX+2)
 281+ 54ED DD 66 03     	LD H,(IX+3)
 282+ 54F0 4E           	LD C,(HL)
 283+ 54F1 23           	INC HL
 284+ 54F2 46           	LD B,(HL)
 285+ 54F3 D9           	EXX
 286+ 54F4 DD 6E 0C     	LD L,(IX+12)
 287+ 54F7 DD 66 0D     	LD H,(IX+13) ; pointer to sprite group data
 288+ 54FA DD 46 0B     	LD B,(IX+11) ; sprite group size
 289+ 54FD CD BA 4E     	CALL SPR_UPDATE_LOC
 290+ 5500 DD E1        	POP IX
 291+ 5502 C9           	RET
 292+ 5503
 293+ 5503              .PROCESS_ANIM_LIST:
 294+ 5503 DD E5        	PUSH IX
 295+ 5505 DD 46 0E         LD B,(IX+14) ; anim list size
 296+ 5508 DD CB 09 7E  	BIT 7,(IX+9)
 297+ 550C 28 08        	JR Z,.PROCESS_ANIM_LIST_L1
 298+ 550E              	; negative direction
 299+ 550E DD 5E 0F     	LD E,(IX+15)
 300+ 5511 DD 56 10     	LD D,(IX+16)
 301+ 5514 18 06        	JR .PROCESS_ANIM_LIST_L2
 302+ 5516              .PROCESS_ANIM_LIST_L1:
 303+ 5516              	; positive direction
 304+ 5516 DD 5E 11     	LD E,(IX+17)
 305+ 5519 DD 56 12     	LD D,(IX+18)
 306+ 551C              .PROCESS_ANIM_LIST_L2:
 307+ 551C CD E2 53     	CALL SGAM_PROCESS_ANIM_LIST
 308+ 551F DD E1        	POP IX
 309+ 5521 C9           	RET
 310+ 5522              ; *******************************************************************************************************
 311+ 5522
# file closed: asm\SGAM.asm
 134  5522               ENDIF
 135  5522
 136  5522               IF (RAM_CMDS == 1)
 137  5522               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
   1+ 5522               IF (0 == 1)
   2+ 5522 ~            ; *******************************************************************************************************
   3+ 5522 ~            ; function to handle CALL MEMCPY basic extension
   4+ 5522 ~            ; _MEMCPY ( INT source,
   5+ 5522 ~            ;			INT destination,
   6+ 5522 ~            ;			INT count,
   7+ 5522 ~            ; will put ram in page 0 also, page 1 is already there
   8+ 5522 ~            MEMCPY:
   9+ 5522 ~            	; opening (
  10+ 5522 ~            	CALL CHKCHAR
  11+ 5522 ~            	DB '('
  12+ 5522 ~            	; get source address
  13+ 5522 ~            	LD IX, FRMQNT
  14+ 5522 ~            	CALL CALBAS
  15+ 5522 ~            	PUSH DE
  16+ 5522 ~            	; comma
  17+ 5522 ~            	CALL CHKCHAR
  18+ 5522 ~            	DB ','
  19+ 5522 ~            	; get destination address
  20+ 5522 ~            	LD IX, FRMQNT
  21+ 5522 ~            	CALL CALBAS
  22+ 5522 ~            	PUSH DE
  23+ 5522 ~            	; comma
  24+ 5522 ~            	CALL CHKCHAR
  25+ 5522 ~            	DB ','
  26+ 5522 ~            	; get length
  27+ 5522 ~            	LD IX, FRMQNT
  28+ 5522 ~            	CALL CALBAS
  29+ 5522 ~            	PUSH DE
  30+ 5522 ~            	; ending )
  31+ 5522 ~            	CALL CHKCHAR
  32+ 5522 ~            	DB ')'
  33+ 5522 ~
  34+ 5522 ~            	; save position
  35+ 5522 ~            	PUSH HL
  36+ 5522 ~            	POP IX
  37+ 5522 ~
  38+ 5522 ~            	POP BC ; count
  39+ 5522 ~            	POP DE ; destination
  40+ 5522 ~            	POP HL ; source
  41+ 5522 ~            	EXX
  42+ 5522 ~            	; enable page 0
  43+ 5522 ~            	LD IY, .RET
  44+ 5522 ~            	JP ENABLE_PAGE0
  45+ 5522 ~            .RET:
  46+ 5522 ~            	EI
  47+ 5522 ~            	EXX
  48+ 5522 ~            	LDIR
  49+ 5522 ~                POP DE
  50+ 5522 ~                POP BC
  51+ 5522 ~                CALL RESTORE_PAGE_INFO
  52+ 5522 ~            	PUSH IX
  53+ 5522 ~            	POP HL
  54+ 5522 ~            	RET
  55+ 5522 ~            ; *******************************************************************************************************
  56+ 5522               ENDIF
  57+ 5522
  58+ 5522               IF (1 == 1)
  59+ 5522              ; *******************************************************************************************************
  60+ 5522              ; same as MEMCPY but for DEFUSR approach
  61+ 5522              ; input IX=pointer to input array, real data from +2
  62+ 5522              ; +2 = source address
  63+ 5522              ; +4 = destination address
  64+ 5522              ; +6 = lenght
  65+ 5522              MEMCPY_DEFUSR:
  66+ 5522              	; enable page 0
  67+ 5522 FD 21 29 55  	LD IY, .RET
  68+ 5526 C3 34 5E     	JP ENABLE_PAGE0
  69+ 5529              .RET:
  70+ 5529 FB           	EI
  71+ 552A DD 6E 02     	LD L,(IX+2)
  72+ 552D DD 66 03     	LD H,(IX+3)
  73+ 5530 DD 5E 04     	LD E,(IX+4)
  74+ 5533 DD 56 05     	LD D,(IX+5)
  75+ 5536 DD 4E 06     	LD C,(IX+6)
  76+ 5539 DD 46 07     	LD B,(IX+7)
  77+ 553C ED B0        	LDIR
  78+ 553E D1               POP DE
  79+ 553F C1               POP BC
  80+ 5540 C3 AB 5D         JP RESTORE_PAGE_INFO
  81+ 5543              ; *******************************************************************************************************
  82+ 5543               ENDIF
  83+ 5543
  84+ 5543               IF (0 == 1)
  85+ 5543 ~            ; *******************************************************************************************************
  86+ 5543 ~            ; function to handle CALL FILRAM basic extension
  87+ 5543 ~            ; FILRAM ( INT start address,
  88+ 5543 ~            ;		   INT count,
  89+ 5543 ~            ;		   BYTE value )
  90+ 5543 ~            ; will put ram in page 0 also, page 1 is already there
  91+ 5543 ~            FILRAM:
  92+ 5543 ~            	; opening (
  93+ 5543 ~            	CALL CHKCHAR
  94+ 5543 ~            	DB '('
  95+ 5543 ~            	; get start address
  96+ 5543 ~            	LD IX, FRMQNT
  97+ 5543 ~            	CALL CALBAS
  98+ 5543 ~            	PUSH DE
  99+ 5543 ~            	; comma
 100+ 5543 ~            	CALL CHKCHAR
 101+ 5543 ~            	DB ','
 102+ 5543 ~            	; get count
 103+ 5543 ~            	LD IX, FRMQNT
 104+ 5543 ~            	CALL CALBAS
 105+ 5543 ~            	PUSH DE
 106+ 5543 ~            	; comma
 107+ 5543 ~            	CALL CHKCHAR
 108+ 5543 ~            	DB ','
 109+ 5543 ~            	; get value
 110+ 5543 ~            	LD IX, GETBYT
 111+ 5543 ~            	CALL CALBAS
 112+ 5543 ~            	PUSH AF
 113+ 5543 ~            	; ending )
 114+ 5543 ~            	CALL CHKCHAR
 115+ 5543 ~            	DB ')'
 116+ 5543 ~
 117+ 5543 ~            	; save position
 118+ 5543 ~            	PUSH HL
 119+ 5543 ~            	POP IX
 120+ 5543 ~
 121+ 5543 ~            	POP DE ; actually AF
 122+ 5543 ~            	POP BC ; count
 123+ 5543 ~            	POP HL ; start address
 124+ 5543 ~            	LD A, B
 125+ 5543 ~            	OR C
 126+ 5543 ~            	JR Z, .EXIT ; 0 bytes to fill, skip
 127+ 5543 ~            	EXX
 128+ 5543 ~            	; enable page 0
 129+ 5543 ~            	LD IY, .RET
 130+ 5543 ~            	JP ENABLE_PAGE0
 131+ 5543 ~            .RET:
 132+ 5543 ~            	EI
 133+ 5543 ~            	EXX
 134+ 5543 ~            	CALL FILVRM_FILLVALUE
 135+ 5543 ~                POP DE
 136+ 5543 ~                POP BC
 137+ 5543 ~                CALL RESTORE_PAGE_INFO
 138+ 5543 ~            .EXIT:
 139+ 5543 ~            	PUSH IX
 140+ 5543 ~            	POP HL
 141+ 5543 ~            	RET
 142+ 5543 ~            ; *******************************************************************************************************
 143+ 5543               ENDIF
 144+ 5543
 145+ 5543               IF (1 == 1)
 146+ 5543              ; *******************************************************************************************************
 147+ 5543              ; same as FILVRM but for DEFUSR approach
 148+ 5543              ; input IX=pointer to input array, real data from +2
 149+ 5543              ; +2 = start address
 150+ 5543              ; +4 = count
 151+ 5543              ; +6 = value
 152+ 5543              FILRAM_DEFUSR:
 153+ 5543              	; enable page 0
 154+ 5543 FD 21 4A 55  	LD IY, .RET
 155+ 5547 C3 34 5E     	JP ENABLE_PAGE0
 156+ 554A              .RET:
 157+ 554A FB           	EI
 158+ 554B DD 6E 02     	LD L,(IX+2)
 159+ 554E DD 66 03     	LD H,(IX+3)
 160+ 5551 DD 4E 04     	LD C,(IX+4)
 161+ 5554 DD 46 05     	LD B,(IX+5)
 162+ 5557 78           	LD A,B
 163+ 5558 B1           	OR C
 164+ 5559 28 06        	JR Z,.EXIT
 165+ 555B DD 56 06     	LD D,(IX+6)
 166+ 555E CD 66 55     	CALL FILVRM_FILLVALUE
 167+ 5561              .EXIT:
 168+ 5561 D1               POP DE
 169+ 5562 C1               POP BC
 170+ 5563 C3 AB 5D         JP RESTORE_PAGE_INFO
 171+ 5566              ; *******************************************************************************************************
 172+ 5566               ENDIF
 173+ 5566
 174+ 5566              ; *******************************************************************************************************
 175+ 5566              ; common function to fill RAM
 176+ 5566              FILVRM_FILLVALUE:
 177+ 5566 72               LD (HL), D
 178+ 5567 54               LD D, H
 179+ 5568 5D               LD E, L
 180+ 5569 13               INC DE
 181+ 556A 0B               DEC BC
 182+ 556B 78           	LD A,B
 183+ 556C B1           	OR C
 184+ 556D C8           	RET Z ; if count was 1
 185+ 556E ED B0            LDIR
 186+ 5570 C9               RET
 187+ 5571              ; *******************************************************************************************************
# file closed: asm\MEMORY.asm
 138  5571               ENDIF
 139  5571
 140  5571               IF (SOUND_CMDS == 1)
 141  5571               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
   1+ 5571              MUSIC_INIT_STATUS:
   2+ 5571 00            DB 0
   3+ 5572              SFX_INIT_STATUS:
   4+ 5572 00            DB 0
   5+ 5573              SOUND_ENABLED:
   6+ 5573 00            DB 0
   7+ 5574
   8+ 5574               IF (0 == 1)
   9+ 5574 ~            ; *******************************************************************************************************
  10+ 5574 ~            ; function to handle CALL SNDPLYINIT basic extension
  11+ 5574 ~            ; initializes sound player
  12+ 5574 ~            ; _SNDPLYINIT ( INT music_offset,
  13+ 5574 ~            ;				INT sfx_offset, can be -1 if no SFX
  14+ 5574 ~            ; will put ram in page 0 also, page 1 is already there
  15+ 5574 ~            ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
  16+ 5574 ~            SNDPLYINIT:
  17+ 5574 ~            	; opening (
  18+ 5574 ~            	CALL CHKCHAR
  19+ 5574 ~            	DB '('
  20+ 5574 ~            	; get music address
  21+ 5574 ~            	LD IX, FRMQNT
  22+ 5574 ~            	CALL CALBAS
  23+ 5574 ~            	PUSH DE
  24+ 5574 ~            	; comma
  25+ 5574 ~            	CALL CHKCHAR
  26+ 5574 ~            	DB ','
  27+ 5574 ~            	; get sfx address
  28+ 5574 ~            	LD IX, FRMQNT
  29+ 5574 ~            	CALL CALBAS
  30+ 5574 ~            	PUSH DE
  31+ 5574 ~            	; ending )
  32+ 5574 ~            	CALL CHKCHAR
  33+ 5574 ~            	DB ')'
  34+ 5574 ~
  35+ 5574 ~                ; save position in BASIC text
  36+ 5574 ~            	LD B, H
  37+ 5574 ~            	LD C, L
  38+ 5574 ~
  39+ 5574 ~            	; pop LDIR parameters and store away for later
  40+ 5574 ~            	POP DE ; sfx address
  41+ 5574 ~            	POP HL ; music address
  42+ 5574 ~            	PUSH BC ; basic text location
  43+ 5574 ~            	EXX
  44+ 5574 ~            	LD IY, .RET
  45+ 5574 ~            	JP ENABLE_PAGE0
  46+ 5574 ~            .RET:
  47+ 5574 ~            	EXX
  48+ 5574 ~
  49+ 5574 ~            	PUSH DE
  50+ 5574 ~            	XOR A
  51+ 5574 ~            	; HL = music location
  52+ 5574 ~            	CALL PLY_AKG_INIT
  53+ 5574 ~            	LD A, 1
  54+ 5574 ~            	LD (MUSIC_INIT_STATUS), A
  55+ 5574 ~
  56+ 5574 ~            	POP HL ; SFX
  57+ 5574 ~            	; check if SFX address -1
  58+ 5574 ~            	INC HL
  59+ 5574 ~            	LD A, L
  60+ 5574 ~            	OR H
  61+ 5574 ~            	JR Z,.L1
  62+ 5574 ~            	DEC HL
  63+ 5574 ~            	CALL PLY_AKG_INITSOUNDEFFECTS
  64+ 5574 ~            	LD A, 1
  65+ 5574 ~            	LD (SFX_INIT_STATUS), A
  66+ 5574 ~            .L1:
  67+ 5574 ~                POP DE
  68+ 5574 ~                POP BC
  69+ 5574 ~                CALL RESTORE_PAGE_INFO
  70+ 5574 ~
  71+ 5574 ~            	POP HL
  72+ 5574 ~            	RET
  73+ 5574 ~            ; *******************************************************************************************************
  74+ 5574               ENDIF
  75+ 5574
  76+ 5574               IF (1 == 1)
  77+ 5574              ; *******************************************************************************************************
  78+ 5574              ; same as SNDPLYINI but for DEFUSR approach
  79+ 5574              ; input IX=pointer to input array, real data from +2
  80+ 5574              ; +2 = music address
  81+ 5574              ; +4 = sfx address
  82+ 5574              SNDPLYINI_DEFUSR:
  83+ 5574 FD 21 7B 55  	LD IY, .RET
  84+ 5578 C3 34 5E     	JP ENABLE_PAGE0
  85+ 557B              .RET:
  86+ 557B AF           	XOR A
  87+ 557C DD 6E 02     	LD L,(IX+2)
  88+ 557F DD 66 03     	LD H,(IX+3)
  89+ 5582 DD E5        	PUSH IX
  90+ 5584 CD 65 41     	CALL PLY_AKG_INIT
  91+ 5587 DD E1        	POP IX
  92+ 5589 3E 01        	LD A, 1
  93+ 558B 32 71 55     	LD (MUSIC_INIT_STATUS), A
  94+ 558E
  95+ 558E DD 6E 04     	LD L,(IX+4)
  96+ 5591 DD 66 05     	LD H,(IX+5)
  97+ 5594              	; check if SFX address -1
  98+ 5594 23           	INC HL
  99+ 5595 7D           	LD A, L
 100+ 5596 B4           	OR H
 101+ 5597 28 09        	JR Z,.L1
 102+ 5599 2B           	DEC HL
 103+ 559A CD 20 40     	CALL PLY_AKG_INITSOUNDEFFECTS
 104+ 559D 3E 01        	LD A, 1
 105+ 559F 32 72 55     	LD (SFX_INIT_STATUS), A
 106+ 55A2              .L1:
 107+ 55A2 D1               POP DE
 108+ 55A3 C1               POP BC
 109+ 55A4 C3 AB 5D         JP RESTORE_PAGE_INFO
 110+ 55A7              ; *******************************************************************************************************
 111+ 55A7               ENDIF
 112+ 55A7
 113+ 55A7              ; *******************************************************************************************************
 114+ 55A7              ; function to handle CALL SNDPLYON basic extension
 115+ 55A7              ; enables sound player
 116+ 55A7              ; _SNDPLYON
 117+ 55A7              ; sets SOUND_ENABLED variable to 1 if init call was done
 118+ 55A7              ; if not throws out of data error
 119+ 55A7              SNDPLYON_DEFUSR:
 120+ 55A7              SNDPLYON:
 121+ 55A7 3A 71 55     	LD A, (MUSIC_INIT_STATUS)
 122+ 55AA B7           	OR A
 123+ 55AB 20 05        	JR NZ, .L1
 124+ 55AD              	; player not initialized, throw error
 125+ 55AD 1E 04        	LD E, 04 ; Out of DATA
 126+ 55AF C3 A9 5E     	JP THROW_ERROR
 127+ 55B2              .L1:
 128+ 55B2 32 73 55     	LD (SOUND_ENABLED), A
 129+ 55B5              	; disable key click
 130+ 55B5 AF           	XOR A
 131+ 55B6 32 DB F3     	LD (CLIKSW), A
 132+ 55B9 C9           	RET
 133+ 55BA              ; *******************************************************************************************************
 134+ 55BA
 135+ 55BA              ; *******************************************************************************************************
 136+ 55BA              ; function to handle CALL SNDPLYOFF basic extension
 137+ 55BA              ; disables sound player
 138+ 55BA              ; _SNDPLYOFF
 139+ 55BA              ; sets SOUND_ENABLED variable to 0
 140+ 55BA              ; calls AKG to stop music and SFX on all channels if initialized
 141+ 55BA              SNDPLYOFF_DEFUSR:
 142+ 55BA              SNDPLYOFF:
 143+ 55BA 3A 73 55     	LD A, (SOUND_ENABLED)
 144+ 55BD B7           	OR A
 145+ 55BE C8           	RET Z ; already stopped
 146+ 55BF AF           	XOR A
 147+ 55C0 32 73 55     	LD (SOUND_ENABLED), A
 148+ 55C3 E5           	PUSH HL
 149+ 55C4 CD 24 42     	CALL PLY_AKG_STOP
 150+ 55C7 3A 72 55     	LD A, (SFX_INIT_STATUS)
 151+ 55CA B7           	OR A
 152+ 55CB 28 0E        	JR Z, .EXIT ; SFX not in use
 153+ 55CD AF           	XOR A
 154+ 55CE CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 155+ 55D1 3E 01        	LD A, 1
 156+ 55D3 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 157+ 55D6 3E 02        	LD A, 2
 158+ 55D8 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 159+ 55DB              .EXIT:
 160+ 55DB E1           	POP HL
 161+ 55DC C9           	RET
 162+ 55DD              ; *******************************************************************************************************
 163+ 55DD
 164+ 55DD               IF (0 == 1)
 165+ 55DD ~            ; *******************************************************************************************************
 166+ 55DD ~            ; function to handle CALL SNDSFX basic extension
 167+ 55DD ~            ; plays a sound effect
 168+ 55DD ~            ; _SNDSFX ( BYTE sfx_number, >0
 169+ 55DD ~            ;			BYTE channel, = 0,1 or 2
 170+ 55DD ~            ;			BYTE inverted_volume = 0-16, 0 being full volume
 171+ 55DD ~            ; will put ram in page 0 also, page 1 is already there
 172+ 55DD ~            ; if sound off throws illegal function call
 173+ 55DD ~            ; if sfx not initialized, throws out of data
 174+ 55DD ~            SNDSFX:
 175+ 55DD ~            	; opening (
 176+ 55DD ~            	CALL CHKCHAR
 177+ 55DD ~            	DB '('
 178+ 55DD ~            	; get sfx_number
 179+ 55DD ~            	LD IX, GETBYT
 180+ 55DD ~            	CALL CALBAS
 181+ 55DD ~            	PUSH DE
 182+ 55DD ~            	; comma
 183+ 55DD ~            	CALL CHKCHAR
 184+ 55DD ~            	DB ','
 185+ 55DD ~            	; get sfx address
 186+ 55DD ~            	LD IX, GETBYT
 187+ 55DD ~            	CALL CALBAS
 188+ 55DD ~            	PUSH DE
 189+ 55DD ~            	; comma
 190+ 55DD ~            	CALL CHKCHAR
 191+ 55DD ~            	DB ','
 192+ 55DD ~            	; get inverted volume
 193+ 55DD ~            	LD IX, GETBYT
 194+ 55DD ~            	CALL CALBAS
 195+ 55DD ~            	PUSH DE
 196+ 55DD ~            	; ending )
 197+ 55DD ~            	CALL CHKCHAR
 198+ 55DD ~            	DB ')'
 199+ 55DD ~
 200+ 55DD ~            	LD A, (SOUND_ENABLED)
 201+ 55DD ~            	OR A
 202+ 55DD ~            	JR NZ, .L1
 203+ 55DD ~            	; sound disabled, throw illegal function call
 204+ 55DD ~            	LD E, 5
 205+ 55DD ~            	JP THROW_ERROR
 206+ 55DD ~            .L1:
 207+ 55DD ~            	LD A, (SFX_INIT_STATUS)
 208+ 55DD ~            	OR A
 209+ 55DD ~            	JR NZ, .L2
 210+ 55DD ~            	; sfx data not initialized, throw out of data
 211+ 55DD ~            	LD E, 4
 212+ 55DD ~            	JP THROW_ERROR
 213+ 55DD ~            .L2:
 214+ 55DD ~            	; pop  parameters and store away for later
 215+ 55DD ~            	POP DE ; inverted volume
 216+ 55DD ~            	LD B, E
 217+ 55DD ~            	POP DE ; channel
 218+ 55DD ~            	LD C, E
 219+ 55DD ~            	POP DE
 220+ 55DD ~            	LD A, E
 221+ 55DD ~            	EX AF, AF'
 222+ 55DD ~            	PUSH HL ; basic text location
 223+ 55DD ~            	EXX
 224+ 55DD ~            	LD IY, .RET
 225+ 55DD ~            	JP ENABLE_PAGE0
 226+ 55DD ~            .RET:
 227+ 55DD ~            	EXX
 228+ 55DD ~            	EX AF, AF'
 229+ 55DD ~            	CALL PLY_AKG_PLAYSOUNDEFFECT
 230+ 55DD ~
 231+ 55DD ~                POP DE
 232+ 55DD ~                POP BC
 233+ 55DD ~                CALL RESTORE_PAGE_INFO
 234+ 55DD ~
 235+ 55DD ~            	POP HL
 236+ 55DD ~            	RET
 237+ 55DD ~            ; *******************************************************************************************************
 238+ 55DD               ENDIF
 239+ 55DD
 240+ 55DD               IF (1 == 1)
 241+ 55DD              ; *******************************************************************************************************
 242+ 55DD              ; same as SNDSFX but for DEFUSR approach
 243+ 55DD              ; input IX=pointer to input array, real data from +2
 244+ 55DD              ; +2 = SFX number
 245+ 55DD              ; +4 = channel
 246+ 55DD              ; +6 = volume
 247+ 55DD              SNDSFX_DEFUSR:
 248+ 55DD 3A 73 55     	LD A, (SOUND_ENABLED)
 249+ 55E0 B7           	OR A
 250+ 55E1 C8           	RET Z ; sound disabled, just exit
 251+ 55E2 3A 72 55     	LD A, (SFX_INIT_STATUS)
 252+ 55E5 B7           	OR A
 253+ 55E6 C8           	RET Z ; sfx data not initialized, just exit
 254+ 55E7 FD 21 EE 55  	LD IY, .RET
 255+ 55EB C3 34 5E     	JP ENABLE_PAGE0
 256+ 55EE              .RET:
 257+ 55EE FB           	EI
 258+ 55EF DD 7E 02     	LD A,(IX+2) ; SFX number
 259+ 55F2 DD 4E 04     	LD C,(IX+4) ; channel
 260+ 55F5 DD 46 06     	LD B,(IX+6) ; volume
 261+ 55F8 CD 24 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
 262+ 55FB D1               POP DE
 263+ 55FC C1               POP BC
 264+ 55FD C3 AB 5D         JP RESTORE_PAGE_INFO
 265+ 5600              ; *******************************************************************************************************
 266+ 5600               ENDIF
# file closed: asm\SOUND.asm
 142  5600               ENDIF
 143  5600
 144  5600               IF (VRAM_CMDS == 1)
 145  5600               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
   1+ 5600               IF (0 == 1)
   2+ 5600 ~            ; *******************************************************************************************************
   3+ 5600 ~            ; function to handle CALL FILVRM basic extension
   4+ 5600 ~            ; FILVRM ( INT offset,
   5+ 5600 ~            ;		   INT count,
   6+ 5600 ~            ;		   BYTE value,
   7+ 5600 ~            ;		   BYTE wait_vsync) >0 = true
   8+ 5600 ~            ; wait_vsync will issue HALT before copying
   9+ 5600 ~            FILVRM:
  10+ 5600 ~            	; opening (
  11+ 5600 ~            	CALL CHKCHAR
  12+ 5600 ~            	DB '('
  13+ 5600 ~            	; get offset address
  14+ 5600 ~            	LD IX, FRMQNT
  15+ 5600 ~            	CALL CALBAS
  16+ 5600 ~            	PUSH DE
  17+ 5600 ~            	; comma
  18+ 5600 ~            	CALL CHKCHAR
  19+ 5600 ~            	DB ','
  20+ 5600 ~            	; get count
  21+ 5600 ~            	LD IX, FRMQNT
  22+ 5600 ~            	CALL CALBAS
  23+ 5600 ~            	PUSH DE
  24+ 5600 ~            	; comma
  25+ 5600 ~            	CALL CHKCHAR
  26+ 5600 ~            	DB ','
  27+ 5600 ~            	; get value
  28+ 5600 ~            	LD IX, GETBYT
  29+ 5600 ~            	CALL CALBAS
  30+ 5600 ~            	PUSH AF
  31+ 5600 ~            	; comma
  32+ 5600 ~            	CALL CHKCHAR
  33+ 5600 ~            	DB ','
  34+ 5600 ~            	; get vsync wait
  35+ 5600 ~            	LD IX, GETBYT
  36+ 5600 ~            	CALL CALBAS
  37+ 5600 ~            	PUSH AF
  38+ 5600 ~            	; ending )
  39+ 5600 ~            	CALL CHKCHAR
  40+ 5600 ~            	DB ')'
  41+ 5600 ~
  42+ 5600 ~            	; save position
  43+ 5600 ~            	PUSH HL
  44+ 5600 ~            	POP IX
  45+ 5600 ~
  46+ 5600 ~            	; syntax ok
  47+ 5600 ~            	; wait for vsync if needed
  48+ 5600 ~            	POP AF
  49+ 5600 ~            	OR A
  50+ 5600 ~            	JR Z, .L1
  51+ 5600 ~            	HALT
  52+ 5600 ~
  53+ 5600 ~            .L1:
  54+ 5600 ~            	LD A,1
  55+ 5600 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  56+ 5600 ~                POP AF ; value
  57+ 5600 ~                POP BC ; count
  58+ 5600 ~                POP HL ; offset
  59+ 5600 ~                CALL BIOS_FILVRM
  60+ 5600 ~            	XOR A
  61+ 5600 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  62+ 5600 ~
  63+ 5600 ~            .L3:
  64+ 5600 ~            	PUSH IX
  65+ 5600 ~            	POP HL
  66+ 5600 ~            	RET
  67+ 5600 ~            ; *******************************************************************************************************
  68+ 5600               ENDIF
  69+ 5600
  70+ 5600               IF (1 == 1)
  71+ 5600              ; *******************************************************************************************************
  72+ 5600              ; same as FILVRM but for DEFUSR approach
  73+ 5600              ; input IX=pointer to input array, real data from +2
  74+ 5600              ; +2 = offset
  75+ 5600              ; +4 = count
  76+ 5600              ; +6 = value
  77+ 5600              ; +8 = halt flag
  78+ 5600              FILVRM_DEFUSR:
  79+ 5600 DD 7E 08     	LD A,(IX+8)
  80+ 5603 B7           	OR A
  81+ 5604 28 01        	JR Z,.L0
  82+ 5606 76           	HALT
  83+ 5607              .L0:
  84+ 5607 3E 01        	LD A,1
  85+ 5609 32 1B 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
  86+ 560C DD 6E 02     	LD L,(IX+2)
  87+ 560F DD 66 03     	LD H,(IX+3)
  88+ 5612 DD 4E 04     	LD C,(IX+4)
  89+ 5615 DD 46 05     	LD B,(IX+5)
  90+ 5618 DD 7E 06     	LD A,(IX+6)
  91+ 561B CD 56 00     	CALL BIOS_FILVRM
  92+ 561E AF           	XOR A
  93+ 561F 32 1B 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
  94+ 5622 C9           	RET
  95+ 5623              ; *******************************************************************************************************
  96+ 5623               ENDIF
  97+ 5623
  98+ 5623               IF (0 == 1)
  99+ 5623 ~            ; *******************************************************************************************************
 100+ 5623 ~            ; function to handle CALL MEMVRM basic extension
 101+ 5623 ~            ; copies from RAM to VRAM
 102+ 5623 ~            ; _MEMVRM ( INT source,
 103+ 5623 ~            ;			INT destination,
 104+ 5623 ~            ;			INT count,
 105+ 5623 ~            ;			BYTE wait_vsync) >0 = true
 106+ 5623 ~            ; will put ram in page 0 also, page 1 is already there
 107+ 5623 ~            ; wait_vsync will issue HALT before copying
 108+ 5623 ~            MEMVRM:
 109+ 5623 ~            	; opening (
 110+ 5623 ~            	CALL CHKCHAR
 111+ 5623 ~            	DB '('
 112+ 5623 ~            	; get source address
 113+ 5623 ~            	LD IX, FRMQNT
 114+ 5623 ~            	CALL CALBAS
 115+ 5623 ~            	PUSH DE
 116+ 5623 ~            	; comma
 117+ 5623 ~            	CALL CHKCHAR
 118+ 5623 ~            	DB ','
 119+ 5623 ~            	; get destination address
 120+ 5623 ~            	LD IX, FRMQNT
 121+ 5623 ~            	CALL CALBAS
 122+ 5623 ~            	PUSH DE
 123+ 5623 ~            	; comma
 124+ 5623 ~            	CALL CHKCHAR
 125+ 5623 ~            	DB ','
 126+ 5623 ~            	; get length
 127+ 5623 ~            	LD IX, FRMQNT
 128+ 5623 ~            	CALL CALBAS
 129+ 5623 ~            	PUSH DE
 130+ 5623 ~            	; comma
 131+ 5623 ~            	CALL CHKCHAR
 132+ 5623 ~            	DB ','
 133+ 5623 ~            	; get vsync wait
 134+ 5623 ~            	LD IX, GETBYT
 135+ 5623 ~            	CALL CALBAS
 136+ 5623 ~            	PUSH AF
 137+ 5623 ~            	; ending )
 138+ 5623 ~            	CALL CHKCHAR
 139+ 5623 ~            	DB ')'
 140+ 5623 ~
 141+ 5623 ~                ; save position in BASIC text
 142+ 5623 ~            	PUSH HL
 143+ 5623 ~            	POP IX
 144+ 5623 ~
 145+ 5623 ~            	POP AF ; wait vsync
 146+ 5623 ~            	OR A
 147+ 5623 ~            	JR Z, .L1
 148+ 5623 ~            	; TEST
 149+ 5623 ~            	LD HL,(SPRATR_UPDATE_FLAG)
 150+ 5623 ~            	LD (HL),A
 151+ 5623 ~            	HALT
 152+ 5623 ~            .L1:
 153+ 5623 ~            	; pop LDIR parameters and store away for later
 154+ 5623 ~            	POP BC ; count
 155+ 5623 ~            	POP DE ; vram destination
 156+ 5623 ~            	POP HL ; ram source
 157+ 5623 ~            	EXX
 158+ 5623 ~             	LD IY, .RET
 159+ 5623 ~            	JP ENABLE_PAGE0
 160+ 5623 ~            .RET:
 161+ 5623 ~            	EI
 162+ 5623 ~            	EXX
 163+ 5623 ~            	CALL VRAM_LDIRVM
 164+ 5623 ~                POP DE
 165+ 5623 ~                POP BC
 166+ 5623 ~                CALL RESTORE_PAGE_INFO
 167+ 5623 ~            	PUSH IX
 168+ 5623 ~            	POP HL
 169+ 5623 ~            	RET
 170+ 5623 ~            ; *******************************************************************************************************
 171+ 5623               ENDIF
 172+ 5623
 173+ 5623               IF (1 == 1)
 174+ 5623              ; *******************************************************************************************************
 175+ 5623              ; same as MEMVRM but for DEFUSR approach
 176+ 5623              ; input IX=pointer to input array, real data from +2
 177+ 5623              ; +2 = source address
 178+ 5623              ; +4 = destination address
 179+ 5623              ; +6 = lenght
 180+ 5623              ; +8 = vsync wait flag
 181+ 5623              MEMVRM_DEFUSR:
 182+ 5623 DD 7E 08     	LD A,(IX+8)
 183+ 5626 B7           	OR A
 184+ 5627 28 01        	JR Z,.L0
 185+ 5629 76           	HALT
 186+ 562A              .L0:
 187+ 562A              	; enable page 0
 188+ 562A FD 21 31 56  	LD IY, .RET
 189+ 562E C3 34 5E     	JP ENABLE_PAGE0
 190+ 5631              .RET:
 191+ 5631 FB           	EI
 192+ 5632 DD 6E 02     	LD L,(IX+2)
 193+ 5635 DD 66 03     	LD H,(IX+3)
 194+ 5638 DD 5E 04     	LD E,(IX+4)
 195+ 563B DD 56 05     	LD D,(IX+5)
 196+ 563E DD 4E 06     	LD C,(IX+6)
 197+ 5641 DD 46 07     	LD B,(IX+7)
 198+ 5644 CD 4C 56     	CALL VRAM_LDIRVM
 199+ 5647 D1               POP DE
 200+ 5648 C1               POP BC
 201+ 5649 C3 AB 5D         JP RESTORE_PAGE_INFO
 202+ 564C              ; *******************************************************************************************************
 203+ 564C               ENDIF
 204+ 564C
 205+ 564C              ; *******************************************************************************************************
 206+ 564C              ; common code to copy from memory to VRAM
 207+ 564C              ; input HL=RAM source
 208+ 564C              ; input DE=VRAM destination
 209+ 564C              ; BC=count
 210+ 564C              VRAM_LDIRVM:
 211+ 564C 3E 01        	LD A,1
 212+ 564E 32 1B 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 213+ 5651 EB           	EX DE, HL
 214+ 5652 F3           	DI
 215+ 5653 CD 5B 5D     	CALL SETWRT_LOCAL
 216+ 5656 FB           	EI
 217+ 5657 EB           	EX DE, HL
 218+ 5658 78           	LD A, B
 219+ 5659 B7           	OR A
 220+ 565A 28 0D        	JR Z, .L3
 221+ 565C C5           	PUSH BC
 222+ 565D 0E 98        	LD C, #98
 223+ 565F              .L2:
 224+ 565F 50           	LD D, B
 225+ 5660 06 00        	LD B, 0
 226+ 5662 CD 68 5D     	CALL BBYTECOPY_NO_C
 227+ 5665 42           	LD B, D
 228+ 5666 10 F7        	DJNZ .L2
 229+ 5668 C1           	POP BC
 230+ 5669              .L3:
 231+ 5669 79           	LD A, C
 232+ 566A B7           	OR A
 233+ 566B 28 04        	JR Z,.L4
 234+ 566D 41           	LD B, C
 235+ 566E CD 66 5D     	CALL BBYTECOPY
 236+ 5671              .L4:
 237+ 5671 AF           	XOR A
 238+ 5672 32 1B 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 239+ 5675 C9           	RET
 240+ 5676              ; *******************************************************************************************************
 241+ 5676
 242+ 5676               IF (0 == 1)
 243+ 5676 ~            ; *******************************************************************************************************
 244+ 5676 ~            ; function to handle CALL VRMMEM basic extension
 245+ 5676 ~            ; copies from RAM to VRAM
 246+ 5676 ~            ; _VRMMEM ( INT source,
 247+ 5676 ~            ;			INT destination,
 248+ 5676 ~            ;			INT count
 249+ 5676 ~            ; will put ram in page 0 also, page 1 is already there
 250+ 5676 ~            VRMMEM:
 251+ 5676 ~            	; opening (
 252+ 5676 ~            	CALL CHKCHAR
 253+ 5676 ~            	DB '('
 254+ 5676 ~            	; get source address
 255+ 5676 ~            	LD IX, FRMQNT
 256+ 5676 ~            	CALL CALBAS
 257+ 5676 ~            	PUSH DE
 258+ 5676 ~            	; comma
 259+ 5676 ~            	CALL CHKCHAR
 260+ 5676 ~            	DB ','
 261+ 5676 ~            	; get destination address
 262+ 5676 ~            	LD IX, FRMQNT
 263+ 5676 ~            	CALL CALBAS
 264+ 5676 ~            	PUSH DE
 265+ 5676 ~            	; comma
 266+ 5676 ~            	CALL CHKCHAR
 267+ 5676 ~            	DB ','
 268+ 5676 ~            	; get length
 269+ 5676 ~            	LD IX, FRMQNT
 270+ 5676 ~            	CALL CALBAS
 271+ 5676 ~            	PUSH DE
 272+ 5676 ~            	; ending )
 273+ 5676 ~            	CALL CHKCHAR
 274+ 5676 ~            	DB ')'
 275+ 5676 ~
 276+ 5676 ~                ; save position in BASIC text
 277+ 5676 ~            	PUSH HL
 278+ 5676 ~            	POP IX
 279+ 5676 ~
 280+ 5676 ~            	POP BC ; count
 281+ 5676 ~            	POP DE ; destination
 282+ 5676 ~            	POP HL ; source
 283+ 5676 ~            	EXX
 284+ 5676 ~            	LD IY, .RET
 285+ 5676 ~            	JP ENABLE_PAGE0
 286+ 5676 ~            .RET:
 287+ 5676 ~            	EI
 288+ 5676 ~            	EXX
 289+ 5676 ~            	CALL VRAM_LDIRMV
 290+ 5676 ~                POP DE
 291+ 5676 ~                POP BC
 292+ 5676 ~                CALL RESTORE_PAGE_INFO
 293+ 5676 ~            	PUSH IX
 294+ 5676 ~            	POP HL
 295+ 5676 ~            	RET
 296+ 5676 ~            ; *******************************************************************************************************
 297+ 5676               ENDIF
 298+ 5676
 299+ 5676               IF (1 == 1)
 300+ 5676              ; *******************************************************************************************************
 301+ 5676              ; same as VRMMEM but for DEFUSR approach
 302+ 5676              ; input IX=pointer to input array, real data from +2
 303+ 5676              ; +2 = source address
 304+ 5676              ; +4 = destination address
 305+ 5676              ; +6 = count
 306+ 5676              VRMMEM_DEFUSR:
 307+ 5676              	; enable page 0
 308+ 5676 FD 21 7D 56  	LD IY, .RET
 309+ 567A C3 34 5E     	JP ENABLE_PAGE0
 310+ 567D              .RET:
 311+ 567D FB           	EI
 312+ 567E DD 6E 02     	LD L,(IX+2)
 313+ 5681 DD 66 03     	LD H,(IX+3)
 314+ 5684 DD 5E 04     	LD E,(IX+4)
 315+ 5687 DD 56 05     	LD D,(IX+5)
 316+ 568A DD 4E 06     	LD C,(IX+6)
 317+ 568D DD 46 07     	LD B,(IX+7)
 318+ 5690 CD 98 56     	CALL VRAM_LDIRMV
 319+ 5693 D1               POP DE
 320+ 5694 C1               POP BC
 321+ 5695 C3 AB 5D         JP RESTORE_PAGE_INFO
 322+ 5698              ; *******************************************************************************************************
 323+ 5698               ENDIF
 324+ 5698
 325+ 5698              ; *******************************************************************************************************
 326+ 5698              ; common code to copy from VRAM to RAM
 327+ 5698              ; input HL=VRAM source
 328+ 5698              ; input DE=RAM destination
 329+ 5698              ; BC=count
 330+ 5698              VRAM_LDIRMV:
 331+ 5698 3E 01        	LD A,1
 332+ 569A 32 1B 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 333+ 569D 7D           	LD	A, L
 334+ 569E F3           	DI
 335+ 569F D3 99        	OUT	(099H), A
 336+ 56A1 7C           	LD	A, H
 337+ 56A2 E6 3F        	AND	03FH
 338+ 56A4 00           	NOP ; too fast VDP access per openMSX
 339+ 56A5 D3 99        	OUT	(099H), A
 340+ 56A7 FB           	EI
 341+ 56A8 00           	NOP
 342+ 56A9 00           	NOP
 343+ 56AA 00           	NOP ; too fast VDP access per openMSX
 344+ 56AB              .L4:
 345+ 56AB DB 98            IN A, (#98)
 346+ 56AD 12           	LD (DE), A
 347+ 56AE 13               INC DE
 348+ 56AF 0B               DEC BC
 349+ 56B0 79               LD A, C
 350+ 56B1 B0               OR B
 351+ 56B2 20 F7            JR NZ, .L4
 352+ 56B4 AF           	XOR A
 353+ 56B5 32 1B 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 354+ 56B8 C9               RET
 355+ 56B9              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
 146  56B9               ENDIF
 147  56B9
 148  56B9               IF (GENCAL_CMD == 1)
 149  56B9               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
   1+ 56B9               IF (1 == 1)
   2+ 56B9              ; *******************************************************************************************************
   3+ 56B9              ; same as GENCAL but for DEFUSR approach
   4+ 56B9              ; input IX=pointer to input array, real data from +2
   5+ 56B9              ; +2 = function address to call
   6+ 56B9              ; +4 = register list array pointer
   7+ 56B9              GENCAL_DEFUSR:
   8+ 56B9 DD 6E 02         LD L,(IX+2)
   9+ 56BC DD 66 03         LD H,(IX+3)
  10+ 56BF E5               PUSH HL
  11+ 56C0 DD 6E 04         LD L,(IX+4)
  12+ 56C3 DD 66 05         LD H,(IX+5)
  13+ 56C6 E5               PUSH HL
  14+ 56C7 18 00            JR GENCAL.COMMON
  15+ 56C9              ; *******************************************************************************************************
  16+ 56C9               ENDIF
  17+ 56C9
  18+ 56C9              ; *******************************************************************************************************
  19+ 56C9              ; function to handle CALL GENCAL basic extension
  20+ 56C9              ; GENCAL ( INT fn_addr, = address of the function to call
  21+ 56C9              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
  22+ 56C9              ; output values of registers will also be stored at reg_list_ptr
  23+ 56C9              GENCAL:
  24+ 56C9               IF (0 == 1)
  25+ 56C9 ~            	; opening (
  26+ 56C9 ~            	CALL CHKCHAR
  27+ 56C9 ~            	DB '('
  28+ 56C9 ~            	; get function address
  29+ 56C9 ~            	LD IX, FRMQNT
  30+ 56C9 ~            	CALL CALBAS
  31+ 56C9 ~            	PUSH DE
  32+ 56C9 ~            	; comma
  33+ 56C9 ~            	CALL CHKCHAR
  34+ 56C9 ~            	DB ','
  35+ 56C9 ~            	; get pointer to register list
  36+ 56C9 ~                LD A,2
  37+ 56C9 ~                LD B,1
  38+ 56C9 ~                LD DE,#0500
  39+ 56C9 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
  40+ 56C9 ~            	PUSH BC
  41+ 56C9 ~            	; ending )
  42+ 56C9 ~            	CALL CHKCHAR
  43+ 56C9 ~            	DB ')'
  44+ 56C9               ENDIF
  45+ 56C9              .COMMON:
  46+ 56C9              	; save BASIC token position
  47+ 56C9 E5           	PUSH HL
  48+ 56CA D9               EXX
  49+ 56CB E1           	POP HL ; HL'=next basic token
  50+ 56CC D9               EXX
  51+ 56CD
  52+ 56CD E1               POP HL ; get pointer to register values
  53+ 56CE F3           	DI
  54+ 56CF ED 73 0A 5D      LD (BLIT_STRUCT), SP
  55+ 56D3 F9               LD SP, HL
  56+ 56D4 F1               POP AF
  57+ 56D5 C1               POP BC
  58+ 56D6 D1               POP DE
  59+ 56D7 E1               POP HL
  60+ 56D8 DD E1            POP IX
  61+ 56DA FD E1            POP IY
  62+ 56DC D9               EXX
  63+ 56DD ED 73 0C 5D      LD (BLIT_STRUCT+2), SP
  64+ 56E1 ED 7B 0A 5D      LD SP, (BLIT_STRUCT)
  65+ 56E5 FB               EI
  66+ 56E6 D1               POP DE ; get function to call
  67+ 56E7 E5               PUSH HL
  68+ 56E8 CD 03 57         CALL .EXXDECALL
  69+ 56EB F3               DI
  70+ 56EC ED 73 0A 5D      LD (BLIT_STRUCT), SP
  71+ 56F0 ED 7B 0C 5D      LD SP, (BLIT_STRUCT+2)
  72+ 56F4 FD E5            PUSH IY
  73+ 56F6 DD E5            PUSH IX
  74+ 56F8 E5               PUSH HL
  75+ 56F9 D5               PUSH DE
  76+ 56FA C5               PUSH BC
  77+ 56FB F5               PUSH AF
  78+ 56FC ED 7B 0A 5D      LD SP, (BLIT_STRUCT)
  79+ 5700 FB               EI
  80+ 5701 E1               POP HL
  81+ 5702 C9           	RET
  82+ 5703
  83+ 5703              .EXXDECALL:
  84+ 5703 D5               PUSH DE
  85+ 5704 D9               EXX
  86+ 5705 C9               RET
  87+ 5706              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
 150  5706               ENDIF
 151  5706
 152  5706               IF (BOX_CMDS == 1)
 153  5706               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
   1+ 5706              ; *******************************************************************************************************
   2+ 5706              ; generic function to implement rectangle data copy
   3+ 5706              ; should be modified to call appropriate function for memory or vram
   4+ 5706              ; input IX=pointer to following structure
   5+ 5706              ; +00 source data pointer
   6+ 5706              ; +02 num bytes in a row
   7+ 5706              ; +04 number of rows
   8+ 5706              ; +06 source add-to value till next row
   9+ 5706              ; +08 destination address
  10+ 5706              ; +10 destination add-to value till next row
  11+ 5706              ; modifies AF, BC, DE, HL
  12+ 5706              RECTANGLE_COPY:
  13+ 5706 DD 6E 00     	LD L, (IX+0)
  14+ 5709 DD 66 01     	LD H, (IX+1) ; source address
  15+ 570C DD 5E 08     	LD E, (IX+8)
  16+ 570F DD 56 09     	LD D, (IX+9) ; destination
  17+ 5712 DD 46 04     	LD B, (IX+4) ; row number
  18+ 5715              .L1:
  19+ 5715 C5           	PUSH BC
  20+ 5716 E5           		PUSH HL
  21+ 5717 D5           			PUSH DE
  22+ 5718 DD 4E 02     				LD C, (IX+2)
  23+ 571B DD 46 03     				LD B, (IX+3) ; num bytes in a row
  24+ 571E              .CALL1:
  25+ 571E CD 00 00     				CALL 0 ; set destination address from DE
  26+ 5721              .CALL2:
  27+ 5721 CD 00 00     				CALL 0 ; copy data fn
  28+ 5724 E1           			POP HL
  29+ 5725 DD 4E 0A     			LD C, (IX+10)
  30+ 5728 DD 46 0B     			LD B, (IX+11) ; destination add-to
  31+ 572B 09           			ADD HL, BC
  32+ 572C EB           			EX DE, HL
  33+ 572D E1           		POP HL
  34+ 572E DD 4E 06     		LD C, (IX+6)
  35+ 5731 DD 46 07     		LD B, (IX+7) ; src add-to
  36+ 5734 09           		ADD HL, BC
  37+ 5735 C1           	POP BC
  38+ 5736 10 DD        	DJNZ .L1
  39+ 5738 C9           	RET
  40+ 5739              ; *******************************************************************************************************
  41+ 5739
  42+ 5739               IF (0 == 1)
  43+ 5739 ~            ; *******************************************************************************************************
  44+ 5739 ~            ; function to handle CALL BOXMEMCPY basic extension
  45+ 5739 ~            ; copies data with window like boundaries within ram
  46+ 5739 ~            ; BOXMEMCPY ( INT source data pointer,
  47+ 5739 ~            ;			  INT source number of bytes in a row,
  48+ 5739 ~            ;			  INT number of rows,
  49+ 5739 ~            ;			  INT source add-to value till next row,
  50+ 5739 ~            ; 			  INT destination pointer,
  51+ 5739 ~            ;			  INT destination add-to value till next row )
  52+ 5739 ~            ; request_data_ptr described in RECTANGLE_COPY
  53+ 5739 ~            ; will put ram in page 0 also, page 1 is already there
  54+ 5739 ~            BOXMEMCPY:
  55+ 5739 ~            	LD DE,BOXMEMCPY_COMMON
  56+ 5739 ~            	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
  57+ 5739 ~            	JP BOX_EXTENSION_PARAMS_COMMON
  58+ 5739               ENDIF
  59+ 5739
  60+ 5739               IF (1 == 1)
  61+ 5739              ; *******************************************************************************************************
  62+ 5739              ; same as BOXMEMCPY but for DEFUSR approach
  63+ 5739              ; input IX=pointer to input array, real data from +2
  64+ 5739              ; +02 = source data pointer
  65+ 5739              ; +04 = source number of bytes in a row
  66+ 5739              ; +06 = number of rows
  67+ 5739              ; +08 = source add-to value till next row
  68+ 5739              ; +10 = destination pointer
  69+ 5739              ; +12 = destination add-to value till next row
  70+ 5739              BOXMEMCPY_DEFUSR:
  71+ 5739 21 46 57     	LD HL,BOXMEMCPY_COMMON
  72+ 573C 22 5C 57     	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
  73+ 573F DD 23        	INC IX
  74+ 5741 DD 23        	INC IX
  75+ 5743 C3 59 57     	JP BOXCOMMON_DEFUSR
  76+ 5746               ENDIF
  77+ 5746
  78+ 5746              BOXMEMCPY_COMMON:
  79+ 5746 FB           	EI
  80+ 5747              	; set RAM functions to call
  81+ 5747 21 00 00     	LD HL, 0
  82+ 574A 22 1E 57     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
  83+ 574D 22 20 57     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
  84+ 5750 21 ED B0     	LD HL, #B0ED ; LDIR
  85+ 5753 22 22 57     	LD (RECTANGLE_COPY.CALL1+4), HL
  86+ 5756 C3 61 57     	JP BOXCOMMON_DEFUSR.CALL
  87+ 5759              ; *******************************************************************************************************
  88+ 5759
  89+ 5759               IF (0 == 1)
  90+ 5759 ~            ; *******************************************************************************************************
  91+ 5759 ~            ; common parts of BOX commands to load parameters
  92+ 5759 ~            BOX_EXTENSION_PARAMS_COMMON:
  93+ 5759 ~            	; opening (
  94+ 5759 ~            	CALL CHKCHAR
  95+ 5759 ~            	DB '('
  96+ 5759 ~            	; get source data pointer
  97+ 5759 ~            	LD IX, FRMQNT
  98+ 5759 ~            	CALL CALBAS
  99+ 5759 ~            	LD (BLIT_STRUCT+0), DE
 100+ 5759 ~            	; comma
 101+ 5759 ~            	CALL CHKCHAR
 102+ 5759 ~            	DB ','
 103+ 5759 ~            	; source number of bytes in a row
 104+ 5759 ~            	LD IX, FRMQNT
 105+ 5759 ~            	CALL CALBAS
 106+ 5759 ~            	LD (BLIT_STRUCT+2), DE
 107+ 5759 ~            	; comma
 108+ 5759 ~            	CALL CHKCHAR
 109+ 5759 ~            	DB ','
 110+ 5759 ~            	; number of rows
 111+ 5759 ~            	LD IX, FRMQNT
 112+ 5759 ~            	CALL CALBAS
 113+ 5759 ~            	LD (BLIT_STRUCT+4), DE
 114+ 5759 ~            	; comma
 115+ 5759 ~            	CALL CHKCHAR
 116+ 5759 ~            	DB ','
 117+ 5759 ~            	; source add-to value till next row
 118+ 5759 ~            	LD IX, FRMQNT
 119+ 5759 ~            	CALL CALBAS
 120+ 5759 ~            	LD (BLIT_STRUCT+6), DE
 121+ 5759 ~            	; comma
 122+ 5759 ~            	CALL CHKCHAR
 123+ 5759 ~            	DB ','
 124+ 5759 ~            	; destination pointer
 125+ 5759 ~            	LD IX, FRMQNT
 126+ 5759 ~            	CALL CALBAS
 127+ 5759 ~            	LD (BLIT_STRUCT+8), DE
 128+ 5759 ~            	; comma
 129+ 5759 ~            	CALL CHKCHAR
 130+ 5759 ~            	DB ','
 131+ 5759 ~            	; destination add-to value till next row
 132+ 5759 ~            	LD IX, FRMQNT
 133+ 5759 ~            	CALL CALBAS
 134+ 5759 ~            	LD (BLIT_STRUCT+10), DE
 135+ 5759 ~            	; ending )
 136+ 5759 ~            	CALL CHKCHAR
 137+ 5759 ~            	DB ')'
 138+ 5759 ~            	LD IX,BLIT_STRUCT
 139+ 5759               ENDIF
 140+ 5759              BOXCOMMON_DEFUSR:
 141+ 5759 E5           	PUSH HL ; save position in BASIC buffer
 142+ 575A              .ADDR:
 143+ 575A FD 21 00 00  	LD IY, 0 ; modified by code
 144+ 575E C3 34 5E     	JP ENABLE_PAGE0
 145+ 5761              .CALL:
 146+ 5761 CD 06 57     	CALL RECTANGLE_COPY
 147+ 5764 AF           	XOR A
 148+ 5765 32 1B 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 149+ 5768
 150+ 5768 D1               POP DE
 151+ 5769 C1               POP BC
 152+ 576A CD AB 5D         CALL RESTORE_PAGE_INFO
 153+ 576D
 154+ 576D E1           	POP HL
 155+ 576E C9           	RET
 156+ 576F              ; *******************************************************************************************************
 157+ 576F
 158+ 576F               IF (0 == 1)
 159+ 576F ~            ; *******************************************************************************************************
 160+ 576F ~            ; function to handle CALL BOXMEMVRM basic extension
 161+ 576F ~            ; copies data with window like boundaries from ram to Vram
 162+ 576F ~            ; BOXMEMVRM ( INT source data pointer,
 163+ 576F ~            ;			  INT source number of bytes in a row,
 164+ 576F ~            ;			  INT number of rows,
 165+ 576F ~            ;			  INT source add-to value till next row,
 166+ 576F ~            ; 			  INT destination pointer,
 167+ 576F ~            ;			  INT destination add-to value till next row )
 168+ 576F ~            ; request_data_ptr described in RECTANGLE_COPY
 169+ 576F ~            ; will put ram in page 0 also, page 1 is already there
 170+ 576F ~            BOXMEMVRM:
 171+ 576F ~            	LD DE,BOXMEMVRM_COMMON
 172+ 576F ~            	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
 173+ 576F ~            	JP BOX_EXTENSION_PARAMS_COMMON
 174+ 576F               ENDIF
 175+ 576F
 176+ 576F               IF (1 == 1)
 177+ 576F              ; *******************************************************************************************************
 178+ 576F              ; same as BOXMEMVRM but for DEFUSR approach
 179+ 576F              ; input IX=pointer to input array, real data from +2
 180+ 576F              ; +02 = source data pointer
 181+ 576F              ; +04 = source number of bytes in a row
 182+ 576F              ; +06 = number of rows
 183+ 576F              ; +08 = source add-to value till next row
 184+ 576F              ; +10 = destination pointer
 185+ 576F              ; +12 = destination add-to value till next row
 186+ 576F              BOXMEMVRM_DEFUSR:
 187+ 576F 21 7C 57     	LD HL,BOXMEMVRM_COMMON
 188+ 5772 22 5C 57     	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
 189+ 5775 DD 23        	INC IX
 190+ 5777 DD 23        	INC IX
 191+ 5779 C3 59 57     	JP BOXCOMMON_DEFUSR
 192+ 577C               ENDIF
 193+ 577C
 194+ 577C              BOXMEMVRM_COMMON:
 195+ 577C FB           	EI
 196+ 577D              	; set RAM functions to call
 197+ 577D 21 97 57     	LD HL, .SETDEST
 198+ 5780 22 1F 57     	LD (RECTANGLE_COPY.CALL1+1), HL
 199+ 5783 21 9F 57     	LD HL, .COPYDATA
 200+ 5786 22 22 57     	LD (RECTANGLE_COPY.CALL2+1), HL
 201+ 5789 3E CD        	LD A, #CD ; CALL
 202+ 578B 32 1E 57     	LD (RECTANGLE_COPY.CALL1), A
 203+ 578E 32 21 57     	LD (RECTANGLE_COPY.CALL2), A
 204+ 5791              	;LD A,1
 205+ 5791 32 1B 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 206+ 5794 C3 61 57     	JP BOXCOMMON_DEFUSR.CALL
 207+ 5797              .SETDEST:
 208+ 5797 EB           	EX DE, HL
 209+ 5798 F3           	DI
 210+ 5799 CD 5B 5D     	CALL SETWRT_LOCAL
 211+ 579C FB           	EI
 212+ 579D EB           	EX DE, HL
 213+ 579E C9           	RET
 214+ 579F              .COPYDATA:
 215+ 579F 41           	LD B, C
 216+ 57A0 C3 66 5D     	JP BBYTECOPY
 217+ 57A3              ; *******************************************************************************************************
# file closed: asm\BOX.asm
 154  57A3               ENDIF
 155  57A3
 156  57A3               IF (BLIT_CMDS == 1)
 157  57A3               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
   1+ 57A3              ; *******************************************************************************************************
   2+ 57A3              ; function rotates mask and data of several characters and applies to background data
   3+ 57A3              ; this handles x-shift from 0 to 4
   4+ 57A3              ; contains self-modifying code that is set-up from external function
   5+ 57A3              ; input HL=pointer to mask data
   6+ 57A3              ; input HL'=pointer to character data
   7+ 57A3              ; input DE=output buffer containing background data
   8+ 57A3              ; input BC=DE+8
   9+ 57A3              ; input A=number of characters to process
  10+ 57A3              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  11+ 57A3              SHIFT04:
  12+ 57A3 08           	EX AF, AF'
  13+ 57A4 7E           	LD A, (HL) ; get mask
  14+ 57A5 D9           	EXX
  15+ 57A6 57           	LD D, A
  16+ 57A7 1E FF        	LD E, #FF
  17+ 57A9 37           	SCF
  18+ 57AA              .M1:
  19+ 57AA 18 FE        	JR .M1 ; this is self-modifying part
  20+ 57AC CB 1A        	RR D
  21+ 57AE CB 1B        	RR E
  22+ 57B0 CB 1A        	RR D
  23+ 57B2 CB 1B        	RR E
  24+ 57B4 CB 1A        	RR D
  25+ 57B6 CB 1B        	RR E
  26+ 57B8 CB 1A        	RR D
  27+ 57BA CB 1B        	RR E
  28+ 57BC
  29+ 57BC 46           	LD B, (HL) ; get data
  30+ 57BD 0E 00        	LD C, 0
  31+ 57BF              .M2:
  32+ 57BF 18 FE        	JR .M2 ; also self-modifying part
  33+ 57C1 CB 38        	SRL B
  34+ 57C3 CB 19        	RR C
  35+ 57C5 CB 38        	SRL B
  36+ 57C7 CB 19        	RR C
  37+ 57C9 CB 38        	SRL B
  38+ 57CB CB 19        	RR C
  39+ 57CD CB 38        	SRL B
  40+ 57CF CB 19        	RR C
  41+ 57D1
  42+ 57D1 D9           	EXX
  43+ 57D2 1A           	LD A, (DE) ; background
  44+ 57D3 D9           	EXX
  45+ 57D4 A2           	AND D
  46+ 57D5 B0           	OR B
  47+ 57D6 D9           	EXX
  48+ 57D7 12           	LD (DE), A
  49+ 57D8
  50+ 57D8 0A           	LD A, (BC)
  51+ 57D9 D9           	EXX
  52+ 57DA A3           	AND E
  53+ 57DB B1           	OR C
  54+ 57DC 23           	INC HL
  55+ 57DD D9           	EXX
  56+ 57DE 02           	LD (BC), A
  57+ 57DF
  58+ 57DF 23           	INC HL
  59+ 57E0 13           	INC DE
  60+ 57E1 03           	INC BC
  61+ 57E2
  62+ 57E2 08           	EX AF, AF'
  63+ 57E3 3D           	DEC A
  64+ 57E4 C2 A3 57     	JP NZ, SHIFT04
  65+ 57E7 C9           	RET
  66+ 57E8              ; *******************************************************************************************************
  67+ 57E8
  68+ 57E8              ; *******************************************************************************************************
  69+ 57E8              ; function rotates mask and data of several characters and applies to background data
  70+ 57E8              ; this handles x-shift from 5 to 8
  71+ 57E8              ; contains self-modifying code that is set-up from external function
  72+ 57E8              ; input HL=pointer to mask data
  73+ 57E8              ; input HL'=pointer to character data
  74+ 57E8              ; input DE=output buffer containing background data
  75+ 57E8              ; input BC=DE+8
  76+ 57E8              ; input A=number of characters to process
  77+ 57E8              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  78+ 57E8              SHIFT58:
  79+ 57E8 08           	EX AF, AF'
  80+ 57E9 7E           	LD A, (HL) ; get mask
  81+ 57EA D9           	EXX
  82+ 57EB 57           	LD D, A
  83+ 57EC 1E FF        	LD E, #FF
  84+ 57EE 37           	SCF
  85+ 57EF              .M1:
  86+ 57EF 18 FE        	JR .M1 ; this is self-modifying part
  87+ 57F1 CB 12        	RL D
  88+ 57F3 CB 13        	RL E
  89+ 57F5 CB 12        	RL D
  90+ 57F7 CB 13        	RL E
  91+ 57F9 CB 12        	RL D
  92+ 57FB CB 13        	RL E
  93+ 57FD
  94+ 57FD 46           	LD B, (HL)
  95+ 57FE 0E 00        	LD C, 0
  96+ 5800              .M2:
  97+ 5800 18 FE        	JR .M2 ; also self-modifying part
  98+ 5802 CB 20        	SLA B
  99+ 5804 CB 11        	RL C
 100+ 5806 CB 20        	SLA B
 101+ 5808 CB 11        	RL C
 102+ 580A CB 20        	SLA B
 103+ 580C CB 11        	RL C
 104+ 580E
 105+ 580E D9           	EXX
 106+ 580F 1A           	LD A, (DE) ; background
 107+ 5810 D9           	EXX
 108+ 5811 A3           	AND E
 109+ 5812 B1           	OR C
 110+ 5813 D9           	EXX
 111+ 5814 12           	LD (DE), A
 112+ 5815
 113+ 5815 0A           	LD A, (BC)
 114+ 5816 D9           	EXX
 115+ 5817 A2           	AND D
 116+ 5818 B0           	OR B
 117+ 5819 23           	INC HL
 118+ 581A D9           	EXX
 119+ 581B 02           	LD (BC), A
 120+ 581C
 121+ 581C 23           	INC HL
 122+ 581D 13           	INC DE
 123+ 581E 03           	INC BC
 124+ 581F
 125+ 581F 08           	EX AF, AF'
 126+ 5820 3D           	DEC A
 127+ 5821 C2 E8 57     	JP NZ, SHIFT58
 128+ 5824 C9           	RET
 129+ 5825              ; *******************************************************************************************************
 130+ 5825
 131+ 5825              ; *******************************************************************************************************
 132+ 5825              ; routine that shifts one row of characters
 133+ 5825              ; contains self-modifying code that is set-up from external function
 134+ 5825              ; input HL=pointer to mask data
 135+ 5825              ; input HL'=pointer to character data
 136+ 5825              ; input DE=output buffer containing background data
 137+ 5825              ; input A=number of characters to process
 138+ 5825              ; input IX=pointer to structure describing input data
 139+ 5825              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 140+ 5825              SHIFT_ROW:
 141+ 5825 F5           	PUSH AF
 142+ 5826 ED 53 06 5D  		LD (BLIT_TMP1), DE
 143+ 582A E5           		PUSH HL
 144+ 582B CD 6E 58     			CALL .ADDYSHIFT
 145+ 582E E1           		POP HL
 146+ 582F ED 53 08 5D  		LD (BLIT_TMP2), DE ; DE+vertical shift
 147+ 5833              .L1:
 148+ 5833 3E 08        		LD A, 8
 149+ 5835 DD 96 02     		SUB (IX+2) ; y shift
 150+ 5838              .CALL1:
 151+ 5838 CD 00 00     		CALL 0
 152+ 583B DD 7E 02     		LD A, (IX+2); y shift
 153+ 583E B7           		OR A
 154+ 583F 28 26        		JR Z, .DONE
 155+ 5841 ED 5B 06 5D  		LD DE, (BLIT_TMP1)
 156+ 5845 E5           		PUSH HL
 157+ 5846 CD 7C 58     			CALL .DETONEXTROW
 158+ 5849 E1           		POP HL
 159+ 584A              .CALL2:
 160+ 584A CD 00 00     		CALL 0
 161+ 584D ED 5B 06 5D  		LD DE, (BLIT_TMP1)
 162+ 5851 E5           		PUSH HL
 163+ 5852 CD 76 58     			CALL .ADD8
 164+ 5855 E1           		POP HL
 165+ 5856 ED 53 06 5D  		LD (BLIT_TMP1), DE
 166+ 585A ED 5B 08 5D  		LD DE, (BLIT_TMP2)
 167+ 585E E5           		PUSH HL
 168+ 585F CD 76 58     			CALL .ADD8
 169+ 5862 E1           		POP HL
 170+ 5863 ED 53 08 5D  		LD (BLIT_TMP2), DE ; DE+vertical shift
 171+ 5867              .DONE:
 172+ 5867 F1           	POP AF
 173+ 5868 3D           	DEC A
 174+ 5869 C8           	RET Z
 175+ 586A F5           	PUSH AF
 176+ 586B C3 33 58     	JP .L1
 177+ 586E              .ADDYSHIFT:
 178+ 586E EB           	EX DE, HL
 179+ 586F 16 00        	LD D, 0
 180+ 5871 DD 5E 02     	LD E, (IX+2); y shift
 181+ 5874 18 0C        	JR .MOVDEBC
 182+ 5876              .ADD8:
 183+ 5876 21 08 00     	LD HL, 8
 184+ 5879 C3 82 58     	JP .MOVDEBC
 185+ 587C              .DETONEXTROW:
 186+ 587C DD 6E 06     	LD L, (IX+6)
 187+ 587F DD 66 07     	LD H, (IX+7) ; bkg add to value
 188+ 5882              .MOVDEBC:
 189+ 5882 19           	ADD HL, DE
 190+ 5883 54           	LD D, H
 191+ 5884 5D           	LD E, L
 192+ 5885 01 08 00     	LD BC, 8
 193+ 5888 09           	ADD HL, BC
 194+ 5889 44           	LD B, H
 195+ 588A 4D           	LD C, L
 196+ 588B C9           	RET
 197+ 588C              ; *******************************************************************************************************
 198+ 588C
 199+ 588C              ; *******************************************************************************************************
 200+ 588C              ; function rotates mask and character data and applies it to background
 201+ 588C              ; input IX=pointer to structure describing input data
 202+ 588C              ; +0  DW horizontal shift count 0-7 (low byte used)
 203+ 588C              ; +2  DW vertical shift count 0-7 (low byte used)
 204+ 588C              ; +4  DW background data start;
 205+ 588C              ; +6  DW background add to value to next row of background data
 206+ 588C              ; +8  DW mask data start;
 207+ 588C              ; +10  DW character data start;
 208+ 588C              ; +12 DW character&mask add to value to next row of data
 209+ 588C              ; +14 DW columns (low byte used)
 210+ 588C              ; +16 DW rows (low byte used)
 211+ 588C              SHIFT_MERGE_CHARACTER:
 212+ 588C DD 7E 00     	LD A, (IX) ; shift
 213+ 588F FE 05        	CP 5
 214+ 5891 38 25        	JR C, .RIGHT
 215+ 5893              	; shifts 5-7, use rotate towards left 1-3
 216+ 5893 21 E8 57     	LD HL, SHIFT58
 217+ 5896 22 39 58     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 218+ 5899 22 4B 58     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 219+ 589C D6 05        	SUB 5
 220+ 589E 28 0D        	JR Z, .L1
 221+ 58A0 87           	ADD A, A
 222+ 58A1 87           	ADD A, A
 223+ 58A2 67           	LD H, A
 224+ 58A3 2E 18        	LD L, #18 ; JR opcode
 225+ 58A5 22 EF 57     	LD (SHIFT58.M1), HL
 226+ 58A8 22 00 58     	LD (SHIFT58.M2), HL
 227+ 58AB 18 32        	JR .DO
 228+ 58AD              .L1:
 229+ 58AD 21 00 00     	LD HL, 0 ; 2xNOP opcode
 230+ 58B0 22 EF 57     	LD (SHIFT58.M1), HL
 231+ 58B3 22 00 58     	LD (SHIFT58.M2), HL
 232+ 58B6 18 27        	JR .DO
 233+ 58B8              .RIGHT:
 234+ 58B8              	; shifts 0-4, rotate towards right
 235+ 58B8 21 A3 57     	LD HL, SHIFT04
 236+ 58BB 22 39 58     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 237+ 58BE 22 4B 58     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 238+ 58C1 FE 04        	CP 4
 239+ 58C3 28 11        	JR Z, .R1
 240+ 58C5 D6 04        	SUB 4
 241+ 58C7 ED 44        	NEG
 242+ 58C9 87           	ADD A, A
 243+ 58CA 87           	ADD A, A
 244+ 58CB 67           	LD H, A
 245+ 58CC 2E 18        	LD L, #18 ; JR opcode
 246+ 58CE 22 AA 57     	LD (SHIFT04.M1), HL
 247+ 58D1 22 BF 57     	LD (SHIFT04.M2), HL
 248+ 58D4 18 09        	JR .DO
 249+ 58D6              .R1:
 250+ 58D6 21 00 00     	LD HL, 0 ; 2xNOP opcode
 251+ 58D9 22 AA 57     	LD (SHIFT04.M1), HL
 252+ 58DC 22 BF 57     	LD (SHIFT04.M2), HL
 253+ 58DF              .DO:
 254+ 58DF DD 46 10     	LD B, (IX+16) ; rows
 255+ 58E2 DD 6E 08     	LD L, (IX+8)
 256+ 58E5 DD 66 09     	LD H, (IX+9) ; mask data
 257+ 58E8 DD 5E 04     	LD E, (IX+4)
 258+ 58EB DD 56 05     	LD D, (IX+5) ; background data
 259+ 58EE D9           	EXX
 260+ 58EF DD 6E 0A     	LD L, (IX+10)
 261+ 58F2 DD 66 0B     	LD H, (IX+11) ; character data
 262+ 58F5 D9           	EXX
 263+ 58F6              .LOOP:
 264+ 58F6 C5           	PUSH BC
 265+ 58F7 E5           		PUSH HL
 266+ 58F8 D5           			PUSH DE
 267+ 58F9 D9           				EXX
 268+ 58FA E5           				PUSH HL
 269+ 58FB D9           					EXX
 270+ 58FC DD 7E 0E     					LD A, (IX+14) ; columns
 271+ 58FF              .CALL:
 272+ 58FF CD 25 58     					CALL SHIFT_ROW
 273+ 5902 E1           				POP HL
 274+ 5903 DD 5E 0C     				LD E, (IX+12)
 275+ 5906 DD 56 0D     				LD D, (IX+13) ; char data to next row
 276+ 5909 19           				ADD HL, DE
 277+ 590A D9           				EXX
 278+ 590B E1           			POP HL
 279+ 590C DD 5E 06     			LD E, (IX+6)
 280+ 590F DD 56 07     			LD D, (IX+7) ; background to next row
 281+ 5912 19           			ADD HL, DE
 282+ 5913 EB           			EX DE, HL
 283+ 5914 E1           		POP HL
 284+ 5915 DD 4E 0C     		LD C, (IX+12)
 285+ 5918 DD 46 0D     		LD B, (IX+13) ; char data to next row
 286+ 591B 09           		ADD HL, BC
 287+ 591C C1           	POP BC
 288+ 591D 10 D7        	DJNZ .LOOP
 289+ 591F C9           	RET
 290+ 5920              ; *******************************************************************************************************
 291+ 5920
 292+ 5920              ; *******************************************************************************************************
 293+ 5920              ; helper function DE \ 8
 294+ 5920              DEdiv8:
 295+ 5920 7B           	LD A,E
 296+ 5921 CB 2A        	SRA D
 297+ 5923 CB 1F            RR  A
 298+ 5925 CB 2A            SRA D
 299+ 5927 CB 1F            RR  A
 300+ 5929 CB 2A            SRA D
 301+ 592B CB 1F            RR  A
 302+ 592D C9           	RET
 303+ 592E              ; *******************************************************************************************************
 304+ 592E
 305+ 592E               IF (1 == 1)
 306+ 592E              ; *******************************************************************************************************
 307+ 592E              ; function to handle BLIT basic extension through DEFUSR call in RAW format
 308+ 592E              ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 309+ 592E              ; +2  DW horizontal shift count 0-7 (low byte used)
 310+ 592E              ; +4  DW vertical shift count 0-7 (low byte used)
 311+ 592E              ; +6  DW background data start;
 312+ 592E              ; +8  DW background add to value to next row of background data
 313+ 592E              ; +10  DW mask data start;
 314+ 592E              ; +12  DW character data start;
 315+ 592E              ; +14 DW character&mask add to value to next row of data
 316+ 592E              ; +16 DW columns (low byte used)
 317+ 592E              ; +18 DW rows (low byte used)
 318+ 592E              ; will put ram in page 0 also, page 1 is already there
 319+ 592E              ;BLIT_DEFUSR:
 320+ 592E              ;	DI
 321+ 592E              ;	LD IY, .RET
 322+ 592E              ;	JP ENABLE_PAGE0
 323+ 592E              ;.RET:
 324+ 592E              ;	EI
 325+ 592E              ;	INC IX
 326+ 592E              ;	INC IX
 327+ 592E              ;	CALL SHIFT_MERGE_CHARACTER
 328+ 592E              ;
 329+ 592E              ;   POP DE
 330+ 592E              ;    POP BC
 331+ 592E              ;    JP RESTORE_PAGE_INFO
 332+ 592E              ; *******************************************************************************************************
 333+ 592E
 334+ 592E              ; *******************************************************************************************************
 335+ 592E              ; function to handle CALL BLIT basic extension in DEFUSR form
 336+ 592E              ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 337+ 592E              ; +02 x
 338+ 592E              ; +04 y
 339+ 592E              ; +06 char_data_pointer
 340+ 592E              ; +08 mask_data_pointer
 341+ 592E              ; +10 width
 342+ 592E              ; +12 height
 343+ 592E              ; +14 background_pointer
 344+ 592E              ; +16 background_width
 345+ 592E              ; BLIT ( INT x,
 346+ 592E              ;		 INT y,
 347+ 592E              ;		 INT char_data_pointer,
 348+ 592E              ;		 INT mask_data_pointer,
 349+ 592E              ;		 INT width (in characters),
 350+ 592E              ;		 INT height (in characters),
 351+ 592E              ;		 INT background_pointer (top left),
 352+ 592E              ;		 INT background_width (in characters),
 353+ 592E              BLIT_DEFUSR:
 354+ 592E DD 5E 02     	LD E,(IX+2)
 355+ 5931 DD 56 03     	LD D,(IX+3)
 356+ 5934 7B           	LD A,E
 357+ 5935 E6 07        	AND 7
 358+ 5937 32 0A 5D     	LD (BLIT_STRUCT+0),A
 359+ 593A CD 20 59     	CALL DEdiv8
 360+ 593D 32 06 5D     	LD (BLIT_TMP+0),A
 361+ 5940 DD 5E 04     	LD E,(IX+4)
 362+ 5943 DD 56 05     	LD D,(IX+5)
 363+ 5946 7B           	LD A,E
 364+ 5947 E6 07        	AND 7
 365+ 5949 32 0C 5D     	LD (BLIT_STRUCT+2),A
 366+ 594C CD 20 59     	CALL DEdiv8
 367+ 594F 32 07 5D     	LD (BLIT_TMP+1),A
 368+ 5952 DD 6E 06     	LD L,(IX+6)
 369+ 5955 DD 66 07     	LD H,(IX+7)
 370+ 5958 22 14 5D     	LD (BLIT_STRUCT+10),HL
 371+ 595B DD 6E 08     	LD L,(IX+8)
 372+ 595E DD 66 09     	LD H,(IX+9)
 373+ 5961 22 12 5D     	LD (BLIT_STRUCT+8),HL
 374+ 5964 DD 7E 0A     	LD A,(IX+10)
 375+ 5967 32 18 5D     	LD (BLIT_STRUCT+14),A
 376+ 596A DD 7E 0C     	LD A,(IX+12)
 377+ 596D 32 1A 5D     	LD (BLIT_STRUCT+16),A
 378+ 5970 DD 6E 0E     	LD L,(IX+14)
 379+ 5973 DD 66 0F     	LD H,(IX+15)
 380+ 5976 22 0E 5D     	LD (BLIT_STRUCT+4),HL
 381+ 5979              	;LD A,(IX+16)
 382+ 5979              	;LD (BLIT_TMP+2),A
 383+ 5979
 384+ 5979              	; calculate char&mask add to value
 385+ 5979 26 00        	LD H,0
 386+ 597B 3A 18 5D     	LD A,(BLIT_STRUCT+14)
 387+ 597E 6F           	LD L,A
 388+ 597F CD 70 5D     	CALL HLx8
 389+ 5982 22 16 5D     	LD (BLIT_STRUCT+12),HL
 390+ 5985              	; calculate background add to value
 391+ 5985 26 00        	LD H,0
 392+ 5987 DD 6E 10     	LD L,(IX+16)
 393+ 598A CD 70 5D     	CALL HLx8
 394+ 598D 22 10 5D     	LD (BLIT_STRUCT+6),HL
 395+ 5990              	; calculate pointer to background location
 396+ 5990 21 00 00     	LD HL,0
 397+ 5993 3A 07 5D     	LD A,(BLIT_TMP+1)
 398+ 5996 B7           	OR A
 399+ 5997 28 08        	JR Z, .L1
 400+ 5999 47           	LD B,A
 401+ 599A ED 5B 10 5D  	LD DE,(BLIT_STRUCT+6)
 402+ 599E              .L0:
 403+ 599E 19           	ADD HL, DE
 404+ 599F 10 FD        	DJNZ .L0
 405+ 59A1              .L1:
 406+ 59A1 EB           	EX DE,HL
 407+ 59A2 26 00        	LD H,0
 408+ 59A4 3A 06 5D     	LD A,(BLIT_TMP+0)
 409+ 59A7 6F           	LD L,A
 410+ 59A8 CD 70 5D     	CALL HLx8
 411+ 59AB 19           	ADD HL,DE
 412+ 59AC ED 5B 0E 5D  	LD DE,(BLIT_STRUCT+4)
 413+ 59B0 19           	ADD HL,DE
 414+ 59B1 22 0E 5D     	LD (BLIT_STRUCT+4),HL
 415+ 59B4
 416+ 59B4 FD 21 BB 59  	LD IY, .RET
 417+ 59B8 C3 34 5E     	JP ENABLE_PAGE0
 418+ 59BB              .RET:
 419+ 59BB FB           	EI
 420+ 59BC DD 21 0A 5D  	LD IX, BLIT_STRUCT
 421+ 59C0 CD 8C 58     	CALL SHIFT_MERGE_CHARACTER
 422+ 59C3
 423+ 59C3 D1               POP DE
 424+ 59C4 C1               POP BC
 425+ 59C5 C3 AB 5D         JP RESTORE_PAGE_INFO
 426+ 59C8              ; *******************************************************************************************************
 427+ 59C8               ENDIF
 428+ 59C8
 429+ 59C8               IF (0 == 1)
 430+ 59C8 ~            ; *******************************************************************************************************
 431+ 59C8 ~            ; function to handle CALL BLIT basic extension
 432+ 59C8 ~            ; rotates 1-bit character drawing horizontally with mask and character data and
 433+ 59C8 ~            ; fuses with background data and applies vertical shift too
 434+ 59C8 ~            ; in form without pointers
 435+ 59C8 ~            ; BLIT ( INT x,
 436+ 59C8 ~            ;		 INT y,
 437+ 59C8 ~            ;		 INT char_data_pointer,
 438+ 59C8 ~            ;		 INT mask_data_pointer,
 439+ 59C8 ~            ;		 INT width (in characters),
 440+ 59C8 ~            ;		 INT height (in characters),
 441+ 59C8 ~            ;		 INT background_pointer (top left),
 442+ 59C8 ~            ;		 INT background_width (in characters),
 443+ 59C8 ~            ; will put ram in page 0 also, page 1 is already there
 444+ 59C8 ~            BLIT:
 445+ 59C8 ~            	; opening (
 446+ 59C8 ~            	CALL CHKCHAR
 447+ 59C8 ~            	DB '('
 448+ 59C8 ~            	; get x coordinate
 449+ 59C8 ~            	LD IX, FRMQNT
 450+ 59C8 ~            	CALL CALBAS
 451+ 59C8 ~            	LD A, E
 452+ 59C8 ~            	AND 7
 453+ 59C8 ~            	LD (BLIT_STRUCT+0), A
 454+ 59C8 ~            	CALL DEdiv8
 455+ 59C8 ~            	LD (BLIT_TMP+0),A
 456+ 59C8 ~            	; comma
 457+ 59C8 ~            	CALL CHKCHAR
 458+ 59C8 ~            	DB ','
 459+ 59C8 ~            	; get y coordinate
 460+ 59C8 ~            	LD IX, FRMQNT
 461+ 59C8 ~            	CALL CALBAS
 462+ 59C8 ~            	LD A, E
 463+ 59C8 ~            	AND 7
 464+ 59C8 ~            	LD (BLIT_STRUCT+2), A
 465+ 59C8 ~            	CALL DEdiv8
 466+ 59C8 ~            	LD (BLIT_TMP+1),A
 467+ 59C8 ~            	; comma
 468+ 59C8 ~            	CALL CHKCHAR
 469+ 59C8 ~            	DB ','
 470+ 59C8 ~            	; get char data pointer
 471+ 59C8 ~            	LD IX, FRMQNT
 472+ 59C8 ~            	CALL CALBAS
 473+ 59C8 ~            	LD (BLIT_STRUCT+10), DE
 474+ 59C8 ~            	; comma
 475+ 59C8 ~            	CALL CHKCHAR
 476+ 59C8 ~            	DB ','
 477+ 59C8 ~            	; get mask data pointer
 478+ 59C8 ~            	LD IX, FRMQNT
 479+ 59C8 ~            	CALL CALBAS
 480+ 59C8 ~            	LD (BLIT_STRUCT+8), DE
 481+ 59C8 ~            	; comma
 482+ 59C8 ~            	CALL CHKCHAR
 483+ 59C8 ~            	DB ','
 484+ 59C8 ~            	; get width
 485+ 59C8 ~            	LD IX, FRMQNT
 486+ 59C8 ~            	CALL CALBAS
 487+ 59C8 ~            	LD A, E
 488+ 59C8 ~            	LD (BLIT_STRUCT+14), A
 489+ 59C8 ~            	; comma
 490+ 59C8 ~            	CALL CHKCHAR
 491+ 59C8 ~            	DB ','
 492+ 59C8 ~            	; get height
 493+ 59C8 ~            	LD IX, FRMQNT
 494+ 59C8 ~            	CALL CALBAS
 495+ 59C8 ~            	LD A, E
 496+ 59C8 ~            	LD (BLIT_STRUCT+16), A
 497+ 59C8 ~            	; comma
 498+ 59C8 ~            	CALL CHKCHAR
 499+ 59C8 ~            	DB ','
 500+ 59C8 ~            	; get background pointer
 501+ 59C8 ~            	LD IX, FRMQNT
 502+ 59C8 ~            	CALL CALBAS
 503+ 59C8 ~            	LD (BLIT_STRUCT+4), DE
 504+ 59C8 ~            	; comma
 505+ 59C8 ~            	CALL CHKCHAR
 506+ 59C8 ~            	DB ','
 507+ 59C8 ~            	; get background width
 508+ 59C8 ~            	LD IX, FRMQNT
 509+ 59C8 ~            	CALL CALBAS
 510+ 59C8 ~            	LD A, E
 511+ 59C8 ~            	LD (BLIT_TMP+2), A
 512+ 59C8 ~            	; ending )
 513+ 59C8 ~            	CALL CHKCHAR
 514+ 59C8 ~            	DB ')'
 515+ 59C8 ~
 516+ 59C8 ~            	PUSH HL ; save position in BASIC buffer
 517+ 59C8 ~
 518+ 59C8 ~            	; calculate char&mask add to value
 519+ 59C8 ~            	LD H, 0
 520+ 59C8 ~            	LD A, (BLIT_STRUCT+14)
 521+ 59C8 ~            	LD L, A
 522+ 59C8 ~            	CALL HLx8
 523+ 59C8 ~            	LD (BLIT_STRUCT+12), HL
 524+ 59C8 ~            	; calculate background add to value
 525+ 59C8 ~            	LD H, 0
 526+ 59C8 ~            	LD A, (BLIT_TMP+2)
 527+ 59C8 ~            	LD L, A
 528+ 59C8 ~            	CALL HLx8
 529+ 59C8 ~            	LD (BLIT_STRUCT+6), HL
 530+ 59C8 ~            	; calculate pointer to background location
 531+ 59C8 ~            	LD HL, 0
 532+ 59C8 ~            	LD A,(BLIT_TMP+1)
 533+ 59C8 ~            	OR A
 534+ 59C8 ~            	JR Z, .L1
 535+ 59C8 ~            	LD B,A
 536+ 59C8 ~            	LD DE,(BLIT_STRUCT+6)
 537+ 59C8 ~            .L0:
 538+ 59C8 ~            	ADD HL, DE
 539+ 59C8 ~            	DJNZ .L0
 540+ 59C8 ~            .L1:
 541+ 59C8 ~            	EX DE,HL
 542+ 59C8 ~            	LD H,0
 543+ 59C8 ~            	LD A,(BLIT_TMP+0)
 544+ 59C8 ~            	LD L,A
 545+ 59C8 ~            	CALL HLx8
 546+ 59C8 ~            	ADD HL,DE
 547+ 59C8 ~            	LD DE,(BLIT_STRUCT+4)
 548+ 59C8 ~            	ADD HL,DE
 549+ 59C8 ~            	LD (BLIT_STRUCT+4),HL
 550+ 59C8 ~
 551+ 59C8 ~            	LD IY, .RET
 552+ 59C8 ~            	JP ENABLE_PAGE0
 553+ 59C8 ~            .RET:
 554+ 59C8 ~            	EI
 555+ 59C8 ~            	LD IX, BLIT_STRUCT
 556+ 59C8 ~            	CALL SHIFT_MERGE_CHARACTER
 557+ 59C8 ~
 558+ 59C8 ~                POP DE
 559+ 59C8 ~                POP BC
 560+ 59C8 ~                CALL RESTORE_PAGE_INFO
 561+ 59C8 ~
 562+ 59C8 ~            	POP HL
 563+ 59C8 ~            	RET
 564+ 59C8 ~            ; *******************************************************************************************************
 565+ 59C8               ENDIF
# file closed: asm\BLIT.asm
 158  59C8               ENDIF
 159  59C8
 160  59C8               IF (TILE_CMDS == 1)
 161  59C8               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
   1+ 59C8              ; *******************************************************************************************************
   2+ 59C8              ; generic function to implement tiling
   3+ 59C8              ; should be modified to call appropriate function for memory or vram
   4+ 59C8              ; input IX=pointer to following structure
   5+ 59C8              ; +00 tile_data_ptr
   6+ 59C8              ; +02 tile_rows
   7+ 59C8              ; +04 tile_columns
   8+ 59C8              ; +06 destination_address
   9+ 59C8              ; +08 dest_to_next_row_add_to_value
  10+ 59C8              ; +10 num_horizontal_tiles
  11+ 59C8              ; +12 num_vertical_tiles
  12+ 59C8              ; modifies AF, BC, DE, HL
  13+ 59C8              TILE:
  14+ 59C8 DD 6E 06     	LD L, (IX+6)
  15+ 59CB DD 66 07     	LD H, (IX+7) ; destination address
  16+ 59CE 22 06 5D     	LD (TILETMP1), HL
  17+ 59D1 DD 46 0C     	LD B, (IX+12) ; vertical tile number
  18+ 59D4              .L1:
  19+ 59D4 C5           	PUSH BC
  20+ 59D5 DD 6E 00     		LD L, (IX+0)
  21+ 59D8 DD 66 01     		LD H, (IX+1) ; tile address
  22+ 59DB 22 08 5D     		LD (TILETMP2), HL
  23+ 59DE DD 46 02     		LD B, (IX+2) ; tile rows
  24+ 59E1              .L2:
  25+ 59E1 C5           		PUSH BC
  26+ 59E2 CD 00 00     .CALL1:		CALL 0
  27+ 59E5 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
  28+ 59E8              .L3:
  29+ 59E8 C5           			PUSH BC
  30+ 59E9 2A 08 5D     				LD HL, (TILETMP2)
  31+ 59EC DD 46 04     				LD B, (IX+4) ; tile columns
  32+ 59EF              .L4:
  33+ 59EF C5           				PUSH BC
  34+ 59F0              .CALL2:
  35+ 59F0 CD 00 00     					CALL 0
  36+ 59F3 C1           				POP BC
  37+ 59F4 10 F9        				DJNZ .L4
  38+ 59F6 C1           			POP BC
  39+ 59F7 10 EF        			DJNZ .L3
  40+ 59F9 22 08 5D     			LD (TILETMP2), HL
  41+ 59FC 2A 06 5D     			LD HL, (TILETMP1)
  42+ 59FF DD 5E 08     			LD E, (IX+8)
  43+ 5A02 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
  44+ 5A05 19           			ADD HL, DE
  45+ 5A06 22 06 5D     			LD (TILETMP1), HL
  46+ 5A09 C1           		POP BC
  47+ 5A0A 10 D5        		DJNZ .L2
  48+ 5A0C C1           	POP BC
  49+ 5A0D 10 C5        	DJNZ .L1
  50+ 5A0F C9           	RET
  51+ 5A10              ; *******************************************************************************************************
  52+ 5A10
  53+ 5A10               IF (1 == 1)
  54+ 5A10              ; *******************************************************************************************************
  55+ 5A10              ; same as TILERAM but for DEFUSR approach
  56+ 5A10              ; input IX=pointer to input array, real data from +2
  57+ 5A10              ; +02 = tile data pointer
  58+ 5A10              ; +04 = tile columns
  59+ 5A10              ; +06 = tile rows
  60+ 5A10              ; +08 = destination pointer
  61+ 5A10              ; +10 = destination columns
  62+ 5A10              ; +12 = destination rows
  63+ 5A10              ; +14 = destination begin column
  64+ 5A10              ; +16 = destination begin row
  65+ 5A10              ; +18 = number of tiles horizontally
  66+ 5A10              ; +20 = number of tiles vertically
  67+ 5A10              ; *******************************************************************************************************
  68+ 5A10              TILERAM_DEFUSR:
  69+ 5A10              	; tile data pointer
  70+ 5A10 DD 6E 02     	LD L,(IX+2)
  71+ 5A13 DD 66 03     	LD H,(IX+3)
  72+ 5A16 22 0A 5D     	LD (BLIT_STRUCT+0),HL
  73+ 5A19              	; tile columns
  74+ 5A19 DD 6E 04     	LD L,(IX+4)
  75+ 5A1C DD 66 05     	LD H,(IX+5)
  76+ 5A1F 22 0E 5D     	LD (BLIT_STRUCT+4),HL
  77+ 5A22              	; tile rows
  78+ 5A22 DD 6E 06     	LD L,(IX+6)
  79+ 5A25 DD 66 07     	LD H,(IX+7)
  80+ 5A28 22 0C 5D     	LD (BLIT_STRUCT+2),HL
  81+ 5A2B              	; destintion pointer
  82+ 5A2B DD 6E 08     	LD L,(IX+8)
  83+ 5A2E DD 66 09     	LD H,(IX+9)
  84+ 5A31 22 10 5D     	LD (BLIT_STRUCT+6),HL
  85+ 5A34              	; destination columns
  86+ 5A34 DD 7E 0A     	LD A,(IX+10)
  87+ 5A37 32 06 5D     	LD (BLIT_TMP+0),A
  88+ 5A3A              	; destination rows
  89+ 5A3A DD 7E 0C     	LD A,(IX+12)
  90+ 5A3D 32 07 5D     	LD (BLIT_TMP+1),A
  91+ 5A40              	; destination begin column
  92+ 5A40 DD 7E 0E     	LD A,(IX+14)
  93+ 5A43 32 08 5D     	LD (BLIT_TMP+2),A
  94+ 5A46              	; destination begin row
  95+ 5A46 DD 7E 10     	LD A,(IX+16)
  96+ 5A49 32 09 5D     	LD (BLIT_TMP+3),A
  97+ 5A4C              	; number of tiles horizontally
  98+ 5A4C DD 6E 12     	LD L,(IX+18)
  99+ 5A4F DD 66 13     	LD H,(IX+19)
 100+ 5A52 22 14 5D     	LD (BLIT_STRUCT+10),HL
 101+ 5A55              	; number of tiles vertically
 102+ 5A55 DD 6E 14     	LD L,(IX+20)
 103+ 5A58 DD 66 15     	LD H,(IX+21)
 104+ 5A5B 22 16 5D     	LD (BLIT_STRUCT+12),HL
 105+ 5A5E               IF (0 == 1) ; otherwise we just continue with code below
 106+ 5A5E ~            	JP TILERAM.COMMON
 107+ 5A5E               ENDIF
 108+ 5A5E               ENDIF
 109+ 5A5E
 110+ 5A5E              ; *******************************************************************************************************
 111+ 5A5E              ; function to handle CALL TILERAM basic extension
 112+ 5A5E              ; fills memory with tiles
 113+ 5A5E              ; TILERAM ( INT tile_data_pointer,
 114+ 5A5E              ;			INT tile_columns,
 115+ 5A5E              ;			INT tile_rows,
 116+ 5A5E              ;			INT destination_pointer,
 117+ 5A5E              ;			INT destination_columns,
 118+ 5A5E              ;			INT destination_rows,
 119+ 5A5E              ;			INT destination_begin_column,
 120+ 5A5E              ;			INT destination_begin_row,
 121+ 5A5E              ;			INT number_of_tiles_horizontally,
 122+ 5A5E              ;			INT	number_of_tiles_vertically )
 123+ 5A5E              ; will put ram in page 0 also, page 1 is already there
 124+ 5A5E              TILERAM:
 125+ 5A5E               IF (0 == 1)
 126+ 5A5E ~            	; opening (
 127+ 5A5E ~            	CALL CHKCHAR
 128+ 5A5E ~            	DB '('
 129+ 5A5E ~            	; get tile data pointer coordinate
 130+ 5A5E ~            	LD IX, FRMQNT
 131+ 5A5E ~            	CALL CALBAS
 132+ 5A5E ~            	LD (BLIT_STRUCT+0), DE
 133+ 5A5E ~            	; comma
 134+ 5A5E ~            	CALL CHKCHAR
 135+ 5A5E ~            	DB ','
 136+ 5A5E ~            	; get tile columns
 137+ 5A5E ~            	LD IX, FRMQNT
 138+ 5A5E ~            	CALL CALBAS
 139+ 5A5E ~            	LD (BLIT_STRUCT+4), DE
 140+ 5A5E ~            	; comma
 141+ 5A5E ~            	CALL CHKCHAR
 142+ 5A5E ~            	DB ','
 143+ 5A5E ~            	; get tile columns
 144+ 5A5E ~            	LD IX, FRMQNT
 145+ 5A5E ~            	CALL CALBAS
 146+ 5A5E ~            	LD (BLIT_STRUCT+2), DE
 147+ 5A5E ~            	; comma
 148+ 5A5E ~            	CALL CHKCHAR
 149+ 5A5E ~            	DB ','
 150+ 5A5E ~            	; get destintion pointer
 151+ 5A5E ~            	LD IX, FRMQNT
 152+ 5A5E ~            	CALL CALBAS
 153+ 5A5E ~            	LD (BLIT_STRUCT+6), DE
 154+ 5A5E ~            	; comma
 155+ 5A5E ~            	CALL CHKCHAR
 156+ 5A5E ~            	DB ','
 157+ 5A5E ~            	; get destination columns
 158+ 5A5E ~            	LD IX, FRMQNT
 159+ 5A5E ~            	CALL CALBAS
 160+ 5A5E ~            	LD A, E
 161+ 5A5E ~            	LD (BLIT_TMP+0), A
 162+ 5A5E ~            	; comma
 163+ 5A5E ~            	CALL CHKCHAR
 164+ 5A5E ~            	DB ','
 165+ 5A5E ~            	; get destination rows
 166+ 5A5E ~            	LD IX, FRMQNT
 167+ 5A5E ~            	CALL CALBAS
 168+ 5A5E ~            	LD A, E
 169+ 5A5E ~            	LD (BLIT_TMP+1), A
 170+ 5A5E ~            	; comma
 171+ 5A5E ~            	CALL CHKCHAR
 172+ 5A5E ~            	DB ','
 173+ 5A5E ~            	; get destination begin column
 174+ 5A5E ~            	LD IX, FRMQNT
 175+ 5A5E ~            	CALL CALBAS
 176+ 5A5E ~            	LD A, E
 177+ 5A5E ~            	LD (BLIT_TMP+2), A
 178+ 5A5E ~            	; comma
 179+ 5A5E ~            	CALL CHKCHAR
 180+ 5A5E ~            	DB ','
 181+ 5A5E ~            	; get destination begin row
 182+ 5A5E ~            	LD IX, FRMQNT
 183+ 5A5E ~            	CALL CALBAS
 184+ 5A5E ~            	LD A, E
 185+ 5A5E ~            	LD (BLIT_TMP+3), A
 186+ 5A5E ~            	; comma
 187+ 5A5E ~            	CALL CHKCHAR
 188+ 5A5E ~            	DB ','
 189+ 5A5E ~            	; get number of tiles horizontally
 190+ 5A5E ~            	LD IX, FRMQNT
 191+ 5A5E ~            	CALL CALBAS
 192+ 5A5E ~            	LD (BLIT_STRUCT+10), DE
 193+ 5A5E ~            	; comma
 194+ 5A5E ~            	CALL CHKCHAR
 195+ 5A5E ~            	DB ','
 196+ 5A5E ~            	; get number of tiles vertically
 197+ 5A5E ~            	LD IX, FRMQNT
 198+ 5A5E ~            	CALL CALBAS
 199+ 5A5E ~            	LD (BLIT_STRUCT+12), DE
 200+ 5A5E ~            	; ending )
 201+ 5A5E ~            	CALL CHKCHAR
 202+ 5A5E ~            	DB ')'
 203+ 5A5E               ENDIF
 204+ 5A5E              .COMMON:
 205+ 5A5E E5           	PUSH HL ; save position in BASIC buffer
 206+ 5A5F
 207+ 5A5F              	; calculate destination add to value
 208+ 5A5F 26 00        	LD H, 0
 209+ 5A61 3A 06 5D     	LD A, (BLIT_TMP+0)
 210+ 5A64 6F           	LD L, A
 211+ 5A65 CD 70 5D     	CALL HLx8
 212+ 5A68 22 12 5D     	LD (BLIT_STRUCT+8), HL
 213+ 5A6B              	; calculate pointer to background location
 214+ 5A6B 21 00 00     	LD HL, 0
 215+ 5A6E 3A 09 5D     	LD A,(BLIT_TMP+3)
 216+ 5A71 B7           	OR A
 217+ 5A72 28 08        	JR Z, .L1
 218+ 5A74 47           	LD B,A
 219+ 5A75 ED 5B 12 5D  	LD DE,(BLIT_STRUCT+8)
 220+ 5A79              .L0:
 221+ 5A79 19           	ADD HL, DE
 222+ 5A7A 10 FD        	DJNZ .L0
 223+ 5A7C              .L1:
 224+ 5A7C EB           	EX DE,HL
 225+ 5A7D 26 00        	LD H,0
 226+ 5A7F 3A 08 5D     	LD A,(BLIT_TMP+2)
 227+ 5A82 6F           	LD L,A
 228+ 5A83 CD 70 5D     	CALL HLx8
 229+ 5A86 19           	ADD HL,DE
 230+ 5A87 ED 5B 10 5D  	LD DE,(BLIT_STRUCT+6)
 231+ 5A8B 19           	ADD HL,DE
 232+ 5A8C 22 10 5D     	LD (BLIT_STRUCT+6),HL
 233+ 5A8F FD 21 96 5A  	LD IY, .RET
 234+ 5A93 C3 34 5E     	JP ENABLE_PAGE0
 235+ 5A96              .RET:
 236+ 5A96 FB           	EI
 237+ 5A97              	; set RAM functions to call
 238+ 5A97 21 B1 5A     	LD HL, .TILECOPY
 239+ 5A9A 22 F1 59     	LD (TILE.CALL2+1), HL
 240+ 5A9D 21 C2 5A     	LD HL, .SETDESTROW
 241+ 5AA0 22 E3 59     	LD (TILE.CALL1+1), HL
 242+ 5AA3 DD 21 0A 5D  	LD IX,BLIT_STRUCT
 243+ 5AA7 CD C8 59     	CALL TILE
 244+ 5AAA
 245+ 5AAA D1               POP DE
 246+ 5AAB C1               POP BC
 247+ 5AAC CD AB 5D         CALL RESTORE_PAGE_INFO
 248+ 5AAF
 249+ 5AAF E1           	POP HL
 250+ 5AB0 C9           	RET
 251+ 5AB1              .TILECOPY:
 252+ 5AB1 ED A0       > LDI
 252+ 5AB3 ED A0       > LDI
 252+ 5AB5 ED A0       > LDI
 252+ 5AB7 ED A0       > LDI
 252+ 5AB9 ED A0       > LDI
 252+ 5ABB ED A0       > LDI
 252+ 5ABD ED A0       > LDI
 252+ 5ABF ED A0       > LDI
 253+ 5AC1 C9           	RET
 254+ 5AC2              .SETDESTROW:
 255+ 5AC2 ED 5B 06 5D  	LD DE, (TILETMP1)
 256+ 5AC6 C9           	RET
 257+ 5AC7              ; *******************************************************************************************************
 258+ 5AC7
 259+ 5AC7               IF (1 == 1)
 260+ 5AC7              ; *******************************************************************************************************
 261+ 5AC7              ; same as TILEVRM but for DEFUSR approach
 262+ 5AC7              ; input IX=pointer to input array, real data from +2
 263+ 5AC7              ; +02 = tile data pointer
 264+ 5AC7              ; +04 = tile columns
 265+ 5AC7              ; +06 = tile rows
 266+ 5AC7              ; +08 = destination begin column
 267+ 5AC7              ; +10 = destination begin row
 268+ 5AC7              ; +12 = number of tiles horizontally
 269+ 5AC7              ; +14 = number of tiles vertically
 270+ 5AC7              ; *******************************************************************************************************
 271+ 5AC7              TILEVRM_DEFUSR:
 272+ 5AC7              	; tile data pointer
 273+ 5AC7 DD 6E 02     	LD L,(IX+2)
 274+ 5ACA DD 66 03     	LD H,(IX+3)
 275+ 5ACD 22 0A 5D     	LD (BLIT_STRUCT+0),HL
 276+ 5AD0              	; tile columns
 277+ 5AD0 DD 6E 04     	LD L,(IX+4)
 278+ 5AD3 DD 66 05     	LD H,(IX+5)
 279+ 5AD6 22 0E 5D     	LD (BLIT_STRUCT+4),HL
 280+ 5AD9              	; tile rows
 281+ 5AD9 DD 6E 06     	LD L,(IX+6)
 282+ 5ADC DD 66 07     	LD H,(IX+7)
 283+ 5ADF 22 0C 5D     	LD (BLIT_STRUCT+2),HL
 284+ 5AE2              	; destination begin column
 285+ 5AE2 DD 7E 08     	LD A,(IX+8)
 286+ 5AE5 32 08 5D     	LD (BLIT_TMP+2),A
 287+ 5AE8              	; destination begin row
 288+ 5AE8 DD 7E 0A     	LD A,(IX+10)
 289+ 5AEB 32 09 5D     	LD (BLIT_TMP+3),A
 290+ 5AEE              	; number of tiles horizontally
 291+ 5AEE DD 6E 0C     	LD L,(IX+12)
 292+ 5AF1 DD 66 0D     	LD H,(IX+13)
 293+ 5AF4 22 14 5D     	LD (BLIT_STRUCT+10),HL
 294+ 5AF7              	; number of tiles vertically
 295+ 5AF7 DD 6E 0E     	LD L,(IX+14)
 296+ 5AFA DD 66 0F     	LD H,(IX+15)
 297+ 5AFD 22 16 5D     	LD (BLIT_STRUCT+12),HL
 298+ 5B00               IF (0 == 1) ; otherwise we just continue with code below
 299+ 5B00 ~            	JP TILEVRM.COMMON
 300+ 5B00               ENDIF
 301+ 5B00               ENDIF
 302+ 5B00
 303+ 5B00              ; *******************************************************************************************************
 304+ 5B00              ; function to handle CALL TILEVRM basic extension
 305+ 5B00              ; fills vram with tiles
 306+ 5B00              ; TILEVRM ( INT tile_data_pointer,
 307+ 5B00              ;			INT tile_columns,
 308+ 5B00              ;			INT tile_rows,
 309+ 5B00              ;			INT destination_begin_column,
 310+ 5B00              ;			INT destination_begin_row,
 311+ 5B00              ;			INT number_of_tiles_horizontally,
 312+ 5B00              ;			INT	number_of_tiles_vertically )
 313+ 5B00              ; will put ram in page 0 also, page 1 is already there
 314+ 5B00              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
 315+ 5B00              TILEVRM:
 316+ 5B00               IF (0 == 1)
 317+ 5B00 ~            	; opening (
 318+ 5B00 ~            	CALL CHKCHAR
 319+ 5B00 ~            	DB '('
 320+ 5B00 ~            	; get tile data pointer coordinate
 321+ 5B00 ~            	LD IX, FRMQNT
 322+ 5B00 ~            	CALL CALBAS
 323+ 5B00 ~            	LD (BLIT_STRUCT+0), DE
 324+ 5B00 ~            	; comma
 325+ 5B00 ~            	CALL CHKCHAR
 326+ 5B00 ~            	DB ','
 327+ 5B00 ~            	; get tile columns
 328+ 5B00 ~            	LD IX, FRMQNT
 329+ 5B00 ~            	CALL CALBAS
 330+ 5B00 ~            	LD (BLIT_STRUCT+4), DE
 331+ 5B00 ~            	; comma
 332+ 5B00 ~            	CALL CHKCHAR
 333+ 5B00 ~            	DB ','
 334+ 5B00 ~            	; get tile columns
 335+ 5B00 ~            	LD IX, FRMQNT
 336+ 5B00 ~            	CALL CALBAS
 337+ 5B00 ~            	LD (BLIT_STRUCT+2), DE
 338+ 5B00 ~            	; comma
 339+ 5B00 ~            	CALL CHKCHAR
 340+ 5B00 ~            	DB ','
 341+ 5B00 ~            	; get destination begin column
 342+ 5B00 ~            	LD IX, FRMQNT
 343+ 5B00 ~            	CALL CALBAS
 344+ 5B00 ~            	LD A, E
 345+ 5B00 ~            	LD (BLIT_TMP+2), A
 346+ 5B00 ~            	; comma
 347+ 5B00 ~            	CALL CHKCHAR
 348+ 5B00 ~            	DB ','
 349+ 5B00 ~            	; get destination begin row
 350+ 5B00 ~            	LD IX, FRMQNT
 351+ 5B00 ~            	CALL CALBAS
 352+ 5B00 ~            	LD A, E
 353+ 5B00 ~            	LD (BLIT_TMP+3), A
 354+ 5B00 ~            	; comma
 355+ 5B00 ~            	CALL CHKCHAR
 356+ 5B00 ~            	DB ','
 357+ 5B00 ~            	; get number of tiles horizontally
 358+ 5B00 ~            	LD IX, FRMQNT
 359+ 5B00 ~            	CALL CALBAS
 360+ 5B00 ~            	LD (BLIT_STRUCT+10), DE
 361+ 5B00 ~            	; comma
 362+ 5B00 ~            	CALL CHKCHAR
 363+ 5B00 ~            	DB ','
 364+ 5B00 ~            	; get number of tiles vertically
 365+ 5B00 ~            	LD IX, FRMQNT
 366+ 5B00 ~            	CALL CALBAS
 367+ 5B00 ~            	LD (BLIT_STRUCT+12), DE
 368+ 5B00 ~            	; ending )
 369+ 5B00 ~            	CALL CHKCHAR
 370+ 5B00 ~            	DB ')'
 371+ 5B00               ENDIF
 372+ 5B00
 373+ 5B00              .COMMON:
 374+ 5B00 E5           	PUSH HL ; save position in BASIC buffer
 375+ 5B01
 376+ 5B01              	; calculate destination add to value
 377+ 5B01 21 00 01     	LD HL, 256
 378+ 5B04 22 12 5D     	LD (BLIT_STRUCT+8), HL
 379+ 5B07              	; calculate pointer to background location
 380+ 5B07 3A 09 5D     	LD A,(BLIT_TMP+3)
 381+ 5B0A 67           	LD H,A
 382+ 5B0B 2E 00        	LD L,0
 383+ 5B0D EB           	EX DE,HL
 384+ 5B0E 26 00        	LD H,0
 385+ 5B10 3A 08 5D     	LD A,(BLIT_TMP+2)
 386+ 5B13 6F           	LD L,A
 387+ 5B14 CD 70 5D     	CALL HLx8
 388+ 5B17 19           	ADD HL,DE
 389+ 5B18 ED 5B CB F3  	LD DE,(GRPCGP)
 390+ 5B1C 19           	ADD HL,DE
 391+ 5B1D 22 10 5D     	LD (BLIT_STRUCT+6),HL
 392+ 5B20 FD 21 27 5B  	LD IY, .RET
 393+ 5B24 C3 34 5E     	JP ENABLE_PAGE0
 394+ 5B27              .RET:
 395+ 5B27 FB           	EI
 396+ 5B28              	; set RAM functions to call
 397+ 5B28 21 42 5B     	LD HL, .TILECOPY
 398+ 5B2B 22 F1 59     	LD (TILE.CALL2+1), HL
 399+ 5B2E 21 48 5B     	LD HL, .SETDESTROW
 400+ 5B31 22 E3 59     	LD (TILE.CALL1+1), HL
 401+ 5B34 DD 21 0A 5D  	LD IX,BLIT_STRUCT
 402+ 5B38 CD C8 59     	CALL TILE
 403+ 5B3B
 404+ 5B3B D1               POP DE
 405+ 5B3C C1               POP BC
 406+ 5B3D CD AB 5D         CALL RESTORE_PAGE_INFO
 407+ 5B40
 408+ 5B40 E1           	POP HL
 409+ 5B41 C9           	RET
 410+ 5B42              .TILECOPY:
 411+ 5B42 01 98 08     	LD BC, #0898
 412+ 5B45 C3 68 5D     	JP BBYTECOPY_NO_C
 413+ 5B48              .SETDESTROW:
 414+ 5B48 2A 06 5D     	LD HL, (TILETMP1)
 415+ 5B4B F3           	DI
 416+ 5B4C CD 5B 5D     	CALL SETWRT_LOCAL
 417+ 5B4F FB           	EI
 418+ 5B50 C9           	RET
 419+ 5B51              ; *******************************************************************************************************
 420+ 5B51
# file closed: asm\TILE.asm
 162  5B51               ENDIF
 163  5B51
 164  5B51               IF (COLL_CMD == 1)
 165  5B51               INCLUDE "COLLISION.asm"
# file opened: asm\COLLISION.asm
   1+ 5B51              ; generic collision checking routines
   2+ 5B51              ; in BASIC we use rectangle structure array DIM R%(7,n) of the format
   3+ 5B51              ; R%(0,n) is active flag, <>0 active / 0 skipped in checks
   4+ 5B51              ; R%(1,n) is either upper left x coordinate or sprite id (0-31) depending on R(7,n)
   5+ 5B51              ; R%(2,n) is either upper left y coordinate or unused depending on R(7,n)
   6+ 5B51              ; R%(3,n) x offset where rectangle begins
   7+ 5B51              ; R%(4,n) y offset where rectangle begins
   8+ 5B51              ; R%(5,n) is width
   9+ 5B51              ; R%(6,n) is height
  10+ 5B51              ; R%(7,0) is type, 0=generic where R%(1,0) contains x coordinate
  11+ 5B51              ;                  <>0 sprite where R%(1,0) contains sprite id
  12+ 5B51              ; for type sprite, upper left coordinates are taken from sprite attribute array
  13+ 5B51
  14+ 5B51              ; ************************************************************************************************
  15+ 5B51              ; quick test if HL<=DE<=HL+BC
  16+ 5B51              ; input BC=width, DE=x, HL=min
  17+ 5B51              ; if not true flag C set
  18+ 5B51              ; modifies AF
  19+ 5B51              GENERIC_INNER_CHECK:
  20+ 5B51 E5               PUSH HL
  21+ 5B52 D5               PUSH DE
  22+ 5B53 EB               EX DE,HL
  23+ 5B54 A7               AND A
  24+ 5B55 ED 52            SBC HL, DE
  25+ 5B57 FA 65 5B         JP M, .GENERIC_INNER_CHECK_NOT
  26+ 5B5A A7               AND A
  27+ 5B5B ED 42            SBC HL, BC
  28+ 5B5D 28 03            JR Z, .L2
  29+ 5B5F F2 65 5B         JP P, .GENERIC_INNER_CHECK_NOT
  30+ 5B62              .L2:
  31+ 5B62 A7               AND A
  32+ 5B63 18 01            JR .EXIT
  33+ 5B65              .GENERIC_INNER_CHECK_NOT:
  34+ 5B65 37               SCF
  35+ 5B66              .EXIT:
  36+ 5B66 D1               POP DE
  37+ 5B67 E1               POP HL
  38+ 5B68 C9               RET
  39+ 5B69              ; ************************************************************************************************
  40+ 5B69
  41+ 5B69              ; ************************************************************************************************
  42+ 5B69              ; function to check if rectangles are overlapping
  43+ 5B69              ; input IX=IY=pointer to struct
  44+ 5B69              ;  +00 active flag
  45+ 5B69              ;  +02 x coordinate
  46+ 5B69              ;  +04 y coordinate
  47+ 5B69              ;  +06 x offset where rectangle begins
  48+ 5B69              ;  +08 y offset where rectangle begins
  49+ 5B69              ;  +10 width
  50+ 5B69              ;  +12 height
  51+ 5B69              ; where IY is used to read +2 and +4, and IX to read +6, +8, +10 and +12
  52+ 5B69              ; this is a hack to allow location being taken from sprite attributes table
  53+ 5B69              ; input BLIT_STRUCT data
  54+ 5B69              ;  +00 x coordinate
  55+ 5B69              ;  +02 y coordinate
  56+ 5B69              ;  +04 width
  57+ 5B69              ;  +06 height
  58+ 5B69              ; returns CF=1 if not overlapping, CF=0 if overlapping
  59+ 5B69              RECTANGLE_OVERLAP_CHECK:
  60+ 5B69                  ; first check which rectangle is higher
  61+ 5B69 DD 6E 0C         LD L,(IX+12)
  62+ 5B6C DD 66 0D         LD H,(IX+13)
  63+ 5B6F ED 5B 10 5D      LD DE,(BLIT_STRUCT+6)
  64+ 5B73 A7               AND A
  65+ 5B74 ED 52            SBC HL,DE
  66+ 5B76 FD 6E 04         LD L,(IY+4)
  67+ 5B79 FD 66 05         LD H,(IY+5)
  68+ 5B7C DD 5E 08         LD E,(IX+8)
  69+ 5B7F DD 56 09         LD D,(IX+9)
  70+ 5B82 FA A2 5B         JP M,.L1
  71+ 5B85                  ; equally high or IX defined one higher
  72+ 5B85                  ; check upper boundary
  73+ 5B85 19               ADD HL,DE
  74+ 5B86 ED 5B 0C 5D      LD DE,(BLIT_STRUCT+2)
  75+ 5B8A DD 4E 0C         LD C,(IX+12)
  76+ 5B8D DD 46 0D         LD B,(IX+13)
  77+ 5B90 CD 51 5B         CALL GENERIC_INNER_CHECK
  78+ 5B93 30 29            JR NC,.INSIDE
  79+ 5B95                  ; check lower boundary
  80+ 5B95 E5               PUSH HL
  81+ 5B96 2A 10 5D         LD HL,(BLIT_STRUCT+6)
  82+ 5B99 19               ADD HL,DE
  83+ 5B9A EB               EX DE,HL
  84+ 5B9B E1               POP HL
  85+ 5B9C CD 51 5B         CALL GENERIC_INNER_CHECK
  86+ 5B9F 30 1D            JR NC,.INSIDE
  87+ 5BA1 C9               RET ; not overlapping
  88+ 5BA2              .L1:
  89+ 5BA2                  ; rectangle defined in BLIT_STRUCT is higher
  90+ 5BA2 19               ADD HL,DE
  91+ 5BA3 EB               EX DE,HL
  92+ 5BA4 2A 0C 5D         LD HL,(BLIT_STRUCT+2)
  93+ 5BA7 ED 4B 10 5D      LD BC,(BLIT_STRUCT+6)
  94+ 5BAB CD 51 5B         CALL GENERIC_INNER_CHECK
  95+ 5BAE 30 0E            JR NC,.INSIDE
  96+ 5BB0 E5               PUSH HL
  97+ 5BB1 DD 6E 0C         LD L,(IX+12)
  98+ 5BB4 DD 66 0D         LD H,(IX+13)
  99+ 5BB7 19               ADD HL,DE
 100+ 5BB8 EB               EX DE,HL
 101+ 5BB9 E1               POP HL
 102+ 5BBA CD 51 5B         CALL GENERIC_INNER_CHECK
 103+ 5BBD D8               RET C
 104+ 5BBE              .INSIDE:
 105+ 5BBE                  ; check x coordinate
 106+ 5BBE                  ; first check which rectangle is wider
 107+ 5BBE DD 6E 0A         LD L,(IX+10)
 108+ 5BC1 DD 66 0B         LD H,(IX+11)
 109+ 5BC4 ED 5B 0E 5D      LD DE,(BLIT_STRUCT+4)
 110+ 5BC8 A7               AND A
 111+ 5BC9 ED 52            SBC HL,DE
 112+ 5BCB FD 6E 02         LD L,(IY+2)
 113+ 5BCE FD 66 03         LD H,(IY+3)
 114+ 5BD1 DD 5E 06         LD E,(IX+6)
 115+ 5BD4 DD 56 07         LD D,(IX+7)
 116+ 5BD7 FA F3 5B         JP M,.L2
 117+ 5BDA                  ; equally wide or IX defined one wider
 118+ 5BDA                  ; check left boundary
 119+ 5BDA 19               ADD HL,DE
 120+ 5BDB ED 5B 0A 5D      LD DE,(BLIT_STRUCT+0)
 121+ 5BDF DD 4E 0A         LD C,(IX+10)
 122+ 5BE2 DD 46 0B         LD B,(IX+11)
 123+ 5BE5 CD 51 5B         CALL GENERIC_INNER_CHECK
 124+ 5BE8 D0               RET NC ; overlap
 125+ 5BE9                  ; check right boundary
 126+ 5BE9 E5               PUSH HL
 127+ 5BEA 2A 0E 5D         LD HL,(BLIT_STRUCT+4)
 128+ 5BED 19               ADD HL,DE
 129+ 5BEE EB               EX DE,HL
 130+ 5BEF E1               POP HL
 131+ 5BF0 C3 51 5B         JP GENERIC_INNER_CHECK ; CF and result set by fn call
 132+ 5BF3              .L2:
 133+ 5BF3                  ; rectangle defined in BLIT_STRUCT is higher
 134+ 5BF3 19               ADD HL,DE
 135+ 5BF4 EB               EX DE,HL
 136+ 5BF5 2A 0A 5D         LD HL,(BLIT_STRUCT+0)
 137+ 5BF8 ED 4B 0E 5D      LD BC,(BLIT_STRUCT+4)
 138+ 5BFC CD 51 5B         CALL GENERIC_INNER_CHECK
 139+ 5BFF D0               RET NC ; overlap
 140+ 5C00 E5               PUSH HL
 141+ 5C01 DD 6E 0A         LD L,(IX+10)
 142+ 5C04 DD 66 0B         LD H,(IX+11)
 143+ 5C07 19               ADD HL,DE
 144+ 5C08 EB               EX DE,HL
 145+ 5C09 E1               POP HL
 146+ 5C0A C3 51 5B         JP GENERIC_INNER_CHECK
 147+ 5C0D              ; ************************************************************************************************
 148+ 5C0D
 149+ 5C0D              ; ************************************************************************************************
 150+ 5C0D              ; function tries to find rectangle overlap and returns an index if found
 151+ 5C0D              ; input BLIT_STRUCT data
 152+ 5C0D              ;  +00 x coordinate
 153+ 5C0D              ;  +02 y coordinate
 154+ 5C0D              ;  +04 width
 155+ 5C0D              ;  +06 height
 156+ 5C0D              ;  +08 number of items in a list, described under RECTANGLE_OVERLAP_CHECK
 157+ 5C0D              ;  +09 pointer to first element of R%(7,n)
 158+ 5C0D              ;  +11 pointer to INT result variable
 159+ 5C0D              ; returns CF=1 if not overlapping
 160+ 5C0D              ; returns A=list index and CF=0 if overlapping
 161+ 5C0D              FIND_OVERLAP:
 162+ 5C0D 3A 12 5D         LD A,(BLIT_STRUCT+8)
 163+ 5C10 47               LD B,A
 164+ 5C11 DD 2A 13 5D      LD IX,(BLIT_STRUCT+9)
 165+ 5C15              .L1:
 166+ 5C15 C5               PUSH BC
 167+ 5C16                  ; check active flag
 168+ 5C16 DD 7E 00         LD A,(IX)
 169+ 5C19 DD B6 01         OR (IX+1)
 170+ 5C1C 28 18            JR Z,.NEXT
 171+ 5C1E                  ; check type
 172+ 5C1E DD 7E 0E         LD A,(IX+14)
 173+ 5C21 DD B6 0F         OR (IX+15)
 174+ 5C24 20 1A            JR NZ,.L2
 175+ 5C26 DD E5            PUSH IX
 176+ 5C28 FD E1            POP IY
 177+ 5C2A              .L3:
 178+ 5C2A CD 69 5B         CALL RECTANGLE_OVERLAP_CHECK
 179+ 5C2D 38 07            JR C,.NEXT
 180+ 5C2F                  ; found
 181+ 5C2F C1               POP BC
 182+ 5C30 3A 12 5D         LD A,(BLIT_STRUCT+8)
 183+ 5C33 90               SUB B
 184+ 5C34 A7               AND A
 185+ 5C35 C9               RET
 186+ 5C36              .NEXT:
 187+ 5C36 11 10 00         LD DE,16
 188+ 5C39 DD 19            ADD IX,DE
 189+ 5C3B C1               POP BC
 190+ 5C3C 10 D7            DJNZ .L1
 191+ 5C3E 37               SCF
 192+ 5C3F C9               RET
 193+ 5C40              .L2:
 194+ 5C40                  ; sprite, need to build a temporary data struct since x and y values are inversed
 195+ 5C40                  ; at BLIT_STRUCT+13
 196+ 5C40 DD 7E 02         LD A,(IX+2) ; sprite ID
 197+ 5C43 CD 89 4D         CALL GETnthSPRATTR
 198+ 5C46 FD 21 15 5D      LD IY,BLIT_STRUCT+11
 199+ 5C4A 7E               LD A,(HL)
 200+ 5C4B FD 77 04         LD (IY+4),A
 201+ 5C4E 23               INC HL
 202+ 5C4F 7E               LD A,(HL)
 203+ 5C50 FD 77 05         LD (IY+5),A
 204+ 5C53 23               INC HL
 205+ 5C54 7E               LD A,(HL)
 206+ 5C55 FD 77 02         LD (IY+2),A
 207+ 5C58 23               INC HL
 208+ 5C59 7E               LD A,(HL)
 209+ 5C5A FD 77 03         LD (IY+3),A
 210+ 5C5D 18 CB            JR .L3
 211+ 5C5F              ; ************************************************************************************************
 212+ 5C5F
 213+ 5C5F               IF (0 == 1)
 214+ 5C5F ~            ; ************************************************************************************************
 215+ 5C5F ~            ; function to handle CALL COLL basic extension
 216+ 5C5F ~            ; checks for collision between player and other rectangles
 217+ 5C5F ~            ; COLL ( INT result variable,
 218+ 5C5F ~            ;	     INT player x value,
 219+ 5C5F ~            ;	     INT player y value,
 220+ 5C5F ~            ;	     INT player width,
 221+ 5C5F ~            ;	     INT player height,
 222+ 5C5F ~            ;	     INT number of items in a list,
 223+ 5C5F ~            ;		 INT[6][n] rectangle struct )
 224+ 5C5F ~            ; will fill result variable with index or -1 if no collision
 225+ 5C5F ~            ; rectangle struct described under RECTANGLE_OVERLAP_CHECK
 226+ 5C5F ~            COLL:
 227+ 5C5F ~            	; opening (
 228+ 5C5F ~            	CALL CHKCHAR
 229+ 5C5F ~            	DB '('
 230+ 5C5F ~            	; get address of result variable
 231+ 5C5F ~            	LD IX, PTRGET
 232+ 5C5F ~            	CALL CALBAS
 233+ 5C5F ~            	LD (BLIT_STRUCT+11),DE
 234+ 5C5F ~            	; comma
 235+ 5C5F ~            	CALL CHKCHAR
 236+ 5C5F ~            	DB ','
 237+ 5C5F ~            	; get x
 238+ 5C5F ~            	LD IX, FRMQNT
 239+ 5C5F ~            	CALL CALBAS
 240+ 5C5F ~            	LD (BLIT_STRUCT+0),DE
 241+ 5C5F ~            	; comma
 242+ 5C5F ~            	CALL CHKCHAR
 243+ 5C5F ~            	DB ','
 244+ 5C5F ~            	; get y
 245+ 5C5F ~            	LD IX, FRMQNT
 246+ 5C5F ~            	CALL CALBAS
 247+ 5C5F ~            	LD (BLIT_STRUCT+2),DE
 248+ 5C5F ~            	; comma
 249+ 5C5F ~            	CALL CHKCHAR
 250+ 5C5F ~            	DB ','
 251+ 5C5F ~            	; get width
 252+ 5C5F ~            	LD IX, FRMQNT
 253+ 5C5F ~            	CALL CALBAS
 254+ 5C5F ~            	LD (BLIT_STRUCT+4),DE
 255+ 5C5F ~            	; comma
 256+ 5C5F ~            	CALL CHKCHAR
 257+ 5C5F ~            	DB ','
 258+ 5C5F ~            	; get height
 259+ 5C5F ~            	LD IX, FRMQNT
 260+ 5C5F ~            	CALL CALBAS
 261+ 5C5F ~            	LD (BLIT_STRUCT+6),DE
 262+ 5C5F ~            	; comma
 263+ 5C5F ~            	CALL CHKCHAR
 264+ 5C5F ~            	DB ','
 265+ 5C5F ~            	; get number of items in a list
 266+ 5C5F ~            	LD IX, GETBYT
 267+ 5C5F ~            	CALL CALBAS
 268+ 5C5F ~            	LD (BLIT_STRUCT+8),A
 269+ 5C5F ~            	; comma
 270+ 5C5F ~            	CALL CHKCHAR
 271+ 5C5F ~            	DB ','
 272+ 5C5F ~            	; get address of rectangle structure array DIM R%(7,n)
 273+ 5C5F ~            	LD A,(BLIT_STRUCT+8)
 274+ 5C5F ~                LD E,A
 275+ 5C5F ~                LD A,2
 276+ 5C5F ~            	LD B,A
 277+ 5C5F ~            	LD D,7
 278+ 5C5F ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
 279+ 5C5F ~            	LD (BLIT_STRUCT+9),BC
 280+ 5C5F ~            	; ending )
 281+ 5C5F ~            	CALL CHKCHAR
 282+ 5C5F ~            	DB ')'
 283+ 5C5F ~
 284+ 5C5F ~                PUSH HL
 285+ 5C5F ~                CALL FIND_OVERLAP
 286+ 5C5F ~                LD HL,(BLIT_STRUCT+11)
 287+ 5C5F ~                JR C,.NOTFOUND
 288+ 5C5F ~                LD (HL),A
 289+ 5C5F ~                INC HL
 290+ 5C5F ~                LD (HL),0
 291+ 5C5F ~                POP HL
 292+ 5C5F ~                RET
 293+ 5C5F ~            .NOTFOUND:
 294+ 5C5F ~                LD (HL),#FF
 295+ 5C5F ~                INC HL
 296+ 5C5F ~                LD (HL),#FF
 297+ 5C5F ~                POP HL
 298+ 5C5F ~                RET
 299+ 5C5F ~            ; ************************************************************************************************
 300+ 5C5F               ENDIF
 301+ 5C5F
 302+ 5C5F               IF (1 == 1)
 303+ 5C5F              ; *******************************************************************************************************
 304+ 5C5F              ; same as COLL but for DEFUSR approach
 305+ 5C5F              ; input IX=pointer to input array, real data from +2
 306+ 5C5F              ; +02 = pointer to result variable
 307+ 5C5F              ; +04 = player X
 308+ 5C5F              ; +06 = player Y
 309+ 5C5F              ; +08 = player width
 310+ 5C5F              ; +10 = player height
 311+ 5C5F              ; +12 = number of list items
 312+ 5C5F              ; +14 = pointer to list of collidable objects
 313+ 5C5F              COLL_DEFUSR:
 314+ 5C5F DD E5            PUSH IX
 315+ 5C61 E1               POP HL
 316+ 5C62 23          > INC HL ; skip over to player x
 316+ 5C63 23          > INC HL
 316+ 5C64 23          > INC HL
 316+ 5C65 23          > INC HL
 317+ 5C66 11 0A 5D         LD DE,BLIT_STRUCT
 318+ 5C69 01 09 00         LD BC,9
 319+ 5C6C ED B0            LDIR ; copy over x,y,w,h,list item number
 320+ 5C6E DD 7E 0E         LD A,(IX+14)
 321+ 5C71 32 13 5D         LD (BLIT_STRUCT+9),A
 322+ 5C74 DD 7E 0F         LD A,(IX+15)
 323+ 5C77 32 14 5D         LD (BLIT_STRUCT+10),A ; address to collidable objects array
 324+ 5C7A DD 7E 02         LD A,(IX+2)
 325+ 5C7D 32 15 5D         LD (BLIT_STRUCT+11),A
 326+ 5C80 DD 7E 03         LD A,(IX+3)
 327+ 5C83 32 16 5D         LD (BLIT_STRUCT+12),A ; address to results variable
 328+ 5C86 DD E5            PUSH IX
 329+ 5C88 CD 0D 5C         CALL FIND_OVERLAP
 330+ 5C8B DD E1            POP IX
 331+ 5C8D DD 6E 02         LD L,(IX+2)
 332+ 5C90 DD 66 03         LD H,(IX+3)
 333+ 5C93 38 05            JR C,.NOTFOUND
 334+ 5C95 77               LD (HL),A
 335+ 5C96 23               INC HL
 336+ 5C97 36 00            LD (HL),0
 337+ 5C99 C9               RET
 338+ 5C9A              .NOTFOUND:
 339+ 5C9A 36 FF            LD (HL),#FF
 340+ 5C9C 23               INC HL
 341+ 5C9D 36 FF            LD (HL),#FF
 342+ 5C9F C9               RET
 343+ 5CA0              ; *******************************************************************************************************
 344+ 5CA0               ENDIF
 345+ 5CA0
# file closed: asm\COLLISION.asm
 166  5CA0               ENDIF
 167  5CA0
 168  5CA0               IF (1 == 1)
 169  5CA0               INCLUDE "DEFUSR.asm"
# file opened: asm\DEFUSR.asm
   1+ 5CA0              ; entry function that handles call using CALLF
   2+ 5CA0              ; pointer to data structure is expected at DAC+2
   3+ 5CA0              ; first entry must be function id followed by function specific parameters
   4+ 5CA0
   5+ 5CA0              DEFUSR_TABLE_ENTRIES    EQU 38
   6+ 5CA0
   7+ 5CA0              DEFUSR_JUMP_TABLE:
   8+ 5CA0               IF (SPRITE_CMDS == 1)
   9+ 5CA0 6E 4E         DW SPRENABLE_DEFUSR        ; 0
  10+ 5CA2               ELSE
  11+ 5CA2 ~             DW NOACTION_DEFUSR
  12+ 5CA2               ENDIF
  13+ 5CA2
  14+ 5CA2               IF (SPRITE_CMDS == 1)
  15+ 5CA2 92 4E         DW SPRDISABLE_DEFUSR        ; 1
  16+ 5CA4               ELSE
  17+ 5CA4 ~             DW NOACTION_DEFUSR
  18+ 5CA4               ENDIF
  19+ 5CA4
  20+ 5CA4               IF (RAM_CMDS == 1)
  21+ 5CA4 22 55         DW MEMCPY_DEFUSR           ; 2
  22+ 5CA6               ELSE
  23+ 5CA6 ~             DW NOACTION_DEFUSR
  24+ 5CA6               ENDIF
  25+ 5CA6
  26+ 5CA6               IF (VRAM_CMDS == 1)        ; 3
  27+ 5CA6 23 56         DW MEMVRM_DEFUSR
  28+ 5CA8               ELSE
  29+ 5CA8 ~             DW NOACTION_DEFUSR
  30+ 5CA8               ENDIF
  31+ 5CA8
  32+ 5CA8               IF (BLIT_CMDS == 1)        ; 4
  33+ 5CA8 2E 59         DW BLIT_DEFUSR
  34+ 5CAA               ELSE
  35+ 5CAA ~             DW NOACTION_DEFUSR
  36+ 5CAA               ENDIF
  37+ 5CAA
  38+ 5CAA               IF (ANIM_CMDS == 1)        ; 5
  39+ 5CAA FA 53         DW SGAM_DEFUSR
  40+ 5CAC               ELSE
  41+ 5CAC ~             DW NOACTION_DEFUSR
  42+ 5CAC               ENDIF
  43+ 5CAC
  44+ 5CAC               IF (SPRITE_CMDS == 1)
  45+ 5CAC D5 4E         DW SPRGRPMOV_DEFUSR        ; 6
  46+ 5CAE               ELSE
  47+ 5CAE ~             DW NOACTION_DEFUSR
  48+ 5CAE               ENDIF
  49+ 5CAE
  50+ 5CAE               IF (COLL_CMD == 1)
  51+ 5CAE 5F 5C         DW COLL_DEFUSR             ; 7
  52+ 5CB0               ELSE
  53+ 5CB0 ~             DW NOACTION_DEFUSR
  54+ 5CB0               ENDIF
  55+ 5CB0
  56+ 5CB0               IF (SOUND_CMDS == 1)
  57+ 5CB0 DD 55         DW SNDSFX_DEFUSR             ; 8
  58+ 5CB2               ELSE
  59+ 5CB2 ~             DW NOACTION_DEFUSR
  60+ 5CB2               ENDIF
  61+ 5CB2
  62+ 5CB2               IF (ANIM_CMDS == 1)
  63+ 5CB2 8B 52         DW ANIMSTEP_SINGLE_DEFUSR      ; 9
  64+ 5CB4 9B 52         DW ANIMSTEP_MULTI_DEFUSR       ; 10
  65+ 5CB6 AC 52         DW ANIMSTART_SINGLE_DEFUSR     ; 11
  66+ 5CB8 BE 52         DW ANIMSTART_MULTI_DEFUSR      ; 12
  67+ 5CBA C3 52         DW ANIMSTOP_SINGLE_DEFUSR      ; 13
  68+ 5CBC CD 52         DW ANIMSTOP_MULTI_DEFUSR       ; 14
  69+ 5CBE               ELSE
  70+ 5CBE ~             DW NOACTION_DEFUSR
  71+ 5CBE ~             DW NOACTION_DEFUSR
  72+ 5CBE ~             DW NOACTION_DEFUSR
  73+ 5CBE ~             DW NOACTION_DEFUSR
  74+ 5CBE ~             DW NOACTION_DEFUSR
  75+ 5CBE ~             DW NOACTION_DEFUSR
  76+ 5CBE               ENDIF
  77+ 5CBE
  78+ 5CBE               IF (BOX_CMDS == 1)
  79+ 5CBE 39 57         DW BOXMEMCPY_DEFUSR            ; 15
  80+ 5CC0 6F 57         DW BOXMEMVRM_DEFUSR            ; 16
  81+ 5CC2               ELSE
  82+ 5CC2 ~             DW NOACTION_DEFUSR
  83+ 5CC2 ~             DW NOACTION_DEFUSR
  84+ 5CC2               ENDIF
  85+ 5CC2
  86+ 5CC2               IF (ANIM_CMDS == 1)
  87+ 5CC2 35 4F         DW MAXANIMITEMS_DEFUSR         ; 17
  88+ 5CC4 44 50         DW MAXANIMDEFS_DEFUSR          ; 18
  89+ 5CC6 A1 50         DW MAXANIMSPRS_DEFUSR          ; 19
  90+ 5CC8 5F 51         DW MAXAUTOSGAMS_DEFUSR         ; 20
  91+ 5CCA FA 4F         DW ANIMITEMPAT_DEFUSR          ; 21
  92+ 5CCC 1F 50         DW ANIMITEMPTR_DEFUSR          ; 22
  93+ 5CCE 7B 50         DW ANIMDEF_DEFUSR              ; 23
  94+ 5CD0 EE 50         DW ANIMSPRITE_DEFUSR           ; 24
  95+ 5CD2 25 51         DW ANIMCHAR_DEFUSR             ; 25
  96+ 5CD4 B0 51         DW AUTOSGAMDEF_DEFUSR          ; 26
  97+ 5CD6 40 52         DW AUTOSGAMSTART_DEFUSR        ; 27
  98+ 5CD8 67 52         DW AUTOSGAMSTOP_DEFUSR         ; 28
  99+ 5CDA               ELSE
 100+ 5CDA ~             DW NOACTION_DEFUSR
 101+ 5CDA ~             DW NOACTION_DEFUSR
 102+ 5CDA ~             DW NOACTION_DEFUSR
 103+ 5CDA ~             DW NOACTION_DEFUSR
 104+ 5CDA ~             DW NOACTION_DEFUSR
 105+ 5CDA ~             DW NOACTION_DEFUSR
 106+ 5CDA ~             DW NOACTION_DEFUSR
 107+ 5CDA ~             DW NOACTION_DEFUSR
 108+ 5CDA ~             DW NOACTION_DEFUSR
 109+ 5CDA ~             DW NOACTION_DEFUSR
 110+ 5CDA ~             DW NOACTION_DEFUSR
 111+ 5CDA ~             DW NOACTION_DEFUSR
 112+ 5CDA               ENDIF
 113+ 5CDA
 114+ 5CDA               IF (GENCAL_CMD == 1)
 115+ 5CDA B9 56         DW GENCAL_DEFUSR               ; 29
 116+ 5CDC               ELSE
 117+ 5CDC ~             DW NOACTION_DEFUSR
 118+ 5CDC               ENDIF
 119+ 5CDC
 120+ 5CDC               IF (RAM_CMDS == 1)
 121+ 5CDC 43 55         DW FILRAM_DEFUSR               ; 30
 122+ 5CDE               ELSE
 123+ 5CDE ~             DW NOACTION_DEFUSR
 124+ 5CDE               ENDIF
 125+ 5CDE
 126+ 5CDE               IF (SOUND_CMDS == 1)
 127+ 5CDE 74 55         DW SNDPLYINI_DEFUSR            ; 31
 128+ 5CE0 A7 55         DW SNDPLYON_DEFUSR             ; 32
 129+ 5CE2 BA 55         DW SNDPLYOFF_DEFUSR            ; 33
 130+ 5CE4               ELSE
 131+ 5CE4 ~             DW NOACTION_DEFUSR
 132+ 5CE4 ~             DW NOACTION_DEFUSR
 133+ 5CE4 ~             DW NOACTION_DEFUSR
 134+ 5CE4               ENDIF
 135+ 5CE4
 136+ 5CE4               IF (TILE_CMDS == 1)
 137+ 5CE4 10 5A         DW TILERAM_DEFUSR              ; 34
 138+ 5CE6 C7 5A         DW TILEVRM_DEFUSR              ; 35
 139+ 5CE8               ELSE
 140+ 5CE8 ~             DW NOACTION_DEFUSR
 141+ 5CE8 ~             DW NOACTION_DEFUSR
 142+ 5CE8               ENDIF
 143+ 5CE8
 144+ 5CE8               IF (VRAM_CMDS == 1)
 145+ 5CE8 00 56         DW FILVRM_DEFUSR               ; 36
 146+ 5CEA 76 56         DW VRMMEM_DEFUSR               ; 37
 147+ 5CEC               ELSE
 148+ 5CEC ~             DW NOACTION_DEFUSR
 149+ 5CEC ~             DW NOACTION_DEFUSR
 150+ 5CEC               ENDIF
 151+ 5CEC
 152+ 5CEC              DEFUSR_ENTRY:
 153+ 5CEC FB               EI
 154+ 5CED DD 2A F8 F7      LD IX,(DAC+2)
 155+ 5CF1 DD 7E 00         LD A,(IX)
 156+ 5CF4 FE 26            CP DEFUSR_TABLE_ENTRIES
 157+ 5CF6 D0               RET NC ; return if an undefined function requested
 158+ 5CF7 26 00            LD H,0
 159+ 5CF9 6F               LD L,A
 160+ 5CFA 29               ADD HL,HL
 161+ 5CFB 11 A0 5C         LD DE,DEFUSR_JUMP_TABLE
 162+ 5CFE 19               ADD HL,DE
 163+ 5CFF EB               EX DE,HL
 164+ 5D00 1A               LD A,(DE)
 165+ 5D01 6F               LD L,A
 166+ 5D02 13               INC DE
 167+ 5D03 1A               LD A,(DE)
 168+ 5D04 67               LD H,A
 169+ 5D05 E9               JP (HL) ; call function with IX=pointer to data array
 170+ 5D06
# file closed: asm\DEFUSR.asm
 170  5D06               ENDIF
 171  5D06
 172  5D06              ; temp variables for BLIT, TILE functions
 173  5D06               IF (BLIT_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS + COLL_CMD > 0)
 174  5D06              BLIT_TMP:
 175  5D06              TILETMP1:
 176  5D06              BLIT_TMP1:
 177  5D06 00 00         DW 0
 178  5D08              TILETMP2:
 179  5D08              BLIT_TMP2:
 180  5D08 00 00         DW 0
 181  5D0A              BLIT_STRUCT:
 182  5D0A 00 00 00...   DS 17
 183  5D0E               ENDIF
 184  5D1B
 185  5D1B               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 186  5D1B              VRAM_UPDATE_IN_PROGRESS:
 187  5D1B 00            DB 0
 188  5D1C               ENDIF
 189  5D1C
 190  5D1C              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 191  5D1C              ; per starting letter, if no commands with this letter, NULL value
 192  5D1C              CMDS:
 193  5D1C 50 5D        	DW CMDS_A ; always present due to ARTINFO
 194  5D1E               IF (BLIT_CMDS + BOX_CMDS > 0) && (0 == 1)
 195  5D1E ~                DW CMDS_B ; B
 196  5D1E               ELSE
 197  5D1E 00 00        	DW 0
 198  5D20               ENDIF
 199  5D20               IF (COLL_CMD == 1) && (0 == 1)
 200  5D20 ~            	DW CMDS_C ;
 201  5D20               ELSE
 202  5D20 00 00            DW 0 ; C
 203  5D22               ENDIF
 204  5D22 00 00            DW 0 ; D
 205  5D24 00 00            DW 0 ; E
 206  5D26               IF (VRAM_CMDS + RAM_CMDS > 0) && (0 == 1)
 207  5D26 ~                DW CMDS_F; F
 208  5D26               ELSE
 209  5D26 00 00        	DW 0
 210  5D28               ENDIF
 211  5D28               IF (GENCAL_CMD > 0) && (0 == 1)
 212  5D28 ~                DW CMDS_G; G
 213  5D28               ELSE
 214  5D28 00 00        	DW 0
 215  5D2A               ENDIF
 216  5D2A 00 00            DW 0 ; H
 217  5D2C 00 00            DW 0 ; I
 218  5D2E 00 00            DW 0 ; J
 219  5D30 00 00            DW 0 ; K
 220  5D32 00 00            DW 0 ; L
 221  5D34               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0) && (0 == 1)
 222  5D34 ~                DW CMDS_M ; M
 223  5D34               ELSE
 224  5D34 00 00        	DW 0
 225  5D36               ENDIF
 226  5D36 00 00            DW 0 ; N
 227  5D38 00 00            DW 0 ; O
 228  5D3A 00 00            DW 0 ; P
 229  5D3C 00 00            DW 0 ; Q
 230  5D3E 00 00            DW 0 ; R
 231  5D40               IF (SOUND_CMDS + SPRITE_CMDS > 0) && (0 == 1)
 232  5D40 ~                DW CMDS_S ; S
 233  5D40               ELSE
 234  5D40 00 00        	DW 0
 235  5D42               ENDIF
 236  5D42               IF (TILE_CMDS > 0) && (0 == 1)
 237  5D42 ~                DW CMDS_T ; T
 238  5D42               ELSE
 239  5D42 00 00        	DW 0
 240  5D44               ENDIF
 241  5D44 00 00            DW 0 ; U
 242  5D46               IF (VRAM_CMDS > 0) && (0 == 1)
 243  5D46 ~                DW CMDS_V ; V
 244  5D46               ELSE
 245  5D46 00 00        	DW 0
 246  5D48               ENDIF
 247  5D48 00 00            DW 0 ; W
 248  5D4A 00 00            DW 0 ; X
 249  5D4C 00 00            DW 0 ; Y
 250  5D4E 00 00            DW 0 ; Z
 251  5D50
 252  5D50               IF (0 == 1)
 253  5D50 ~            CMDS_M:
 254  5D50 ~             IF (VRAM_CMDS == 1)
 255  5D50 ~                DB "MEMVRM", 0
 256  5D50 ~                DW MEMVRM
 257  5D50 ~             ENDIF
 258  5D50 ~             IF (RAM_CMDS == 1)
 259  5D50 ~            	DB "MEMCPY", 0
 260  5D50 ~            	DW MEMCPY
 261  5D50 ~             ENDIF
 262  5D50 ~             IF (ANIM_CMDS == 1)
 263  5D50 ~            	DB "MAXANIMITEMS",0
 264  5D50 ~            	DW MAXANIMITEMS
 265  5D50 ~            	DB "MAXANIMDEFS",0
 266  5D50 ~            	DW MAXANIMDEFS
 267  5D50 ~            	DB "MAXANIMSPRS",0
 268  5D50 ~            	DW MAXANIMSPRS
 269  5D50 ~               DB "MAXAUTOSGAMS",0
 270  5D50 ~               DW MAXAUTOSGAMS
 271  5D50 ~             ENDIF
 272  5D50 ~             IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 273  5D50 ~            	DB 0
 274  5D50 ~             ENDIF
 275  5D50 ~            CMDS_F:
 276  5D50 ~             IF (VRAM_CMDS == 1)
 277  5D50 ~                DB "FILVRM", 0
 278  5D50 ~                DW FILVRM
 279  5D50 ~             ENDIF
 280  5D50 ~             IF (RAM_CMDS == 1)
 281  5D50 ~                DB "FILRAM", 0
 282  5D50 ~                DW FILRAM
 283  5D50 ~             ENDIF
 284  5D50 ~             IF (VRAM_CMDS + RAM_CMDS > 0)
 285  5D50 ~                DB 0
 286  5D50 ~             ENDIF
 287  5D50 ~            CMDS_G:
 288  5D50 ~             IF (GENCAL_CMD == 1)
 289  5D50 ~                DB "GENCAL", 0
 290  5D50 ~                DW GENCAL
 291  5D50 ~             ENDIF
 292  5D50 ~             IF (GENCAL_CMD > 0)
 293  5D50 ~            	DB	0
 294  5D50 ~             ENDIF
 295  5D50 ~            CMDS_V:
 296  5D50 ~             IF (VRAM_CMDS == 1)
 297  5D50 ~            	DB "VRMMEM", 0
 298  5D50 ~            	DW VRMMEM
 299  5D50 ~             ENDIF
 300  5D50 ~             IF (VRAM_CMDS > 0)
 301  5D50 ~            	DB 0
 302  5D50 ~             ENDIF
 303  5D50 ~            CMDS_S:
 304  5D50 ~             IF (SPRITE_CMDS + ANIM_CMDS > 0)
 305  5D50 ~                DB "SGAM",0
 306  5D50 ~                DW SGAM
 307  5D50 ~             ENDIF
 308  5D50 ~             IF (SPRITE_CMDS == 1)
 309  5D50 ~            	DB "SPRGRPMOV", 0
 310  5D50 ~            	DW SPRGRPMOV
 311  5D50 ~             ENDIF
 312  5D50 ~             IF (SOUND_CMDS == 1)
 313  5D50 ~            	DB "SNDSFX", 0
 314  5D50 ~            	DW SNDSFX
 315  5D50 ~            	DB "SNDPLYON", 0
 316  5D50 ~            	DW SNDPLYON
 317  5D50 ~            	DB "SNDPLYOFF", 0
 318  5D50 ~            	DW SNDPLYOFF
 319  5D50 ~            	DB "SNDPLYINI", 0
 320  5D50 ~            	DW SNDPLYINIT
 321  5D50 ~             ENDIF
 322  5D50 ~             IF (SPRITE_CMDS == 1)
 323  5D50 ~            	DB "SPRENABLE", 0
 324  5D50 ~            	DW SPRENABLE
 325  5D50 ~            	DB "SPRDISABLE", 0
 326  5D50 ~            	DW SPRDISABLE
 327  5D50 ~             ENDIF
 328  5D50 ~             IF (SOUND_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 329  5D50 ~            	DB 0
 330  5D50 ~             ENDIF
 331  5D50 ~            CMDS_B:
 332  5D50 ~             IF (BLIT_CMDS == 1)
 333  5D50 ~            	DB "BLIT", 0
 334  5D50 ~            	DW BLIT
 335  5D50 ~             ENDIF
 336  5D50 ~             IF (BOX_CMDS == 1)
 337  5D50 ~            	DB "BOXMEMCPY", 0
 338  5D50 ~            	DW BOXMEMCPY
 339  5D50 ~            	DB "BOXMEMVRM", 0
 340  5D50 ~            	DW BOXMEMVRM
 341  5D50 ~             ENDIF
 342  5D50 ~             IF (BLIT_CMDS + BOX_CMDS > 0)
 343  5D50 ~            	DB 0
 344  5D50 ~             ENDIF
 345  5D50 ~            CMDS_T:
 346  5D50 ~             IF (TILE_CMDS == 1)
 347  5D50 ~            	DB "TILERAM", 0
 348  5D50 ~            	DW TILERAM
 349  5D50 ~            	DB "TILEVRM", 0
 350  5D50 ~            	DW TILEVRM
 351  5D50 ~             ENDIF
 352  5D50 ~             IF (TILE_CMDS > 0)
 353  5D50 ~            	DB 0
 354  5D50 ~             ENDIF
 355  5D50 ~            CMDS_C:
 356  5D50 ~             IF (COLL_CMD == 1)
 357  5D50 ~                DB "COLL", 0
 358  5D50 ~                DW COLL
 359  5D50 ~             ENDIF
 360  5D50 ~             IF (COLL_CMD > 0)
 361  5D50 ~            	DB	0
 362  5D50 ~             ENDIF
 363  5D50 ~            CMDS_A:
 364  5D50 ~             IF (ANIM_CMDS == 1)
 365  5D50 ~               DB "ANIMSTEP",0
 366  5D50 ~               DW ANIMSTEP
 367  5D50 ~            	DB "ANIMSTART",0
 368  5D50 ~            	DW ANIMSTART
 369  5D50 ~            	DB "ANIMSTOP",0
 370  5D50 ~            	DW ANIMSTOP
 371  5D50 ~            	DB "ANIMITEMPAT",0
 372  5D50 ~            	DW ANIMITEMPAT
 373  5D50 ~            	DB "ANIMITEMPTR",0
 374  5D50 ~            	DW ANIMITEMPTR_CMD
 375  5D50 ~            	DB "ANIMDEF",0
 376  5D50 ~            	DW ANIMDEF
 377  5D50 ~            	DB "ANIMSPRITE",0
 378  5D50 ~            	DW ANIMSPRITE
 379  5D50 ~               DB "ANIMCHAR",0
 380  5D50 ~               DW ANIMCHAR
 381  5D50 ~               DB "AUTOSGAMDEF",0
 382  5D50 ~               DW AUTOSGAMDEF
 383  5D50 ~               DB "AUTOSGAMSTART",0
 384  5D50 ~               DW AUTOSGAMSTART
 385  5D50 ~               DB "AUTOSGAMSTOP",0
 386  5D50 ~               DW AUTOSGAMSTOP
 387  5D50 ~             ENDIF
 388  5D50 ~               DB "ARTINFO",0
 389  5D50 ~               DW ARTINFO
 390  5D50 ~            	DB 0
 391  5D50               ELSE
 392  5D50              CMDS_A:
 393  5D50 41 52 54 49   DB "ARTINFO",0
 393  5D54 4E 46 4F 00
 394  5D58 B0 5E         DW ARTINFO
 395  5D5A 00            DB 0
 396  5D5B               ENDIF
 397  5D5B
 398  5D5B
 399  5D5B               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 400  5D5B              ; ****************************************************************************************************
 401  5D5B              ; function sets VRAM address
 402  5D5B              ; input HL=address
 403  5D5B              ; modifies AF
 404  5D5B              SETWRT_LOCAL:
 405  5D5B 7D           	LD	A,L
 406  5D5C D3 99        	OUT (099H),A
 407  5D5E 7C           	LD	A,H
 408  5D5F E6 3F        	AND 03FH
 409  5D61 F6 40        	OR	040H
 410  5D63 D3 99        	OUT (099H),A
 411  5D65 C9           	RET
 412  5D66              ; ****************************************************************************************************
 413  5D66               ENDIF
 414  5D66
 415  5D66               IF (VRAM_CMDS + TILE_CMDS > 0)
 416  5D66              ; ****************************************************************************************************
 417  5D66              ; function copies data from RAM to VRAM
 418  5D66              ; input HL=address in RAM
 419  5D66              ; input B=count
 420  5D66              ; modifies AF, BC, HL
 421  5D66              BBYTECOPY:
 422  5D66 0E 98        	LD C,#98
 423  5D68              BBYTECOPY_NO_C:
 424  5D68 ED A3        	OUTI
 425  5D6A C2 68 5D     	JP	NZ, BBYTECOPY_NO_C
 426  5D6D C9           	RET
 427  5D6E              ; ****************************************************************************************************
 428  5D6E               ENDIF
 429  5D6E
 430  5D6E              ; ****************************************************************************************************
 431  5D6E              ; function multiplies HL by 32
 432  5D6E              HLx32:
 433  5D6E 29           	ADD HL,HL
 434  5D6F              ; ****************************************************************************************************
 435  5D6F              ; function multiplies HL by 16
 436  5D6F              HLx16:
 437  5D6F 29           	ADD HL,HL
 438  5D70              ; ****************************************************************************************************
 439  5D70              ; function multiplies HL by 8
 440  5D70              HLx8:
 441  5D70 29          > ADD HL, HL
 441  5D71 29          > ADD HL, HL
 441  5D72 29          > ADD HL, HL
 442  5D73 C9           	RET
 443  5D74              ; ****************************************************************************************************
 444  5D74
 445  5D74              ; ****************************************************************************************************
 446  5D74              ; function gets slot and subslot data for specific page
 447  5D74              ; input A=page (0, 1 or 2)
 448  5D74              ; output B = 0A8H register value
 449  5D74              ; output D = 0 is no subslots, 1 if yes
 450  5D74              ; output C = 0A8H value when page 3 slot equals to requested page slot
 451  5D74              ; output E = subslot value if present
 452  5D74              ; modifies AF, BC, DE, HL
 453  5D74              GET_PAGE_INFO:
 454  5D74 6F               LD L, A
 455  5D75 C6 C1            ADD A, low (EXPTBL)
 456  5D77 32 81 5D         LD (GET_PAGE_INFO_L1+1), A
 457  5D7A DB A8            IN A, (0A8H)
 458  5D7C 47               LD B, A
 459  5D7D E6 3F            AND 03FH
 460  5D7F 4F               LD C, A
 461  5D80              GET_PAGE_INFO_L1:
 462  5D80 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 463  5D83 E6 80            AND 080H
 464  5D85 28 1B            JR Z, GET_PAGE_INFO_L2
 465  5D87                  ; expanded
 466  5D87 2D               DEC L
 467  5D88 FA A7 5D         JP M, GET_PAGE_INFO_L3
 468  5D8B 2D               DEC L
 469  5D8C FA A5 5D         JP M, GET_PAGE_INFO_L4
 470  5D8F                  ; page 2
 471  5D8F 07               RLCA
 472  5D90 07               RLCA
 473  5D91              GET_PAGE_INFO_L5:
 474  5D91 E6 C0            AND 0C0H
 475  5D93 B1               OR C
 476  5D94 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 477  5D96 4F               LD C, A
 478  5D97 3A FF FF         LD A, (0FFFFH)
 479  5D9A 2F               CPL
 480  5D9B 5F               LD E, A
 481  5D9C 16 01            LD D, 1
 482  5D9E 78               LD A, B ; return stack
 483  5D9F D3 A8            OUT (0A8H), A
 484  5DA1 C9               RET
 485  5DA2              GET_PAGE_INFO_L2:
 486  5DA2                  ; not expanded
 487  5DA2 16 00            LD D, 0
 488  5DA4 C9               RET
 489  5DA5              GET_PAGE_INFO_L4:
 490  5DA5                  ; page 1
 491  5DA5 0F               RRCA
 492  5DA6 0F               RRCA
 493  5DA7              GET_PAGE_INFO_L3:
 494  5DA7                  ; page 0
 495  5DA7 0F               RRCA
 496  5DA8 0F               RRCA
 497  5DA9 18 E6            JR GET_PAGE_INFO_L5
 498  5DAB              ; ****************************************************************************************************
 499  5DAB
 500  5DAB              ; ****************************************************************************************************
 501  5DAB              ; function returns original slot and subslot info
 502  5DAB              ; input B = 0A8H register value
 503  5DAB              ; input D = 0 is no subslots, 1 if yes
 504  5DAB              ; input C = 0A8H value when page 3 slot equals to requested page slot
 505  5DAB              ; input E = subslot value if present
 506  5DAB              ; modifies AF, disables interrupts
 507  5DAB              RESTORE_PAGE_INFO:
 508  5DAB F3              DI
 509  5DAC 7A              LD A, D
 510  5DAD B7              OR A
 511  5DAE 28 07           JR Z, RESTORE_PAGE_INFO_L1
 512  5DB0 79              LD A, C
 513  5DB1 D3 A8           OUT (0A8H), A
 514  5DB3 7B              LD A, E
 515  5DB4 32 FF FF        LD (0FFFFH), A
 516  5DB7              RESTORE_PAGE_INFO_L1:
 517  5DB7 78              LD A, B
 518  5DB8 D3 A8           OUT (0A8H), A
 519  5DBA              NOACTION_DEFUSR: ; just a safe RET for use when DEFUSR table has an empty entry
 520  5DBA C9              RET
 521  5DBB              ; ****************************************************************************************************
 522  5DBB
 523  5DBB              ; *******************************************************************************************************
 524  5DBB              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 525  5DBB              ; INPUT:  A = SLOT ID: EXXXSSPP
 526  5DBB              ; E = EXPANDED FLAG
 527  5DBB              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 528  5DBB              ; PP = PRIMARY SLOT NUMBER
 529  5DBB              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 530  5DBB              ; CHANGES: AF, BC, DE
 531  5DBB
 532  5DBB              LOCAL_ENASLT:
 533  5DBB CD DB 5D         CALL L0353
 534  5DBE FA C8 5D         JP M, L0340
 535  5DC1 DB A8            IN A, (0A8H)
 536  5DC3 A1               AND C
 537  5DC4 B0               OR B
 538  5DC5 D3 A8            OUT (0A8H), A
 539  5DC7 C9               RET
 540  5DC8              L0340:
 541  5DC8 E5               PUSH HL
 542  5DC9 CD 00 5E         CALL L0378
 543  5DCC 4F               LD C, A
 544  5DCD 06 00            LD B, 0
 545  5DCF 7D               LD A, L
 546  5DD0 A4               AND H
 547  5DD1 B2               OR D
 548  5DD2 21 C5 FC         LD HL, 0FCC5H
 549  5DD5 09               ADD HL, BC
 550  5DD6 77               LD (HL), A
 551  5DD7 E1               POP HL
 552  5DD8 79               LD A, C
 553  5DD9 18 E0            JR LOCAL_ENASLT
 554  5DDB              L0353:
 555  5DDB F3               DI
 556  5DDC F5               PUSH AF
 557  5DDD 7C               LD A, H
 558  5DDE 07               RLCA
 559  5DDF 07               RLCA
 560  5DE0 E6 03            AND 3
 561  5DE2 5F               LD E, A
 562  5DE3 3E C0            LD A, 0C0H
 563  5DE5              L035D:
 564  5DE5 07               RLCA
 565  5DE6 07               RLCA
 566  5DE7 1D               DEC E
 567  5DE8 F2 E5 5D         JP P, L035D
 568  5DEB 5F               LD E, A
 569  5DEC 2F               CPL
 570  5DED 4F               LD C, A
 571  5DEE F1               POP AF
 572  5DEF F5               PUSH AF
 573  5DF0 E6 03            AND 3
 574  5DF2 3C               INC A
 575  5DF3 47               LD B, A
 576  5DF4 3E AB            LD A, 0ABH
 577  5DF6              L036E:
 578  5DF6 C6 55            ADD A, 055H
 579  5DF8 10 FC            DJNZ L036E
 580  5DFA 57               LD D, A
 581  5DFB A3               AND E
 582  5DFC 47               LD B, A
 583  5DFD F1               POP AF
 584  5DFE A7               AND A
 585  5DFF C9               RET
 586  5E00              L0378:
 587  5E00 F5               PUSH AF
 588  5E01 7A               LD A, D
 589  5E02 E6 C0            AND 0C0H
 590  5E04 4F               LD C, A
 591  5E05 F1               POP AF
 592  5E06 F5               PUSH AF
 593  5E07 57               LD D, A
 594  5E08 DB A8            IN A, (0A8H)
 595  5E0A 47               LD B, A
 596  5E0B E6 3F            AND 03FH
 597  5E0D B1               OR C
 598  5E0E D3 A8            OUT (0A8H), A
 599  5E10 7A               LD A, D
 600  5E11 0F               RRCA
 601  5E12 0F               RRCA
 602  5E13 E6 03            AND 3
 603  5E15 57               LD D, A
 604  5E16 3E AB            LD A, 0ABH
 605  5E18              L0390:
 606  5E18 C6 55            ADD A, 055H
 607  5E1A 15               DEC D
 608  5E1B F2 18 5E         JP P, L0390
 609  5E1E A3               AND E
 610  5E1F 57               LD D, A
 611  5E20 7B               LD A, E
 612  5E21 2F               CPL
 613  5E22 67               LD H, A
 614  5E23 3A FF FF         LD A, (0FFFFH)
 615  5E26 2F               CPL
 616  5E27 6F               LD L, A
 617  5E28 A4               AND H
 618  5E29 B2               OR D
 619  5E2A 32 FF FF         LD (0FFFFH), A
 620  5E2D 78               LD A, B
 621  5E2E D3 A8            OUT (0A8H), A
 622  5E30 F1               POP AF
 623  5E31 E6 03            AND 3
 624  5E33 C9               RET
 625  5E34              ; *******************************************************************************************************
 626  5E34
 627  5E34              ; *******************************************************************************************************
 628  5E34              ; some common code to activate page 0 and place values needed to restore original page on stack
 629  5E34              ; input IY=return address
 630  5E34              ENABLE_PAGE0:
 631  5E34 F3              DI
 632  5E35 AF              XOR A
 633  5E36 CD 74 5D        CALL GET_PAGE_INFO
 634  5E39 C5              PUSH BC
 635  5E3A D5              PUSH DE
 636  5E3B 3A 41 F3        LD A, (RAMAD0)
 637  5E3E 26 00           LD H, 0
 638  5E40 CD BB 5D        CALL LOCAL_ENASLT
 639  5E43 FD E9        	JP (IY)
 640  5E45              ; *******************************************************************************************************
 641  5E45
 642  5E45              ; General BASIC CALL-instruction handler
 643  5E45              CALLHAND:
 644  5E45 FB              EI
 645  5E46 E5           	PUSH HL
 646  5E47 21 1C 5D     	LD	HL, CMDS ; pointer table based on starting letter
 647  5E4A 3A 89 FD        LD A, (PROCNM)
 648  5E4D D6 41           SUB 'A'
 649  5E4F 87              ADD A, A
 650  5E50 16 00           LD D, 0
 651  5E52 5F              LD E, A
 652  5E53 19              ADD HL, DE
 653  5E54 5E              LD E, (HL)
 654  5E55 23              INC HL
 655  5E56 56              LD D, (HL)
 656  5E57 7A              LD A, D
 657  5E58 B3              OR E
 658  5E59 28 23           JR Z, .CMDNOTRECOGNIZED
 659  5E5B EB              EX DE, HL
 660  5E5C              .CHKCMD:
 661  5E5C 11 89 FD     	LD	DE, PROCNM
 662  5E5F              .LOOP:
 663  5E5F 1A              LD	A,(DE)
 664  5E60 BE           	CP	(HL)
 665  5E61 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 666  5E63 13           	INC	DE
 667  5E64 23           	INC	HL
 668  5E65 A7           	AND	A
 669  5E66 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 670  5E68 5E           	LD	E,(HL)
 671  5E69 23           	INC	HL
 672  5E6A 56           	LD	D,(HL)
 673  5E6B E1           	POP	HL		; routine address
 674  5E6C CD 8D 5E     	CALL	GETPREVCHAR
 675  5E6F CD 81 5E     	CALL	.CALLDE		; Call routine
 676  5E72 A7           	AND	A
 677  5E73 C9           	RET
 678  5E74
 679  5E74              .TONEXTCMD:
 680  5E74 0E FF        	LD	C,0FFH
 681  5E76 AF           	XOR	A
 682  5E77 ED B1        	CPIR			; Skip to end of instruction name
 683  5E79 23           	INC	HL
 684  5E7A 23           	INC	HL		; Skip address
 685  5E7B BE           	CP	(HL)
 686  5E7C 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 687  5E7E              .CMDNOTRECOGNIZED:
 688  5E7E E1           	POP	HL
 689  5E7F 37              SCF
 690  5E80 C9           	RET
 691  5E81
 692  5E81              .CALLDE:
 693  5E81 D5           	PUSH	DE
 694  5E82 C9           	RET
 695  5E83
 696  5E83              ;---------------------------
 697  5E83
 698  5E83              ;GETSTRPNT:
 699  5E83              ; OUT:
 700  5E83              ; HL = String Address
 701  5E83              ; B  = Lenght
 702  5E83              ;        LD      HL,(USR)
 703  5E83              ;        LD      B,(HL)
 704  5E83              ;        INC     HL
 705  5E83              ;        LD      E,(HL)
 706  5E83              ;        INC     HL
 707  5E83              ;        LD      D,(HL)
 708  5E83              ;        EX      DE,HL
 709  5E83              ;        RET
 710  5E83
 711  5E83              ;EVALTXTPARAM:
 712  5E83              ;	CALL	CHKCHAR
 713  5E83              ;	DEFB	"("             ; Check for (
 714  5E83              ;	LD	IX,FRMEVL
 715  5E83              ;	CALL	CALBAS		; Evaluate expression
 716  5E83              ;       LD      A,(VALTYP)
 717  5E83              ;        CP      3               ; Text type?
 718  5E83              ;        JP      NZ,TYPE_MISMATCH
 719  5E83              ;        PUSH	HL
 720  5E83              ;        LD	IX,FRESTR         ; Free the temporary string
 721  5E83              ;        CALL	CALBAS
 722  5E83              ;        POP	HL
 723  5E83              ;	CALL	CHKCHAR
 724  5E83              ;	DEFB	")"             ; Check for )
 725  5E83              ;        RET
 726  5E83
 727  5E83
 728  5E83              CHKCHAR:
 729  5E83 CD 8D 5E     	CALL	GETPREVCHAR	; Get previous basic char
 730  5E86 E3           	EX	(SP),HL
 731  5E87 BE           	CP	(HL) 	        ; Check if good char
 732  5E88 20 1D        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 733  5E8A 23           	INC	HL
 734  5E8B E3           	EX	(SP),HL
 735  5E8C 23           	INC	HL		; Get next basic char
 736  5E8D
 737  5E8D              GETPREVCHAR:
 738  5E8D 2B           	DEC HL
 739  5E8E DD 21 66 46  	LD	IX,CHRGTR
 740  5E92 CD 59 01     	CALL CALBAS
 741  5E95 FB              EI
 742  5E96 C9              RET
 743  5E97
 744  5E97
 745  5E97              TYPE_MISMATCH:
 746  5E97 1E 0D            LD E, 13 ; Type mismatch
 747  5E99 18 0E            JR THROW_ERROR
 748  5E9B              SUBSCRIPT_OUT_OF_RANGE:
 749  5E9B 1E 09            LD E,9 ; subscript out of range
 750  5E9D 18 0A        	JR THROW_ERROR
 751  5E9F              OVERFLOW:
 752  5E9F 1E 06        	LD E,6
 753  5EA1 18 06        	JR THROW_ERROR
 754  5EA3              ILLEGAL_FUNCTION:
 755  5EA3 1E 05            LD E, 5 ; illegal function call
 756  5EA5 18 02            JR THROW_ERROR
 757  5EA7              SYNTAX_ERROR:
 758  5EA7 1E 02            LD E, 2 ; Syntax error
 759  5EA9              THROW_ERROR:
 760  5EA9 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 761  5EAD C3 59 01     	JP	CALBAS
 762  5EB0
 763  5EB0              ;---------------------------
 764  5EB0
 765  5EB0               IF (0 == 1)
 766  5EB0 ~            ; *******************************************************************************************************
 767  5EB0 ~            ; helper function to get pointer to BASIC array data
 768  5EB0 ~            ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
 769  5EB0 ~            ; input B=dimensions (1 or 2)
 770  5EB0 ~            ; input D=minimal first dimension
 771  5EB0 ~            ; input E=minimal second dimension, if applicable
 772  5EB0 ~            ; returns BC=pointer to first data element
 773  5EB0 ~            ; throws BASIC error if invalid type
 774  5EB0 ~            GET_BASIC_ARRAY_DATA_POINTER:
 775  5EB0 ~            	PUSH DE
 776  5EB0 ~            	PUSH BC
 777  5EB0 ~            	PUSH AF
 778  5EB0 ~               LD A,1
 779  5EB0 ~               LD (SUBFLG),A ; search for arrays only
 780  5EB0 ~            	LD IX, PTRGET
 781  5EB0 ~            	CALL CALBAS
 782  5EB0 ~               XOR A
 783  5EB0 ~               LD (SUBFLG),A ; if not reset will cause syntax errors
 784  5EB0 ~            	LD A,(VALTYP)
 785  5EB0 ~            	POP DE ; required type
 786  5EB0 ~            	CP D
 787  5EB0 ~            	JP NZ,TYPE_MISMATCH
 788  5EB0 ~            	LD A,(BC)
 789  5EB0 ~            	INC BC
 790  5EB0 ~            	POP DE ; required number of dimensions
 791  5EB0 ~            	CP D
 792  5EB0 ~            	JP NZ,TYPE_MISMATCH
 793  5EB0 ~            	POP DE ; required minimal array dimensions
 794  5EB0 ~            	DEC A
 795  5EB0 ~            	JR Z,.ONE_DIMENSION
 796  5EB0 ~            	; 2-dimension array
 797  5EB0 ~            	LD A,(BC)
 798  5EB0 ~            	.2 INC BC
 799  5EB0 ~            	CP E
 800  5EB0 ~            	JP C,SUBSCRIPT_OUT_OF_RANGE
 801  5EB0 ~            .ONE_DIMENSION:
 802  5EB0 ~            	LD A,(BC)
 803  5EB0 ~            	.2 INC BC
 804  5EB0 ~            	CP D
 805  5EB0 ~            	JP C,SUBSCRIPT_OUT_OF_RANGE
 806  5EB0 ~            	RET
 807  5EB0 ~            ; *******************************************************************************************************
 808  5EB0               ENDIF
 809  5EB0
 810  5EB0              ; *******************************************************************************************************
 811  5EB0              ; function to handle CALL ARTINFO basic extension
 812  5EB0              ; returns info about the extension
 813  5EB0              ; _ARTINFO ( INT variable version,
 814  5EB0              ;			    INT variable build_flags,
 815  5EB0              ;			    INT variable free_memory_ptr )
 816  5EB0              ; this function is always available and can be used to test if the extension is active
 817  5EB0              ARTINFO:
 818  5EB0              	; opening (
 819  5EB0 CD 83 5E     	CALL CHKCHAR
 820  5EB3 28           	DB '('
 821  5EB4              	; get address of version variable
 822  5EB4 DD 21 A4 5E  	LD IX, PTRGET
 823  5EB8 CD 59 01     	CALL CALBAS
 824  5EBB 3A 12 40     	LD A,(VERSION)
 825  5EBE 12              LD (DE),A
 826  5EBF 13              INC DE
 827  5EC0 3A 13 40        LD A,(VERSION+1)
 828  5EC3 12              LD (DE),A
 829  5EC4              	; comma
 830  5EC4 CD 83 5E     	CALL CHKCHAR
 831  5EC7 2C           	DB ','
 832  5EC8              	; get address of build flags variable
 833  5EC8 DD 21 A4 5E  	LD IX, PTRGET
 834  5ECC CD 59 01     	CALL CALBAS
 835  5ECF E5              PUSH HL
 836  5ED0 21 FF 0B        LD HL,SOUND_CMDS+2*RAM_CMDS+4*VRAM_CMDS+8*BLIT_CMDS+16*SPRITE_CMDS+32*GENCAL_CMD+64*TILE_CMDS+128*BOX_CMDS+256*ANIM_CMDS+512*COLL_CMD+1024*0+2048*1
 837  5ED3 EB              EX DE,HL
 838  5ED4 73              LD (HL),E
 839  5ED5 23              INC HL
 840  5ED6 72              LD (HL),D
 841  5ED7 E1              POP HL
 842  5ED8              	; comma
 843  5ED8 CD 83 5E     	CALL CHKCHAR
 844  5EDB 2C           	DB ','
 845  5EDC              	; get address of free memory variable
 846  5EDC DD 21 A4 5E  	LD IX, PTRGET
 847  5EE0 CD 59 01     	CALL CALBAS
 848  5EE3 3A 10 40     	LD A,(FREEMEMPTR)
 849  5EE6 12              LD (DE),A
 850  5EE7 13              INC DE
 851  5EE8 3A 11 40        LD A,(FREEMEMPTR+1)
 852  5EEB 12              LD (DE),A
 853  5EEC              	; ending )
 854  5EEC CD 83 5E     	CALL CHKCHAR
 855  5EEF 29           	DB ')'
 856  5EF0 C9           	RET
 857  5EF1              ; *******************************************************************************************************
 858  5EF1
 859  5EF1              EXT_END:
 860  5EF1
# file closed: asm\main.asm
