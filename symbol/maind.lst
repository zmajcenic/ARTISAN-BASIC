# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		   EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000              COLL_CMD       EQU 1
  14  4000              DECOMP_CMDS    EQU 1
  15  4000
  16  4000              ; what to compile, provided in sjasmplus command line
  17  4000              ;BASIC_EXTENSION   EQU 1
  18  4000              ;DEFUSR_EXTENSION  EQU 0
  19  4000
  20  4000              CHPUT   EQU    #A2
  21  4000              CALBAS  EQU		#159
  22  4000              ERRHAND EQU    #406F
  23  4000              FRMEVL  EQU    #4C64
  24  4000              FRESTR  EQU		#67D0
  25  4000              ; FRMQNT = formula quantificator
  26  4000              ; input HL=pointer to current program expression
  27  4000              ; output HL=next address
  28  4000              ; output DE=integer datum
  29  4000              FRMQNT	EQU		#542F
  30  4000              ; GETBYT = get byte parameter
  31  4000              ; input HL=pointer to current program expression
  32  4000              ; output HL=next address
  33  4000              ; output A=E=byte read
  34  4000              GETBYT		EQU	#521C
  35  4000              CHRGTR  	   EQU   #4666
  36  4000              PTRGET		EQU 	#5EA4
  37  4000              SUBFLG		EQU	#F6A5
  38  4000              SYNCHR		EQU	#558C
  39  4000              VALTYP  	   EQU   #F663
  40  4000              DAC         EQU   #F7F6
  41  4000              USR     	   EQU   #F7F8
  42  4000              PROCNM		EQU	#FD89
  43  4000              BIOS_FILVRM EQU   #0056
  44  4000              CLIKSW		EQU	#F3DB
  45  4000
  46  4000              RAMAD0	   EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  47  4000              RAMAD1	   EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  48  4000              RAMAD2	   EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  49  4000              RAMAD3	   EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  50  4000              EXPTBL	   EQU   #FCC1
  51  4000              SCRMOD	   EQU   #FCAF ; current screen mode
  52  4000              REG1SAV     EQU   #F3E0 ; VDP(1)
  53  4000              JIFFY	      EQU   #FC9E
  54  4000              GRPPAT	   EQU   #F3CF ; SCREEN 2 sprite generator table address
  55  4000              GRPCGP		EQU	#F3CB ; SCREEN 2 pattern generator table address
  56  4000              GRPATR      EQU   #F3CD ; SCREEN 2 sprite attribute table address
  57  4000              T32PAT	   EQU   #F3C5 ; SCREEN 1 sprite generator table address
  58  4000              T32CGP      EQU   #F3C1 ; SCREEN 1 pattern ganarator table address
  59  4000              T32ATR      EQU   #F3C3 ; SCREEN 1 sprite attribute table address
  60  4000
  61  4000              ; BASIC error codes
  62  4000              ;01 NEXT without FOR
  63  4000              ;02 Syntax error
  64  4000              ;03 RETURN without GOSUB
  65  4000              ;04 Out of DATA
  66  4000              ;05 Illegal function call
  67  4000              ;06 Overflow
  68  4000              ;07 Out of memory
  69  4000              ;08 Undefined line number
  70  4000              ;09 Subscript out of range
  71  4000              ;10 Redimensioned array
  72  4000              ;11 Division by zero
  73  4000              ;12 Illegal direct
  74  4000              ;13 Type mismatch
  75  4000              ;14 Out of string space
  76  4000              ;15 String too long
  77  4000              ;16 String formula too complex
  78  4000              ;17 Can't CONTINUE
  79  4000              ;18 Undefined user function
  80  4000              ;19 Device I/O error
  81  4000              ;20 Verify error
  82  4000              ;21 No RESUME
  83  4000              ;22 RESUME without error
  84  4000              ;23 Unprintable error
  85  4000              ;24 Missing operand
  86  4000              ;25 Line buffer overflow
  87  4000              ;50 FIELD overflow
  88  4000              ;51 Internal error
  89  4000              ;52 Bad file number
  90  4000              ;53 File not found
  91  4000              ;54 File already open
  92  4000              ;55 Input past end
  93  4000              ;56 Bad file name
  94  4000              ;57 Direct statement in file
  95  4000              ;58 Sequential I/O only
  96  4000              ;59 File not OPEN
  97  4000
  98  4000
  99  4000               ; simulate cartridge with BASIC extension
 100  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
 100  4004 16 5F 00 00
 100  4008 00 00 00 00
 100  400C 00 00 00 00
 101  4010
 102  4010              ; this location #4010 stores last location used by basic extension
 103  4010              ; free memory after that point
 104  4010              FREEMEMPTR:
 105  4010 C2 5F         DW EXT_END
 106  4012
 107  4012              ; this location #4012 stores extension version in DAA format
 108  4012              ; first byte is major version and second minor
 109  4012              VERSION:
 110  4012 00 92         DB #00, #92
 111  4014
 112  4014              ; this location #4014 contains a jump to entry point for DEFUSR approach
 113  4014              ; if excluded it contains 3xRET so that sound player can be at aspecific spot
 114  4014               IF (1 == 1)
 115  4014 C3 B3 5D        JP DEFUSR_ENTRY
 116  4017               ELSE
 117  4017 ~               .3 RET
 118  4017               ENDIF
 119  4017
 120  4017              ; binary included AKG player compiled at #4017
 121  4017               IF (SOUND_CMDS == 1)
 122  4017              	INCBIN "bin/AKG.bin"
 123  4CF3              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF3              MAIN_PLAYER_START EQU 04017H
   2+ 4CF3              PLY_AKG_START EQU 04017H
   3+ 4CF3              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 04020H
   4+ 4CF3              PLY_AKG_INITSOUNDEFFECTS EQU 04020H
   5+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04024H
   6+ 4CF3              PLY_AKG_PLAYSOUNDEFFECT EQU 04024H
   7+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04025H
   8+ 4CF3              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04025H
   9+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 0404CH
  10+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 0404CH
  11+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 0405AH
  12+ 4CF3              PLY_AKG_PSES_PLAY EQU 04093H
  13+ 4CF3              PLY_AKG_PSES_READFIRSTBYTE EQU 0409CH
  14+ 4CF3              PLY_AKG_PSES_S_ENDORLOOP EQU 040B4H
  15+ 4CF3              PLY_AKG_PSES_S_LOOP EQU 040BFH
  16+ 4CF3              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C5H
  17+ 4CF3              PLY_AKG_PSES_NOTREACHED EQU 040D8H
  18+ 4CF3              PLY_AKG_PSES_HARDWAREONLY EQU 040DCH
  19+ 4CF3              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E3H
  20+ 4CF3              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F5H
  21+ 4CF3              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FFH
  22+ 4CF3              PLY_AKG_PSES_H_AFTERRETRIG EQU 04109H
  23+ 4CF3              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411DH
  24+ 4CF3              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 04122H
  25+ 4CF3              PLY_AKG_PSES_READHARDWAREPERIOD EQU 0412AH
  26+ 4CF3              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04135H
  27+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 04141H
  28+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04143H
  29+ 4CF3              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04149H
  30+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414DH
  31+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414DH
  32+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414FH
  33+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414FH
  34+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414FH
  35+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 04150H
  36+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 04151H
  37+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04155H
  38+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04155H
  39+ 4CF3              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04155H
  40+ 4CF3              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415DH
  41+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04165H
  42+ 4CF3              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04165H
  43+ 4CF3              PLY_AKG_INIT EQU 04165H
  44+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04165H
  45+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04193H
  46+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A7H
  47+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B9H
  48+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D8H
  49+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E5H
  50+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL EQU 041EBH
  51+ 4CF3              PLY_AKG_INITTABLE0 EQU 041EEH
  52+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EEH
  53+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04208H
  54+ 4CF3              PLY_AKG_INITTABLE0_END EQU 04208H
  55+ 4CF3              PLY_AKG_INITTABLE1 EQU 04208H
  56+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04208H
  57+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 0420CH
  58+ 4CF3              PLY_AKG_INITTABLE1_END EQU 0420CH
  59+ 4CF3              PLY_AKG_INITTABLEORA EQU 0420CH
  60+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 0420CH
  61+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04224H
  62+ 4CF3              PLY_AKG_INITTABLEORA_END EQU 04224H
  63+ 4CF3              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04224H
  64+ 4CF3              PLY_AKG_STOP EQU 04224H
  65+ 4CF3              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04236H
  66+ 4CF3              PLY_AKG_PLAY EQU 04236H
  67+ 4CF3              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423EH
  68+ 4CF3              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04244H
  69+ 4CF3              PLY_AKG_READLINKER EQU 04249H
  70+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04249H
  71+ 4CF3              PLY_AKG_READLINKER_PTLINKER EQU 04249H
  72+ 4CF3              PLY_AKG_READLINKER_NOLOOP EQU 04254H
  73+ 4CF3              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428DH
  74+ 4CF3              PLY_AKG_READLINE EQU 04290H
  75+ 4CF3              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 04290H
  76+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04296H
  77+ 4CF3              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04296H
  78+ 4CF3              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A3H
  79+ 4CF3              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A7H
  80+ 4CF3              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042AAH
  81+ 4CF3              PLY_AKG_SPEEDTRACK_END EQU 042ADH
  82+ 4CF3              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042ADH
  83+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B3H
  84+ 4CF3              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B3H
  85+ 4CF3              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042C0H
  86+ 4CF3              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C4H
  87+ 4CF3              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C7H
  88+ 4CF3              PLY_AKG_EVENTTRACK_END EQU 042CAH
  89+ 4CF3              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042CAH
  90+ 4CF3              PLY_AKG_CHANNEL1_READTRACK EQU 042D6H
  91+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D6H
  92+ 4CF3              PLY_AKG_CHANNEL1_PTTRACK EQU 042D6H
  93+ 4CF3              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042F1H
  94+ 4CF3              PLY_AKG_CHANNEL1_WAIT EQU 042FCH
  95+ 4CF3              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04303H
  96+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04303H
  97+ 4CF3              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04303H
  98+ 4CF3              PLY_AKG_CHANNEL1_NOTE EQU 0430CH
  99+ 4CF3              PLY_AKG_BASENOTEINDEX EQU 0430CH
 100+ 4CF3              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430EH
 101+ 4CF3              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430EH
 102+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431EH
 103+ 4CF3              PLY_AKG_INSTRUMENTSTABLE EQU 0431EH
 104+ 4CF3              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 04330H
 105+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 04340H
 106+ 4CF3              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04368H
 107+ 4CF3              PLY_AKG_CHANNEL1_READCELLEND EQU 0436BH
 108+ 4CF3              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 0436BH
 109+ 4CF3              PLY_AKG_CHANNEL2_READTRACK EQU 04377H
 110+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04377H
 111+ 4CF3              PLY_AKG_CHANNEL2_PTTRACK EQU 04377H
 112+ 4CF3              PLY_AKG_CHANNEL2_SMALLWAIT EQU 04392H
 113+ 4CF3              PLY_AKG_CHANNEL2_WAIT EQU 0439DH
 114+ 4CF3              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A4H
 115+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A4H
 116+ 4CF3              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A4H
 117+ 4CF3              PLY_AKG_CHANNEL2_NOTE EQU 043ADH
 118+ 4CF3              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043B2H
 119+ 4CF3              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043B2H
 120+ 4CF3              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D4H
 121+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E4H
 122+ 4CF3              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 0440CH
 123+ 4CF3              PLY_AKG_CHANNEL2_READCELLEND EQU 0440FH
 124+ 4CF3              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440FH
 125+ 4CF3              PLY_AKG_CHANNEL3_READTRACK EQU 0441BH
 126+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 0441BH
 127+ 4CF3              PLY_AKG_CHANNEL3_PTTRACK EQU 0441BH
 128+ 4CF3              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04436H
 129+ 4CF3              PLY_AKG_CHANNEL3_WAIT EQU 04441H
 130+ 4CF3              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04448H
 131+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04448H
 132+ 4CF3              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04448H
 133+ 4CF3              PLY_AKG_CHANNEL3_NOTE EQU 04451H
 134+ 4CF3              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04456H
 135+ 4CF3              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04456H
 136+ 4CF3              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04478H
 137+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04488H
 138+ 4CF3              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044B0H
 139+ 4CF3              PLY_AKG_CHANNEL3_READCELLEND EQU 044B3H
 140+ 4CF3              PLY_AKG_CURRENTSPEED EQU 044B3H
 141+ 4CF3              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B5H
 142+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B8H
 143+ 4CF3              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B8H
 144+ 4CF3              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044BBH
 145+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BEH
 146+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BEH
 147+ 4CF3              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044CAH
 148+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044D1H
 149+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D4H
 150+ 4CF3              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044DAH
 151+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DDH
 152+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DDH
 153+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044EBH
 154+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044F0H
 155+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044FBH
 156+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FEH
 157+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FEH
 158+ 4CF3              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 04501H
 159+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04504H
 160+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04504H
 161+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450DH
 162+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04517H
 163+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 0451AH
 164+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 0451AH
 165+ 4CF3              PLY_AKG_CHANNEL1_PITCH EQU 0451AH
 166+ 4CF3              PLY_AKG_CHANNEL1_ISPITCH EQU 0451DH
 167+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 04522H
 168+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACK EQU 04522H
 169+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04526H
 170+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04528H
 171+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 0452AH
 172+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 04531H
 173+ 4CF3              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 04532H
 174+ 4CF3              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04535H
 175+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04535H
 176+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 04551H
 177+ 4CF3              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 04551H
 178+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455EH
 179+ 4CF3              PLY_AKG_CHANNEL1_GLIDEOVER EQU 04562H
 180+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 04572H
 181+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 04572H
 182+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04573H
 183+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04574H
 184+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04576H
 185+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04576H
 186+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04576H
 187+ 4CF3              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04577H
 188+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04578H
 189+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 0457AH
 190+ 4CF3              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 0457AH
 191+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 0457AH
 192+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 0457AH
 193+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 0457AH
 194+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457DH
 195+ 4CF3              PLY_AKG_CHANNEL1_PITCH_END EQU 0457FH
 196+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04587H
 197+ 4CF3              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04587H
 198+ 4CF3              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 0458AH
 199+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458DH
 200+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458DH
 201+ 4CF3              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04599H
 202+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 045A0H
 203+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A3H
 204+ 4CF3              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A9H
 205+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045ACH
 206+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045ACH
 207+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045BAH
 208+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BFH
 209+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045CAH
 210+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CDH
 211+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CDH
 212+ 4CF3              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045D0H
 213+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D3H
 214+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D3H
 215+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045DCH
 216+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E6H
 217+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E9H
 218+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E9H
 219+ 4CF3              PLY_AKG_CHANNEL2_PITCH EQU 045E9H
 220+ 4CF3              PLY_AKG_CHANNEL2_ISPITCH EQU 045ECH
 221+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045F1H
 222+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045F1H
 223+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F5H
 224+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F7H
 225+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F9H
 226+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 04600H
 227+ 4CF3              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 04601H
 228+ 4CF3              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04604H
 229+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04604H
 230+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 04620H
 231+ 4CF3              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 04620H
 232+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462DH
 233+ 4CF3              PLY_AKG_CHANNEL2_GLIDEOVER EQU 04631H
 234+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 04641H
 235+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 04641H
 236+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 04642H
 237+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04643H
 238+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04645H
 239+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04645H
 240+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04645H
 241+ 4CF3              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04646H
 242+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04647H
 243+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04649H
 244+ 4CF3              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04649H
 245+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04649H
 246+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04649H
 247+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04649H
 248+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_END EQU 0464CH
 249+ 4CF3              PLY_AKG_CHANNEL2_PITCH_END EQU 0464EH
 250+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04656H
 251+ 4CF3              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04656H
 252+ 4CF3              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04659H
 253+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 0465CH
 254+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 0465CH
 255+ 4CF3              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04668H
 256+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466FH
 257+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 04672H
 258+ 4CF3              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04678H
 259+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 0467BH
 260+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 0467BH
 261+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04689H
 262+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468EH
 263+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04699H
 264+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 0469CH
 265+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 0469CH
 266+ 4CF3              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469FH
 267+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 046A2H
 268+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE EQU 046A2H
 269+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046ABH
 270+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B5H
 271+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B8H
 272+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B8H
 273+ 4CF3              PLY_AKG_CHANNEL3_PITCH EQU 046B8H
 274+ 4CF3              PLY_AKG_CHANNEL3_ISPITCH EQU 046BBH
 275+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046C0H
 276+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046C0H
 277+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C4H
 278+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C6H
 279+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C8H
 280+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CFH
 281+ 4CF3              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046D0H
 282+ 4CF3              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D3H
 283+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D3H
 284+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046EFH
 285+ 4CF3              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046EFH
 286+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046FCH
 287+ 4CF3              PLY_AKG_CHANNEL3_GLIDEOVER EQU 04700H
 288+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 04710H
 289+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 04710H
 290+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 04711H
 291+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 04712H
 292+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04714H
 293+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04714H
 294+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04714H
 295+ 4CF3              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04715H
 296+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04716H
 297+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04718H
 298+ 4CF3              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04718H
 299+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04718H
 300+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04718H
 301+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04718H
 302+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_END EQU 0471BH
 303+ 4CF3              PLY_AKG_CHANNEL3_PITCH_END EQU 0471DH
 304+ 4CF3              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04729H
 305+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04729H
 306+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04729H
 307+ 4CF3              PLY_AKG_CHANNEL1_TRACKNOTE EQU 0472CH
 308+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472EH
 309+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04734H
 310+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04737H
 311+ 4CF3              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04737H
 312+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 0473AH
 313+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04743H
 314+ 4CF3              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 0474BH
 315+ 4CF3              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04758H
 316+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04758H
 317+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04758H
 318+ 4CF3              PLY_AKG_CHANNEL2_TRACKNOTE EQU 0475BH
 319+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475DH
 320+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04763H
 321+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04766H
 322+ 4CF3              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04766H
 323+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04769H
 324+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 04772H
 325+ 4CF3              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 0477AH
 326+ 4CF3              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04788H
 327+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04788H
 328+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04788H
 329+ 4CF3              PLY_AKG_CHANNEL3_TRACKNOTE EQU 0478BH
 330+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478DH
 331+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04793H
 332+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04796H
 333+ 4CF3              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04796H
 334+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04799H
 335+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 047A2H
 336+ 4CF3              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047AAH
 337+ 4CF3              PLY_AKG_SENDPSGREGISTERS EQU 047B9H
 338+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047C1H
 339+ 4CF3              PLY_AKG_PSGREG01_INSTR EQU 047C1H
 340+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047D1H
 341+ 4CF3              PLY_AKG_PSGREG23_INSTR EQU 047D1H
 342+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047E2H
 343+ 4CF3              PLY_AKG_PSGREG45_INSTR EQU 047E2H
 344+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F3H
 345+ 4CF3              PLY_AKG_PSGREG6_8_INSTR EQU 047F3H
 346+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04804H
 347+ 4CF3              PLY_AKG_PSGREG9_10_INSTR EQU 04804H
 348+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04815H
 349+ 4CF3              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04815H
 350+ 4CF3              PLY_AKG_PSGREG13_OLDVALUE EQU 0482AH
 351+ 4CF3              PLY_AKG_RETRIG EQU 0482CH
 352+ 4CF3              PLY_AKG_PSGREG13_INSTR EQU 0482EH
 353+ 4CF3              PLY_AKG_PSGREG13_END EQU 0483DH
 354+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483DH
 355+ 4CF3              PLY_AKG_SAVESP EQU 0483DH
 356+ 4CF3              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 04841H
 357+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTS EQU 04849H
 358+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04856H
 359+ 4CF3              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04856H
 360+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485EH
 361+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 0486BH
 362+ 4CF3              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 0486BH
 363+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTS EQU 04873H
 364+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487EH
 365+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS EQU 0487EH
 366+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488DH
 367+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488DH
 368+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04894H
 369+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A4H
 370+ 4CF3              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A4H
 371+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048ABH
 372+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048ABH
 373+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048AEH
 374+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B7H
 375+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B7H
 376+ 4CF3              PLY_AKG_READINSTRUMENTCELL EQU 048BDH
 377+ 4CF3              PLY_AKG_NOSOFTNOHARD EQU 048CAH
 378+ 4CF3              PLY_AKG_NSNH_NONOISE EQU 048DFH
 379+ 4CF3              PLY_AKG_SOFT EQU 048E2H
 380+ 4CF3              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E9H
 381+ 4CF3              PLY_AKG_S_NOTSIMPLE EQU 048F1H
 382+ 4CF3              PLY_AKG_S_AFTERSIMPLETEST EQU 048F4H
 383+ 4CF3              PLY_AKG_HARDTOSOFT EQU 04901H
 384+ 4CF3              PLY_AKG_HS_JUMPRATIO EQU 0490CH
 385+ 4CF3              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04939H
 386+ 4CF3              PLY_AKG_ENDWITHOUTLOOP EQU 0493BH
 387+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 0493BH
 388+ 4CF3              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 0493BH
 389+ 4CF3              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04943H
 390+ 4CF3              PLY_AKG_SH_JUMPRATIO EQU 04950H
 391+ 4CF3              PLY_AKG_SH_JUMPRATIOEND EQU 04971H
 392+ 4CF3              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 04980H
 393+ 4CF3              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04986H
 394+ 4CF3              PLY_AKG_H_OR_ENDWITHLOOP EQU 049A0H
 395+ 4CF3              PLY_AKG_H_RETRIGEND EQU 049B2H
 396+ 4CF3              PLY_AKG_H_AFTERRETRIG EQU 049B3H
 397+ 4CF3              PLY_AKG_ENDWITHLOOP EQU 049C5H
 398+ 4CF3              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049CCH
 399+ 4CF3              PLY_AKG_S_OR_H_NEXTBYTE EQU 049E2H
 400+ 4CF3              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049F0H
 401+ 4CF3              PLY_AKG_S_OR_H_AFTERPITCH EQU 04A00H
 402+ 4CF3              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0EH
 403+ 4CF3              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1DH
 404+ 4CF3              PLY_AKG_SHOHS_RETRIGEND EQU 04A2CH
 405+ 4CF3              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2DH
 406+ 4CF3              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3FH
 407+ 4CF3              PLY_AKG_EFFECTTABLE EQU 04A4DH
 408+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4DH
 409+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A71H
 410+ 4CF3              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A71H
 411+ 4CF3              PLY_AKG_EFFECT_RESET EQU 04A74H
 412+ 4CF3              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A76H
 413+ 4CF3              PLY_AKG_EFFECT_VOLUME EQU 04A91H
 414+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9DH
 415+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA3H
 416+ 4CF3              PLY_AKG_ARPEGGIOSTABLE EQU 04AA3H
 417+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04ACAH
 418+ 4CF3              PLY_AKG_EFFECT_PITCHTABLE EQU 04AD1H
 419+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD7H
 420+ 4CF3              PLY_AKG_PITCHESTABLE EQU 04AD7H
 421+ 4CF3              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFEH
 422+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B05H
 423+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B16H
 424+ 4CF3              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1DH
 425+ 4CF3              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2DH
 426+ 4CF3              PLY_AKG_EFFECT_PITCHUP EQU 04B42H
 427+ 4CF3              PLY_AKG_EFFECT_PITCHSTOP EQU 04B54H
 428+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B5BH
 429+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B85H
 430+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B85H
 431+ 4CF3              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9EH
 432+ 4CF3              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9EH
 433+ 4CF3              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BB0H
 434+ 4CF3              PLY_AKG_EFFECT_LEGATO EQU 04BC6H
 435+ 4CF3              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BDAH
 436+ 4CF3              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BE2H
 437+ 4CF3              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BEAH
 438+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BF2H
 439+ 4CF3              PLY_AKG_EVENT EQU 04BF2H
 440+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF3H
 441+ 4CF3              PLY_AKG_PERIODTABLE EQU 04BF3H
 442+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF3H
 443+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF3H
 444+ 4CF3              PLY_AKG_PERIODTABLE_END EQU 04CF3H
 445+ 4CF3              PLY_AKG_END EQU 04CF3H
 446+ 4CF3              MAIN_PLAYER_END EQU 04CF3H
 447+ 4CF3              TESTEREND EQU 04CF3H
 448+ 4CF3
# file closed: ./symbol/AKG.sym
 124  4CF3               ENDIF
 125  4CF3
 126  4CF3               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
   1+ 4CF3              ORIG.HTIMI:
   2+ 4CF3 00 00 00 00  	DB 0, 0, 0, 0, 0
   2+ 4CF7 00
   3+ 4CF8               EXPORT ORIG.HTIMI
   4+ 4CF8
   5+ 4CF8              ; *******************************************************************************************************
   6+ 4CF8              ; interrupt handler when page 0 enabled
   7+ 4CF8              ; we are here only if one of the extended basic commands have paged in page 0
   8+ 4CF8              ; which means we arrived from BASIC so page 2 is already good
   9+ 4CF8              VBLANK:
  10+ 4CF8              	EXPORT VBLANK
  11+ 4CF8
  12+ 4CF8 F5               PUSH AF
  13+ 4CF9              	; is VDP originator ?
  14+ 4CF9 DB 99        	IN	A, (099H)
  15+ 4CFB A7           	AND	A
  16+ 4CFC F2 23 4D     	JP P, .EXIT
  17+ 4CFF
  18+ 4CFF               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  19+ 4CFF C5               PUSH BC
  20+ 4D00 D5               PUSH DE
  21+ 4D01 E5               PUSH HL
  22+ 4D02 08               EX AF, AF'
  23+ 4D03 D9               EXX
  24+ 4D04 F5               PUSH AF
  25+ 4D05 C5               PUSH BC
  26+ 4D06 D5               PUSH DE
  27+ 4D07 E5               PUSH HL
  28+ 4D08 DD E5            PUSH IX
  29+ 4D0A FD E5            PUSH IY
  30+ 4D0C
  31+ 4D0C               IF (SPRITE_CMDS == 1)
  32+ 4D0C CD 5D 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  33+ 4D0F               ENDIF
  34+ 4D0F
  35+ 4D0F               IF (SOUND_CMDS == 1)
  36+ 4D0F 3A 73 55     	LD A, (SOUND_ENABLED)
  37+ 4D12 B7           	OR A
  38+ 4D13 C4 36 42     	CALL NZ,PLY_AKG_PLAY
  39+ 4D16               ENDIF
  40+ 4D16
  41+ 4D16                  ; increase JIFFY
  42+ 4D16                  ;LD HL,(JIFFY)
  43+ 4D16                  ;INC HL
  44+ 4D16                  ;LD (JIFFY),HL
  45+ 4D16
  46+ 4D16 FD E1            POP IY
  47+ 4D18 DD E1            POP IX
  48+ 4D1A E1               POP HL
  49+ 4D1B D1               POP DE
  50+ 4D1C C1               POP BC
  51+ 4D1D F1               POP AF
  52+ 4D1E 08               EX AF, AF'
  53+ 4D1F D9               EXX
  54+ 4D20 E1               POP HL
  55+ 4D21 D1               POP DE
  56+ 4D22 C1               POP BC
  57+ 4D23               ENDIF
  58+ 4D23
  59+ 4D23              .EXIT:
  60+ 4D23 F1           	POP AF
  61+ 4D24 FB           	EI
  62+ 4D25 ED 4D        	RETI
  63+ 4D27              ; *******************************************************************************************************
  64+ 4D27
  65+ 4D27              ; *******************************************************************************************************
  66+ 4D27              ; H.TIMI function
  67+ 4D27              ; we can end up here from anywhere so page in both page 0 and 2
  68+ 4D27              MBGE_HTIMI:
  69+ 4D27               EXPORT MBGE_HTIMI
  70+ 4D27
  71+ 4D27               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  72+ 4D27
  73+ 4D27 F5           	PUSH AF
  74+ 4D28
  75+ 4D28              	; enable page 2
  76+ 4D28 3E 02            LD A, 2
  77+ 4D2A CD 45 5E         CALL GET_PAGE_INFO
  78+ 4D2D C5               PUSH BC
  79+ 4D2E D5               PUSH DE
  80+ 4D2F 3A 43 F3         LD A, (RAMAD2)
  81+ 4D32 26 80            LD H, 080H
  82+ 4D34 CD 8C 5E         CALL LOCAL_ENASLT
  83+ 4D37              	; enable page 0
  84+ 4D37 AF               XOR A
  85+ 4D38 CD 45 5E         CALL GET_PAGE_INFO
  86+ 4D3B C5               PUSH BC
  87+ 4D3C D5               PUSH DE
  88+ 4D3D 3A 41 F3         LD A, (RAMAD0)
  89+ 4D40 26 00            LD H, 0
  90+ 4D42 CD 8C 5E         CALL LOCAL_ENASLT
  91+ 4D45
  92+ 4D45               IF (SPRITE_CMDS == 1)
  93+ 4D45 CD 5D 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  94+ 4D48               ENDIF
  95+ 4D48
  96+ 4D48               IF (SOUND_CMDS == 1)
  97+ 4D48 3A 73 55     	LD A, (SOUND_ENABLED)
  98+ 4D4B B7           	OR A
  99+ 4D4C C4 36 42     	CALL NZ,PLY_AKG_PLAY
 100+ 4D4F               ENDIF
 101+ 4D4F
 102+ 4D4F              	; restore page 0
 103+ 4D4F D1               POP DE
 104+ 4D50 C1               POP BC
 105+ 4D51 CD 7C 5E         CALL RESTORE_PAGE_INFO
 106+ 4D54              	; restore page 2
 107+ 4D54 D1               POP DE
 108+ 4D55 C1               POP BC
 109+ 4D56 CD 7C 5E         CALL RESTORE_PAGE_INFO
 110+ 4D59
 111+ 4D59 F1           	POP AF
 112+ 4D5A               ENDIF
 113+ 4D5A C3 F3 4C     	JP ORIG.HTIMI
 114+ 4D5D              ; *******************************************************************************************************
 115+ 4D5D
 116+ 4D5D              ; *******************************************************************************************************
 117+ 4D5D              ; function checks if the sprite system is initialized and what screen mode we are running
 118+ 4D5D              ; also checks if some VRAM modifying command is running
 119+ 4D5D              ; when that checks out calls sprite updates and animation processing
 120+ 4D5D              ; if in an unsupported mode disables sprite handling
 121+ 4D5D              PROCESS_SPRITES_AND_ANIMATIONS:
 122+ 4D5D              	; check if initialized
 123+ 4D5D 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
 124+ 4D60 B7           	OR A
 125+ 4D61 C8           	RET Z
 126+ 4D62              	; check screen mode
 127+ 4D62 3A AF FC     	LD A, (SCRMOD)
 128+ 4D65 3D           	DEC A
 129+ 4D66 28 08        	JR Z, .L0 ; screen 1
 130+ 4D68 3D           	DEC A
 131+ 4D69 28 05            JR Z, .L0 ; screen 2
 132+ 4D6B              	; unsupported screen mode, disable
 133+ 4D6B AF               XOR A
 134+ 4D6C 32 7F 4D         LD (SPRATR_INIT_STATUS),A
 135+ 4D6F C9               RET
 136+ 4D70              .L0:
 137+ 4D70                  ; check if anyone else is working with VRAM
 138+ 4D70 3A E2 5D         LD A,(VRAM_UPDATE_IN_PROGRESS)
 139+ 4D73 B7               OR A
 140+ 4D74 C0               RET NZ
 141+ 4D75
 142+ 4D75 CD 95 4D         CALL SPRATR_UPDATE
 143+ 4D78
 144+ 4D78               IF (ANIM_CMDS == 1)
 145+ 4D78 CD D2 52         CALL PROCESS_ANIMATIONS
 146+ 4D7B CD 31 54         CALL PROCESS_AUTOSGAMS
 147+ 4D7E               ENDIF
 148+ 4D7E C9               RET
 149+ 4D7F              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
 127  4D7F
 128  4D7F               IF (SPRITE_CMDS == 1)
 129  4D7F               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4D7F              ; commands and variables related to sprites
   2+ 4D7F
   3+ 4D7F              SPRATR_INIT_STATUS:
   4+ 4D7F 00            DB 0
   5+ 4D80              SPRATR_UPDATE_FLAG:
   6+ 4D80 00 00         DW 0
   7+ 4D82              SPRATR_DATA:
   8+ 4D82 00 00         DW 0
   9+ 4D84              SPRFLICKER_ENABLED:
  10+ 4D84 00            DB 0
  11+ 4D85              ; to support sprite flicker
  12+ 4D85              FLICKER:
  13+ 4D85 00            DB 0
  14+ 4D86              NUM_SPRITES_HANDLED:
  15+ 4D86 20            DB 32
  16+ 4D87
  17+ 4D87              ; to temporarily store stack pointer
  18+ 4D87              TMPSP:
  19+ 4D87 00 00         DW 0
  20+ 4D89
  21+ 4D89              ; *******************************************************************************************************
  22+ 4D89              ; helper function gets pointer to n-th entry in sprite attributes
  23+ 4D89              ; changes HL,DE
  24+ 4D89              GETnthSPRATTR:
  25+ 4D89 26 00            LD H,0
  26+ 4D8B 6F               LD L,A
  27+ 4D8C CD 41 5E         CALL HLx8
  28+ 4D8F ED 5B 82 4D      LD DE,(SPRATR_DATA)
  29+ 4D93 19               ADD HL,DE
  30+ 4D94 C9               RET
  31+ 4D95              ; *******************************************************************************************************
  32+ 4D95
  33+ 4D95              ; *******************************************************************************************************
  34+ 4D95              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  35+ 4D95              ; struct {
  36+ 4D95              ; DW y
  37+ 4D95              ; DW x
  38+ 4D95              ; DW pattern (0-63)
  39+ 4D95              ; DW color
  40+ 4D95              ; } [32]
  41+ 4D95              ; will hide sprites whose location is outside of visible area
  42+ 4D95              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  43+ 4D95              ; modifies AF, AF', BC, DE, HL, IX
  44+ 4D95              SPRATR_UPDATE:
  45+ 4D95              	; check if update requested
  46+ 4D95 2A 80 4D     	LD HL, (SPRATR_UPDATE_FLAG)
  47+ 4D98 7E           	LD A, (HL)
  48+ 4D99 B7           	OR A
  49+ 4D9A C8           	RET Z
  50+ 4D9B
  51+ 4D9B DD 21 86 4D  	LD IX,NUM_SPRITES_HANDLED
  52+ 4D9F DD 46 00     	LD B, (IX) ; sprite number
  53+ 4DA2 0E 98        	LD C, #98 ; register for vdp data output
  54+ 4DA4              	; set VDP address
  55+ 4DA4 3A AF FC         LD A,(SCRMOD)
  56+ 4DA7 3D               DEC A
  57+ 4DA8 20 05            JR NZ,.L4
  58+ 4DAA 2A C3 F3         LD HL, (T32ATR)
  59+ 4DAD 18 03            JR .L5
  60+ 4DAF              .L4:
  61+ 4DAF 2A CD F3         LD HL, (GRPATR)
  62+ 4DB2              .L5:
  63+ 4DB2 3A 84 4D     	LD A, (SPRFLICKER_ENABLED)
  64+ 4DB5 B7           	OR A
  65+ 4DB6 28 03        	JR Z, .L3
  66+ 4DB8 3A 85 4D     	LD A, (FLICKER)
  67+ 4DBB              .L3:
  68+ 4DBB 5F           	LD E, A
  69+ 4DBC 08           	EX AF, AF'
  70+ 4DBD 7B           	LD A, E
  71+ 4DBE 87           	ADD A, A
  72+ 4DBF 87           	ADD A, A
  73+ 4DC0 16 00        	LD D, 0
  74+ 4DC2 5F           	LD E, A
  75+ 4DC3 19           	ADD HL, DE
  76+ 4DC4 CD 22 5E     	CALL SETWRT_LOCAL_WRITE
  77+ 4DC7 ED 73 87 4D  	LD (TMPSP), SP
  78+ 4DCB ED 7B 82 4D  	LD SP, (SPRATR_DATA)
  79+ 4DCF
  80+ 4DCF              .LOOP:
  81+ 4DCF E1           	POP HL
  82+ 4DD0 24           	INC H
  83+ 4DD1 28 0D        	JR Z, .L1 ; negative number between -256 and -1
  84+ 4DD3 25           	DEC H
  85+ 4DD4 20 15        	JR NZ, .OUT3 ; sprite vertically can't be visible
  86+ 4DD6 7D           	LD A, L
  87+ 4DD7 FE C0        	CP 192
  88+ 4DD9 30 10        	JR NC, .OUT3
  89+ 4DDB 3D           	DEC A ; due to VDP rule that top of screen is -1
  90+ 4DDC 57           	LD D, A
  91+ 4DDD C3 04 4E     	JP .X
  92+ 4DE0              .L1:
  93+ 4DE0 7D           	LD A, L
  94+ 4DE1 C6 10        	ADD 16
  95+ 4DE3 FA EB 4D     	JP M, .OUT3 ; below -16
  96+ 4DE6 2D           	DEC L ; due to VDP rule that top of screen is -1
  97+ 4DE7 55           	LD D, L
  98+ 4DE8 C3 04 4E     	JP .X
  99+ 4DEB              .OUT3:
 100+ 4DEB E1           	POP HL ; skip x value
 101+ 4DEC              .OUT2:
 102+ 4DEC E1           	POP HL ; skip pattern
 103+ 4DED E1           	POP HL ; skip color
 104+ 4DEE 3E D1        	LD A, #D1
 105+ 4DF0 ED 79        	OUT (C), A ; sprite hidden
 106+ 4DF2 00          > NOP
 106+ 4DF3 00          > NOP
 106+ 4DF4 00          > NOP
 107+ 4DF5 ED 79        	OUT (C), A ; value unimportant
 108+ 4DF7 00          > NOP
 108+ 4DF8 00          > NOP
 108+ 4DF9 00          > NOP
 109+ 4DFA ED 79        	OUT (C), A ; value unimportant
 110+ 4DFC 00          > NOP
 110+ 4DFD 00          > NOP
 110+ 4DFE 00          > NOP
 111+ 4DFF ED 79        	OUT (C), A ; value unimportant
 112+ 4E01 C3 2F 4E     	JP .NEXT
 113+ 4E04              .X:
 114+ 4E04 E1           	POP HL
 115+ 4E05 24           	INC H
 116+ 4E06 28 08        	JR Z, .L2
 117+ 4E08 25           	DEC H
 118+ 4E09 20 E1        	JR NZ, .OUT2
 119+ 4E0B 1E 00        	LD E, 0 ; EC bit
 120+ 4E0D C3 19 4E     	JP .XY
 121+ 4E10              .L2:
 122+ 4E10 7D           	LD A, L
 123+ 4E11 C6 20        	ADD 32
 124+ 4E13 FA EC 4D     	JP M, .OUT2
 125+ 4E16 6F           	LD L, A
 126+ 4E17 1E 80        	LD E, #80
 127+ 4E19              .XY:
 128+ 4E19 ED 51        	OUT (C), D
 129+ 4E1B 3A E0 F3     	LD A, (REG1SAV)
 130+ 4E1E E6 02        	AND 2
 131+ 4E20 ED 69        	OUT (C), L
 132+ 4E22 E1           	POP HL ; pattern
 133+ 4E23 7D           	LD A, L
 134+ 4E24 28 02        	JR Z, .SMALLSPRITES
 135+ 4E26 87           	ADD A, A
 136+ 4E27 87           	ADD A, A ; needs to go at 4x
 137+ 4E28              .SMALLSPRITES:
 138+ 4E28 D3 98        	OUT (#98), A
 139+ 4E2A E1           	POP HL ; color
 140+ 4E2B 7D           	LD A, L
 141+ 4E2C B3           	OR E
 142+ 4E2D D3 98        	OUT (#98), A
 143+ 4E2F              .NEXT:
 144+ 4E2F 08           	EX AF, AF'
 145+ 4E30 3C           	INC A ; increase current sprite
 146+ 4E31 DD BE 00     	CP (IX) ; compare to maximum handled
 147+ 4E34 C2 54 4E     	JP NZ, .NEXT2 ; continue if not over
 148+ 4E37 AF           	XOR A ; back to zero
 149+ 4E38 08           	EX AF, AF'
 150+ 4E39 3A AF FC         LD A,(SCRMOD)
 151+ 4E3C 3D               DEC A
 152+ 4E3D 20 05            JR NZ,.L6
 153+ 4E3F 2A C3 F3         LD HL, (T32ATR)
 154+ 4E42 18 03            JR .L7
 155+ 4E44              .L6:
 156+ 4E44 2A CD F3         LD HL, (GRPATR)
 157+ 4E47              .L7:
 158+ 4E47              	; CALL SETWRT_LOCAL not allowed as SP modified
 159+ 4E47 7D           	LD	A, L
 160+ 4E48 D3 99        	OUT	(099H), A
 161+ 4E4A 7C           	LD	A, H
 162+ 4E4B E6 3F        	AND	03FH
 163+ 4E4D F6 40        	OR	040H
 164+ 4E4F D3 99        	OUT	(099H), A
 165+ 4E51 C3 55 4E     	JP .NEXT3
 166+ 4E54              .NEXT2:
 167+ 4E54 08           	EX AF, AF'
 168+ 4E55              .NEXT3:
 169+ 4E55 05           	DEC B
 170+ 4E56 C2 CF 4D     	JP NZ, .LOOP
 171+ 4E59 08           	EX AF, AF'
 172+ 4E5A 3C           	INC A ; increase flicker to start at the next one on next vblank
 173+ 4E5B DD BE 00     	CP (IX)
 174+ 4E5E 20 01        	JR NZ,.L8
 175+ 4E60 AF           	XOR A
 176+ 4E61              .L8:
 177+ 4E61 32 85 4D     	LD (FLICKER), A
 178+ 4E64
 179+ 4E64 ED 7B 87 4D  	LD SP, (TMPSP)
 180+ 4E68 2A 80 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 181+ 4E6B 36 00        	LD (HL), 0 ; zero out update flag
 182+ 4E6D C9           	RET
 183+ 4E6E              ; *******************************************************************************************************
 184+ 4E6E
 185+ 4E6E               IF (0 == 1)
 186+ 4E6E ~            ; *******************************************************************************************************
 187+ 4E6E ~            ; function to handle CALL SPRENABLE basic extension
 188+ 4E6E ~            ; initializes sprites handler
 189+ 4E6E ~            ; _SPRENABLE ( INT[3][31] variable sprites_attributes,
 190+ 4E6E ~            ;			   INT variable update_variable,
 191+ 4E6E ~            ;			   BYTE sprite_flicker_enabled,
 192+ 4E6E ~            ;			   BYTE num_sprites_handled )
 193+ 4E6E ~            ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA, SPRFLICKER_ENABLED and NUM_SPRITES_HANDLED
 194+ 4E6E ~            SPRENABLE:
 195+ 4E6E ~            	; opening (
 196+ 4E6E ~            	CALL CHKCHAR
 197+ 4E6E ~            	DB '('
 198+ 4E6E ~            	; get address of sprite attribute table DIM SA%(3,31)
 199+ 4E6E ~            	LD A,2
 200+ 4E6E ~            	LD B,2
 201+ 4E6E ~            	LD DE,#0420
 202+ 4E6E ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
 203+ 4E6E ~            	LD (SPRATR_DATA), BC
 204+ 4E6E ~            	; comma
 205+ 4E6E ~            	CALL CHKCHAR
 206+ 4E6E ~            	DB ','
 207+ 4E6E ~            	; get address of sprite update flag
 208+ 4E6E ~            	LD IX, PTRGET
 209+ 4E6E ~            	CALL CALBAS
 210+ 4E6E ~            	LD (SPRATR_UPDATE_FLAG), DE
 211+ 4E6E ~            	; comma
 212+ 4E6E ~            	CALL CHKCHAR
 213+ 4E6E ~            	DB ','
 214+ 4E6E ~            	; get flicker enabled flag
 215+ 4E6E ~            	LD IX, GETBYT
 216+ 4E6E ~            	CALL CALBAS
 217+ 4E6E ~            	LD (SPRFLICKER_ENABLED), A
 218+ 4E6E ~            	; comma
 219+ 4E6E ~            	CALL CHKCHAR
 220+ 4E6E ~            	DB ','
 221+ 4E6E ~            	; get number of handled sprites
 222+ 4E6E ~            	LD IX, GETBYT
 223+ 4E6E ~            	CALL CALBAS
 224+ 4E6E ~            	LD (NUM_SPRITES_HANDLED),A
 225+ 4E6E ~            	; ending )
 226+ 4E6E ~            	CALL CHKCHAR
 227+ 4E6E ~            	DB ')'
 228+ 4E6E ~            .L0:
 229+ 4E6E ~            	LD A, 1
 230+ 4E6E ~            	LD (SPRATR_INIT_STATUS), A
 231+ 4E6E ~            	RET
 232+ 4E6E ~            ; *******************************************************************************************************
 233+ 4E6E               ENDIF
 234+ 4E6E
 235+ 4E6E               IF (1 == 1)
 236+ 4E6E              ; same as SPRENABLE but for DEFUSR approach
 237+ 4E6E              ; input IX=pointer to input array, real data from +2
 238+ 4E6E              ; +2 = pointer to sprite attributes array data
 239+ 4E6E              ; +4 = pointer to sprite update variable
 240+ 4E6E              ; +6 = flicker flag
 241+ 4E6E              ; +8 = number of sprites to handle
 242+ 4E6E              SPRENABLE_DEFUSR:
 243+ 4E6E DD 6E 02     	LD L,(IX+2)
 244+ 4E71 DD 66 03     	LD H,(IX+3)
 245+ 4E74 22 82 4D     	LD (SPRATR_DATA),HL
 246+ 4E77 DD 6E 04     	LD L,(IX+4)
 247+ 4E7A DD 66 05     	LD H,(IX+5)
 248+ 4E7D 22 80 4D     	LD (SPRATR_UPDATE_FLAG),HL
 249+ 4E80 DD 7E 06     	LD A,(IX+6)
 250+ 4E83 32 84 4D     	LD (SPRFLICKER_ENABLED),A
 251+ 4E86 DD 7E 08     	LD A,(IX+8)
 252+ 4E89 32 86 4D     	LD (NUM_SPRITES_HANDLED),A
 253+ 4E8C               IF (0 == 1)
 254+ 4E8C ~            	JR SPRENABLE.L0
 255+ 4E8C               ELSE
 256+ 4E8C 3E 01        	LD A, 1
 257+ 4E8E 32 7F 4D     	LD (SPRATR_INIT_STATUS), A
 258+ 4E91 C9           	RET
 259+ 4E92               ENDIF
 260+ 4E92               ENDIF
 261+ 4E92
 262+ 4E92               IF (1 + 0 > 0)
 263+ 4E92              ; *******************************************************************************************************
 264+ 4E92              ; function to handle CALL SPRDISABLE basic extension
 265+ 4E92              ; disables sprites handling
 266+ 4E92              ; _SPRDISABLE
 267+ 4E92              ; resets variable SPRATR_INIT_STATUS
 268+ 4E92              SPRDISABLE:
 269+ 4E92              SPRDISABLE_DEFUSR:
 270+ 4E92 AF           	XOR A
 271+ 4E93 32 7F 4D     	LD (SPRATR_INIT_STATUS), A
 272+ 4E96 C9           	RET
 273+ 4E97              ; *******************************************************************************************************
 274+ 4E97               ENDIF
 275+ 4E97
 276+ 4E97              ; *******************************************************************************************************
 277+ 4E97              ; function to handle CALL SPRSET basic extension
 278+ 4E97              ; sets position, and optionally pattern and color of sprite
 279+ 4E97              ; _SPRSET ( BYTE sprite_num , valid 0-31
 280+ 4E97              ;			INT x,
 281+ 4E97              ;			INT y,
 282+ 4E97              ;			INT pattern, valid 0-63, otherwise ignored
 283+ 4E97              ;			INT color, valid 0-15, otherwise ignored
 284+ 4E97              ;SPRSET:
 285+ 4E97              ;	LD A, (SPRATR_INIT_STATUS)
 286+ 4E97              ;	OR A
 287+ 4E97              ;	JR NZ, .L1
 288+ 4E97              ;	LD E, 5 ; illegal function call
 289+ 4E97              ;	JP THROW_ERROR
 290+ 4E97              ;.L1:
 291+ 4E97              ;	; opening (
 292+ 4E97              ;	CALL CHKCHAR
 293+ 4E97              ;	DB '('
 294+ 4E97              ;	; get sprite number
 295+ 4E97              ;	LD IX, GETBYT
 296+ 4E97              ;	CALL CALBAS
 297+ 4E97              ;	PUSH AF
 298+ 4E97              ;	; comma
 299+ 4E97              ;	CALL CHKCHAR
 300+ 4E97              ;	DB ','
 301+ 4E97              ;	; get x
 302+ 4E97              ;	LD IX, FRMQNT
 303+ 4E97              ;	CALL CALBAS
 304+ 4E97              ;	PUSH DE
 305+ 4E97              ;	; comma
 306+ 4E97              ;	CALL CHKCHAR
 307+ 4E97              ;	DB ','
 308+ 4E97              ;	; get y
 309+ 4E97              ;	LD IX, FRMQNT
 310+ 4E97              ;	CALL CALBAS
 311+ 4E97              ;	PUSH DE
 312+ 4E97              ;	; comma
 313+ 4E97              ;	CALL CHKCHAR
 314+ 4E97              ;	DB ','
 315+ 4E97              ;	; get pattern
 316+ 4E97              ;	LD IX, FRMQNT
 317+ 4E97              ;	CALL CALBAS
 318+ 4E97              ;	PUSH DE
 319+ 4E97              ;	; comma
 320+ 4E97              ;	CALL CHKCHAR
 321+ 4E97              ;	DB ','
 322+ 4E97              ;	; get color
 323+ 4E97              ;	LD IX, FRMQNT
 324+ 4E97              ;	CALL CALBAS
 325+ 4E97              ;	PUSH DE
 326+ 4E97              ;	; ending )
 327+ 4E97              ;	CALL CHKCHAR
 328+ 4E97              ;	DB ')'
 329+ 4E97              ;
 330+ 4E97              ;   ; save position in BASIC text
 331+ 4E97              ;	PUSH HL
 332+ 4E97              ;	POP IX
 333+ 4E97              ;
 334+ 4E97              ;	POP BC ; color
 335+ 4E97              ;	POP DE ; pattern
 336+ 4E97              ;	EXX
 337+ 4E97              ;	POP BC ; y
 338+ 4E97              ;	POP DE ; x
 339+ 4E97              ;	POP AF ; sprite number
 340+ 4E97              ;	CP 32
 341+ 4E97              ;	JR C, .L2
 342+ 4E97              ;	LD E, 5 ; illegal function call
 343+ 4E97              ;	JP THROW_ERROR
 344+ 4E97              ;.L2:
 345+ 4E97              ;	; find location in sprite attributes table
 346+ 4E97              ;	PUSH DE
 347+ 4E97              ;	CALL GETnthSPRATTR
 348+ 4E97              ;	POP DE
 349+ 4E97              ;	DI
 350+ 4E97              ;	; set y
 351+ 4E97              ;	LD (HL), C
 352+ 4E97              ;	INC HL
 353+ 4E97              ;	LD (HL), B
 354+ 4E97              ;	INC HL
 355+ 4E97              ;	; set x
 356+ 4E97              ;	LD (HL), E
 357+ 4E97              ;	INC HL
 358+ 4E97              ;	LD (HL), D
 359+ 4E97              ;	INC HL
 360+ 4E97              ;	PUSH HL
 361+ 4E97              ;	EXX
 362+ 4E97              ;	POP HL
 363+ 4E97              ;	; check if 0<=pattern<64
 364+ 4E97              ;	LD A, D
 365+ 4E97              ;	OR A
 366+ 4E97              ;	JR NZ, .L3
 367+ 4E97              ;	LD A, E
 368+ 4E97              ;	CP 64
 369+ 4E97              ;	JR NC, .L3
 370+ 4E97              ;	; set pattern
 371+ 4E97              ;	;ADD A, A
 372+ 4E97              ;	;ADD A, A
 373+ 4E97              ;	;ADD A, A
 374+ 4E97              ;	LD (HL), A
 375+ 4E97              ;	INC HL
 376+ 4E97              ;	LD (HL), D
 377+ 4E97              ;	INC HL
 378+ 4E97              ;	JR .L4
 379+ 4E97              ;.L3:
 380+ 4E97              ;	; skip pattern
 381+ 4E97              ;	.2 INC HL
 382+ 4E97              ;.L4:
 383+ 4E97              ;	; check if 0<=color<16
 384+ 4E97              ;	LD A, B
 385+ 4E97              ;	OR A
 386+ 4E97              ;	JR NZ, .L5
 387+ 4E97              ;	LD A, C
 388+ 4E97              ;	CP 16
 389+ 4E97              ;	JR NC, .L5
 390+ 4E97              ;	; set color
 391+ 4E97              ;	LD (HL), C
 392+ 4E97              ;	INC HL
 393+ 4E97              ;	LD (HL), B
 394+ 4E97              ;
 395+ 4E97              ;.L5:
 396+ 4E97              ;	EI
 397+ 4E97              ;	PUSH IX
 398+ 4E97              ;	POP HL
 399+ 4E97              ;	RET
 400+ 4E97              ; *******************************************************************************************************
 401+ 4E97
 402+ 4E97              ; *******************************************************************************************************
 403+ 4E97              ; function sets sprite location based on initial coordinates and offset provided
 404+ 4E97              ; input A=sprite number in SPRATR_DATA , 0-31
 405+ 4E97              ; input DE=initial x
 406+ 4E97              ; input BC=initial y
 407+ 4E97              ; input IY=location where delta y,x are located
 408+ 4E97              ; modifies AF, HL, IX
 409+ 4E97              SPRSET_DELTA_POS:
 410+ 4E97 D5           	PUSH DE
 411+ 4E98 CD 89 4D     	CALL GETnthSPRATTR
 412+ 4E9B E5           	PUSH HL
 413+ 4E9C DD E1        	POP IX
 414+ 4E9E D1           	POP DE
 415+ 4E9F              	; IX=sprite's y location
 416+ 4E9F FD 6E 00     	LD L, (IY)
 417+ 4EA2 FD 66 01     	LD H, (IY+1)
 418+ 4EA5 09           	ADD HL, BC
 419+ 4EA6 DD 75 00     	LD (IX), L
 420+ 4EA9 DD 74 01     	LD (IX+1), H
 421+ 4EAC FD 6E 02     	LD L, (IY+2)
 422+ 4EAF FD 66 03     	LD H, (IY+3)
 423+ 4EB2 19           	ADD HL, DE
 424+ 4EB3 DD 75 02     	LD (IX+2), L
 425+ 4EB6 DD 74 03     	LD (IX+3), H
 426+ 4EB9 C9           	RET
 427+ 4EBA              ; *******************************************************************************************************
 428+ 4EBA
 429+ 4EBA              ; *******************************************************************************************************
 430+ 4EBA              ; helper function to set new locations for a set of sprites
 431+ 4EBA              ; input B=number of sprites
 432+ 4EBA              ; HL=pointer to list of sprites and offsets
 433+ 4EBA              SPR_UPDATE_LOC:
 434+ 4EBA 3E 01        	LD A,1
 435+ 4EBC 32 E2 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 436+ 4EBF 7E           	LD A, (HL)
 437+ 4EC0 23           	INC HL
 438+ 4EC1 23           	INC HL
 439+ 4EC2 E5           	PUSH HL
 440+ 4EC3 FD E1        	POP IY
 441+ 4EC5 D9           	EXX
 442+ 4EC6 CD 97 4E     	CALL SPRSET_DELTA_POS
 443+ 4EC9 D9           	EXX
 444+ 4ECA 23          > INC HL
 444+ 4ECB 23          > INC HL
 444+ 4ECC 23          > INC HL
 444+ 4ECD 23          > INC HL
 445+ 4ECE 10 EA        	DJNZ SPR_UPDATE_LOC
 446+ 4ED0 AF           	XOR A
 447+ 4ED1 32 E2 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 448+ 4ED4 C9           	RET
 449+ 4ED5              ; *******************************************************************************************************
 450+ 4ED5
 451+ 4ED5               IF (0 == 1)
 452+ 4ED5 ~            ; *******************************************************************************************************
 453+ 4ED5 ~            ; function to handle CALL SPRGRPMOV basic extension
 454+ 4ED5 ~            ; sets position of a group of sprites described with
 455+ 4ED5 ~            ; { int sprite_num, int delta_y, int delta_x } [count]
 456+ 4ED5 ~            ; _SPRGRPMOV ( INT x,
 457+ 4ED5 ~            ;			   INT y,
 458+ 4ED5 ~            ;			   BYTE count,
 459+ 4ED5 ~            ;			   INT[2][count] data_ptr
 460+ 4ED5 ~            SPRGRPMOV:
 461+ 4ED5 ~            	LD A, (SPRATR_INIT_STATUS)
 462+ 4ED5 ~            	OR A
 463+ 4ED5 ~            	JP Z,ILLEGAL_FUNCTION
 464+ 4ED5 ~            	; opening (
 465+ 4ED5 ~            	CALL CHKCHAR
 466+ 4ED5 ~            	DB '('
 467+ 4ED5 ~            	; get x
 468+ 4ED5 ~            	LD IX, FRMQNT
 469+ 4ED5 ~            	CALL CALBAS
 470+ 4ED5 ~            	LD (BLIT_STRUCT),DE
 471+ 4ED5 ~            	; comma
 472+ 4ED5 ~            	CALL CHKCHAR
 473+ 4ED5 ~            	DB ','
 474+ 4ED5 ~            	; get y
 475+ 4ED5 ~            	LD IX, FRMQNT
 476+ 4ED5 ~            	CALL CALBAS
 477+ 4ED5 ~            	LD (BLIT_STRUCT+2),DE
 478+ 4ED5 ~            	; comma
 479+ 4ED5 ~            	CALL CHKCHAR
 480+ 4ED5 ~            	DB ','
 481+ 4ED5 ~            	; get count
 482+ 4ED5 ~            	LD IX, GETBYT
 483+ 4ED5 ~            	CALL CALBAS
 484+ 4ED5 ~            	LD (BLIT_STRUCT+4),A
 485+ 4ED5 ~            	; comma
 486+ 4ED5 ~            	CALL CHKCHAR
 487+ 4ED5 ~            	DB ','
 488+ 4ED5 ~            	; get sprite group definition array data pointer
 489+ 4ED5 ~            	LD A,(BLIT_STRUCT+4)
 490+ 4ED5 ~            	LD E,A
 491+ 4ED5 ~            	LD D,3
 492+ 4ED5 ~            	LD A,2
 493+ 4ED5 ~            	LD B,A
 494+ 4ED5 ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
 495+ 4ED5 ~            	LD (BLIT_STRUCT+5),BC
 496+ 4ED5 ~            	; ending )
 497+ 4ED5 ~            	CALL CHKCHAR
 498+ 4ED5 ~            	DB ')'
 499+ 4ED5 ~
 500+ 4ED5 ~            	PUSH HL
 501+ 4ED5 ~
 502+ 4ED5 ~                EXX
 503+ 4ED5 ~                LD DE,(BLIT_STRUCT) ; initial x
 504+ 4ED5 ~                LD BC,(BLIT_STRUCT+2) ; initial y
 505+ 4ED5 ~                EXX
 506+ 4ED5 ~                LD HL,(BLIT_STRUCT+5) ; pointer to data
 507+ 4ED5 ~                LD A,(BLIT_STRUCT+4) ; number of entries
 508+ 4ED5 ~                LD B,A
 509+ 4ED5 ~            	CALL SPR_UPDATE_LOC
 510+ 4ED5 ~
 511+ 4ED5 ~            	POP HL
 512+ 4ED5 ~            	RET
 513+ 4ED5 ~            ; *******************************************************************************************************
 514+ 4ED5               ENDIF
 515+ 4ED5
 516+ 4ED5               IF (1 == 1)
 517+ 4ED5              ; *******************************************************************************************************
 518+ 4ED5              ; same as SPRGRPMOV but for DEFUSR approach
 519+ 4ED5              ; input IX=pointer to input array, real data from +2
 520+ 4ED5              ; +2 = X
 521+ 4ED5              ; +4 = Y
 522+ 4ED5              ; +6 = count
 523+ 4ED5              ; +8 = data pointer
 524+ 4ED5              SPRGRPMOV_DEFUSR:
 525+ 4ED5 D9               EXX
 526+ 4ED6 DD 5E 02     	LD E,(IX+2)
 527+ 4ED9 DD 56 03     	LD D,(IX+3) ; initial x
 528+ 4EDC DD 4E 04     	LD C,(IX+4)
 529+ 4EDF DD 46 05     	LD B,(IX+5) ; initial y
 530+ 4EE2 D9               EXX
 531+ 4EE3 DD 6E 08     	LD L,(IX+8)
 532+ 4EE6 DD 66 09     	LD H,(IX+9) ; pointer to data
 533+ 4EE9 DD 46 06         LD B,(IX+6) ; count
 534+ 4EEC C3 BA 4E         JP SPR_UPDATE_LOC
 535+ 4EEF              ; *******************************************************************************************************
 536+ 4EEF               ENDIF
# file closed: asm\SPRITES.asm
 130  4EEF               ENDIF
 131  4EEF
 132  4EEF               IF (ANIM_CMDS == 1)
 133  4EEF               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4EEF              ; sprite animation routines
   2+ 4EEF
   3+ 4EEF              ; number of animation items and pointer
   4+ 4EEF              ANIMITEMNUM:
   5+ 4EEF 00            DB 0
   6+ 4EF0              ANIMITEMPTR:
   7+ 4EF0 C2 5F         DW EXT_END
   8+ 4EF2              ; number of animation definitions and pointer
   9+ 4EF2              ANIMDEFNUM:
  10+ 4EF2 00            DB 0
  11+ 4EF3              ANIMDEFPTR:
  12+ 4EF3 C2 5F         DW EXT_END
  13+ 4EF5              ; number of links between sprite and animation definitions
  14+ 4EF5              ANIMSPRNUM:
  15+ 4EF5 00            DB 0
  16+ 4EF6              ANIMSPRPTR:
  17+ 4EF6 C2 5F         DW EXT_END
  18+ 4EF8              ; number of automatic sprite group move and animate structures
  19+ 4EF8              AUTOSGAMNUM:
  20+ 4EF8 00            DB 0
  21+ 4EF9              AUTOSGAMPTR:
  22+ 4EF9 C2 5F         DW EXT_END
  23+ 4EFB
  24+ 4EFB              ; ANIMATION ITEM
  25+ 4EFB              ; byte type = [0 - pattern and color change
  26+ 4EFB              ;              1 - pattern definition change ]
  27+ 4EFB              ; word ticks - number of ticks to hold this state
  28+ 4EFB              ; for type = 0
  29+ 4EFB              ;   byte pattern;
  30+ 4EFB              ;   byte color;
  31+ 4EFB              ; for type = 1
  32+ 4EFB              ;   work data_pointer;
  33+ 4EFB              ; total size = 5b
  34+ 4EFB
  35+ 4EFB              ; ANIMATION DEFINITION
  36+ 4EFB              ; byte number of items 1-15
  37+ 4EFB              ; byte[15] anim_item;
  38+ 4EFB              ; total size = 16b
  39+ 4EFB
  40+ 4EFB              ; SPRITE/CHAR ANIMATION
  41+ 4EFB              ; +00 byte sprite/char number;
  42+ 4EFB              ; +01 word time;
  43+ 4EFB              ; +03 byte current item;
  44+ 4EFB              ; +04 byte animation definition;
  45+ 4EFB              ; +05 byte cyclic;
  46+ 4EFB              ; +06 byte active;
  47+ 4EFB              ; +07 byte 0=sprite, 1-3 character bank
  48+ 4EFB              ; total size = 8b
  49+ 4EFB
  50+ 4EFB              ; AUTOMATIC SPRITE GROUP MOVE AND ANIMATE structure
  51+ 4EFB              ; +00 pointer to X variable
  52+ 4EFB              ; +02 pointer to Y variable
  53+ 4EFB              ; +04 minimum value
  54+ 4EFB              ; +06 maximal value
  55+ 4EFB              ; +08 delta value
  56+ 4EFB              ; +10 direction 0=horizontal, <>0 = vertical
  57+ 4EFB              ; +11 sprite group size
  58+ 4EFB              ; +12 sprite group pointer
  59+ 4EFB              ; +14 animation list size
  60+ 4EFB              ; +15 animation list pointer for negative delta values
  61+ 4EFB              ; +17 animation list pointer for positive delta values
  62+ 4EFB              ; +19 active flag
  63+ 4EFB              ; +20 ticks for movement
  64+ 4EFB              ; +22 timer
  65+ 4EFB              ; total = 24b
  66+ 4EFB
  67+ 4EFB              ; *******************************************************************************************************
  68+ 4EFB              ; helper function HL=A*5
  69+ 4EFB              ; changes HL,DE
  70+ 4EFB              Ax5:
  71+ 4EFB 26 00            LD H,0
  72+ 4EFD 6F               LD L,A
  73+ 4EFE 54               LD D,H
  74+ 4EFF 5D               LD E,L
  75+ 4F00 29               ADD HL,HL
  76+ 4F01 29               ADD HL,HL
  77+ 4F02 19               ADD HL,DE
  78+ 4F03 C9               RET
  79+ 4F04              ; *******************************************************************************************************
  80+ 4F04
  81+ 4F04              ; *******************************************************************************************************
  82+ 4F04              ; helper function gets pointer to n-th animation item
  83+ 4F04              ; changes HL,DE
  84+ 4F04              GETnthANIMITEM:
  85+ 4F04 CD FB 4E         CALL Ax5
  86+ 4F07 ED 5B F0 4E      LD DE,(ANIMITEMPTR)
  87+ 4F0B 19               ADD HL,DE
  88+ 4F0C C9               RET
  89+ 4F0D              ; *******************************************************************************************************
  90+ 4F0D
  91+ 4F0D              ; *******************************************************************************************************
  92+ 4F0D              ; helper function gets pointer to n-th entry in animation definition
  93+ 4F0D              ; changes HL,DE
  94+ 4F0D              GETnthANIMDEF:
  95+ 4F0D 26 00            LD H,0
  96+ 4F0F 6F               LD L,A
  97+ 4F10 CD 40 5E         CALL HLx16
  98+ 4F13 ED 5B F3 4E      LD DE,(ANIMDEFPTR)
  99+ 4F17 19               ADD HL,DE
 100+ 4F18 C9               RET
 101+ 4F19              ; *******************************************************************************************************
 102+ 4F19
 103+ 4F19              ; *******************************************************************************************************
 104+ 4F19              ; helper function gets pointer to n-th entry in sprite animation
 105+ 4F19              ; changes HL,DE
 106+ 4F19              GETnthSPRANIM:
 107+ 4F19 26 00            LD H,0
 108+ 4F1B 6F               LD L,A
 109+ 4F1C CD 41 5E         CALL HLx8
 110+ 4F1F ED 5B F6 4E      LD DE,(ANIMSPRPTR)
 111+ 4F23 19               ADD HL,DE
 112+ 4F24 C9               RET
 113+ 4F25              ; *******************************************************************************************************
 114+ 4F25
 115+ 4F25              ; *******************************************************************************************************
 116+ 4F25              ; helper function gets pointer to n-th entry in autosgam table
 117+ 4F25              ; changes HL,DE
 118+ 4F25              GETnthAUTOSGAM:
 119+ 4F25 26 00            LD H,0
 120+ 4F27 6F               LD L,A
 121+ 4F28 CD 41 5E         CALL HLx8
 122+ 4F2B 54               LD D,H
 123+ 4F2C 5D               LD E,L
 124+ 4F2D 29               ADD HL,HL
 125+ 4F2E 19               ADD HL,DE
 126+ 4F2F ED 5B F9 4E      LD DE,(AUTOSGAMPTR)
 127+ 4F33 19               ADD HL,DE
 128+ 4F34 C9               RET
 129+ 4F35              ; *******************************************************************************************************
 130+ 4F35
 131+ 4F35               IF (1 == 1)
 132+ 4F35              ; *******************************************************************************************************
 133+ 4F35              ; same as MAXIANIMITEMS but for DEFUSR approach
 134+ 4F35              ; input IX=pointer to input array, real data from +2
 135+ 4F35              ; +2 = number
 136+ 4F35              MAXANIMITEMS_DEFUSR:
 137+ 4F35 DD 7E 02         LD A,(IX+2)
 138+ 4F38 18 00            JR MAXANIMITEMS.COMMON
 139+ 4F3A              ; *******************************************************************************************************
 140+ 4F3A               ENDIF
 141+ 4F3A
 142+ 4F3A              ; *******************************************************************************************************
 143+ 4F3A              ; function to handle CALL MAXANIMITEMS basic extension
 144+ 4F3A              ; MAXANIMITEMS (BYTE number)
 145+ 4F3A              ; sets new number and moves memory buffers as needed
 146+ 4F3A              MAXANIMITEMS:
 147+ 4F3A               IF (0 == 1)
 148+ 4F3A ~            	; opening (
 149+ 4F3A ~            	CALL CHKCHAR
 150+ 4F3A ~            	DB '('
 151+ 4F3A ~            	; get value
 152+ 4F3A ~            	LD IX, GETBYT
 153+ 4F3A ~            	CALL CALBAS
 154+ 4F3A ~                PUSH AF
 155+ 4F3A ~            	; ending )
 156+ 4F3A ~            	CALL CHKCHAR
 157+ 4F3A ~            	DB ')'
 158+ 4F3A ~                POP AF
 159+ 4F3A               ENDIF
 160+ 4F3A              .COMMON: ; entry for DEFUSR part, A=number
 161+ 4F3A F3               DI
 162+ 4F3B              	; save position
 163+ 4F3B E5           	PUSH HL
 164+ 4F3C              .ENTRY:
 165+ 4F3C 47               LD B,A
 166+ 4F3D 3A EF 4E         LD A,(ANIMITEMNUM)
 167+ 4F40 90               SUB B
 168+ 4F41 28 28            JR Z, .EXIT; same value as before
 169+ 4F43 FD 21 F3 4E      LD IY,ANIMDEFPTR
 170+ 4F47 FA 6E 4F         JP M, .INCREASE
 171+ 4F4A                  ; new value is lower than previous one
 172+ 4F4A CD 8D 4F         CALL .SIZEDIFF
 173+ 4F4D CD A8 4F         CALL .DECREASE_COMMON
 174+ 4F50 2A F6 4E         LD HL,(ANIMSPRPTR)
 175+ 4F53 AF               XOR A
 176+ 4F54 ED 42            SBC HL,BC
 177+ 4F56 22 F6 4E         LD (ANIMSPRPTR),HL
 178+ 4F59              .E1:
 179+ 4F59 2A F9 4E         LD HL,(AUTOSGAMPTR)
 180+ 4F5C AF               XOR A
 181+ 4F5D ED 42            SBC HL,BC
 182+ 4F5F 22 F9 4E         LD (AUTOSGAMPTR),HL
 183+ 4F62              .E3:
 184+ 4F62 2A 10 40         LD HL,(FREEMEMPTR)
 185+ 4F65 AF               XOR A
 186+ 4F66 ED 42            SBC HL,BC
 187+ 4F68 22 10 40         LD (FREEMEMPTR),HL
 188+ 4F6B              .EXIT:
 189+ 4F6B FB               EI
 190+ 4F6C E1           	POP HL
 191+ 4F6D C9           	RET
 192+ 4F6E              .INCREASE:
 193+ 4F6E ED 44            NEG
 194+ 4F70 CD 8D 4F         CALL .SIZEDIFF
 195+ 4F73 CD D4 4F         CALL .INCREASE_COMMON
 196+ 4F76 2A F6 4E         LD HL,(ANIMSPRPTR)
 197+ 4F79 09               ADD HL,BC
 198+ 4F7A 22 F6 4E         LD (ANIMSPRPTR),HL
 199+ 4F7D              .E2:
 200+ 4F7D 2A F9 4E         LD HL,(AUTOSGAMPTR)
 201+ 4F80 09               ADD HL,BC
 202+ 4F81 22 F9 4E         LD (AUTOSGAMPTR),HL
 203+ 4F84              .E4:
 204+ 4F84 2A 10 40         LD HL,(FREEMEMPTR)
 205+ 4F87 09               ADD HL,BC
 206+ 4F88 22 10 40         LD (FREEMEMPTR),HL
 207+ 4F8B 18 DE            JR .EXIT
 208+ 4F8D              .SIZEDIFF:
 209+ 4F8D CD FB 4E         CALL Ax5
 210+ 4F90 78               LD A,B
 211+ 4F91 32 EF 4E         LD (ANIMITEMNUM),A
 212+ 4F94 44               LD B,H
 213+ 4F95 4D               LD C,L
 214+ 4F96 C9               RET ; BC=size difference in bytes
 215+ 4F97              .SIZETOMOVE:
 216+ 4F97 D5               PUSH DE
 217+ 4F98 2A 10 40         LD HL,(FREEMEMPTR)
 218+ 4F9B FD 5E 00         LD E,(IY)
 219+ 4F9E FD 56 01         LD D,(IY+1)
 220+ 4FA1 AF               XOR A
 221+ 4FA2 ED 52            SBC HL,DE
 222+ 4FA4 44               LD B,H
 223+ 4FA5 4D               LD C,L
 224+ 4FA6 D1               POP DE
 225+ 4FA7 C9               RET
 226+ 4FA8              .DECREASE_COMMON:
 227+ 4FA8 FD 6E 00         LD L,(IY)
 228+ 4FAB FD 66 01         LD H,(IY+1)
 229+ 4FAE AF               XOR A
 230+ 4FAF ED 42            SBC HL,BC
 231+ 4FB1 EB               EX DE,HL
 232+ 4FB2 C5               PUSH BC
 233+ 4FB3 CD 97 4F         CALL .SIZETOMOVE
 234+ 4FB6 F3               DI
 235+ 4FB7 78               LD A,B
 236+ 4FB8 B1               OR C
 237+ 4FB9 28 08            JR Z,.L1
 238+ 4FBB FD 6E 00         LD L,(IY)
 239+ 4FBE FD 66 01         LD H,(IY+1)
 240+ 4FC1 ED B0            LDIR
 241+ 4FC3              .L1:
 242+ 4FC3 C1               POP BC
 243+ 4FC4 FD 6E 00         LD L,(IY)
 244+ 4FC7 FD 66 01         LD H,(IY+1)
 245+ 4FCA AF               XOR A
 246+ 4FCB ED 42            SBC HL,BC
 247+ 4FCD FD 75 00         LD (IY),L
 248+ 4FD0 FD 74 01         LD (IY+1),H
 249+ 4FD3 C9               RET
 250+ 4FD4              .INCREASE_COMMON:
 251+ 4FD4 2A 10 40         LD HL,(FREEMEMPTR)
 252+ 4FD7 2B               DEC HL
 253+ 4FD8 AF               XOR A
 254+ 4FD9 ED 42            SBC HL,BC
 255+ 4FDB EB               EX DE,HL
 256+ 4FDC C5               PUSH BC
 257+ 4FDD CD 97 4F         CALL .SIZETOMOVE
 258+ 4FE0 F3               DI
 259+ 4FE1 78               LD A,B
 260+ 4FE2 B1               OR C
 261+ 4FE3 28 06            JR Z,.L2
 262+ 4FE5 2A 10 40         LD HL,(FREEMEMPTR)
 263+ 4FE8 2B               DEC HL
 264+ 4FE9 ED B8            LDDR
 265+ 4FEB              .L2:
 266+ 4FEB C1               POP BC
 267+ 4FEC FD 6E 00         LD L,(IY)
 268+ 4FEF FD 66 01         LD H,(IY+1)
 269+ 4FF2 09               ADD HL,BC
 270+ 4FF3 FD 75 00         LD (IY),L
 271+ 4FF6 FD 74 01         LD (IY+1),H
 272+ 4FF9 C9               RET
 273+ 4FFA              ; *******************************************************************************************************
 274+ 4FFA
 275+ 4FFA               IF (0 == 1)
 276+ 4FFA ~            ; *******************************************************************************************************
 277+ 4FFA ~            ; function to handle CALL ANIMITEMPAT basic extension
 278+ 4FFA ~            ; ANIMITEMPAT ( BYTE id,
 279+ 4FFA ~            ;               INT ticks >0,
 280+ 4FFA ~            ;               BYTE pattern,
 281+ 4FFA ~            ;               BYTE color )
 282+ 4FFA ~            ; fills animation item data, returns an error if ID out of bounds
 283+ 4FFA ~            ANIMITEMPAT:
 284+ 4FFA ~                ; opening (
 285+ 4FFA ~            	CALL CHKCHAR
 286+ 4FFA ~            	DB '('
 287+ 4FFA ~            	; get id
 288+ 4FFA ~            	LD IX, GETBYT
 289+ 4FFA ~            	CALL CALBAS
 290+ 4FFA ~                PUSH AF
 291+ 4FFA ~                ; check if out of bounds
 292+ 4FFA ~                INC A
 293+ 4FFA ~                LD C,A
 294+ 4FFA ~                LD A,(ANIMITEMNUM)
 295+ 4FFA ~                CP C
 296+ 4FFA ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 297+ 4FFA ~            	; comma
 298+ 4FFA ~            	CALL CHKCHAR
 299+ 4FFA ~            	DB ','
 300+ 4FFA ~            	; get ticks
 301+ 4FFA ~            	LD IX, FRMQNT
 302+ 4FFA ~            	CALL CALBAS
 303+ 4FFA ~                LD A,D
 304+ 4FFA ~                OR E
 305+ 4FFA ~                JP Z, OVERFLOW
 306+ 4FFA ~            	PUSH DE
 307+ 4FFA ~            	; comma
 308+ 4FFA ~            	CALL CHKCHAR
 309+ 4FFA ~            	DB ','
 310+ 4FFA ~            	; get pattern
 311+ 4FFA ~            	LD IX, GETBYT
 312+ 4FFA ~            	CALL CALBAS
 313+ 4FFA ~                PUSH AF
 314+ 4FFA ~            	; comma
 315+ 4FFA ~            	CALL CHKCHAR
 316+ 4FFA ~            	DB ','
 317+ 4FFA ~            	; get color
 318+ 4FFA ~            	LD IX, GETBYT
 319+ 4FFA ~            	CALL CALBAS
 320+ 4FFA ~                PUSH AF
 321+ 4FFA ~            	; ending )
 322+ 4FFA ~            	CALL CHKCHAR
 323+ 4FFA ~            	DB ')'
 324+ 4FFA ~            .ENTRY:
 325+ 4FFA ~                PUSH HL
 326+ 4FFA ~                POP IX
 327+ 4FFA ~                EXX
 328+ 4FFA ~                POP BC ; color
 329+ 4FFA ~                POP DE ; pattern
 330+ 4FFA ~                POP HL ; ticks
 331+ 4FFA ~                EXX
 332+ 4FFA ~                POP AF
 333+ 4FFA ~                CALL GETnthANIMITEM
 334+ 4FFA ~                PUSH HL
 335+ 4FFA ~                POP IY
 336+ 4FFA ~                EXX
 337+ 4FFA ~                LD (IY),0 ; type=0
 338+ 4FFA ~                LD (IY+1),L
 339+ 4FFA ~                LD (IY+2),H
 340+ 4FFA ~                LD (IY+3),D
 341+ 4FFA ~                LD (IY+4),B
 342+ 4FFA ~
 343+ 4FFA ~                PUSH IX
 344+ 4FFA ~                POP HL
 345+ 4FFA ~                RET
 346+ 4FFA ~            ; *******************************************************************************************************
 347+ 4FFA               ENDIF
 348+ 4FFA
 349+ 4FFA               IF (1 == 1)
 350+ 4FFA              ; *******************************************************************************************************
 351+ 4FFA              ; same as ANIMITEMPAT but for DEFUSR approach
 352+ 4FFA              ; input IX=pointer to input array, real data from +2
 353+ 4FFA              ; +02 = ID
 354+ 4FFA              ; +04 = ticks
 355+ 4FFA              ; +06 = pattern
 356+ 4FFA              ; +08 = color
 357+ 4FFA              ANIMITEMPAT_DEFUSR:
 358+ 4FFA                  ; check if out of bounds
 359+ 4FFA DD 4E 02         LD C,(IX+2)
 360+ 4FFD 0C               INC C
 361+ 4FFE 3A EF 4E         LD A,(ANIMITEMNUM)
 362+ 5001 B9               CP C
 363+ 5002 D8               RET C ; out of bounds, prevent memory corruption
 364+ 5003 79               LD A,C
 365+ 5004 3D               DEC A
 366+ 5005 CD 04 4F         CALL GETnthANIMITEM
 367+ 5008 36 00            LD (HL),0 ; type=0
 368+ 500A 23               INC HL
 369+ 500B DD 7E 04         LD A,(IX+4) ; ticks low
 370+ 500E 77               LD (HL),A
 371+ 500F 23               INC HL
 372+ 5010 DD 7E 05         LD A,(IX+5) ; ticks high
 373+ 5013 77               LD (HL),A
 374+ 5014 23               INC HL
 375+ 5015 DD 7E 06         LD A,(IX+6) ; pattern
 376+ 5018 77               LD (HL),A
 377+ 5019 23               INC HL
 378+ 501A DD 7E 08         LD A,(IX+8) ; color
 379+ 501D 77               LD (HL),A
 380+ 501E C9               RET
 381+ 501F              ; *******************************************************************************************************
 382+ 501F               ENDIF
 383+ 501F
 384+ 501F               IF (0 == 1)
 385+ 501F ~            ; *******************************************************************************************************
 386+ 501F ~            ; function to handle CALL ANIMITEMPTR basic extension
 387+ 501F ~            ; ANIMITEMPTR ( BYTE id,
 388+ 501F ~            ;               INT ticks,
 389+ 501F ~            ;               INT pointer,
 390+ 501F ~            ; fills animation item data, returns an error if ID out of bounds
 391+ 501F ~            ANIMITEMPTR_CMD:
 392+ 501F ~                ; opening (
 393+ 501F ~            	CALL CHKCHAR
 394+ 501F ~            	DB '('
 395+ 501F ~            	; get id
 396+ 501F ~            	LD IX, GETBYT
 397+ 501F ~            	CALL CALBAS
 398+ 501F ~                PUSH AF
 399+ 501F ~                ; check if out of bounds
 400+ 501F ~                INC A
 401+ 501F ~                LD C,A
 402+ 501F ~                LD A,(ANIMITEMNUM)
 403+ 501F ~                CP C
 404+ 501F ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 405+ 501F ~            	; comma
 406+ 501F ~            	CALL CHKCHAR
 407+ 501F ~            	DB ','
 408+ 501F ~            	; get ticks
 409+ 501F ~            	LD IX, FRMQNT
 410+ 501F ~            	CALL CALBAS
 411+ 501F ~                LD A,D
 412+ 501F ~                OR E
 413+ 501F ~                JP Z,OVERFLOW
 414+ 501F ~            	PUSH DE
 415+ 501F ~            	; comma
 416+ 501F ~            	CALL CHKCHAR
 417+ 501F ~            	DB ','
 418+ 501F ~            	; get pointer
 419+ 501F ~            	LD IX, FRMQNT
 420+ 501F ~            	CALL CALBAS
 421+ 501F ~            	PUSH DE
 422+ 501F ~            	; ending )
 423+ 501F ~            	CALL CHKCHAR
 424+ 501F ~            	DB ')'
 425+ 501F ~            .ENTRY:
 426+ 501F ~                PUSH HL
 427+ 501F ~                POP IX
 428+ 501F ~                EXX
 429+ 501F ~                POP DE ; pointer
 430+ 501F ~                POP HL ; ticks
 431+ 501F ~                EXX
 432+ 501F ~                POP AF
 433+ 501F ~                CALL GETnthANIMITEM
 434+ 501F ~                PUSH HL
 435+ 501F ~                POP IY
 436+ 501F ~                EXX
 437+ 501F ~                LD (IY),1 ; type=1
 438+ 501F ~                LD (IY+1),L
 439+ 501F ~                LD (IY+2),H
 440+ 501F ~                LD (IY+3),E
 441+ 501F ~                LD (IY+4),D
 442+ 501F ~
 443+ 501F ~                PUSH IX
 444+ 501F ~                POP HL
 445+ 501F ~                RET
 446+ 501F ~            ; *******************************************************************************************************
 447+ 501F               ENDIF
 448+ 501F
 449+ 501F               IF (1 == 1)
 450+ 501F              ; *******************************************************************************************************
 451+ 501F              ; same as ANIMITEMPTR but for DEFUSR approach
 452+ 501F              ; input IX=pointer to input array, real data from +2
 453+ 501F              ; +02 = ID
 454+ 501F              ; +04 = ticks
 455+ 501F              ; +06 = pointer
 456+ 501F              ANIMITEMPTR_DEFUSR:
 457+ 501F                  ; check if out of bounds
 458+ 501F DD 4E 02         LD C,(IX+2)
 459+ 5022 0C               INC C
 460+ 5023 3A EF 4E         LD A,(ANIMITEMNUM)
 461+ 5026 B9               CP C
 462+ 5027 D8               RET C ; out of bounds, prevent memory corruption
 463+ 5028 79               LD A,C
 464+ 5029 3D               DEC A
 465+ 502A CD 04 4F         CALL GETnthANIMITEM
 466+ 502D 36 01            LD (HL),1 ; type=1
 467+ 502F 23               INC HL
 468+ 5030 DD 7E 04         LD A,(IX+4) ; ticks low
 469+ 5033 77               LD (HL),A
 470+ 5034 23               INC HL
 471+ 5035 DD 7E 05         LD A,(IX+5) ; ticks high
 472+ 5038 77               LD (HL),A
 473+ 5039 23               INC HL
 474+ 503A DD 7E 06         LD A,(IX+6) ; pointer low
 475+ 503D 77               LD (HL),A
 476+ 503E 23               INC HL
 477+ 503F DD 7E 07         LD A,(IX+7) ; pointer high
 478+ 5042 77               LD (HL),A
 479+ 5043 C9               RET
 480+ 5044              ; *******************************************************************************************************
 481+ 5044               ENDIF
 482+ 5044
 483+ 5044               IF (1 == 1)
 484+ 5044              ; *******************************************************************************************************
 485+ 5044              ; same as MAXANIMDEFS but for DEFUSR approach
 486+ 5044              ; input IX=pointer to input array, real data from +2
 487+ 5044              ; +2 = number
 488+ 5044              MAXANIMDEFS_DEFUSR:
 489+ 5044 DD 7E 02         LD A,(IX+2)
 490+ 5047 18 00            JR MAXANIMDEFS.COMMON
 491+ 5049              ; *******************************************************************************************************
 492+ 5049               ENDIF
 493+ 5049
 494+ 5049              ; *******************************************************************************************************
 495+ 5049              ; function to handle CALL MAXANIMDEFS basic extension
 496+ 5049              ; MAXANIMDEFS (BYTE number)
 497+ 5049              ; sets new number and moves memory buffers as needed
 498+ 5049              MAXANIMDEFS:
 499+ 5049               IF (0 == 1)
 500+ 5049 ~            	; opening (
 501+ 5049 ~            	CALL CHKCHAR
 502+ 5049 ~            	DB '('
 503+ 5049 ~            	; get value
 504+ 5049 ~            	LD IX, GETBYT
 505+ 5049 ~            	CALL CALBAS
 506+ 5049 ~                PUSH AF
 507+ 5049 ~            	; ending )
 508+ 5049 ~            	CALL CHKCHAR
 509+ 5049 ~            	DB ')'
 510+ 5049 ~                POP AF
 511+ 5049               ENDIF
 512+ 5049              .COMMON:
 513+ 5049 F3               DI
 514+ 504A              	; save position
 515+ 504A E5           	PUSH HL
 516+ 504B              .ENTRY:
 517+ 504B 47               LD B,A
 518+ 504C 3A F2 4E         LD A,(ANIMDEFNUM)
 519+ 504F 90               SUB B
 520+ 5050 CA 6B 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 521+ 5053 FD 21 F6 4E      LD IY,ANIMSPRPTR
 522+ 5057 FA 63 50         JP M, .INCREASE
 523+ 505A                  ; new value is lower than previous one
 524+ 505A CD 6E 50         CALL .SIZEDIFF
 525+ 505D CD A8 4F         CALL MAXANIMITEMS.DECREASE_COMMON
 526+ 5060 C3 59 4F         JP MAXANIMITEMS.E1
 527+ 5063              .INCREASE:
 528+ 5063 ED 44            NEG
 529+ 5065 CD 6E 50         CALL .SIZEDIFF
 530+ 5068 CD D4 4F         CALL MAXANIMITEMS.INCREASE_COMMON
 531+ 506B C3 7D 4F         JP MAXANIMITEMS.E2
 532+ 506E              .SIZEDIFF:
 533+ 506E 26 00            LD H,0
 534+ 5070 6F               LD L,A
 535+ 5071 CD 40 5E         CALL HLx16
 536+ 5074 78               LD A,B
 537+ 5075 32 F2 4E         LD (ANIMDEFNUM),A
 538+ 5078 44               LD B,H
 539+ 5079 4D               LD C,L
 540+ 507A C9               RET ; BC=size difference in bytes
 541+ 507B              ; *******************************************************************************************************
 542+ 507B
 543+ 507B               IF (0 == 1)
 544+ 507B ~            ; *******************************************************************************************************
 545+ 507B ~            ; function to handle CALL ANIMDEF basic extension
 546+ 507B ~            ; ANIMITEMPAT ( BYTE id,
 547+ 507B ~            ;               BYTE size,
 548+ 507B ~            ;               INT[] list )
 549+ 507B ~            ; fills animation definition data, returns an error if out of bounds, or invalid type
 550+ 507B ~            ANIMDEF:
 551+ 507B ~                ; opening (
 552+ 507B ~            	CALL CHKCHAR
 553+ 507B ~            	DB '('
 554+ 507B ~            	; get id
 555+ 507B ~            	LD IX, GETBYT
 556+ 507B ~            	CALL CALBAS
 557+ 507B ~                PUSH AF
 558+ 507B ~                ; check if out of bounds
 559+ 507B ~                INC A
 560+ 507B ~                LD C,A
 561+ 507B ~                LD A,(ANIMDEFNUM)
 562+ 507B ~                CP C
 563+ 507B ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 564+ 507B ~            	; comma
 565+ 507B ~            	CALL CHKCHAR
 566+ 507B ~            	DB ','
 567+ 507B ~            	; get size
 568+ 507B ~            	LD IX, GETBYT
 569+ 507B ~            	CALL CALBAS
 570+ 507B ~                CP 16
 571+ 507B ~                JP NC, OVERFLOW
 572+ 507B ~                OR A
 573+ 507B ~                JP Z, OVERFLOW
 574+ 507B ~            	PUSH AF
 575+ 507B ~            	; comma
 576+ 507B ~            	CALL CHKCHAR
 577+ 507B ~            	DB ','
 578+ 507B ~            	; get pointer to a list of animation items in integer array format
 579+ 507B ~                ; get array pointer
 580+ 507B ~                POP DE
 581+ 507B ~                PUSH DE
 582+ 507B ~                LD A,2
 583+ 507B ~                LD B,1
 584+ 507B ~                CALL GET_BASIC_ARRAY_DATA_POINTER
 585+ 507B ~                PUSH BC
 586+ 507B ~            	; ending )
 587+ 507B ~            	CALL CHKCHAR
 588+ 507B ~            	DB ')'
 589+ 507B ~            .ENTRY:
 590+ 507B ~                PUSH HL
 591+ 507B ~                POP IX
 592+ 507B ~                POP DE ; pointer to INT array
 593+ 507B ~                POP BC ; B=item number
 594+ 507B ~                POP AF ; id
 595+ 507B ~                PUSH DE
 596+ 507B ~                CALL GETnthANIMDEF
 597+ 507B ~                POP DE
 598+ 507B ~                LD (HL),B
 599+ 507B ~            .L1:
 600+ 507B ~                INC HL
 601+ 507B ~                LD A,(DE)
 602+ 507B ~                .2 INC DE
 603+ 507B ~                LD (HL),A
 604+ 507B ~                DJNZ .L1
 605+ 507B ~                PUSH IX
 606+ 507B ~                POP HL
 607+ 507B ~                RET
 608+ 507B ~            ; *******************************************************************************************************
 609+ 507B               ENDIF
 610+ 507B
 611+ 507B               IF (1 == 1)
 612+ 507B              ; *******************************************************************************************************
 613+ 507B              ; same as ANIMDEF but for DEFUSR approach
 614+ 507B              ; input IX=pointer to input array, real data from +2
 615+ 507B              ; +02 = ID
 616+ 507B              ; +04 = list size
 617+ 507B              ; +06 = list pointer
 618+ 507B              ANIMDEF_DEFUSR:
 619+ 507B                  ; check if out of bounds
 620+ 507B DD 4E 02         LD C,(IX+2)
 621+ 507E 0C               INC C
 622+ 507F 3A F2 4E         LD A,(ANIMDEFNUM)
 623+ 5082 B9               CP C
 624+ 5083 D8               RET C ; invalid id
 625+ 5084              	; get size
 626+ 5084 DD 7E 04         LD A,(IX+4)
 627+ 5087 FE 10            CP 16
 628+ 5089 D0               RET NC ; overflow
 629+ 508A B7               OR A
 630+ 508B C8               RET Z ; ID=0, invalid
 631+ 508C 47               LD B,A
 632+ 508D 79               LD A,C
 633+ 508E 3D               DEC A
 634+ 508F CD 0D 4F         CALL GETnthANIMDEF
 635+ 5092 70               LD (HL),B
 636+ 5093 DD 5E 06         LD E,(IX+6)
 637+ 5096 DD 56 07         LD D,(IX+7)
 638+ 5099              .L1:
 639+ 5099 23               INC HL
 640+ 509A 1A               LD A,(DE)
 641+ 509B 13          > INC DE
 641+ 509C 13          > INC DE
 642+ 509D 77               LD (HL),A
 643+ 509E 10 F9            DJNZ .L1
 644+ 50A0 C9               RET
 645+ 50A1              ; *******************************************************************************************************
 646+ 50A1               ENDIF
 647+ 50A1
 648+ 50A1               IF (1 == 1)
 649+ 50A1              ; *******************************************************************************************************
 650+ 50A1              ; same as MAXANIMSPRS but for DEFUSR approach
 651+ 50A1              ; input IX=pointer to input array, real data from +2
 652+ 50A1              ; +2 = number
 653+ 50A1              MAXANIMSPRS_DEFUSR:
 654+ 50A1 DD 7E 02         LD A,(IX+2)
 655+ 50A4 18 00            JR MAXANIMSPRS.COMMON
 656+ 50A6              ; *******************************************************************************************************
 657+ 50A6               ENDIF
 658+ 50A6
 659+ 50A6              ; *******************************************************************************************************
 660+ 50A6              ; function to handle CALL MAXANIMSPRS basic extension
 661+ 50A6              ; MAXANIMSPRS (BYTE number)
 662+ 50A6              ; sets new number and moves memory buffers as needed
 663+ 50A6              MAXANIMSPRS:
 664+ 50A6               IF (0 == 1)
 665+ 50A6 ~            	; opening (
 666+ 50A6 ~            	CALL CHKCHAR
 667+ 50A6 ~            	DB '('
 668+ 50A6 ~            	; get value
 669+ 50A6 ~            	LD IX, GETBYT
 670+ 50A6 ~            	CALL CALBAS
 671+ 50A6 ~                PUSH AF
 672+ 50A6 ~            	; ending )
 673+ 50A6 ~            	CALL CHKCHAR
 674+ 50A6 ~            	DB ')'
 675+ 50A6 ~                POP AF
 676+ 50A6               ENDIF
 677+ 50A6              .COMMON:
 678+ 50A6 F3               DI
 679+ 50A7              	; save position
 680+ 50A7 E5           	PUSH HL
 681+ 50A8              .ENTRY:
 682+ 50A8 47               LD B,A
 683+ 50A9 3A F5 4E         LD A,(ANIMSPRNUM)
 684+ 50AC 90               SUB B
 685+ 50AD CA 6B 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 686+ 50B0 FD 21 F9 4E      LD IY,AUTOSGAMPTR
 687+ 50B4 FA C0 50         JP M, .INCREASE
 688+ 50B7                  ; new value is lower than previous one
 689+ 50B7 CD E1 50         CALL .SIZEDIFF
 690+ 50BA CD A8 4F         CALL MAXANIMITEMS.DECREASE_COMMON
 691+ 50BD C3 62 4F         JP MAXANIMITEMS.E3
 692+ 50C0              .INCREASE:
 693+ 50C0 ED 44            NEG
 694+ 50C2 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 695+ 50C3 CD E1 50         CALL .SIZEDIFF
 696+ 50C6 CD D4 4F         CALL MAXANIMITEMS.INCREASE_COMMON
 697+ 50C9 AF               XOR A
 698+ 50CA ED 42            SBC HL,BC ; location of new stuff
 699+ 50CC F1               POP AF
 700+ 50CD C5               PUSH BC
 701+ 50CE 47               LD B,A
 702+ 50CF 11 08 00         LD DE,8
 703+ 50D2 E5               PUSH HL
 704+ 50D3 DD E1            POP IX
 705+ 50D5              .L1:
 706+ 50D5 DD 36 06 00      LD (IX+6),0 ; active flag
 707+ 50D9 DD 19            ADD IX,DE
 708+ 50DB 10 F8            DJNZ .L1
 709+ 50DD C1               POP BC
 710+ 50DE C3 84 4F         JP MAXANIMITEMS.E4
 711+ 50E1              .SIZEDIFF:
 712+ 50E1 26 00            LD H,0
 713+ 50E3 6F               LD L,A
 714+ 50E4 CD 41 5E         CALL HLx8
 715+ 50E7 78               LD A,B
 716+ 50E8 32 F5 4E         LD (ANIMSPRNUM),A
 717+ 50EB 44               LD B,H
 718+ 50EC 4D               LD C,L
 719+ 50ED C9               RET ; BC=size difference in bytes
 720+ 50EE              ; *******************************************************************************************************
 721+ 50EE
 722+ 50EE               IF (0 == 1)
 723+ 50EE ~            ; *******************************************************************************************************
 724+ 50EE ~            ; function to handle CALL ANIMSPRITE basic extension
 725+ 50EE ~            ; ANIMSPRITE ( BYTE id,
 726+ 50EE ~            ;              BYTE sprite_number,
 727+ 50EE ~            ;              BYTE animation_definition_id,
 728+ 50EE ~            ;              BYTE cyclic_flag )
 729+ 50EE ~            ; fills sprite animation data, returns an error if out of bounds, or invalid type
 730+ 50EE ~            ANIMSPRITE:
 731+ 50EE ~                ; opening (
 732+ 50EE ~            	CALL CHKCHAR
 733+ 50EE ~            	DB '('
 734+ 50EE ~            	; get sprite animation id
 735+ 50EE ~            	LD IX, GETBYT
 736+ 50EE ~            	CALL CALBAS
 737+ 50EE ~                PUSH AF
 738+ 50EE ~                INC A
 739+ 50EE ~                LD C,A
 740+ 50EE ~                LD A,(ANIMSPRNUM)
 741+ 50EE ~                CP C
 742+ 50EE ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 743+ 50EE ~            	; comma
 744+ 50EE ~            	CALL CHKCHAR
 745+ 50EE ~            	DB ','
 746+ 50EE ~            	; get sprite number
 747+ 50EE ~            	LD IX, GETBYT
 748+ 50EE ~            	CALL CALBAS
 749+ 50EE ~                PUSH AF
 750+ 50EE ~                ; check if out of bounds
 751+ 50EE ~                CP 32
 752+ 50EE ~                JP NC, SUBSCRIPT_OUT_OF_RANGE
 753+ 50EE ~            	; comma
 754+ 50EE ~            	CALL CHKCHAR
 755+ 50EE ~            	DB ','
 756+ 50EE ~            	; get animation definition id
 757+ 50EE ~            	LD IX, GETBYT
 758+ 50EE ~            	CALL CALBAS
 759+ 50EE ~                PUSH AF
 760+ 50EE ~                INC A
 761+ 50EE ~                LD C,A
 762+ 50EE ~                LD A,(ANIMDEFNUM)
 763+ 50EE ~                CP C
 764+ 50EE ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 765+ 50EE ~            	; comma
 766+ 50EE ~            	CALL CHKCHAR
 767+ 50EE ~            	DB ','
 768+ 50EE ~            	; get cyclic flag
 769+ 50EE ~            	LD IX, GETBYT
 770+ 50EE ~                CALL CALBAS
 771+ 50EE ~            	PUSH AF
 772+ 50EE ~            	; ending )
 773+ 50EE ~            	CALL CHKCHAR
 774+ 50EE ~            	DB ')'
 775+ 50EE ~            .ENTRY:
 776+ 50EE ~                PUSH HL
 777+ 50EE ~                POP IX
 778+ 50EE ~                EXX
 779+ 50EE ~                POP DE ; cyclic
 780+ 50EE ~                POP BC ; animation definition id
 781+ 50EE ~                POP HL ; sprite number
 782+ 50EE ~                EXX
 783+ 50EE ~                POP AF ; sprite animation id
 784+ 50EE ~                CALL GETnthSPRANIM
 785+ 50EE ~                PUSH HL
 786+ 50EE ~                POP IY
 787+ 50EE ~                EXX
 788+ 50EE ~                LD (IY),H
 789+ 50EE ~                LD (IY+4),B
 790+ 50EE ~                LD (IY+5),D
 791+ 50EE ~                ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 792+ 50EE ~                ; following will do preparation for ANIMSTEP situation
 793+ 50EE ~                ; current item set to above limit and timer to 1
 794+ 50EE ~                ; any call to ANIMSTEP will switch and setup to first item for cyclic
 795+ 50EE ~                LD (IY+3),255
 796+ 50EE ~                LD (IY+1),1
 797+ 50EE ~                LD (IY+2),0
 798+ 50EE ~                ; mark as sprite animation
 799+ 50EE ~                LD (IY+7),0
 800+ 50EE ~                PUSH IX
 801+ 50EE ~                POP HL
 802+ 50EE ~                RET
 803+ 50EE ~            ; *******************************************************************************************************
 804+ 50EE               ENDIF
 805+ 50EE
 806+ 50EE               IF (1 == 1)
 807+ 50EE              ; *******************************************************************************************************
 808+ 50EE              ; same as ANIMSPRITE but for DEFUSR approach
 809+ 50EE              ; input IX=pointer to input array, real data from +2
 810+ 50EE              ; +02 = ID
 811+ 50EE              ; +04 = sprite number
 812+ 50EE              ; +06 = animation definition id
 813+ 50EE              ; +08 = cyclic flag
 814+ 50EE              ANIMSPRITE_DEFUSR:
 815+ 50EE DD 4E 02         LD C,(IX+2)
 816+ 50F1 0C               INC C
 817+ 50F2 3A F5 4E         LD A,(ANIMSPRNUM)
 818+ 50F5 B9               CP C
 819+ 50F6 D8               RET C ; invalid id
 820+ 50F7              	; get sprite number
 821+ 50F7 DD 7E 04         LD A,(IX+4)
 822+ 50FA FE 20            CP 32
 823+ 50FC D0               RET NC ; invalid sprite id
 824+ 50FD DD 46 06         LD B,(IX+6)
 825+ 5100 04               INC B
 826+ 5101 3A F2 4E         LD A,(ANIMDEFNUM)
 827+ 5104 B8               CP B
 828+ 5105 D8               RET C ; invalid animation definition id
 829+ 5106 79               LD A,C
 830+ 5107 3D               DEC A
 831+ 5108 CD 19 4F         CALL GETnthSPRANIM
 832+ 510B DD 7E 04         LD A,(IX+4)
 833+ 510E 77               LD (HL),A ; +0
 834+ 510F 23               INC HL
 835+ 5110 36 01            LD (HL),1 ; +1
 836+ 5112 23               INC HL
 837+ 5113 36 00            LD (HL),0 ; +2
 838+ 5115 23               INC HL
 839+ 5116 36 FF            LD (HL),255 ; +3
 840+ 5118 23               INC HL
 841+ 5119 05               DEC B
 842+ 511A 70               LD (HL),B ; +4
 843+ 511B 23               INC HL
 844+ 511C DD 7E 08         LD A,(IX+8) ; +5
 845+ 511F 77               LD (HL),A
 846+ 5120 23               INC HL
 847+ 5121 23               INC HL
 848+ 5122 36 00            LD (HL),0 ; +7
 849+ 5124 C9               RET
 850+ 5125              ; *******************************************************************************************************
 851+ 5125               ENDIF
 852+ 5125
 853+ 5125
 854+ 5125               IF (0 == 1)
 855+ 5125 ~            ; *******************************************************************************************************
 856+ 5125 ~            ; function to handle CALL ANIMCHAR basic extension
 857+ 5125 ~            ; ANIMCHAR ( BYTE id,
 858+ 5125 ~            ;            INT character number 0-767,
 859+ 5125 ~            ;            BYTE animation_definition_id,
 860+ 5125 ~            ;            BYTE cyclic_flag )
 861+ 5125 ~            ; fills sprite animation data, returns an error if out of bounds, or invalid type
 862+ 5125 ~            ANIMCHAR:
 863+ 5125 ~                ; opening (
 864+ 5125 ~            	CALL CHKCHAR
 865+ 5125 ~            	DB '('
 866+ 5125 ~            	; get sprite animation id
 867+ 5125 ~            	LD IX, GETBYT
 868+ 5125 ~            	CALL CALBAS
 869+ 5125 ~                PUSH AF
 870+ 5125 ~                INC A
 871+ 5125 ~                LD C,A
 872+ 5125 ~                LD A,(ANIMSPRNUM)
 873+ 5125 ~                CP C
 874+ 5125 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 875+ 5125 ~            	; comma
 876+ 5125 ~            	CALL CHKCHAR
 877+ 5125 ~            	DB ','
 878+ 5125 ~            	; get character number
 879+ 5125 ~            	LD IX, FRMQNT
 880+ 5125 ~            	CALL CALBAS
 881+ 5125 ~                PUSH DE
 882+ 5125 ~                ; check if out of bounds
 883+ 5125 ~                LD A,D
 884+ 5125 ~                CP 3
 885+ 5125 ~                JP NC, SUBSCRIPT_OUT_OF_RANGE
 886+ 5125 ~            	; comma
 887+ 5125 ~            	CALL CHKCHAR
 888+ 5125 ~            	DB ','
 889+ 5125 ~            	; get animation definition id
 890+ 5125 ~            	LD IX, GETBYT
 891+ 5125 ~            	CALL CALBAS
 892+ 5125 ~                PUSH AF
 893+ 5125 ~                INC A
 894+ 5125 ~                LD C,A
 895+ 5125 ~                LD A,(ANIMDEFNUM)
 896+ 5125 ~                CP C
 897+ 5125 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 898+ 5125 ~            	; comma
 899+ 5125 ~            	CALL CHKCHAR
 900+ 5125 ~            	DB ','
 901+ 5125 ~            	; get cyclic flag
 902+ 5125 ~            	LD IX, GETBYT
 903+ 5125 ~                CALL CALBAS
 904+ 5125 ~            	PUSH AF
 905+ 5125 ~            	; ending )
 906+ 5125 ~            	CALL CHKCHAR
 907+ 5125 ~            	DB ')'
 908+ 5125 ~            .ENTRY:
 909+ 5125 ~                PUSH HL
 910+ 5125 ~                POP IX
 911+ 5125 ~                EXX
 912+ 5125 ~                POP DE ; cyclic
 913+ 5125 ~                POP BC ; animation definition id
 914+ 5125 ~                POP HL ; character number
 915+ 5125 ~                EXX
 916+ 5125 ~                POP AF ; sprite animation id
 917+ 5125 ~                CALL GETnthSPRANIM
 918+ 5125 ~                PUSH HL
 919+ 5125 ~                POP IY
 920+ 5125 ~                EXX
 921+ 5125 ~                LD (IY),L
 922+ 5125 ~                INC H ; save character bank+1
 923+ 5125 ~                LD (IY+7),H
 924+ 5125 ~                LD (IY+4),B
 925+ 5125 ~                LD (IY+5),D
 926+ 5125 ~                ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 927+ 5125 ~                ; following will do preparation for ANIMSTEP situation
 928+ 5125 ~                ; current item set to above limit and timer to 1
 929+ 5125 ~                ; any call to ANIMSTEP will switch and setup to first item for cyclic
 930+ 5125 ~                LD (IY+3),255
 931+ 5125 ~                LD (IY+1),1
 932+ 5125 ~                LD (IY+2),0
 933+ 5125 ~                PUSH IX
 934+ 5125 ~                POP HL
 935+ 5125 ~                RET
 936+ 5125 ~            ; *******************************************************************************************************
 937+ 5125               ENDIF
 938+ 5125
 939+ 5125               IF (1 == 1)
 940+ 5125              ; *******************************************************************************************************
 941+ 5125              ; same as ANIMCHAR but for DEFUSR approach
 942+ 5125              ; input IX=pointer to input array, real data from +2
 943+ 5125              ; +02 = ID
 944+ 5125              ; +04 = character number
 945+ 5125              ; +06 = animation definition id
 946+ 5125              ; +08 = cyclic flag
 947+ 5125              ANIMCHAR_DEFUSR:
 948+ 5125 DD 4E 02         LD C,(IX+2)
 949+ 5128 0C               INC C
 950+ 5129 3A F5 4E         LD A,(ANIMSPRNUM)
 951+ 512C B9               CP C
 952+ 512D D8               RET C ; invalid id
 953+ 512E              	; get sprite number
 954+ 512E DD 7E 05         LD A,(IX+5)
 955+ 5131 FE 03            CP 3
 956+ 5133 D0               RET NC ; invalid character (>767)
 957+ 5134 DD 46 06         LD B,(IX+6)
 958+ 5137 04               INC B
 959+ 5138 3A F2 4E         LD A,(ANIMDEFNUM)
 960+ 513B B8               CP B
 961+ 513C D8               RET C ; invalid animation definition id
 962+ 513D 79               LD A,C
 963+ 513E 3D               DEC A
 964+ 513F CD 19 4F         CALL GETnthSPRANIM
 965+ 5142 DD 7E 04         LD A,(IX+4)
 966+ 5145 77               LD (HL),A ; +0
 967+ 5146 23               INC HL
 968+ 5147 36 01            LD (HL),1 ; +1
 969+ 5149 23               INC HL
 970+ 514A 36 00            LD (HL),0 ; +2
 971+ 514C 23               INC HL
 972+ 514D 36 FF            LD (HL),255 ; +3
 973+ 514F 23               INC HL
 974+ 5150 05               DEC B
 975+ 5151 70               LD (HL),B ; +4
 976+ 5152 23               INC HL
 977+ 5153 DD 7E 08         LD A,(IX+8) ; +5
 978+ 5156 77               LD (HL),A
 979+ 5157 23               INC HL
 980+ 5158 23               INC HL
 981+ 5159 DD 7E 05         LD A,(IX+5)
 982+ 515C 3C               INC A
 983+ 515D 77               LD (HL),A ; +7
 984+ 515E C9               RET
 985+ 515F              ; *******************************************************************************************************
 986+ 515F               ENDIF
 987+ 515F
 988+ 515F               IF (1 == 1)
 989+ 515F              ; *******************************************************************************************************
 990+ 515F              ; same as MAXAUTOSGAMS but for DEFUSR approach
 991+ 515F              ; input IX=pointer to input array, real data from +2
 992+ 515F              ; +2 = number
 993+ 515F              MAXAUTOSGAMS_DEFUSR:
 994+ 515F DD 7E 02         LD A,(IX+2)
 995+ 5162 18 00            JR MAXAUTOSGAMS.COMMON
 996+ 5164              ; *******************************************************************************************************
 997+ 5164               ENDIF
 998+ 5164
 999+ 5164              ; *******************************************************************************************************
1000+ 5164              ; function to handle CALL MAXAUTOSGAMS basic extension
1001+ 5164              ; MAXAUTOSGAMS (BYTE number)
1002+ 5164              ; sets new number and moves memory buffers as needed
1003+ 5164              MAXAUTOSGAMS:
1004+ 5164               IF (0 == 1)
1005+ 5164 ~            	; opening (
1006+ 5164 ~            	CALL CHKCHAR
1007+ 5164 ~            	DB '('
1008+ 5164 ~            	; get value
1009+ 5164 ~            	LD IX, GETBYT
1010+ 5164 ~            	CALL CALBAS
1011+ 5164 ~                PUSH AF
1012+ 5164 ~            	; ending )
1013+ 5164 ~            	CALL CHKCHAR
1014+ 5164 ~            	DB ')'
1015+ 5164 ~                POP AF
1016+ 5164               ENDIF
1017+ 5164              .COMMON:
1018+ 5164 F3               DI
1019+ 5165              	; save position
1020+ 5165 E5           	PUSH HL
1021+ 5166              .ENTRY:
1022+ 5166 47               LD B,A
1023+ 5167 3A F8 4E         LD A,(AUTOSGAMNUM)
1024+ 516A 90               SUB B
1025+ 516B CA 6B 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
1026+ 516E FD 21 10 40      LD IY,FREEMEMPTR
1027+ 5172 FA 7E 51         JP M, .INCREASE
1028+ 5175                  ; new value is lower than previous one
1029+ 5175 CD 9F 51         CALL .SIZEDIFF
1030+ 5178 CD A8 4F         CALL MAXANIMITEMS.DECREASE_COMMON
1031+ 517B C3 6B 4F         JP MAXANIMITEMS.EXIT
1032+ 517E              .INCREASE:
1033+ 517E ED 44            NEG
1034+ 5180 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
1035+ 5181 CD 9F 51         CALL .SIZEDIFF
1036+ 5184 CD D4 4F         CALL MAXANIMITEMS.INCREASE_COMMON
1037+ 5187 AF               XOR A
1038+ 5188 ED 42            SBC HL,BC ; location of new stuff
1039+ 518A F1               POP AF
1040+ 518B C5               PUSH BC
1041+ 518C 47               LD B,A
1042+ 518D 11 18 00         LD DE,24
1043+ 5190 E5               PUSH HL
1044+ 5191 DD E1            POP IX
1045+ 5193              .L1:
1046+ 5193 DD 36 13 00      LD (IX+19),0 ; active flag
1047+ 5197 DD 19            ADD IX,DE
1048+ 5199 10 F8            DJNZ .L1
1049+ 519B C1               POP BC
1050+ 519C C3 6B 4F         JP MAXANIMITEMS.EXIT
1051+ 519F              .SIZEDIFF:
1052+ 519F 26 00            LD H,0
1053+ 51A1 6F               LD L,A
1054+ 51A2 CD 41 5E         CALL HLx8
1055+ 51A5 54               LD D,H
1056+ 51A6 5D               LD E,L
1057+ 51A7 29               ADD HL,HL
1058+ 51A8 19               ADD HL,DE
1059+ 51A9 78               LD A,B
1060+ 51AA 32 F8 4E         LD (AUTOSGAMNUM),A
1061+ 51AD 44               LD B,H
1062+ 51AE 4D               LD C,L
1063+ 51AF C9               RET ; BC=size difference in bytes
1064+ 51B0              ; *******************************************************************************************************
1065+ 51B0
1066+ 51B0               IF (0 == 1)
1067+ 51B0 ~            ; *******************************************************************************************************
1068+ 51B0 ~            ; function to handle CALL AUTOSGAMDEF basic extension
1069+ 51B0 ~            ; AUTOSGAMDEF ( BYTE id,
1070+ 51B0 ~            ;               INT VARIABLE x, INT VARIABLE y,
1071+ 51B0 ~            ;               INT minimum, INT maximum, INT delta,
1072+ 51B0 ~            ;               INT direction =0 horizontal,
1073+ 51B0 ~            ;               INT ticks,
1074+ 51B0 ~            ;               BYTE sprite_group_count,
1075+ 51B0 ~            ;               INT[2][sprite_group_count] VARIABLE sprite_group,
1076+ 51B0 ~            ;               BYTE item_number,
1077+ 51B0 ~            ;               INT[] VARIABLE sprite_animations_negative_direction,
1078+ 51B0 ~            ;               INT[] VARIABLE sprite_animations_positive_direction
1079+ 51B0 ~            AUTOSGAMDEF:
1080+ 51B0 ~                ; opening (
1081+ 51B0 ~            	CALL CHKCHAR
1082+ 51B0 ~            	DB '('
1083+ 51B0 ~            	; get sprite animation id
1084+ 51B0 ~            	LD IX, GETBYT
1085+ 51B0 ~            	CALL CALBAS
1086+ 51B0 ~                PUSH AF
1087+ 51B0 ~                INC A
1088+ 51B0 ~                LD C,A
1089+ 51B0 ~                LD A,(AUTOSGAMNUM)
1090+ 51B0 ~                CP C
1091+ 51B0 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
1092+ 51B0 ~                POP AF
1093+ 51B0 ~                PUSH HL
1094+ 51B0 ~                CALL GETnthAUTOSGAM
1095+ 51B0 ~                LD (BLIT_TMP),HL ; for later
1096+ 51B0 ~                POP HL
1097+ 51B0 ~            	; comma
1098+ 51B0 ~            	CALL CHKCHAR
1099+ 51B0 ~            	DB ','
1100+ 51B0 ~            	; get address of the X coordinate variable
1101+ 51B0 ~            	LD IX, PTRGET
1102+ 51B0 ~            	CALL CALBAS
1103+ 51B0 ~            	LD IX,(BLIT_TMP)
1104+ 51B0 ~                LD (IX+0),E
1105+ 51B0 ~                LD (IX+1),D
1106+ 51B0 ~            	; comma
1107+ 51B0 ~            	CALL CHKCHAR
1108+ 51B0 ~            	DB ','
1109+ 51B0 ~            	; get address of the Y coordinate variable
1110+ 51B0 ~            	LD IX, PTRGET
1111+ 51B0 ~            	CALL CALBAS
1112+ 51B0 ~            	LD IX,(BLIT_TMP)
1113+ 51B0 ~                LD (IX+2),E
1114+ 51B0 ~                LD (IX+3),D
1115+ 51B0 ~            	; comma
1116+ 51B0 ~            	CALL CHKCHAR
1117+ 51B0 ~            	DB ','
1118+ 51B0 ~            	; get minimum value
1119+ 51B0 ~            	LD IX, FRMQNT
1120+ 51B0 ~            	CALL CALBAS
1121+ 51B0 ~            	LD IX,(BLIT_TMP)
1122+ 51B0 ~                LD (IX+4),E
1123+ 51B0 ~                LD (IX+5),D
1124+ 51B0 ~            	; comma
1125+ 51B0 ~            	CALL CHKCHAR
1126+ 51B0 ~            	DB ','
1127+ 51B0 ~            	; get maximum value
1128+ 51B0 ~            	LD IX, FRMQNT
1129+ 51B0 ~            	CALL CALBAS
1130+ 51B0 ~            	LD IX,(BLIT_TMP)
1131+ 51B0 ~                LD (IX+6),E
1132+ 51B0 ~                LD (IX+7),D
1133+ 51B0 ~            	; comma
1134+ 51B0 ~            	CALL CHKCHAR
1135+ 51B0 ~            	DB ','
1136+ 51B0 ~            	; get delta value
1137+ 51B0 ~            	LD IX, FRMQNT
1138+ 51B0 ~            	CALL CALBAS
1139+ 51B0 ~            	LD IX,(BLIT_TMP)
1140+ 51B0 ~                LD (IX+8),E
1141+ 51B0 ~                LD (IX+9),D
1142+ 51B0 ~            	; comma
1143+ 51B0 ~            	CALL CHKCHAR
1144+ 51B0 ~            	DB ','
1145+ 51B0 ~            	; get direction value
1146+ 51B0 ~            	LD IX, FRMQNT
1147+ 51B0 ~            	CALL CALBAS
1148+ 51B0 ~            	LD IX,(BLIT_TMP)
1149+ 51B0 ~                LD (IX+10),E
1150+ 51B0 ~            	; comma
1151+ 51B0 ~            	CALL CHKCHAR
1152+ 51B0 ~            	DB ','
1153+ 51B0 ~            	; get ticks value
1154+ 51B0 ~            	LD IX, FRMQNT
1155+ 51B0 ~            	CALL CALBAS
1156+ 51B0 ~            	LD IX,(BLIT_TMP)
1157+ 51B0 ~                LD (IX+20),E
1158+ 51B0 ~                LD (IX+21),D
1159+ 51B0 ~            	; comma
1160+ 51B0 ~            	CALL CHKCHAR
1161+ 51B0 ~            	DB ','
1162+ 51B0 ~            	; get sprite group count
1163+ 51B0 ~            	LD IX, GETBYT
1164+ 51B0 ~            	CALL CALBAS
1165+ 51B0 ~                OR A
1166+ 51B0 ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
1167+ 51B0 ~            	LD IX,(BLIT_TMP)
1168+ 51B0 ~                LD (IX+11),A
1169+ 51B0 ~            	; comma
1170+ 51B0 ~            	CALL CHKCHAR
1171+ 51B0 ~            	DB ','
1172+ 51B0 ~            	; get sprite group definition array data pointer
1173+ 51B0 ~            	LD IX,(BLIT_TMP)
1174+ 51B0 ~                LD E,(IX+11)
1175+ 51B0 ~            	LD D,3
1176+ 51B0 ~            	LD A,2
1177+ 51B0 ~            	LD B,A
1178+ 51B0 ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
1179+ 51B0 ~            	LD IX,(BLIT_TMP)
1180+ 51B0 ~            	LD (IX+12),C
1181+ 51B0 ~                LD (IX+13),B
1182+ 51B0 ~            	; comma
1183+ 51B0 ~            	CALL CHKCHAR
1184+ 51B0 ~            	DB ','
1185+ 51B0 ~            	; get sprite animation array size
1186+ 51B0 ~            	LD IX,GETBYT
1187+ 51B0 ~            	CALL CALBAS
1188+ 51B0 ~            	LD IX,(BLIT_TMP)
1189+ 51B0 ~                LD (IX+14),A
1190+ 51B0 ~                OR A
1191+ 51B0 ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
1192+ 51B0 ~            	; comma
1193+ 51B0 ~            	CALL CHKCHAR
1194+ 51B0 ~            	DB ','
1195+ 51B0 ~                ; get array pointer for negative direction
1196+ 51B0 ~            	LD IX,(BLIT_TMP)
1197+ 51B0 ~                LD D,(IX+14)
1198+ 51B0 ~                LD A,2
1199+ 51B0 ~                LD B,1
1200+ 51B0 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
1201+ 51B0 ~            	LD IX,(BLIT_TMP)
1202+ 51B0 ~                LD (IX+15),C
1203+ 51B0 ~                LD (IX+16),B
1204+ 51B0 ~            	; comma
1205+ 51B0 ~            	CALL CHKCHAR
1206+ 51B0 ~            	DB ','
1207+ 51B0 ~                ; get array pointer for positive direction
1208+ 51B0 ~            	LD IX,(BLIT_TMP)
1209+ 51B0 ~                LD D,(IX+14)
1210+ 51B0 ~                LD A,2
1211+ 51B0 ~                LD B,1
1212+ 51B0 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
1213+ 51B0 ~            	LD IX,(BLIT_TMP)
1214+ 51B0 ~                LD (IX+17),C
1215+ 51B0 ~                LD (IX+18),B
1216+ 51B0 ~            	; ending )
1217+ 51B0 ~            	CALL CHKCHAR
1218+ 51B0 ~            	DB ')'
1219+ 51B0 ~                RET
1220+ 51B0 ~            ; *******************************************************************************************************
1221+ 51B0               ENDIF
1222+ 51B0
1223+ 51B0               IF (1 == 1)
1224+ 51B0              ; *******************************************************************************************************
1225+ 51B0              ; same as AUTOSGAMDEF but for DEFUSR approach
1226+ 51B0              ; input IX=pointer to input array, real data from +2
1227+ 51B0              ; +02 = ID
1228+ 51B0              ; +04 = pointer to X variable
1229+ 51B0              ; +06 = pointer to Y variable
1230+ 51B0              ; +08 = minimum
1231+ 51B0              ; +10 = maximum
1232+ 51B0              ; +12 = delta
1233+ 51B0              ; +14 = direction
1234+ 51B0              ; +16 = ticks
1235+ 51B0              ; +18 = sprite group count
1236+ 51B0              ; +20 = sprite group array pointer
1237+ 51B0              ; +22 = item number
1238+ 51B0              ; +24 = sprite animations negative direction array pointer
1239+ 51B0              ; +26 = sprite animations positive direction array pointer
1240+ 51B0              AUTOSGAMDEF_DEFUSR:
1241+ 51B0 DD 4E 02         LD C,(IX+2)
1242+ 51B3 0C               INC C
1243+ 51B4 3A F8 4E         LD A,(AUTOSGAMNUM)
1244+ 51B7 B9               CP C
1245+ 51B8 D8               RET C ; invalid id
1246+ 51B9 79               LD A,C
1247+ 51BA 3D               DEC A
1248+ 51BB CD 25 4F         CALL GETnthAUTOSGAM
1249+ 51BE E5               PUSH HL
1250+ 51BF FD E1            POP IY
1251+ 51C1                  ; X variable
1252+ 51C1 DD 7E 04         LD A,(IX+4)
1253+ 51C4 FD 77 00         LD (IY+0),A
1254+ 51C7 DD 7E 05         LD A,(IX+5)
1255+ 51CA FD 77 01         LD (IY+1),A
1256+ 51CD              	; Y variable
1257+ 51CD DD 7E 06         LD A,(IX+6)
1258+ 51D0 FD 77 02         LD (IY+2),A
1259+ 51D3 DD 7E 07         LD A,(IX+7)
1260+ 51D6 FD 77 03         LD (IY+3),A
1261+ 51D9              	; get minimum value
1262+ 51D9 DD 7E 08         LD A,(IX+8)
1263+ 51DC FD 77 04         LD (IY+4),A
1264+ 51DF DD 7E 09         LD A,(IX+9)
1265+ 51E2 FD 77 05         LD (IY+5),A
1266+ 51E5              	; get maximum value
1267+ 51E5 DD 7E 0A         LD A,(IX+10)
1268+ 51E8 FD 77 06         LD (IY+6),A
1269+ 51EB DD 7E 0B         LD A,(IX+11)
1270+ 51EE FD 77 07         LD (IY+7),A
1271+ 51F1              	; get delta value
1272+ 51F1 DD 7E 0C         LD A,(IX+12)
1273+ 51F4 FD 77 08         LD (IY+8),A
1274+ 51F7 DD 7E 0D         LD A,(IX+13)
1275+ 51FA FD 77 09         LD (IY+9),A
1276+ 51FD              	; get direction value
1277+ 51FD DD 7E 0E         LD A,(IX+14)
1278+ 5200 FD 77 0A         LD (IY+10),A
1279+ 5203              	; get ticks value
1280+ 5203 DD 7E 10         LD A,(IX+16)
1281+ 5206 FD 77 14         LD (IY+20),A
1282+ 5209 DD 7E 11         LD A,(IX+17)
1283+ 520C FD 77 15         LD (IY+21),A
1284+ 520F              	; get sprite group count
1285+ 520F DD 7E 12         LD A,(IX+18)
1286+ 5212 FD 77 0B         LD (IY+11),A
1287+ 5215              	; get sprite group definition array data pointer
1288+ 5215 DD 7E 14         LD A,(IX+20)
1289+ 5218 FD 77 0C         LD (IY+12),A
1290+ 521B DD 7E 15         LD A,(IX+21)
1291+ 521E FD 77 0D         LD (IY+13),A
1292+ 5221              	; get sprite animation array size
1293+ 5221 DD 7E 16         LD A,(IX+22)
1294+ 5224 FD 77 0E         LD (IY+14),A
1295+ 5227                  ; get array pointer for negative direction
1296+ 5227 DD 7E 18         LD A,(IX+24)
1297+ 522A FD 77 0F         LD (IY+15),A
1298+ 522D DD 7E 19         LD A,(IX+25)
1299+ 5230 FD 77 10         LD (IY+16),A
1300+ 5233                  ; get array pointer for positive direction
1301+ 5233 DD 7E 1A         LD A,(IX+26)
1302+ 5236 FD 77 11         LD (IY+17),A
1303+ 5239 DD 7E 1B         LD A,(IX+27)
1304+ 523C FD 77 12         LD (IY+18),A
1305+ 523F C9               RET
1306+ 5240              ; *******************************************************************************************************
1307+ 5240               ENDIF
1308+ 5240
1309+ 5240               IF (0 == 1)
1310+ 5240 ~            ; *******************************************************************************************************
1311+ 5240 ~            ; function to handle CALL AUTOSGAMSTART basic extension
1312+ 5240 ~            ; AUTOSGAMSTART ( BYTE id )
1313+ 5240 ~            AUTOSGAMSTART:
1314+ 5240 ~                LD A,1
1315+ 5240 ~            .COMMON:
1316+ 5240 ~                LD (.SETVALUE+3),A
1317+ 5240 ~                ; opening (
1318+ 5240 ~            	CALL CHKCHAR
1319+ 5240 ~            	DB '('
1320+ 5240 ~            	; get sprite animation id
1321+ 5240 ~            	LD IX, GETBYT
1322+ 5240 ~            	CALL CALBAS
1323+ 5240 ~                PUSH AF
1324+ 5240 ~                INC A
1325+ 5240 ~                LD C,A
1326+ 5240 ~                LD A,(AUTOSGAMNUM)
1327+ 5240 ~                CP C
1328+ 5240 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
1329+ 5240 ~                POP AF
1330+ 5240 ~                PUSH HL
1331+ 5240 ~                CALL GETnthAUTOSGAM
1332+ 5240 ~                PUSH HL
1333+ 5240 ~                POP IX
1334+ 5240 ~                POP HL
1335+ 5240 ~                PUSH IX
1336+ 5240 ~            	; ending )
1337+ 5240 ~            	CALL CHKCHAR
1338+ 5240 ~            	DB ')'
1339+ 5240 ~
1340+ 5240 ~                ; so syntax is fine
1341+ 5240 ~                POP IX
1342+ 5240 ~            .SETVALUE:
1343+ 5240 ~                LD (IX+19),1 ; active flag
1344+ 5240 ~                ; set initial timer
1345+ 5240 ~                LD A,(IX+20)
1346+ 5240 ~                LD (IX+22),A
1347+ 5240 ~                LD A,(IX+21)
1348+ 5240 ~                LD (IX+23),A
1349+ 5240 ~                RET
1350+ 5240 ~            ; *******************************************************************************************************
1351+ 5240 ~
1352+ 5240 ~            ; *******************************************************************************************************
1353+ 5240 ~            ; function to handle CALL AUTOSGAMSTOP basic extension
1354+ 5240 ~            ; AUTOSGAMSTOP ( BYTE id )
1355+ 5240 ~            AUTOSGAMSTOP:
1356+ 5240 ~                XOR A
1357+ 5240 ~                JR AUTOSGAMSTART.COMMON
1358+ 5240 ~            ; *******************************************************************************************************
1359+ 5240               ENDIF
1360+ 5240
1361+ 5240               IF (1 == 1)
1362+ 5240              ; *******************************************************************************************************
1363+ 5240              ; function to handle CALL AUTOSGAMSTART basic extension in DEFUSR mode
1364+ 5240              ; input IX=pointer to input array, real data from +2
1365+ 5240              ; +2 = source address
1366+ 5240              AUTOSGAMSTART_DEFUSR:
1367+ 5240 3E 01            LD A,1
1368+ 5242              .COMMON:
1369+ 5242 32 59 52         LD (.SETVALUE+3),A
1370+ 5245 DD 4E 02         LD C,(IX+2)
1371+ 5248 0C               INC C
1372+ 5249 3A F8 4E         LD A,(AUTOSGAMNUM)
1373+ 524C B9               CP C
1374+ 524D D8               RET C ; invalid id
1375+ 524E 79               LD A,C
1376+ 524F 3D               DEC A
1377+ 5250 CD 25 4F         CALL GETnthAUTOSGAM
1378+ 5253 E5               PUSH HL
1379+ 5254 DD E1            POP IX
1380+ 5256              .SETVALUE:
1381+ 5256 DD 36 13 01      LD (IX+19),1 ; active flag
1382+ 525A                  ; set initial timer
1383+ 525A DD 7E 14         LD A,(IX+20)
1384+ 525D DD 77 16         LD (IX+22),A
1385+ 5260 DD 7E 15         LD A,(IX+21)
1386+ 5263 DD 77 17         LD (IX+23),A
1387+ 5266 C9               RET
1388+ 5267              ; *******************************************************************************************************
1389+ 5267
1390+ 5267              ; *******************************************************************************************************
1391+ 5267              ; function to handle CALL AUTOSGAMSTOP basic extension in DEFUSR mode
1392+ 5267              ; input IX=pointer to input array, real data from +2
1393+ 5267              ; +2 = source address
1394+ 5267              AUTOSGAMSTOP_DEFUSR:
1395+ 5267 AF               XOR A
1396+ 5268 18 D8            JR AUTOSGAMSTART_DEFUSR.COMMON
1397+ 526A              ; *******************************************************************************************************
1398+ 526A               ENDIF
1399+ 526A
1400+ 526A               IF (0 == 1)
1401+ 526A ~            ; *******************************************************************************************************
1402+ 526A ~            ; function to handle CALL ANIMSTEP basic extension
1403+ 526A ~            ; two forms
1404+ 526A ~            ; ANIMSTEP ( BYTE id )
1405+ 526A ~            ; or
1406+ 526A ~            ; ANIMSTEP ( BYTE item_number,
1407+ 526A ~            ;            INT[] sprite_animations )
1408+ 526A ~            ANIMSTEP:
1409+ 526A ~                LD DE,ANIMSTARTSTOP_COMMON.STEP
1410+ 526A ~                JR ANIMSTARTSTOP_COMMON
1411+ 526A ~            ; *******************************************************************************************************
1412+ 526A ~            ; *******************************************************************************************************
1413+ 526A ~            ; function to handle CALL ANIMSTART basic extension
1414+ 526A ~            ; two forms
1415+ 526A ~            ; ANIMSTART ( BYTE id )
1416+ 526A ~            ; or
1417+ 526A ~            ; ANIMSTART ( BYTE item_number,
1418+ 526A ~            ;             INT[] sprite_animations )
1419+ 526A ~            ; sets active flag to 1
1420+ 526A ~            ANIMSTART:
1421+ 526A ~                LD DE,ANIMSTARTSTOP_COMMON.START
1422+ 526A ~                JR ANIMSTARTSTOP_COMMON
1423+ 526A ~            ; *******************************************************************************************************
1424+ 526A ~            ; *******************************************************************************************************
1425+ 526A ~            ; function to handle CALL ANIMSTOP basic extension
1426+ 526A ~            ; two forms
1427+ 526A ~            ; ANIMSTOP ( BYTE id )
1428+ 526A ~            ; or
1429+ 526A ~            ; ANIMSTOP ( BYTE item_number,
1430+ 526A ~            ;            INT[] sprite_animations )
1431+ 526A ~            ; sets active flag to 0
1432+ 526A ~            ANIMSTOP:
1433+ 526A ~                LD DE,ANIMSTARTSTOP_COMMON.STOP
1434+ 526A ~            ; *******************************************************************************************************
1435+ 526A ~            ANIMSTARTSTOP_COMMON:
1436+ 526A ~                LD (ANIMSTARTSTOP_COMMON.FN+1),DE
1437+ 526A ~                ; opening (
1438+ 526A ~            	CALL CHKCHAR
1439+ 526A ~            	DB '('
1440+ 526A ~            	; get sprite animation id or array size
1441+ 526A ~            	LD IX,GETBYT
1442+ 526A ~            	CALL CALBAS
1443+ 526A ~                PUSH AF
1444+ 526A ~                ; check if comma present
1445+ 526A ~                CALL GETPREVCHAR
1446+ 526A ~                INC HL
1447+ 526A ~                CP ','
1448+ 526A ~                JR Z,.L1
1449+ 526A ~                CP ')'
1450+ 526A ~                JP NZ,SYNTAX_ERROR
1451+ 526A ~                ; ok so single argument variant
1452+ 526A ~                POP AF
1453+ 526A ~                PUSH HL
1454+ 526A ~                DI
1455+ 526A ~                CALL .SETVALUE
1456+ 526A ~                EI
1457+ 526A ~                POP HL
1458+ 526A ~                RET
1459+ 526A ~            .L1:
1460+ 526A ~                ; get array pointer
1461+ 526A ~                POP DE
1462+ 526A ~                PUSH DE
1463+ 526A ~                LD A,2
1464+ 526A ~                LD B,1
1465+ 526A ~                CALL GET_BASIC_ARRAY_DATA_POINTER
1466+ 526A ~                PUSH BC
1467+ 526A ~            	; ending )
1468+ 526A ~            	CALL CHKCHAR
1469+ 526A ~            	DB ')'
1470+ 526A ~                POP DE ; array pointer
1471+ 526A ~                POP BC ; number of items
1472+ 526A ~                LD A,B
1473+ 526A ~                OR A
1474+ 526A ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
1475+ 526A ~                PUSH HL
1476+ 526A ~                DI
1477+ 526A ~            .L2:
1478+ 526A ~                PUSH BC
1479+ 526A ~                LD A,(DE)
1480+ 526A ~                .2 INC DE
1481+ 526A ~                PUSH DE
1482+ 526A ~                CALL .SETVALUE
1483+ 526A ~                POP DE
1484+ 526A ~                POP BC
1485+ 526A ~                DJNZ .L2
1486+ 526A ~                EI
1487+ 526A ~                POP HL
1488+ 526A ~                RET
1489+ 526A ~
1490+ 526A ~            .SETVALUE:
1491+ 526A ~                LD B,A
1492+ 526A ~                INC A
1493+ 526A ~                LD C,A
1494+ 526A ~                LD A,(ANIMSPRNUM)
1495+ 526A ~                CP C
1496+ 526A ~                JP C,SUBSCRIPT_OUT_OF_RANGE
1497+ 526A ~                LD A,B
1498+ 526A ~                CALL GETnthSPRANIM
1499+ 526A ~                PUSH HL
1500+ 526A ~                POP IX
1501+ 526A ~            .FN:
1502+ 526A ~                JP 0
1503+ 526A ~            .START:
1504+ 526A ~                LD (IX+6),1 ; active flag
1505+ 526A ~                LD (IX+3),0 ; current item
1506+ 526A ~                LD B,0 ; setup timer
1507+ 526A ~                JP SETUP_ANIM_STEP
1508+ 526A ~            .STOP:
1509+ 526A ~                LD (IX+6),0 ; active flag
1510+ 526A ~                RET
1511+ 526A ~            .STEP:
1512+ 526A ~                LD B,0
1513+ 526A ~                JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1514+ 526A ~            ; *******************************************************************************************************
1515+ 526A               ENDIF
1516+ 526A
1517+ 526A              ; *******************************************************************************************************
1518+ 526A              ; helper function to locate single animation and execute operation
1519+ 526A              ; needs to have jump set to a correct function
1520+ 526A              ; used by SGAM helper routines so always needed
1521+ 526A              ; input A=animation item
1522+ 526A              ANIM_SETVALUE:
1523+ 526A 47               LD B,A
1524+ 526B 3C               INC A
1525+ 526C 4F               LD C,A
1526+ 526D 3A F5 4E         LD A,(ANIMSPRNUM)
1527+ 5270 B9               CP C
1528+ 5271 D8               RET C ; out of range, so do nothing
1529+ 5272 78               LD A,B
1530+ 5273 CD 19 4F         CALL GETnthSPRANIM
1531+ 5276 E5               PUSH HL
1532+ 5277 DD E1            POP IX
1533+ 5279              .FN:
1534+ 5279 C3 00 00         JP 0
1535+ 527C              ; *******************************************************************************************************
1536+ 527C
1537+ 527C               IF (1 == 1)
1538+ 527C              ; *******************************************************************************************************
1539+ 527C              ; helper function to set values of multiple animations
1540+ 527C              ; needs to have jump set to a correct function
1541+ 527C              ; input B=number of animation item
1542+ 527C              ; input DE=animation item array
1543+ 527C              ANIM_LIST_SETVALUE:
1544+ 527C F3               DI
1545+ 527D C5               PUSH BC
1546+ 527E 1A               LD A,(DE)
1547+ 527F 13          > INC DE
1547+ 5280 13          > INC DE
1548+ 5281 D5               PUSH DE
1549+ 5282 CD 6A 52         CALL ANIM_SETVALUE
1550+ 5285 D1               POP DE
1551+ 5286 C1               POP BC
1552+ 5287 10 F3            DJNZ ANIM_LIST_SETVALUE
1553+ 5289 FB               EI
1554+ 528A C9               RET
1555+ 528B              ; *******************************************************************************************************
1556+ 528B
1557+ 528B              ; *******************************************************************************************************
1558+ 528B              ; function to handle single item ANIMSTEP in DEFUSR mode
1559+ 528B              ; input IX=pointer to input array, real data from +2
1560+ 528B              ; +2 = animation id
1561+ 528B              ANIMSTEP_SINGLE_DEFUSR:
1562+ 528B 21 96 52         LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1563+ 528E              .L1:
1564+ 528E 22 7A 52         LD (ANIM_SETVALUE.FN+1),HL
1565+ 5291 DD 7E 02         LD A,(IX+2)
1566+ 5294 18 D4            JR ANIM_SETVALUE
1567+ 5296              .STEP:
1568+ 5296 06 00            LD B,0
1569+ 5298 C3 F0 52         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1570+ 529B              ; *******************************************************************************************************
1571+ 529B
1572+ 529B              ; *******************************************************************************************************
1573+ 529B              ; function to handle multi item ANIMSTEP in DEFUSR mode
1574+ 529B              ; input IX=pointer to input array, real data from +2
1575+ 529B              ; +2 = list size
1576+ 529B              ; +4 = array pointer holding items
1577+ 529B              ANIMSTEP_MULTI_DEFUSR:
1578+ 529B 21 96 52         LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1579+ 529E              .L1:
1580+ 529E 22 7A 52         LD (ANIM_SETVALUE.FN+1),HL
1581+ 52A1 DD 46 02         LD B,(IX+2)
1582+ 52A4 DD 5E 04         LD E,(IX+4)
1583+ 52A7 DD 56 05         LD D,(IX+5)
1584+ 52AA 18 D0            JR ANIM_LIST_SETVALUE
1585+ 52AC              ; *******************************************************************************************************
1586+ 52AC
1587+ 52AC              ; *******************************************************************************************************
1588+ 52AC              ; function to handle single item ANIMSTART in DEFUSR mode
1589+ 52AC              ; input IX=pointer to input array, real data from +2
1590+ 52AC              ; +2 = animation id
1591+ 52AC              ANIMSTART_SINGLE_DEFUSR:
1592+ 52AC 21 B1 52         LD HL,ANIMSTART_SINGLE_DEFUSR.START
1593+ 52AF 18 DD            JR ANIMSTEP_SINGLE_DEFUSR.L1
1594+ 52B1              .START:
1595+ 52B1 DD 36 06 01      LD (IX+6),1 ; active flag
1596+ 52B5 DD 36 03 00      LD (IX+3),0 ; current item
1597+ 52B9 06 00            LD B,0 ; setup timer
1598+ 52BB C3 4C 53         JP SETUP_ANIM_STEP
1599+ 52BE              ; *******************************************************************************************************
1600+ 52BE
1601+ 52BE              ; *******************************************************************************************************
1602+ 52BE              ; function to handle multi item ANIMSTART in DEFUSR mode
1603+ 52BE              ; input IX=pointer to input array, real data from +2
1604+ 52BE              ; +2 = list size
1605+ 52BE              ; +4 = array pointer holding items
1606+ 52BE              ANIMSTART_MULTI_DEFUSR:
1607+ 52BE 21 B1 52         LD HL,ANIMSTART_SINGLE_DEFUSR.START
1608+ 52C1 18 DB            JR ANIMSTEP_MULTI_DEFUSR.L1
1609+ 52C3              ; *******************************************************************************************************
1610+ 52C3
1611+ 52C3              ; *******************************************************************************************************
1612+ 52C3              ; function to handle single item ANIMSTOP in DEFUSR mode
1613+ 52C3              ; input IX=pointer to input array, real data from +2
1614+ 52C3              ; +2 = animation id
1615+ 52C3              ANIMSTOP_SINGLE_DEFUSR:
1616+ 52C3 21 C8 52         LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1617+ 52C6 18 C6            JR ANIMSTEP_SINGLE_DEFUSR.L1
1618+ 52C8              .STOP:
1619+ 52C8 DD 36 06 00      LD (IX+6),0 ; active flag
1620+ 52CC C9               RET
1621+ 52CD              ; *******************************************************************************************************
1622+ 52CD
1623+ 52CD              ; *******************************************************************************************************
1624+ 52CD              ; function to handle multi item ANIMSTOP in DEFUSR mode
1625+ 52CD              ; input IX=pointer to input array, real data from +2
1626+ 52CD              ; +2 = list size
1627+ 52CD              ; +4 = array pointer holding items
1628+ 52CD              ANIMSTOP_MULTI_DEFUSR:
1629+ 52CD 21 C8 52         LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1630+ 52D0 18 CC            JR ANIMSTEP_MULTI_DEFUSR.L1
1631+ 52D2              ; *******************************************************************************************************
1632+ 52D2               ENDIF
1633+ 52D2
1634+ 52D2              ; *******************************************************************************************************
1635+ 52D2              ; function processes animations during vblank period
1636+ 52D2              PROCESS_ANIMATIONS:
1637+ 52D2 3A F5 4E         LD A,(ANIMSPRNUM)
1638+ 52D5 B7               OR A
1639+ 52D6 C8               RET Z; no animations defined
1640+ 52D7 47               LD B,A
1641+ 52D8 DD 2A F6 4E      LD IX,(ANIMSPRPTR)
1642+ 52DC              .L1:
1643+ 52DC C5               PUSH BC
1644+ 52DD 06 00            LD B,0 ; normal mode, change on timer expiry only
1645+ 52DF CD EB 52         CALL PROCESS_SINGLE_ANIMATION
1646+ 52E2 11 08 00         LD DE,8
1647+ 52E5 DD 19            ADD IX,DE
1648+ 52E7 C1               POP BC
1649+ 52E8 10 F2            DJNZ .L1
1650+ 52EA C9               RET
1651+ 52EB              ; *******************************************************************************************************
1652+ 52EB
1653+ 52EB              ; *******************************************************************************************************
1654+ 52EB              ; processes single sprite animation
1655+ 52EB              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
1656+ 52EB              ; on timer expiry goes to next animation item
1657+ 52EB              ; input IX=sprite animation pointer
1658+ 52EB              ; input B=1 force mode, activate animation action regardless of expired timer
1659+ 52EB              PROCESS_SINGLE_ANIMATION:
1660+ 52EB DD 7E 06         LD A,(IX+6); active
1661+ 52EE B7               OR A
1662+ 52EF C8               RET Z ; inactive animation
1663+ 52F0              .INACTIVE_TOO:
1664+ 52F0 DD 6E 01         LD L,(IX+1)
1665+ 52F3 DD 66 02         LD H,(IX+2) ; HL=end time
1666+ 52F6 2B               DEC HL
1667+ 52F7 DD 75 01         LD (IX+1),L
1668+ 52FA DD 74 02         LD (IX+2),H
1669+ 52FD 7D               LD A,L
1670+ 52FE B4               OR H
1671+ 52FF 28 06            JR Z,.STEP
1672+ 5301 05               DEC B
1673+ 5302 04               INC B
1674+ 5303 C8               RET Z ; not forced mode, return
1675+ 5304 C3 4C 53         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
1676+ 5307              .STEP:
1677+ 5307 06 00            LD B,0; setup timer
1678+ 5309 DD 34 03         INC (IX+3) ; current animation item
1679+ 530C C3 4C 53         JP SETUP_ANIM_STEP
1680+ 530F              ; *******************************************************************************************************
1681+ 530F
1682+ 530F              ; *******************************************************************************************************
1683+ 530F              ; function will setup sprite animation after current item change
1684+ 530F              ; input A=current animation definition
1685+ 530F              ; input IX=pointer to sprite animation
1686+ 530F              ; input B=1 skip timer setup
1687+ 530F              ; output IY=pointer to animation item
1688+ 530F              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
1689+ 530F              ; basically sets new end time for current animation
1690+ 530F              INIT_CURRENT_ANIMATION:
1691+ 530F CD 0D 4F         CALL GETnthANIMDEF
1692+ 5312 DD 7E 03         LD A,(IX+3) ; current animation item
1693+ 5315 BE               CP (HL) ; number of animation items in the animation definition
1694+ 5316 38 0A            JR C,.L3 ; last item not reached
1695+ 5318                  ; last item reached
1696+ 5318 DD 7E 05         LD A,(IX+5) ; cyclic flag
1697+ 531B B7               OR A
1698+ 531C 28 2C            JR Z,.ERROR ; non-cyclic animation
1699+ 531E                  ; cyclic animation, restart
1700+ 531E DD 36 03 00      LD (IX+3),0; current item
1701+ 5322              .L3:
1702+ 5322                  ; HL = animation definition
1703+ 5322 23               INC HL ; skip animation definition size field
1704+ 5323 16 00            LD D,0
1705+ 5325 DD 5E 03         LD E,(IX+3); current item
1706+ 5328 19               ADD HL,DE
1707+ 5329 4E               LD C,(HL) ; current animation item
1708+ 532A 0C               INC C
1709+ 532B 3A EF 4E         LD A,(ANIMITEMNUM)
1710+ 532E B9               CP C
1711+ 532F 38 19            JR C,.ERROR ; invalid animation item, stop animation
1712+ 5331 0D               DEC C
1713+ 5332 79               LD A,C
1714+ 5333 CD 04 4F         CALL GETnthANIMITEM
1715+ 5336 E5               PUSH HL
1716+ 5337 FD E1            POP IY ; IY=animation item
1717+ 5339 05               DEC B
1718+ 533A 28 0C            JR Z,.EXIT
1719+ 533C FD 5E 01         LD E,(IY+1)
1720+ 533F FD 56 02         LD D,(IY+2) ; duration
1721+ 5342 DD 73 01         LD (IX+1),E
1722+ 5345 DD 72 02         LD (IX+2),D
1723+ 5348              .EXIT:
1724+ 5348 AF               XOR A
1725+ 5349 C9               RET
1726+ 534A              .ERROR:
1727+ 534A 37               SCF
1728+ 534B C9               RET
1729+ 534C              ; *******************************************************************************************************
1730+ 534C
1731+ 534C              ; *******************************************************************************************************
1732+ 534C              ; function will display currect item and set up expiry time
1733+ 534C              ; it will also stop the animation if expired
1734+ 534C              ; sets sprite update flag if any changes in sprite data made
1735+ 534C              ; input IX=current sprite animation
1736+ 534C              ; input B=1 skip timer setup
1737+ 534C              SETUP_ANIM_STEP:
1738+ 534C DD 4E 04         LD C,(IX+4) ; animation definition ID
1739+ 534F 0C               INC C
1740+ 5350 3A F2 4E         LD A,(ANIMDEFNUM)
1741+ 5353 B9               CP C
1742+ 5354 30 05            JR NC,.L2
1743+ 5356                  ; given animation item is outside of bounds, deactivate animation
1744+ 5356              .STOPANIM:
1745+ 5356 DD 36 06 00      LD (IX+6),0
1746+ 535A C9               RET
1747+ 535B              .L2:
1748+ 535B 0D               DEC C
1749+ 535C 79               LD A,C
1750+ 535D CD 0F 53         CALL INIT_CURRENT_ANIMATION
1751+ 5360 38 F4            JR C, .STOPANIM
1752+ 5362 FD 7E 00         LD A,(IY) ; type of animation item
1753+ 5365 B7               OR A
1754+ 5366 28 44            JR Z,.L4 ; change pattern and/or color
1755+ 5368              .PAT:
1756+ 5368                  ; change pattern definition
1757+ 5368                  ; check if sprite or character
1758+ 5368 DD 7E 07         LD A,(IX+7)
1759+ 536B B7               OR A
1760+ 536C 20 58            JR NZ,.CHAR
1761+ 536E DD 7E 00         LD A,(IX) ; sprite number
1762+ 5371 CD 89 4D         CALL GETnthSPRATTR
1763+ 5374 23          > INC HL ; skip y and x
1763+ 5375 23          > INC HL
1763+ 5376 23          > INC HL
1763+ 5377 23          > INC HL
1764+ 5378 7E               LD A,(HL); current pattern
1765+ 5379 26 00            LD H,0
1766+ 537B 6F               LD L,A
1767+ 537C 3A E0 F3         LD A,(REG1SAV)
1768+ 537F E6 02            AND 2
1769+ 5381 20 07            JR NZ,.L6
1770+ 5383                  ; 8x8 sprite
1771+ 5383 CD 41 5E         CALL HLx8
1772+ 5386 06 08            LD B,8
1773+ 5388 18 05            JR .L5
1774+ 538A              .L6:
1775+ 538A CD 3F 5E         CALL HLx32
1776+ 538D 06 20            LD B,32
1777+ 538F              .L5:
1778+ 538F 3A AF FC         LD A,(SCRMOD)
1779+ 5392 3D               DEC A
1780+ 5393 20 06            JR NZ,.L10
1781+ 5395 ED 5B C5 F3      LD DE,(T32PAT)
1782+ 5399 18 04            JR .L7
1783+ 539B              .L10:
1784+ 539B ED 5B CF F3      LD DE,(GRPPAT)
1785+ 539F              .L7:
1786+ 539F 19               ADD HL,DE
1787+ 53A0 CD 22 5E         CALL SETWRT_LOCAL_WRITE
1788+ 53A3 FD 6E 03         LD L,(IY+3)
1789+ 53A6 FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
1790+ 53A9 C3 37 5E         JP BBYTECOPY
1791+ 53AC              .L4:
1792+ 53AC                  ; change pattern and color in sprite attributes table
1793+ 53AC DD 7E 00         LD A,(IX) ; sprite number
1794+ 53AF CD 89 4D         CALL GETnthSPRATTR
1795+ 53B2 23          > INC HL ; skip y and x
1795+ 53B3 23          > INC HL
1795+ 53B4 23          > INC HL
1795+ 53B5 23          > INC HL
1796+ 53B6 FD 7E 03         LD A,(IY+3) ; new pattern
1797+ 53B9 77               LD (HL),A
1798+ 53BA 23          > INC HL
1798+ 53BB 23          > INC HL
1799+ 53BC FD 7E 04         LD A,(IY+4) ; new color
1800+ 53BF 77               LD (HL),A
1801+ 53C0 2A 80 4D         LD HL,(SPRATR_UPDATE_FLAG)
1802+ 53C3 36 01            LD (HL),1
1803+ 53C5 C9               RET
1804+ 53C6              .CHAR:
1805+ 53C6 DD 6E 00         LD L,(IX)
1806+ 53C9 3D               DEC A
1807+ 53CA 67               LD H,A
1808+ 53CB CD 41 5E         CALL HLx8
1809+ 53CE 3A AF FC         LD A,(SCRMOD)
1810+ 53D1 3D               DEC A
1811+ 53D2 20 06            JR NZ,.L8
1812+ 53D4 ED 5B C1 F3      LD DE,(T32CGP)
1813+ 53D8 18 04            JR .L9
1814+ 53DA              .L8:
1815+ 53DA ED 5B CB F3      LD DE,(GRPCGP)
1816+ 53DE              .L9:
1817+ 53DE 06 08            LD B,8
1818+ 53E0 18 BD            JR .L7
1819+ 53E2              ; *******************************************************************************************************
1820+ 53E2
# file closed: asm\ANIMATION.asm
 134  53E2               INCLUDE "SGAM.asm"
# file opened: asm\SGAM.asm
   1+ 53E2              ; Sprite Group Animate and Move
   2+ 53E2
   3+ 53E2              ; *******************************************************************************************************
   4+ 53E2              ; shared function to process a list of animations
   5+ 53E2              ; input B=list size
   6+ 53E2              ; input DE=list pointer
   7+ 53E2              SGAM_PROCESS_ANIM_LIST:
   8+ 53E2 21 F5 53         LD HL,.STEP
   9+ 53E5 22 7A 52         LD (ANIM_SETVALUE.FN+1),HL
  10+ 53E8              .L1:
  11+ 53E8 C5               PUSH BC
  12+ 53E9 1A               LD A,(DE)
  13+ 53EA 13          > INC DE
  13+ 53EB 13          > INC DE
  14+ 53EC D5               PUSH DE
  15+ 53ED CD 6A 52         CALL ANIM_SETVALUE
  16+ 53F0 D1               POP DE
  17+ 53F1 C1               POP BC
  18+ 53F2 10 F4            DJNZ .L1
  19+ 53F4 C9           	RET
  20+ 53F5              .STEP:
  21+ 53F5 06 01            LD B,1
  22+ 53F7 C3 F0 52         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
  23+ 53FA              ; *******************************************************************************************************
  24+ 53FA
  25+ 53FA               IF (0 == 1)
  26+ 53FA ~            ; *******************************************************************************************************
  27+ 53FA ~            ; function to handle CALL SGAM basic extension
  28+ 53FA ~            ; sets position of a group of sprites as described in SPRGRPMOV
  29+ 53FA ~            ; and manually animate a list of animations
  30+ 53FA ~            ; _SGAM ( INT x,
  31+ 53FA ~            ;	      INT y,
  32+ 53FA ~            ;		  BYTE count,
  33+ 53FA ~            ;		  INT[2][count] data_ptr,
  34+ 53FA ~            ;         BYTE item_number,
  35+ 53FA ~            ;         INT[] sprite_animations )
  36+ 53FA ~            ; will put ram in page 0 also, page 1 is already there
  37+ 53FA ~            SGAM:
  38+ 53FA ~            	LD A, (SPRATR_INIT_STATUS)
  39+ 53FA ~            	OR A
  40+ 53FA ~            	JP Z,ILLEGAL_FUNCTION
  41+ 53FA ~            	; opening (
  42+ 53FA ~            	CALL CHKCHAR
  43+ 53FA ~            	DB '('
  44+ 53FA ~            	; get x
  45+ 53FA ~            	LD IX, FRMQNT
  46+ 53FA ~            	CALL CALBAS
  47+ 53FA ~            	LD (BLIT_STRUCT),DE
  48+ 53FA ~            	; comma
  49+ 53FA ~            	CALL CHKCHAR
  50+ 53FA ~            	DB ','
  51+ 53FA ~            	; get y
  52+ 53FA ~            	LD IX, FRMQNT
  53+ 53FA ~            	CALL CALBAS
  54+ 53FA ~            	LD (BLIT_STRUCT+2),DE
  55+ 53FA ~            	; comma
  56+ 53FA ~            	CALL CHKCHAR
  57+ 53FA ~            	DB ','
  58+ 53FA ~            	; get count
  59+ 53FA ~            	LD IX, GETBYT
  60+ 53FA ~            	CALL CALBAS
  61+ 53FA ~                OR A
  62+ 53FA ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
  63+ 53FA ~            	LD (BLIT_STRUCT+4),A
  64+ 53FA ~            	; comma
  65+ 53FA ~            	CALL CHKCHAR
  66+ 53FA ~            	DB ','
  67+ 53FA ~            	; get sprite group definition array data pointer
  68+ 53FA ~                LD A,(BLIT_STRUCT+4)
  69+ 53FA ~            	LD E,A
  70+ 53FA ~            	LD D,3
  71+ 53FA ~            	LD A,2
  72+ 53FA ~            	LD B,A
  73+ 53FA ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
  74+ 53FA ~            	LD (BLIT_STRUCT+5),BC
  75+ 53FA ~            	; comma
  76+ 53FA ~            	CALL CHKCHAR
  77+ 53FA ~            	DB ','
  78+ 53FA ~            	; get sprite animation array size
  79+ 53FA ~            	LD IX,GETBYT
  80+ 53FA ~            	CALL CALBAS
  81+ 53FA ~                LD (BLIT_STRUCT+7),A
  82+ 53FA ~                OR A
  83+ 53FA ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
  84+ 53FA ~            	; comma
  85+ 53FA ~            	CALL CHKCHAR
  86+ 53FA ~            	DB ','
  87+ 53FA ~                ; get array pointer
  88+ 53FA ~                LD A,(BLIT_STRUCT+7)
  89+ 53FA ~                LD D,A
  90+ 53FA ~                LD A,2
  91+ 53FA ~                LD B,1
  92+ 53FA ~                CALL GET_BASIC_ARRAY_DATA_POINTER
  93+ 53FA ~                LD (BLIT_STRUCT+8),BC
  94+ 53FA ~            	; ending )
  95+ 53FA ~            	CALL CHKCHAR
  96+ 53FA ~            	DB ')'
  97+ 53FA ~            .ENTRY:
  98+ 53FA ~                PUSH HL
  99+ 53FA ~
 100+ 53FA ~            	; enable page 0
 101+ 53FA ~            	LD IY, .RET
 102+ 53FA ~            	JP ENABLE_PAGE0
 103+ 53FA ~            .RET:
 104+ 53FA ~                EXX
 105+ 53FA ~                LD DE,(BLIT_STRUCT) ; initial x
 106+ 53FA ~                LD BC,(BLIT_STRUCT+2) ; initial y
 107+ 53FA ~                EXX
 108+ 53FA ~                LD HL,(BLIT_STRUCT+5) ; pointer to data
 109+ 53FA ~                LD A,(BLIT_STRUCT+4) ; number of entries
 110+ 53FA ~                LD B,A
 111+ 53FA ~                CALL SPR_UPDATE_LOC
 112+ 53FA ~
 113+ 53FA ~                LD A,(BLIT_STRUCT+7) ; anim number
 114+ 53FA ~                LD B,A
 115+ 53FA ~                LD DE,(BLIT_STRUCT+8) ; anim list
 116+ 53FA ~            	CALL SGAM_PROCESS_ANIM_LIST
 117+ 53FA ~
 118+ 53FA ~                POP DE
 119+ 53FA ~                POP BC
 120+ 53FA ~                CALL RESTORE_PAGE_INFO
 121+ 53FA ~                EI
 122+ 53FA ~                POP HL
 123+ 53FA ~                RET
 124+ 53FA ~            ; *******************************************************************************************************
 125+ 53FA               ENDIF
 126+ 53FA
 127+ 53FA               IF (1 == 1)
 128+ 53FA              ; *******************************************************************************************************
 129+ 53FA              ; same as SGAM but for DEFUSR approach
 130+ 53FA              ; input IX=pointer to input array, real data from +2
 131+ 53FA              ; +02 = X
 132+ 53FA              ; +04 = Y
 133+ 53FA              ; +06 = count
 134+ 53FA              ; +08 = data pointer
 135+ 53FA              ; +10 = anim number
 136+ 53FA              ; +12 = sprite animations
 137+ 53FA              SGAM_DEFUSR:
 138+ 53FA              	; enable page 0
 139+ 53FA FD 21 01 54  	LD IY, .RET
 140+ 53FE C3 05 5F     	JP ENABLE_PAGE0
 141+ 5401              .RET:
 142+ 5401 FB           	EI
 143+ 5402 D9               EXX
 144+ 5403 DD 5E 02     	LD E,(IX+2)
 145+ 5406 DD 56 03     	LD D,(IX+3) ; initial x
 146+ 5409 DD 4E 04     	LD C,(IX+4)
 147+ 540C DD 46 05     	LD B,(IX+5) ; initial y
 148+ 540F D9               EXX
 149+ 5410 DD 6E 08     	LD L,(IX+8)
 150+ 5413 DD 66 09     	LD H,(IX+9) ; pointer to data
 151+ 5416 DD 46 06         LD B,(IX+6) ; count
 152+ 5419 DD E5        	PUSH IX
 153+ 541B CD BA 4E         CALL SPR_UPDATE_LOC
 154+ 541E DD E1        	POP IX
 155+ 5420 DD 46 0A         LD B,(IX+10) ; anim number
 156+ 5423 DD 5E 0C     	LD E,(IX+12)
 157+ 5426 DD 56 0D     	LD D,(IX+13)
 158+ 5429 CD E2 53     	CALL SGAM_PROCESS_ANIM_LIST
 159+ 542C
 160+ 542C D1               POP DE
 161+ 542D C1               POP BC
 162+ 542E C3 7C 5E         JP RESTORE_PAGE_INFO
 163+ 5431              ; *******************************************************************************************************
 164+ 5431               ENDIF
 165+ 5431
 166+ 5431              ; *******************************************************************************************************
 167+ 5431              ; handles automatic move and animate sprite groups during interrupt
 168+ 5431              PROCESS_AUTOSGAMS:
 169+ 5431 3A F8 4E     	LD A,(AUTOSGAMNUM)
 170+ 5434 B7           	OR A
 171+ 5435 C8           	RET Z
 172+ 5436 47           	LD B,A
 173+ 5437 DD 2A F9 4E  	LD IX,(AUTOSGAMPTR)
 174+ 543B              .L1:
 175+ 543B C5           	PUSH BC
 176+ 543C DD 7E 13     	LD A,(IX+19) ; active flag
 177+ 543F B7           	OR A
 178+ 5440 28 28        	JR Z,.LOOPEND
 179+ 5442              	; active, check timer
 180+ 5442 DD 6E 16     	LD L,(IX+22)
 181+ 5445 DD 66 17     	LD H,(IX+23) ; timer
 182+ 5448 2B           	DEC HL
 183+ 5449 7C           	LD A,H
 184+ 544A B5           	OR L
 185+ 544B 28 08        	JR Z,.L2
 186+ 544D              	; not expired
 187+ 544D DD 75 16     	LD (IX+22),L
 188+ 5450 DD 74 17     	LD (IX+23),H
 189+ 5453 18 15        	JR .LOOPEND
 190+ 5455              .L2:
 191+ 5455              	; expired, process
 192+ 5455
 193+ 5455                  ; set initial timer
 194+ 5455 DD 7E 14         LD A,(IX+20)
 195+ 5458 DD 77 16         LD (IX+22),A
 196+ 545B DD 7E 15         LD A,(IX+21)
 197+ 545E DD 77 17         LD (IX+23),A
 198+ 5461
 199+ 5461 CD 73 54     	CALL .MOVE
 200+ 5464 CD DE 54     	CALL .UPDATELOC
 201+ 5467 CD 03 55     	CALL .PROCESS_ANIM_LIST
 202+ 546A
 203+ 546A              .LOOPEND:
 204+ 546A 11 18 00     	LD DE,24
 205+ 546D DD 19        	ADD IX,DE
 206+ 546F C1           	POP BC
 207+ 5470 10 C9        	DJNZ .L1
 208+ 5472 C9           	RET
 209+ 5473
 210+ 5473              .MOVE:
 211+ 5473              	; process movement
 212+ 5473 DD 7E 0A     	LD A,(IX+10) ; direction
 213+ 5476 B7           	OR A
 214+ 5477 28 08        	JR Z, .MOVE_L1
 215+ 5479              	; vertical
 216+ 5479 DD 6E 02     	LD L,(IX+2)
 217+ 547C DD 66 03     	LD H,(IX+3) ; vertical variable pointer
 218+ 547F 18 06        	JR .MOVE_L2
 219+ 5481              .MOVE_L1:
 220+ 5481              	; horizontal
 221+ 5481 DD 6E 00     	LD L,(IX+0)
 222+ 5484 DD 66 01     	LD H,(IX+1) ; horizontal variable pointer
 223+ 5487              .MOVE_L2:
 224+ 5487 E5           	PUSH HL
 225+ 5488 FD E1        	POP IY
 226+ 548A FD 6E 00     	LD L,(IY+0)
 227+ 548D FD 66 01     	LD H,(IY+1)
 228+ 5490 DD 5E 08     	LD E,(IX+8)
 229+ 5493 DD 56 09     	LD D,(IX+9) ; delta value
 230+ 5496 19           	ADD HL,DE
 231+ 5497 E5           	PUSH HL
 232+ 5498 DD 5E 04     	LD E,(IX+4)
 233+ 549B DD 56 05     	LD D,(IX+5) ; minimum value
 234+ 549E A7           	AND A
 235+ 549F ED 52        	SBC HL,DE
 236+ 54A1 FA BB 54     	JP M,.MOVE_L3 ; below minimum
 237+ 54A4 E1           	POP HL
 238+ 54A5 E5           	PUSH HL
 239+ 54A6 DD 5E 06     	LD E,(IX+6)
 240+ 54A9 DD 56 07     	LD D,(IX+7) ; maximum value
 241+ 54AC EB           	EX DE,HL
 242+ 54AD A7           	AND A
 243+ 54AE ED 52        	SBC HL,DE
 244+ 54B0 FA C3 54     	JP M,.MOVE_L4 ; above maximum
 245+ 54B3 E1           	POP HL
 246+ 54B4              	; within bounds
 247+ 54B4              .MOVE_L5:
 248+ 54B4 FD 75 00     	LD (IY+0),L
 249+ 54B7 FD 74 01     	LD (IY+1),H
 250+ 54BA C9           	RET
 251+ 54BB              .MOVE_L3:
 252+ 54BB E1           	POP HL
 253+ 54BC CD CF 54     	CALL .INVERSE_DELTA
 254+ 54BF 6B           	LD L,E
 255+ 54C0 62           	LD H,D
 256+ 54C1 18 F1        	JR .MOVE_L5
 257+ 54C3              .MOVE_L4:
 258+ 54C3 E1           	POP HL
 259+ 54C4 CD CF 54     	CALL .INVERSE_DELTA
 260+ 54C7 DD 6E 06     	LD L,(IX+6)
 261+ 54CA DD 66 07     	LD H,(IX+7) ; maximum
 262+ 54CD 18 E5        	JR .MOVE_L5
 263+ 54CF              .INVERSE_DELTA:
 264+ 54CF AF           	XOR A
 265+ 54D0 DD 96 08     	SUB (IX+8)
 266+ 54D3 DD 77 08     	LD (IX+8),A
 267+ 54D6 9F           	SBC A,A
 268+ 54D7 DD 96 09     	SUB (IX+9)
 269+ 54DA DD 77 09     	LD (IX+9),A
 270+ 54DD C9           	RET
 271+ 54DE
 272+ 54DE              .UPDATELOC:
 273+ 54DE DD E5        	PUSH IX
 274+ 54E0 D9           	EXX
 275+ 54E1 DD 6E 00     	LD L,(IX+0)
 276+ 54E4 DD 66 01     	LD H,(IX+1)
 277+ 54E7 5E           	LD E,(HL)
 278+ 54E8 23           	INC HL
 279+ 54E9 56           	LD D,(HL)
 280+ 54EA DD 6E 02     	LD L,(IX+2)
 281+ 54ED DD 66 03     	LD H,(IX+3)
 282+ 54F0 4E           	LD C,(HL)
 283+ 54F1 23           	INC HL
 284+ 54F2 46           	LD B,(HL)
 285+ 54F3 D9           	EXX
 286+ 54F4 DD 6E 0C     	LD L,(IX+12)
 287+ 54F7 DD 66 0D     	LD H,(IX+13) ; pointer to sprite group data
 288+ 54FA DD 46 0B     	LD B,(IX+11) ; sprite group size
 289+ 54FD CD BA 4E     	CALL SPR_UPDATE_LOC
 290+ 5500 DD E1        	POP IX
 291+ 5502 C9           	RET
 292+ 5503
 293+ 5503              .PROCESS_ANIM_LIST:
 294+ 5503 DD E5        	PUSH IX
 295+ 5505 DD 46 0E         LD B,(IX+14) ; anim list size
 296+ 5508 DD CB 09 7E  	BIT 7,(IX+9)
 297+ 550C 28 08        	JR Z,.PROCESS_ANIM_LIST_L1
 298+ 550E              	; negative direction
 299+ 550E DD 5E 0F     	LD E,(IX+15)
 300+ 5511 DD 56 10     	LD D,(IX+16)
 301+ 5514 18 06        	JR .PROCESS_ANIM_LIST_L2
 302+ 5516              .PROCESS_ANIM_LIST_L1:
 303+ 5516              	; positive direction
 304+ 5516 DD 5E 11     	LD E,(IX+17)
 305+ 5519 DD 56 12     	LD D,(IX+18)
 306+ 551C              .PROCESS_ANIM_LIST_L2:
 307+ 551C CD E2 53     	CALL SGAM_PROCESS_ANIM_LIST
 308+ 551F DD E1        	POP IX
 309+ 5521 C9           	RET
 310+ 5522              ; *******************************************************************************************************
 311+ 5522
# file closed: asm\SGAM.asm
 135  5522               ENDIF
 136  5522
 137  5522               IF (RAM_CMDS == 1)
 138  5522               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
   1+ 5522               IF (0 == 1)
   2+ 5522 ~            ; *******************************************************************************************************
   3+ 5522 ~            ; function to handle CALL MEMCPY basic extension
   4+ 5522 ~            ; _MEMCPY ( INT source,
   5+ 5522 ~            ;			INT destination,
   6+ 5522 ~            ;			INT count,
   7+ 5522 ~            ; will put ram in page 0 also, page 1 is already there
   8+ 5522 ~            MEMCPY:
   9+ 5522 ~            	; opening (
  10+ 5522 ~            	CALL CHKCHAR
  11+ 5522 ~            	DB '('
  12+ 5522 ~            	; get source address
  13+ 5522 ~            	LD IX, FRMQNT
  14+ 5522 ~            	CALL CALBAS
  15+ 5522 ~            	PUSH DE
  16+ 5522 ~            	; comma
  17+ 5522 ~            	CALL CHKCHAR
  18+ 5522 ~            	DB ','
  19+ 5522 ~            	; get destination address
  20+ 5522 ~            	LD IX, FRMQNT
  21+ 5522 ~            	CALL CALBAS
  22+ 5522 ~            	PUSH DE
  23+ 5522 ~            	; comma
  24+ 5522 ~            	CALL CHKCHAR
  25+ 5522 ~            	DB ','
  26+ 5522 ~            	; get length
  27+ 5522 ~            	LD IX, FRMQNT
  28+ 5522 ~            	CALL CALBAS
  29+ 5522 ~            	PUSH DE
  30+ 5522 ~            	; ending )
  31+ 5522 ~            	CALL CHKCHAR
  32+ 5522 ~            	DB ')'
  33+ 5522 ~
  34+ 5522 ~            	; save position
  35+ 5522 ~            	PUSH HL
  36+ 5522 ~            	POP IX
  37+ 5522 ~
  38+ 5522 ~            	POP BC ; count
  39+ 5522 ~            	POP DE ; destination
  40+ 5522 ~            	POP HL ; source
  41+ 5522 ~            	EXX
  42+ 5522 ~            	; enable page 0
  43+ 5522 ~            	LD IY, .RET
  44+ 5522 ~            	JP ENABLE_PAGE0
  45+ 5522 ~            .RET:
  46+ 5522 ~            	EI
  47+ 5522 ~            	EXX
  48+ 5522 ~            	LDIR
  49+ 5522 ~                POP DE
  50+ 5522 ~                POP BC
  51+ 5522 ~                CALL RESTORE_PAGE_INFO
  52+ 5522 ~            	PUSH IX
  53+ 5522 ~            	POP HL
  54+ 5522 ~            	RET
  55+ 5522 ~            ; *******************************************************************************************************
  56+ 5522               ENDIF
  57+ 5522
  58+ 5522               IF (1 == 1)
  59+ 5522              ; *******************************************************************************************************
  60+ 5522              ; same as MEMCPY but for DEFUSR approach
  61+ 5522              ; input IX=pointer to input array, real data from +2
  62+ 5522              ; +2 = source address
  63+ 5522              ; +4 = destination address
  64+ 5522              ; +6 = lenght
  65+ 5522              MEMCPY_DEFUSR:
  66+ 5522              	; enable page 0
  67+ 5522 FD 21 29 55  	LD IY, .RET
  68+ 5526 C3 05 5F     	JP ENABLE_PAGE0
  69+ 5529              .RET:
  70+ 5529 FB           	EI
  71+ 552A DD 6E 02     	LD L,(IX+2)
  72+ 552D DD 66 03     	LD H,(IX+3)
  73+ 5530 DD 5E 04     	LD E,(IX+4)
  74+ 5533 DD 56 05     	LD D,(IX+5)
  75+ 5536 DD 4E 06     	LD C,(IX+6)
  76+ 5539 DD 46 07     	LD B,(IX+7)
  77+ 553C ED B0        	LDIR
  78+ 553E D1               POP DE
  79+ 553F C1               POP BC
  80+ 5540 C3 7C 5E         JP RESTORE_PAGE_INFO
  81+ 5543              ; *******************************************************************************************************
  82+ 5543               ENDIF
  83+ 5543
  84+ 5543               IF (0 == 1)
  85+ 5543 ~            ; *******************************************************************************************************
  86+ 5543 ~            ; function to handle CALL FILRAM basic extension
  87+ 5543 ~            ; FILRAM ( INT start address,
  88+ 5543 ~            ;		   INT count,
  89+ 5543 ~            ;		   BYTE value )
  90+ 5543 ~            ; will put ram in page 0 also, page 1 is already there
  91+ 5543 ~            FILRAM:
  92+ 5543 ~            	; opening (
  93+ 5543 ~            	CALL CHKCHAR
  94+ 5543 ~            	DB '('
  95+ 5543 ~            	; get start address
  96+ 5543 ~            	LD IX, FRMQNT
  97+ 5543 ~            	CALL CALBAS
  98+ 5543 ~            	PUSH DE
  99+ 5543 ~            	; comma
 100+ 5543 ~            	CALL CHKCHAR
 101+ 5543 ~            	DB ','
 102+ 5543 ~            	; get count
 103+ 5543 ~            	LD IX, FRMQNT
 104+ 5543 ~            	CALL CALBAS
 105+ 5543 ~            	PUSH DE
 106+ 5543 ~            	; comma
 107+ 5543 ~            	CALL CHKCHAR
 108+ 5543 ~            	DB ','
 109+ 5543 ~            	; get value
 110+ 5543 ~            	LD IX, GETBYT
 111+ 5543 ~            	CALL CALBAS
 112+ 5543 ~            	PUSH AF
 113+ 5543 ~            	; ending )
 114+ 5543 ~            	CALL CHKCHAR
 115+ 5543 ~            	DB ')'
 116+ 5543 ~
 117+ 5543 ~            	; save position
 118+ 5543 ~            	PUSH HL
 119+ 5543 ~            	POP IX
 120+ 5543 ~
 121+ 5543 ~            	POP DE ; actually AF
 122+ 5543 ~            	POP BC ; count
 123+ 5543 ~            	POP HL ; start address
 124+ 5543 ~            	LD A, B
 125+ 5543 ~            	OR C
 126+ 5543 ~            	JR Z, .EXIT ; 0 bytes to fill, skip
 127+ 5543 ~            	EXX
 128+ 5543 ~            	; enable page 0
 129+ 5543 ~            	LD IY, .RET
 130+ 5543 ~            	JP ENABLE_PAGE0
 131+ 5543 ~            .RET:
 132+ 5543 ~            	EI
 133+ 5543 ~            	EXX
 134+ 5543 ~            	CALL FILVRM_FILLVALUE
 135+ 5543 ~                POP DE
 136+ 5543 ~                POP BC
 137+ 5543 ~                CALL RESTORE_PAGE_INFO
 138+ 5543 ~            .EXIT:
 139+ 5543 ~            	PUSH IX
 140+ 5543 ~            	POP HL
 141+ 5543 ~            	RET
 142+ 5543 ~            ; *******************************************************************************************************
 143+ 5543               ENDIF
 144+ 5543
 145+ 5543               IF (1 == 1)
 146+ 5543              ; *******************************************************************************************************
 147+ 5543              ; same as FILVRM but for DEFUSR approach
 148+ 5543              ; input IX=pointer to input array, real data from +2
 149+ 5543              ; +2 = start address
 150+ 5543              ; +4 = count
 151+ 5543              ; +6 = value
 152+ 5543              FILRAM_DEFUSR:
 153+ 5543              	; enable page 0
 154+ 5543 FD 21 4A 55  	LD IY, .RET
 155+ 5547 C3 05 5F     	JP ENABLE_PAGE0
 156+ 554A              .RET:
 157+ 554A FB           	EI
 158+ 554B DD 6E 02     	LD L,(IX+2)
 159+ 554E DD 66 03     	LD H,(IX+3)
 160+ 5551 DD 4E 04     	LD C,(IX+4)
 161+ 5554 DD 46 05     	LD B,(IX+5)
 162+ 5557 78           	LD A,B
 163+ 5558 B1           	OR C
 164+ 5559 28 06        	JR Z,.EXIT
 165+ 555B DD 56 06     	LD D,(IX+6)
 166+ 555E CD 66 55     	CALL FILVRM_FILLVALUE
 167+ 5561              .EXIT:
 168+ 5561 D1               POP DE
 169+ 5562 C1               POP BC
 170+ 5563 C3 7C 5E         JP RESTORE_PAGE_INFO
 171+ 5566              ; *******************************************************************************************************
 172+ 5566               ENDIF
 173+ 5566
 174+ 5566              ; *******************************************************************************************************
 175+ 5566              ; common function to fill RAM
 176+ 5566              FILVRM_FILLVALUE:
 177+ 5566 72               LD (HL), D
 178+ 5567 54               LD D, H
 179+ 5568 5D               LD E, L
 180+ 5569 13               INC DE
 181+ 556A 0B               DEC BC
 182+ 556B 78           	LD A,B
 183+ 556C B1           	OR C
 184+ 556D C8           	RET Z ; if count was 1
 185+ 556E ED B0            LDIR
 186+ 5570 C9               RET
 187+ 5571              ; *******************************************************************************************************
# file closed: asm\MEMORY.asm
 139  5571               ENDIF
 140  5571
 141  5571               IF (SOUND_CMDS == 1)
 142  5571               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
   1+ 5571              MUSIC_INIT_STATUS:
   2+ 5571 00            DB 0
   3+ 5572              SFX_INIT_STATUS:
   4+ 5572 00            DB 0
   5+ 5573              SOUND_ENABLED:
   6+ 5573 00            DB 0
   7+ 5574
   8+ 5574               IF (0 == 1)
   9+ 5574 ~            ; *******************************************************************************************************
  10+ 5574 ~            ; function to handle CALL SNDPLYINIT basic extension
  11+ 5574 ~            ; initializes sound player
  12+ 5574 ~            ; _SNDPLYINIT ( INT music_offset,
  13+ 5574 ~            ;				INT sfx_offset, can be -1 if no SFX
  14+ 5574 ~            ; will put ram in page 0 also, page 1 is already there
  15+ 5574 ~            ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
  16+ 5574 ~            SNDPLYINIT:
  17+ 5574 ~            	; opening (
  18+ 5574 ~            	CALL CHKCHAR
  19+ 5574 ~            	DB '('
  20+ 5574 ~            	; get music address
  21+ 5574 ~            	LD IX, FRMQNT
  22+ 5574 ~            	CALL CALBAS
  23+ 5574 ~            	PUSH DE
  24+ 5574 ~            	; comma
  25+ 5574 ~            	CALL CHKCHAR
  26+ 5574 ~            	DB ','
  27+ 5574 ~            	; get sfx address
  28+ 5574 ~            	LD IX, FRMQNT
  29+ 5574 ~            	CALL CALBAS
  30+ 5574 ~            	PUSH DE
  31+ 5574 ~            	; ending )
  32+ 5574 ~            	CALL CHKCHAR
  33+ 5574 ~            	DB ')'
  34+ 5574 ~
  35+ 5574 ~                ; save position in BASIC text
  36+ 5574 ~            	LD B, H
  37+ 5574 ~            	LD C, L
  38+ 5574 ~
  39+ 5574 ~            	; pop LDIR parameters and store away for later
  40+ 5574 ~            	POP DE ; sfx address
  41+ 5574 ~            	POP HL ; music address
  42+ 5574 ~            	PUSH BC ; basic text location
  43+ 5574 ~            	EXX
  44+ 5574 ~            	LD IY, .RET
  45+ 5574 ~            	JP ENABLE_PAGE0
  46+ 5574 ~            .RET:
  47+ 5574 ~            	EXX
  48+ 5574 ~
  49+ 5574 ~            	PUSH DE
  50+ 5574 ~            	XOR A
  51+ 5574 ~            	; HL = music location
  52+ 5574 ~            	CALL PLY_AKG_INIT
  53+ 5574 ~            	LD A, 1
  54+ 5574 ~            	LD (MUSIC_INIT_STATUS), A
  55+ 5574 ~
  56+ 5574 ~            	POP HL ; SFX
  57+ 5574 ~            	; check if SFX address -1
  58+ 5574 ~            	INC HL
  59+ 5574 ~            	LD A, L
  60+ 5574 ~            	OR H
  61+ 5574 ~            	JR Z,.L1
  62+ 5574 ~            	DEC HL
  63+ 5574 ~            	CALL PLY_AKG_INITSOUNDEFFECTS
  64+ 5574 ~            	LD A, 1
  65+ 5574 ~            	LD (SFX_INIT_STATUS), A
  66+ 5574 ~            .L1:
  67+ 5574 ~                POP DE
  68+ 5574 ~                POP BC
  69+ 5574 ~                CALL RESTORE_PAGE_INFO
  70+ 5574 ~
  71+ 5574 ~            	POP HL
  72+ 5574 ~            	RET
  73+ 5574 ~            ; *******************************************************************************************************
  74+ 5574               ENDIF
  75+ 5574
  76+ 5574               IF (1 == 1)
  77+ 5574              ; *******************************************************************************************************
  78+ 5574              ; same as SNDPLYINI but for DEFUSR approach
  79+ 5574              ; input IX=pointer to input array, real data from +2
  80+ 5574              ; +2 = music address
  81+ 5574              ; +4 = sfx address
  82+ 5574              SNDPLYINI_DEFUSR:
  83+ 5574 FD 21 7B 55  	LD IY, .RET
  84+ 5578 C3 05 5F     	JP ENABLE_PAGE0
  85+ 557B              .RET:
  86+ 557B AF           	XOR A
  87+ 557C DD 6E 02     	LD L,(IX+2)
  88+ 557F DD 66 03     	LD H,(IX+3)
  89+ 5582 DD E5        	PUSH IX
  90+ 5584 CD 65 41     	CALL PLY_AKG_INIT
  91+ 5587 DD E1        	POP IX
  92+ 5589 3E 01        	LD A, 1
  93+ 558B 32 71 55     	LD (MUSIC_INIT_STATUS), A
  94+ 558E
  95+ 558E DD 6E 04     	LD L,(IX+4)
  96+ 5591 DD 66 05     	LD H,(IX+5)
  97+ 5594              	; check if SFX address -1
  98+ 5594 23           	INC HL
  99+ 5595 7D           	LD A, L
 100+ 5596 B4           	OR H
 101+ 5597 28 09        	JR Z,.L1
 102+ 5599 2B           	DEC HL
 103+ 559A CD 20 40     	CALL PLY_AKG_INITSOUNDEFFECTS
 104+ 559D 3E 01        	LD A, 1
 105+ 559F 32 72 55     	LD (SFX_INIT_STATUS), A
 106+ 55A2              .L1:
 107+ 55A2 D1               POP DE
 108+ 55A3 C1               POP BC
 109+ 55A4 C3 7C 5E         JP RESTORE_PAGE_INFO
 110+ 55A7              ; *******************************************************************************************************
 111+ 55A7               ENDIF
 112+ 55A7
 113+ 55A7              ; *******************************************************************************************************
 114+ 55A7              ; function to handle CALL SNDPLYON basic extension
 115+ 55A7              ; enables sound player
 116+ 55A7              ; _SNDPLYON
 117+ 55A7              ; sets SOUND_ENABLED variable to 1 if init call was done
 118+ 55A7              ; if not throws out of data error
 119+ 55A7              SNDPLYON_DEFUSR:
 120+ 55A7              SNDPLYON:
 121+ 55A7 3A 71 55     	LD A, (MUSIC_INIT_STATUS)
 122+ 55AA B7           	OR A
 123+ 55AB 20 05        	JR NZ, .L1
 124+ 55AD              	; player not initialized, throw error
 125+ 55AD 1E 04        	LD E, 04 ; Out of DATA
 126+ 55AF C3 7A 5F     	JP THROW_ERROR
 127+ 55B2              .L1:
 128+ 55B2 32 73 55     	LD (SOUND_ENABLED), A
 129+ 55B5              	; disable key click
 130+ 55B5 AF           	XOR A
 131+ 55B6 32 DB F3     	LD (CLIKSW), A
 132+ 55B9 C9           	RET
 133+ 55BA              ; *******************************************************************************************************
 134+ 55BA
 135+ 55BA              ; *******************************************************************************************************
 136+ 55BA              ; function to handle CALL SNDPLYOFF basic extension
 137+ 55BA              ; disables sound player
 138+ 55BA              ; _SNDPLYOFF
 139+ 55BA              ; sets SOUND_ENABLED variable to 0
 140+ 55BA              ; calls AKG to stop music and SFX on all channels if initialized
 141+ 55BA              SNDPLYOFF_DEFUSR:
 142+ 55BA              SNDPLYOFF:
 143+ 55BA 3A 73 55     	LD A, (SOUND_ENABLED)
 144+ 55BD B7           	OR A
 145+ 55BE C8           	RET Z ; already stopped
 146+ 55BF AF           	XOR A
 147+ 55C0 32 73 55     	LD (SOUND_ENABLED), A
 148+ 55C3 E5           	PUSH HL
 149+ 55C4 CD 24 42     	CALL PLY_AKG_STOP
 150+ 55C7 3A 72 55     	LD A, (SFX_INIT_STATUS)
 151+ 55CA B7           	OR A
 152+ 55CB 28 0E        	JR Z, .EXIT ; SFX not in use
 153+ 55CD AF           	XOR A
 154+ 55CE CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 155+ 55D1 3E 01        	LD A, 1
 156+ 55D3 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 157+ 55D6 3E 02        	LD A, 2
 158+ 55D8 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 159+ 55DB              .EXIT:
 160+ 55DB E1           	POP HL
 161+ 55DC C9           	RET
 162+ 55DD              ; *******************************************************************************************************
 163+ 55DD
 164+ 55DD               IF (0 == 1)
 165+ 55DD ~            ; *******************************************************************************************************
 166+ 55DD ~            ; function to handle CALL SNDSFX basic extension
 167+ 55DD ~            ; plays a sound effect
 168+ 55DD ~            ; _SNDSFX ( BYTE sfx_number, >0
 169+ 55DD ~            ;			BYTE channel, = 0,1 or 2
 170+ 55DD ~            ;			BYTE inverted_volume = 0-16, 0 being full volume
 171+ 55DD ~            ; will put ram in page 0 also, page 1 is already there
 172+ 55DD ~            ; if sound off throws illegal function call
 173+ 55DD ~            ; if sfx not initialized, throws out of data
 174+ 55DD ~            SNDSFX:
 175+ 55DD ~            	; opening (
 176+ 55DD ~            	CALL CHKCHAR
 177+ 55DD ~            	DB '('
 178+ 55DD ~            	; get sfx_number
 179+ 55DD ~            	LD IX, GETBYT
 180+ 55DD ~            	CALL CALBAS
 181+ 55DD ~            	PUSH DE
 182+ 55DD ~            	; comma
 183+ 55DD ~            	CALL CHKCHAR
 184+ 55DD ~            	DB ','
 185+ 55DD ~            	; get sfx address
 186+ 55DD ~            	LD IX, GETBYT
 187+ 55DD ~            	CALL CALBAS
 188+ 55DD ~            	PUSH DE
 189+ 55DD ~            	; comma
 190+ 55DD ~            	CALL CHKCHAR
 191+ 55DD ~            	DB ','
 192+ 55DD ~            	; get inverted volume
 193+ 55DD ~            	LD IX, GETBYT
 194+ 55DD ~            	CALL CALBAS
 195+ 55DD ~            	PUSH DE
 196+ 55DD ~            	; ending )
 197+ 55DD ~            	CALL CHKCHAR
 198+ 55DD ~            	DB ')'
 199+ 55DD ~
 200+ 55DD ~            	LD A, (SOUND_ENABLED)
 201+ 55DD ~            	OR A
 202+ 55DD ~            	JR NZ, .L1
 203+ 55DD ~            	; sound disabled, throw illegal function call
 204+ 55DD ~            	LD E, 5
 205+ 55DD ~            	JP THROW_ERROR
 206+ 55DD ~            .L1:
 207+ 55DD ~            	LD A, (SFX_INIT_STATUS)
 208+ 55DD ~            	OR A
 209+ 55DD ~            	JR NZ, .L2
 210+ 55DD ~            	; sfx data not initialized, throw out of data
 211+ 55DD ~            	LD E, 4
 212+ 55DD ~            	JP THROW_ERROR
 213+ 55DD ~            .L2:
 214+ 55DD ~            	; pop  parameters and store away for later
 215+ 55DD ~            	POP DE ; inverted volume
 216+ 55DD ~            	LD B, E
 217+ 55DD ~            	POP DE ; channel
 218+ 55DD ~            	LD C, E
 219+ 55DD ~            	POP DE
 220+ 55DD ~            	LD A, E
 221+ 55DD ~            	EX AF, AF'
 222+ 55DD ~            	PUSH HL ; basic text location
 223+ 55DD ~            	EXX
 224+ 55DD ~            	LD IY, .RET
 225+ 55DD ~            	JP ENABLE_PAGE0
 226+ 55DD ~            .RET:
 227+ 55DD ~            	EXX
 228+ 55DD ~            	EX AF, AF'
 229+ 55DD ~            	CALL PLY_AKG_PLAYSOUNDEFFECT
 230+ 55DD ~
 231+ 55DD ~                POP DE
 232+ 55DD ~                POP BC
 233+ 55DD ~                CALL RESTORE_PAGE_INFO
 234+ 55DD ~
 235+ 55DD ~            	POP HL
 236+ 55DD ~            	RET
 237+ 55DD ~            ; *******************************************************************************************************
 238+ 55DD               ENDIF
 239+ 55DD
 240+ 55DD               IF (1 == 1)
 241+ 55DD              ; *******************************************************************************************************
 242+ 55DD              ; same as SNDSFX but for DEFUSR approach
 243+ 55DD              ; input IX=pointer to input array, real data from +2
 244+ 55DD              ; +2 = SFX number
 245+ 55DD              ; +4 = channel
 246+ 55DD              ; +6 = volume
 247+ 55DD              SNDSFX_DEFUSR:
 248+ 55DD 3A 73 55     	LD A, (SOUND_ENABLED)
 249+ 55E0 B7           	OR A
 250+ 55E1 C8           	RET Z ; sound disabled, just exit
 251+ 55E2 3A 72 55     	LD A, (SFX_INIT_STATUS)
 252+ 55E5 B7           	OR A
 253+ 55E6 C8           	RET Z ; sfx data not initialized, just exit
 254+ 55E7 FD 21 EE 55  	LD IY, .RET
 255+ 55EB C3 05 5F     	JP ENABLE_PAGE0
 256+ 55EE              .RET:
 257+ 55EE FB           	EI
 258+ 55EF DD 7E 02     	LD A,(IX+2) ; SFX number
 259+ 55F2 DD 4E 04     	LD C,(IX+4) ; channel
 260+ 55F5 DD 46 06     	LD B,(IX+6) ; volume
 261+ 55F8 CD 24 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
 262+ 55FB D1               POP DE
 263+ 55FC C1               POP BC
 264+ 55FD C3 7C 5E         JP RESTORE_PAGE_INFO
 265+ 5600              ; *******************************************************************************************************
 266+ 5600               ENDIF
# file closed: asm\SOUND.asm
 143  5600               ENDIF
 144  5600
 145  5600               IF (VRAM_CMDS == 1)
 146  5600               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
   1+ 5600               IF (0 == 1)
   2+ 5600 ~            ; *******************************************************************************************************
   3+ 5600 ~            ; function to handle CALL FILVRM basic extension
   4+ 5600 ~            ; FILVRM ( INT offset,
   5+ 5600 ~            ;		   INT count,
   6+ 5600 ~            ;		   BYTE value,
   7+ 5600 ~            ;		   BYTE wait_vsync) >0 = true
   8+ 5600 ~            ; wait_vsync will issue HALT before copying
   9+ 5600 ~            FILVRM:
  10+ 5600 ~            	; opening (
  11+ 5600 ~            	CALL CHKCHAR
  12+ 5600 ~            	DB '('
  13+ 5600 ~            	; get offset address
  14+ 5600 ~            	LD IX, FRMQNT
  15+ 5600 ~            	CALL CALBAS
  16+ 5600 ~            	PUSH DE
  17+ 5600 ~            	; comma
  18+ 5600 ~            	CALL CHKCHAR
  19+ 5600 ~            	DB ','
  20+ 5600 ~            	; get count
  21+ 5600 ~            	LD IX, FRMQNT
  22+ 5600 ~            	CALL CALBAS
  23+ 5600 ~            	PUSH DE
  24+ 5600 ~            	; comma
  25+ 5600 ~            	CALL CHKCHAR
  26+ 5600 ~            	DB ','
  27+ 5600 ~            	; get value
  28+ 5600 ~            	LD IX, GETBYT
  29+ 5600 ~            	CALL CALBAS
  30+ 5600 ~            	PUSH AF
  31+ 5600 ~            	; comma
  32+ 5600 ~            	CALL CHKCHAR
  33+ 5600 ~            	DB ','
  34+ 5600 ~            	; get vsync wait
  35+ 5600 ~            	LD IX, GETBYT
  36+ 5600 ~            	CALL CALBAS
  37+ 5600 ~            	PUSH AF
  38+ 5600 ~            	; ending )
  39+ 5600 ~            	CALL CHKCHAR
  40+ 5600 ~            	DB ')'
  41+ 5600 ~
  42+ 5600 ~            	; save position
  43+ 5600 ~            	PUSH HL
  44+ 5600 ~            	POP IX
  45+ 5600 ~
  46+ 5600 ~            	; syntax ok
  47+ 5600 ~            	; wait for vsync if needed
  48+ 5600 ~            	POP AF
  49+ 5600 ~            	OR A
  50+ 5600 ~            	JR Z, .L1
  51+ 5600 ~            	HALT
  52+ 5600 ~
  53+ 5600 ~            .L1:
  54+ 5600 ~            	LD A,1
  55+ 5600 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  56+ 5600 ~                POP AF ; value
  57+ 5600 ~                POP BC ; count
  58+ 5600 ~                POP HL ; offset
  59+ 5600 ~                CALL BIOS_FILVRM
  60+ 5600 ~            	XOR A
  61+ 5600 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  62+ 5600 ~
  63+ 5600 ~            .L3:
  64+ 5600 ~            	PUSH IX
  65+ 5600 ~            	POP HL
  66+ 5600 ~            	RET
  67+ 5600 ~            ; *******************************************************************************************************
  68+ 5600               ENDIF
  69+ 5600
  70+ 5600               IF (1 == 1)
  71+ 5600              ; *******************************************************************************************************
  72+ 5600              ; same as FILVRM but for DEFUSR approach
  73+ 5600              ; input IX=pointer to input array, real data from +2
  74+ 5600              ; +2 = offset
  75+ 5600              ; +4 = count
  76+ 5600              ; +6 = value
  77+ 5600              ; +8 = halt flag
  78+ 5600              FILVRM_DEFUSR:
  79+ 5600 DD 7E 08     	LD A,(IX+8)
  80+ 5603 B7           	OR A
  81+ 5604 28 01        	JR Z,.L0
  82+ 5606 76           	HALT
  83+ 5607              .L0:
  84+ 5607 3E 01        	LD A,1
  85+ 5609 32 E2 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
  86+ 560C DD 6E 02     	LD L,(IX+2)
  87+ 560F DD 66 03     	LD H,(IX+3)
  88+ 5612 DD 4E 04     	LD C,(IX+4)
  89+ 5615 DD 46 05     	LD B,(IX+5)
  90+ 5618 DD 7E 06     	LD A,(IX+6)
  91+ 561B CD 56 00     	CALL BIOS_FILVRM
  92+ 561E AF           	XOR A
  93+ 561F 32 E2 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
  94+ 5622 C9           	RET
  95+ 5623              ; *******************************************************************************************************
  96+ 5623               ENDIF
  97+ 5623
  98+ 5623               IF (0 == 1)
  99+ 5623 ~            ; *******************************************************************************************************
 100+ 5623 ~            ; function to handle CALL MEMVRM basic extension
 101+ 5623 ~            ; copies from RAM to VRAM
 102+ 5623 ~            ; if flag != 0 it will issue HALT before copying
 103+ 5623 ~            ; if bit 1 of flag set and sprite system initialized it will set sprite update flag
 104+ 5623 ~            ; _MEMVRM ( INT source,
 105+ 5623 ~            ;			INT destination,
 106+ 5623 ~            ;			INT count,
 107+ 5623 ~            ;			BYTE flag)
 108+ 5623 ~            ; will put ram in page 0 also, page 1 is already there
 109+ 5623 ~            MEMVRM:
 110+ 5623 ~            	; opening (
 111+ 5623 ~            	CALL CHKCHAR
 112+ 5623 ~            	DB '('
 113+ 5623 ~            	; get source address
 114+ 5623 ~            	LD IX, FRMQNT
 115+ 5623 ~            	CALL CALBAS
 116+ 5623 ~            	PUSH DE
 117+ 5623 ~            	; comma
 118+ 5623 ~            	CALL CHKCHAR
 119+ 5623 ~            	DB ','
 120+ 5623 ~            	; get destination address
 121+ 5623 ~            	LD IX, FRMQNT
 122+ 5623 ~            	CALL CALBAS
 123+ 5623 ~            	PUSH DE
 124+ 5623 ~            	; comma
 125+ 5623 ~            	CALL CHKCHAR
 126+ 5623 ~            	DB ','
 127+ 5623 ~            	; get length
 128+ 5623 ~            	LD IX, FRMQNT
 129+ 5623 ~            	CALL CALBAS
 130+ 5623 ~            	PUSH DE
 131+ 5623 ~            	; comma
 132+ 5623 ~            	CALL CHKCHAR
 133+ 5623 ~            	DB ','
 134+ 5623 ~            	; get vsync wait
 135+ 5623 ~            	LD IX, GETBYT
 136+ 5623 ~            	CALL CALBAS
 137+ 5623 ~            	PUSH AF
 138+ 5623 ~            	; ending )
 139+ 5623 ~            	CALL CHKCHAR
 140+ 5623 ~            	DB ')'
 141+ 5623 ~
 142+ 5623 ~                ; save position in BASIC text
 143+ 5623 ~            	PUSH HL
 144+ 5623 ~            	POP IX
 145+ 5623 ~
 146+ 5623 ~            	POP AF ; wait vsync
 147+ 5623 ~            	OR A
 148+ 5623 ~            	JR Z, .L1
 149+ 5623 ~            	; check for special case to set sprite update flag
 150+ 5623 ~            	IF (SPRITE_CMDS == 1)
 151+ 5623 ~            		AND 2
 152+ 5623 ~            		JR Z,.L2
 153+ 5623 ~            		LD A, (SPRATR_INIT_STATUS)
 154+ 5623 ~            		OR A
 155+ 5623 ~            		JR Z,.L2
 156+ 5623 ~            		LD HL,(SPRATR_UPDATE_FLAG)
 157+ 5623 ~            		LD (HL),A
 158+ 5623 ~            	ENDIF
 159+ 5623 ~            .L2:
 160+ 5623 ~            	HALT
 161+ 5623 ~            .L1:
 162+ 5623 ~            	; pop LDIR parameters and store away for later
 163+ 5623 ~            	POP BC ; count
 164+ 5623 ~            	POP DE ; vram destination
 165+ 5623 ~            	POP HL ; ram source
 166+ 5623 ~            	EXX
 167+ 5623 ~             	LD IY, .RET
 168+ 5623 ~            	JP ENABLE_PAGE0
 169+ 5623 ~            .RET:
 170+ 5623 ~            	EI
 171+ 5623 ~            	EXX
 172+ 5623 ~            	CALL VRAM_LDIRVM
 173+ 5623 ~                POP DE
 174+ 5623 ~                POP BC
 175+ 5623 ~                CALL RESTORE_PAGE_INFO
 176+ 5623 ~            	PUSH IX
 177+ 5623 ~            	POP HL
 178+ 5623 ~            	RET
 179+ 5623 ~            ; *******************************************************************************************************
 180+ 5623               ENDIF
 181+ 5623
 182+ 5623               IF (1 == 1)
 183+ 5623              ; *******************************************************************************************************
 184+ 5623              ; same as MEMVRM but for DEFUSR approach
 185+ 5623              ; input IX=pointer to input array, real data from +2
 186+ 5623              ; +2 = source address
 187+ 5623              ; +4 = destination address
 188+ 5623              ; +6 = lenght
 189+ 5623              ; +8 = flag
 190+ 5623              MEMVRM_DEFUSR:
 191+ 5623 DD 7E 08     	LD A,(IX+8)
 192+ 5626 B7           	OR A
 193+ 5627 28 0F        	JR Z,.L0
 194+ 5629              	IF (SPRITE_CMDS == 1)
 195+ 5629 E6 02        		AND 2
 196+ 562B 28 0A        		JR Z,.L2
 197+ 562D 3A 7F 4D     		LD A, (SPRATR_INIT_STATUS)
 198+ 5630 B7           		OR A
 199+ 5631 28 04        		JR Z,.L2
 200+ 5633 2A 80 4D     		LD HL,(SPRATR_UPDATE_FLAG)
 201+ 5636 77           		LD (HL),A
 202+ 5637              	ENDIF
 203+ 5637              .L2:
 204+ 5637 76           	HALT
 205+ 5638              .L0:
 206+ 5638              	; enable page 0
 207+ 5638 FD 21 3F 56  	LD IY, .RET
 208+ 563C C3 05 5F     	JP ENABLE_PAGE0
 209+ 563F              .RET:
 210+ 563F FB           	EI
 211+ 5640 DD 6E 02     	LD L,(IX+2)
 212+ 5643 DD 66 03     	LD H,(IX+3)
 213+ 5646 DD 5E 04     	LD E,(IX+4)
 214+ 5649 DD 56 05     	LD D,(IX+5)
 215+ 564C DD 4E 06     	LD C,(IX+6)
 216+ 564F DD 46 07     	LD B,(IX+7)
 217+ 5652 CD 5A 56     	CALL VRAM_LDIRVM
 218+ 5655 D1               POP DE
 219+ 5656 C1               POP BC
 220+ 5657 C3 7C 5E         JP RESTORE_PAGE_INFO
 221+ 565A              ; *******************************************************************************************************
 222+ 565A               ENDIF
 223+ 565A
 224+ 565A              ; *******************************************************************************************************
 225+ 565A              ; common code to copy from memory to VRAM
 226+ 565A              ; input HL=RAM source
 227+ 565A              ; input DE=VRAM destination
 228+ 565A              ; BC=count
 229+ 565A              VRAM_LDIRVM:
 230+ 565A 3E 01        	LD A,1
 231+ 565C 32 E2 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 232+ 565F EB           	EX DE, HL
 233+ 5660 F3           	DI
 234+ 5661 CD 22 5E     	CALL SETWRT_LOCAL_WRITE
 235+ 5664 FB           	EI
 236+ 5665 EB           	EX DE, HL
 237+ 5666 78           	LD A, B
 238+ 5667 B7           	OR A
 239+ 5668 28 0D        	JR Z, .L3
 240+ 566A C5           	PUSH BC
 241+ 566B 0E 98        	LD C, #98
 242+ 566D              .L2:
 243+ 566D 50           	LD D, B
 244+ 566E 06 00        	LD B, 0
 245+ 5670 CD 39 5E     	CALL BBYTECOPY_NO_C
 246+ 5673 42           	LD B, D
 247+ 5674 10 F7        	DJNZ .L2
 248+ 5676 C1           	POP BC
 249+ 5677              .L3:
 250+ 5677 79           	LD A, C
 251+ 5678 B7           	OR A
 252+ 5679 28 04        	JR Z,.L4
 253+ 567B 41           	LD B, C
 254+ 567C CD 37 5E     	CALL BBYTECOPY
 255+ 567F              .L4:
 256+ 567F AF           	XOR A
 257+ 5680 32 E2 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 258+ 5683 C9           	RET
 259+ 5684              ; *******************************************************************************************************
 260+ 5684
 261+ 5684               IF (0 == 1)
 262+ 5684 ~            ; *******************************************************************************************************
 263+ 5684 ~            ; function to handle CALL VRMMEM basic extension
 264+ 5684 ~            ; copies from VRAM to RAM
 265+ 5684 ~            ; _VRMMEM ( INT source,
 266+ 5684 ~            ;			INT destination,
 267+ 5684 ~            ;			INT count
 268+ 5684 ~            ; will put ram in page 0 also, page 1 is already there
 269+ 5684 ~            VRMMEM:
 270+ 5684 ~            	; opening (
 271+ 5684 ~            	CALL CHKCHAR
 272+ 5684 ~            	DB '('
 273+ 5684 ~            	; get source address
 274+ 5684 ~            	LD IX, FRMQNT
 275+ 5684 ~            	CALL CALBAS
 276+ 5684 ~            	PUSH DE
 277+ 5684 ~            	; comma
 278+ 5684 ~            	CALL CHKCHAR
 279+ 5684 ~            	DB ','
 280+ 5684 ~            	; get destination address
 281+ 5684 ~            	LD IX, FRMQNT
 282+ 5684 ~            	CALL CALBAS
 283+ 5684 ~            	PUSH DE
 284+ 5684 ~            	; comma
 285+ 5684 ~            	CALL CHKCHAR
 286+ 5684 ~            	DB ','
 287+ 5684 ~            	; get length
 288+ 5684 ~            	LD IX, FRMQNT
 289+ 5684 ~            	CALL CALBAS
 290+ 5684 ~            	PUSH DE
 291+ 5684 ~            	; ending )
 292+ 5684 ~            	CALL CHKCHAR
 293+ 5684 ~            	DB ')'
 294+ 5684 ~
 295+ 5684 ~                ; save position in BASIC text
 296+ 5684 ~            	PUSH HL
 297+ 5684 ~            	POP IX
 298+ 5684 ~
 299+ 5684 ~            	POP BC ; count
 300+ 5684 ~            	POP DE ; destination
 301+ 5684 ~            	POP HL ; source
 302+ 5684 ~            	EXX
 303+ 5684 ~            	LD IY, .RET
 304+ 5684 ~            	JP ENABLE_PAGE0
 305+ 5684 ~            .RET:
 306+ 5684 ~            	EI
 307+ 5684 ~            	EXX
 308+ 5684 ~            	CALL VRAM_LDIRMV
 309+ 5684 ~                POP DE
 310+ 5684 ~                POP BC
 311+ 5684 ~                CALL RESTORE_PAGE_INFO
 312+ 5684 ~            	PUSH IX
 313+ 5684 ~            	POP HL
 314+ 5684 ~            	RET
 315+ 5684 ~            ; *******************************************************************************************************
 316+ 5684               ENDIF
 317+ 5684
 318+ 5684               IF (1 == 1)
 319+ 5684              ; *******************************************************************************************************
 320+ 5684              ; same as VRMMEM but for DEFUSR approach
 321+ 5684              ; input IX=pointer to input array, real data from +2
 322+ 5684              ; +2 = source address
 323+ 5684              ; +4 = destination address
 324+ 5684              ; +6 = count
 325+ 5684              VRMMEM_DEFUSR:
 326+ 5684              	; enable page 0
 327+ 5684 FD 21 8B 56  	LD IY, .RET
 328+ 5688 C3 05 5F     	JP ENABLE_PAGE0
 329+ 568B              .RET:
 330+ 568B FB           	EI
 331+ 568C DD 6E 02     	LD L,(IX+2)
 332+ 568F DD 66 03     	LD H,(IX+3)
 333+ 5692 DD 5E 04     	LD E,(IX+4)
 334+ 5695 DD 56 05     	LD D,(IX+5)
 335+ 5698 DD 4E 06     	LD C,(IX+6)
 336+ 569B DD 46 07     	LD B,(IX+7)
 337+ 569E CD A6 56     	CALL VRAM_LDIRMV
 338+ 56A1 D1               POP DE
 339+ 56A2 C1               POP BC
 340+ 56A3 C3 7C 5E         JP RESTORE_PAGE_INFO
 341+ 56A6              ; *******************************************************************************************************
 342+ 56A6               ENDIF
 343+ 56A6
 344+ 56A6              ; *******************************************************************************************************
 345+ 56A6              ; common code to copy from VRAM to RAM
 346+ 56A6              ; input HL=VRAM source
 347+ 56A6              ; input DE=RAM destination
 348+ 56A6              ; BC=count
 349+ 56A6              VRAM_LDIRMV:
 350+ 56A6 3E 01        	LD A,1
 351+ 56A8 32 E2 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 352+ 56AB 7D           	LD	A, L
 353+ 56AC F3           	DI
 354+ 56AD CD 2D 5E     	CALL SETWRT_LOCAL_READ
 355+ 56B0 FB           	EI
 356+ 56B1 00           	NOP
 357+ 56B2 00           	NOP
 358+ 56B3 00           	NOP ; too fast VDP access per openMSX
 359+ 56B4              .L4:
 360+ 56B4 DB 98            IN A, (#98)
 361+ 56B6 12           	LD (DE), A
 362+ 56B7 13               INC DE
 363+ 56B8 0B               DEC BC
 364+ 56B9 79               LD A, C
 365+ 56BA B0               OR B
 366+ 56BB 20 F7            JR NZ, .L4
 367+ 56BD AF           	XOR A
 368+ 56BE 32 E2 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 369+ 56C1 C9               RET
 370+ 56C2              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
 147  56C2               ENDIF
 148  56C2
 149  56C2               IF (GENCAL_CMD == 1)
 150  56C2               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
   1+ 56C2               IF (1 == 1)
   2+ 56C2              ; *******************************************************************************************************
   3+ 56C2              ; same as GENCAL but for DEFUSR approach
   4+ 56C2              ; input IX=pointer to input array, real data from +2
   5+ 56C2              ; +2 = function address to call
   6+ 56C2              ; +4 = register list array pointer
   7+ 56C2              GENCAL_DEFUSR:
   8+ 56C2 DD 6E 02         LD L,(IX+2)
   9+ 56C5 DD 66 03         LD H,(IX+3)
  10+ 56C8 E5               PUSH HL
  11+ 56C9 DD 6E 04         LD L,(IX+4)
  12+ 56CC DD 66 05         LD H,(IX+5)
  13+ 56CF E5               PUSH HL
  14+ 56D0 18 00            JR GENCAL.COMMON
  15+ 56D2              ; *******************************************************************************************************
  16+ 56D2               ENDIF
  17+ 56D2
  18+ 56D2              ; *******************************************************************************************************
  19+ 56D2              ; function to handle CALL GENCAL basic extension
  20+ 56D2              ; GENCAL ( INT fn_addr, = address of the function to call
  21+ 56D2              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
  22+ 56D2              ; output values of registers will also be stored at reg_list_ptr
  23+ 56D2              GENCAL:
  24+ 56D2               IF (0 == 1)
  25+ 56D2 ~            	; opening (
  26+ 56D2 ~            	CALL CHKCHAR
  27+ 56D2 ~            	DB '('
  28+ 56D2 ~            	; get function address
  29+ 56D2 ~            	LD IX, FRMQNT
  30+ 56D2 ~            	CALL CALBAS
  31+ 56D2 ~            	PUSH DE
  32+ 56D2 ~            	; comma
  33+ 56D2 ~            	CALL CHKCHAR
  34+ 56D2 ~            	DB ','
  35+ 56D2 ~            	; get pointer to register list
  36+ 56D2 ~                LD A,2
  37+ 56D2 ~                LD B,1
  38+ 56D2 ~                LD DE,#0500
  39+ 56D2 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
  40+ 56D2 ~            	PUSH BC
  41+ 56D2 ~            	; ending )
  42+ 56D2 ~            	CALL CHKCHAR
  43+ 56D2 ~            	DB ')'
  44+ 56D2               ENDIF
  45+ 56D2              .COMMON:
  46+ 56D2              	; save BASIC token position
  47+ 56D2 E5           	PUSH HL
  48+ 56D3 D9               EXX
  49+ 56D4 E1           	POP HL ; HL'=next basic token
  50+ 56D5 D9               EXX
  51+ 56D6
  52+ 56D6 E1               POP HL ; get pointer to register values
  53+ 56D7 F3           	DI
  54+ 56D8 ED 73 D1 5D      LD (BLIT_STRUCT), SP
  55+ 56DC F9               LD SP, HL
  56+ 56DD F1               POP AF
  57+ 56DE C1               POP BC
  58+ 56DF D1               POP DE
  59+ 56E0 E1               POP HL
  60+ 56E1 DD E1            POP IX
  61+ 56E3 FD E1            POP IY
  62+ 56E5 D9               EXX
  63+ 56E6 ED 73 D3 5D      LD (BLIT_STRUCT+2), SP
  64+ 56EA ED 7B D1 5D      LD SP, (BLIT_STRUCT)
  65+ 56EE FB               EI
  66+ 56EF D1               POP DE ; get function to call
  67+ 56F0 E5               PUSH HL
  68+ 56F1 CD 0C 57         CALL .EXXDECALL
  69+ 56F4 F3               DI
  70+ 56F5 ED 73 D1 5D      LD (BLIT_STRUCT), SP
  71+ 56F9 ED 7B D3 5D      LD SP, (BLIT_STRUCT+2)
  72+ 56FD FD E5            PUSH IY
  73+ 56FF DD E5            PUSH IX
  74+ 5701 E5               PUSH HL
  75+ 5702 D5               PUSH DE
  76+ 5703 C5               PUSH BC
  77+ 5704 F5               PUSH AF
  78+ 5705 ED 7B D1 5D      LD SP, (BLIT_STRUCT)
  79+ 5709 FB               EI
  80+ 570A E1               POP HL
  81+ 570B C9           	RET
  82+ 570C
  83+ 570C              .EXXDECALL:
  84+ 570C D5               PUSH DE
  85+ 570D D9               EXX
  86+ 570E C9               RET
  87+ 570F              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
 151  570F               ENDIF
 152  570F
 153  570F               IF (BOX_CMDS == 1)
 154  570F               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
   1+ 570F              ; *******************************************************************************************************
   2+ 570F              ; generic function to implement rectangle data copy
   3+ 570F              ; should be modified to call appropriate function for memory or vram
   4+ 570F              ; input IX=pointer to following structure
   5+ 570F              ; +00 source data pointer
   6+ 570F              ; +02 num bytes in a row
   7+ 570F              ; +04 number of rows
   8+ 570F              ; +06 source add-to value till next row
   9+ 570F              ; +08 destination address
  10+ 570F              ; +10 destination add-to value till next row
  11+ 570F              ; modifies AF, BC, DE, HL
  12+ 570F              RECTANGLE_COPY:
  13+ 570F DD 6E 00     	LD L, (IX+0)
  14+ 5712 DD 66 01     	LD H, (IX+1) ; source address
  15+ 5715 DD 5E 08     	LD E, (IX+8)
  16+ 5718 DD 56 09     	LD D, (IX+9) ; destination
  17+ 571B DD 46 04     	LD B, (IX+4) ; row number
  18+ 571E              .L1:
  19+ 571E C5           	PUSH BC
  20+ 571F E5           		PUSH HL
  21+ 5720 D5           			PUSH DE
  22+ 5721 DD 4E 02     				LD C, (IX+2)
  23+ 5724 DD 46 03     				LD B, (IX+3) ; num bytes in a row
  24+ 5727              .CALL1:
  25+ 5727 CD 00 00     				CALL 0 ; set destination address from DE
  26+ 572A              .CALL2:
  27+ 572A CD 00 00     				CALL 0 ; copy data fn
  28+ 572D E1           			POP HL
  29+ 572E DD 4E 0A     			LD C, (IX+10)
  30+ 5731 DD 46 0B     			LD B, (IX+11) ; destination add-to
  31+ 5734 09           			ADD HL, BC
  32+ 5735 EB           			EX DE, HL
  33+ 5736 E1           		POP HL
  34+ 5737 DD 4E 06     		LD C, (IX+6)
  35+ 573A DD 46 07     		LD B, (IX+7) ; src add-to
  36+ 573D 09           		ADD HL, BC
  37+ 573E C1           	POP BC
  38+ 573F 10 DD        	DJNZ .L1
  39+ 5741 C9           	RET
  40+ 5742              ; *******************************************************************************************************
  41+ 5742
  42+ 5742               IF (0 == 1)
  43+ 5742 ~            ; *******************************************************************************************************
  44+ 5742 ~            ; function to handle CALL BOXMEMCPY basic extension
  45+ 5742 ~            ; copies data with window like boundaries within ram
  46+ 5742 ~            ; BOXMEMCPY ( INT source data pointer,
  47+ 5742 ~            ;			  INT source number of bytes in a row,
  48+ 5742 ~            ;			  INT number of rows,
  49+ 5742 ~            ;			  INT source add-to value till next row,
  50+ 5742 ~            ; 			  INT destination pointer,
  51+ 5742 ~            ;			  INT destination add-to value till next row )
  52+ 5742 ~            ; request_data_ptr described in RECTANGLE_COPY
  53+ 5742 ~            ; will put ram in page 0 also, page 1 is already there
  54+ 5742 ~            BOXMEMCPY:
  55+ 5742 ~            	LD DE,BOXMEMCPY_COMMON
  56+ 5742 ~            	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
  57+ 5742 ~            	JP BOX_EXTENSION_PARAMS_COMMON
  58+ 5742               ENDIF
  59+ 5742
  60+ 5742               IF (1 == 1)
  61+ 5742              ; *******************************************************************************************************
  62+ 5742              ; same as BOXMEMCPY but for DEFUSR approach
  63+ 5742              ; input IX=pointer to input array, real data from +2
  64+ 5742              ; +02 = source data pointer
  65+ 5742              ; +04 = source number of bytes in a row
  66+ 5742              ; +06 = number of rows
  67+ 5742              ; +08 = source add-to value till next row
  68+ 5742              ; +10 = destination pointer
  69+ 5742              ; +12 = destination add-to value till next row
  70+ 5742              BOXMEMCPY_DEFUSR:
  71+ 5742 21 4F 57     	LD HL,BOXMEMCPY_COMMON
  72+ 5745 22 65 57     	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
  73+ 5748 DD 23        	INC IX
  74+ 574A DD 23        	INC IX
  75+ 574C C3 62 57     	JP BOXCOMMON_DEFUSR
  76+ 574F               ENDIF
  77+ 574F
  78+ 574F              BOXMEMCPY_COMMON:
  79+ 574F FB           	EI
  80+ 5750              	; set RAM functions to call
  81+ 5750 21 00 00     	LD HL, 0
  82+ 5753 22 27 57     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
  83+ 5756 22 29 57     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
  84+ 5759 21 ED B0     	LD HL, #B0ED ; LDIR
  85+ 575C 22 2B 57     	LD (RECTANGLE_COPY.CALL1+4), HL
  86+ 575F C3 6A 57     	JP BOXCOMMON_DEFUSR.CALL
  87+ 5762              ; *******************************************************************************************************
  88+ 5762
  89+ 5762               IF (0 == 1)
  90+ 5762 ~            ; *******************************************************************************************************
  91+ 5762 ~            ; common parts of BOX commands to load parameters
  92+ 5762 ~            BOX_EXTENSION_PARAMS_COMMON:
  93+ 5762 ~            	; opening (
  94+ 5762 ~            	CALL CHKCHAR
  95+ 5762 ~            	DB '('
  96+ 5762 ~            	; get source data pointer
  97+ 5762 ~            	LD IX, FRMQNT
  98+ 5762 ~            	CALL CALBAS
  99+ 5762 ~            	LD (BLIT_STRUCT+0), DE
 100+ 5762 ~            	; comma
 101+ 5762 ~            	CALL CHKCHAR
 102+ 5762 ~            	DB ','
 103+ 5762 ~            	; source number of bytes in a row
 104+ 5762 ~            	LD IX, FRMQNT
 105+ 5762 ~            	CALL CALBAS
 106+ 5762 ~            	LD (BLIT_STRUCT+2), DE
 107+ 5762 ~            	; comma
 108+ 5762 ~            	CALL CHKCHAR
 109+ 5762 ~            	DB ','
 110+ 5762 ~            	; number of rows
 111+ 5762 ~            	LD IX, FRMQNT
 112+ 5762 ~            	CALL CALBAS
 113+ 5762 ~            	LD (BLIT_STRUCT+4), DE
 114+ 5762 ~            	; comma
 115+ 5762 ~            	CALL CHKCHAR
 116+ 5762 ~            	DB ','
 117+ 5762 ~            	; source add-to value till next row
 118+ 5762 ~            	LD IX, FRMQNT
 119+ 5762 ~            	CALL CALBAS
 120+ 5762 ~            	LD (BLIT_STRUCT+6), DE
 121+ 5762 ~            	; comma
 122+ 5762 ~            	CALL CHKCHAR
 123+ 5762 ~            	DB ','
 124+ 5762 ~            	; destination pointer
 125+ 5762 ~            	LD IX, FRMQNT
 126+ 5762 ~            	CALL CALBAS
 127+ 5762 ~            	LD (BLIT_STRUCT+8), DE
 128+ 5762 ~            	; comma
 129+ 5762 ~            	CALL CHKCHAR
 130+ 5762 ~            	DB ','
 131+ 5762 ~            	; destination add-to value till next row
 132+ 5762 ~            	LD IX, FRMQNT
 133+ 5762 ~            	CALL CALBAS
 134+ 5762 ~            	LD (BLIT_STRUCT+10), DE
 135+ 5762 ~            	; ending )
 136+ 5762 ~            	CALL CHKCHAR
 137+ 5762 ~            	DB ')'
 138+ 5762 ~            	LD IX,BLIT_STRUCT
 139+ 5762               ENDIF
 140+ 5762              BOXCOMMON_DEFUSR:
 141+ 5762 E5           	PUSH HL ; save position in BASIC buffer
 142+ 5763              .ADDR:
 143+ 5763 FD 21 00 00  	LD IY, 0 ; modified by code
 144+ 5767 C3 05 5F     	JP ENABLE_PAGE0
 145+ 576A              .CALL:
 146+ 576A CD 0F 57     	CALL RECTANGLE_COPY
 147+ 576D AF           	XOR A
 148+ 576E 32 E2 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 149+ 5771
 150+ 5771 D1               POP DE
 151+ 5772 C1               POP BC
 152+ 5773 CD 7C 5E         CALL RESTORE_PAGE_INFO
 153+ 5776
 154+ 5776 E1           	POP HL
 155+ 5777 C9           	RET
 156+ 5778              ; *******************************************************************************************************
 157+ 5778
 158+ 5778               IF (0 == 1)
 159+ 5778 ~            ; *******************************************************************************************************
 160+ 5778 ~            ; function to handle CALL BOXMEMVRM basic extension
 161+ 5778 ~            ; copies data with window like boundaries from ram to Vram
 162+ 5778 ~            ; BOXMEMVRM ( INT source data pointer,
 163+ 5778 ~            ;			  INT source number of bytes in a row,
 164+ 5778 ~            ;			  INT number of rows,
 165+ 5778 ~            ;			  INT source add-to value till next row,
 166+ 5778 ~            ; 			  INT destination pointer,
 167+ 5778 ~            ;			  INT destination add-to value till next row )
 168+ 5778 ~            ; request_data_ptr described in RECTANGLE_COPY
 169+ 5778 ~            ; will put ram in page 0 also, page 1 is already there
 170+ 5778 ~            BOXMEMVRM:
 171+ 5778 ~            	LD DE,BOXMEMVRM_COMMON
 172+ 5778 ~            	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
 173+ 5778 ~            	JP BOX_EXTENSION_PARAMS_COMMON
 174+ 5778               ENDIF
 175+ 5778
 176+ 5778               IF (1 == 1)
 177+ 5778              ; *******************************************************************************************************
 178+ 5778              ; same as BOXMEMVRM but for DEFUSR approach
 179+ 5778              ; input IX=pointer to input array, real data from +2
 180+ 5778              ; +02 = source data pointer
 181+ 5778              ; +04 = source number of bytes in a row
 182+ 5778              ; +06 = number of rows
 183+ 5778              ; +08 = source add-to value till next row
 184+ 5778              ; +10 = destination pointer
 185+ 5778              ; +12 = destination add-to value till next row
 186+ 5778              BOXMEMVRM_DEFUSR:
 187+ 5778 21 85 57     	LD HL,BOXMEMVRM_COMMON
 188+ 577B 22 65 57     	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
 189+ 577E DD 23        	INC IX
 190+ 5780 DD 23        	INC IX
 191+ 5782 C3 62 57     	JP BOXCOMMON_DEFUSR
 192+ 5785               ENDIF
 193+ 5785
 194+ 5785              BOXMEMVRM_COMMON:
 195+ 5785 FB           	EI
 196+ 5786              	; set RAM functions to call
 197+ 5786 21 A0 57     	LD HL, .SETDEST
 198+ 5789 22 28 57     	LD (RECTANGLE_COPY.CALL1+1), HL
 199+ 578C 21 A8 57     	LD HL, .COPYDATA
 200+ 578F 22 2B 57     	LD (RECTANGLE_COPY.CALL2+1), HL
 201+ 5792 3E CD        	LD A, #CD ; CALL
 202+ 5794 32 27 57     	LD (RECTANGLE_COPY.CALL1), A
 203+ 5797 32 2A 57     	LD (RECTANGLE_COPY.CALL2), A
 204+ 579A              	;LD A,1
 205+ 579A 32 E2 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 206+ 579D C3 6A 57     	JP BOXCOMMON_DEFUSR.CALL
 207+ 57A0              .SETDEST:
 208+ 57A0 EB           	EX DE, HL
 209+ 57A1 F3           	DI
 210+ 57A2 CD 22 5E     	CALL SETWRT_LOCAL_WRITE
 211+ 57A5 FB           	EI
 212+ 57A6 EB           	EX DE, HL
 213+ 57A7 C9           	RET
 214+ 57A8              .COPYDATA:
 215+ 57A8 41           	LD B, C
 216+ 57A9 C3 37 5E     	JP BBYTECOPY
 217+ 57AC              ; *******************************************************************************************************
# file closed: asm\BOX.asm
 155  57AC               ENDIF
 156  57AC
 157  57AC               IF (BLIT_CMDS == 1)
 158  57AC               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
   1+ 57AC              ; *******************************************************************************************************
   2+ 57AC              ; function rotates mask and data of several characters and applies to background data
   3+ 57AC              ; this handles x-shift from 0 to 4
   4+ 57AC              ; contains self-modifying code that is set-up from external function
   5+ 57AC              ; input HL=pointer to mask data
   6+ 57AC              ; input HL'=pointer to character data
   7+ 57AC              ; input DE=output buffer containing background data
   8+ 57AC              ; input BC=DE+8
   9+ 57AC              ; input A=number of characters to process
  10+ 57AC              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  11+ 57AC              SHIFT04:
  12+ 57AC 08           	EX AF, AF'
  13+ 57AD 7E           	LD A, (HL) ; get mask
  14+ 57AE D9           	EXX
  15+ 57AF 57           	LD D, A
  16+ 57B0 1E FF        	LD E, #FF
  17+ 57B2 37           	SCF
  18+ 57B3              .M1:
  19+ 57B3 18 FE        	JR .M1 ; this is self-modifying part
  20+ 57B5 CB 1A        	RR D
  21+ 57B7 CB 1B        	RR E
  22+ 57B9 CB 1A        	RR D
  23+ 57BB CB 1B        	RR E
  24+ 57BD CB 1A        	RR D
  25+ 57BF CB 1B        	RR E
  26+ 57C1 CB 1A        	RR D
  27+ 57C3 CB 1B        	RR E
  28+ 57C5
  29+ 57C5 46           	LD B, (HL) ; get data
  30+ 57C6 0E 00        	LD C, 0
  31+ 57C8              .M2:
  32+ 57C8 18 FE        	JR .M2 ; also self-modifying part
  33+ 57CA CB 38        	SRL B
  34+ 57CC CB 19        	RR C
  35+ 57CE CB 38        	SRL B
  36+ 57D0 CB 19        	RR C
  37+ 57D2 CB 38        	SRL B
  38+ 57D4 CB 19        	RR C
  39+ 57D6 CB 38        	SRL B
  40+ 57D8 CB 19        	RR C
  41+ 57DA
  42+ 57DA D9           	EXX
  43+ 57DB 1A           	LD A, (DE) ; background
  44+ 57DC D9           	EXX
  45+ 57DD A2           	AND D
  46+ 57DE B0           	OR B
  47+ 57DF D9           	EXX
  48+ 57E0 12           	LD (DE), A
  49+ 57E1
  50+ 57E1 0A           	LD A, (BC)
  51+ 57E2 D9           	EXX
  52+ 57E3 A3           	AND E
  53+ 57E4 B1           	OR C
  54+ 57E5 23           	INC HL
  55+ 57E6 D9           	EXX
  56+ 57E7 02           	LD (BC), A
  57+ 57E8
  58+ 57E8 23           	INC HL
  59+ 57E9 13           	INC DE
  60+ 57EA 03           	INC BC
  61+ 57EB
  62+ 57EB 08           	EX AF, AF'
  63+ 57EC 3D           	DEC A
  64+ 57ED C2 AC 57     	JP NZ, SHIFT04
  65+ 57F0 C9           	RET
  66+ 57F1              ; *******************************************************************************************************
  67+ 57F1
  68+ 57F1              ; *******************************************************************************************************
  69+ 57F1              ; function rotates mask and data of several characters and applies to background data
  70+ 57F1              ; this handles x-shift from 5 to 8
  71+ 57F1              ; contains self-modifying code that is set-up from external function
  72+ 57F1              ; input HL=pointer to mask data
  73+ 57F1              ; input HL'=pointer to character data
  74+ 57F1              ; input DE=output buffer containing background data
  75+ 57F1              ; input BC=DE+8
  76+ 57F1              ; input A=number of characters to process
  77+ 57F1              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  78+ 57F1              SHIFT58:
  79+ 57F1 08           	EX AF, AF'
  80+ 57F2 7E           	LD A, (HL) ; get mask
  81+ 57F3 D9           	EXX
  82+ 57F4 57           	LD D, A
  83+ 57F5 1E FF        	LD E, #FF
  84+ 57F7 37           	SCF
  85+ 57F8              .M1:
  86+ 57F8 18 FE        	JR .M1 ; this is self-modifying part
  87+ 57FA CB 12        	RL D
  88+ 57FC CB 13        	RL E
  89+ 57FE CB 12        	RL D
  90+ 5800 CB 13        	RL E
  91+ 5802 CB 12        	RL D
  92+ 5804 CB 13        	RL E
  93+ 5806
  94+ 5806 46           	LD B, (HL)
  95+ 5807 0E 00        	LD C, 0
  96+ 5809              .M2:
  97+ 5809 18 FE        	JR .M2 ; also self-modifying part
  98+ 580B CB 20        	SLA B
  99+ 580D CB 11        	RL C
 100+ 580F CB 20        	SLA B
 101+ 5811 CB 11        	RL C
 102+ 5813 CB 20        	SLA B
 103+ 5815 CB 11        	RL C
 104+ 5817
 105+ 5817 D9           	EXX
 106+ 5818 1A           	LD A, (DE) ; background
 107+ 5819 D9           	EXX
 108+ 581A A3           	AND E
 109+ 581B B1           	OR C
 110+ 581C D9           	EXX
 111+ 581D 12           	LD (DE), A
 112+ 581E
 113+ 581E 0A           	LD A, (BC)
 114+ 581F D9           	EXX
 115+ 5820 A2           	AND D
 116+ 5821 B0           	OR B
 117+ 5822 23           	INC HL
 118+ 5823 D9           	EXX
 119+ 5824 02           	LD (BC), A
 120+ 5825
 121+ 5825 23           	INC HL
 122+ 5826 13           	INC DE
 123+ 5827 03           	INC BC
 124+ 5828
 125+ 5828 08           	EX AF, AF'
 126+ 5829 3D           	DEC A
 127+ 582A C2 F1 57     	JP NZ, SHIFT58
 128+ 582D C9           	RET
 129+ 582E              ; *******************************************************************************************************
 130+ 582E
 131+ 582E              ; *******************************************************************************************************
 132+ 582E              ; routine that shifts one row of characters
 133+ 582E              ; contains self-modifying code that is set-up from external function
 134+ 582E              ; input HL=pointer to mask data
 135+ 582E              ; input HL'=pointer to character data
 136+ 582E              ; input DE=output buffer containing background data
 137+ 582E              ; input A=number of characters to process
 138+ 582E              ; input IX=pointer to structure describing input data
 139+ 582E              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 140+ 582E              SHIFT_ROW:
 141+ 582E F5           	PUSH AF
 142+ 582F ED 53 CD 5D  		LD (BLIT_TMP1), DE
 143+ 5833 E5           		PUSH HL
 144+ 5834 CD 77 58     			CALL .ADDYSHIFT
 145+ 5837 E1           		POP HL
 146+ 5838 ED 53 CF 5D  		LD (BLIT_TMP2), DE ; DE+vertical shift
 147+ 583C              .L1:
 148+ 583C 3E 08        		LD A, 8
 149+ 583E DD 96 02     		SUB (IX+2) ; y shift
 150+ 5841              .CALL1:
 151+ 5841 CD 00 00     		CALL 0
 152+ 5844 DD 7E 02     		LD A, (IX+2); y shift
 153+ 5847 B7           		OR A
 154+ 5848 28 26        		JR Z, .DONE
 155+ 584A ED 5B CD 5D  		LD DE, (BLIT_TMP1)
 156+ 584E E5           		PUSH HL
 157+ 584F CD 85 58     			CALL .DETONEXTROW
 158+ 5852 E1           		POP HL
 159+ 5853              .CALL2:
 160+ 5853 CD 00 00     		CALL 0
 161+ 5856 ED 5B CD 5D  		LD DE, (BLIT_TMP1)
 162+ 585A E5           		PUSH HL
 163+ 585B CD 7F 58     			CALL .ADD8
 164+ 585E E1           		POP HL
 165+ 585F ED 53 CD 5D  		LD (BLIT_TMP1), DE
 166+ 5863 ED 5B CF 5D  		LD DE, (BLIT_TMP2)
 167+ 5867 E5           		PUSH HL
 168+ 5868 CD 7F 58     			CALL .ADD8
 169+ 586B E1           		POP HL
 170+ 586C ED 53 CF 5D  		LD (BLIT_TMP2), DE ; DE+vertical shift
 171+ 5870              .DONE:
 172+ 5870 F1           	POP AF
 173+ 5871 3D           	DEC A
 174+ 5872 C8           	RET Z
 175+ 5873 F5           	PUSH AF
 176+ 5874 C3 3C 58     	JP .L1
 177+ 5877              .ADDYSHIFT:
 178+ 5877 EB           	EX DE, HL
 179+ 5878 16 00        	LD D, 0
 180+ 587A DD 5E 02     	LD E, (IX+2); y shift
 181+ 587D 18 0C        	JR .MOVDEBC
 182+ 587F              .ADD8:
 183+ 587F 21 08 00     	LD HL, 8
 184+ 5882 C3 8B 58     	JP .MOVDEBC
 185+ 5885              .DETONEXTROW:
 186+ 5885 DD 6E 06     	LD L, (IX+6)
 187+ 5888 DD 66 07     	LD H, (IX+7) ; bkg add to value
 188+ 588B              .MOVDEBC:
 189+ 588B 19           	ADD HL, DE
 190+ 588C 54           	LD D, H
 191+ 588D 5D           	LD E, L
 192+ 588E 01 08 00     	LD BC, 8
 193+ 5891 09           	ADD HL, BC
 194+ 5892 44           	LD B, H
 195+ 5893 4D           	LD C, L
 196+ 5894 C9           	RET
 197+ 5895              ; *******************************************************************************************************
 198+ 5895
 199+ 5895              ; *******************************************************************************************************
 200+ 5895              ; function rotates mask and character data and applies it to background
 201+ 5895              ; input IX=pointer to structure describing input data
 202+ 5895              ; +0  DW horizontal shift count 0-7 (low byte used)
 203+ 5895              ; +2  DW vertical shift count 0-7 (low byte used)
 204+ 5895              ; +4  DW background data start;
 205+ 5895              ; +6  DW background add to value to next row of background data
 206+ 5895              ; +8  DW mask data start;
 207+ 5895              ; +10  DW character data start;
 208+ 5895              ; +12 DW character&mask add to value to next row of data
 209+ 5895              ; +14 DW columns (low byte used)
 210+ 5895              ; +16 DW rows (low byte used)
 211+ 5895              SHIFT_MERGE_CHARACTER:
 212+ 5895 DD 7E 00     	LD A, (IX) ; shift
 213+ 5898 FE 05        	CP 5
 214+ 589A 38 25        	JR C, .RIGHT
 215+ 589C              	; shifts 5-7, use rotate towards left 1-3
 216+ 589C 21 F1 57     	LD HL, SHIFT58
 217+ 589F 22 42 58     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 218+ 58A2 22 54 58     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 219+ 58A5 D6 05        	SUB 5
 220+ 58A7 28 0D        	JR Z, .L1
 221+ 58A9 87           	ADD A, A
 222+ 58AA 87           	ADD A, A
 223+ 58AB 67           	LD H, A
 224+ 58AC 2E 18        	LD L, #18 ; JR opcode
 225+ 58AE 22 F8 57     	LD (SHIFT58.M1), HL
 226+ 58B1 22 09 58     	LD (SHIFT58.M2), HL
 227+ 58B4 18 32        	JR .DO
 228+ 58B6              .L1:
 229+ 58B6 21 00 00     	LD HL, 0 ; 2xNOP opcode
 230+ 58B9 22 F8 57     	LD (SHIFT58.M1), HL
 231+ 58BC 22 09 58     	LD (SHIFT58.M2), HL
 232+ 58BF 18 27        	JR .DO
 233+ 58C1              .RIGHT:
 234+ 58C1              	; shifts 0-4, rotate towards right
 235+ 58C1 21 AC 57     	LD HL, SHIFT04
 236+ 58C4 22 42 58     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 237+ 58C7 22 54 58     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 238+ 58CA FE 04        	CP 4
 239+ 58CC 28 11        	JR Z, .R1
 240+ 58CE D6 04        	SUB 4
 241+ 58D0 ED 44        	NEG
 242+ 58D2 87           	ADD A, A
 243+ 58D3 87           	ADD A, A
 244+ 58D4 67           	LD H, A
 245+ 58D5 2E 18        	LD L, #18 ; JR opcode
 246+ 58D7 22 B3 57     	LD (SHIFT04.M1), HL
 247+ 58DA 22 C8 57     	LD (SHIFT04.M2), HL
 248+ 58DD 18 09        	JR .DO
 249+ 58DF              .R1:
 250+ 58DF 21 00 00     	LD HL, 0 ; 2xNOP opcode
 251+ 58E2 22 B3 57     	LD (SHIFT04.M1), HL
 252+ 58E5 22 C8 57     	LD (SHIFT04.M2), HL
 253+ 58E8              .DO:
 254+ 58E8 DD 46 10     	LD B, (IX+16) ; rows
 255+ 58EB DD 6E 08     	LD L, (IX+8)
 256+ 58EE DD 66 09     	LD H, (IX+9) ; mask data
 257+ 58F1 DD 5E 04     	LD E, (IX+4)
 258+ 58F4 DD 56 05     	LD D, (IX+5) ; background data
 259+ 58F7 D9           	EXX
 260+ 58F8 DD 6E 0A     	LD L, (IX+10)
 261+ 58FB DD 66 0B     	LD H, (IX+11) ; character data
 262+ 58FE D9           	EXX
 263+ 58FF              .LOOP:
 264+ 58FF C5           	PUSH BC
 265+ 5900 E5           		PUSH HL
 266+ 5901 D5           			PUSH DE
 267+ 5902 D9           				EXX
 268+ 5903 E5           				PUSH HL
 269+ 5904 D9           					EXX
 270+ 5905 DD 7E 0E     					LD A, (IX+14) ; columns
 271+ 5908              .CALL:
 272+ 5908 CD 2E 58     					CALL SHIFT_ROW
 273+ 590B E1           				POP HL
 274+ 590C DD 5E 0C     				LD E, (IX+12)
 275+ 590F DD 56 0D     				LD D, (IX+13) ; char data to next row
 276+ 5912 19           				ADD HL, DE
 277+ 5913 D9           				EXX
 278+ 5914 E1           			POP HL
 279+ 5915 DD 5E 06     			LD E, (IX+6)
 280+ 5918 DD 56 07     			LD D, (IX+7) ; background to next row
 281+ 591B 19           			ADD HL, DE
 282+ 591C EB           			EX DE, HL
 283+ 591D E1           		POP HL
 284+ 591E DD 4E 0C     		LD C, (IX+12)
 285+ 5921 DD 46 0D     		LD B, (IX+13) ; char data to next row
 286+ 5924 09           		ADD HL, BC
 287+ 5925 C1           	POP BC
 288+ 5926 10 D7        	DJNZ .LOOP
 289+ 5928 C9           	RET
 290+ 5929              ; *******************************************************************************************************
 291+ 5929
 292+ 5929              ; *******************************************************************************************************
 293+ 5929              ; helper function DE \ 8
 294+ 5929              DEdiv8:
 295+ 5929 7B           	LD A,E
 296+ 592A CB 2A        	SRA D
 297+ 592C CB 1F            RR  A
 298+ 592E CB 2A            SRA D
 299+ 5930 CB 1F            RR  A
 300+ 5932 CB 2A            SRA D
 301+ 5934 CB 1F            RR  A
 302+ 5936 C9           	RET
 303+ 5937              ; *******************************************************************************************************
 304+ 5937
 305+ 5937               IF (1 == 1)
 306+ 5937              ; *******************************************************************************************************
 307+ 5937              ; function to handle BLIT basic extension through DEFUSR call in RAW format
 308+ 5937              ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 309+ 5937              ; +2  DW horizontal shift count 0-7 (low byte used)
 310+ 5937              ; +4  DW vertical shift count 0-7 (low byte used)
 311+ 5937              ; +6  DW background data start;
 312+ 5937              ; +8  DW background add to value to next row of background data
 313+ 5937              ; +10  DW mask data start;
 314+ 5937              ; +12  DW character data start;
 315+ 5937              ; +14 DW character&mask add to value to next row of data
 316+ 5937              ; +16 DW columns (low byte used)
 317+ 5937              ; +18 DW rows (low byte used)
 318+ 5937              ; will put ram in page 0 also, page 1 is already there
 319+ 5937              ;BLIT_DEFUSR:
 320+ 5937              ;	DI
 321+ 5937              ;	LD IY, .RET
 322+ 5937              ;	JP ENABLE_PAGE0
 323+ 5937              ;.RET:
 324+ 5937              ;	EI
 325+ 5937              ;	INC IX
 326+ 5937              ;	INC IX
 327+ 5937              ;	CALL SHIFT_MERGE_CHARACTER
 328+ 5937              ;
 329+ 5937              ;   POP DE
 330+ 5937              ;    POP BC
 331+ 5937              ;    JP RESTORE_PAGE_INFO
 332+ 5937              ; *******************************************************************************************************
 333+ 5937
 334+ 5937              ; *******************************************************************************************************
 335+ 5937              ; function to handle CALL BLIT basic extension in DEFUSR form
 336+ 5937              ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 337+ 5937              ; +02 x
 338+ 5937              ; +04 y
 339+ 5937              ; +06 char_data_pointer
 340+ 5937              ; +08 mask_data_pointer
 341+ 5937              ; +10 width
 342+ 5937              ; +12 height
 343+ 5937              ; +14 background_pointer
 344+ 5937              ; +16 background_width
 345+ 5937              ; BLIT ( INT x,
 346+ 5937              ;		 INT y,
 347+ 5937              ;		 INT char_data_pointer,
 348+ 5937              ;		 INT mask_data_pointer,
 349+ 5937              ;		 INT width (in characters),
 350+ 5937              ;		 INT height (in characters),
 351+ 5937              ;		 INT background_pointer (top left),
 352+ 5937              ;		 INT background_width (in characters),
 353+ 5937              BLIT_DEFUSR:
 354+ 5937 DD 5E 02     	LD E,(IX+2)
 355+ 593A DD 56 03     	LD D,(IX+3)
 356+ 593D 7B           	LD A,E
 357+ 593E E6 07        	AND 7
 358+ 5940 32 D1 5D     	LD (BLIT_STRUCT+0),A
 359+ 5943 CD 29 59     	CALL DEdiv8
 360+ 5946 32 CD 5D     	LD (BLIT_TMP+0),A
 361+ 5949 DD 5E 04     	LD E,(IX+4)
 362+ 594C DD 56 05     	LD D,(IX+5)
 363+ 594F 7B           	LD A,E
 364+ 5950 E6 07        	AND 7
 365+ 5952 32 D3 5D     	LD (BLIT_STRUCT+2),A
 366+ 5955 CD 29 59     	CALL DEdiv8
 367+ 5958 32 CE 5D     	LD (BLIT_TMP+1),A
 368+ 595B DD 6E 06     	LD L,(IX+6)
 369+ 595E DD 66 07     	LD H,(IX+7)
 370+ 5961 22 DB 5D     	LD (BLIT_STRUCT+10),HL
 371+ 5964 DD 6E 08     	LD L,(IX+8)
 372+ 5967 DD 66 09     	LD H,(IX+9)
 373+ 596A 22 D9 5D     	LD (BLIT_STRUCT+8),HL
 374+ 596D DD 7E 0A     	LD A,(IX+10)
 375+ 5970 32 DF 5D     	LD (BLIT_STRUCT+14),A
 376+ 5973 DD 7E 0C     	LD A,(IX+12)
 377+ 5976 32 E1 5D     	LD (BLIT_STRUCT+16),A
 378+ 5979 DD 6E 0E     	LD L,(IX+14)
 379+ 597C DD 66 0F     	LD H,(IX+15)
 380+ 597F 22 D5 5D     	LD (BLIT_STRUCT+4),HL
 381+ 5982              	;LD A,(IX+16)
 382+ 5982              	;LD (BLIT_TMP+2),A
 383+ 5982
 384+ 5982              	; calculate char&mask add to value
 385+ 5982 26 00        	LD H,0
 386+ 5984 3A DF 5D     	LD A,(BLIT_STRUCT+14)
 387+ 5987 6F           	LD L,A
 388+ 5988 CD 41 5E     	CALL HLx8
 389+ 598B 22 DD 5D     	LD (BLIT_STRUCT+12),HL
 390+ 598E              	; calculate background add to value
 391+ 598E 26 00        	LD H,0
 392+ 5990 DD 6E 10     	LD L,(IX+16)
 393+ 5993 CD 41 5E     	CALL HLx8
 394+ 5996 22 D7 5D     	LD (BLIT_STRUCT+6),HL
 395+ 5999              	; calculate pointer to background location
 396+ 5999 21 00 00     	LD HL,0
 397+ 599C 3A CE 5D     	LD A,(BLIT_TMP+1)
 398+ 599F B7           	OR A
 399+ 59A0 28 08        	JR Z, .L1
 400+ 59A2 47           	LD B,A
 401+ 59A3 ED 5B D7 5D  	LD DE,(BLIT_STRUCT+6)
 402+ 59A7              .L0:
 403+ 59A7 19           	ADD HL, DE
 404+ 59A8 10 FD        	DJNZ .L0
 405+ 59AA              .L1:
 406+ 59AA EB           	EX DE,HL
 407+ 59AB 26 00        	LD H,0
 408+ 59AD 3A CD 5D     	LD A,(BLIT_TMP+0)
 409+ 59B0 6F           	LD L,A
 410+ 59B1 CD 41 5E     	CALL HLx8
 411+ 59B4 19           	ADD HL,DE
 412+ 59B5 ED 5B D5 5D  	LD DE,(BLIT_STRUCT+4)
 413+ 59B9 19           	ADD HL,DE
 414+ 59BA 22 D5 5D     	LD (BLIT_STRUCT+4),HL
 415+ 59BD
 416+ 59BD FD 21 C4 59  	LD IY, .RET
 417+ 59C1 C3 05 5F     	JP ENABLE_PAGE0
 418+ 59C4              .RET:
 419+ 59C4 FB           	EI
 420+ 59C5 DD 21 D1 5D  	LD IX, BLIT_STRUCT
 421+ 59C9 CD 95 58     	CALL SHIFT_MERGE_CHARACTER
 422+ 59CC
 423+ 59CC D1               POP DE
 424+ 59CD C1               POP BC
 425+ 59CE C3 7C 5E         JP RESTORE_PAGE_INFO
 426+ 59D1              ; *******************************************************************************************************
 427+ 59D1               ENDIF
 428+ 59D1
 429+ 59D1               IF (0 == 1)
 430+ 59D1 ~            ; *******************************************************************************************************
 431+ 59D1 ~            ; function to handle CALL BLIT basic extension
 432+ 59D1 ~            ; rotates 1-bit character drawing horizontally with mask and character data and
 433+ 59D1 ~            ; fuses with background data and applies vertical shift too
 434+ 59D1 ~            ; in form without pointers
 435+ 59D1 ~            ; BLIT ( INT x,
 436+ 59D1 ~            ;		 INT y,
 437+ 59D1 ~            ;		 INT char_data_pointer,
 438+ 59D1 ~            ;		 INT mask_data_pointer,
 439+ 59D1 ~            ;		 INT width (in characters),
 440+ 59D1 ~            ;		 INT height (in characters),
 441+ 59D1 ~            ;		 INT background_pointer (top left),
 442+ 59D1 ~            ;		 INT background_width (in characters),
 443+ 59D1 ~            ; will put ram in page 0 also, page 1 is already there
 444+ 59D1 ~            BLIT:
 445+ 59D1 ~            	; opening (
 446+ 59D1 ~            	CALL CHKCHAR
 447+ 59D1 ~            	DB '('
 448+ 59D1 ~            	; get x coordinate
 449+ 59D1 ~            	LD IX, FRMQNT
 450+ 59D1 ~            	CALL CALBAS
 451+ 59D1 ~            	LD A, E
 452+ 59D1 ~            	AND 7
 453+ 59D1 ~            	LD (BLIT_STRUCT+0), A
 454+ 59D1 ~            	CALL DEdiv8
 455+ 59D1 ~            	LD (BLIT_TMP+0),A
 456+ 59D1 ~            	; comma
 457+ 59D1 ~            	CALL CHKCHAR
 458+ 59D1 ~            	DB ','
 459+ 59D1 ~            	; get y coordinate
 460+ 59D1 ~            	LD IX, FRMQNT
 461+ 59D1 ~            	CALL CALBAS
 462+ 59D1 ~            	LD A, E
 463+ 59D1 ~            	AND 7
 464+ 59D1 ~            	LD (BLIT_STRUCT+2), A
 465+ 59D1 ~            	CALL DEdiv8
 466+ 59D1 ~            	LD (BLIT_TMP+1),A
 467+ 59D1 ~            	; comma
 468+ 59D1 ~            	CALL CHKCHAR
 469+ 59D1 ~            	DB ','
 470+ 59D1 ~            	; get char data pointer
 471+ 59D1 ~            	LD IX, FRMQNT
 472+ 59D1 ~            	CALL CALBAS
 473+ 59D1 ~            	LD (BLIT_STRUCT+10), DE
 474+ 59D1 ~            	; comma
 475+ 59D1 ~            	CALL CHKCHAR
 476+ 59D1 ~            	DB ','
 477+ 59D1 ~            	; get mask data pointer
 478+ 59D1 ~            	LD IX, FRMQNT
 479+ 59D1 ~            	CALL CALBAS
 480+ 59D1 ~            	LD (BLIT_STRUCT+8), DE
 481+ 59D1 ~            	; comma
 482+ 59D1 ~            	CALL CHKCHAR
 483+ 59D1 ~            	DB ','
 484+ 59D1 ~            	; get width
 485+ 59D1 ~            	LD IX, FRMQNT
 486+ 59D1 ~            	CALL CALBAS
 487+ 59D1 ~            	LD A, E
 488+ 59D1 ~            	LD (BLIT_STRUCT+14), A
 489+ 59D1 ~            	; comma
 490+ 59D1 ~            	CALL CHKCHAR
 491+ 59D1 ~            	DB ','
 492+ 59D1 ~            	; get height
 493+ 59D1 ~            	LD IX, FRMQNT
 494+ 59D1 ~            	CALL CALBAS
 495+ 59D1 ~            	LD A, E
 496+ 59D1 ~            	LD (BLIT_STRUCT+16), A
 497+ 59D1 ~            	; comma
 498+ 59D1 ~            	CALL CHKCHAR
 499+ 59D1 ~            	DB ','
 500+ 59D1 ~            	; get background pointer
 501+ 59D1 ~            	LD IX, FRMQNT
 502+ 59D1 ~            	CALL CALBAS
 503+ 59D1 ~            	LD (BLIT_STRUCT+4), DE
 504+ 59D1 ~            	; comma
 505+ 59D1 ~            	CALL CHKCHAR
 506+ 59D1 ~            	DB ','
 507+ 59D1 ~            	; get background width
 508+ 59D1 ~            	LD IX, FRMQNT
 509+ 59D1 ~            	CALL CALBAS
 510+ 59D1 ~            	LD A, E
 511+ 59D1 ~            	LD (BLIT_TMP+2), A
 512+ 59D1 ~            	; ending )
 513+ 59D1 ~            	CALL CHKCHAR
 514+ 59D1 ~            	DB ')'
 515+ 59D1 ~
 516+ 59D1 ~            	PUSH HL ; save position in BASIC buffer
 517+ 59D1 ~
 518+ 59D1 ~            	; calculate char&mask add to value
 519+ 59D1 ~            	LD H, 0
 520+ 59D1 ~            	LD A, (BLIT_STRUCT+14)
 521+ 59D1 ~            	LD L, A
 522+ 59D1 ~            	CALL HLx8
 523+ 59D1 ~            	LD (BLIT_STRUCT+12), HL
 524+ 59D1 ~            	; calculate background add to value
 525+ 59D1 ~            	LD H, 0
 526+ 59D1 ~            	LD A, (BLIT_TMP+2)
 527+ 59D1 ~            	LD L, A
 528+ 59D1 ~            	CALL HLx8
 529+ 59D1 ~            	LD (BLIT_STRUCT+6), HL
 530+ 59D1 ~            	; calculate pointer to background location
 531+ 59D1 ~            	LD HL, 0
 532+ 59D1 ~            	LD A,(BLIT_TMP+1)
 533+ 59D1 ~            	OR A
 534+ 59D1 ~            	JR Z, .L1
 535+ 59D1 ~            	LD B,A
 536+ 59D1 ~            	LD DE,(BLIT_STRUCT+6)
 537+ 59D1 ~            .L0:
 538+ 59D1 ~            	ADD HL, DE
 539+ 59D1 ~            	DJNZ .L0
 540+ 59D1 ~            .L1:
 541+ 59D1 ~            	EX DE,HL
 542+ 59D1 ~            	LD H,0
 543+ 59D1 ~            	LD A,(BLIT_TMP+0)
 544+ 59D1 ~            	LD L,A
 545+ 59D1 ~            	CALL HLx8
 546+ 59D1 ~            	ADD HL,DE
 547+ 59D1 ~            	LD DE,(BLIT_STRUCT+4)
 548+ 59D1 ~            	ADD HL,DE
 549+ 59D1 ~            	LD (BLIT_STRUCT+4),HL
 550+ 59D1 ~
 551+ 59D1 ~            	LD IY, .RET
 552+ 59D1 ~            	JP ENABLE_PAGE0
 553+ 59D1 ~            .RET:
 554+ 59D1 ~            	EI
 555+ 59D1 ~            	LD IX, BLIT_STRUCT
 556+ 59D1 ~            	CALL SHIFT_MERGE_CHARACTER
 557+ 59D1 ~
 558+ 59D1 ~                POP DE
 559+ 59D1 ~                POP BC
 560+ 59D1 ~                CALL RESTORE_PAGE_INFO
 561+ 59D1 ~
 562+ 59D1 ~            	POP HL
 563+ 59D1 ~            	RET
 564+ 59D1 ~            ; *******************************************************************************************************
 565+ 59D1               ENDIF
# file closed: asm\BLIT.asm
 159  59D1               ENDIF
 160  59D1
 161  59D1               IF (TILE_CMDS == 1)
 162  59D1               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
   1+ 59D1              ; *******************************************************************************************************
   2+ 59D1              ; generic function to implement tiling
   3+ 59D1              ; should be modified to call appropriate function for memory or vram
   4+ 59D1              ; input IX=pointer to following structure
   5+ 59D1              ; +00 tile_data_ptr
   6+ 59D1              ; +02 tile_rows
   7+ 59D1              ; +04 tile_columns
   8+ 59D1              ; +06 destination_address
   9+ 59D1              ; +08 dest_to_next_row_add_to_value
  10+ 59D1              ; +10 num_horizontal_tiles
  11+ 59D1              ; +12 num_vertical_tiles
  12+ 59D1              ; modifies AF, BC, DE, HL
  13+ 59D1              TILE:
  14+ 59D1 DD 6E 06     	LD L, (IX+6)
  15+ 59D4 DD 66 07     	LD H, (IX+7) ; destination address
  16+ 59D7 22 CD 5D     	LD (TILETMP1), HL
  17+ 59DA DD 46 0C     	LD B, (IX+12) ; vertical tile number
  18+ 59DD              .L1:
  19+ 59DD C5           	PUSH BC
  20+ 59DE DD 6E 00     		LD L, (IX+0)
  21+ 59E1 DD 66 01     		LD H, (IX+1) ; tile address
  22+ 59E4 22 CF 5D     		LD (TILETMP2), HL
  23+ 59E7 DD 46 02     		LD B, (IX+2) ; tile rows
  24+ 59EA              .L2:
  25+ 59EA C5           		PUSH BC
  26+ 59EB CD 00 00     .CALL1:		CALL 0
  27+ 59EE DD 46 0A     			LD B, (IX+10) ; horizontal tile num
  28+ 59F1              .L3:
  29+ 59F1 C5           			PUSH BC
  30+ 59F2 2A CF 5D     				LD HL, (TILETMP2)
  31+ 59F5 DD 46 04     				LD B, (IX+4) ; tile columns
  32+ 59F8              .L4:
  33+ 59F8 C5           				PUSH BC
  34+ 59F9              .CALL2:
  35+ 59F9 CD 00 00     					CALL 0
  36+ 59FC C1           				POP BC
  37+ 59FD 10 F9        				DJNZ .L4
  38+ 59FF C1           			POP BC
  39+ 5A00 10 EF        			DJNZ .L3
  40+ 5A02 22 CF 5D     			LD (TILETMP2), HL
  41+ 5A05 2A CD 5D     			LD HL, (TILETMP1)
  42+ 5A08 DD 5E 08     			LD E, (IX+8)
  43+ 5A0B DD 56 09     			LD D, (IX+9) ; add to value for dest next row
  44+ 5A0E 19           			ADD HL, DE
  45+ 5A0F 22 CD 5D     			LD (TILETMP1), HL
  46+ 5A12 C1           		POP BC
  47+ 5A13 10 D5        		DJNZ .L2
  48+ 5A15 C1           	POP BC
  49+ 5A16 10 C5        	DJNZ .L1
  50+ 5A18 C9           	RET
  51+ 5A19              ; *******************************************************************************************************
  52+ 5A19
  53+ 5A19               IF (1 == 1)
  54+ 5A19              ; *******************************************************************************************************
  55+ 5A19              ; same as TILERAM but for DEFUSR approach
  56+ 5A19              ; input IX=pointer to input array, real data from +2
  57+ 5A19              ; +02 = tile data pointer
  58+ 5A19              ; +04 = tile columns
  59+ 5A19              ; +06 = tile rows
  60+ 5A19              ; +08 = destination pointer
  61+ 5A19              ; +10 = destination columns
  62+ 5A19              ; +12 = destination rows
  63+ 5A19              ; +14 = destination begin column
  64+ 5A19              ; +16 = destination begin row
  65+ 5A19              ; +18 = number of tiles horizontally
  66+ 5A19              ; +20 = number of tiles vertically
  67+ 5A19              ; *******************************************************************************************************
  68+ 5A19              TILERAM_DEFUSR:
  69+ 5A19              	; tile data pointer
  70+ 5A19 DD 6E 02     	LD L,(IX+2)
  71+ 5A1C DD 66 03     	LD H,(IX+3)
  72+ 5A1F 22 D1 5D     	LD (BLIT_STRUCT+0),HL
  73+ 5A22              	; tile columns
  74+ 5A22 DD 6E 04     	LD L,(IX+4)
  75+ 5A25 DD 66 05     	LD H,(IX+5)
  76+ 5A28 22 D5 5D     	LD (BLIT_STRUCT+4),HL
  77+ 5A2B              	; tile rows
  78+ 5A2B DD 6E 06     	LD L,(IX+6)
  79+ 5A2E DD 66 07     	LD H,(IX+7)
  80+ 5A31 22 D3 5D     	LD (BLIT_STRUCT+2),HL
  81+ 5A34              	; destintion pointer
  82+ 5A34 DD 6E 08     	LD L,(IX+8)
  83+ 5A37 DD 66 09     	LD H,(IX+9)
  84+ 5A3A 22 D7 5D     	LD (BLIT_STRUCT+6),HL
  85+ 5A3D              	; destination columns
  86+ 5A3D DD 7E 0A     	LD A,(IX+10)
  87+ 5A40 32 CD 5D     	LD (BLIT_TMP+0),A
  88+ 5A43              	; destination rows
  89+ 5A43 DD 7E 0C     	LD A,(IX+12)
  90+ 5A46 32 CE 5D     	LD (BLIT_TMP+1),A
  91+ 5A49              	; destination begin column
  92+ 5A49 DD 7E 0E     	LD A,(IX+14)
  93+ 5A4C 32 CF 5D     	LD (BLIT_TMP+2),A
  94+ 5A4F              	; destination begin row
  95+ 5A4F DD 7E 10     	LD A,(IX+16)
  96+ 5A52 32 D0 5D     	LD (BLIT_TMP+3),A
  97+ 5A55              	; number of tiles horizontally
  98+ 5A55 DD 6E 12     	LD L,(IX+18)
  99+ 5A58 DD 66 13     	LD H,(IX+19)
 100+ 5A5B 22 DB 5D     	LD (BLIT_STRUCT+10),HL
 101+ 5A5E              	; number of tiles vertically
 102+ 5A5E DD 6E 14     	LD L,(IX+20)
 103+ 5A61 DD 66 15     	LD H,(IX+21)
 104+ 5A64 22 DD 5D     	LD (BLIT_STRUCT+12),HL
 105+ 5A67               IF (0 == 1) ; otherwise we just continue with code below
 106+ 5A67 ~            	JP TILERAM.COMMON
 107+ 5A67               ENDIF
 108+ 5A67               ENDIF
 109+ 5A67
 110+ 5A67              ; *******************************************************************************************************
 111+ 5A67              ; function to handle CALL TILERAM basic extension
 112+ 5A67              ; fills memory with tiles
 113+ 5A67              ; TILERAM ( INT tile_data_pointer,
 114+ 5A67              ;			INT tile_columns,
 115+ 5A67              ;			INT tile_rows,
 116+ 5A67              ;			INT destination_pointer,
 117+ 5A67              ;			INT destination_columns,
 118+ 5A67              ;			INT destination_rows,
 119+ 5A67              ;			INT destination_begin_column,
 120+ 5A67              ;			INT destination_begin_row,
 121+ 5A67              ;			INT number_of_tiles_horizontally,
 122+ 5A67              ;			INT	number_of_tiles_vertically )
 123+ 5A67              ; will put ram in page 0 also, page 1 is already there
 124+ 5A67              TILERAM:
 125+ 5A67               IF (0 == 1)
 126+ 5A67 ~            	; opening (
 127+ 5A67 ~            	CALL CHKCHAR
 128+ 5A67 ~            	DB '('
 129+ 5A67 ~            	; get tile data pointer coordinate
 130+ 5A67 ~            	LD IX, FRMQNT
 131+ 5A67 ~            	CALL CALBAS
 132+ 5A67 ~            	LD (BLIT_STRUCT+0), DE
 133+ 5A67 ~            	; comma
 134+ 5A67 ~            	CALL CHKCHAR
 135+ 5A67 ~            	DB ','
 136+ 5A67 ~            	; get tile columns
 137+ 5A67 ~            	LD IX, FRMQNT
 138+ 5A67 ~            	CALL CALBAS
 139+ 5A67 ~            	LD (BLIT_STRUCT+4), DE
 140+ 5A67 ~            	; comma
 141+ 5A67 ~            	CALL CHKCHAR
 142+ 5A67 ~            	DB ','
 143+ 5A67 ~            	; get tile columns
 144+ 5A67 ~            	LD IX, FRMQNT
 145+ 5A67 ~            	CALL CALBAS
 146+ 5A67 ~            	LD (BLIT_STRUCT+2), DE
 147+ 5A67 ~            	; comma
 148+ 5A67 ~            	CALL CHKCHAR
 149+ 5A67 ~            	DB ','
 150+ 5A67 ~            	; get destintion pointer
 151+ 5A67 ~            	LD IX, FRMQNT
 152+ 5A67 ~            	CALL CALBAS
 153+ 5A67 ~            	LD (BLIT_STRUCT+6), DE
 154+ 5A67 ~            	; comma
 155+ 5A67 ~            	CALL CHKCHAR
 156+ 5A67 ~            	DB ','
 157+ 5A67 ~            	; get destination columns
 158+ 5A67 ~            	LD IX, FRMQNT
 159+ 5A67 ~            	CALL CALBAS
 160+ 5A67 ~            	LD A, E
 161+ 5A67 ~            	LD (BLIT_TMP+0), A
 162+ 5A67 ~            	; comma
 163+ 5A67 ~            	CALL CHKCHAR
 164+ 5A67 ~            	DB ','
 165+ 5A67 ~            	; get destination rows
 166+ 5A67 ~            	LD IX, FRMQNT
 167+ 5A67 ~            	CALL CALBAS
 168+ 5A67 ~            	LD A, E
 169+ 5A67 ~            	LD (BLIT_TMP+1), A
 170+ 5A67 ~            	; comma
 171+ 5A67 ~            	CALL CHKCHAR
 172+ 5A67 ~            	DB ','
 173+ 5A67 ~            	; get destination begin column
 174+ 5A67 ~            	LD IX, FRMQNT
 175+ 5A67 ~            	CALL CALBAS
 176+ 5A67 ~            	LD A, E
 177+ 5A67 ~            	LD (BLIT_TMP+2), A
 178+ 5A67 ~            	; comma
 179+ 5A67 ~            	CALL CHKCHAR
 180+ 5A67 ~            	DB ','
 181+ 5A67 ~            	; get destination begin row
 182+ 5A67 ~            	LD IX, FRMQNT
 183+ 5A67 ~            	CALL CALBAS
 184+ 5A67 ~            	LD A, E
 185+ 5A67 ~            	LD (BLIT_TMP+3), A
 186+ 5A67 ~            	; comma
 187+ 5A67 ~            	CALL CHKCHAR
 188+ 5A67 ~            	DB ','
 189+ 5A67 ~            	; get number of tiles horizontally
 190+ 5A67 ~            	LD IX, FRMQNT
 191+ 5A67 ~            	CALL CALBAS
 192+ 5A67 ~            	LD (BLIT_STRUCT+10), DE
 193+ 5A67 ~            	; comma
 194+ 5A67 ~            	CALL CHKCHAR
 195+ 5A67 ~            	DB ','
 196+ 5A67 ~            	; get number of tiles vertically
 197+ 5A67 ~            	LD IX, FRMQNT
 198+ 5A67 ~            	CALL CALBAS
 199+ 5A67 ~            	LD (BLIT_STRUCT+12), DE
 200+ 5A67 ~            	; ending )
 201+ 5A67 ~            	CALL CHKCHAR
 202+ 5A67 ~            	DB ')'
 203+ 5A67               ENDIF
 204+ 5A67              .COMMON:
 205+ 5A67 E5           	PUSH HL ; save position in BASIC buffer
 206+ 5A68
 207+ 5A68              	; calculate destination add to value
 208+ 5A68 26 00        	LD H, 0
 209+ 5A6A 3A CD 5D     	LD A, (BLIT_TMP+0)
 210+ 5A6D 6F           	LD L, A
 211+ 5A6E CD 41 5E     	CALL HLx8
 212+ 5A71 22 D9 5D     	LD (BLIT_STRUCT+8), HL
 213+ 5A74              	; calculate pointer to background location
 214+ 5A74 21 00 00     	LD HL, 0
 215+ 5A77 3A D0 5D     	LD A,(BLIT_TMP+3)
 216+ 5A7A B7           	OR A
 217+ 5A7B 28 08        	JR Z, .L1
 218+ 5A7D 47           	LD B,A
 219+ 5A7E ED 5B D9 5D  	LD DE,(BLIT_STRUCT+8)
 220+ 5A82              .L0:
 221+ 5A82 19           	ADD HL, DE
 222+ 5A83 10 FD        	DJNZ .L0
 223+ 5A85              .L1:
 224+ 5A85 EB           	EX DE,HL
 225+ 5A86 26 00        	LD H,0
 226+ 5A88 3A CF 5D     	LD A,(BLIT_TMP+2)
 227+ 5A8B 6F           	LD L,A
 228+ 5A8C CD 41 5E     	CALL HLx8
 229+ 5A8F 19           	ADD HL,DE
 230+ 5A90 ED 5B D7 5D  	LD DE,(BLIT_STRUCT+6)
 231+ 5A94 19           	ADD HL,DE
 232+ 5A95 22 D7 5D     	LD (BLIT_STRUCT+6),HL
 233+ 5A98 FD 21 9F 5A  	LD IY, .RET
 234+ 5A9C C3 05 5F     	JP ENABLE_PAGE0
 235+ 5A9F              .RET:
 236+ 5A9F FB           	EI
 237+ 5AA0              	; set RAM functions to call
 238+ 5AA0 21 BA 5A     	LD HL, .TILECOPY
 239+ 5AA3 22 FA 59     	LD (TILE.CALL2+1), HL
 240+ 5AA6 21 CB 5A     	LD HL, .SETDESTROW
 241+ 5AA9 22 EC 59     	LD (TILE.CALL1+1), HL
 242+ 5AAC DD 21 D1 5D  	LD IX,BLIT_STRUCT
 243+ 5AB0 CD D1 59     	CALL TILE
 244+ 5AB3
 245+ 5AB3 D1               POP DE
 246+ 5AB4 C1               POP BC
 247+ 5AB5 CD 7C 5E         CALL RESTORE_PAGE_INFO
 248+ 5AB8
 249+ 5AB8 E1           	POP HL
 250+ 5AB9 C9           	RET
 251+ 5ABA              .TILECOPY:
 252+ 5ABA ED A0       > LDI
 252+ 5ABC ED A0       > LDI
 252+ 5ABE ED A0       > LDI
 252+ 5AC0 ED A0       > LDI
 252+ 5AC2 ED A0       > LDI
 252+ 5AC4 ED A0       > LDI
 252+ 5AC6 ED A0       > LDI
 252+ 5AC8 ED A0       > LDI
 253+ 5ACA C9           	RET
 254+ 5ACB              .SETDESTROW:
 255+ 5ACB ED 5B CD 5D  	LD DE, (TILETMP1)
 256+ 5ACF C9           	RET
 257+ 5AD0              ; *******************************************************************************************************
 258+ 5AD0
 259+ 5AD0               IF (1 == 1)
 260+ 5AD0              ; *******************************************************************************************************
 261+ 5AD0              ; same as TILEVRM but for DEFUSR approach
 262+ 5AD0              ; input IX=pointer to input array, real data from +2
 263+ 5AD0              ; +02 = tile data pointer
 264+ 5AD0              ; +04 = tile columns
 265+ 5AD0              ; +06 = tile rows
 266+ 5AD0              ; +08 = destination begin column
 267+ 5AD0              ; +10 = destination begin row
 268+ 5AD0              ; +12 = number of tiles horizontally
 269+ 5AD0              ; +14 = number of tiles vertically
 270+ 5AD0              ; *******************************************************************************************************
 271+ 5AD0              TILEVRM_DEFUSR:
 272+ 5AD0              	; tile data pointer
 273+ 5AD0 DD 6E 02     	LD L,(IX+2)
 274+ 5AD3 DD 66 03     	LD H,(IX+3)
 275+ 5AD6 22 D1 5D     	LD (BLIT_STRUCT+0),HL
 276+ 5AD9              	; tile columns
 277+ 5AD9 DD 6E 04     	LD L,(IX+4)
 278+ 5ADC DD 66 05     	LD H,(IX+5)
 279+ 5ADF 22 D5 5D     	LD (BLIT_STRUCT+4),HL
 280+ 5AE2              	; tile rows
 281+ 5AE2 DD 6E 06     	LD L,(IX+6)
 282+ 5AE5 DD 66 07     	LD H,(IX+7)
 283+ 5AE8 22 D3 5D     	LD (BLIT_STRUCT+2),HL
 284+ 5AEB              	; destination begin column
 285+ 5AEB DD 7E 08     	LD A,(IX+8)
 286+ 5AEE 32 CF 5D     	LD (BLIT_TMP+2),A
 287+ 5AF1              	; destination begin row
 288+ 5AF1 DD 7E 0A     	LD A,(IX+10)
 289+ 5AF4 32 D0 5D     	LD (BLIT_TMP+3),A
 290+ 5AF7              	; number of tiles horizontally
 291+ 5AF7 DD 6E 0C     	LD L,(IX+12)
 292+ 5AFA DD 66 0D     	LD H,(IX+13)
 293+ 5AFD 22 DB 5D     	LD (BLIT_STRUCT+10),HL
 294+ 5B00              	; number of tiles vertically
 295+ 5B00 DD 6E 0E     	LD L,(IX+14)
 296+ 5B03 DD 66 0F     	LD H,(IX+15)
 297+ 5B06 22 DD 5D     	LD (BLIT_STRUCT+12),HL
 298+ 5B09               IF (0 == 1) ; otherwise we just continue with code below
 299+ 5B09 ~            	JP TILEVRM.COMMON
 300+ 5B09               ENDIF
 301+ 5B09               ENDIF
 302+ 5B09
 303+ 5B09              ; *******************************************************************************************************
 304+ 5B09              ; function to handle CALL TILEVRM basic extension
 305+ 5B09              ; fills vram with tiles
 306+ 5B09              ; TILEVRM ( INT tile_data_pointer,
 307+ 5B09              ;			INT tile_columns,
 308+ 5B09              ;			INT tile_rows,
 309+ 5B09              ;			INT destination_begin_column,
 310+ 5B09              ;			INT destination_begin_row,
 311+ 5B09              ;			INT number_of_tiles_horizontally,
 312+ 5B09              ;			INT	number_of_tiles_vertically )
 313+ 5B09              ; will put ram in page 0 also, page 1 is already there
 314+ 5B09              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
 315+ 5B09              TILEVRM:
 316+ 5B09               IF (0 == 1)
 317+ 5B09 ~            	; opening (
 318+ 5B09 ~            	CALL CHKCHAR
 319+ 5B09 ~            	DB '('
 320+ 5B09 ~            	; get tile data pointer coordinate
 321+ 5B09 ~            	LD IX, FRMQNT
 322+ 5B09 ~            	CALL CALBAS
 323+ 5B09 ~            	LD (BLIT_STRUCT+0), DE
 324+ 5B09 ~            	; comma
 325+ 5B09 ~            	CALL CHKCHAR
 326+ 5B09 ~            	DB ','
 327+ 5B09 ~            	; get tile columns
 328+ 5B09 ~            	LD IX, FRMQNT
 329+ 5B09 ~            	CALL CALBAS
 330+ 5B09 ~            	LD (BLIT_STRUCT+4), DE
 331+ 5B09 ~            	; comma
 332+ 5B09 ~            	CALL CHKCHAR
 333+ 5B09 ~            	DB ','
 334+ 5B09 ~            	; get tile columns
 335+ 5B09 ~            	LD IX, FRMQNT
 336+ 5B09 ~            	CALL CALBAS
 337+ 5B09 ~            	LD (BLIT_STRUCT+2), DE
 338+ 5B09 ~            	; comma
 339+ 5B09 ~            	CALL CHKCHAR
 340+ 5B09 ~            	DB ','
 341+ 5B09 ~            	; get destination begin column
 342+ 5B09 ~            	LD IX, FRMQNT
 343+ 5B09 ~            	CALL CALBAS
 344+ 5B09 ~            	LD A, E
 345+ 5B09 ~            	LD (BLIT_TMP+2), A
 346+ 5B09 ~            	; comma
 347+ 5B09 ~            	CALL CHKCHAR
 348+ 5B09 ~            	DB ','
 349+ 5B09 ~            	; get destination begin row
 350+ 5B09 ~            	LD IX, FRMQNT
 351+ 5B09 ~            	CALL CALBAS
 352+ 5B09 ~            	LD A, E
 353+ 5B09 ~            	LD (BLIT_TMP+3), A
 354+ 5B09 ~            	; comma
 355+ 5B09 ~            	CALL CHKCHAR
 356+ 5B09 ~            	DB ','
 357+ 5B09 ~            	; get number of tiles horizontally
 358+ 5B09 ~            	LD IX, FRMQNT
 359+ 5B09 ~            	CALL CALBAS
 360+ 5B09 ~            	LD (BLIT_STRUCT+10), DE
 361+ 5B09 ~            	; comma
 362+ 5B09 ~            	CALL CHKCHAR
 363+ 5B09 ~            	DB ','
 364+ 5B09 ~            	; get number of tiles vertically
 365+ 5B09 ~            	LD IX, FRMQNT
 366+ 5B09 ~            	CALL CALBAS
 367+ 5B09 ~            	LD (BLIT_STRUCT+12), DE
 368+ 5B09 ~            	; ending )
 369+ 5B09 ~            	CALL CHKCHAR
 370+ 5B09 ~            	DB ')'
 371+ 5B09               ENDIF
 372+ 5B09
 373+ 5B09              .COMMON:
 374+ 5B09 E5           	PUSH HL ; save position in BASIC buffer
 375+ 5B0A
 376+ 5B0A              	; calculate destination add to value
 377+ 5B0A 21 00 01     	LD HL, 256
 378+ 5B0D 22 D9 5D     	LD (BLIT_STRUCT+8), HL
 379+ 5B10              	; calculate pointer to background location
 380+ 5B10 3A D0 5D     	LD A,(BLIT_TMP+3)
 381+ 5B13 67           	LD H,A
 382+ 5B14 2E 00        	LD L,0
 383+ 5B16 EB           	EX DE,HL
 384+ 5B17 26 00        	LD H,0
 385+ 5B19 3A CF 5D     	LD A,(BLIT_TMP+2)
 386+ 5B1C 6F           	LD L,A
 387+ 5B1D CD 41 5E     	CALL HLx8
 388+ 5B20 19           	ADD HL,DE
 389+ 5B21 ED 5B CB F3  	LD DE,(GRPCGP)
 390+ 5B25 19           	ADD HL,DE
 391+ 5B26 22 D7 5D     	LD (BLIT_STRUCT+6),HL
 392+ 5B29 FD 21 30 5B  	LD IY, .RET
 393+ 5B2D C3 05 5F     	JP ENABLE_PAGE0
 394+ 5B30              .RET:
 395+ 5B30 FB           	EI
 396+ 5B31              	; set RAM functions to call
 397+ 5B31 21 4B 5B     	LD HL, .TILECOPY
 398+ 5B34 22 FA 59     	LD (TILE.CALL2+1), HL
 399+ 5B37 21 51 5B     	LD HL, .SETDESTROW
 400+ 5B3A 22 EC 59     	LD (TILE.CALL1+1), HL
 401+ 5B3D DD 21 D1 5D  	LD IX,BLIT_STRUCT
 402+ 5B41 CD D1 59     	CALL TILE
 403+ 5B44
 404+ 5B44 D1               POP DE
 405+ 5B45 C1               POP BC
 406+ 5B46 CD 7C 5E         CALL RESTORE_PAGE_INFO
 407+ 5B49
 408+ 5B49 E1           	POP HL
 409+ 5B4A C9           	RET
 410+ 5B4B              .TILECOPY:
 411+ 5B4B 01 98 08     	LD BC, #0898
 412+ 5B4E C3 39 5E     	JP BBYTECOPY_NO_C
 413+ 5B51              .SETDESTROW:
 414+ 5B51 2A CD 5D     	LD HL, (TILETMP1)
 415+ 5B54 F3           	DI
 416+ 5B55 CD 22 5E     	CALL SETWRT_LOCAL_WRITE
 417+ 5B58 FB           	EI
 418+ 5B59 C9           	RET
 419+ 5B5A              ; *******************************************************************************************************
 420+ 5B5A
# file closed: asm\TILE.asm
 163  5B5A               ENDIF
 164  5B5A
 165  5B5A               IF (COLL_CMD == 1)
 166  5B5A               INCLUDE "COLLISION.asm"
# file opened: asm\COLLISION.asm
   1+ 5B5A              ; generic collision checking routines
   2+ 5B5A              ; in BASIC we use rectangle structure array DIM R%(7,n) of the format
   3+ 5B5A              ; R%(0,n) is active flag, <>0 active / 0 skipped in checks
   4+ 5B5A              ; R%(1,n) is either upper left x coordinate or sprite id (0-31) depending on R(7,n)
   5+ 5B5A              ; R%(2,n) is either upper left y coordinate or unused depending on R(7,n)
   6+ 5B5A              ; R%(3,n) x offset where rectangle begins
   7+ 5B5A              ; R%(4,n) y offset where rectangle begins
   8+ 5B5A              ; R%(5,n) is width
   9+ 5B5A              ; R%(6,n) is height
  10+ 5B5A              ; R%(7,0) is type, 0=generic where R%(1,0) contains x coordinate
  11+ 5B5A              ;                  <>0 sprite where R%(1,0) contains sprite id
  12+ 5B5A              ; for type sprite, upper left coordinates are taken from sprite attribute array
  13+ 5B5A
  14+ 5B5A              ; ************************************************************************************************
  15+ 5B5A              ; quick test if HL<=DE<=HL+BC
  16+ 5B5A              ; input BC=width, DE=x, HL=min
  17+ 5B5A              ; if not true flag C set
  18+ 5B5A              ; modifies AF
  19+ 5B5A              GENERIC_INNER_CHECK:
  20+ 5B5A E5               PUSH HL
  21+ 5B5B D5               PUSH DE
  22+ 5B5C EB               EX DE,HL
  23+ 5B5D A7               AND A
  24+ 5B5E ED 52            SBC HL, DE
  25+ 5B60 FA 6E 5B         JP M, .GENERIC_INNER_CHECK_NOT
  26+ 5B63 A7               AND A
  27+ 5B64 ED 42            SBC HL, BC
  28+ 5B66 28 03            JR Z, .L2
  29+ 5B68 F2 6E 5B         JP P, .GENERIC_INNER_CHECK_NOT
  30+ 5B6B              .L2:
  31+ 5B6B A7               AND A
  32+ 5B6C 18 01            JR .EXIT
  33+ 5B6E              .GENERIC_INNER_CHECK_NOT:
  34+ 5B6E 37               SCF
  35+ 5B6F              .EXIT:
  36+ 5B6F D1               POP DE
  37+ 5B70 E1               POP HL
  38+ 5B71 C9               RET
  39+ 5B72              ; ************************************************************************************************
  40+ 5B72
  41+ 5B72              ; ************************************************************************************************
  42+ 5B72              ; function to check if rectangles are overlapping
  43+ 5B72              ; input IX=IY=pointer to struct
  44+ 5B72              ;  +00 active flag
  45+ 5B72              ;  +02 x coordinate
  46+ 5B72              ;  +04 y coordinate
  47+ 5B72              ;  +06 x offset where rectangle begins
  48+ 5B72              ;  +08 y offset where rectangle begins
  49+ 5B72              ;  +10 width
  50+ 5B72              ;  +12 height
  51+ 5B72              ; where IY is used to read +2 and +4, and IX to read +6, +8, +10 and +12
  52+ 5B72              ; this is a hack to allow location being taken from sprite attributes table
  53+ 5B72              ; input BLIT_STRUCT data
  54+ 5B72              ;  +00 x coordinate
  55+ 5B72              ;  +02 y coordinate
  56+ 5B72              ;  +04 width
  57+ 5B72              ;  +06 height
  58+ 5B72              ; returns CF=1 if not overlapping, CF=0 if overlapping
  59+ 5B72              RECTANGLE_OVERLAP_CHECK:
  60+ 5B72                  ; first check which rectangle is higher
  61+ 5B72 DD 6E 0C         LD L,(IX+12)
  62+ 5B75 DD 66 0D         LD H,(IX+13)
  63+ 5B78 ED 5B D7 5D      LD DE,(BLIT_STRUCT+6)
  64+ 5B7C A7               AND A
  65+ 5B7D ED 52            SBC HL,DE
  66+ 5B7F FD 6E 04         LD L,(IY+4)
  67+ 5B82 FD 66 05         LD H,(IY+5)
  68+ 5B85 DD 5E 08         LD E,(IX+8)
  69+ 5B88 DD 56 09         LD D,(IX+9)
  70+ 5B8B FA AB 5B         JP M,.L1
  71+ 5B8E                  ; equally high or IX defined one higher
  72+ 5B8E                  ; check upper boundary
  73+ 5B8E 19               ADD HL,DE
  74+ 5B8F ED 5B D3 5D      LD DE,(BLIT_STRUCT+2)
  75+ 5B93 DD 4E 0C         LD C,(IX+12)
  76+ 5B96 DD 46 0D         LD B,(IX+13)
  77+ 5B99 CD 5A 5B         CALL GENERIC_INNER_CHECK
  78+ 5B9C 30 29            JR NC,.INSIDE
  79+ 5B9E                  ; check lower boundary
  80+ 5B9E E5               PUSH HL
  81+ 5B9F 2A D7 5D         LD HL,(BLIT_STRUCT+6)
  82+ 5BA2 19               ADD HL,DE
  83+ 5BA3 EB               EX DE,HL
  84+ 5BA4 E1               POP HL
  85+ 5BA5 CD 5A 5B         CALL GENERIC_INNER_CHECK
  86+ 5BA8 30 1D            JR NC,.INSIDE
  87+ 5BAA C9               RET ; not overlapping
  88+ 5BAB              .L1:
  89+ 5BAB                  ; rectangle defined in BLIT_STRUCT is higher
  90+ 5BAB 19               ADD HL,DE
  91+ 5BAC EB               EX DE,HL
  92+ 5BAD 2A D3 5D         LD HL,(BLIT_STRUCT+2)
  93+ 5BB0 ED 4B D7 5D      LD BC,(BLIT_STRUCT+6)
  94+ 5BB4 CD 5A 5B         CALL GENERIC_INNER_CHECK
  95+ 5BB7 30 0E            JR NC,.INSIDE
  96+ 5BB9 E5               PUSH HL
  97+ 5BBA DD 6E 0C         LD L,(IX+12)
  98+ 5BBD DD 66 0D         LD H,(IX+13)
  99+ 5BC0 19               ADD HL,DE
 100+ 5BC1 EB               EX DE,HL
 101+ 5BC2 E1               POP HL
 102+ 5BC3 CD 5A 5B         CALL GENERIC_INNER_CHECK
 103+ 5BC6 D8               RET C
 104+ 5BC7              .INSIDE:
 105+ 5BC7                  ; check x coordinate
 106+ 5BC7                  ; first check which rectangle is wider
 107+ 5BC7 DD 6E 0A         LD L,(IX+10)
 108+ 5BCA DD 66 0B         LD H,(IX+11)
 109+ 5BCD ED 5B D5 5D      LD DE,(BLIT_STRUCT+4)
 110+ 5BD1 A7               AND A
 111+ 5BD2 ED 52            SBC HL,DE
 112+ 5BD4 FD 6E 02         LD L,(IY+2)
 113+ 5BD7 FD 66 03         LD H,(IY+3)
 114+ 5BDA DD 5E 06         LD E,(IX+6)
 115+ 5BDD DD 56 07         LD D,(IX+7)
 116+ 5BE0 FA FC 5B         JP M,.L2
 117+ 5BE3                  ; equally wide or IX defined one wider
 118+ 5BE3                  ; check left boundary
 119+ 5BE3 19               ADD HL,DE
 120+ 5BE4 ED 5B D1 5D      LD DE,(BLIT_STRUCT+0)
 121+ 5BE8 DD 4E 0A         LD C,(IX+10)
 122+ 5BEB DD 46 0B         LD B,(IX+11)
 123+ 5BEE CD 5A 5B         CALL GENERIC_INNER_CHECK
 124+ 5BF1 D0               RET NC ; overlap
 125+ 5BF2                  ; check right boundary
 126+ 5BF2 E5               PUSH HL
 127+ 5BF3 2A D5 5D         LD HL,(BLIT_STRUCT+4)
 128+ 5BF6 19               ADD HL,DE
 129+ 5BF7 EB               EX DE,HL
 130+ 5BF8 E1               POP HL
 131+ 5BF9 C3 5A 5B         JP GENERIC_INNER_CHECK ; CF and result set by fn call
 132+ 5BFC              .L2:
 133+ 5BFC                  ; rectangle defined in BLIT_STRUCT is higher
 134+ 5BFC 19               ADD HL,DE
 135+ 5BFD EB               EX DE,HL
 136+ 5BFE 2A D1 5D         LD HL,(BLIT_STRUCT+0)
 137+ 5C01 ED 4B D5 5D      LD BC,(BLIT_STRUCT+4)
 138+ 5C05 CD 5A 5B         CALL GENERIC_INNER_CHECK
 139+ 5C08 D0               RET NC ; overlap
 140+ 5C09 E5               PUSH HL
 141+ 5C0A DD 6E 0A         LD L,(IX+10)
 142+ 5C0D DD 66 0B         LD H,(IX+11)
 143+ 5C10 19               ADD HL,DE
 144+ 5C11 EB               EX DE,HL
 145+ 5C12 E1               POP HL
 146+ 5C13 C3 5A 5B         JP GENERIC_INNER_CHECK
 147+ 5C16              ; ************************************************************************************************
 148+ 5C16
 149+ 5C16              ; ************************************************************************************************
 150+ 5C16              ; function tries to find rectangle overlap and returns an index if found
 151+ 5C16              ; input BLIT_STRUCT data
 152+ 5C16              ;  +00 x coordinate
 153+ 5C16              ;  +02 y coordinate
 154+ 5C16              ;  +04 width
 155+ 5C16              ;  +06 height
 156+ 5C16              ;  +08 number of items in a list, described under RECTANGLE_OVERLAP_CHECK
 157+ 5C16              ;  +09 pointer to first element of R%(7,n)
 158+ 5C16              ;  +11 pointer to INT result variable
 159+ 5C16              ; returns CF=1 if not overlapping
 160+ 5C16              ; returns A=list index and CF=0 if overlapping
 161+ 5C16              FIND_OVERLAP:
 162+ 5C16 3A D9 5D         LD A,(BLIT_STRUCT+8)
 163+ 5C19 47               LD B,A
 164+ 5C1A DD 2A DA 5D      LD IX,(BLIT_STRUCT+9)
 165+ 5C1E              .L1:
 166+ 5C1E C5               PUSH BC
 167+ 5C1F                  ; check active flag
 168+ 5C1F DD 7E 00         LD A,(IX)
 169+ 5C22 DD B6 01         OR (IX+1)
 170+ 5C25 28 18            JR Z,.NEXT
 171+ 5C27                  ; check type
 172+ 5C27 DD 7E 0E         LD A,(IX+14)
 173+ 5C2A DD B6 0F         OR (IX+15)
 174+ 5C2D 20 1A            JR NZ,.L2
 175+ 5C2F DD E5            PUSH IX
 176+ 5C31 FD E1            POP IY
 177+ 5C33              .L3:
 178+ 5C33 CD 72 5B         CALL RECTANGLE_OVERLAP_CHECK
 179+ 5C36 38 07            JR C,.NEXT
 180+ 5C38                  ; found
 181+ 5C38 C1               POP BC
 182+ 5C39 3A D9 5D         LD A,(BLIT_STRUCT+8)
 183+ 5C3C 90               SUB B
 184+ 5C3D A7               AND A
 185+ 5C3E C9               RET
 186+ 5C3F              .NEXT:
 187+ 5C3F 11 10 00         LD DE,16
 188+ 5C42 DD 19            ADD IX,DE
 189+ 5C44 C1               POP BC
 190+ 5C45 10 D7            DJNZ .L1
 191+ 5C47 37               SCF
 192+ 5C48 C9               RET
 193+ 5C49              .L2:
 194+ 5C49                  ; sprite, need to build a temporary data struct since x and y values are inversed
 195+ 5C49                  ; at BLIT_STRUCT+13
 196+ 5C49 DD 7E 02         LD A,(IX+2) ; sprite ID
 197+ 5C4C CD 89 4D         CALL GETnthSPRATTR
 198+ 5C4F FD 21 DC 5D      LD IY,BLIT_STRUCT+11
 199+ 5C53 7E               LD A,(HL)
 200+ 5C54 FD 77 04         LD (IY+4),A
 201+ 5C57 23               INC HL
 202+ 5C58 7E               LD A,(HL)
 203+ 5C59 FD 77 05         LD (IY+5),A
 204+ 5C5C 23               INC HL
 205+ 5C5D 7E               LD A,(HL)
 206+ 5C5E FD 77 02         LD (IY+2),A
 207+ 5C61 23               INC HL
 208+ 5C62 7E               LD A,(HL)
 209+ 5C63 FD 77 03         LD (IY+3),A
 210+ 5C66 18 CB            JR .L3
 211+ 5C68              ; ************************************************************************************************
 212+ 5C68
 213+ 5C68               IF (0 == 1)
 214+ 5C68 ~            ; ************************************************************************************************
 215+ 5C68 ~            ; function to handle CALL COLL basic extension
 216+ 5C68 ~            ; checks for collision between player and other rectangles
 217+ 5C68 ~            ; COLL ( INT result variable,
 218+ 5C68 ~            ;	     INT player x value,
 219+ 5C68 ~            ;	     INT player y value,
 220+ 5C68 ~            ;	     INT player width,
 221+ 5C68 ~            ;	     INT player height,
 222+ 5C68 ~            ;	     INT number of items in a list,
 223+ 5C68 ~            ;		 INT[6][n] rectangle struct )
 224+ 5C68 ~            ; will fill result variable with index or -1 if no collision
 225+ 5C68 ~            ; rectangle struct described under RECTANGLE_OVERLAP_CHECK
 226+ 5C68 ~            COLL:
 227+ 5C68 ~            	; opening (
 228+ 5C68 ~            	CALL CHKCHAR
 229+ 5C68 ~            	DB '('
 230+ 5C68 ~            	; get address of result variable
 231+ 5C68 ~            	LD IX, PTRGET
 232+ 5C68 ~            	CALL CALBAS
 233+ 5C68 ~            	LD (BLIT_STRUCT+11),DE
 234+ 5C68 ~            	; comma
 235+ 5C68 ~            	CALL CHKCHAR
 236+ 5C68 ~            	DB ','
 237+ 5C68 ~            	; get x
 238+ 5C68 ~            	LD IX, FRMQNT
 239+ 5C68 ~            	CALL CALBAS
 240+ 5C68 ~            	LD (BLIT_STRUCT+0),DE
 241+ 5C68 ~            	; comma
 242+ 5C68 ~            	CALL CHKCHAR
 243+ 5C68 ~            	DB ','
 244+ 5C68 ~            	; get y
 245+ 5C68 ~            	LD IX, FRMQNT
 246+ 5C68 ~            	CALL CALBAS
 247+ 5C68 ~            	LD (BLIT_STRUCT+2),DE
 248+ 5C68 ~            	; comma
 249+ 5C68 ~            	CALL CHKCHAR
 250+ 5C68 ~            	DB ','
 251+ 5C68 ~            	; get width
 252+ 5C68 ~            	LD IX, FRMQNT
 253+ 5C68 ~            	CALL CALBAS
 254+ 5C68 ~            	LD (BLIT_STRUCT+4),DE
 255+ 5C68 ~            	; comma
 256+ 5C68 ~            	CALL CHKCHAR
 257+ 5C68 ~            	DB ','
 258+ 5C68 ~            	; get height
 259+ 5C68 ~            	LD IX, FRMQNT
 260+ 5C68 ~            	CALL CALBAS
 261+ 5C68 ~            	LD (BLIT_STRUCT+6),DE
 262+ 5C68 ~            	; comma
 263+ 5C68 ~            	CALL CHKCHAR
 264+ 5C68 ~            	DB ','
 265+ 5C68 ~            	; get number of items in a list
 266+ 5C68 ~            	LD IX, GETBYT
 267+ 5C68 ~            	CALL CALBAS
 268+ 5C68 ~            	LD (BLIT_STRUCT+8),A
 269+ 5C68 ~            	; comma
 270+ 5C68 ~            	CALL CHKCHAR
 271+ 5C68 ~            	DB ','
 272+ 5C68 ~            	; get address of rectangle structure array DIM R%(7,n)
 273+ 5C68 ~            	LD A,(BLIT_STRUCT+8)
 274+ 5C68 ~                LD E,A
 275+ 5C68 ~                LD A,2
 276+ 5C68 ~            	LD B,A
 277+ 5C68 ~            	LD D,7
 278+ 5C68 ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
 279+ 5C68 ~            	LD (BLIT_STRUCT+9),BC
 280+ 5C68 ~            	; ending )
 281+ 5C68 ~            	CALL CHKCHAR
 282+ 5C68 ~            	DB ')'
 283+ 5C68 ~
 284+ 5C68 ~                PUSH HL
 285+ 5C68 ~                CALL FIND_OVERLAP
 286+ 5C68 ~                LD HL,(BLIT_STRUCT+11)
 287+ 5C68 ~                JR C,.NOTFOUND
 288+ 5C68 ~                LD (HL),A
 289+ 5C68 ~                INC HL
 290+ 5C68 ~                LD (HL),0
 291+ 5C68 ~                POP HL
 292+ 5C68 ~                RET
 293+ 5C68 ~            .NOTFOUND:
 294+ 5C68 ~                LD (HL),#FF
 295+ 5C68 ~                INC HL
 296+ 5C68 ~                LD (HL),#FF
 297+ 5C68 ~                POP HL
 298+ 5C68 ~                RET
 299+ 5C68 ~            ; ************************************************************************************************
 300+ 5C68               ENDIF
 301+ 5C68
 302+ 5C68               IF (1 == 1)
 303+ 5C68              ; *******************************************************************************************************
 304+ 5C68              ; same as COLL but for DEFUSR approach
 305+ 5C68              ; input IX=pointer to input array, real data from +2
 306+ 5C68              ; +02 = pointer to result variable
 307+ 5C68              ; +04 = player X
 308+ 5C68              ; +06 = player Y
 309+ 5C68              ; +08 = player width
 310+ 5C68              ; +10 = player height
 311+ 5C68              ; +12 = number of list items
 312+ 5C68              ; +14 = pointer to list of collidable objects
 313+ 5C68              COLL_DEFUSR:
 314+ 5C68 DD E5            PUSH IX
 315+ 5C6A E1               POP HL
 316+ 5C6B 23          > INC HL ; skip over to player x
 316+ 5C6C 23          > INC HL
 316+ 5C6D 23          > INC HL
 316+ 5C6E 23          > INC HL
 317+ 5C6F 11 D1 5D         LD DE,BLIT_STRUCT
 318+ 5C72 01 09 00         LD BC,9
 319+ 5C75 ED B0            LDIR ; copy over x,y,w,h,list item number
 320+ 5C77 DD 7E 0E         LD A,(IX+14)
 321+ 5C7A 32 DA 5D         LD (BLIT_STRUCT+9),A
 322+ 5C7D DD 7E 0F         LD A,(IX+15)
 323+ 5C80 32 DB 5D         LD (BLIT_STRUCT+10),A ; address to collidable objects array
 324+ 5C83 DD 7E 02         LD A,(IX+2)
 325+ 5C86 32 DC 5D         LD (BLIT_STRUCT+11),A
 326+ 5C89 DD 7E 03         LD A,(IX+3)
 327+ 5C8C 32 DD 5D         LD (BLIT_STRUCT+12),A ; address to results variable
 328+ 5C8F DD E5            PUSH IX
 329+ 5C91 CD 16 5C         CALL FIND_OVERLAP
 330+ 5C94 DD E1            POP IX
 331+ 5C96 DD 6E 02         LD L,(IX+2)
 332+ 5C99 DD 66 03         LD H,(IX+3)
 333+ 5C9C 38 05            JR C,.NOTFOUND
 334+ 5C9E 77               LD (HL),A
 335+ 5C9F 23               INC HL
 336+ 5CA0 36 00            LD (HL),0
 337+ 5CA2 C9               RET
 338+ 5CA3              .NOTFOUND:
 339+ 5CA3 36 FF            LD (HL),#FF
 340+ 5CA5 23               INC HL
 341+ 5CA6 36 FF            LD (HL),#FF
 342+ 5CA8 C9               RET
 343+ 5CA9              ; *******************************************************************************************************
 344+ 5CA9               ENDIF
 345+ 5CA9
# file closed: asm\COLLISION.asm
 167  5CA9               ENDIF
 168  5CA9
 169  5CA9               IF (DECOMP_CMDS == 1)
 170  5CA9               INCLUDE "decomp.asm"
# file opened: asm\decomp.asm
   1+ 5CA9              ; -----------------------------------------------------------------------------
   2+ 5CA9              ; ZX0 decoder by Einar Saukas & Urusergi
   3+ 5CA9              ; "Standard" version (68 bytes only)
   4+ 5CA9              ; -----------------------------------------------------------------------------
   5+ 5CA9              ; Parameters:
   6+ 5CA9              ;   HL: source address (compressed data)
   7+ 5CA9              ;   DE: destination address (decompressing)
   8+ 5CA9              ; -----------------------------------------------------------------------------
   9+ 5CA9
  10+ 5CA9              dzx0_standard:
  11+ 5CA9 01 FF FF             ld      bc, $ffff               ; preserve default offset 1
  12+ 5CAC C5                   push    bc
  13+ 5CAD 03                   inc     bc
  14+ 5CAE 3E 80                ld      a, $80
  15+ 5CB0              dzx0s_literals:
  16+ 5CB0 CD E0 5C             call    dzx0s_elias             ; obtain length
  17+ 5CB3              dzx0_ldir_1:
  18+ 5CB3 ED B0                ldir                            ; copy literals
  19+ 5CB5 00                   nop                             ; placeholder for call
  20+ 5CB6 87                   add     a, a                    ; copy from last offset or new offset?
  21+ 5CB7 38 0E                jr      c, dzx0s_new_offset
  22+ 5CB9 CD E0 5C             call    dzx0s_elias             ; obtain length
  23+ 5CBC              dzx0s_copy:
  24+ 5CBC E3                   ex      (sp), hl                ; preserve source, restore offset
  25+ 5CBD E5                   push    hl                      ; preserve offset
  26+ 5CBE 19                   add     hl, de                  ; calculate destination - offset
  27+ 5CBF              dzx0_ldir_2:
  28+ 5CBF ED B0                ldir                            ; copy from offset
  29+ 5CC1 00                   nop                             ; placeholder for call
  30+ 5CC2 E1                   pop     hl                      ; restore offset
  31+ 5CC3 E3                   ex      (sp), hl                ; preserve offset, restore source
  32+ 5CC4 87                   add     a, a                    ; copy from literals or new offset?
  33+ 5CC5 30 E9                jr      nc, dzx0s_literals
  34+ 5CC7              dzx0s_new_offset:
  35+ 5CC7 C1                   pop     bc                      ; discard last offset
  36+ 5CC8 0E FE                ld      c, $fe                  ; prepare negative offset
  37+ 5CCA CD E1 5C             call    dzx0s_elias_loop        ; obtain offset MSB
  38+ 5CCD 0C                   inc     c
  39+ 5CCE C8                   ret     z                       ; check end marker
  40+ 5CCF 41                   ld      b, c
  41+ 5CD0 4E                   ld      c, (hl)                 ; obtain offset LSB
  42+ 5CD1 23                   inc     hl
  43+ 5CD2 CB 18                rr      b                       ; last offset bit becomes first length bit
  44+ 5CD4 CB 19                rr      c
  45+ 5CD6 C5                   push    bc                      ; preserve new offset
  46+ 5CD7 01 01 00             ld      bc, 1                   ; obtain length
  47+ 5CDA D4 E8 5C             call    nc, dzx0s_elias_backtrack
  48+ 5CDD 03                   inc     bc
  49+ 5CDE 18 DC                jr      dzx0s_copy
  50+ 5CE0              dzx0s_elias:
  51+ 5CE0 0C                   inc     c                       ; interlaced Elias gamma coding
  52+ 5CE1              dzx0s_elias_loop:
  53+ 5CE1 87                   add     a, a
  54+ 5CE2 20 03                jr      nz, dzx0s_elias_skip
  55+ 5CE4 7E                   ld      a, (hl)                 ; load another group of 8 bits
  56+ 5CE5 23                   inc     hl
  57+ 5CE6 17                   rla
  58+ 5CE7              dzx0s_elias_skip:
  59+ 5CE7 D8                   ret     c
  60+ 5CE8              dzx0s_elias_backtrack:
  61+ 5CE8 87                   add     a, a
  62+ 5CE9 CB 11                rl      c
  63+ 5CEB CB 10                rl      b
  64+ 5CED 18 F2                jr      dzx0s_elias_loop
  65+ 5CEF              ; -----------------------------------------------------------------------------
  66+ 5CEF
  67+ 5CEF              ; *******************************************************************************************************
  68+ 5CEF              ; helper function for VRAM unpack to save AF prior to calling copy to VRAM fn
  69+ 5CEF              ; also simulates register states as if LDIR was called
  70+ 5CEF              LDIR_TO_VRAM:
  71+ 5CEF F5                   PUSH AF ; save AF used by algorithm
  72+ 5CF0 D5                   PUSH DE
  73+ 5CF1 C5                   PUSH BC
  74+ 5CF2 CD 5A 56             CALL VRAM_LDIRVM
  75+ 5CF5 C1                   POP BC
  76+ 5CF6 EB                   EX DE,HL
  77+ 5CF7 E1                   POP HL
  78+ 5CF8 09                   ADD HL,BC
  79+ 5CF9 EB                   EX DE,HL
  80+ 5CFA 01 00 00             LD BC,0
  81+ 5CFD F1                   POP AF
  82+ 5CFE C9                   RET
  83+ 5CFF              ; *******************************************************************************************************
  84+ 5CFF
  85+ 5CFF              ; *******************************************************************************************************
  86+ 5CFF              ; helper function to get a byte from VRAM address at HL and place it at DE also in VRAM
  87+ 5CFF              VPOKE_VPEEK:
  88+ 5CFF F3                   DI
  89+ 5D00 CD 2D 5E             CALL SETWRT_LOCAL_READ
  90+ 5D03 E3                   EX (SP),HL
  91+ 5D04 E3                   EX (SP),HL
  92+ 5D05 DB 98                IN A,(#98)
  93+ 5D07                      ;IN A,(#98) ; WHY IS THIS NEEDED ?
  94+ 5D07 F5                   PUSH AF
  95+ 5D08 EB                   EX DE,HL
  96+ 5D09 CD 22 5E             CALL SETWRT_LOCAL_WRITE
  97+ 5D0C E3                   EX (SP),HL
  98+ 5D0D E3                   EX (SP),HL
  99+ 5D0E EB                   EX DE,HL
 100+ 5D0F F1                   POP AF
 101+ 5D10 D3 98                OUT (#98),A
 102+ 5D12 FB                   EI
 103+ 5D13 C9                   RET
 104+ 5D14              ; *******************************************************************************************************
 105+ 5D14
 106+ 5D14              ; *******************************************************************************************************
 107+ 5D14              ; helper fn VRAM variant of LDIR
 108+ 5D14              ; input HL = source, DE = destination, BC = count
 109+ 5D14              VRAM_LDIR:
 110+ 5D14 F5                   PUSH AF
 111+ 5D15              _L0:
 112+ 5D15 CD FF 5C             CALL VPOKE_VPEEK
 113+ 5D18 23                   INC HL
 114+ 5D19 13                   INC DE
 115+ 5D1A 0B                   DEC BC
 116+ 5D1B 78                   LD A, B
 117+ 5D1C B1                   OR C
 118+ 5D1D 20 F6                JR NZ, _L0
 119+ 5D1F F1                   POP AF
 120+ 5D20 C9                   RET
 121+ 5D21              ; *******************************************************************************************************
 122+ 5D21
 123+ 5D21               IF (0 == 1)
 124+ 5D21 ~            ; *******************************************************************************************************
 125+ 5D21 ~            ; function to handle CALL VUNPACK basic extension
 126+ 5D21 ~            ; _VUNPACK ( INT source,
 127+ 5D21 ~            ;			 INT destination )
 128+ 5D21 ~            ; will put ram in page 0 also, page 1 is already there
 129+ 5D21 ~            ; *******************************************************************************************************
 130+ 5D21 ~            VUNPACK:
 131+ 5D21 ~                LD A, #CD ; CALL
 132+ 5D21 ~                LD (dzx0_ldir_1), A
 133+ 5D21 ~                LD (dzx0_ldir_2), A
 134+ 5D21 ~                LD DE, LDIR_TO_VRAM
 135+ 5D21 ~                LD (dzx0_ldir_1 + 1), DE
 136+ 5D21 ~                LD DE, VRAM_LDIR
 137+ 5D21 ~                LD (dzx0_ldir_2 + 1), DE
 138+ 5D21 ~                JR UNPACK_COMMON
 139+ 5D21 ~            ; function to handle CALL UNPACK basic extension
 140+ 5D21 ~            ; _UNPACK ( INT source,
 141+ 5D21 ~            ;			INT destination )
 142+ 5D21 ~            ; will put ram in page 0 also, page 1 is already there
 143+ 5D21 ~            UNPACK:
 144+ 5D21 ~                LD DE, #B0ED ; LDIR
 145+ 5D21 ~                LD (dzx0_ldir_1), DE
 146+ 5D21 ~                LD (dzx0_ldir_2), DE
 147+ 5D21 ~                XOR A ; NOP
 148+ 5D21 ~                LD (dzx0_ldir_1 + 2), A
 149+ 5D21 ~                LD (dzx0_ldir_2 + 2), A
 150+ 5D21 ~            UNPACK_COMMON:
 151+ 5D21 ~            	; opening (
 152+ 5D21 ~            	CALL CHKCHAR
 153+ 5D21 ~            	DB '('
 154+ 5D21 ~            	; get source address
 155+ 5D21 ~            	LD IX, FRMQNT
 156+ 5D21 ~            	CALL CALBAS
 157+ 5D21 ~            	PUSH DE
 158+ 5D21 ~            	; comma
 159+ 5D21 ~            	CALL CHKCHAR
 160+ 5D21 ~            	DB ','
 161+ 5D21 ~            	; get destination address
 162+ 5D21 ~            	LD IX, FRMQNT
 163+ 5D21 ~            	CALL CALBAS
 164+ 5D21 ~            	PUSH DE
 165+ 5D21 ~            	; ending )
 166+ 5D21 ~            	CALL CHKCHAR
 167+ 5D21 ~            	DB ')'
 168+ 5D21 ~
 169+ 5D21 ~            	; save position
 170+ 5D21 ~            	PUSH HL
 171+ 5D21 ~            	POP IX
 172+ 5D21 ~
 173+ 5D21 ~            	POP DE ; destination
 174+ 5D21 ~            	POP HL ; source
 175+ 5D21 ~            	EXX
 176+ 5D21 ~            	; enable page 0
 177+ 5D21 ~            	LD IY, .RET
 178+ 5D21 ~            	JP ENABLE_PAGE0
 179+ 5D21 ~            .RET:
 180+ 5D21 ~            	EI
 181+ 5D21 ~            	EXX
 182+ 5D21 ~            	CALL dzx0_standard
 183+ 5D21 ~                    POP DE
 184+ 5D21 ~                    POP BC
 185+ 5D21 ~                    CALL RESTORE_PAGE_INFO
 186+ 5D21 ~            	PUSH IX
 187+ 5D21 ~            	POP HL
 188+ 5D21 ~            	RET
 189+ 5D21 ~            ; *******************************************************************************************************
 190+ 5D21               ENDIF
 191+ 5D21
 192+ 5D21               IF (1 == 1)
 193+ 5D21              ; *******************************************************************************************************
 194+ 5D21              ; same as VUNPACK but for DEFUSR approach
 195+ 5D21              ; input IX=pointer to input array, real data from +2
 196+ 5D21              ; +2 = source address
 197+ 5D21              ; +4 = destination address
 198+ 5D21              ; *******************************************************************************************************
 199+ 5D21              VUNPACK_DEFUSR:
 200+ 5D21 3E CD            LD A, #CD ; CALL
 201+ 5D23 32 B3 5C         LD (dzx0_ldir_1), A
 202+ 5D26 32 BF 5C         LD (dzx0_ldir_2), A
 203+ 5D29 21 EF 5C         LD HL, LDIR_TO_VRAM
 204+ 5D2C 22 B4 5C         LD (dzx0_ldir_1 + 1), HL
 205+ 5D2F 21 14 5D         LD HL, VRAM_LDIR
 206+ 5D32 22 C0 5C         LD (dzx0_ldir_2 + 1), HL
 207+ 5D35 18 10            JR UNPACK_DEFUSR_COMMON
 208+ 5D37              ; same as UNPACK but for DEFUSR approach
 209+ 5D37              ; input IX=pointer to input array, real data from +2
 210+ 5D37              ; +2 = source address
 211+ 5D37              ; +4 = destination address
 212+ 5D37              UNPACK_DEFUSR:
 213+ 5D37 21 ED B0         LD HL, #B0ED ; LDIR
 214+ 5D3A 22 B3 5C         LD (dzx0_ldir_1), HL
 215+ 5D3D 22 BF 5C         LD (dzx0_ldir_2), HL
 216+ 5D40 AF               XOR A ; NOP
 217+ 5D41 32 B5 5C         LD (dzx0_ldir_1 + 2), A
 218+ 5D44 32 C1 5C         LD (dzx0_ldir_2 + 2), A
 219+ 5D47              UNPACK_DEFUSR_COMMON:
 220+ 5D47              	; enable page 0
 221+ 5D47 FD 21 4E 5D  	LD IY, .RET
 222+ 5D4B C3 05 5F     	JP ENABLE_PAGE0
 223+ 5D4E              .RET:
 224+ 5D4E FB           	EI
 225+ 5D4F DD 6E 02     	LD L,(IX+2)
 226+ 5D52 DD 66 03     	LD H,(IX+3)
 227+ 5D55 DD 5E 04     	LD E,(IX+4)
 228+ 5D58 DD 56 05     	LD D,(IX+5)
 229+ 5D5B CD A9 5C     	CALL dzx0_standard
 230+ 5D5E D1               POP DE
 231+ 5D5F C1               POP BC
 232+ 5D60 C3 7C 5E         JP RESTORE_PAGE_INFO
 233+ 5D63              ; *******************************************************************************************************
 234+ 5D63               ENDIF
# file closed: asm\decomp.asm
 171  5D63               ENDIF
 172  5D63
 173  5D63               IF (1 == 1)
 174  5D63               INCLUDE "DEFUSR.asm"
# file opened: asm\DEFUSR.asm
   1+ 5D63              ; entry function that handles call using CALLF
   2+ 5D63              ; pointer to data structure is expected at DAC+2
   3+ 5D63              ; first entry must be function id followed by function specific parameters
   4+ 5D63
   5+ 5D63              DEFUSR_TABLE_ENTRIES    EQU 40
   6+ 5D63
   7+ 5D63              DEFUSR_JUMP_TABLE:
   8+ 5D63               IF (SPRITE_CMDS == 1)
   9+ 5D63 6E 4E         DW SPRENABLE_DEFUSR        ; 0
  10+ 5D65               ELSE
  11+ 5D65 ~             DW NOACTION_DEFUSR
  12+ 5D65               ENDIF
  13+ 5D65
  14+ 5D65               IF (SPRITE_CMDS == 1)
  15+ 5D65 92 4E         DW SPRDISABLE_DEFUSR        ; 1
  16+ 5D67               ELSE
  17+ 5D67 ~             DW NOACTION_DEFUSR
  18+ 5D67               ENDIF
  19+ 5D67
  20+ 5D67               IF (RAM_CMDS == 1)
  21+ 5D67 22 55         DW MEMCPY_DEFUSR           ; 2
  22+ 5D69               ELSE
  23+ 5D69 ~             DW NOACTION_DEFUSR
  24+ 5D69               ENDIF
  25+ 5D69
  26+ 5D69               IF (VRAM_CMDS == 1)        ; 3
  27+ 5D69 23 56         DW MEMVRM_DEFUSR
  28+ 5D6B               ELSE
  29+ 5D6B ~             DW NOACTION_DEFUSR
  30+ 5D6B               ENDIF
  31+ 5D6B
  32+ 5D6B               IF (BLIT_CMDS == 1)        ; 4
  33+ 5D6B 37 59         DW BLIT_DEFUSR
  34+ 5D6D               ELSE
  35+ 5D6D ~             DW NOACTION_DEFUSR
  36+ 5D6D               ENDIF
  37+ 5D6D
  38+ 5D6D               IF (ANIM_CMDS == 1)        ; 5
  39+ 5D6D FA 53         DW SGAM_DEFUSR
  40+ 5D6F               ELSE
  41+ 5D6F ~             DW NOACTION_DEFUSR
  42+ 5D6F               ENDIF
  43+ 5D6F
  44+ 5D6F               IF (SPRITE_CMDS == 1)
  45+ 5D6F D5 4E         DW SPRGRPMOV_DEFUSR        ; 6
  46+ 5D71               ELSE
  47+ 5D71 ~             DW NOACTION_DEFUSR
  48+ 5D71               ENDIF
  49+ 5D71
  50+ 5D71               IF (COLL_CMD == 1)
  51+ 5D71 68 5C         DW COLL_DEFUSR             ; 7
  52+ 5D73               ELSE
  53+ 5D73 ~             DW NOACTION_DEFUSR
  54+ 5D73               ENDIF
  55+ 5D73
  56+ 5D73               IF (SOUND_CMDS == 1)
  57+ 5D73 DD 55         DW SNDSFX_DEFUSR             ; 8
  58+ 5D75               ELSE
  59+ 5D75 ~             DW NOACTION_DEFUSR
  60+ 5D75               ENDIF
  61+ 5D75
  62+ 5D75               IF (ANIM_CMDS == 1)
  63+ 5D75 8B 52         DW ANIMSTEP_SINGLE_DEFUSR      ; 9
  64+ 5D77 9B 52         DW ANIMSTEP_MULTI_DEFUSR       ; 10
  65+ 5D79 AC 52         DW ANIMSTART_SINGLE_DEFUSR     ; 11
  66+ 5D7B BE 52         DW ANIMSTART_MULTI_DEFUSR      ; 12
  67+ 5D7D C3 52         DW ANIMSTOP_SINGLE_DEFUSR      ; 13
  68+ 5D7F CD 52         DW ANIMSTOP_MULTI_DEFUSR       ; 14
  69+ 5D81               ELSE
  70+ 5D81 ~             DW NOACTION_DEFUSR
  71+ 5D81 ~             DW NOACTION_DEFUSR
  72+ 5D81 ~             DW NOACTION_DEFUSR
  73+ 5D81 ~             DW NOACTION_DEFUSR
  74+ 5D81 ~             DW NOACTION_DEFUSR
  75+ 5D81 ~             DW NOACTION_DEFUSR
  76+ 5D81               ENDIF
  77+ 5D81
  78+ 5D81               IF (BOX_CMDS == 1)
  79+ 5D81 42 57         DW BOXMEMCPY_DEFUSR            ; 15
  80+ 5D83 78 57         DW BOXMEMVRM_DEFUSR            ; 16
  81+ 5D85               ELSE
  82+ 5D85 ~             DW NOACTION_DEFUSR
  83+ 5D85 ~             DW NOACTION_DEFUSR
  84+ 5D85               ENDIF
  85+ 5D85
  86+ 5D85               IF (ANIM_CMDS == 1)
  87+ 5D85 35 4F         DW MAXANIMITEMS_DEFUSR         ; 17
  88+ 5D87 44 50         DW MAXANIMDEFS_DEFUSR          ; 18
  89+ 5D89 A1 50         DW MAXANIMSPRS_DEFUSR          ; 19
  90+ 5D8B 5F 51         DW MAXAUTOSGAMS_DEFUSR         ; 20
  91+ 5D8D FA 4F         DW ANIMITEMPAT_DEFUSR          ; 21
  92+ 5D8F 1F 50         DW ANIMITEMPTR_DEFUSR          ; 22
  93+ 5D91 7B 50         DW ANIMDEF_DEFUSR              ; 23
  94+ 5D93 EE 50         DW ANIMSPRITE_DEFUSR           ; 24
  95+ 5D95 25 51         DW ANIMCHAR_DEFUSR             ; 25
  96+ 5D97 B0 51         DW AUTOSGAMDEF_DEFUSR          ; 26
  97+ 5D99 40 52         DW AUTOSGAMSTART_DEFUSR        ; 27
  98+ 5D9B 67 52         DW AUTOSGAMSTOP_DEFUSR         ; 28
  99+ 5D9D               ELSE
 100+ 5D9D ~             DW NOACTION_DEFUSR
 101+ 5D9D ~             DW NOACTION_DEFUSR
 102+ 5D9D ~             DW NOACTION_DEFUSR
 103+ 5D9D ~             DW NOACTION_DEFUSR
 104+ 5D9D ~             DW NOACTION_DEFUSR
 105+ 5D9D ~             DW NOACTION_DEFUSR
 106+ 5D9D ~             DW NOACTION_DEFUSR
 107+ 5D9D ~             DW NOACTION_DEFUSR
 108+ 5D9D ~             DW NOACTION_DEFUSR
 109+ 5D9D ~             DW NOACTION_DEFUSR
 110+ 5D9D ~             DW NOACTION_DEFUSR
 111+ 5D9D ~             DW NOACTION_DEFUSR
 112+ 5D9D               ENDIF
 113+ 5D9D
 114+ 5D9D               IF (GENCAL_CMD == 1)
 115+ 5D9D C2 56         DW GENCAL_DEFUSR               ; 29
 116+ 5D9F               ELSE
 117+ 5D9F ~             DW NOACTION_DEFUSR
 118+ 5D9F               ENDIF
 119+ 5D9F
 120+ 5D9F               IF (RAM_CMDS == 1)
 121+ 5D9F 43 55         DW FILRAM_DEFUSR               ; 30
 122+ 5DA1               ELSE
 123+ 5DA1 ~             DW NOACTION_DEFUSR
 124+ 5DA1               ENDIF
 125+ 5DA1
 126+ 5DA1               IF (SOUND_CMDS == 1)
 127+ 5DA1 74 55         DW SNDPLYINI_DEFUSR            ; 31
 128+ 5DA3 A7 55         DW SNDPLYON_DEFUSR             ; 32
 129+ 5DA5 BA 55         DW SNDPLYOFF_DEFUSR            ; 33
 130+ 5DA7               ELSE
 131+ 5DA7 ~             DW NOACTION_DEFUSR
 132+ 5DA7 ~             DW NOACTION_DEFUSR
 133+ 5DA7 ~             DW NOACTION_DEFUSR
 134+ 5DA7               ENDIF
 135+ 5DA7
 136+ 5DA7               IF (TILE_CMDS == 1)
 137+ 5DA7 19 5A         DW TILERAM_DEFUSR              ; 34
 138+ 5DA9 D0 5A         DW TILEVRM_DEFUSR              ; 35
 139+ 5DAB               ELSE
 140+ 5DAB ~             DW NOACTION_DEFUSR
 141+ 5DAB ~             DW NOACTION_DEFUSR
 142+ 5DAB               ENDIF
 143+ 5DAB
 144+ 5DAB               IF (VRAM_CMDS == 1)
 145+ 5DAB 00 56         DW FILVRM_DEFUSR               ; 36
 146+ 5DAD 84 56         DW VRMMEM_DEFUSR               ; 37
 147+ 5DAF               ELSE
 148+ 5DAF ~             DW NOACTION_DEFUSR
 149+ 5DAF ~             DW NOACTION_DEFUSR
 150+ 5DAF               ENDIF
 151+ 5DAF
 152+ 5DAF               IF (DECOMP_CMDS == 1)
 153+ 5DAF 37 5D         DW UNPACK_DEFUSR               ; 38
 154+ 5DB1               IF (VRAM_CMDS == 1)
 155+ 5DB1 21 5D          DW VUNPACK_DEFUSR             ; 39
 156+ 5DB3               ELSE
 157+ 5DB3 ~              DW NOACTION_DEFUSR
 158+ 5DB3               ENDIF
 159+ 5DB3               ELSE
 160+ 5DB3 ~             DW NOACTION_DEFUSR
 161+ 5DB3 ~             DW NOACTION_DEFUSR
 162+ 5DB3               ENDIF
 163+ 5DB3
 164+ 5DB3              DEFUSR_ENTRY:
 165+ 5DB3 FB               EI
 166+ 5DB4 DD 2A F8 F7      LD IX,(DAC+2)
 167+ 5DB8 DD 7E 00         LD A,(IX)
 168+ 5DBB FE 28            CP DEFUSR_TABLE_ENTRIES
 169+ 5DBD D0               RET NC ; return if an undefined function requested
 170+ 5DBE 26 00            LD H,0
 171+ 5DC0 6F               LD L,A
 172+ 5DC1 29               ADD HL,HL
 173+ 5DC2 11 63 5D         LD DE,DEFUSR_JUMP_TABLE
 174+ 5DC5 19               ADD HL,DE
 175+ 5DC6 EB               EX DE,HL
 176+ 5DC7 1A               LD A,(DE)
 177+ 5DC8 6F               LD L,A
 178+ 5DC9 13               INC DE
 179+ 5DCA 1A               LD A,(DE)
 180+ 5DCB 67               LD H,A
 181+ 5DCC E9               JP (HL) ; call function with IX=pointer to data array
 182+ 5DCD
# file closed: asm\DEFUSR.asm
 175  5DCD               ENDIF
 176  5DCD
 177  5DCD              ; temp variables for BLIT, TILE functions
 178  5DCD               IF (BLIT_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS + COLL_CMD > 0)
 179  5DCD              BLIT_TMP:
 180  5DCD              TILETMP1:
 181  5DCD              BLIT_TMP1:
 182  5DCD 00 00         DW 0
 183  5DCF              TILETMP2:
 184  5DCF              BLIT_TMP2:
 185  5DCF 00 00         DW 0
 186  5DD1              BLIT_STRUCT:
 187  5DD1 00 00 00...   DS 17
 188  5DD5               ENDIF
 189  5DE2
 190  5DE2               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 191  5DE2              VRAM_UPDATE_IN_PROGRESS:
 192  5DE2 00            DB 0
 193  5DE3               ENDIF
 194  5DE3
 195  5DE3              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 196  5DE3              ; per starting letter, if no commands with this letter, NULL value
 197  5DE3              CMDS:
 198  5DE3 17 5E        	DW CMDS_A ; always present due to ARTINFO
 199  5DE5               IF (BLIT_CMDS + BOX_CMDS > 0) && (0 == 1)
 200  5DE5 ~                DW CMDS_B ; B
 201  5DE5               ELSE
 202  5DE5 00 00        	DW 0
 203  5DE7               ENDIF
 204  5DE7               IF (COLL_CMD == 1) && (0 == 1)
 205  5DE7 ~            	DW CMDS_C ;
 206  5DE7               ELSE
 207  5DE7 00 00            DW 0 ; C
 208  5DE9               ENDIF
 209  5DE9 00 00            DW 0 ; D
 210  5DEB 00 00            DW 0 ; E
 211  5DED               IF (VRAM_CMDS + RAM_CMDS > 0) && (0 == 1)
 212  5DED ~                DW CMDS_F; F
 213  5DED               ELSE
 214  5DED 00 00        	DW 0
 215  5DEF               ENDIF
 216  5DEF               IF (GENCAL_CMD > 0) && (0 == 1)
 217  5DEF ~                DW CMDS_G; G
 218  5DEF               ELSE
 219  5DEF 00 00        	DW 0
 220  5DF1               ENDIF
 221  5DF1 00 00            DW 0 ; H
 222  5DF3 00 00            DW 0 ; I
 223  5DF5 00 00            DW 0 ; J
 224  5DF7 00 00            DW 0 ; K
 225  5DF9 00 00            DW 0 ; L
 226  5DFB               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0) && (0 == 1)
 227  5DFB ~                DW CMDS_M ; M
 228  5DFB               ELSE
 229  5DFB 00 00        	DW 0
 230  5DFD               ENDIF
 231  5DFD 00 00            DW 0 ; N
 232  5DFF 00 00            DW 0 ; O
 233  5E01 00 00            DW 0 ; P
 234  5E03 00 00            DW 0 ; Q
 235  5E05 00 00            DW 0 ; R
 236  5E07               IF (SOUND_CMDS + SPRITE_CMDS > 0) && (0 == 1)
 237  5E07 ~                DW CMDS_S ; S
 238  5E07               ELSE
 239  5E07 00 00        	DW 0
 240  5E09               ENDIF
 241  5E09               IF (TILE_CMDS > 0) && (0 == 1)
 242  5E09 ~                DW CMDS_T ; T
 243  5E09               ELSE
 244  5E09 00 00        	DW 0
 245  5E0B               ENDIF
 246  5E0B               IF (DECOMP_CMDS > 0) && (0 == 1)
 247  5E0B ~                DW CMDS_U ; U
 248  5E0B               ELSE
 249  5E0B 00 00        	DW 0
 250  5E0D               ENDIF
 251  5E0D               IF ((VRAM_CMDS > 0) || (VRAM_CMDS + DECOMP_CMDS > 1)) && (0 == 1)
 252  5E0D ~                DW CMDS_V ; V
 253  5E0D               ELSE
 254  5E0D 00 00        	DW 0
 255  5E0F               ENDIF
 256  5E0F 00 00            DW 0 ; W
 257  5E11 00 00            DW 0 ; X
 258  5E13 00 00            DW 0 ; Y
 259  5E15 00 00            DW 0 ; Z
 260  5E17
 261  5E17               IF (0 == 1)
 262  5E17 ~             IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 263  5E17 ~            CMDS_M:
 264  5E17 ~             IF (VRAM_CMDS == 1)
 265  5E17 ~                DB "MEMVRM", 0
 266  5E17 ~                DW MEMVRM
 267  5E17 ~             ENDIF
 268  5E17 ~             IF (RAM_CMDS == 1)
 269  5E17 ~            	DB "MEMCPY", 0
 270  5E17 ~            	DW MEMCPY
 271  5E17 ~             ENDIF
 272  5E17 ~             IF (ANIM_CMDS == 1)
 273  5E17 ~            	DB "MAXANIMITEMS",0
 274  5E17 ~            	DW MAXANIMITEMS
 275  5E17 ~            	DB "MAXANIMDEFS",0
 276  5E17 ~            	DW MAXANIMDEFS
 277  5E17 ~            	DB "MAXANIMSPRS",0
 278  5E17 ~            	DW MAXANIMSPRS
 279  5E17 ~               DB "MAXAUTOSGAMS",0
 280  5E17 ~               DW MAXAUTOSGAMS
 281  5E17 ~             ENDIF
 282  5E17 ~             ENDIF
 283  5E17 ~
 284  5E17 ~             IF (VRAM_CMDS + RAM_CMDS > 0)
 285  5E17 ~            CMDS_F:
 286  5E17 ~             IF (VRAM_CMDS == 1)
 287  5E17 ~                DB "FILVRM", 0
 288  5E17 ~                DW FILVRM
 289  5E17 ~             ENDIF
 290  5E17 ~             IF (RAM_CMDS == 1)
 291  5E17 ~                DB "FILRAM", 0
 292  5E17 ~                DW FILRAM
 293  5E17 ~             ENDIF
 294  5E17 ~             ENDIF
 295  5E17 ~
 296  5E17 ~             IF (GENCAL_CMD > 0)
 297  5E17 ~            CMDS_G:
 298  5E17 ~             IF (GENCAL_CMD == 1)
 299  5E17 ~                DB "GENCAL", 0
 300  5E17 ~                DW GENCAL
 301  5E17 ~             ENDIF
 302  5E17 ~             ENDIF
 303  5E17 ~
 304  5E17 ~             IF (VRAM_CMDS > 0)
 305  5E17 ~            CMDS_V:
 306  5E17 ~             IF (VRAM_CMDS == 1)
 307  5E17 ~            	DB "VRMMEM", 0
 308  5E17 ~            	DW VRMMEM
 309  5E17 ~             ENDIF
 310  5E17 ~             IF (DECOMP_CMDS == 1)
 311  5E17 ~            	DB "VUNPACK", 0
 312  5E17 ~            	DW VUNPACK
 313  5E17 ~             ENDIF
 314  5E17 ~             ENDIF
 315  5E17 ~
 316  5E17 ~             IF (SOUND_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 317  5E17 ~            CMDS_S:
 318  5E17 ~             IF (SPRITE_CMDS + ANIM_CMDS > 0)
 319  5E17 ~                DB "SGAM",0
 320  5E17 ~                DW SGAM
 321  5E17 ~             ENDIF
 322  5E17 ~             IF (SPRITE_CMDS == 1)
 323  5E17 ~            	DB "SPRGRPMOV", 0
 324  5E17 ~            	DW SPRGRPMOV
 325  5E17 ~             ENDIF
 326  5E17 ~             IF (SOUND_CMDS == 1)
 327  5E17 ~            	DB "SNDSFX", 0
 328  5E17 ~            	DW SNDSFX
 329  5E17 ~            	DB "SNDPLYON", 0
 330  5E17 ~            	DW SNDPLYON
 331  5E17 ~            	DB "SNDPLYOFF", 0
 332  5E17 ~            	DW SNDPLYOFF
 333  5E17 ~            	DB "SNDPLYINI", 0
 334  5E17 ~            	DW SNDPLYINIT
 335  5E17 ~             ENDIF
 336  5E17 ~             IF (SPRITE_CMDS == 1)
 337  5E17 ~            	DB "SPRENABLE", 0
 338  5E17 ~            	DW SPRENABLE
 339  5E17 ~            	DB "SPRDISABLE", 0
 340  5E17 ~            	DW SPRDISABLE
 341  5E17 ~             ENDIF
 342  5E17 ~             ENDIF
 343  5E17 ~
 344  5E17 ~             IF (BLIT_CMDS + BOX_CMDS > 0)
 345  5E17 ~            CMDS_B:
 346  5E17 ~             IF (BLIT_CMDS == 1)
 347  5E17 ~            	DB "BLIT", 0
 348  5E17 ~            	DW BLIT
 349  5E17 ~             ENDIF
 350  5E17 ~             IF (BOX_CMDS == 1)
 351  5E17 ~            	DB "BOXMEMCPY", 0
 352  5E17 ~            	DW BOXMEMCPY
 353  5E17 ~            	DB "BOXMEMVRM", 0
 354  5E17 ~            	DW BOXMEMVRM
 355  5E17 ~             ENDIF
 356  5E17 ~             ENDIF
 357  5E17 ~
 358  5E17 ~             IF (TILE_CMDS > 0)
 359  5E17 ~            CMDS_T:
 360  5E17 ~             IF (TILE_CMDS == 1)
 361  5E17 ~            	DB "TILERAM", 0
 362  5E17 ~            	DW TILERAM
 363  5E17 ~            	DB "TILEVRM", 0
 364  5E17 ~            	DW TILEVRM
 365  5E17 ~             ENDIF
 366  5E17 ~             ENDIF
 367  5E17 ~
 368  5E17 ~             IF (COLL_CMD > 0)
 369  5E17 ~            CMDS_C:
 370  5E17 ~             IF (COLL_CMD == 1)
 371  5E17 ~                DB "COLL", 0
 372  5E17 ~                DW COLL
 373  5E17 ~             ENDIF
 374  5E17 ~             ENDIF
 375  5E17 ~
 376  5E17 ~             IF (DECOMP_CMDS > 0)
 377  5E17 ~            CMDS_U:
 378  5E17 ~             IF (DECOMP_CMDS == 1)
 379  5E17 ~                DB "UNPACK", 0
 380  5E17 ~                DW UNPACK
 381  5E17 ~             ENDIF
 382  5E17 ~             ENDIF
 383  5E17 ~
 384  5E17 ~            CMDS_A:
 385  5E17 ~             IF (ANIM_CMDS == 1)
 386  5E17 ~               DB "ANIMSTEP",0
 387  5E17 ~               DW ANIMSTEP
 388  5E17 ~            	DB "ANIMSTART",0
 389  5E17 ~            	DW ANIMSTART
 390  5E17 ~            	DB "ANIMSTOP",0
 391  5E17 ~            	DW ANIMSTOP
 392  5E17 ~            	DB "ANIMITEMPAT",0
 393  5E17 ~            	DW ANIMITEMPAT
 394  5E17 ~            	DB "ANIMITEMPTR",0
 395  5E17 ~            	DW ANIMITEMPTR_CMD
 396  5E17 ~            	DB "ANIMDEF",0
 397  5E17 ~            	DW ANIMDEF
 398  5E17 ~            	DB "ANIMSPRITE",0
 399  5E17 ~            	DW ANIMSPRITE
 400  5E17 ~               DB "ANIMCHAR",0
 401  5E17 ~               DW ANIMCHAR
 402  5E17 ~               DB "AUTOSGAMDEF",0
 403  5E17 ~               DW AUTOSGAMDEF
 404  5E17 ~               DB "AUTOSGAMSTART",0
 405  5E17 ~               DW AUTOSGAMSTART
 406  5E17 ~               DB "AUTOSGAMSTOP",0
 407  5E17 ~               DW AUTOSGAMSTOP
 408  5E17 ~             ENDIF
 409  5E17 ~               DB "ARTINFO",0
 410  5E17 ~               DW ARTINFO
 411  5E17 ~            	DB 0
 412  5E17               ELSE // if not BASIC extension
 413  5E17              CMDS_A:
 414  5E17 41 52 54 49     DB "ARTINFO",0
 414  5E1B 4E 46 4F 00
 415  5E1F 81 5F           DW ARTINFO
 416  5E21 00           	DB 0
 417  5E22               ENDIF
 418  5E22
 419  5E22               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 420  5E22              ; ****************************************************************************************************
 421  5E22              ; function sets VRAM address for writing
 422  5E22              ; input HL=address
 423  5E22              ; modifies AF
 424  5E22              SETWRT_LOCAL_WRITE:
 425  5E22 7D           	LD	A,L
 426  5E23 D3 99        	OUT (#99),A
 427  5E25 7C           	LD	A,H
 428  5E26 E6 3F        	AND #3F
 429  5E28 F6 40        	OR	#40
 430  5E2A D3 99        	OUT (#99),A
 431  5E2C C9           	RET
 432  5E2D              ; ****************************************************************************************************
 433  5E2D
 434  5E2D              ; ****************************************************************************************************
 435  5E2D              ; function sets VRAM address for reading
 436  5E2D              ; input HL=address
 437  5E2D              ; modifies AF
 438  5E2D              SETWRT_LOCAL_READ:
 439  5E2D 7D           	LD	A,L
 440  5E2E D3 99        	OUT (#99),A
 441  5E30 7C           	LD	A,H
 442  5E31 E6 3F        	AND #3F
 443  5E33 00              NOP
 444  5E34 D3 99        	OUT (#99),A
 445  5E36 C9           	RET
 446  5E37              ; ****************************************************************************************************
 447  5E37               ENDIF
 448  5E37
 449  5E37               IF (VRAM_CMDS + TILE_CMDS > 0)
 450  5E37              ; ****************************************************************************************************
 451  5E37              ; function copies data from RAM to VRAM
 452  5E37              ; input HL=address in RAM
 453  5E37              ; input B=count
 454  5E37              ; modifies AF, BC, HL
 455  5E37              BBYTECOPY:
 456  5E37 0E 98        	LD C,#98
 457  5E39              BBYTECOPY_NO_C:
 458  5E39 ED A3        	OUTI
 459  5E3B C2 39 5E     	JP	NZ, BBYTECOPY_NO_C
 460  5E3E C9           	RET
 461  5E3F              ; ****************************************************************************************************
 462  5E3F               ENDIF
 463  5E3F
 464  5E3F              ; ****************************************************************************************************
 465  5E3F              ; function multiplies HL by 32
 466  5E3F              HLx32:
 467  5E3F 29           	ADD HL,HL
 468  5E40              ; ****************************************************************************************************
 469  5E40              ; function multiplies HL by 16
 470  5E40              HLx16:
 471  5E40 29           	ADD HL,HL
 472  5E41              ; ****************************************************************************************************
 473  5E41              ; function multiplies HL by 8
 474  5E41              HLx8:
 475  5E41 29          > ADD HL, HL
 475  5E42 29          > ADD HL, HL
 475  5E43 29          > ADD HL, HL
 476  5E44 C9           	RET
 477  5E45              ; ****************************************************************************************************
 478  5E45
 479  5E45              ; ****************************************************************************************************
 480  5E45              ; function gets slot and subslot data for specific page
 481  5E45              ; input A=page (0, 1 or 2)
 482  5E45              ; output B = 0A8H register value
 483  5E45              ; output D = 0 is no subslots, 1 if yes
 484  5E45              ; output C = 0A8H value when page 3 slot equals to requested page slot
 485  5E45              ; output E = subslot value if present
 486  5E45              ; modifies AF, BC, DE, HL
 487  5E45              GET_PAGE_INFO:
 488  5E45 6F               LD L, A
 489  5E46 C6 C1            ADD A, low (EXPTBL)
 490  5E48 32 52 5E         LD (GET_PAGE_INFO_L1+1), A
 491  5E4B DB A8            IN A, (0A8H)
 492  5E4D 47               LD B, A
 493  5E4E E6 3F            AND 03FH
 494  5E50 4F               LD C, A
 495  5E51              GET_PAGE_INFO_L1:
 496  5E51 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 497  5E54 E6 80            AND 080H
 498  5E56 28 1B            JR Z, GET_PAGE_INFO_L2
 499  5E58                  ; expanded
 500  5E58 2D               DEC L
 501  5E59 FA 78 5E         JP M, GET_PAGE_INFO_L3
 502  5E5C 2D               DEC L
 503  5E5D FA 76 5E         JP M, GET_PAGE_INFO_L4
 504  5E60                  ; page 2
 505  5E60 07               RLCA
 506  5E61 07               RLCA
 507  5E62              GET_PAGE_INFO_L5:
 508  5E62 E6 C0            AND 0C0H
 509  5E64 B1               OR C
 510  5E65 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 511  5E67 4F               LD C, A
 512  5E68 3A FF FF         LD A, (0FFFFH)
 513  5E6B 2F               CPL
 514  5E6C 5F               LD E, A
 515  5E6D 16 01            LD D, 1
 516  5E6F 78               LD A, B ; return stack
 517  5E70 D3 A8            OUT (0A8H), A
 518  5E72 C9               RET
 519  5E73              GET_PAGE_INFO_L2:
 520  5E73                  ; not expanded
 521  5E73 16 00            LD D, 0
 522  5E75 C9               RET
 523  5E76              GET_PAGE_INFO_L4:
 524  5E76                  ; page 1
 525  5E76 0F               RRCA
 526  5E77 0F               RRCA
 527  5E78              GET_PAGE_INFO_L3:
 528  5E78                  ; page 0
 529  5E78 0F               RRCA
 530  5E79 0F               RRCA
 531  5E7A 18 E6            JR GET_PAGE_INFO_L5
 532  5E7C              ; ****************************************************************************************************
 533  5E7C
 534  5E7C              ; ****************************************************************************************************
 535  5E7C              ; function returns original slot and subslot info
 536  5E7C              ; input B = 0A8H register value
 537  5E7C              ; input D = 0 is no subslots, 1 if yes
 538  5E7C              ; input C = 0A8H value when page 3 slot equals to requested page slot
 539  5E7C              ; input E = subslot value if present
 540  5E7C              ; modifies AF, disables interrupts
 541  5E7C              RESTORE_PAGE_INFO:
 542  5E7C F3              DI
 543  5E7D 7A              LD A, D
 544  5E7E B7              OR A
 545  5E7F 28 07           JR Z, RESTORE_PAGE_INFO_L1
 546  5E81 79              LD A, C
 547  5E82 D3 A8           OUT (0A8H), A
 548  5E84 7B              LD A, E
 549  5E85 32 FF FF        LD (0FFFFH), A
 550  5E88              RESTORE_PAGE_INFO_L1:
 551  5E88 78              LD A, B
 552  5E89 D3 A8           OUT (0A8H), A
 553  5E8B              NOACTION_DEFUSR: ; just a safe RET for use when DEFUSR table has an empty entry
 554  5E8B C9              RET
 555  5E8C              ; ****************************************************************************************************
 556  5E8C
 557  5E8C              ; *******************************************************************************************************
 558  5E8C              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 559  5E8C              ; INPUT:  A = SLOT ID: EXXXSSPP
 560  5E8C              ; E = EXPANDED FLAG
 561  5E8C              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 562  5E8C              ; PP = PRIMARY SLOT NUMBER
 563  5E8C              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 564  5E8C              ; CHANGES: AF, BC, DE
 565  5E8C
 566  5E8C              LOCAL_ENASLT:
 567  5E8C CD AC 5E         CALL L0353
 568  5E8F FA 99 5E         JP M, L0340
 569  5E92 DB A8            IN A, (0A8H)
 570  5E94 A1               AND C
 571  5E95 B0               OR B
 572  5E96 D3 A8            OUT (0A8H), A
 573  5E98 C9               RET
 574  5E99              L0340:
 575  5E99 E5               PUSH HL
 576  5E9A CD D1 5E         CALL L0378
 577  5E9D 4F               LD C, A
 578  5E9E 06 00            LD B, 0
 579  5EA0 7D               LD A, L
 580  5EA1 A4               AND H
 581  5EA2 B2               OR D
 582  5EA3 21 C5 FC         LD HL, 0FCC5H
 583  5EA6 09               ADD HL, BC
 584  5EA7 77               LD (HL), A
 585  5EA8 E1               POP HL
 586  5EA9 79               LD A, C
 587  5EAA 18 E0            JR LOCAL_ENASLT
 588  5EAC              L0353:
 589  5EAC F3               DI
 590  5EAD F5               PUSH AF
 591  5EAE 7C               LD A, H
 592  5EAF 07               RLCA
 593  5EB0 07               RLCA
 594  5EB1 E6 03            AND 3
 595  5EB3 5F               LD E, A
 596  5EB4 3E C0            LD A, 0C0H
 597  5EB6              L035D:
 598  5EB6 07               RLCA
 599  5EB7 07               RLCA
 600  5EB8 1D               DEC E
 601  5EB9 F2 B6 5E         JP P, L035D
 602  5EBC 5F               LD E, A
 603  5EBD 2F               CPL
 604  5EBE 4F               LD C, A
 605  5EBF F1               POP AF
 606  5EC0 F5               PUSH AF
 607  5EC1 E6 03            AND 3
 608  5EC3 3C               INC A
 609  5EC4 47               LD B, A
 610  5EC5 3E AB            LD A, 0ABH
 611  5EC7              L036E:
 612  5EC7 C6 55            ADD A, 055H
 613  5EC9 10 FC            DJNZ L036E
 614  5ECB 57               LD D, A
 615  5ECC A3               AND E
 616  5ECD 47               LD B, A
 617  5ECE F1               POP AF
 618  5ECF A7               AND A
 619  5ED0 C9               RET
 620  5ED1              L0378:
 621  5ED1 F5               PUSH AF
 622  5ED2 7A               LD A, D
 623  5ED3 E6 C0            AND 0C0H
 624  5ED5 4F               LD C, A
 625  5ED6 F1               POP AF
 626  5ED7 F5               PUSH AF
 627  5ED8 57               LD D, A
 628  5ED9 DB A8            IN A, (0A8H)
 629  5EDB 47               LD B, A
 630  5EDC E6 3F            AND 03FH
 631  5EDE B1               OR C
 632  5EDF D3 A8            OUT (0A8H), A
 633  5EE1 7A               LD A, D
 634  5EE2 0F               RRCA
 635  5EE3 0F               RRCA
 636  5EE4 E6 03            AND 3
 637  5EE6 57               LD D, A
 638  5EE7 3E AB            LD A, 0ABH
 639  5EE9              L0390:
 640  5EE9 C6 55            ADD A, 055H
 641  5EEB 15               DEC D
 642  5EEC F2 E9 5E         JP P, L0390
 643  5EEF A3               AND E
 644  5EF0 57               LD D, A
 645  5EF1 7B               LD A, E
 646  5EF2 2F               CPL
 647  5EF3 67               LD H, A
 648  5EF4 3A FF FF         LD A, (0FFFFH)
 649  5EF7 2F               CPL
 650  5EF8 6F               LD L, A
 651  5EF9 A4               AND H
 652  5EFA B2               OR D
 653  5EFB 32 FF FF         LD (0FFFFH), A
 654  5EFE 78               LD A, B
 655  5EFF D3 A8            OUT (0A8H), A
 656  5F01 F1               POP AF
 657  5F02 E6 03            AND 3
 658  5F04 C9               RET
 659  5F05              ; *******************************************************************************************************
 660  5F05
 661  5F05              ; *******************************************************************************************************
 662  5F05              ; some common code to activate page 0 and place values needed to restore original page on stack
 663  5F05              ; input IY=return address
 664  5F05              ENABLE_PAGE0:
 665  5F05 F3              DI
 666  5F06 AF              XOR A
 667  5F07 CD 45 5E        CALL GET_PAGE_INFO
 668  5F0A C5              PUSH BC
 669  5F0B D5              PUSH DE
 670  5F0C 3A 41 F3        LD A, (RAMAD0)
 671  5F0F 26 00           LD H, 0
 672  5F11 CD 8C 5E        CALL LOCAL_ENASLT
 673  5F14 FD E9        	JP (IY)
 674  5F16              ; *******************************************************************************************************
 675  5F16
 676  5F16              ; General BASIC CALL-instruction handler
 677  5F16              CALLHAND:
 678  5F16 FB              EI
 679  5F17 E5           	PUSH HL
 680  5F18 21 E3 5D     	LD	HL, CMDS ; pointer table based on starting letter
 681  5F1B 3A 89 FD        LD A, (PROCNM)
 682  5F1E D6 41           SUB 'A'
 683  5F20 87              ADD A, A
 684  5F21 16 00           LD D, 0
 685  5F23 5F              LD E, A
 686  5F24 19              ADD HL, DE
 687  5F25 5E              LD E, (HL)
 688  5F26 23              INC HL
 689  5F27 56              LD D, (HL)
 690  5F28 7A              LD A, D
 691  5F29 B3              OR E
 692  5F2A 28 23           JR Z, .CMDNOTRECOGNIZED
 693  5F2C EB              EX DE, HL
 694  5F2D              .CHKCMD:
 695  5F2D 11 89 FD     	LD	DE, PROCNM
 696  5F30              .LOOP:
 697  5F30 1A              LD	A,(DE)
 698  5F31 BE           	CP	(HL)
 699  5F32 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 700  5F34 13           	INC	DE
 701  5F35 23           	INC	HL
 702  5F36 A7           	AND	A
 703  5F37 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 704  5F39 5E           	LD	E,(HL)
 705  5F3A 23           	INC	HL
 706  5F3B 56           	LD	D,(HL)
 707  5F3C E1           	POP	HL		; routine address
 708  5F3D CD 5E 5F     	CALL	GETPREVCHAR
 709  5F40 CD 52 5F     	CALL	.CALLDE		; Call routine
 710  5F43 A7           	AND	A
 711  5F44 C9           	RET
 712  5F45
 713  5F45              .TONEXTCMD:
 714  5F45 0E FF        	LD	C,0FFH
 715  5F47 AF           	XOR	A
 716  5F48 ED B1        	CPIR			; Skip to end of instruction name
 717  5F4A 23           	INC	HL
 718  5F4B 23           	INC	HL		; Skip address
 719  5F4C BE           	CP	(HL)
 720  5F4D 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 721  5F4F              .CMDNOTRECOGNIZED:
 722  5F4F E1           	POP	HL
 723  5F50 37              SCF
 724  5F51 C9           	RET
 725  5F52
 726  5F52              .CALLDE:
 727  5F52 D5           	PUSH	DE
 728  5F53 C9           	RET
 729  5F54
 730  5F54              ;---------------------------
 731  5F54
 732  5F54              ;GETSTRPNT:
 733  5F54              ; OUT:
 734  5F54              ; HL = String Address
 735  5F54              ; B  = Lenght
 736  5F54              ;        LD      HL,(USR)
 737  5F54              ;        LD      B,(HL)
 738  5F54              ;        INC     HL
 739  5F54              ;        LD      E,(HL)
 740  5F54              ;        INC     HL
 741  5F54              ;        LD      D,(HL)
 742  5F54              ;        EX      DE,HL
 743  5F54              ;        RET
 744  5F54
 745  5F54              ;EVALTXTPARAM:
 746  5F54              ;	CALL	CHKCHAR
 747  5F54              ;	DEFB	"("             ; Check for (
 748  5F54              ;	LD	IX,FRMEVL
 749  5F54              ;	CALL	CALBAS		; Evaluate expression
 750  5F54              ;       LD      A,(VALTYP)
 751  5F54              ;        CP      3               ; Text type?
 752  5F54              ;        JP      NZ,TYPE_MISMATCH
 753  5F54              ;        PUSH	HL
 754  5F54              ;        LD	IX,FRESTR         ; Free the temporary string
 755  5F54              ;        CALL	CALBAS
 756  5F54              ;        POP	HL
 757  5F54              ;	CALL	CHKCHAR
 758  5F54              ;	DEFB	")"             ; Check for )
 759  5F54              ;        RET
 760  5F54
 761  5F54
 762  5F54              CHKCHAR:
 763  5F54 CD 5E 5F     	CALL	GETPREVCHAR	; Get previous basic char
 764  5F57 E3           	EX	(SP),HL
 765  5F58 BE           	CP	(HL) 	        ; Check if good char
 766  5F59 20 1D        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 767  5F5B 23           	INC	HL
 768  5F5C E3           	EX	(SP),HL
 769  5F5D 23           	INC	HL		; Get next basic char
 770  5F5E
 771  5F5E              GETPREVCHAR:
 772  5F5E 2B           	DEC HL
 773  5F5F DD 21 66 46  	LD	IX,CHRGTR
 774  5F63 CD 59 01     	CALL CALBAS
 775  5F66 FB              EI
 776  5F67 C9              RET
 777  5F68
 778  5F68
 779  5F68              TYPE_MISMATCH:
 780  5F68 1E 0D            LD E, 13 ; Type mismatch
 781  5F6A 18 0E            JR THROW_ERROR
 782  5F6C              SUBSCRIPT_OUT_OF_RANGE:
 783  5F6C 1E 09            LD E,9 ; subscript out of range
 784  5F6E 18 0A        	JR THROW_ERROR
 785  5F70              OVERFLOW:
 786  5F70 1E 06        	LD E,6
 787  5F72 18 06        	JR THROW_ERROR
 788  5F74              ILLEGAL_FUNCTION:
 789  5F74 1E 05            LD E, 5 ; illegal function call
 790  5F76 18 02            JR THROW_ERROR
 791  5F78              SYNTAX_ERROR:
 792  5F78 1E 02            LD E, 2 ; Syntax error
 793  5F7A              THROW_ERROR:
 794  5F7A DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 795  5F7E C3 59 01     	JP	CALBAS
 796  5F81
 797  5F81              ;---------------------------
 798  5F81
 799  5F81               IF (0 == 1)
 800  5F81 ~            ; *******************************************************************************************************
 801  5F81 ~            ; helper function to get pointer to BASIC array data
 802  5F81 ~            ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
 803  5F81 ~            ; input B=dimensions (1 or 2)
 804  5F81 ~            ; input D=minimal first dimension
 805  5F81 ~            ; input E=minimal second dimension, if applicable
 806  5F81 ~            ; returns BC=pointer to first data element
 807  5F81 ~            ; throws BASIC error if invalid type
 808  5F81 ~            GET_BASIC_ARRAY_DATA_POINTER:
 809  5F81 ~            	PUSH DE
 810  5F81 ~            	PUSH BC
 811  5F81 ~            	PUSH AF
 812  5F81 ~               LD A,1
 813  5F81 ~               LD (SUBFLG),A ; search for arrays only
 814  5F81 ~            	LD IX, PTRGET
 815  5F81 ~            	CALL CALBAS
 816  5F81 ~               XOR A
 817  5F81 ~               LD (SUBFLG),A ; if not reset will cause syntax errors
 818  5F81 ~            	LD A,(VALTYP)
 819  5F81 ~            	POP DE ; required type
 820  5F81 ~            	CP D
 821  5F81 ~            	JP NZ,TYPE_MISMATCH
 822  5F81 ~            	LD A,(BC)
 823  5F81 ~            	INC BC
 824  5F81 ~            	POP DE ; required number of dimensions
 825  5F81 ~            	CP D
 826  5F81 ~            	JP NZ,TYPE_MISMATCH
 827  5F81 ~            	POP DE ; required minimal array dimensions
 828  5F81 ~            	DEC A
 829  5F81 ~            	JR Z,.ONE_DIMENSION
 830  5F81 ~            	; 2-dimension array
 831  5F81 ~            	LD A,(BC)
 832  5F81 ~            	.2 INC BC
 833  5F81 ~            	CP E
 834  5F81 ~            	JP C,SUBSCRIPT_OUT_OF_RANGE
 835  5F81 ~            .ONE_DIMENSION:
 836  5F81 ~            	LD A,(BC)
 837  5F81 ~            	.2 INC BC
 838  5F81 ~            	CP D
 839  5F81 ~            	JP C,SUBSCRIPT_OUT_OF_RANGE
 840  5F81 ~            	RET
 841  5F81 ~            ; *******************************************************************************************************
 842  5F81               ENDIF
 843  5F81
 844  5F81              ; *******************************************************************************************************
 845  5F81              ; function to handle CALL ARTINFO basic extension
 846  5F81              ; returns info about the extension
 847  5F81              ; _ARTINFO ( INT variable version,
 848  5F81              ;			    INT variable build_flags,
 849  5F81              ;			    INT variable free_memory_ptr )
 850  5F81              ; this function is always available and can be used to test if the extension is active
 851  5F81              ARTINFO:
 852  5F81              	; opening (
 853  5F81 CD 54 5F     	CALL CHKCHAR
 854  5F84 28           	DB '('
 855  5F85              	; get address of version variable
 856  5F85 DD 21 A4 5E  	LD IX, PTRGET
 857  5F89 CD 59 01     	CALL CALBAS
 858  5F8C 3A 12 40     	LD A,(VERSION)
 859  5F8F 12              LD (DE),A
 860  5F90 13              INC DE
 861  5F91 3A 13 40        LD A,(VERSION+1)
 862  5F94 12              LD (DE),A
 863  5F95              	; comma
 864  5F95 CD 54 5F     	CALL CHKCHAR
 865  5F98 2C           	DB ','
 866  5F99              	; get address of build flags variable
 867  5F99 DD 21 A4 5E  	LD IX, PTRGET
 868  5F9D CD 59 01     	CALL CALBAS
 869  5FA0 E5              PUSH HL
 870  5FA1 21 FF 1B        LD HL,SOUND_CMDS+2*RAM_CMDS+4*VRAM_CMDS+8*BLIT_CMDS+16*SPRITE_CMDS+32*GENCAL_CMD+64*TILE_CMDS+128*BOX_CMDS+256*ANIM_CMDS+512*COLL_CMD+1024*0+2048*1+4096*DECOMP_CMDS
 871  5FA4 EB              EX DE,HL
 872  5FA5 73              LD (HL),E
 873  5FA6 23              INC HL
 874  5FA7 72              LD (HL),D
 875  5FA8 E1              POP HL
 876  5FA9              	; comma
 877  5FA9 CD 54 5F     	CALL CHKCHAR
 878  5FAC 2C           	DB ','
 879  5FAD              	; get address of free memory variable
 880  5FAD DD 21 A4 5E  	LD IX, PTRGET
 881  5FB1 CD 59 01     	CALL CALBAS
 882  5FB4 3A 10 40     	LD A,(FREEMEMPTR)
 883  5FB7 12              LD (DE),A
 884  5FB8 13              INC DE
 885  5FB9 3A 11 40        LD A,(FREEMEMPTR+1)
 886  5FBC 12              LD (DE),A
 887  5FBD              	; ending )
 888  5FBD CD 54 5F     	CALL CHKCHAR
 889  5FC0 29           	DB ')'
 890  5FC1 C9           	RET
 891  5FC2              ; *******************************************************************************************************
 892  5FC2
 893  5FC2              EXT_END:
 894  5FC2
# file closed: asm\main.asm
