# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		   EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000              COLL_CMD       EQU 1
  14  4000              DECOMP_CMDS    EQU 1
  15  4000              DLOAD_CMD      EQU 1
  16  4000
  17  4000              ; what to compile, provided in sjasmplus command line
  18  4000              ;BASIC_EXTENSION   EQU 1
  19  4000              ;DEFUSR_EXTENSION  EQU 0
  20  4000
  21  4000              CHPUT   EQU    #A2
  22  4000              CALBAS  EQU		#159
  23  4000              ERRHAND EQU    #406F
  24  4000              FRMEVL  EQU    #4C64
  25  4000              FRESTR  EQU		#67D0
  26  4000              ; FRMQNT = formula quantificator
  27  4000              ; input HL=pointer to current program expression
  28  4000              ; output HL=next address
  29  4000              ; output DE=integer datum
  30  4000              FRMQNT	EQU		#542F
  31  4000              ; GETBYT = get byte parameter
  32  4000              ; input HL=pointer to current program expression
  33  4000              ; output HL=next address
  34  4000              ; output A=E=byte read
  35  4000              GETBYT		EQU	#521C
  36  4000              CHRGTR  	   EQU   #4666
  37  4000              PTRGET		EQU 	#5EA4
  38  4000              SUBFLG		EQU	#F6A5
  39  4000              SYNCHR		EQU	#558C
  40  4000              VALTYP  	   EQU   #F663
  41  4000              DAC         EQU   #F7F6
  42  4000              USR     	   EQU   #F7F8
  43  4000              PROCNM		EQU	#FD89
  44  4000              BIOS_FILVRM EQU   #0056
  45  4000              CLIKSW		EQU	#F3DB
  46  4000
  47  4000              RAMAD0	   EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  48  4000              RAMAD1	   EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  49  4000              RAMAD2	   EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  50  4000              RAMAD3	   EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  51  4000              EXPTBL	   EQU   #FCC1
  52  4000              SCRMOD	   EQU   #FCAF ; current screen mode
  53  4000              REG1SAV     EQU   #F3E0 ; VDP(1)
  54  4000              JIFFY	      EQU   #FC9E
  55  4000              GRPPAT	   EQU   #F3CF ; SCREEN 2 sprite generator table address
  56  4000              GRPCGP		EQU	#F3CB ; SCREEN 2 pattern generator table address
  57  4000              GRPATR      EQU   #F3CD ; SCREEN 2 sprite attribute table address
  58  4000              T32PAT	   EQU   #F3C5 ; SCREEN 1 sprite generator table address
  59  4000              T32CGP      EQU   #F3C1 ; SCREEN 1 pattern ganarator table address
  60  4000              T32ATR      EQU   #F3C3 ; SCREEN 1 sprite attribute table address
  61  4000
  62  4000              FCB0        EQU   #F353 ; location of FCB 0
  63  4000              BDOS        EQU   #F37D ; disk functions
  64  4000              NULBUF      EQU   #F862 ; disk buffer of 256 bytes address
  65  4000
  66  4000              ; BASIC error codes
  67  4000              ;01 NEXT without FOR
  68  4000              ;02 Syntax error
  69  4000              ;03 RETURN without GOSUB
  70  4000              ;04 Out of DATA
  71  4000              ;05 Illegal function call
  72  4000              ;06 Overflow
  73  4000              ;07 Out of memory
  74  4000              ;08 Undefined line number
  75  4000              ;09 Subscript out of range
  76  4000              ;10 Redimensioned array
  77  4000              ;11 Division by zero
  78  4000              ;12 Illegal direct
  79  4000              ;13 Type mismatch
  80  4000              ;14 Out of string space
  81  4000              ;15 String too long
  82  4000              ;16 String formula too complex
  83  4000              ;17 Can't CONTINUE
  84  4000              ;18 Undefined user function
  85  4000              ;19 Device I/O error
  86  4000              ;20 Verify error
  87  4000              ;21 No RESUME
  88  4000              ;22 RESUME without error
  89  4000              ;23 Unprintable error
  90  4000              ;24 Missing operand
  91  4000              ;25 Line buffer overflow
  92  4000              ;50 FIELD overflow
  93  4000              ;51 Internal error
  94  4000              ;52 Bad file number
  95  4000              ;53 File not found
  96  4000              ;54 File already open
  97  4000              ;55 Input past end
  98  4000              ;56 Bad file name
  99  4000              ;57 Direct statement in file
 100  4000              ;58 Sequential I/O only
 101  4000              ;59 File not OPEN
 102  4000
 103  4000
 104  4000               ; simulate cartridge with BASIC extension
 105  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
 105  4004 90 60 00 00
 105  4008 00 00 00 00
 105  400C 00 00 00 00
 106  4010
 107  4010              ; this location #4010 stores last location used by basic extension
 108  4010              ; free memory after that point
 109  4010              FREEMEMPTR:
 110  4010 35 61         DW EXT_END
 111  4012
 112  4012              ; this location #4012 stores extension version in DAA format
 113  4012              ; first byte is major version and second minor
 114  4012              VERSION:
 115  4012 00 93         DB #00, #93
 116  4014
 117  4014              ; this location #4014 contains a jump to entry point for DEFUSR approach
 118  4014              ; if excluded it contains 3xRET so that sound player can be at aspecific spot
 119  4014               IF (1 == 1)
 120  4014 C3 14 5F        JP DEFUSR_ENTRY
 121  4017               ELSE
 122  4017 ~               .3 RET
 123  4017               ENDIF
 124  4017
 125  4017              ; binary included AKG player compiled at #4017
 126  4017               IF (SOUND_CMDS == 1)
 127  4017              	INCBIN "bin/AKG.bin"
 128  4CF3              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF3              MAIN_PLAYER_START EQU 04017H
   2+ 4CF3              PLY_AKG_START EQU 04017H
   3+ 4CF3              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 04020H
   4+ 4CF3              PLY_AKG_INITSOUNDEFFECTS EQU 04020H
   5+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04024H
   6+ 4CF3              PLY_AKG_PLAYSOUNDEFFECT EQU 04024H
   7+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04025H
   8+ 4CF3              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04025H
   9+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 0404CH
  10+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 0404CH
  11+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 0405AH
  12+ 4CF3              PLY_AKG_PSES_PLAY EQU 04093H
  13+ 4CF3              PLY_AKG_PSES_READFIRSTBYTE EQU 0409CH
  14+ 4CF3              PLY_AKG_PSES_S_ENDORLOOP EQU 040B4H
  15+ 4CF3              PLY_AKG_PSES_S_LOOP EQU 040BFH
  16+ 4CF3              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C5H
  17+ 4CF3              PLY_AKG_PSES_NOTREACHED EQU 040D8H
  18+ 4CF3              PLY_AKG_PSES_HARDWAREONLY EQU 040DCH
  19+ 4CF3              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E3H
  20+ 4CF3              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F5H
  21+ 4CF3              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FFH
  22+ 4CF3              PLY_AKG_PSES_H_AFTERRETRIG EQU 04109H
  23+ 4CF3              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411DH
  24+ 4CF3              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 04122H
  25+ 4CF3              PLY_AKG_PSES_READHARDWAREPERIOD EQU 0412AH
  26+ 4CF3              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04135H
  27+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 04141H
  28+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04143H
  29+ 4CF3              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04149H
  30+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414DH
  31+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414DH
  32+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414FH
  33+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414FH
  34+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414FH
  35+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 04150H
  36+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 04151H
  37+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04155H
  38+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04155H
  39+ 4CF3              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04155H
  40+ 4CF3              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415DH
  41+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04165H
  42+ 4CF3              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04165H
  43+ 4CF3              PLY_AKG_INIT EQU 04165H
  44+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04165H
  45+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04193H
  46+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A7H
  47+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B9H
  48+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D8H
  49+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E5H
  50+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL EQU 041EBH
  51+ 4CF3              PLY_AKG_INITTABLE0 EQU 041EEH
  52+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EEH
  53+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04208H
  54+ 4CF3              PLY_AKG_INITTABLE0_END EQU 04208H
  55+ 4CF3              PLY_AKG_INITTABLE1 EQU 04208H
  56+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04208H
  57+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 0420CH
  58+ 4CF3              PLY_AKG_INITTABLE1_END EQU 0420CH
  59+ 4CF3              PLY_AKG_INITTABLEORA EQU 0420CH
  60+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 0420CH
  61+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04224H
  62+ 4CF3              PLY_AKG_INITTABLEORA_END EQU 04224H
  63+ 4CF3              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04224H
  64+ 4CF3              PLY_AKG_STOP EQU 04224H
  65+ 4CF3              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04236H
  66+ 4CF3              PLY_AKG_PLAY EQU 04236H
  67+ 4CF3              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423EH
  68+ 4CF3              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04244H
  69+ 4CF3              PLY_AKG_READLINKER EQU 04249H
  70+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04249H
  71+ 4CF3              PLY_AKG_READLINKER_PTLINKER EQU 04249H
  72+ 4CF3              PLY_AKG_READLINKER_NOLOOP EQU 04254H
  73+ 4CF3              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428DH
  74+ 4CF3              PLY_AKG_READLINE EQU 04290H
  75+ 4CF3              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 04290H
  76+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04296H
  77+ 4CF3              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04296H
  78+ 4CF3              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A3H
  79+ 4CF3              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A7H
  80+ 4CF3              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042AAH
  81+ 4CF3              PLY_AKG_SPEEDTRACK_END EQU 042ADH
  82+ 4CF3              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042ADH
  83+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B3H
  84+ 4CF3              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B3H
  85+ 4CF3              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042C0H
  86+ 4CF3              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C4H
  87+ 4CF3              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C7H
  88+ 4CF3              PLY_AKG_EVENTTRACK_END EQU 042CAH
  89+ 4CF3              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042CAH
  90+ 4CF3              PLY_AKG_CHANNEL1_READTRACK EQU 042D6H
  91+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D6H
  92+ 4CF3              PLY_AKG_CHANNEL1_PTTRACK EQU 042D6H
  93+ 4CF3              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042F1H
  94+ 4CF3              PLY_AKG_CHANNEL1_WAIT EQU 042FCH
  95+ 4CF3              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04303H
  96+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04303H
  97+ 4CF3              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04303H
  98+ 4CF3              PLY_AKG_CHANNEL1_NOTE EQU 0430CH
  99+ 4CF3              PLY_AKG_BASENOTEINDEX EQU 0430CH
 100+ 4CF3              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430EH
 101+ 4CF3              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430EH
 102+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431EH
 103+ 4CF3              PLY_AKG_INSTRUMENTSTABLE EQU 0431EH
 104+ 4CF3              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 04330H
 105+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 04340H
 106+ 4CF3              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04368H
 107+ 4CF3              PLY_AKG_CHANNEL1_READCELLEND EQU 0436BH
 108+ 4CF3              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 0436BH
 109+ 4CF3              PLY_AKG_CHANNEL2_READTRACK EQU 04377H
 110+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04377H
 111+ 4CF3              PLY_AKG_CHANNEL2_PTTRACK EQU 04377H
 112+ 4CF3              PLY_AKG_CHANNEL2_SMALLWAIT EQU 04392H
 113+ 4CF3              PLY_AKG_CHANNEL2_WAIT EQU 0439DH
 114+ 4CF3              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A4H
 115+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A4H
 116+ 4CF3              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A4H
 117+ 4CF3              PLY_AKG_CHANNEL2_NOTE EQU 043ADH
 118+ 4CF3              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043B2H
 119+ 4CF3              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043B2H
 120+ 4CF3              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D4H
 121+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E4H
 122+ 4CF3              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 0440CH
 123+ 4CF3              PLY_AKG_CHANNEL2_READCELLEND EQU 0440FH
 124+ 4CF3              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440FH
 125+ 4CF3              PLY_AKG_CHANNEL3_READTRACK EQU 0441BH
 126+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 0441BH
 127+ 4CF3              PLY_AKG_CHANNEL3_PTTRACK EQU 0441BH
 128+ 4CF3              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04436H
 129+ 4CF3              PLY_AKG_CHANNEL3_WAIT EQU 04441H
 130+ 4CF3              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04448H
 131+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04448H
 132+ 4CF3              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04448H
 133+ 4CF3              PLY_AKG_CHANNEL3_NOTE EQU 04451H
 134+ 4CF3              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04456H
 135+ 4CF3              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04456H
 136+ 4CF3              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04478H
 137+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04488H
 138+ 4CF3              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044B0H
 139+ 4CF3              PLY_AKG_CHANNEL3_READCELLEND EQU 044B3H
 140+ 4CF3              PLY_AKG_CURRENTSPEED EQU 044B3H
 141+ 4CF3              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B5H
 142+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B8H
 143+ 4CF3              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B8H
 144+ 4CF3              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044BBH
 145+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BEH
 146+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BEH
 147+ 4CF3              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044CAH
 148+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044D1H
 149+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D4H
 150+ 4CF3              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044DAH
 151+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DDH
 152+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DDH
 153+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044EBH
 154+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044F0H
 155+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044FBH
 156+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FEH
 157+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FEH
 158+ 4CF3              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 04501H
 159+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04504H
 160+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04504H
 161+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450DH
 162+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04517H
 163+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 0451AH
 164+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 0451AH
 165+ 4CF3              PLY_AKG_CHANNEL1_PITCH EQU 0451AH
 166+ 4CF3              PLY_AKG_CHANNEL1_ISPITCH EQU 0451DH
 167+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 04522H
 168+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACK EQU 04522H
 169+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04526H
 170+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04528H
 171+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 0452AH
 172+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 04531H
 173+ 4CF3              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 04532H
 174+ 4CF3              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04535H
 175+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04535H
 176+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 04551H
 177+ 4CF3              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 04551H
 178+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455EH
 179+ 4CF3              PLY_AKG_CHANNEL1_GLIDEOVER EQU 04562H
 180+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 04572H
 181+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 04572H
 182+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04573H
 183+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04574H
 184+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04576H
 185+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04576H
 186+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04576H
 187+ 4CF3              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04577H
 188+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04578H
 189+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 0457AH
 190+ 4CF3              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 0457AH
 191+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 0457AH
 192+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 0457AH
 193+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 0457AH
 194+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457DH
 195+ 4CF3              PLY_AKG_CHANNEL1_PITCH_END EQU 0457FH
 196+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04587H
 197+ 4CF3              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04587H
 198+ 4CF3              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 0458AH
 199+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458DH
 200+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458DH
 201+ 4CF3              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04599H
 202+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 045A0H
 203+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A3H
 204+ 4CF3              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A9H
 205+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045ACH
 206+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045ACH
 207+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045BAH
 208+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BFH
 209+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045CAH
 210+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CDH
 211+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CDH
 212+ 4CF3              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045D0H
 213+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D3H
 214+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D3H
 215+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045DCH
 216+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E6H
 217+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E9H
 218+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E9H
 219+ 4CF3              PLY_AKG_CHANNEL2_PITCH EQU 045E9H
 220+ 4CF3              PLY_AKG_CHANNEL2_ISPITCH EQU 045ECH
 221+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045F1H
 222+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045F1H
 223+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F5H
 224+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F7H
 225+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F9H
 226+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 04600H
 227+ 4CF3              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 04601H
 228+ 4CF3              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04604H
 229+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04604H
 230+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 04620H
 231+ 4CF3              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 04620H
 232+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462DH
 233+ 4CF3              PLY_AKG_CHANNEL2_GLIDEOVER EQU 04631H
 234+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 04641H
 235+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 04641H
 236+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 04642H
 237+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04643H
 238+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04645H
 239+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04645H
 240+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04645H
 241+ 4CF3              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04646H
 242+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04647H
 243+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04649H
 244+ 4CF3              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04649H
 245+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04649H
 246+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04649H
 247+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04649H
 248+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_END EQU 0464CH
 249+ 4CF3              PLY_AKG_CHANNEL2_PITCH_END EQU 0464EH
 250+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04656H
 251+ 4CF3              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04656H
 252+ 4CF3              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04659H
 253+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 0465CH
 254+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 0465CH
 255+ 4CF3              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04668H
 256+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466FH
 257+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 04672H
 258+ 4CF3              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04678H
 259+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 0467BH
 260+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 0467BH
 261+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04689H
 262+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468EH
 263+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04699H
 264+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 0469CH
 265+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 0469CH
 266+ 4CF3              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469FH
 267+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 046A2H
 268+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE EQU 046A2H
 269+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046ABH
 270+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B5H
 271+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B8H
 272+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B8H
 273+ 4CF3              PLY_AKG_CHANNEL3_PITCH EQU 046B8H
 274+ 4CF3              PLY_AKG_CHANNEL3_ISPITCH EQU 046BBH
 275+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046C0H
 276+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046C0H
 277+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C4H
 278+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C6H
 279+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C8H
 280+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CFH
 281+ 4CF3              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046D0H
 282+ 4CF3              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D3H
 283+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D3H
 284+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046EFH
 285+ 4CF3              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046EFH
 286+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046FCH
 287+ 4CF3              PLY_AKG_CHANNEL3_GLIDEOVER EQU 04700H
 288+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 04710H
 289+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 04710H
 290+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 04711H
 291+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 04712H
 292+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04714H
 293+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04714H
 294+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04714H
 295+ 4CF3              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04715H
 296+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04716H
 297+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04718H
 298+ 4CF3              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04718H
 299+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04718H
 300+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04718H
 301+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04718H
 302+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_END EQU 0471BH
 303+ 4CF3              PLY_AKG_CHANNEL3_PITCH_END EQU 0471DH
 304+ 4CF3              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04729H
 305+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04729H
 306+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04729H
 307+ 4CF3              PLY_AKG_CHANNEL1_TRACKNOTE EQU 0472CH
 308+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472EH
 309+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04734H
 310+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04737H
 311+ 4CF3              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04737H
 312+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 0473AH
 313+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04743H
 314+ 4CF3              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 0474BH
 315+ 4CF3              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04758H
 316+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04758H
 317+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04758H
 318+ 4CF3              PLY_AKG_CHANNEL2_TRACKNOTE EQU 0475BH
 319+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475DH
 320+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04763H
 321+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04766H
 322+ 4CF3              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04766H
 323+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04769H
 324+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 04772H
 325+ 4CF3              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 0477AH
 326+ 4CF3              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04788H
 327+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04788H
 328+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04788H
 329+ 4CF3              PLY_AKG_CHANNEL3_TRACKNOTE EQU 0478BH
 330+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478DH
 331+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04793H
 332+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04796H
 333+ 4CF3              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04796H
 334+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04799H
 335+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 047A2H
 336+ 4CF3              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047AAH
 337+ 4CF3              PLY_AKG_SENDPSGREGISTERS EQU 047B9H
 338+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047C1H
 339+ 4CF3              PLY_AKG_PSGREG01_INSTR EQU 047C1H
 340+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047D1H
 341+ 4CF3              PLY_AKG_PSGREG23_INSTR EQU 047D1H
 342+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047E2H
 343+ 4CF3              PLY_AKG_PSGREG45_INSTR EQU 047E2H
 344+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F3H
 345+ 4CF3              PLY_AKG_PSGREG6_8_INSTR EQU 047F3H
 346+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04804H
 347+ 4CF3              PLY_AKG_PSGREG9_10_INSTR EQU 04804H
 348+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04815H
 349+ 4CF3              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04815H
 350+ 4CF3              PLY_AKG_PSGREG13_OLDVALUE EQU 0482AH
 351+ 4CF3              PLY_AKG_RETRIG EQU 0482CH
 352+ 4CF3              PLY_AKG_PSGREG13_INSTR EQU 0482EH
 353+ 4CF3              PLY_AKG_PSGREG13_END EQU 0483DH
 354+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483DH
 355+ 4CF3              PLY_AKG_SAVESP EQU 0483DH
 356+ 4CF3              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 04841H
 357+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTS EQU 04849H
 358+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04856H
 359+ 4CF3              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04856H
 360+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485EH
 361+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 0486BH
 362+ 4CF3              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 0486BH
 363+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTS EQU 04873H
 364+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487EH
 365+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS EQU 0487EH
 366+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488DH
 367+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488DH
 368+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04894H
 369+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A4H
 370+ 4CF3              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A4H
 371+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048ABH
 372+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048ABH
 373+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048AEH
 374+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B7H
 375+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B7H
 376+ 4CF3              PLY_AKG_READINSTRUMENTCELL EQU 048BDH
 377+ 4CF3              PLY_AKG_NOSOFTNOHARD EQU 048CAH
 378+ 4CF3              PLY_AKG_NSNH_NONOISE EQU 048DFH
 379+ 4CF3              PLY_AKG_SOFT EQU 048E2H
 380+ 4CF3              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E9H
 381+ 4CF3              PLY_AKG_S_NOTSIMPLE EQU 048F1H
 382+ 4CF3              PLY_AKG_S_AFTERSIMPLETEST EQU 048F4H
 383+ 4CF3              PLY_AKG_HARDTOSOFT EQU 04901H
 384+ 4CF3              PLY_AKG_HS_JUMPRATIO EQU 0490CH
 385+ 4CF3              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04939H
 386+ 4CF3              PLY_AKG_ENDWITHOUTLOOP EQU 0493BH
 387+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 0493BH
 388+ 4CF3              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 0493BH
 389+ 4CF3              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04943H
 390+ 4CF3              PLY_AKG_SH_JUMPRATIO EQU 04950H
 391+ 4CF3              PLY_AKG_SH_JUMPRATIOEND EQU 04971H
 392+ 4CF3              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 04980H
 393+ 4CF3              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04986H
 394+ 4CF3              PLY_AKG_H_OR_ENDWITHLOOP EQU 049A0H
 395+ 4CF3              PLY_AKG_H_RETRIGEND EQU 049B2H
 396+ 4CF3              PLY_AKG_H_AFTERRETRIG EQU 049B3H
 397+ 4CF3              PLY_AKG_ENDWITHLOOP EQU 049C5H
 398+ 4CF3              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049CCH
 399+ 4CF3              PLY_AKG_S_OR_H_NEXTBYTE EQU 049E2H
 400+ 4CF3              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049F0H
 401+ 4CF3              PLY_AKG_S_OR_H_AFTERPITCH EQU 04A00H
 402+ 4CF3              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0EH
 403+ 4CF3              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1DH
 404+ 4CF3              PLY_AKG_SHOHS_RETRIGEND EQU 04A2CH
 405+ 4CF3              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2DH
 406+ 4CF3              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3FH
 407+ 4CF3              PLY_AKG_EFFECTTABLE EQU 04A4DH
 408+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4DH
 409+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A71H
 410+ 4CF3              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A71H
 411+ 4CF3              PLY_AKG_EFFECT_RESET EQU 04A74H
 412+ 4CF3              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A76H
 413+ 4CF3              PLY_AKG_EFFECT_VOLUME EQU 04A91H
 414+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9DH
 415+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA3H
 416+ 4CF3              PLY_AKG_ARPEGGIOSTABLE EQU 04AA3H
 417+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04ACAH
 418+ 4CF3              PLY_AKG_EFFECT_PITCHTABLE EQU 04AD1H
 419+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD7H
 420+ 4CF3              PLY_AKG_PITCHESTABLE EQU 04AD7H
 421+ 4CF3              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFEH
 422+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B05H
 423+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B16H
 424+ 4CF3              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1DH
 425+ 4CF3              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2DH
 426+ 4CF3              PLY_AKG_EFFECT_PITCHUP EQU 04B42H
 427+ 4CF3              PLY_AKG_EFFECT_PITCHSTOP EQU 04B54H
 428+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B5BH
 429+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B85H
 430+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B85H
 431+ 4CF3              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9EH
 432+ 4CF3              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9EH
 433+ 4CF3              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BB0H
 434+ 4CF3              PLY_AKG_EFFECT_LEGATO EQU 04BC6H
 435+ 4CF3              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BDAH
 436+ 4CF3              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BE2H
 437+ 4CF3              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BEAH
 438+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BF2H
 439+ 4CF3              PLY_AKG_EVENT EQU 04BF2H
 440+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF3H
 441+ 4CF3              PLY_AKG_PERIODTABLE EQU 04BF3H
 442+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF3H
 443+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF3H
 444+ 4CF3              PLY_AKG_PERIODTABLE_END EQU 04CF3H
 445+ 4CF3              PLY_AKG_END EQU 04CF3H
 446+ 4CF3              MAIN_PLAYER_END EQU 04CF3H
 447+ 4CF3              TESTEREND EQU 04CF3H
 448+ 4CF3
# file closed: ./symbol/AKG.sym
 129  4CF3               ENDIF
 130  4CF3
 131  4CF3               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
   1+ 4CF3              ORIG.HTIMI:
   2+ 4CF3 00 00 00 00  	DB 0, 0, 0, 0, 0
   2+ 4CF7 00
   3+ 4CF8               EXPORT ORIG.HTIMI
   4+ 4CF8
   5+ 4CF8              ; *******************************************************************************************************
   6+ 4CF8              ; interrupt handler when page 0 enabled
   7+ 4CF8              ; we are here only if one of the extended basic commands have paged in page 0
   8+ 4CF8              ; which means we arrived from BASIC so page 2 is already good
   9+ 4CF8              VBLANK:
  10+ 4CF8              	EXPORT VBLANK
  11+ 4CF8
  12+ 4CF8 F5               PUSH AF
  13+ 4CF9              	; is VDP originator ?
  14+ 4CF9 DB 99        	IN	A, (099H)
  15+ 4CFB A7           	AND	A
  16+ 4CFC F2 2A 4D     	JP P, .EXIT
  17+ 4CFF
  18+ 4CFF               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  19+ 4CFF C5               PUSH BC
  20+ 4D00 D5               PUSH DE
  21+ 4D01 E5               PUSH HL
  22+ 4D02 08               EX AF, AF'
  23+ 4D03 D9               EXX
  24+ 4D04 F5               PUSH AF
  25+ 4D05 C5               PUSH BC
  26+ 4D06 D5               PUSH DE
  27+ 4D07 E5               PUSH HL
  28+ 4D08 DD E5            PUSH IX
  29+ 4D0A FD E5            PUSH IY
  30+ 4D0C
  31+ 4D0C               IF (SPRITE_CMDS == 1)
  32+ 4D0C CD 64 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  33+ 4D0F               ENDIF
  34+ 4D0F
  35+ 4D0F               IF (SOUND_CMDS == 1)
  36+ 4D0F 3A A8 55     	LD A, (SOUND_ENABLED)
  37+ 4D12 B7           	OR A
  38+ 4D13 C4 36 42     	CALL NZ,PLY_AKG_PLAY
  39+ 4D16               ENDIF
  40+ 4D16
  41+ 4D16                  ; increase JIFFY
  42+ 4D16 2A 9E FC         LD HL,(JIFFY)
  43+ 4D19 23               INC HL
  44+ 4D1A 22 9E FC         LD (JIFFY),HL
  45+ 4D1D
  46+ 4D1D FD E1            POP IY
  47+ 4D1F DD E1            POP IX
  48+ 4D21 E1               POP HL
  49+ 4D22 D1               POP DE
  50+ 4D23 C1               POP BC
  51+ 4D24 F1               POP AF
  52+ 4D25 08               EX AF, AF'
  53+ 4D26 D9               EXX
  54+ 4D27 E1               POP HL
  55+ 4D28 D1               POP DE
  56+ 4D29 C1               POP BC
  57+ 4D2A               ENDIF
  58+ 4D2A
  59+ 4D2A              .EXIT:
  60+ 4D2A F1           	POP AF
  61+ 4D2B FB           	EI
  62+ 4D2C ED 4D        	RETI
  63+ 4D2E              ; *******************************************************************************************************
  64+ 4D2E
  65+ 4D2E              ; *******************************************************************************************************
  66+ 4D2E              ; H.TIMI function
  67+ 4D2E              ; we can end up here from anywhere so page in both page 0 and 2
  68+ 4D2E              MBGE_HTIMI:
  69+ 4D2E               EXPORT MBGE_HTIMI
  70+ 4D2E
  71+ 4D2E               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  72+ 4D2E
  73+ 4D2E F5           	PUSH AF
  74+ 4D2F
  75+ 4D2F              	; enable page 2
  76+ 4D2F 3E 02            LD A, 2
  77+ 4D31 CD BF 5F         CALL GET_PAGE_INFO
  78+ 4D34 C5               PUSH BC
  79+ 4D35 D5               PUSH DE
  80+ 4D36 3A 43 F3         LD A, (RAMAD2)
  81+ 4D39 26 80            LD H, 080H
  82+ 4D3B CD 06 60         CALL LOCAL_ENASLT
  83+ 4D3E              	; enable page 0
  84+ 4D3E AF               XOR A
  85+ 4D3F CD BF 5F         CALL GET_PAGE_INFO
  86+ 4D42 C5               PUSH BC
  87+ 4D43 D5               PUSH DE
  88+ 4D44 3A 41 F3         LD A, (RAMAD0)
  89+ 4D47 26 00            LD H, 0
  90+ 4D49 CD 06 60         CALL LOCAL_ENASLT
  91+ 4D4C
  92+ 4D4C               IF (SPRITE_CMDS == 1)
  93+ 4D4C CD 64 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  94+ 4D4F               ENDIF
  95+ 4D4F
  96+ 4D4F               IF (SOUND_CMDS == 1)
  97+ 4D4F 3A A8 55     	LD A, (SOUND_ENABLED)
  98+ 4D52 B7           	OR A
  99+ 4D53 C4 36 42     	CALL NZ,PLY_AKG_PLAY
 100+ 4D56               ENDIF
 101+ 4D56
 102+ 4D56              	; restore page 0
 103+ 4D56 D1               POP DE
 104+ 4D57 C1               POP BC
 105+ 4D58 CD F6 5F         CALL RESTORE_PAGE_INFO
 106+ 4D5B              	; restore page 2
 107+ 4D5B D1               POP DE
 108+ 4D5C C1               POP BC
 109+ 4D5D CD F6 5F         CALL RESTORE_PAGE_INFO
 110+ 4D60
 111+ 4D60 F1           	POP AF
 112+ 4D61               ENDIF
 113+ 4D61 C3 F3 4C     	JP ORIG.HTIMI
 114+ 4D64              ; *******************************************************************************************************
 115+ 4D64
 116+ 4D64              ; *******************************************************************************************************
 117+ 4D64              ; function checks if the sprite system is initialized and what screen mode we are running
 118+ 4D64              ; also checks if some VRAM modifying command is running
 119+ 4D64              ; when that checks out calls sprite updates and animation processing
 120+ 4D64              ; if in an unsupported mode disables sprite handling
 121+ 4D64              PROCESS_SPRITES_AND_ANIMATIONS:
 122+ 4D64              	; check if initialized
 123+ 4D64 3A 86 4D     	LD A, (SPRATR_INIT_STATUS)
 124+ 4D67 B7           	OR A
 125+ 4D68 C8           	RET Z
 126+ 4D69              	; check screen mode
 127+ 4D69 3A AF FC     	LD A, (SCRMOD)
 128+ 4D6C 3D           	DEC A
 129+ 4D6D 28 08        	JR Z, .L0 ; screen 1
 130+ 4D6F 3D           	DEC A
 131+ 4D70 28 05            JR Z, .L0 ; screen 2
 132+ 4D72              	; unsupported screen mode, disable
 133+ 4D72 AF               XOR A
 134+ 4D73 32 86 4D         LD (SPRATR_INIT_STATUS),A
 135+ 4D76 C9               RET
 136+ 4D77              .L0:
 137+ 4D77                  ; check if anyone else is working with VRAM
 138+ 4D77 3A 52 5F         LD A,(VRAM_UPDATE_IN_PROGRESS)
 139+ 4D7A B7               OR A
 140+ 4D7B C0               RET NZ
 141+ 4D7C
 142+ 4D7C CD 9C 4D         CALL SPRATR_UPDATE
 143+ 4D7F
 144+ 4D7F               IF (ANIM_CMDS == 1)
 145+ 4D7F CD 0E 53         CALL PROCESS_ANIMATIONS
 146+ 4D82 CD 6B 54         CALL PROCESS_AUTOSGAMS
 147+ 4D85               ENDIF
 148+ 4D85 C9               RET
 149+ 4D86              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
 132  4D86
 133  4D86               IF (SPRITE_CMDS == 1)
 134  4D86               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4D86              ; commands and variables related to sprites
   2+ 4D86
   3+ 4D86              SPRATR_INIT_STATUS:
   4+ 4D86 00            DB 0
   5+ 4D87              SPRATR_UPDATE_FLAG:
   6+ 4D87 00 00         DW 0
   7+ 4D89              SPRATR_DATA:
   8+ 4D89 00 00         DW 0
   9+ 4D8B              SPRFLICKER_ENABLED:
  10+ 4D8B 00            DB 0
  11+ 4D8C              ; to support sprite flicker
  12+ 4D8C              FLICKER:
  13+ 4D8C 00            DB 0
  14+ 4D8D              NUM_SPRITES_HANDLED:
  15+ 4D8D 20            DB 32
  16+ 4D8E
  17+ 4D8E              ; to temporarily store stack pointer
  18+ 4D8E              TMPSP:
  19+ 4D8E 00 00         DW 0
  20+ 4D90
  21+ 4D90              ; *******************************************************************************************************
  22+ 4D90              ; helper function gets pointer to n-th entry in sprite attributes
  23+ 4D90              ; changes HL,DE
  24+ 4D90              GETnthSPRATTR:
  25+ 4D90 26 00            LD H,0
  26+ 4D92 6F               LD L,A
  27+ 4D93 CD BB 5F         CALL HLx8
  28+ 4D96 ED 5B 89 4D      LD DE,(SPRATR_DATA)
  29+ 4D9A 19               ADD HL,DE
  30+ 4D9B C9               RET
  31+ 4D9C              ; *******************************************************************************************************
  32+ 4D9C
  33+ 4D9C              ; *******************************************************************************************************
  34+ 4D9C              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  35+ 4D9C              ; struct {
  36+ 4D9C              ; DW y
  37+ 4D9C              ; DW x
  38+ 4D9C              ; DW pattern (0-63)
  39+ 4D9C              ; DW color
  40+ 4D9C              ; } [32]
  41+ 4D9C              ; will hide sprites whose location is outside of visible area
  42+ 4D9C              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  43+ 4D9C              ; modifies AF, AF', BC, DE, HL, IX
  44+ 4D9C              SPRATR_UPDATE:
  45+ 4D9C              	; check if update requested
  46+ 4D9C 2A 87 4D     	LD HL, (SPRATR_UPDATE_FLAG)
  47+ 4D9F 7E           	LD A, (HL)
  48+ 4DA0 B7           	OR A
  49+ 4DA1 C8           	RET Z
  50+ 4DA2
  51+ 4DA2 DD 21 8D 4D  	LD IX,NUM_SPRITES_HANDLED
  52+ 4DA6 DD 46 00     	LD B, (IX) ; sprite number
  53+ 4DA9 0E 98        	LD C, #98 ; register for vdp data output
  54+ 4DAB              	; set VDP address
  55+ 4DAB 3A AF FC         LD A,(SCRMOD)
  56+ 4DAE 3D               DEC A
  57+ 4DAF 20 05            JR NZ,.L4
  58+ 4DB1 2A C3 F3         LD HL, (T32ATR)
  59+ 4DB4 18 03            JR .L5
  60+ 4DB6              .L4:
  61+ 4DB6 2A CD F3         LD HL, (GRPATR)
  62+ 4DB9              .L5:
  63+ 4DB9 3A 8B 4D     	LD A, (SPRFLICKER_ENABLED)
  64+ 4DBC B7           	OR A
  65+ 4DBD 28 03        	JR Z, .L3
  66+ 4DBF 3A 8C 4D     	LD A, (FLICKER)
  67+ 4DC2              .L3:
  68+ 4DC2 5F           	LD E, A
  69+ 4DC3 08           	EX AF, AF'
  70+ 4DC4 7B           	LD A, E
  71+ 4DC5 87           	ADD A, A
  72+ 4DC6 87           	ADD A, A
  73+ 4DC7 16 00        	LD D, 0
  74+ 4DC9 5F           	LD E, A
  75+ 4DCA 19           	ADD HL, DE
  76+ 4DCB CD 9C 5F     	CALL SETWRT_LOCAL_WRITE
  77+ 4DCE ED 73 8E 4D  	LD (TMPSP), SP
  78+ 4DD2 ED 7B 89 4D  	LD SP, (SPRATR_DATA)
  79+ 4DD6
  80+ 4DD6              .LOOP:
  81+ 4DD6 E1           	POP HL
  82+ 4DD7 24           	INC H
  83+ 4DD8 28 0D        	JR Z, .L1 ; negative number between -256 and -1
  84+ 4DDA 25           	DEC H
  85+ 4DDB 20 15        	JR NZ, .OUT3 ; sprite vertically can't be visible
  86+ 4DDD 7D           	LD A, L
  87+ 4DDE FE C0        	CP 192
  88+ 4DE0 30 10        	JR NC, .OUT3
  89+ 4DE2 3D           	DEC A ; due to VDP rule that top of screen is -1
  90+ 4DE3 57           	LD D, A
  91+ 4DE4 C3 0B 4E     	JP .X
  92+ 4DE7              .L1:
  93+ 4DE7 7D           	LD A, L
  94+ 4DE8 C6 10        	ADD 16
  95+ 4DEA FA F2 4D     	JP M, .OUT3 ; below -16
  96+ 4DED 2D           	DEC L ; due to VDP rule that top of screen is -1
  97+ 4DEE 55           	LD D, L
  98+ 4DEF C3 0B 4E     	JP .X
  99+ 4DF2              .OUT3:
 100+ 4DF2 E1           	POP HL ; skip x value
 101+ 4DF3              .OUT2:
 102+ 4DF3 E1           	POP HL ; skip pattern
 103+ 4DF4 E1           	POP HL ; skip color
 104+ 4DF5 3E D1        	LD A, #D1
 105+ 4DF7 ED 79        	OUT (C), A ; sprite hidden
 106+ 4DF9 00          > NOP
 106+ 4DFA 00          > NOP
 106+ 4DFB 00          > NOP
 107+ 4DFC ED 79        	OUT (C), A ; value unimportant
 108+ 4DFE 00          > NOP
 108+ 4DFF 00          > NOP
 108+ 4E00 00          > NOP
 109+ 4E01 ED 79        	OUT (C), A ; value unimportant
 110+ 4E03 00          > NOP
 110+ 4E04 00          > NOP
 110+ 4E05 00          > NOP
 111+ 4E06 ED 79        	OUT (C), A ; value unimportant
 112+ 4E08 C3 36 4E     	JP .NEXT
 113+ 4E0B              .X:
 114+ 4E0B E1           	POP HL
 115+ 4E0C 24           	INC H
 116+ 4E0D 28 08        	JR Z, .L2
 117+ 4E0F 25           	DEC H
 118+ 4E10 20 E1        	JR NZ, .OUT2
 119+ 4E12 1E 00        	LD E, 0 ; EC bit
 120+ 4E14 C3 20 4E     	JP .XY
 121+ 4E17              .L2:
 122+ 4E17 7D           	LD A, L
 123+ 4E18 C6 20        	ADD 32
 124+ 4E1A FA F3 4D     	JP M, .OUT2
 125+ 4E1D 6F           	LD L, A
 126+ 4E1E 1E 80        	LD E, #80
 127+ 4E20              .XY:
 128+ 4E20 ED 51        	OUT (C), D
 129+ 4E22 3A E0 F3     	LD A, (REG1SAV)
 130+ 4E25 E6 02        	AND 2
 131+ 4E27 ED 69        	OUT (C), L
 132+ 4E29 E1           	POP HL ; pattern
 133+ 4E2A 7D           	LD A, L
 134+ 4E2B 28 02        	JR Z, .SMALLSPRITES
 135+ 4E2D 87           	ADD A, A
 136+ 4E2E 87           	ADD A, A ; needs to go at 4x
 137+ 4E2F              .SMALLSPRITES:
 138+ 4E2F D3 98        	OUT (#98), A
 139+ 4E31 E1           	POP HL ; color
 140+ 4E32 7D           	LD A, L
 141+ 4E33 B3           	OR E
 142+ 4E34 D3 98        	OUT (#98), A
 143+ 4E36              .NEXT:
 144+ 4E36 08           	EX AF, AF'
 145+ 4E37 3C           	INC A ; increase current sprite
 146+ 4E38 DD BE 00     	CP (IX) ; compare to maximum handled
 147+ 4E3B C2 5B 4E     	JP NZ, .NEXT2 ; continue if not over
 148+ 4E3E AF           	XOR A ; back to zero
 149+ 4E3F 08           	EX AF, AF'
 150+ 4E40 3A AF FC         LD A,(SCRMOD)
 151+ 4E43 3D               DEC A
 152+ 4E44 20 05            JR NZ,.L6
 153+ 4E46 2A C3 F3         LD HL, (T32ATR)
 154+ 4E49 18 03            JR .L7
 155+ 4E4B              .L6:
 156+ 4E4B 2A CD F3         LD HL, (GRPATR)
 157+ 4E4E              .L7:
 158+ 4E4E              	; CALL SETWRT_LOCAL not allowed as SP modified
 159+ 4E4E 7D           	LD	A, L
 160+ 4E4F D3 99        	OUT	(099H), A
 161+ 4E51 7C           	LD	A, H
 162+ 4E52 E6 3F        	AND	03FH
 163+ 4E54 F6 40        	OR	040H
 164+ 4E56 D3 99        	OUT	(099H), A
 165+ 4E58 C3 5C 4E     	JP .NEXT3
 166+ 4E5B              .NEXT2:
 167+ 4E5B 08           	EX AF, AF'
 168+ 4E5C              .NEXT3:
 169+ 4E5C 05           	DEC B
 170+ 4E5D C2 D6 4D     	JP NZ, .LOOP
 171+ 4E60 08           	EX AF, AF'
 172+ 4E61 3C           	INC A ; increase flicker to start at the next one on next vblank
 173+ 4E62 DD BE 00     	CP (IX)
 174+ 4E65 20 01        	JR NZ,.L8
 175+ 4E67 AF           	XOR A
 176+ 4E68              .L8:
 177+ 4E68 32 8C 4D     	LD (FLICKER), A
 178+ 4E6B
 179+ 4E6B ED 7B 8E 4D  	LD SP, (TMPSP)
 180+ 4E6F 2A 87 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 181+ 4E72 36 00        	LD (HL), 0 ; zero out update flag
 182+ 4E74 C9           	RET
 183+ 4E75              ; *******************************************************************************************************
 184+ 4E75
 185+ 4E75               IF (0 == 1)
 186+ 4E75 ~            ; *******************************************************************************************************
 187+ 4E75 ~            ; function to handle CALL SPRENABLE basic extension
 188+ 4E75 ~            ; initializes sprites handler
 189+ 4E75 ~            ; _SPRENABLE ( INT[3][31] variable sprites_attributes,
 190+ 4E75 ~            ;			   INT variable update_variable,
 191+ 4E75 ~            ;			   BYTE sprite_flicker_enabled,
 192+ 4E75 ~            ;			   BYTE num_sprites_handled )
 193+ 4E75 ~            ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA, SPRFLICKER_ENABLED and NUM_SPRITES_HANDLED
 194+ 4E75 ~            SPRENABLE:
 195+ 4E75 ~            	; opening (
 196+ 4E75 ~            	CALL CHKCHAR
 197+ 4E75 ~            	DB '('
 198+ 4E75 ~            	; get address of sprite attribute table DIM SA%(3,31)
 199+ 4E75 ~            	LD A,2
 200+ 4E75 ~            	LD B,2
 201+ 4E75 ~            	LD DE,#0420
 202+ 4E75 ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
 203+ 4E75 ~            	LD (SPRATR_DATA), BC
 204+ 4E75 ~            	; comma
 205+ 4E75 ~            	CALL CHKCHAR
 206+ 4E75 ~            	DB ','
 207+ 4E75 ~            	; get address of sprite update flag
 208+ 4E75 ~            	LD IX, PTRGET
 209+ 4E75 ~            	CALL CALBAS
 210+ 4E75 ~            	LD (SPRATR_UPDATE_FLAG), DE
 211+ 4E75 ~            	; comma
 212+ 4E75 ~            	CALL CHKCHAR
 213+ 4E75 ~            	DB ','
 214+ 4E75 ~            	; get flicker enabled flag
 215+ 4E75 ~            	LD IX, GETBYT
 216+ 4E75 ~            	CALL CALBAS
 217+ 4E75 ~            	LD (SPRFLICKER_ENABLED), A
 218+ 4E75 ~            	; comma
 219+ 4E75 ~            	CALL CHKCHAR
 220+ 4E75 ~            	DB ','
 221+ 4E75 ~            	; get number of handled sprites
 222+ 4E75 ~            	LD IX, GETBYT
 223+ 4E75 ~            	CALL CALBAS
 224+ 4E75 ~            	LD (NUM_SPRITES_HANDLED),A
 225+ 4E75 ~            	; ending )
 226+ 4E75 ~            	CALL CHKCHAR
 227+ 4E75 ~            	DB ')'
 228+ 4E75 ~            .L0:
 229+ 4E75 ~            	LD A, 1
 230+ 4E75 ~            	LD (SPRATR_INIT_STATUS), A
 231+ 4E75 ~            	RET
 232+ 4E75 ~            ; *******************************************************************************************************
 233+ 4E75               ENDIF
 234+ 4E75
 235+ 4E75               IF (1 == 1)
 236+ 4E75              ; same as SPRENABLE but for DEFUSR approach
 237+ 4E75              ; input IX=pointer to input array, real data from +2
 238+ 4E75              ; +2 = pointer to sprite attributes array data
 239+ 4E75              ; +4 = pointer to sprite update variable
 240+ 4E75              ; +6 = flicker flag
 241+ 4E75              ; +8 = number of sprites to handle
 242+ 4E75              SPRENABLE_DEFUSR:
 243+ 4E75 DD 6E 02     	LD L,(IX+2)
 244+ 4E78 DD 66 03     	LD H,(IX+3)
 245+ 4E7B 22 89 4D     	LD (SPRATR_DATA),HL
 246+ 4E7E DD 6E 04     	LD L,(IX+4)
 247+ 4E81 DD 66 05     	LD H,(IX+5)
 248+ 4E84 22 87 4D     	LD (SPRATR_UPDATE_FLAG),HL
 249+ 4E87 DD 7E 06     	LD A,(IX+6)
 250+ 4E8A 32 8B 4D     	LD (SPRFLICKER_ENABLED),A
 251+ 4E8D DD 7E 08     	LD A,(IX+8)
 252+ 4E90 32 8D 4D     	LD (NUM_SPRITES_HANDLED),A
 253+ 4E93 3E 01        	LD A, 1
 254+ 4E95 32 86 4D     	LD (SPRATR_INIT_STATUS), A
 255+ 4E98 AF           	XOR A ; success
 256+ 4E99 C9           	RET
 257+ 4E9A               ENDIF
 258+ 4E9A
 259+ 4E9A               IF (1 + 0 > 0)
 260+ 4E9A              ; *******************************************************************************************************
 261+ 4E9A              ; function to handle CALL SPRDISABLE basic extension
 262+ 4E9A              ; disables sprites handling
 263+ 4E9A              ; _SPRDISABLE
 264+ 4E9A              ; resets variable SPRATR_INIT_STATUS
 265+ 4E9A              SPRDISABLE:
 266+ 4E9A              SPRDISABLE_DEFUSR:
 267+ 4E9A AF           	XOR A
 268+ 4E9B 32 86 4D     	LD (SPRATR_INIT_STATUS), A
 269+ 4E9E C9           	RET
 270+ 4E9F              ; *******************************************************************************************************
 271+ 4E9F               ENDIF
 272+ 4E9F
 273+ 4E9F              ; *******************************************************************************************************
 274+ 4E9F              ; function to handle CALL SPRSET basic extension
 275+ 4E9F              ; sets position, and optionally pattern and color of sprite
 276+ 4E9F              ; _SPRSET ( BYTE sprite_num , valid 0-31
 277+ 4E9F              ;			INT x,
 278+ 4E9F              ;			INT y,
 279+ 4E9F              ;			INT pattern, valid 0-63, otherwise ignored
 280+ 4E9F              ;			INT color, valid 0-15, otherwise ignored
 281+ 4E9F              ;SPRSET:
 282+ 4E9F              ;	LD A, (SPRATR_INIT_STATUS)
 283+ 4E9F              ;	OR A
 284+ 4E9F              ;	JR NZ, .L1
 285+ 4E9F              ;	LD E, 5 ; illegal function call
 286+ 4E9F              ;	JP THROW_ERROR
 287+ 4E9F              ;.L1:
 288+ 4E9F              ;	; opening (
 289+ 4E9F              ;	CALL CHKCHAR
 290+ 4E9F              ;	DB '('
 291+ 4E9F              ;	; get sprite number
 292+ 4E9F              ;	LD IX, GETBYT
 293+ 4E9F              ;	CALL CALBAS
 294+ 4E9F              ;	PUSH AF
 295+ 4E9F              ;	; comma
 296+ 4E9F              ;	CALL CHKCHAR
 297+ 4E9F              ;	DB ','
 298+ 4E9F              ;	; get x
 299+ 4E9F              ;	LD IX, FRMQNT
 300+ 4E9F              ;	CALL CALBAS
 301+ 4E9F              ;	PUSH DE
 302+ 4E9F              ;	; comma
 303+ 4E9F              ;	CALL CHKCHAR
 304+ 4E9F              ;	DB ','
 305+ 4E9F              ;	; get y
 306+ 4E9F              ;	LD IX, FRMQNT
 307+ 4E9F              ;	CALL CALBAS
 308+ 4E9F              ;	PUSH DE
 309+ 4E9F              ;	; comma
 310+ 4E9F              ;	CALL CHKCHAR
 311+ 4E9F              ;	DB ','
 312+ 4E9F              ;	; get pattern
 313+ 4E9F              ;	LD IX, FRMQNT
 314+ 4E9F              ;	CALL CALBAS
 315+ 4E9F              ;	PUSH DE
 316+ 4E9F              ;	; comma
 317+ 4E9F              ;	CALL CHKCHAR
 318+ 4E9F              ;	DB ','
 319+ 4E9F              ;	; get color
 320+ 4E9F              ;	LD IX, FRMQNT
 321+ 4E9F              ;	CALL CALBAS
 322+ 4E9F              ;	PUSH DE
 323+ 4E9F              ;	; ending )
 324+ 4E9F              ;	CALL CHKCHAR
 325+ 4E9F              ;	DB ')'
 326+ 4E9F              ;
 327+ 4E9F              ;   ; save position in BASIC text
 328+ 4E9F              ;	PUSH HL
 329+ 4E9F              ;	POP IX
 330+ 4E9F              ;
 331+ 4E9F              ;	POP BC ; color
 332+ 4E9F              ;	POP DE ; pattern
 333+ 4E9F              ;	EXX
 334+ 4E9F              ;	POP BC ; y
 335+ 4E9F              ;	POP DE ; x
 336+ 4E9F              ;	POP AF ; sprite number
 337+ 4E9F              ;	CP 32
 338+ 4E9F              ;	JR C, .L2
 339+ 4E9F              ;	LD E, 5 ; illegal function call
 340+ 4E9F              ;	JP THROW_ERROR
 341+ 4E9F              ;.L2:
 342+ 4E9F              ;	; find location in sprite attributes table
 343+ 4E9F              ;	PUSH DE
 344+ 4E9F              ;	CALL GETnthSPRATTR
 345+ 4E9F              ;	POP DE
 346+ 4E9F              ;	DI
 347+ 4E9F              ;	; set y
 348+ 4E9F              ;	LD (HL), C
 349+ 4E9F              ;	INC HL
 350+ 4E9F              ;	LD (HL), B
 351+ 4E9F              ;	INC HL
 352+ 4E9F              ;	; set x
 353+ 4E9F              ;	LD (HL), E
 354+ 4E9F              ;	INC HL
 355+ 4E9F              ;	LD (HL), D
 356+ 4E9F              ;	INC HL
 357+ 4E9F              ;	PUSH HL
 358+ 4E9F              ;	EXX
 359+ 4E9F              ;	POP HL
 360+ 4E9F              ;	; check if 0<=pattern<64
 361+ 4E9F              ;	LD A, D
 362+ 4E9F              ;	OR A
 363+ 4E9F              ;	JR NZ, .L3
 364+ 4E9F              ;	LD A, E
 365+ 4E9F              ;	CP 64
 366+ 4E9F              ;	JR NC, .L3
 367+ 4E9F              ;	; set pattern
 368+ 4E9F              ;	;ADD A, A
 369+ 4E9F              ;	;ADD A, A
 370+ 4E9F              ;	;ADD A, A
 371+ 4E9F              ;	LD (HL), A
 372+ 4E9F              ;	INC HL
 373+ 4E9F              ;	LD (HL), D
 374+ 4E9F              ;	INC HL
 375+ 4E9F              ;	JR .L4
 376+ 4E9F              ;.L3:
 377+ 4E9F              ;	; skip pattern
 378+ 4E9F              ;	.2 INC HL
 379+ 4E9F              ;.L4:
 380+ 4E9F              ;	; check if 0<=color<16
 381+ 4E9F              ;	LD A, B
 382+ 4E9F              ;	OR A
 383+ 4E9F              ;	JR NZ, .L5
 384+ 4E9F              ;	LD A, C
 385+ 4E9F              ;	CP 16
 386+ 4E9F              ;	JR NC, .L5
 387+ 4E9F              ;	; set color
 388+ 4E9F              ;	LD (HL), C
 389+ 4E9F              ;	INC HL
 390+ 4E9F              ;	LD (HL), B
 391+ 4E9F              ;
 392+ 4E9F              ;.L5:
 393+ 4E9F              ;	EI
 394+ 4E9F              ;	PUSH IX
 395+ 4E9F              ;	POP HL
 396+ 4E9F              ;	RET
 397+ 4E9F              ; *******************************************************************************************************
 398+ 4E9F
 399+ 4E9F              ; *******************************************************************************************************
 400+ 4E9F              ; function sets sprite location based on initial coordinates and offset provided
 401+ 4E9F              ; input A=sprite number in SPRATR_DATA , 0-31
 402+ 4E9F              ; input DE=initial x
 403+ 4E9F              ; input BC=initial y
 404+ 4E9F              ; input IY=location where delta y,x are located
 405+ 4E9F              ; modifies AF, HL, IX
 406+ 4E9F              SPRSET_DELTA_POS:
 407+ 4E9F D5           	PUSH DE
 408+ 4EA0 CD 90 4D     	CALL GETnthSPRATTR
 409+ 4EA3 E5           	PUSH HL
 410+ 4EA4 DD E1        	POP IX
 411+ 4EA6 D1           	POP DE
 412+ 4EA7              	; IX=sprite's y location
 413+ 4EA7 FD 6E 00     	LD L, (IY)
 414+ 4EAA FD 66 01     	LD H, (IY+1)
 415+ 4EAD 09           	ADD HL, BC
 416+ 4EAE DD 75 00     	LD (IX), L
 417+ 4EB1 DD 74 01     	LD (IX+1), H
 418+ 4EB4 FD 6E 02     	LD L, (IY+2)
 419+ 4EB7 FD 66 03     	LD H, (IY+3)
 420+ 4EBA 19           	ADD HL, DE
 421+ 4EBB DD 75 02     	LD (IX+2), L
 422+ 4EBE DD 74 03     	LD (IX+3), H
 423+ 4EC1 C9           	RET
 424+ 4EC2              ; *******************************************************************************************************
 425+ 4EC2
 426+ 4EC2              ; *******************************************************************************************************
 427+ 4EC2              ; helper function to set new locations for a set of sprites
 428+ 4EC2              ; input B=number of sprites
 429+ 4EC2              ; HL=pointer to list of sprites and offsets
 430+ 4EC2              SPR_UPDATE_LOC:
 431+ 4EC2 3E 01        	LD A,1
 432+ 4EC4 32 52 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 433+ 4EC7 7E           	LD A, (HL)
 434+ 4EC8 23           	INC HL
 435+ 4EC9 23           	INC HL
 436+ 4ECA E5           	PUSH HL
 437+ 4ECB FD E1        	POP IY
 438+ 4ECD D9           	EXX
 439+ 4ECE CD 9F 4E     	CALL SPRSET_DELTA_POS
 440+ 4ED1 D9           	EXX
 441+ 4ED2 23          > INC HL
 441+ 4ED3 23          > INC HL
 441+ 4ED4 23          > INC HL
 441+ 4ED5 23          > INC HL
 442+ 4ED6 10 EA        	DJNZ SPR_UPDATE_LOC
 443+ 4ED8 AF           	XOR A
 444+ 4ED9 32 52 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 445+ 4EDC C9           	RET
 446+ 4EDD              ; *******************************************************************************************************
 447+ 4EDD
 448+ 4EDD               IF (0 == 1)
 449+ 4EDD ~            ; *******************************************************************************************************
 450+ 4EDD ~            ; function to handle CALL SPRGRPMOV basic extension
 451+ 4EDD ~            ; sets position of a group of sprites described with
 452+ 4EDD ~            ; { int sprite_num, int delta_y, int delta_x } [count]
 453+ 4EDD ~            ; _SPRGRPMOV ( INT x,
 454+ 4EDD ~            ;			   INT y,
 455+ 4EDD ~            ;			   BYTE count,
 456+ 4EDD ~            ;			   INT[2][count] data_ptr
 457+ 4EDD ~            SPRGRPMOV:
 458+ 4EDD ~            	LD A, (SPRATR_INIT_STATUS)
 459+ 4EDD ~            	OR A
 460+ 4EDD ~            	JP Z,ILLEGAL_FUNCTION
 461+ 4EDD ~            	; opening (
 462+ 4EDD ~            	CALL CHKCHAR
 463+ 4EDD ~            	DB '('
 464+ 4EDD ~            	; get x
 465+ 4EDD ~            	LD IX, FRMQNT
 466+ 4EDD ~            	CALL CALBAS
 467+ 4EDD ~            	LD (TMP_STRUCT),DE
 468+ 4EDD ~            	; comma
 469+ 4EDD ~            	CALL CHKCHAR
 470+ 4EDD ~            	DB ','
 471+ 4EDD ~            	; get y
 472+ 4EDD ~            	LD IX, FRMQNT
 473+ 4EDD ~            	CALL CALBAS
 474+ 4EDD ~            	LD (TMP_STRUCT+2),DE
 475+ 4EDD ~            	; comma
 476+ 4EDD ~            	CALL CHKCHAR
 477+ 4EDD ~            	DB ','
 478+ 4EDD ~            	; get count
 479+ 4EDD ~            	LD IX, GETBYT
 480+ 4EDD ~            	CALL CALBAS
 481+ 4EDD ~            	LD (TMP_STRUCT+4),A
 482+ 4EDD ~            	; comma
 483+ 4EDD ~            	CALL CHKCHAR
 484+ 4EDD ~            	DB ','
 485+ 4EDD ~            	; get sprite group definition array data pointer
 486+ 4EDD ~            	LD A,(TMP_STRUCT+4)
 487+ 4EDD ~            	LD E,A
 488+ 4EDD ~            	LD D,3
 489+ 4EDD ~            	LD A,2
 490+ 4EDD ~            	LD B,A
 491+ 4EDD ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
 492+ 4EDD ~            	LD (TMP_STRUCT+5),BC
 493+ 4EDD ~            	; ending )
 494+ 4EDD ~            	CALL CHKCHAR
 495+ 4EDD ~            	DB ')'
 496+ 4EDD ~
 497+ 4EDD ~            	PUSH HL
 498+ 4EDD ~
 499+ 4EDD ~                EXX
 500+ 4EDD ~                LD DE,(TMP_STRUCT) ; initial x
 501+ 4EDD ~                LD BC,(TMP_STRUCT+2) ; initial y
 502+ 4EDD ~                EXX
 503+ 4EDD ~                LD HL,(TMP_STRUCT+5) ; pointer to data
 504+ 4EDD ~                LD A,(TMP_STRUCT+4) ; number of entries
 505+ 4EDD ~                LD B,A
 506+ 4EDD ~            	CALL SPR_UPDATE_LOC
 507+ 4EDD ~
 508+ 4EDD ~            	POP HL
 509+ 4EDD ~            	RET
 510+ 4EDD ~            ; *******************************************************************************************************
 511+ 4EDD               ENDIF
 512+ 4EDD
 513+ 4EDD               IF (1 == 1)
 514+ 4EDD              ; *******************************************************************************************************
 515+ 4EDD              ; same as SPRGRPMOV but for DEFUSR approach
 516+ 4EDD              ; input IX=pointer to input array, real data from +2
 517+ 4EDD              ; +2 = X
 518+ 4EDD              ; +4 = Y
 519+ 4EDD              ; +6 = count
 520+ 4EDD              ; +8 = data pointer
 521+ 4EDD              SPRGRPMOV_DEFUSR:
 522+ 4EDD D9               EXX
 523+ 4EDE DD 5E 02     	LD E,(IX+2)
 524+ 4EE1 DD 56 03     	LD D,(IX+3) ; initial x
 525+ 4EE4 DD 4E 04     	LD C,(IX+4)
 526+ 4EE7 DD 46 05     	LD B,(IX+5) ; initial y
 527+ 4EEA D9               EXX
 528+ 4EEB DD 6E 08     	LD L,(IX+8)
 529+ 4EEE DD 66 09     	LD H,(IX+9) ; pointer to data
 530+ 4EF1 DD 46 06         LD B,(IX+6) ; count
 531+ 4EF4 C3 C2 4E         JP SPR_UPDATE_LOC
 532+ 4EF7              ; *******************************************************************************************************
 533+ 4EF7               ENDIF
# file closed: asm\SPRITES.asm
 135  4EF7               ENDIF
 136  4EF7
 137  4EF7               IF (ANIM_CMDS == 1)
 138  4EF7               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4EF7              ; sprite animation routines
   2+ 4EF7
   3+ 4EF7              ; number of animation items and pointer
   4+ 4EF7              ANIMITEMNUM:
   5+ 4EF7 00            DB 0
   6+ 4EF8              ANIMITEMPTR:
   7+ 4EF8 35 61         DW EXT_END
   8+ 4EFA              ; number of animation definitions and pointer
   9+ 4EFA              ANIMDEFNUM:
  10+ 4EFA 00            DB 0
  11+ 4EFB              ANIMDEFPTR:
  12+ 4EFB 35 61         DW EXT_END
  13+ 4EFD              ; number of links between sprite and animation definitions
  14+ 4EFD              ANIMSPRNUM:
  15+ 4EFD 00            DB 0
  16+ 4EFE              ANIMSPRPTR:
  17+ 4EFE 35 61         DW EXT_END
  18+ 4F00              ; number of automatic sprite group move and animate structures
  19+ 4F00              AUTOSGAMNUM:
  20+ 4F00 00            DB 0
  21+ 4F01              AUTOSGAMPTR:
  22+ 4F01 35 61         DW EXT_END
  23+ 4F03
  24+ 4F03              ; ANIMATION ITEM
  25+ 4F03              ; byte type = [0 - pattern and color change
  26+ 4F03              ;              1 - pattern definition change ]
  27+ 4F03              ; word ticks - number of ticks to hold this state
  28+ 4F03              ; for type = 0
  29+ 4F03              ;   byte pattern;
  30+ 4F03              ;   byte color;
  31+ 4F03              ; for type = 1
  32+ 4F03              ;   work data_pointer;
  33+ 4F03              ; total size = 5b
  34+ 4F03
  35+ 4F03              ; ANIMATION DEFINITION
  36+ 4F03              ; byte number of items 1-15
  37+ 4F03              ; byte[15] anim_item;
  38+ 4F03              ; total size = 16b
  39+ 4F03
  40+ 4F03              ; SPRITE/CHAR ANIMATION
  41+ 4F03              ; +00 byte sprite/char number;
  42+ 4F03              ; +01 word time;
  43+ 4F03              ; +03 byte current item;
  44+ 4F03              ; +04 byte animation definition;
  45+ 4F03              ; +05 byte cyclic;
  46+ 4F03              ; +06 byte active;
  47+ 4F03              ; +07 byte 0=sprite, 1-3 character bank
  48+ 4F03              ; total size = 8b
  49+ 4F03
  50+ 4F03              ; AUTOMATIC SPRITE GROUP MOVE AND ANIMATE structure
  51+ 4F03              ; +00 pointer to X variable
  52+ 4F03              ; +02 pointer to Y variable
  53+ 4F03              ; +04 minimum value
  54+ 4F03              ; +06 maximal value
  55+ 4F03              ; +08 delta value
  56+ 4F03              ; +10 direction 0=horizontal, <>0 = vertical
  57+ 4F03              ; +11 sprite group size
  58+ 4F03              ; +12 sprite group pointer
  59+ 4F03              ; +14 animation list size
  60+ 4F03              ; +15 animation list pointer for negative delta values
  61+ 4F03              ; +17 animation list pointer for positive delta values
  62+ 4F03              ; +19 active flag
  63+ 4F03              ; +20 ticks for movement
  64+ 4F03              ; +22 timer
  65+ 4F03              ; total = 24b
  66+ 4F03
  67+ 4F03              ; *******************************************************************************************************
  68+ 4F03              ; helper function HL=A*5
  69+ 4F03              ; changes HL,DE
  70+ 4F03              Ax5:
  71+ 4F03 26 00            LD H,0
  72+ 4F05 6F               LD L,A
  73+ 4F06 54               LD D,H
  74+ 4F07 5D               LD E,L
  75+ 4F08 29               ADD HL,HL
  76+ 4F09 29               ADD HL,HL
  77+ 4F0A 19               ADD HL,DE
  78+ 4F0B C9               RET
  79+ 4F0C              ; *******************************************************************************************************
  80+ 4F0C
  81+ 4F0C              ; *******************************************************************************************************
  82+ 4F0C              ; helper function gets pointer to n-th animation item
  83+ 4F0C              ; changes HL,DE
  84+ 4F0C              GETnthANIMITEM:
  85+ 4F0C CD 03 4F         CALL Ax5
  86+ 4F0F ED 5B F8 4E      LD DE,(ANIMITEMPTR)
  87+ 4F13 19               ADD HL,DE
  88+ 4F14 C9               RET
  89+ 4F15              ; *******************************************************************************************************
  90+ 4F15
  91+ 4F15              ; *******************************************************************************************************
  92+ 4F15              ; helper function gets pointer to n-th entry in animation definition
  93+ 4F15              ; changes HL,DE
  94+ 4F15              GETnthANIMDEF:
  95+ 4F15 26 00            LD H,0
  96+ 4F17 6F               LD L,A
  97+ 4F18 CD BA 5F         CALL HLx16
  98+ 4F1B ED 5B FB 4E      LD DE,(ANIMDEFPTR)
  99+ 4F1F 19               ADD HL,DE
 100+ 4F20 C9               RET
 101+ 4F21              ; *******************************************************************************************************
 102+ 4F21
 103+ 4F21              ; *******************************************************************************************************
 104+ 4F21              ; helper function gets pointer to n-th entry in sprite animation
 105+ 4F21              ; changes HL,DE
 106+ 4F21              GETnthSPRANIM:
 107+ 4F21 26 00            LD H,0
 108+ 4F23 6F               LD L,A
 109+ 4F24 CD BB 5F         CALL HLx8
 110+ 4F27 ED 5B FE 4E      LD DE,(ANIMSPRPTR)
 111+ 4F2B 19               ADD HL,DE
 112+ 4F2C C9               RET
 113+ 4F2D              ; *******************************************************************************************************
 114+ 4F2D
 115+ 4F2D              ; *******************************************************************************************************
 116+ 4F2D              ; helper function gets pointer to n-th entry in autosgam table
 117+ 4F2D              ; changes HL,DE
 118+ 4F2D              GETnthAUTOSGAM:
 119+ 4F2D 26 00            LD H,0
 120+ 4F2F 6F               LD L,A
 121+ 4F30 CD BB 5F         CALL HLx8
 122+ 4F33 54               LD D,H
 123+ 4F34 5D               LD E,L
 124+ 4F35 29               ADD HL,HL
 125+ 4F36 19               ADD HL,DE
 126+ 4F37 ED 5B 01 4F      LD DE,(AUTOSGAMPTR)
 127+ 4F3B 19               ADD HL,DE
 128+ 4F3C C9               RET
 129+ 4F3D              ; *******************************************************************************************************
 130+ 4F3D
 131+ 4F3D               IF (1 == 1)
 132+ 4F3D              ; *******************************************************************************************************
 133+ 4F3D              ; same as MAXIANIMITEMS but for DEFUSR approach
 134+ 4F3D              ; input IX=pointer to input array, real data from +2
 135+ 4F3D              ; +2 = number
 136+ 4F3D              MAXANIMITEMS_DEFUSR:
 137+ 4F3D DD 7E 02         LD A,(IX+2)
 138+ 4F40 CD 45 4F         CALL MAXANIMITEMS.COMMON
 139+ 4F43 AF               XOR A ; success
 140+ 4F44 C9               RET
 141+ 4F45              ; *******************************************************************************************************
 142+ 4F45               ENDIF
 143+ 4F45
 144+ 4F45              ; *******************************************************************************************************
 145+ 4F45              ; function to handle CALL MAXANIMITEMS basic extension
 146+ 4F45              ; MAXANIMITEMS (BYTE number)
 147+ 4F45              ; sets new number and moves memory buffers as needed
 148+ 4F45              MAXANIMITEMS:
 149+ 4F45               IF (0 == 1)
 150+ 4F45 ~            	; opening (
 151+ 4F45 ~            	CALL CHKCHAR
 152+ 4F45 ~            	DB '('
 153+ 4F45 ~            	; get value
 154+ 4F45 ~            	LD IX, GETBYT
 155+ 4F45 ~            	CALL CALBAS
 156+ 4F45 ~                PUSH AF
 157+ 4F45 ~            	; ending )
 158+ 4F45 ~            	CALL CHKCHAR
 159+ 4F45 ~            	DB ')'
 160+ 4F45 ~                POP AF
 161+ 4F45               ENDIF
 162+ 4F45              .COMMON: ; entry for DEFUSR part, A=number
 163+ 4F45 F3               DI
 164+ 4F46              	; save position
 165+ 4F46 E5           	PUSH HL
 166+ 4F47              .ENTRY:
 167+ 4F47 47               LD B,A
 168+ 4F48 3A F7 4E         LD A,(ANIMITEMNUM)
 169+ 4F4B 90               SUB B
 170+ 4F4C 28 28            JR Z, .EXIT; same value as before
 171+ 4F4E FD 21 FB 4E      LD IY,ANIMDEFPTR
 172+ 4F52 FA 79 4F         JP M, .INCREASE
 173+ 4F55                  ; new value is lower than previous one
 174+ 4F55 CD 98 4F         CALL .SIZEDIFF
 175+ 4F58 CD B3 4F         CALL .DECREASE_COMMON
 176+ 4F5B 2A FE 4E         LD HL,(ANIMSPRPTR)
 177+ 4F5E AF               XOR A
 178+ 4F5F ED 42            SBC HL,BC
 179+ 4F61 22 FE 4E         LD (ANIMSPRPTR),HL
 180+ 4F64              .E1:
 181+ 4F64 2A 01 4F         LD HL,(AUTOSGAMPTR)
 182+ 4F67 AF               XOR A
 183+ 4F68 ED 42            SBC HL,BC
 184+ 4F6A 22 01 4F         LD (AUTOSGAMPTR),HL
 185+ 4F6D              .E3:
 186+ 4F6D 2A 10 40         LD HL,(FREEMEMPTR)
 187+ 4F70 AF               XOR A
 188+ 4F71 ED 42            SBC HL,BC
 189+ 4F73 22 10 40         LD (FREEMEMPTR),HL
 190+ 4F76              .EXIT:
 191+ 4F76 FB               EI
 192+ 4F77 E1           	POP HL
 193+ 4F78 C9           	RET
 194+ 4F79              .INCREASE:
 195+ 4F79 ED 44            NEG
 196+ 4F7B CD 98 4F         CALL .SIZEDIFF
 197+ 4F7E CD DF 4F         CALL .INCREASE_COMMON
 198+ 4F81 2A FE 4E         LD HL,(ANIMSPRPTR)
 199+ 4F84 09               ADD HL,BC
 200+ 4F85 22 FE 4E         LD (ANIMSPRPTR),HL
 201+ 4F88              .E2:
 202+ 4F88 2A 01 4F         LD HL,(AUTOSGAMPTR)
 203+ 4F8B 09               ADD HL,BC
 204+ 4F8C 22 01 4F         LD (AUTOSGAMPTR),HL
 205+ 4F8F              .E4:
 206+ 4F8F 2A 10 40         LD HL,(FREEMEMPTR)
 207+ 4F92 09               ADD HL,BC
 208+ 4F93 22 10 40         LD (FREEMEMPTR),HL
 209+ 4F96 18 DE            JR .EXIT
 210+ 4F98              .SIZEDIFF:
 211+ 4F98 CD 03 4F         CALL Ax5
 212+ 4F9B 78               LD A,B
 213+ 4F9C 32 F7 4E         LD (ANIMITEMNUM),A
 214+ 4F9F 44               LD B,H
 215+ 4FA0 4D               LD C,L
 216+ 4FA1 C9               RET ; BC=size difference in bytes
 217+ 4FA2              .SIZETOMOVE:
 218+ 4FA2 D5               PUSH DE
 219+ 4FA3 2A 10 40         LD HL,(FREEMEMPTR)
 220+ 4FA6 FD 5E 00         LD E,(IY)
 221+ 4FA9 FD 56 01         LD D,(IY+1)
 222+ 4FAC AF               XOR A
 223+ 4FAD ED 52            SBC HL,DE
 224+ 4FAF 44               LD B,H
 225+ 4FB0 4D               LD C,L
 226+ 4FB1 D1               POP DE
 227+ 4FB2 C9               RET
 228+ 4FB3              .DECREASE_COMMON:
 229+ 4FB3 FD 6E 00         LD L,(IY)
 230+ 4FB6 FD 66 01         LD H,(IY+1)
 231+ 4FB9 AF               XOR A
 232+ 4FBA ED 42            SBC HL,BC
 233+ 4FBC EB               EX DE,HL
 234+ 4FBD C5               PUSH BC
 235+ 4FBE CD A2 4F         CALL .SIZETOMOVE
 236+ 4FC1 F3               DI
 237+ 4FC2 78               LD A,B
 238+ 4FC3 B1               OR C
 239+ 4FC4 28 08            JR Z,.L1
 240+ 4FC6 FD 6E 00         LD L,(IY)
 241+ 4FC9 FD 66 01         LD H,(IY+1)
 242+ 4FCC ED B0            LDIR
 243+ 4FCE              .L1:
 244+ 4FCE C1               POP BC
 245+ 4FCF FD 6E 00         LD L,(IY)
 246+ 4FD2 FD 66 01         LD H,(IY+1)
 247+ 4FD5 AF               XOR A
 248+ 4FD6 ED 42            SBC HL,BC
 249+ 4FD8 FD 75 00         LD (IY),L
 250+ 4FDB FD 74 01         LD (IY+1),H
 251+ 4FDE C9               RET
 252+ 4FDF              .INCREASE_COMMON:
 253+ 4FDF 2A 10 40         LD HL,(FREEMEMPTR)
 254+ 4FE2 2B               DEC HL
 255+ 4FE3 AF               XOR A
 256+ 4FE4 ED 42            SBC HL,BC
 257+ 4FE6 EB               EX DE,HL
 258+ 4FE7 C5               PUSH BC
 259+ 4FE8 CD A2 4F         CALL .SIZETOMOVE
 260+ 4FEB F3               DI
 261+ 4FEC 78               LD A,B
 262+ 4FED B1               OR C
 263+ 4FEE 28 06            JR Z,.L2
 264+ 4FF0 2A 10 40         LD HL,(FREEMEMPTR)
 265+ 4FF3 2B               DEC HL
 266+ 4FF4 ED B8            LDDR
 267+ 4FF6              .L2:
 268+ 4FF6 C1               POP BC
 269+ 4FF7 FD 6E 00         LD L,(IY)
 270+ 4FFA FD 66 01         LD H,(IY+1)
 271+ 4FFD 09               ADD HL,BC
 272+ 4FFE FD 75 00         LD (IY),L
 273+ 5001 FD 74 01         LD (IY+1),H
 274+ 5004 C9               RET
 275+ 5005              ; *******************************************************************************************************
 276+ 5005
 277+ 5005               IF (0 == 1)
 278+ 5005 ~            ; *******************************************************************************************************
 279+ 5005 ~            ; function to handle CALL ANIMITEMPAT basic extension
 280+ 5005 ~            ; ANIMITEMPAT ( BYTE id,
 281+ 5005 ~            ;               INT ticks >0,
 282+ 5005 ~            ;               BYTE pattern,
 283+ 5005 ~            ;               BYTE color )
 284+ 5005 ~            ; fills animation item data, returns an error if ID out of bounds
 285+ 5005 ~            ANIMITEMPAT:
 286+ 5005 ~                ; opening (
 287+ 5005 ~            	CALL CHKCHAR
 288+ 5005 ~            	DB '('
 289+ 5005 ~            	; get id
 290+ 5005 ~            	LD IX, GETBYT
 291+ 5005 ~            	CALL CALBAS
 292+ 5005 ~                PUSH AF
 293+ 5005 ~                ; check if out of bounds
 294+ 5005 ~                INC A
 295+ 5005 ~                LD C,A
 296+ 5005 ~                LD A,(ANIMITEMNUM)
 297+ 5005 ~                CP C
 298+ 5005 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 299+ 5005 ~            	; comma
 300+ 5005 ~            	CALL CHKCHAR
 301+ 5005 ~            	DB ','
 302+ 5005 ~            	; get ticks
 303+ 5005 ~            	LD IX, FRMQNT
 304+ 5005 ~            	CALL CALBAS
 305+ 5005 ~                LD A,D
 306+ 5005 ~                OR E
 307+ 5005 ~                JP Z, OVERFLOW
 308+ 5005 ~            	PUSH DE
 309+ 5005 ~            	; comma
 310+ 5005 ~            	CALL CHKCHAR
 311+ 5005 ~            	DB ','
 312+ 5005 ~            	; get pattern
 313+ 5005 ~            	LD IX, GETBYT
 314+ 5005 ~            	CALL CALBAS
 315+ 5005 ~                PUSH AF
 316+ 5005 ~            	; comma
 317+ 5005 ~            	CALL CHKCHAR
 318+ 5005 ~            	DB ','
 319+ 5005 ~            	; get color
 320+ 5005 ~            	LD IX, GETBYT
 321+ 5005 ~            	CALL CALBAS
 322+ 5005 ~                PUSH AF
 323+ 5005 ~            	; ending )
 324+ 5005 ~            	CALL CHKCHAR
 325+ 5005 ~            	DB ')'
 326+ 5005 ~            .ENTRY:
 327+ 5005 ~                PUSH HL
 328+ 5005 ~                POP IX
 329+ 5005 ~                EXX
 330+ 5005 ~                POP BC ; color
 331+ 5005 ~                POP DE ; pattern
 332+ 5005 ~                POP HL ; ticks
 333+ 5005 ~                EXX
 334+ 5005 ~                POP AF
 335+ 5005 ~                CALL GETnthANIMITEM
 336+ 5005 ~                PUSH HL
 337+ 5005 ~                POP IY
 338+ 5005 ~                EXX
 339+ 5005 ~                LD (IY),0 ; type=0
 340+ 5005 ~                LD (IY+1),L
 341+ 5005 ~                LD (IY+2),H
 342+ 5005 ~                LD (IY+3),D
 343+ 5005 ~                LD (IY+4),B
 344+ 5005 ~
 345+ 5005 ~                PUSH IX
 346+ 5005 ~                POP HL
 347+ 5005 ~                RET
 348+ 5005 ~            ; *******************************************************************************************************
 349+ 5005               ENDIF
 350+ 5005
 351+ 5005               IF (1 == 1)
 352+ 5005              ; *******************************************************************************************************
 353+ 5005              ; same as ANIMITEMPAT but for DEFUSR approach
 354+ 5005              ; input IX=pointer to input array, real data from +2
 355+ 5005              ; +02 = ID
 356+ 5005              ; +04 = ticks
 357+ 5005              ; +06 = pattern
 358+ 5005              ; +08 = color
 359+ 5005              ANIMITEMPAT_DEFUSR:
 360+ 5005                  ; check if out of bounds
 361+ 5005 DD 4E 02         LD C,(IX+2)
 362+ 5008 0C               INC C
 363+ 5009 3A F7 4E         LD A,(ANIMITEMNUM)
 364+ 500C B9               CP C
 365+ 500D 38 1D            JR C,.ERR ; out of bounds, prevent memory corruption
 366+ 500F 79               LD A,C
 367+ 5010 3D               DEC A
 368+ 5011 CD 0C 4F         CALL GETnthANIMITEM
 369+ 5014 36 00            LD (HL),0 ; type=0
 370+ 5016 23               INC HL
 371+ 5017 DD 7E 04         LD A,(IX+4) ; ticks low
 372+ 501A 77               LD (HL),A
 373+ 501B 23               INC HL
 374+ 501C DD 7E 05         LD A,(IX+5) ; ticks high
 375+ 501F 77               LD (HL),A
 376+ 5020 23               INC HL
 377+ 5021 DD 7E 06         LD A,(IX+6) ; pattern
 378+ 5024 77               LD (HL),A
 379+ 5025 23               INC HL
 380+ 5026 DD 7E 08         LD A,(IX+8) ; color
 381+ 5029 77               LD (HL),A
 382+ 502A AF               XOR A ; success
 383+ 502B C9               RET
 384+ 502C              .ERR:
 385+ 502C 3E 01            LD A,1
 386+ 502E C9               RET
 387+ 502F              ; *******************************************************************************************************
 388+ 502F               ENDIF
 389+ 502F
 390+ 502F               IF (0 == 1)
 391+ 502F ~            ; *******************************************************************************************************
 392+ 502F ~            ; function to handle CALL ANIMITEMPTR basic extension
 393+ 502F ~            ; ANIMITEMPTR ( BYTE id,
 394+ 502F ~            ;               INT ticks,
 395+ 502F ~            ;               INT pointer,
 396+ 502F ~            ; fills animation item data, returns an error if ID out of bounds
 397+ 502F ~            ANIMITEMPTR_CMD:
 398+ 502F ~                ; opening (
 399+ 502F ~            	CALL CHKCHAR
 400+ 502F ~            	DB '('
 401+ 502F ~            	; get id
 402+ 502F ~            	LD IX, GETBYT
 403+ 502F ~            	CALL CALBAS
 404+ 502F ~                PUSH AF
 405+ 502F ~                ; check if out of bounds
 406+ 502F ~                INC A
 407+ 502F ~                LD C,A
 408+ 502F ~                LD A,(ANIMITEMNUM)
 409+ 502F ~                CP C
 410+ 502F ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 411+ 502F ~            	; comma
 412+ 502F ~            	CALL CHKCHAR
 413+ 502F ~            	DB ','
 414+ 502F ~            	; get ticks
 415+ 502F ~            	LD IX, FRMQNT
 416+ 502F ~            	CALL CALBAS
 417+ 502F ~                LD A,D
 418+ 502F ~                OR E
 419+ 502F ~                JP Z,OVERFLOW
 420+ 502F ~            	PUSH DE
 421+ 502F ~            	; comma
 422+ 502F ~            	CALL CHKCHAR
 423+ 502F ~            	DB ','
 424+ 502F ~            	; get pointer
 425+ 502F ~            	LD IX, FRMQNT
 426+ 502F ~            	CALL CALBAS
 427+ 502F ~            	PUSH DE
 428+ 502F ~            	; ending )
 429+ 502F ~            	CALL CHKCHAR
 430+ 502F ~            	DB ')'
 431+ 502F ~            .ENTRY:
 432+ 502F ~                PUSH HL
 433+ 502F ~                POP IX
 434+ 502F ~                EXX
 435+ 502F ~                POP DE ; pointer
 436+ 502F ~                POP HL ; ticks
 437+ 502F ~                EXX
 438+ 502F ~                POP AF
 439+ 502F ~                CALL GETnthANIMITEM
 440+ 502F ~                PUSH HL
 441+ 502F ~                POP IY
 442+ 502F ~                EXX
 443+ 502F ~                LD (IY),1 ; type=1
 444+ 502F ~                LD (IY+1),L
 445+ 502F ~                LD (IY+2),H
 446+ 502F ~                LD (IY+3),E
 447+ 502F ~                LD (IY+4),D
 448+ 502F ~
 449+ 502F ~                PUSH IX
 450+ 502F ~                POP HL
 451+ 502F ~                RET
 452+ 502F ~            ; *******************************************************************************************************
 453+ 502F               ENDIF
 454+ 502F
 455+ 502F               IF (1 == 1)
 456+ 502F              ; *******************************************************************************************************
 457+ 502F              ; same as ANIMITEMPTR but for DEFUSR approach
 458+ 502F              ; input IX=pointer to input array, real data from +2
 459+ 502F              ; +02 = ID
 460+ 502F              ; +04 = ticks
 461+ 502F              ; +06 = pointer
 462+ 502F              ANIMITEMPTR_DEFUSR:
 463+ 502F                  ; check if out of bounds
 464+ 502F DD 4E 02         LD C,(IX+2)
 465+ 5032 0C               INC C
 466+ 5033 3A F7 4E         LD A,(ANIMITEMNUM)
 467+ 5036 B9               CP C
 468+ 5037 38 1D            JR C,.ERR ; out of bounds, prevent memory corruption
 469+ 5039 79               LD A,C
 470+ 503A 3D               DEC A
 471+ 503B CD 0C 4F         CALL GETnthANIMITEM
 472+ 503E 36 01            LD (HL),1 ; type=1
 473+ 5040 23               INC HL
 474+ 5041 DD 7E 04         LD A,(IX+4) ; ticks low
 475+ 5044 77               LD (HL),A
 476+ 5045 23               INC HL
 477+ 5046 DD 7E 05         LD A,(IX+5) ; ticks high
 478+ 5049 77               LD (HL),A
 479+ 504A 23               INC HL
 480+ 504B DD 7E 06         LD A,(IX+6) ; pointer low
 481+ 504E 77               LD (HL),A
 482+ 504F 23               INC HL
 483+ 5050 DD 7E 07         LD A,(IX+7) ; pointer high
 484+ 5053 77               LD (HL),A
 485+ 5054 AF               XOR A ; success
 486+ 5055 C9               RET
 487+ 5056              .ERR:
 488+ 5056 3E 01            LD A,1
 489+ 5058 C9               RET
 490+ 5059              ; *******************************************************************************************************
 491+ 5059               ENDIF
 492+ 5059
 493+ 5059               IF (1 == 1)
 494+ 5059              ; *******************************************************************************************************
 495+ 5059              ; same as MAXANIMDEFS but for DEFUSR approach
 496+ 5059              ; input IX=pointer to input array, real data from +2
 497+ 5059              ; +2 = number
 498+ 5059              MAXANIMDEFS_DEFUSR:
 499+ 5059 DD 7E 02         LD A,(IX+2)
 500+ 505C CD 61 50         CALL MAXANIMDEFS.COMMON
 501+ 505F AF               XOR A ; success
 502+ 5060 C9               RET
 503+ 5061              ; *******************************************************************************************************
 504+ 5061               ENDIF
 505+ 5061
 506+ 5061              ; *******************************************************************************************************
 507+ 5061              ; function to handle CALL MAXANIMDEFS basic extension
 508+ 5061              ; MAXANIMDEFS (BYTE number)
 509+ 5061              ; sets new number and moves memory buffers as needed
 510+ 5061              MAXANIMDEFS:
 511+ 5061               IF (0 == 1)
 512+ 5061 ~            	; opening (
 513+ 5061 ~            	CALL CHKCHAR
 514+ 5061 ~            	DB '('
 515+ 5061 ~            	; get value
 516+ 5061 ~            	LD IX, GETBYT
 517+ 5061 ~            	CALL CALBAS
 518+ 5061 ~                PUSH AF
 519+ 5061 ~            	; ending )
 520+ 5061 ~            	CALL CHKCHAR
 521+ 5061 ~            	DB ')'
 522+ 5061 ~                POP AF
 523+ 5061               ENDIF
 524+ 5061              .COMMON:
 525+ 5061 F3               DI
 526+ 5062              	; save position
 527+ 5062 E5           	PUSH HL
 528+ 5063              .ENTRY:
 529+ 5063 47               LD B,A
 530+ 5064 3A FA 4E         LD A,(ANIMDEFNUM)
 531+ 5067 90               SUB B
 532+ 5068 CA 76 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 533+ 506B FD 21 FE 4E      LD IY,ANIMSPRPTR
 534+ 506F FA 7B 50         JP M, .INCREASE
 535+ 5072                  ; new value is lower than previous one
 536+ 5072 CD 86 50         CALL .SIZEDIFF
 537+ 5075 CD B3 4F         CALL MAXANIMITEMS.DECREASE_COMMON
 538+ 5078 C3 64 4F         JP MAXANIMITEMS.E1
 539+ 507B              .INCREASE:
 540+ 507B ED 44            NEG
 541+ 507D CD 86 50         CALL .SIZEDIFF
 542+ 5080 CD DF 4F         CALL MAXANIMITEMS.INCREASE_COMMON
 543+ 5083 C3 88 4F         JP MAXANIMITEMS.E2
 544+ 5086              .SIZEDIFF:
 545+ 5086 26 00            LD H,0
 546+ 5088 6F               LD L,A
 547+ 5089 CD BA 5F         CALL HLx16
 548+ 508C 78               LD A,B
 549+ 508D 32 FA 4E         LD (ANIMDEFNUM),A
 550+ 5090 44               LD B,H
 551+ 5091 4D               LD C,L
 552+ 5092 C9               RET ; BC=size difference in bytes
 553+ 5093              ; *******************************************************************************************************
 554+ 5093
 555+ 5093               IF (0 == 1)
 556+ 5093 ~            ; *******************************************************************************************************
 557+ 5093 ~            ; function to handle CALL ANIMDEF basic extension
 558+ 5093 ~            ; ANIMITEMPAT ( BYTE id,
 559+ 5093 ~            ;               BYTE size,
 560+ 5093 ~            ;               INT[] list )
 561+ 5093 ~            ; fills animation definition data, returns an error if out of bounds, or invalid type
 562+ 5093 ~            ANIMDEF:
 563+ 5093 ~                ; opening (
 564+ 5093 ~            	CALL CHKCHAR
 565+ 5093 ~            	DB '('
 566+ 5093 ~            	; get id
 567+ 5093 ~            	LD IX, GETBYT
 568+ 5093 ~            	CALL CALBAS
 569+ 5093 ~                PUSH AF
 570+ 5093 ~                ; check if out of bounds
 571+ 5093 ~                INC A
 572+ 5093 ~                LD C,A
 573+ 5093 ~                LD A,(ANIMDEFNUM)
 574+ 5093 ~                CP C
 575+ 5093 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 576+ 5093 ~            	; comma
 577+ 5093 ~            	CALL CHKCHAR
 578+ 5093 ~            	DB ','
 579+ 5093 ~            	; get size
 580+ 5093 ~            	LD IX, GETBYT
 581+ 5093 ~            	CALL CALBAS
 582+ 5093 ~                CP 16
 583+ 5093 ~                JP NC, OVERFLOW
 584+ 5093 ~                OR A
 585+ 5093 ~                JP Z, OVERFLOW
 586+ 5093 ~            	PUSH AF
 587+ 5093 ~            	; comma
 588+ 5093 ~            	CALL CHKCHAR
 589+ 5093 ~            	DB ','
 590+ 5093 ~            	; get pointer to a list of animation items in integer array format
 591+ 5093 ~                ; get array pointer
 592+ 5093 ~                POP DE
 593+ 5093 ~                PUSH DE
 594+ 5093 ~                LD A,2
 595+ 5093 ~                LD B,1
 596+ 5093 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
 597+ 5093 ~                PUSH BC
 598+ 5093 ~            	; ending )
 599+ 5093 ~            	CALL CHKCHAR
 600+ 5093 ~            	DB ')'
 601+ 5093 ~            .ENTRY:
 602+ 5093 ~                PUSH HL
 603+ 5093 ~                POP IX
 604+ 5093 ~                POP DE ; pointer to INT array
 605+ 5093 ~                POP BC ; B=item number
 606+ 5093 ~                POP AF ; id
 607+ 5093 ~                PUSH DE
 608+ 5093 ~                CALL GETnthANIMDEF
 609+ 5093 ~                POP DE
 610+ 5093 ~                LD (HL),B
 611+ 5093 ~            .L1:
 612+ 5093 ~                INC HL
 613+ 5093 ~                LD A,(DE)
 614+ 5093 ~                .2 INC DE
 615+ 5093 ~                LD (HL),A
 616+ 5093 ~                DJNZ .L1
 617+ 5093 ~                PUSH IX
 618+ 5093 ~                POP HL
 619+ 5093 ~                RET
 620+ 5093 ~            ; *******************************************************************************************************
 621+ 5093               ENDIF
 622+ 5093
 623+ 5093               IF (1 == 1)
 624+ 5093              ; *******************************************************************************************************
 625+ 5093              ; same as ANIMDEF but for DEFUSR approach
 626+ 5093              ; input IX=pointer to input array, real data from +2
 627+ 5093              ; +02 = ID
 628+ 5093              ; +04 = list size
 629+ 5093              ; +06 = list pointer
 630+ 5093              ANIMDEF_DEFUSR:
 631+ 5093                  ; check if out of bounds
 632+ 5093 DD 4E 02         LD C,(IX+2)
 633+ 5096 0C               INC C
 634+ 5097 3A FA 4E         LD A,(ANIMDEFNUM)
 635+ 509A B9               CP C
 636+ 509B 38 1E            JR C,.ERR ; invalid id
 637+ 509D              	; get size
 638+ 509D DD 7E 04         LD A,(IX+4)
 639+ 50A0 FE 10            CP 16
 640+ 50A2 D0               RET NC ; overflow
 641+ 50A3 B7               OR A
 642+ 50A4 C8               RET Z ; ID=0, invalid
 643+ 50A5 47               LD B,A
 644+ 50A6 79               LD A,C
 645+ 50A7 3D               DEC A
 646+ 50A8 CD 15 4F         CALL GETnthANIMDEF
 647+ 50AB 70               LD (HL),B
 648+ 50AC DD 5E 06         LD E,(IX+6)
 649+ 50AF DD 56 07         LD D,(IX+7)
 650+ 50B2              .L1:
 651+ 50B2 23               INC HL
 652+ 50B3 1A               LD A,(DE)
 653+ 50B4 13          > INC DE
 653+ 50B5 13          > INC DE
 654+ 50B6 77               LD (HL),A
 655+ 50B7 10 F9            DJNZ .L1
 656+ 50B9 AF               XOR A ; success
 657+ 50BA C9               RET
 658+ 50BB              .ERR:
 659+ 50BB 3E 01            LD A,1
 660+ 50BD C9               RET
 661+ 50BE              ; *******************************************************************************************************
 662+ 50BE               ENDIF
 663+ 50BE
 664+ 50BE               IF (1 == 1)
 665+ 50BE              ; *******************************************************************************************************
 666+ 50BE              ; same as MAXANIMSPRS but for DEFUSR approach
 667+ 50BE              ; input IX=pointer to input array, real data from +2
 668+ 50BE              ; +2 = number
 669+ 50BE              MAXANIMSPRS_DEFUSR:
 670+ 50BE DD 7E 02         LD A,(IX+2)
 671+ 50C1 CD C6 50         CALL MAXANIMSPRS.COMMON
 672+ 50C4 AF               XOR A ; success
 673+ 50C5 C9               RET
 674+ 50C6              ; *******************************************************************************************************
 675+ 50C6               ENDIF
 676+ 50C6
 677+ 50C6              ; *******************************************************************************************************
 678+ 50C6              ; function to handle CALL MAXANIMSPRS basic extension
 679+ 50C6              ; MAXANIMSPRS (BYTE number)
 680+ 50C6              ; sets new number and moves memory buffers as needed
 681+ 50C6              MAXANIMSPRS:
 682+ 50C6               IF (0 == 1)
 683+ 50C6 ~            	; opening (
 684+ 50C6 ~            	CALL CHKCHAR
 685+ 50C6 ~            	DB '('
 686+ 50C6 ~            	; get value
 687+ 50C6 ~            	LD IX, GETBYT
 688+ 50C6 ~            	CALL CALBAS
 689+ 50C6 ~                PUSH AF
 690+ 50C6 ~            	; ending )
 691+ 50C6 ~            	CALL CHKCHAR
 692+ 50C6 ~            	DB ')'
 693+ 50C6 ~                POP AF
 694+ 50C6               ENDIF
 695+ 50C6              .COMMON:
 696+ 50C6 F3               DI
 697+ 50C7              	; save position
 698+ 50C7 E5           	PUSH HL
 699+ 50C8              .ENTRY:
 700+ 50C8 47               LD B,A
 701+ 50C9 3A FD 4E         LD A,(ANIMSPRNUM)
 702+ 50CC 90               SUB B
 703+ 50CD CA 76 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 704+ 50D0 FD 21 01 4F      LD IY,AUTOSGAMPTR
 705+ 50D4 FA E0 50         JP M, .INCREASE
 706+ 50D7                  ; new value is lower than previous one
 707+ 50D7 CD 01 51         CALL .SIZEDIFF
 708+ 50DA CD B3 4F         CALL MAXANIMITEMS.DECREASE_COMMON
 709+ 50DD C3 6D 4F         JP MAXANIMITEMS.E3
 710+ 50E0              .INCREASE:
 711+ 50E0 ED 44            NEG
 712+ 50E2 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 713+ 50E3 CD 01 51         CALL .SIZEDIFF
 714+ 50E6 CD DF 4F         CALL MAXANIMITEMS.INCREASE_COMMON
 715+ 50E9 AF               XOR A
 716+ 50EA ED 42            SBC HL,BC ; location of new stuff
 717+ 50EC F1               POP AF
 718+ 50ED C5               PUSH BC
 719+ 50EE 47               LD B,A
 720+ 50EF 11 08 00         LD DE,8
 721+ 50F2 E5               PUSH HL
 722+ 50F3 DD E1            POP IX
 723+ 50F5              .L1:
 724+ 50F5 DD 36 06 00      LD (IX+6),0 ; active flag
 725+ 50F9 DD 19            ADD IX,DE
 726+ 50FB 10 F8            DJNZ .L1
 727+ 50FD C1               POP BC
 728+ 50FE C3 8F 4F         JP MAXANIMITEMS.E4
 729+ 5101              .SIZEDIFF:
 730+ 5101 26 00            LD H,0
 731+ 5103 6F               LD L,A
 732+ 5104 CD BB 5F         CALL HLx8
 733+ 5107 78               LD A,B
 734+ 5108 32 FD 4E         LD (ANIMSPRNUM),A
 735+ 510B 44               LD B,H
 736+ 510C 4D               LD C,L
 737+ 510D C9               RET ; BC=size difference in bytes
 738+ 510E              ; *******************************************************************************************************
 739+ 510E
 740+ 510E               IF (0 == 1)
 741+ 510E ~            ; *******************************************************************************************************
 742+ 510E ~            ; function to handle CALL ANIMSPRITE basic extension
 743+ 510E ~            ; ANIMSPRITE ( BYTE id,
 744+ 510E ~            ;              BYTE sprite_number,
 745+ 510E ~            ;              BYTE animation_definition_id,
 746+ 510E ~            ;              BYTE cyclic_flag )
 747+ 510E ~            ; fills sprite animation data, returns an error if out of bounds, or invalid type
 748+ 510E ~            ANIMSPRITE:
 749+ 510E ~                ; opening (
 750+ 510E ~            	CALL CHKCHAR
 751+ 510E ~            	DB '('
 752+ 510E ~            	; get sprite animation id
 753+ 510E ~            	LD IX, GETBYT
 754+ 510E ~            	CALL CALBAS
 755+ 510E ~                PUSH AF
 756+ 510E ~                INC A
 757+ 510E ~                LD C,A
 758+ 510E ~                LD A,(ANIMSPRNUM)
 759+ 510E ~                CP C
 760+ 510E ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 761+ 510E ~            	; comma
 762+ 510E ~            	CALL CHKCHAR
 763+ 510E ~            	DB ','
 764+ 510E ~            	; get sprite number
 765+ 510E ~            	LD IX, GETBYT
 766+ 510E ~            	CALL CALBAS
 767+ 510E ~                PUSH AF
 768+ 510E ~                ; check if out of bounds
 769+ 510E ~                CP 32
 770+ 510E ~                JP NC, SUBSCRIPT_OUT_OF_RANGE
 771+ 510E ~            	; comma
 772+ 510E ~            	CALL CHKCHAR
 773+ 510E ~            	DB ','
 774+ 510E ~            	; get animation definition id
 775+ 510E ~            	LD IX, GETBYT
 776+ 510E ~            	CALL CALBAS
 777+ 510E ~                PUSH AF
 778+ 510E ~                INC A
 779+ 510E ~                LD C,A
 780+ 510E ~                LD A,(ANIMDEFNUM)
 781+ 510E ~                CP C
 782+ 510E ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 783+ 510E ~            	; comma
 784+ 510E ~            	CALL CHKCHAR
 785+ 510E ~            	DB ','
 786+ 510E ~            	; get cyclic flag
 787+ 510E ~            	LD IX, GETBYT
 788+ 510E ~                CALL CALBAS
 789+ 510E ~            	PUSH AF
 790+ 510E ~            	; ending )
 791+ 510E ~            	CALL CHKCHAR
 792+ 510E ~            	DB ')'
 793+ 510E ~            .ENTRY:
 794+ 510E ~                PUSH HL
 795+ 510E ~                POP IX
 796+ 510E ~                EXX
 797+ 510E ~                POP DE ; cyclic
 798+ 510E ~                POP BC ; animation definition id
 799+ 510E ~                POP HL ; sprite number
 800+ 510E ~                EXX
 801+ 510E ~                POP AF ; sprite animation id
 802+ 510E ~                CALL GETnthSPRANIM
 803+ 510E ~                PUSH HL
 804+ 510E ~                POP IY
 805+ 510E ~                EXX
 806+ 510E ~                LD (IY),H
 807+ 510E ~                LD (IY+4),B
 808+ 510E ~                LD (IY+5),D
 809+ 510E ~                ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 810+ 510E ~                ; following will do preparation for ANIMSTEP situation
 811+ 510E ~                ; current item set to above limit and timer to 1
 812+ 510E ~                ; any call to ANIMSTEP will switch and setup to first item for cyclic
 813+ 510E ~                LD (IY+3),255
 814+ 510E ~                LD (IY+1),1
 815+ 510E ~                LD (IY+2),0
 816+ 510E ~                ; mark as sprite animation
 817+ 510E ~                LD (IY+7),0
 818+ 510E ~                PUSH IX
 819+ 510E ~                POP HL
 820+ 510E ~                RET
 821+ 510E ~            ; *******************************************************************************************************
 822+ 510E               ENDIF
 823+ 510E
 824+ 510E               IF (1 == 1)
 825+ 510E              ; *******************************************************************************************************
 826+ 510E              ; same as ANIMSPRITE but for DEFUSR approach
 827+ 510E              ; input IX=pointer to input array, real data from +2
 828+ 510E              ; +02 = ID
 829+ 510E              ; +04 = sprite number
 830+ 510E              ; +06 = animation definition id
 831+ 510E              ; +08 = cyclic flag
 832+ 510E              ANIMSPRITE_DEFUSR:
 833+ 510E DD 4E 02         LD C,(IX+2)
 834+ 5111 0C               INC C
 835+ 5112 3A FD 4E         LD A,(ANIMSPRNUM)
 836+ 5115 B9               CP C
 837+ 5116 38 31            JR C,.ERR ; invalid id
 838+ 5118              	; get sprite number
 839+ 5118 DD 7E 04         LD A,(IX+4)
 840+ 511B FE 20            CP 32
 841+ 511D 30 2A            JR NC,.ERR ; invalid sprite id
 842+ 511F DD 46 06         LD B,(IX+6)
 843+ 5122 04               INC B
 844+ 5123 3A FA 4E         LD A,(ANIMDEFNUM)
 845+ 5126 B8               CP B
 846+ 5127 38 20            JR C,.ERR ; invalid animation definition id
 847+ 5129 79               LD A,C
 848+ 512A 3D               DEC A
 849+ 512B CD 21 4F         CALL GETnthSPRANIM
 850+ 512E DD 7E 04         LD A,(IX+4)
 851+ 5131 77               LD (HL),A ; +0
 852+ 5132 23               INC HL
 853+ 5133 36 01            LD (HL),1 ; +1
 854+ 5135 23               INC HL
 855+ 5136 36 00            LD (HL),0 ; +2
 856+ 5138 23               INC HL
 857+ 5139 36 FF            LD (HL),255 ; +3
 858+ 513B 23               INC HL
 859+ 513C 05               DEC B
 860+ 513D 70               LD (HL),B ; +4
 861+ 513E 23               INC HL
 862+ 513F DD 7E 08         LD A,(IX+8) ; +5
 863+ 5142 77               LD (HL),A
 864+ 5143 23               INC HL
 865+ 5144 23               INC HL
 866+ 5145 36 00            LD (HL),0 ; +7
 867+ 5147 AF               XOR A ; success
 868+ 5148 C9               RET
 869+ 5149              .ERR:
 870+ 5149 3E 01            LD A,1
 871+ 514B C9               RET
 872+ 514C              ; *******************************************************************************************************
 873+ 514C               ENDIF
 874+ 514C
 875+ 514C
 876+ 514C               IF (0 == 1)
 877+ 514C ~            ; *******************************************************************************************************
 878+ 514C ~            ; function to handle CALL ANIMCHAR basic extension
 879+ 514C ~            ; ANIMCHAR ( BYTE id,
 880+ 514C ~            ;            INT character number 0-767,
 881+ 514C ~            ;            BYTE animation_definition_id,
 882+ 514C ~            ;            BYTE cyclic_flag )
 883+ 514C ~            ; fills sprite animation data, returns an error if out of bounds, or invalid type
 884+ 514C ~            ANIMCHAR:
 885+ 514C ~                ; opening (
 886+ 514C ~            	CALL CHKCHAR
 887+ 514C ~            	DB '('
 888+ 514C ~            	; get sprite animation id
 889+ 514C ~            	LD IX, GETBYT
 890+ 514C ~            	CALL CALBAS
 891+ 514C ~                PUSH AF
 892+ 514C ~                INC A
 893+ 514C ~                LD C,A
 894+ 514C ~                LD A,(ANIMSPRNUM)
 895+ 514C ~                CP C
 896+ 514C ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 897+ 514C ~            	; comma
 898+ 514C ~            	CALL CHKCHAR
 899+ 514C ~            	DB ','
 900+ 514C ~            	; get character number
 901+ 514C ~            	LD IX, FRMQNT
 902+ 514C ~            	CALL CALBAS
 903+ 514C ~                PUSH DE
 904+ 514C ~                ; check if out of bounds
 905+ 514C ~                LD A,D
 906+ 514C ~                CP 3
 907+ 514C ~                JP NC, SUBSCRIPT_OUT_OF_RANGE
 908+ 514C ~            	; comma
 909+ 514C ~            	CALL CHKCHAR
 910+ 514C ~            	DB ','
 911+ 514C ~            	; get animation definition id
 912+ 514C ~            	LD IX, GETBYT
 913+ 514C ~            	CALL CALBAS
 914+ 514C ~                PUSH AF
 915+ 514C ~                INC A
 916+ 514C ~                LD C,A
 917+ 514C ~                LD A,(ANIMDEFNUM)
 918+ 514C ~                CP C
 919+ 514C ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 920+ 514C ~            	; comma
 921+ 514C ~            	CALL CHKCHAR
 922+ 514C ~            	DB ','
 923+ 514C ~            	; get cyclic flag
 924+ 514C ~            	LD IX, GETBYT
 925+ 514C ~                CALL CALBAS
 926+ 514C ~            	PUSH AF
 927+ 514C ~            	; ending )
 928+ 514C ~            	CALL CHKCHAR
 929+ 514C ~            	DB ')'
 930+ 514C ~            .ENTRY:
 931+ 514C ~                PUSH HL
 932+ 514C ~                POP IX
 933+ 514C ~                EXX
 934+ 514C ~                POP DE ; cyclic
 935+ 514C ~                POP BC ; animation definition id
 936+ 514C ~                POP HL ; character number
 937+ 514C ~                EXX
 938+ 514C ~                POP AF ; sprite animation id
 939+ 514C ~                CALL GETnthSPRANIM
 940+ 514C ~                PUSH HL
 941+ 514C ~                POP IY
 942+ 514C ~                EXX
 943+ 514C ~                LD (IY),L
 944+ 514C ~                INC H ; save character bank+1
 945+ 514C ~                LD (IY+7),H
 946+ 514C ~                LD (IY+4),B
 947+ 514C ~                LD (IY+5),D
 948+ 514C ~                ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 949+ 514C ~                ; following will do preparation for ANIMSTEP situation
 950+ 514C ~                ; current item set to above limit and timer to 1
 951+ 514C ~                ; any call to ANIMSTEP will switch and setup to first item for cyclic
 952+ 514C ~                LD (IY+3),255
 953+ 514C ~                LD (IY+1),1
 954+ 514C ~                LD (IY+2),0
 955+ 514C ~                PUSH IX
 956+ 514C ~                POP HL
 957+ 514C ~                RET
 958+ 514C ~            ; *******************************************************************************************************
 959+ 514C               ENDIF
 960+ 514C
 961+ 514C               IF (1 == 1)
 962+ 514C              ; *******************************************************************************************************
 963+ 514C              ; same as ANIMCHAR but for DEFUSR approach
 964+ 514C              ; input IX=pointer to input array, real data from +2
 965+ 514C              ; +02 = ID
 966+ 514C              ; +04 = character number
 967+ 514C              ; +06 = animation definition id
 968+ 514C              ; +08 = cyclic flag
 969+ 514C              ANIMCHAR_DEFUSR:
 970+ 514C DD 4E 02         LD C,(IX+2)
 971+ 514F 0C               INC C
 972+ 5150 3A FD 4E         LD A,(ANIMSPRNUM)
 973+ 5153 B9               CP C
 974+ 5154 38 34            JR C,.ERR ; invalid id
 975+ 5156              	; get sprite number
 976+ 5156 DD 7E 05         LD A,(IX+5)
 977+ 5159 FE 03            CP 3
 978+ 515B 30 2D            JR NC,.ERR ; invalid character (>767)
 979+ 515D DD 46 06         LD B,(IX+6)
 980+ 5160 04               INC B
 981+ 5161 3A FA 4E         LD A,(ANIMDEFNUM)
 982+ 5164 B8               CP B
 983+ 5165 38 23            JR C,.ERR ; invalid animation definition id
 984+ 5167 79               LD A,C
 985+ 5168 3D               DEC A
 986+ 5169 CD 21 4F         CALL GETnthSPRANIM
 987+ 516C DD 7E 04         LD A,(IX+4)
 988+ 516F 77               LD (HL),A ; +0
 989+ 5170 23               INC HL
 990+ 5171 36 01            LD (HL),1 ; +1
 991+ 5173 23               INC HL
 992+ 5174 36 00            LD (HL),0 ; +2
 993+ 5176 23               INC HL
 994+ 5177 36 FF            LD (HL),255 ; +3
 995+ 5179 23               INC HL
 996+ 517A 05               DEC B
 997+ 517B 70               LD (HL),B ; +4
 998+ 517C 23               INC HL
 999+ 517D DD 7E 08         LD A,(IX+8) ; +5
1000+ 5180 77               LD (HL),A
1001+ 5181 23               INC HL
1002+ 5182 23               INC HL
1003+ 5183 DD 7E 05         LD A,(IX+5)
1004+ 5186 3C               INC A
1005+ 5187 77               LD (HL),A ; +7
1006+ 5188 AF               XOR A ; success
1007+ 5189 C9               RET
1008+ 518A              .ERR:
1009+ 518A 3E 01            LD A,1
1010+ 518C C9               RET
1011+ 518D              ; *******************************************************************************************************
1012+ 518D               ENDIF
1013+ 518D
1014+ 518D               IF (1 == 1)
1015+ 518D              ; *******************************************************************************************************
1016+ 518D              ; same as MAXAUTOSGAMS but for DEFUSR approach
1017+ 518D              ; input IX=pointer to input array, real data from +2
1018+ 518D              ; +2 = number
1019+ 518D              MAXAUTOSGAMS_DEFUSR:
1020+ 518D DD 7E 02         LD A,(IX+2)
1021+ 5190 CD 95 51         CALL MAXAUTOSGAMS.COMMON
1022+ 5193 AF               XOR A ; success
1023+ 5194 C9               RET
1024+ 5195              ; *******************************************************************************************************
1025+ 5195               ENDIF
1026+ 5195
1027+ 5195              ; *******************************************************************************************************
1028+ 5195              ; function to handle CALL MAXAUTOSGAMS basic extension
1029+ 5195              ; MAXAUTOSGAMS (BYTE number)
1030+ 5195              ; sets new number and moves memory buffers as needed
1031+ 5195              MAXAUTOSGAMS:
1032+ 5195               IF (0 == 1)
1033+ 5195 ~            	; opening (
1034+ 5195 ~            	CALL CHKCHAR
1035+ 5195 ~            	DB '('
1036+ 5195 ~            	; get value
1037+ 5195 ~            	LD IX, GETBYT
1038+ 5195 ~            	CALL CALBAS
1039+ 5195 ~                PUSH AF
1040+ 5195 ~            	; ending )
1041+ 5195 ~            	CALL CHKCHAR
1042+ 5195 ~            	DB ')'
1043+ 5195 ~                POP AF
1044+ 5195               ENDIF
1045+ 5195              .COMMON:
1046+ 5195 F3               DI
1047+ 5196              	; save position
1048+ 5196 E5           	PUSH HL
1049+ 5197              .ENTRY:
1050+ 5197 47               LD B,A
1051+ 5198 3A 00 4F         LD A,(AUTOSGAMNUM)
1052+ 519B 90               SUB B
1053+ 519C CA 76 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
1054+ 519F FD 21 10 40      LD IY,FREEMEMPTR
1055+ 51A3 FA AF 51         JP M, .INCREASE
1056+ 51A6                  ; new value is lower than previous one
1057+ 51A6 CD D0 51         CALL .SIZEDIFF
1058+ 51A9 CD B3 4F         CALL MAXANIMITEMS.DECREASE_COMMON
1059+ 51AC C3 76 4F         JP MAXANIMITEMS.EXIT
1060+ 51AF              .INCREASE:
1061+ 51AF ED 44            NEG
1062+ 51B1 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
1063+ 51B2 CD D0 51         CALL .SIZEDIFF
1064+ 51B5 CD DF 4F         CALL MAXANIMITEMS.INCREASE_COMMON
1065+ 51B8 AF               XOR A
1066+ 51B9 ED 42            SBC HL,BC ; location of new stuff
1067+ 51BB F1               POP AF
1068+ 51BC C5               PUSH BC
1069+ 51BD 47               LD B,A
1070+ 51BE 11 18 00         LD DE,24
1071+ 51C1 E5               PUSH HL
1072+ 51C2 DD E1            POP IX
1073+ 51C4              .L1:
1074+ 51C4 DD 36 13 00      LD (IX+19),0 ; active flag
1075+ 51C8 DD 19            ADD IX,DE
1076+ 51CA 10 F8            DJNZ .L1
1077+ 51CC C1               POP BC
1078+ 51CD C3 76 4F         JP MAXANIMITEMS.EXIT
1079+ 51D0              .SIZEDIFF:
1080+ 51D0 26 00            LD H,0
1081+ 51D2 6F               LD L,A
1082+ 51D3 CD BB 5F         CALL HLx8
1083+ 51D6 54               LD D,H
1084+ 51D7 5D               LD E,L
1085+ 51D8 29               ADD HL,HL
1086+ 51D9 19               ADD HL,DE
1087+ 51DA 78               LD A,B
1088+ 51DB 32 00 4F         LD (AUTOSGAMNUM),A
1089+ 51DE 44               LD B,H
1090+ 51DF 4D               LD C,L
1091+ 51E0 C9               RET ; BC=size difference in bytes
1092+ 51E1              ; *******************************************************************************************************
1093+ 51E1
1094+ 51E1               IF (0 == 1)
1095+ 51E1 ~            ; *******************************************************************************************************
1096+ 51E1 ~            ; function to handle CALL AUTOSGAMDEF basic extension
1097+ 51E1 ~            ; AUTOSGAMDEF ( BYTE id,
1098+ 51E1 ~            ;               INT VARIABLE x, INT VARIABLE y,
1099+ 51E1 ~            ;               INT minimum, INT maximum, INT delta,
1100+ 51E1 ~            ;               INT direction =0 horizontal,
1101+ 51E1 ~            ;               INT ticks,
1102+ 51E1 ~            ;               BYTE sprite_group_count,
1103+ 51E1 ~            ;               INT[2][sprite_group_count] VARIABLE sprite_group,
1104+ 51E1 ~            ;               BYTE item_number,
1105+ 51E1 ~            ;               INT[] VARIABLE sprite_animations_negative_direction,
1106+ 51E1 ~            ;               INT[] VARIABLE sprite_animations_positive_direction
1107+ 51E1 ~            AUTOSGAMDEF:
1108+ 51E1 ~                ; opening (
1109+ 51E1 ~            	CALL CHKCHAR
1110+ 51E1 ~            	DB '('
1111+ 51E1 ~            	; get sprite animation id
1112+ 51E1 ~            	LD IX, GETBYT
1113+ 51E1 ~            	CALL CALBAS
1114+ 51E1 ~                PUSH AF
1115+ 51E1 ~                INC A
1116+ 51E1 ~                LD C,A
1117+ 51E1 ~                LD A,(AUTOSGAMNUM)
1118+ 51E1 ~                CP C
1119+ 51E1 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
1120+ 51E1 ~                POP AF
1121+ 51E1 ~                PUSH HL
1122+ 51E1 ~                CALL GETnthAUTOSGAM
1123+ 51E1 ~                LD (BLIT_TMP),HL ; for later
1124+ 51E1 ~                POP HL
1125+ 51E1 ~            	; comma
1126+ 51E1 ~            	CALL CHKCHAR
1127+ 51E1 ~            	DB ','
1128+ 51E1 ~            	; get address of the X coordinate variable
1129+ 51E1 ~            	LD IX, PTRGET
1130+ 51E1 ~            	CALL CALBAS
1131+ 51E1 ~            	LD IX,(BLIT_TMP)
1132+ 51E1 ~                LD (IX+0),E
1133+ 51E1 ~                LD (IX+1),D
1134+ 51E1 ~            	; comma
1135+ 51E1 ~            	CALL CHKCHAR
1136+ 51E1 ~            	DB ','
1137+ 51E1 ~            	; get address of the Y coordinate variable
1138+ 51E1 ~            	LD IX, PTRGET
1139+ 51E1 ~            	CALL CALBAS
1140+ 51E1 ~            	LD IX,(BLIT_TMP)
1141+ 51E1 ~                LD (IX+2),E
1142+ 51E1 ~                LD (IX+3),D
1143+ 51E1 ~            	; comma
1144+ 51E1 ~            	CALL CHKCHAR
1145+ 51E1 ~            	DB ','
1146+ 51E1 ~            	; get minimum value
1147+ 51E1 ~            	LD IX, FRMQNT
1148+ 51E1 ~            	CALL CALBAS
1149+ 51E1 ~            	LD IX,(BLIT_TMP)
1150+ 51E1 ~                LD (IX+4),E
1151+ 51E1 ~                LD (IX+5),D
1152+ 51E1 ~            	; comma
1153+ 51E1 ~            	CALL CHKCHAR
1154+ 51E1 ~            	DB ','
1155+ 51E1 ~            	; get maximum value
1156+ 51E1 ~            	LD IX, FRMQNT
1157+ 51E1 ~            	CALL CALBAS
1158+ 51E1 ~            	LD IX,(BLIT_TMP)
1159+ 51E1 ~                LD (IX+6),E
1160+ 51E1 ~                LD (IX+7),D
1161+ 51E1 ~            	; comma
1162+ 51E1 ~            	CALL CHKCHAR
1163+ 51E1 ~            	DB ','
1164+ 51E1 ~            	; get delta value
1165+ 51E1 ~            	LD IX, FRMQNT
1166+ 51E1 ~            	CALL CALBAS
1167+ 51E1 ~            	LD IX,(BLIT_TMP)
1168+ 51E1 ~                LD (IX+8),E
1169+ 51E1 ~                LD (IX+9),D
1170+ 51E1 ~            	; comma
1171+ 51E1 ~            	CALL CHKCHAR
1172+ 51E1 ~            	DB ','
1173+ 51E1 ~            	; get direction value
1174+ 51E1 ~            	LD IX, FRMQNT
1175+ 51E1 ~            	CALL CALBAS
1176+ 51E1 ~            	LD IX,(BLIT_TMP)
1177+ 51E1 ~                LD (IX+10),E
1178+ 51E1 ~            	; comma
1179+ 51E1 ~            	CALL CHKCHAR
1180+ 51E1 ~            	DB ','
1181+ 51E1 ~            	; get ticks value
1182+ 51E1 ~            	LD IX, FRMQNT
1183+ 51E1 ~            	CALL CALBAS
1184+ 51E1 ~            	LD IX,(BLIT_TMP)
1185+ 51E1 ~                LD (IX+20),E
1186+ 51E1 ~                LD (IX+21),D
1187+ 51E1 ~            	; comma
1188+ 51E1 ~            	CALL CHKCHAR
1189+ 51E1 ~            	DB ','
1190+ 51E1 ~            	; get sprite group count
1191+ 51E1 ~            	LD IX, GETBYT
1192+ 51E1 ~            	CALL CALBAS
1193+ 51E1 ~                OR A
1194+ 51E1 ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
1195+ 51E1 ~            	LD IX,(BLIT_TMP)
1196+ 51E1 ~                LD (IX+11),A
1197+ 51E1 ~            	; comma
1198+ 51E1 ~            	CALL CHKCHAR
1199+ 51E1 ~            	DB ','
1200+ 51E1 ~            	; get sprite group definition array data pointer
1201+ 51E1 ~            	LD IX,(BLIT_TMP)
1202+ 51E1 ~                LD E,(IX+11)
1203+ 51E1 ~            	LD D,3
1204+ 51E1 ~            	LD A,2
1205+ 51E1 ~            	LD B,A
1206+ 51E1 ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
1207+ 51E1 ~            	LD IX,(BLIT_TMP)
1208+ 51E1 ~            	LD (IX+12),C
1209+ 51E1 ~                LD (IX+13),B
1210+ 51E1 ~            	; comma
1211+ 51E1 ~            	CALL CHKCHAR
1212+ 51E1 ~            	DB ','
1213+ 51E1 ~            	; get sprite animation array size
1214+ 51E1 ~            	LD IX,GETBYT
1215+ 51E1 ~            	CALL CALBAS
1216+ 51E1 ~            	LD IX,(BLIT_TMP)
1217+ 51E1 ~                LD (IX+14),A
1218+ 51E1 ~                OR A
1219+ 51E1 ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
1220+ 51E1 ~            	; comma
1221+ 51E1 ~            	CALL CHKCHAR
1222+ 51E1 ~            	DB ','
1223+ 51E1 ~                ; get array pointer for negative direction
1224+ 51E1 ~            	LD IX,(BLIT_TMP)
1225+ 51E1 ~                LD D,(IX+14)
1226+ 51E1 ~                LD A,2
1227+ 51E1 ~                LD B,1
1228+ 51E1 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
1229+ 51E1 ~            	LD IX,(BLIT_TMP)
1230+ 51E1 ~                LD (IX+15),C
1231+ 51E1 ~                LD (IX+16),B
1232+ 51E1 ~            	; comma
1233+ 51E1 ~            	CALL CHKCHAR
1234+ 51E1 ~            	DB ','
1235+ 51E1 ~                ; get array pointer for positive direction
1236+ 51E1 ~            	LD IX,(BLIT_TMP)
1237+ 51E1 ~                LD D,(IX+14)
1238+ 51E1 ~                LD A,2
1239+ 51E1 ~                LD B,1
1240+ 51E1 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
1241+ 51E1 ~            	LD IX,(BLIT_TMP)
1242+ 51E1 ~                LD (IX+17),C
1243+ 51E1 ~                LD (IX+18),B
1244+ 51E1 ~            	; ending )
1245+ 51E1 ~            	CALL CHKCHAR
1246+ 51E1 ~            	DB ')'
1247+ 51E1 ~                RET
1248+ 51E1 ~            ; *******************************************************************************************************
1249+ 51E1               ENDIF
1250+ 51E1
1251+ 51E1               IF (1 == 1)
1252+ 51E1              ; *******************************************************************************************************
1253+ 51E1              ; same as AUTOSGAMDEF but for DEFUSR approach
1254+ 51E1              ; input IX=pointer to input array, real data from +2
1255+ 51E1              ; +02 = ID
1256+ 51E1              ; +04 = pointer to X variable
1257+ 51E1              ; +06 = pointer to Y variable
1258+ 51E1              ; +08 = minimum
1259+ 51E1              ; +10 = maximum
1260+ 51E1              ; +12 = delta
1261+ 51E1              ; +14 = direction
1262+ 51E1              ; +16 = ticks
1263+ 51E1              ; +18 = sprite group count
1264+ 51E1              ; +20 = sprite group array pointer
1265+ 51E1              ; +22 = item number
1266+ 51E1              ; +24 = sprite animations negative direction array pointer
1267+ 51E1              ; +26 = sprite animations positive direction array pointer
1268+ 51E1              AUTOSGAMDEF_DEFUSR:
1269+ 51E1 DD 4E 02         LD C,(IX+2)
1270+ 51E4 0C               INC C
1271+ 51E5 3A 00 4F         LD A,(AUTOSGAMNUM)
1272+ 51E8 B9               CP C
1273+ 51E9 DA 74 52         JP C,.ERR ; invalid id
1274+ 51EC 79               LD A,C
1275+ 51ED 3D               DEC A
1276+ 51EE CD 2D 4F         CALL GETnthAUTOSGAM
1277+ 51F1 E5               PUSH HL
1278+ 51F2 FD E1            POP IY
1279+ 51F4                  ; X variable
1280+ 51F4 DD 7E 04         LD A,(IX+4)
1281+ 51F7 FD 77 00         LD (IY+0),A
1282+ 51FA DD 7E 05         LD A,(IX+5)
1283+ 51FD FD 77 01         LD (IY+1),A
1284+ 5200              	; Y variable
1285+ 5200 DD 7E 06         LD A,(IX+6)
1286+ 5203 FD 77 02         LD (IY+2),A
1287+ 5206 DD 7E 07         LD A,(IX+7)
1288+ 5209 FD 77 03         LD (IY+3),A
1289+ 520C              	; get minimum value
1290+ 520C DD 7E 08         LD A,(IX+8)
1291+ 520F FD 77 04         LD (IY+4),A
1292+ 5212 DD 7E 09         LD A,(IX+9)
1293+ 5215 FD 77 05         LD (IY+5),A
1294+ 5218              	; get maximum value
1295+ 5218 DD 7E 0A         LD A,(IX+10)
1296+ 521B FD 77 06         LD (IY+6),A
1297+ 521E DD 7E 0B         LD A,(IX+11)
1298+ 5221 FD 77 07         LD (IY+7),A
1299+ 5224              	; get delta value
1300+ 5224 DD 7E 0C         LD A,(IX+12)
1301+ 5227 FD 77 08         LD (IY+8),A
1302+ 522A DD 7E 0D         LD A,(IX+13)
1303+ 522D FD 77 09         LD (IY+9),A
1304+ 5230              	; get direction value
1305+ 5230 DD 7E 0E         LD A,(IX+14)
1306+ 5233 FD 77 0A         LD (IY+10),A
1307+ 5236              	; get ticks value
1308+ 5236 DD 7E 10         LD A,(IX+16)
1309+ 5239 FD 77 14         LD (IY+20),A
1310+ 523C DD 7E 11         LD A,(IX+17)
1311+ 523F FD 77 15         LD (IY+21),A
1312+ 5242              	; get sprite group count
1313+ 5242 DD 7E 12         LD A,(IX+18)
1314+ 5245 FD 77 0B         LD (IY+11),A
1315+ 5248              	; get sprite group definition array data pointer
1316+ 5248 DD 7E 14         LD A,(IX+20)
1317+ 524B FD 77 0C         LD (IY+12),A
1318+ 524E DD 7E 15         LD A,(IX+21)
1319+ 5251 FD 77 0D         LD (IY+13),A
1320+ 5254              	; get sprite animation array size
1321+ 5254 DD 7E 16         LD A,(IX+22)
1322+ 5257 FD 77 0E         LD (IY+14),A
1323+ 525A                  ; get array pointer for negative direction
1324+ 525A DD 7E 18         LD A,(IX+24)
1325+ 525D FD 77 0F         LD (IY+15),A
1326+ 5260 DD 7E 19         LD A,(IX+25)
1327+ 5263 FD 77 10         LD (IY+16),A
1328+ 5266                  ; get array pointer for positive direction
1329+ 5266 DD 7E 1A         LD A,(IX+26)
1330+ 5269 FD 77 11         LD (IY+17),A
1331+ 526C DD 7E 1B         LD A,(IX+27)
1332+ 526F FD 77 12         LD (IY+18),A
1333+ 5272 AF               XOR A ; success
1334+ 5273 C9               RET
1335+ 5274              .ERR:
1336+ 5274 3E 01            LD A,1
1337+ 5276 C9               RET
1338+ 5277              ; *******************************************************************************************************
1339+ 5277               ENDIF
1340+ 5277
1341+ 5277               IF (0 == 1)
1342+ 5277 ~            ; *******************************************************************************************************
1343+ 5277 ~            ; function to handle CALL AUTOSGAMSTART basic extension
1344+ 5277 ~            ; AUTOSGAMSTART ( BYTE id )
1345+ 5277 ~            AUTOSGAMSTART:
1346+ 5277 ~                LD A,1
1347+ 5277 ~            .COMMON:
1348+ 5277 ~                LD (.SETVALUE+3),A
1349+ 5277 ~                ; opening (
1350+ 5277 ~            	CALL CHKCHAR
1351+ 5277 ~            	DB '('
1352+ 5277 ~            	; get sprite animation id
1353+ 5277 ~            	LD IX, GETBYT
1354+ 5277 ~            	CALL CALBAS
1355+ 5277 ~                PUSH AF
1356+ 5277 ~                INC A
1357+ 5277 ~                LD C,A
1358+ 5277 ~                LD A,(AUTOSGAMNUM)
1359+ 5277 ~                CP C
1360+ 5277 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
1361+ 5277 ~                POP AF
1362+ 5277 ~                PUSH HL
1363+ 5277 ~                CALL GETnthAUTOSGAM
1364+ 5277 ~                PUSH HL
1365+ 5277 ~                POP IX
1366+ 5277 ~                POP HL
1367+ 5277 ~                PUSH IX
1368+ 5277 ~            	; ending )
1369+ 5277 ~            	CALL CHKCHAR
1370+ 5277 ~            	DB ')'
1371+ 5277 ~
1372+ 5277 ~                ; so syntax is fine
1373+ 5277 ~                POP IX
1374+ 5277 ~            .SETVALUE:
1375+ 5277 ~                LD (IX+19),1 ; active flag
1376+ 5277 ~                ; set initial timer
1377+ 5277 ~                LD A,(IX+20)
1378+ 5277 ~                LD (IX+22),A
1379+ 5277 ~                LD A,(IX+21)
1380+ 5277 ~                LD (IX+23),A
1381+ 5277 ~                RET
1382+ 5277 ~            ; *******************************************************************************************************
1383+ 5277 ~
1384+ 5277 ~            ; *******************************************************************************************************
1385+ 5277 ~            ; function to handle CALL AUTOSGAMSTOP basic extension
1386+ 5277 ~            ; AUTOSGAMSTOP ( BYTE id )
1387+ 5277 ~            AUTOSGAMSTOP:
1388+ 5277 ~                XOR A
1389+ 5277 ~                JR AUTOSGAMSTART.COMMON
1390+ 5277 ~            ; *******************************************************************************************************
1391+ 5277               ENDIF
1392+ 5277
1393+ 5277               IF (1 == 1)
1394+ 5277              ; *******************************************************************************************************
1395+ 5277              ; function to handle CALL AUTOSGAMSTART basic extension in DEFUSR mode
1396+ 5277              ; input IX=pointer to input array, real data from +2
1397+ 5277              ; +2 = source address
1398+ 5277              AUTOSGAMSTART_DEFUSR:
1399+ 5277 3E 01            LD A,1
1400+ 5279              .COMMON:
1401+ 5279 32 91 52         LD (.SETVALUE+3),A
1402+ 527C DD 4E 02         LD C,(IX+2)
1403+ 527F 0C               INC C
1404+ 5280 3A 00 4F         LD A,(AUTOSGAMNUM)
1405+ 5283 B9               CP C
1406+ 5284 38 1A            JR C,.ERR ; invalid id
1407+ 5286 79               LD A,C
1408+ 5287 3D               DEC A
1409+ 5288 CD 2D 4F         CALL GETnthAUTOSGAM
1410+ 528B E5               PUSH HL
1411+ 528C DD E1            POP IX
1412+ 528E              .SETVALUE:
1413+ 528E DD 36 13 01      LD (IX+19),1 ; active flag
1414+ 5292                  ; set initial timer
1415+ 5292 DD 7E 14         LD A,(IX+20)
1416+ 5295 DD 77 16         LD (IX+22),A
1417+ 5298 DD 7E 15         LD A,(IX+21)
1418+ 529B DD 77 17         LD (IX+23),A
1419+ 529E AF               XOR A ; success
1420+ 529F C9               RET
1421+ 52A0              .ERR:
1422+ 52A0 3E 01            LD A,1
1423+ 52A2 C9               RET
1424+ 52A3              ; *******************************************************************************************************
1425+ 52A3
1426+ 52A3              ; *******************************************************************************************************
1427+ 52A3              ; function to handle CALL AUTOSGAMSTOP basic extension in DEFUSR mode
1428+ 52A3              ; input IX=pointer to input array, real data from +2
1429+ 52A3              ; +2 = source address
1430+ 52A3              AUTOSGAMSTOP_DEFUSR:
1431+ 52A3 AF               XOR A
1432+ 52A4 18 D3            JR AUTOSGAMSTART_DEFUSR.COMMON
1433+ 52A6              ; *******************************************************************************************************
1434+ 52A6               ENDIF
1435+ 52A6
1436+ 52A6               IF (0 == 1)
1437+ 52A6 ~            ; *******************************************************************************************************
1438+ 52A6 ~            ; function to handle CALL ANIMSTEP basic extension
1439+ 52A6 ~            ; two forms
1440+ 52A6 ~            ; ANIMSTEP ( BYTE id )
1441+ 52A6 ~            ; or
1442+ 52A6 ~            ; ANIMSTEP ( BYTE item_number,
1443+ 52A6 ~            ;            INT[] sprite_animations )
1444+ 52A6 ~            ANIMSTEP:
1445+ 52A6 ~                LD DE,ANIMSTARTSTOP_COMMON.STEP
1446+ 52A6 ~                JR ANIMSTARTSTOP_COMMON
1447+ 52A6 ~            ; *******************************************************************************************************
1448+ 52A6 ~            ; *******************************************************************************************************
1449+ 52A6 ~            ; function to handle CALL ANIMSTART basic extension
1450+ 52A6 ~            ; two forms
1451+ 52A6 ~            ; ANIMSTART ( BYTE id )
1452+ 52A6 ~            ; or
1453+ 52A6 ~            ; ANIMSTART ( BYTE item_number,
1454+ 52A6 ~            ;             INT[] sprite_animations )
1455+ 52A6 ~            ; sets active flag to 1
1456+ 52A6 ~            ANIMSTART:
1457+ 52A6 ~                LD DE,ANIMSTARTSTOP_COMMON.START
1458+ 52A6 ~                JR ANIMSTARTSTOP_COMMON
1459+ 52A6 ~            ; *******************************************************************************************************
1460+ 52A6 ~            ; *******************************************************************************************************
1461+ 52A6 ~            ; function to handle CALL ANIMSTOP basic extension
1462+ 52A6 ~            ; two forms
1463+ 52A6 ~            ; ANIMSTOP ( BYTE id )
1464+ 52A6 ~            ; or
1465+ 52A6 ~            ; ANIMSTOP ( BYTE item_number,
1466+ 52A6 ~            ;            INT[] sprite_animations )
1467+ 52A6 ~            ; sets active flag to 0
1468+ 52A6 ~            ANIMSTOP:
1469+ 52A6 ~                LD DE,ANIMSTARTSTOP_COMMON.STOP
1470+ 52A6 ~            ; *******************************************************************************************************
1471+ 52A6 ~            ANIMSTARTSTOP_COMMON:
1472+ 52A6 ~                LD (ANIMSTARTSTOP_COMMON.FN+1),DE
1473+ 52A6 ~                ; opening (
1474+ 52A6 ~            	CALL CHKCHAR
1475+ 52A6 ~            	DB '('
1476+ 52A6 ~            	; get sprite animation id or array size
1477+ 52A6 ~            	LD IX,GETBYT
1478+ 52A6 ~            	CALL CALBAS
1479+ 52A6 ~                PUSH AF
1480+ 52A6 ~                ; check if comma present
1481+ 52A6 ~                CALL GETPREVCHAR
1482+ 52A6 ~                INC HL
1483+ 52A6 ~                CP ','
1484+ 52A6 ~                JR Z,.L1
1485+ 52A6 ~                CP ')'
1486+ 52A6 ~                JP NZ,SYNTAX_ERROR
1487+ 52A6 ~                ; ok so single argument variant
1488+ 52A6 ~                POP AF
1489+ 52A6 ~                PUSH HL
1490+ 52A6 ~                DI
1491+ 52A6 ~                CALL .SETVALUE
1492+ 52A6 ~                EI
1493+ 52A6 ~                POP HL
1494+ 52A6 ~                RET
1495+ 52A6 ~            .L1:
1496+ 52A6 ~                ; get array pointer
1497+ 52A6 ~                POP DE
1498+ 52A6 ~                PUSH DE
1499+ 52A6 ~                LD A,2
1500+ 52A6 ~                LD B,1
1501+ 52A6 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
1502+ 52A6 ~                PUSH BC
1503+ 52A6 ~            	; ending )
1504+ 52A6 ~            	CALL CHKCHAR
1505+ 52A6 ~            	DB ')'
1506+ 52A6 ~                POP DE ; array pointer
1507+ 52A6 ~                POP BC ; number of items
1508+ 52A6 ~                LD A,B
1509+ 52A6 ~                OR A
1510+ 52A6 ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
1511+ 52A6 ~                PUSH HL
1512+ 52A6 ~                DI
1513+ 52A6 ~            .L2:
1514+ 52A6 ~                PUSH BC
1515+ 52A6 ~                LD A,(DE)
1516+ 52A6 ~                .2 INC DE
1517+ 52A6 ~                PUSH DE
1518+ 52A6 ~                CALL .SETVALUE
1519+ 52A6 ~                POP DE
1520+ 52A6 ~                POP BC
1521+ 52A6 ~                DJNZ .L2
1522+ 52A6 ~                EI
1523+ 52A6 ~                POP HL
1524+ 52A6 ~                RET
1525+ 52A6 ~
1526+ 52A6 ~            .SETVALUE:
1527+ 52A6 ~                LD B,A
1528+ 52A6 ~                INC A
1529+ 52A6 ~                LD C,A
1530+ 52A6 ~                LD A,(ANIMSPRNUM)
1531+ 52A6 ~                CP C
1532+ 52A6 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
1533+ 52A6 ~                LD A,B
1534+ 52A6 ~                CALL GETnthSPRANIM
1535+ 52A6 ~                PUSH HL
1536+ 52A6 ~                POP IX
1537+ 52A6 ~            .FN:
1538+ 52A6 ~                JP 0
1539+ 52A6 ~            .START:
1540+ 52A6 ~                LD (IX+6),1 ; active flag
1541+ 52A6 ~                LD (IX+3),0 ; current item
1542+ 52A6 ~                LD B,0 ; setup timer
1543+ 52A6 ~                JP SETUP_ANIM_STEP
1544+ 52A6 ~            .STOP:
1545+ 52A6 ~                LD (IX+6),0 ; active flag
1546+ 52A6 ~                RET
1547+ 52A6 ~            .STEP:
1548+ 52A6 ~                LD B,0
1549+ 52A6 ~                JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1550+ 52A6 ~            ; *******************************************************************************************************
1551+ 52A6               ENDIF
1552+ 52A6
1553+ 52A6              ; *******************************************************************************************************
1554+ 52A6              ; helper function to locate single animation and execute operation
1555+ 52A6              ; needs to have jump set to a correct function
1556+ 52A6              ; used by SGAM helper routines so always needed
1557+ 52A6              ; input A=animation item
1558+ 52A6              ANIM_SETVALUE:
1559+ 52A6 47               LD B,A
1560+ 52A7 3C               INC A
1561+ 52A8 4F               LD C,A
1562+ 52A9 3A FD 4E         LD A,(ANIMSPRNUM)
1563+ 52AC B9               CP C
1564+ 52AD D8               RET C ; out of range, so do nothing
1565+ 52AE 78               LD A,B
1566+ 52AF CD 21 4F         CALL GETnthSPRANIM
1567+ 52B2 E5               PUSH HL
1568+ 52B3 DD E1            POP IX
1569+ 52B5              .FN:
1570+ 52B5 C3 00 00         JP 0
1571+ 52B8              ; *******************************************************************************************************
1572+ 52B8
1573+ 52B8               IF (1 == 1)
1574+ 52B8              ; *******************************************************************************************************
1575+ 52B8              ; helper function to set values of multiple animations
1576+ 52B8              ; needs to have jump set to a correct function
1577+ 52B8              ; input B=number of animation item
1578+ 52B8              ; input DE=animation item array
1579+ 52B8              ANIM_LIST_SETVALUE:
1580+ 52B8 F3               DI
1581+ 52B9 C5               PUSH BC
1582+ 52BA 1A               LD A,(DE)
1583+ 52BB 13          > INC DE
1583+ 52BC 13          > INC DE
1584+ 52BD D5               PUSH DE
1585+ 52BE CD A6 52         CALL ANIM_SETVALUE
1586+ 52C1 D1               POP DE
1587+ 52C2 C1               POP BC
1588+ 52C3 10 F3            DJNZ ANIM_LIST_SETVALUE
1589+ 52C5 FB               EI
1590+ 52C6 C9               RET
1591+ 52C7              ; *******************************************************************************************************
1592+ 52C7
1593+ 52C7              ; *******************************************************************************************************
1594+ 52C7              ; function to handle single item ANIMSTEP in DEFUSR mode
1595+ 52C7              ; input IX=pointer to input array, real data from +2
1596+ 52C7              ; +2 = animation id
1597+ 52C7              ANIMSTEP_SINGLE_DEFUSR:
1598+ 52C7 21 D2 52         LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1599+ 52CA              .L1:
1600+ 52CA 22 B6 52         LD (ANIM_SETVALUE.FN+1),HL
1601+ 52CD DD 7E 02         LD A,(IX+2)
1602+ 52D0 18 D4            JR ANIM_SETVALUE
1603+ 52D2              .STEP:
1604+ 52D2 06 00            LD B,0
1605+ 52D4 C3 2C 53         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1606+ 52D7              ; *******************************************************************************************************
1607+ 52D7
1608+ 52D7              ; *******************************************************************************************************
1609+ 52D7              ; function to handle multi item ANIMSTEP in DEFUSR mode
1610+ 52D7              ; input IX=pointer to input array, real data from +2
1611+ 52D7              ; +2 = list size
1612+ 52D7              ; +4 = array pointer holding items
1613+ 52D7              ANIMSTEP_MULTI_DEFUSR:
1614+ 52D7 21 D2 52         LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1615+ 52DA              .L1:
1616+ 52DA 22 B6 52         LD (ANIM_SETVALUE.FN+1),HL
1617+ 52DD DD 46 02         LD B,(IX+2)
1618+ 52E0 DD 5E 04         LD E,(IX+4)
1619+ 52E3 DD 56 05         LD D,(IX+5)
1620+ 52E6 18 D0            JR ANIM_LIST_SETVALUE
1621+ 52E8              ; *******************************************************************************************************
1622+ 52E8
1623+ 52E8              ; *******************************************************************************************************
1624+ 52E8              ; function to handle single item ANIMSTART in DEFUSR mode
1625+ 52E8              ; input IX=pointer to input array, real data from +2
1626+ 52E8              ; +2 = animation id
1627+ 52E8              ANIMSTART_SINGLE_DEFUSR:
1628+ 52E8 21 ED 52         LD HL,ANIMSTART_SINGLE_DEFUSR.START
1629+ 52EB 18 DD            JR ANIMSTEP_SINGLE_DEFUSR.L1
1630+ 52ED              .START:
1631+ 52ED DD 36 06 01      LD (IX+6),1 ; active flag
1632+ 52F1 DD 36 03 00      LD (IX+3),0 ; current item
1633+ 52F5 06 00            LD B,0 ; setup timer
1634+ 52F7 C3 88 53         JP SETUP_ANIM_STEP
1635+ 52FA              ; *******************************************************************************************************
1636+ 52FA
1637+ 52FA              ; *******************************************************************************************************
1638+ 52FA              ; function to handle multi item ANIMSTART in DEFUSR mode
1639+ 52FA              ; input IX=pointer to input array, real data from +2
1640+ 52FA              ; +2 = list size
1641+ 52FA              ; +4 = array pointer holding items
1642+ 52FA              ANIMSTART_MULTI_DEFUSR:
1643+ 52FA 21 ED 52         LD HL,ANIMSTART_SINGLE_DEFUSR.START
1644+ 52FD 18 DB            JR ANIMSTEP_MULTI_DEFUSR.L1
1645+ 52FF              ; *******************************************************************************************************
1646+ 52FF
1647+ 52FF              ; *******************************************************************************************************
1648+ 52FF              ; function to handle single item ANIMSTOP in DEFUSR mode
1649+ 52FF              ; input IX=pointer to input array, real data from +2
1650+ 52FF              ; +2 = animation id
1651+ 52FF              ANIMSTOP_SINGLE_DEFUSR:
1652+ 52FF 21 04 53         LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1653+ 5302 18 C6            JR ANIMSTEP_SINGLE_DEFUSR.L1
1654+ 5304              .STOP:
1655+ 5304 DD 36 06 00      LD (IX+6),0 ; active flag
1656+ 5308 C9               RET
1657+ 5309              ; *******************************************************************************************************
1658+ 5309
1659+ 5309              ; *******************************************************************************************************
1660+ 5309              ; function to handle multi item ANIMSTOP in DEFUSR mode
1661+ 5309              ; input IX=pointer to input array, real data from +2
1662+ 5309              ; +2 = list size
1663+ 5309              ; +4 = array pointer holding items
1664+ 5309              ANIMSTOP_MULTI_DEFUSR:
1665+ 5309 21 04 53         LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1666+ 530C 18 CC            JR ANIMSTEP_MULTI_DEFUSR.L1
1667+ 530E              ; *******************************************************************************************************
1668+ 530E               ENDIF
1669+ 530E
1670+ 530E              ; *******************************************************************************************************
1671+ 530E              ; function processes animations during vblank period
1672+ 530E              PROCESS_ANIMATIONS:
1673+ 530E 3A FD 4E         LD A,(ANIMSPRNUM)
1674+ 5311 B7               OR A
1675+ 5312 C8               RET Z; no animations defined
1676+ 5313 47               LD B,A
1677+ 5314 DD 2A FE 4E      LD IX,(ANIMSPRPTR)
1678+ 5318              .L1:
1679+ 5318 C5               PUSH BC
1680+ 5319 06 00            LD B,0 ; normal mode, change on timer expiry only
1681+ 531B CD 27 53         CALL PROCESS_SINGLE_ANIMATION
1682+ 531E 11 08 00         LD DE,8
1683+ 5321 DD 19            ADD IX,DE
1684+ 5323 C1               POP BC
1685+ 5324 10 F2            DJNZ .L1
1686+ 5326 C9               RET
1687+ 5327              ; *******************************************************************************************************
1688+ 5327
1689+ 5327              ; *******************************************************************************************************
1690+ 5327              ; processes single sprite animation
1691+ 5327              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
1692+ 5327              ; on timer expiry goes to next animation item
1693+ 5327              ; input IX=sprite animation pointer
1694+ 5327              ; input B=1 force mode, activate animation action regardless of expired timer
1695+ 5327              PROCESS_SINGLE_ANIMATION:
1696+ 5327 DD 7E 06         LD A,(IX+6); active
1697+ 532A B7               OR A
1698+ 532B C8               RET Z ; inactive animation
1699+ 532C              .INACTIVE_TOO:
1700+ 532C DD 6E 01         LD L,(IX+1)
1701+ 532F DD 66 02         LD H,(IX+2) ; HL=end time
1702+ 5332 2B               DEC HL
1703+ 5333 DD 75 01         LD (IX+1),L
1704+ 5336 DD 74 02         LD (IX+2),H
1705+ 5339 7D               LD A,L
1706+ 533A B4               OR H
1707+ 533B 28 06            JR Z,.STEP
1708+ 533D 05               DEC B
1709+ 533E 04               INC B
1710+ 533F C8               RET Z ; not forced mode, return
1711+ 5340 C3 88 53         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
1712+ 5343              .STEP:
1713+ 5343 06 00            LD B,0; setup timer
1714+ 5345 DD 34 03         INC (IX+3) ; current animation item
1715+ 5348 C3 88 53         JP SETUP_ANIM_STEP
1716+ 534B              ; *******************************************************************************************************
1717+ 534B
1718+ 534B              ; *******************************************************************************************************
1719+ 534B              ; function will setup sprite animation after current item change
1720+ 534B              ; input A=current animation definition
1721+ 534B              ; input IX=pointer to sprite animation
1722+ 534B              ; input B=1 skip timer setup
1723+ 534B              ; output IY=pointer to animation item
1724+ 534B              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
1725+ 534B              ; basically sets new end time for current animation
1726+ 534B              INIT_CURRENT_ANIMATION:
1727+ 534B CD 15 4F         CALL GETnthANIMDEF
1728+ 534E DD 7E 03         LD A,(IX+3) ; current animation item
1729+ 5351 BE               CP (HL) ; number of animation items in the animation definition
1730+ 5352 38 0A            JR C,.L3 ; last item not reached
1731+ 5354                  ; last item reached
1732+ 5354 DD 7E 05         LD A,(IX+5) ; cyclic flag
1733+ 5357 B7               OR A
1734+ 5358 28 2C            JR Z,.ERROR ; non-cyclic animation
1735+ 535A                  ; cyclic animation, restart
1736+ 535A DD 36 03 00      LD (IX+3),0; current item
1737+ 535E              .L3:
1738+ 535E                  ; HL = animation definition
1739+ 535E 23               INC HL ; skip animation definition size field
1740+ 535F 16 00            LD D,0
1741+ 5361 DD 5E 03         LD E,(IX+3); current item
1742+ 5364 19               ADD HL,DE
1743+ 5365 4E               LD C,(HL) ; current animation item
1744+ 5366 0C               INC C
1745+ 5367 3A F7 4E         LD A,(ANIMITEMNUM)
1746+ 536A B9               CP C
1747+ 536B 38 19            JR C,.ERROR ; invalid animation item, stop animation
1748+ 536D 0D               DEC C
1749+ 536E 79               LD A,C
1750+ 536F CD 0C 4F         CALL GETnthANIMITEM
1751+ 5372 E5               PUSH HL
1752+ 5373 FD E1            POP IY ; IY=animation item
1753+ 5375 05               DEC B
1754+ 5376 28 0C            JR Z,.EXIT
1755+ 5378 FD 5E 01         LD E,(IY+1)
1756+ 537B FD 56 02         LD D,(IY+2) ; duration
1757+ 537E DD 73 01         LD (IX+1),E
1758+ 5381 DD 72 02         LD (IX+2),D
1759+ 5384              .EXIT:
1760+ 5384 AF               XOR A
1761+ 5385 C9               RET
1762+ 5386              .ERROR:
1763+ 5386 37               SCF
1764+ 5387 C9               RET
1765+ 5388              ; *******************************************************************************************************
1766+ 5388
1767+ 5388              ; *******************************************************************************************************
1768+ 5388              ; function will display currect item and set up expiry time
1769+ 5388              ; it will also stop the animation if expired
1770+ 5388              ; sets sprite update flag if any changes in sprite data made
1771+ 5388              ; input IX=current sprite animation
1772+ 5388              ; input B=1 skip timer setup
1773+ 5388              SETUP_ANIM_STEP:
1774+ 5388 DD 4E 04         LD C,(IX+4) ; animation definition ID
1775+ 538B 0C               INC C
1776+ 538C 3A FA 4E         LD A,(ANIMDEFNUM)
1777+ 538F B9               CP C
1778+ 5390 30 05            JR NC,.L2
1779+ 5392                  ; given animation item is outside of bounds, deactivate animation
1780+ 5392              .STOPANIM:
1781+ 5392 DD 36 06 00      LD (IX+6),0
1782+ 5396 C9               RET
1783+ 5397              .L2:
1784+ 5397 0D               DEC C
1785+ 5398 79               LD A,C
1786+ 5399 CD 4B 53         CALL INIT_CURRENT_ANIMATION
1787+ 539C 38 F4            JR C, .STOPANIM
1788+ 539E FD 7E 00         LD A,(IY) ; type of animation item
1789+ 53A1 B7               OR A
1790+ 53A2 28 44            JR Z,.L4 ; change pattern and/or color
1791+ 53A4              .PAT:
1792+ 53A4                  ; change pattern definition
1793+ 53A4                  ; check if sprite or character
1794+ 53A4 DD 7E 07         LD A,(IX+7)
1795+ 53A7 B7               OR A
1796+ 53A8 20 58            JR NZ,.CHAR
1797+ 53AA DD 7E 00         LD A,(IX) ; sprite number
1798+ 53AD CD 90 4D         CALL GETnthSPRATTR
1799+ 53B0 23          > INC HL ; skip y and x
1799+ 53B1 23          > INC HL
1799+ 53B2 23          > INC HL
1799+ 53B3 23          > INC HL
1800+ 53B4 7E               LD A,(HL); current pattern
1801+ 53B5 26 00            LD H,0
1802+ 53B7 6F               LD L,A
1803+ 53B8 3A E0 F3         LD A,(REG1SAV)
1804+ 53BB E6 02            AND 2
1805+ 53BD 20 07            JR NZ,.L6
1806+ 53BF                  ; 8x8 sprite
1807+ 53BF CD BB 5F         CALL HLx8
1808+ 53C2 06 08            LD B,8
1809+ 53C4 18 05            JR .L5
1810+ 53C6              .L6:
1811+ 53C6 CD B9 5F         CALL HLx32
1812+ 53C9 06 20            LD B,32
1813+ 53CB              .L5:
1814+ 53CB 3A AF FC         LD A,(SCRMOD)
1815+ 53CE 3D               DEC A
1816+ 53CF 20 06            JR NZ,.L10
1817+ 53D1 ED 5B C5 F3      LD DE,(T32PAT)
1818+ 53D5 18 04            JR .L7
1819+ 53D7              .L10:
1820+ 53D7 ED 5B CF F3      LD DE,(GRPPAT)
1821+ 53DB              .L7:
1822+ 53DB 19               ADD HL,DE
1823+ 53DC CD 9C 5F         CALL SETWRT_LOCAL_WRITE
1824+ 53DF FD 6E 03         LD L,(IY+3)
1825+ 53E2 FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
1826+ 53E5 C3 B1 5F         JP BBYTECOPY
1827+ 53E8              .L4:
1828+ 53E8                  ; change pattern and color in sprite attributes table
1829+ 53E8 DD 7E 00         LD A,(IX) ; sprite number
1830+ 53EB CD 90 4D         CALL GETnthSPRATTR
1831+ 53EE 23          > INC HL ; skip y and x
1831+ 53EF 23          > INC HL
1831+ 53F0 23          > INC HL
1831+ 53F1 23          > INC HL
1832+ 53F2 FD 7E 03         LD A,(IY+3) ; new pattern
1833+ 53F5 77               LD (HL),A
1834+ 53F6 23          > INC HL
1834+ 53F7 23          > INC HL
1835+ 53F8 FD 7E 04         LD A,(IY+4) ; new color
1836+ 53FB 77               LD (HL),A
1837+ 53FC 2A 87 4D         LD HL,(SPRATR_UPDATE_FLAG)
1838+ 53FF 36 01            LD (HL),1
1839+ 5401 C9               RET
1840+ 5402              .CHAR:
1841+ 5402 DD 6E 00         LD L,(IX)
1842+ 5405 3D               DEC A
1843+ 5406 67               LD H,A
1844+ 5407 CD BB 5F         CALL HLx8
1845+ 540A 3A AF FC         LD A,(SCRMOD)
1846+ 540D 3D               DEC A
1847+ 540E 20 06            JR NZ,.L8
1848+ 5410 ED 5B C1 F3      LD DE,(T32CGP)
1849+ 5414 18 04            JR .L9
1850+ 5416              .L8:
1851+ 5416 ED 5B CB F3      LD DE,(GRPCGP)
1852+ 541A              .L9:
1853+ 541A 06 08            LD B,8
1854+ 541C 18 BD            JR .L7
1855+ 541E              ; *******************************************************************************************************
1856+ 541E
# file closed: asm\ANIMATION.asm
 139  541E               INCLUDE "SGAM.asm"
# file opened: asm\SGAM.asm
   1+ 541E              ; Sprite Group Animate and Move
   2+ 541E
   3+ 541E              ; *******************************************************************************************************
   4+ 541E              ; shared function to process a list of animations
   5+ 541E              ; input B=list size
   6+ 541E              ; input DE=list pointer
   7+ 541E              SGAM_PROCESS_ANIM_LIST:
   8+ 541E 21 31 54         LD HL,.STEP
   9+ 5421 22 B6 52         LD (ANIM_SETVALUE.FN+1),HL
  10+ 5424              .L1:
  11+ 5424 C5               PUSH BC
  12+ 5425 1A               LD A,(DE)
  13+ 5426 13          > INC DE
  13+ 5427 13          > INC DE
  14+ 5428 D5               PUSH DE
  15+ 5429 CD A6 52         CALL ANIM_SETVALUE
  16+ 542C D1               POP DE
  17+ 542D C1               POP BC
  18+ 542E 10 F4            DJNZ .L1
  19+ 5430 C9           	RET
  20+ 5431              .STEP:
  21+ 5431 06 01            LD B,1
  22+ 5433 C3 2C 53         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
  23+ 5436              ; *******************************************************************************************************
  24+ 5436
  25+ 5436               IF (0 == 1)
  26+ 5436 ~            ; *******************************************************************************************************
  27+ 5436 ~            ; function to handle CALL SGAM basic extension
  28+ 5436 ~            ; sets position of a group of sprites as described in SPRGRPMOV
  29+ 5436 ~            ; and manually animate a list of animations
  30+ 5436 ~            ; _SGAM ( INT x,
  31+ 5436 ~            ;	      INT y,
  32+ 5436 ~            ;		  BYTE count,
  33+ 5436 ~            ;		  INT[2][count] data_ptr,
  34+ 5436 ~            ;         BYTE item_number,
  35+ 5436 ~            ;         INT[] sprite_animations )
  36+ 5436 ~            ; will put ram in page 0 also, page 1 is already there
  37+ 5436 ~            SGAM:
  38+ 5436 ~            	LD A, (SPRATR_INIT_STATUS)
  39+ 5436 ~            	OR A
  40+ 5436 ~            	JP Z,ILLEGAL_FUNCTION
  41+ 5436 ~            	; opening (
  42+ 5436 ~            	CALL CHKCHAR
  43+ 5436 ~            	DB '('
  44+ 5436 ~            	; get x
  45+ 5436 ~            	LD IX, FRMQNT
  46+ 5436 ~            	CALL CALBAS
  47+ 5436 ~            	LD (TMP_STRUCT),DE
  48+ 5436 ~            	; comma
  49+ 5436 ~            	CALL CHKCHAR
  50+ 5436 ~            	DB ','
  51+ 5436 ~            	; get y
  52+ 5436 ~            	LD IX, FRMQNT
  53+ 5436 ~            	CALL CALBAS
  54+ 5436 ~            	LD (TMP_STRUCT+2),DE
  55+ 5436 ~            	; comma
  56+ 5436 ~            	CALL CHKCHAR
  57+ 5436 ~            	DB ','
  58+ 5436 ~            	; get count
  59+ 5436 ~            	LD IX, GETBYT
  60+ 5436 ~            	CALL CALBAS
  61+ 5436 ~                OR A
  62+ 5436 ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
  63+ 5436 ~            	LD (TMP_STRUCT+4),A
  64+ 5436 ~            	; comma
  65+ 5436 ~            	CALL CHKCHAR
  66+ 5436 ~            	DB ','
  67+ 5436 ~            	; get sprite group definition array data pointer
  68+ 5436 ~                LD A,(TMP_STRUCT+4)
  69+ 5436 ~            	LD E,A
  70+ 5436 ~            	LD D,3
  71+ 5436 ~            	LD A,2
  72+ 5436 ~            	LD B,A
  73+ 5436 ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
  74+ 5436 ~            	LD (TMP_STRUCT+5),BC
  75+ 5436 ~            	; comma
  76+ 5436 ~            	CALL CHKCHAR
  77+ 5436 ~            	DB ','
  78+ 5436 ~            	; get sprite animation array size
  79+ 5436 ~            	LD IX,GETBYT
  80+ 5436 ~            	CALL CALBAS
  81+ 5436 ~                LD (TMP_STRUCT+7),A
  82+ 5436 ~                OR A
  83+ 5436 ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
  84+ 5436 ~            	; comma
  85+ 5436 ~            	CALL CHKCHAR
  86+ 5436 ~            	DB ','
  87+ 5436 ~                ; get array pointer
  88+ 5436 ~                LD A,(TMP_STRUCT+7)
  89+ 5436 ~                LD D,A
  90+ 5436 ~                LD A,2
  91+ 5436 ~                LD B,1
  92+ 5436 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
  93+ 5436 ~                LD (TMP_STRUCT+8),BC
  94+ 5436 ~            	; ending )
  95+ 5436 ~            	CALL CHKCHAR
  96+ 5436 ~            	DB ')'
  97+ 5436 ~            .ENTRY:
  98+ 5436 ~                PUSH HL
  99+ 5436 ~
 100+ 5436 ~            	; enable page 0
 101+ 5436 ~            	LD IY, .RET
 102+ 5436 ~            	JP ENABLE_PAGE0
 103+ 5436 ~            .RET:
 104+ 5436 ~                EXX
 105+ 5436 ~                LD DE,(TMP_STRUCT) ; initial x
 106+ 5436 ~                LD BC,(TMP_STRUCT+2) ; initial y
 107+ 5436 ~                EXX
 108+ 5436 ~                LD HL,(TMP_STRUCT+5) ; pointer to data
 109+ 5436 ~                LD A,(TMP_STRUCT+4) ; number of entries
 110+ 5436 ~                LD B,A
 111+ 5436 ~                CALL SPR_UPDATE_LOC
 112+ 5436 ~
 113+ 5436 ~                LD A,(TMP_STRUCT+7) ; anim number
 114+ 5436 ~                LD B,A
 115+ 5436 ~                LD DE,(TMP_STRUCT+8) ; anim list
 116+ 5436 ~            	CALL SGAM_PROCESS_ANIM_LIST
 117+ 5436 ~                POP DE
 118+ 5436 ~                POP BC
 119+ 5436 ~                CALL RESTORE_PAGE_INFO
 120+ 5436 ~            	XOR A
 121+ 5436 ~            	POP HL
 122+ 5436 ~            	RET
 123+ 5436 ~            ; *******************************************************************************************************
 124+ 5436               ENDIF
 125+ 5436
 126+ 5436               IF (1 == 1)
 127+ 5436              ; *******************************************************************************************************
 128+ 5436              ; same as SGAM but for DEFUSR approach
 129+ 5436              ; input IX=pointer to input array, real data from +2
 130+ 5436              ; +02 = X
 131+ 5436              ; +04 = Y
 132+ 5436              ; +06 = count
 133+ 5436              ; +08 = data pointer
 134+ 5436              ; +10 = anim number
 135+ 5436              ; +12 = sprite animations
 136+ 5436              SGAM_DEFUSR:
 137+ 5436              	; enable page 0
 138+ 5436 FD 21 3D 54  	LD IY, .RET
 139+ 543A C3 7F 60     	JP ENABLE_PAGE0
 140+ 543D              .RET:
 141+ 543D FB           	EI
 142+ 543E D9               EXX
 143+ 543F DD 5E 02     	LD E,(IX+2)
 144+ 5442 DD 56 03     	LD D,(IX+3) ; initial x
 145+ 5445 DD 4E 04     	LD C,(IX+4)
 146+ 5448 DD 46 05     	LD B,(IX+5) ; initial y
 147+ 544B D9               EXX
 148+ 544C DD 6E 08     	LD L,(IX+8)
 149+ 544F DD 66 09     	LD H,(IX+9) ; pointer to data
 150+ 5452 DD 46 06         LD B,(IX+6) ; count
 151+ 5455 DD E5        	PUSH IX
 152+ 5457 CD C2 4E         CALL SPR_UPDATE_LOC
 153+ 545A DD E1        	POP IX
 154+ 545C DD 46 0A         LD B,(IX+10) ; anim number
 155+ 545F DD 5E 0C     	LD E,(IX+12)
 156+ 5462 DD 56 0D     	LD D,(IX+13)
 157+ 5465 CD 1E 54     	CALL SGAM_PROCESS_ANIM_LIST
 158+ 5468 C3 95 5F     	JP COMMON_EXIT_CODE
 159+ 546B              ; *******************************************************************************************************
 160+ 546B               ENDIF
 161+ 546B
 162+ 546B              ; *******************************************************************************************************
 163+ 546B              ; handles automatic move and animate sprite groups during interrupt
 164+ 546B              PROCESS_AUTOSGAMS:
 165+ 546B 3A 00 4F     	LD A,(AUTOSGAMNUM)
 166+ 546E B7           	OR A
 167+ 546F C8           	RET Z
 168+ 5470 47           	LD B,A
 169+ 5471 DD 2A 01 4F  	LD IX,(AUTOSGAMPTR)
 170+ 5475              .L1:
 171+ 5475 C5           	PUSH BC
 172+ 5476 DD 7E 13     	LD A,(IX+19) ; active flag
 173+ 5479 B7           	OR A
 174+ 547A 28 28        	JR Z,.LOOPEND
 175+ 547C              	; active, check timer
 176+ 547C DD 6E 16     	LD L,(IX+22)
 177+ 547F DD 66 17     	LD H,(IX+23) ; timer
 178+ 5482 2B           	DEC HL
 179+ 5483 7C           	LD A,H
 180+ 5484 B5           	OR L
 181+ 5485 28 08        	JR Z,.L2
 182+ 5487              	; not expired
 183+ 5487 DD 75 16     	LD (IX+22),L
 184+ 548A DD 74 17     	LD (IX+23),H
 185+ 548D 18 15        	JR .LOOPEND
 186+ 548F              .L2:
 187+ 548F              	; expired, process
 188+ 548F
 189+ 548F                  ; set initial timer
 190+ 548F DD 7E 14         LD A,(IX+20)
 191+ 5492 DD 77 16         LD (IX+22),A
 192+ 5495 DD 7E 15         LD A,(IX+21)
 193+ 5498 DD 77 17         LD (IX+23),A
 194+ 549B
 195+ 549B CD AD 54     	CALL .MOVE
 196+ 549E CD 18 55     	CALL .UPDATELOC
 197+ 54A1 CD 3D 55     	CALL .PROCESS_ANIM_LIST
 198+ 54A4
 199+ 54A4              .LOOPEND:
 200+ 54A4 11 18 00     	LD DE,24
 201+ 54A7 DD 19        	ADD IX,DE
 202+ 54A9 C1           	POP BC
 203+ 54AA 10 C9        	DJNZ .L1
 204+ 54AC C9           	RET
 205+ 54AD
 206+ 54AD              .MOVE:
 207+ 54AD              	; process movement
 208+ 54AD DD 7E 0A     	LD A,(IX+10) ; direction
 209+ 54B0 B7           	OR A
 210+ 54B1 28 08        	JR Z, .MOVE_L1
 211+ 54B3              	; vertical
 212+ 54B3 DD 6E 02     	LD L,(IX+2)
 213+ 54B6 DD 66 03     	LD H,(IX+3) ; vertical variable pointer
 214+ 54B9 18 06        	JR .MOVE_L2
 215+ 54BB              .MOVE_L1:
 216+ 54BB              	; horizontal
 217+ 54BB DD 6E 00     	LD L,(IX+0)
 218+ 54BE DD 66 01     	LD H,(IX+1) ; horizontal variable pointer
 219+ 54C1              .MOVE_L2:
 220+ 54C1 E5           	PUSH HL
 221+ 54C2 FD E1        	POP IY
 222+ 54C4 FD 6E 00     	LD L,(IY+0)
 223+ 54C7 FD 66 01     	LD H,(IY+1)
 224+ 54CA DD 5E 08     	LD E,(IX+8)
 225+ 54CD DD 56 09     	LD D,(IX+9) ; delta value
 226+ 54D0 19           	ADD HL,DE
 227+ 54D1 E5           	PUSH HL
 228+ 54D2 DD 5E 04     	LD E,(IX+4)
 229+ 54D5 DD 56 05     	LD D,(IX+5) ; minimum value
 230+ 54D8 A7           	AND A
 231+ 54D9 ED 52        	SBC HL,DE
 232+ 54DB FA F5 54     	JP M,.MOVE_L3 ; below minimum
 233+ 54DE E1           	POP HL
 234+ 54DF E5           	PUSH HL
 235+ 54E0 DD 5E 06     	LD E,(IX+6)
 236+ 54E3 DD 56 07     	LD D,(IX+7) ; maximum value
 237+ 54E6 EB           	EX DE,HL
 238+ 54E7 A7           	AND A
 239+ 54E8 ED 52        	SBC HL,DE
 240+ 54EA FA FD 54     	JP M,.MOVE_L4 ; above maximum
 241+ 54ED E1           	POP HL
 242+ 54EE              	; within bounds
 243+ 54EE              .MOVE_L5:
 244+ 54EE FD 75 00     	LD (IY+0),L
 245+ 54F1 FD 74 01     	LD (IY+1),H
 246+ 54F4 C9           	RET
 247+ 54F5              .MOVE_L3:
 248+ 54F5 E1           	POP HL
 249+ 54F6 CD 09 55     	CALL .INVERSE_DELTA
 250+ 54F9 6B           	LD L,E
 251+ 54FA 62           	LD H,D
 252+ 54FB 18 F1        	JR .MOVE_L5
 253+ 54FD              .MOVE_L4:
 254+ 54FD E1           	POP HL
 255+ 54FE CD 09 55     	CALL .INVERSE_DELTA
 256+ 5501 DD 6E 06     	LD L,(IX+6)
 257+ 5504 DD 66 07     	LD H,(IX+7) ; maximum
 258+ 5507 18 E5        	JR .MOVE_L5
 259+ 5509              .INVERSE_DELTA:
 260+ 5509 AF           	XOR A
 261+ 550A DD 96 08     	SUB (IX+8)
 262+ 550D DD 77 08     	LD (IX+8),A
 263+ 5510 9F           	SBC A,A
 264+ 5511 DD 96 09     	SUB (IX+9)
 265+ 5514 DD 77 09     	LD (IX+9),A
 266+ 5517 C9           	RET
 267+ 5518
 268+ 5518              .UPDATELOC:
 269+ 5518 DD E5        	PUSH IX
 270+ 551A D9           	EXX
 271+ 551B DD 6E 00     	LD L,(IX+0)
 272+ 551E DD 66 01     	LD H,(IX+1)
 273+ 5521 5E           	LD E,(HL)
 274+ 5522 23           	INC HL
 275+ 5523 56           	LD D,(HL)
 276+ 5524 DD 6E 02     	LD L,(IX+2)
 277+ 5527 DD 66 03     	LD H,(IX+3)
 278+ 552A 4E           	LD C,(HL)
 279+ 552B 23           	INC HL
 280+ 552C 46           	LD B,(HL)
 281+ 552D D9           	EXX
 282+ 552E DD 6E 0C     	LD L,(IX+12)
 283+ 5531 DD 66 0D     	LD H,(IX+13) ; pointer to sprite group data
 284+ 5534 DD 46 0B     	LD B,(IX+11) ; sprite group size
 285+ 5537 CD C2 4E     	CALL SPR_UPDATE_LOC
 286+ 553A DD E1        	POP IX
 287+ 553C C9           	RET
 288+ 553D
 289+ 553D              .PROCESS_ANIM_LIST:
 290+ 553D DD E5        	PUSH IX
 291+ 553F DD 46 0E         LD B,(IX+14) ; anim list size
 292+ 5542 DD CB 09 7E  	BIT 7,(IX+9)
 293+ 5546 28 08        	JR Z,.PROCESS_ANIM_LIST_L1
 294+ 5548              	; negative direction
 295+ 5548 DD 5E 0F     	LD E,(IX+15)
 296+ 554B DD 56 10     	LD D,(IX+16)
 297+ 554E 18 06        	JR .PROCESS_ANIM_LIST_L2
 298+ 5550              .PROCESS_ANIM_LIST_L1:
 299+ 5550              	; positive direction
 300+ 5550 DD 5E 11     	LD E,(IX+17)
 301+ 5553 DD 56 12     	LD D,(IX+18)
 302+ 5556              .PROCESS_ANIM_LIST_L2:
 303+ 5556 CD 1E 54     	CALL SGAM_PROCESS_ANIM_LIST
 304+ 5559 DD E1        	POP IX
 305+ 555B C9           	RET
 306+ 555C              ; *******************************************************************************************************
 307+ 555C
# file closed: asm\SGAM.asm
 140  555C               ENDIF
 141  555C
 142  555C               IF (RAM_CMDS == 1)
 143  555C               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
   1+ 555C               IF (0 == 1)
   2+ 555C ~            ; *******************************************************************************************************
   3+ 555C ~            ; function to handle CALL MEMCPY basic extension
   4+ 555C ~            ; _MEMCPY ( INT source,
   5+ 555C ~            ;			INT destination,
   6+ 555C ~            ;			INT count,
   7+ 555C ~            ; will put ram in page 0 also, page 1 is already there
   8+ 555C ~            MEMCPY:
   9+ 555C ~            	; opening (
  10+ 555C ~            	CALL CHKCHAR
  11+ 555C ~            	DB '('
  12+ 555C ~            	; get source address
  13+ 555C ~            	LD IX, FRMQNT
  14+ 555C ~            	CALL CALBAS
  15+ 555C ~            	PUSH DE
  16+ 555C ~            	; comma
  17+ 555C ~            	CALL CHKCHAR
  18+ 555C ~            	DB ','
  19+ 555C ~            	; get destination address
  20+ 555C ~            	LD IX, FRMQNT
  21+ 555C ~            	CALL CALBAS
  22+ 555C ~            	PUSH DE
  23+ 555C ~            	; comma
  24+ 555C ~            	CALL CHKCHAR
  25+ 555C ~            	DB ','
  26+ 555C ~            	; get length
  27+ 555C ~            	LD IX, FRMQNT
  28+ 555C ~            	CALL CALBAS
  29+ 555C ~            	PUSH DE
  30+ 555C ~            	; ending )
  31+ 555C ~            	CALL CHKCHAR
  32+ 555C ~            	DB ')'
  33+ 555C ~
  34+ 555C ~            	; save position
  35+ 555C ~            	PUSH HL
  36+ 555C ~            	POP IX
  37+ 555C ~
  38+ 555C ~            	POP BC ; count
  39+ 555C ~            	POP DE ; destination
  40+ 555C ~            	POP HL ; source
  41+ 555C ~            	EXX
  42+ 555C ~            	; enable page 0
  43+ 555C ~            	LD IY, .RET
  44+ 555C ~            	JP ENABLE_PAGE0
  45+ 555C ~            .RET:
  46+ 555C ~            	EI
  47+ 555C ~            	EXX
  48+ 555C ~            	LDIR
  49+ 555C ~            	JP COMMON_EXIT_CODE_IX
  50+ 555C ~            ; *******************************************************************************************************
  51+ 555C               ENDIF
  52+ 555C
  53+ 555C               IF (1 == 1)
  54+ 555C              ; *******************************************************************************************************
  55+ 555C              ; same as MEMCPY but for DEFUSR approach
  56+ 555C              ; input IX=pointer to input array, real data from +2
  57+ 555C              ; +2 = source address
  58+ 555C              ; +4 = destination address
  59+ 555C              ; +6 = lenght
  60+ 555C              MEMCPY_DEFUSR:
  61+ 555C              	; enable page 0
  62+ 555C FD 21 63 55  	LD IY, .RET
  63+ 5560 C3 7F 60     	JP ENABLE_PAGE0
  64+ 5563              .RET:
  65+ 5563 FB           	EI
  66+ 5564 DD 6E 02     	LD L,(IX+2)
  67+ 5567 DD 66 03     	LD H,(IX+3)
  68+ 556A DD 5E 04     	LD E,(IX+4)
  69+ 556D DD 56 05     	LD D,(IX+5)
  70+ 5570 DD 4E 06     	LD C,(IX+6)
  71+ 5573 DD 46 07     	LD B,(IX+7)
  72+ 5576 ED B0        	LDIR
  73+ 5578 C3 95 5F         JP COMMON_EXIT_CODE
  74+ 557B              ; *******************************************************************************************************
  75+ 557B               ENDIF
  76+ 557B
  77+ 557B               IF (0 == 1)
  78+ 557B ~            ; *******************************************************************************************************
  79+ 557B ~            ; function to handle CALL FILRAM basic extension
  80+ 557B ~            ; FILRAM ( INT start address,
  81+ 557B ~            ;		   INT count,
  82+ 557B ~            ;		   BYTE value )
  83+ 557B ~            ; will put ram in page 0 also, page 1 is already there
  84+ 557B ~            FILRAM:
  85+ 557B ~            	; opening (
  86+ 557B ~            	CALL CHKCHAR
  87+ 557B ~            	DB '('
  88+ 557B ~            	; get start address
  89+ 557B ~            	LD IX, FRMQNT
  90+ 557B ~            	CALL CALBAS
  91+ 557B ~            	PUSH DE
  92+ 557B ~            	; comma
  93+ 557B ~            	CALL CHKCHAR
  94+ 557B ~            	DB ','
  95+ 557B ~            	; get count
  96+ 557B ~            	LD IX, FRMQNT
  97+ 557B ~            	CALL CALBAS
  98+ 557B ~            	PUSH DE
  99+ 557B ~            	; comma
 100+ 557B ~            	CALL CHKCHAR
 101+ 557B ~            	DB ','
 102+ 557B ~            	; get value
 103+ 557B ~            	LD IX, GETBYT
 104+ 557B ~            	CALL CALBAS
 105+ 557B ~            	PUSH AF
 106+ 557B ~            	; ending )
 107+ 557B ~            	CALL CHKCHAR
 108+ 557B ~            	DB ')'
 109+ 557B ~
 110+ 557B ~            	; save position
 111+ 557B ~            	PUSH HL
 112+ 557B ~            	POP IX
 113+ 557B ~
 114+ 557B ~            	POP DE ; actually AF
 115+ 557B ~            	POP BC ; count
 116+ 557B ~            	POP HL ; start address
 117+ 557B ~            	EXX
 118+ 557B ~            	; enable page 0
 119+ 557B ~            	LD IY, .RET
 120+ 557B ~            	JP ENABLE_PAGE0
 121+ 557B ~            .RET:
 122+ 557B ~            	EI
 123+ 557B ~            	EXX
 124+ 557B ~            	CALL FILVRM_FILLVALUE
 125+ 557B ~            	JP COMMON_EXIT_CODE_IX
 126+ 557B ~            ; *******************************************************************************************************
 127+ 557B               ENDIF
 128+ 557B
 129+ 557B               IF (1 == 1)
 130+ 557B              ; *******************************************************************************************************
 131+ 557B              ; same as FILVRM but for DEFUSR approach
 132+ 557B              ; input IX=pointer to input array, real data from +2
 133+ 557B              ; +2 = start address
 134+ 557B              ; +4 = count
 135+ 557B              ; +6 = value
 136+ 557B              FILRAM_DEFUSR:
 137+ 557B              	; enable page 0
 138+ 557B FD 21 82 55  	LD IY, .RET
 139+ 557F C3 7F 60     	JP ENABLE_PAGE0
 140+ 5582              .RET:
 141+ 5582 FB           	EI
 142+ 5583 DD 6E 02     	LD L,(IX+2)
 143+ 5586 DD 66 03     	LD H,(IX+3)
 144+ 5589 DD 4E 04     	LD C,(IX+4)
 145+ 558C DD 46 05     	LD B,(IX+5)
 146+ 558F DD 56 06     	LD D,(IX+6)
 147+ 5592 CD 98 55     	CALL FILVRM_FILLVALUE
 148+ 5595 C3 95 5F         JP COMMON_EXIT_CODE
 149+ 5598              ; *******************************************************************************************************
 150+ 5598               ENDIF
 151+ 5598
 152+ 5598              ; *******************************************************************************************************
 153+ 5598              ; common function to fill RAM
 154+ 5598              FILVRM_FILLVALUE:
 155+ 5598 78           	LD A,B
 156+ 5599 B1           	OR C
 157+ 559A C8           	RET Z ; zero size
 158+ 559B 72               LD (HL), D
 159+ 559C 54               LD D, H
 160+ 559D 5D               LD E, L
 161+ 559E 13               INC DE
 162+ 559F 0B               DEC BC
 163+ 55A0 78           	LD A,B
 164+ 55A1 B1           	OR C
 165+ 55A2 C8           	RET Z ; if count was 1
 166+ 55A3 ED B0            LDIR
 167+ 55A5 C9               RET
 168+ 55A6              ; *******************************************************************************************************
# file closed: asm\MEMORY.asm
 144  55A6               ENDIF
 145  55A6
 146  55A6               IF (SOUND_CMDS == 1)
 147  55A6               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
   1+ 55A6              MUSIC_INIT_STATUS:
   2+ 55A6 00            DB 0
   3+ 55A7              SFX_INIT_STATUS:
   4+ 55A7 00            DB 0
   5+ 55A8              SOUND_ENABLED:
   6+ 55A8 00            DB 0
   7+ 55A9
   8+ 55A9               IF (0 == 1)
   9+ 55A9 ~            ; *******************************************************************************************************
  10+ 55A9 ~            ; function to handle CALL SNDPLYINIT basic extension
  11+ 55A9 ~            ; initializes sound player
  12+ 55A9 ~            ; _SNDPLYINIT ( INT music_offset,
  13+ 55A9 ~            ;				INT sfx_offset, can be -1 if no SFX
  14+ 55A9 ~            ; will put ram in page 0 also, page 1 is already there
  15+ 55A9 ~            ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
  16+ 55A9 ~            SNDPLYINIT:
  17+ 55A9 ~            	; opening (
  18+ 55A9 ~            	CALL CHKCHAR
  19+ 55A9 ~            	DB '('
  20+ 55A9 ~            	; get music address
  21+ 55A9 ~            	LD IX, FRMQNT
  22+ 55A9 ~            	CALL CALBAS
  23+ 55A9 ~            	PUSH DE
  24+ 55A9 ~            	; comma
  25+ 55A9 ~            	CALL CHKCHAR
  26+ 55A9 ~            	DB ','
  27+ 55A9 ~            	; get sfx address
  28+ 55A9 ~            	LD IX, FRMQNT
  29+ 55A9 ~            	CALL CALBAS
  30+ 55A9 ~            	PUSH DE
  31+ 55A9 ~            	; ending )
  32+ 55A9 ~            	CALL CHKCHAR
  33+ 55A9 ~            	DB ')'
  34+ 55A9 ~
  35+ 55A9 ~                ; save position in BASIC text
  36+ 55A9 ~            	LD B, H
  37+ 55A9 ~            	LD C, L
  38+ 55A9 ~
  39+ 55A9 ~            	; pop LDIR parameters and store away for later
  40+ 55A9 ~            	POP DE ; sfx address
  41+ 55A9 ~            	POP HL ; music address
  42+ 55A9 ~            	PUSH BC ; basic text location
  43+ 55A9 ~            	EXX
  44+ 55A9 ~            	LD IY, .RET
  45+ 55A9 ~            	JP ENABLE_PAGE0
  46+ 55A9 ~            .RET:
  47+ 55A9 ~            	EXX
  48+ 55A9 ~
  49+ 55A9 ~            	PUSH DE
  50+ 55A9 ~            	XOR A
  51+ 55A9 ~            	; HL = music location
  52+ 55A9 ~            	CALL PLY_AKG_INIT
  53+ 55A9 ~            	LD A, 1
  54+ 55A9 ~            	LD (MUSIC_INIT_STATUS), A
  55+ 55A9 ~
  56+ 55A9 ~            	POP HL ; SFX
  57+ 55A9 ~            	; check if SFX address -1
  58+ 55A9 ~            	INC HL
  59+ 55A9 ~            	LD A, L
  60+ 55A9 ~            	OR H
  61+ 55A9 ~            	JR Z,.L1
  62+ 55A9 ~            	DEC HL
  63+ 55A9 ~            	CALL PLY_AKG_INITSOUNDEFFECTS
  64+ 55A9 ~            	LD A, 1
  65+ 55A9 ~            	LD (SFX_INIT_STATUS), A
  66+ 55A9 ~            .L1:
  67+ 55A9 ~                POP DE
  68+ 55A9 ~                POP BC
  69+ 55A9 ~                CALL RESTORE_PAGE_INFO
  70+ 55A9 ~            	XOR A
  71+ 55A9 ~            	POP HL
  72+ 55A9 ~            	RET
  73+ 55A9 ~            ; *******************************************************************************************************
  74+ 55A9               ENDIF
  75+ 55A9
  76+ 55A9               IF (1 == 1)
  77+ 55A9              ; *******************************************************************************************************
  78+ 55A9              ; same as SNDPLYINI but for DEFUSR approach
  79+ 55A9              ; input IX=pointer to input array, real data from +2
  80+ 55A9              ; +2 = music address
  81+ 55A9              ; +4 = sfx address
  82+ 55A9              SNDPLYINI_DEFUSR:
  83+ 55A9 FD 21 B0 55  	LD IY, .RET
  84+ 55AD C3 7F 60     	JP ENABLE_PAGE0
  85+ 55B0              .RET:
  86+ 55B0 AF           	XOR A
  87+ 55B1 DD 6E 02     	LD L,(IX+2)
  88+ 55B4 DD 66 03     	LD H,(IX+3)
  89+ 55B7 DD E5        	PUSH IX
  90+ 55B9 CD 65 41     	CALL PLY_AKG_INIT
  91+ 55BC DD E1        	POP IX
  92+ 55BE 3E 01        	LD A, 1
  93+ 55C0 32 A6 55     	LD (MUSIC_INIT_STATUS), A
  94+ 55C3
  95+ 55C3 DD 6E 04     	LD L,(IX+4)
  96+ 55C6 DD 66 05     	LD H,(IX+5)
  97+ 55C9              	; check if SFX address -1
  98+ 55C9 23           	INC HL
  99+ 55CA 7D           	LD A, L
 100+ 55CB B4           	OR H
 101+ 55CC 28 09        	JR Z,.L1
 102+ 55CE 2B           	DEC HL
 103+ 55CF CD 20 40     	CALL PLY_AKG_INITSOUNDEFFECTS
 104+ 55D2 3E 01        	LD A, 1
 105+ 55D4 32 A7 55     	LD (SFX_INIT_STATUS), A
 106+ 55D7              .L1:
 107+ 55D7 C3 95 5F     	JP COMMON_EXIT_CODE
 108+ 55DA              ; *******************************************************************************************************
 109+ 55DA               ENDIF
 110+ 55DA
 111+ 55DA              ; *******************************************************************************************************
 112+ 55DA              ; function to handle CALL SNDPLYON basic extension
 113+ 55DA              ; enables sound player
 114+ 55DA              ; _SNDPLYON
 115+ 55DA              ; sets SOUND_ENABLED variable to 1 if init call was done
 116+ 55DA              ; if not throws out of data error
 117+ 55DA              SNDPLYON_DEFUSR:
 118+ 55DA              SNDPLYON:
 119+ 55DA 3A A6 55     	LD A, (MUSIC_INIT_STATUS)
 120+ 55DD B7           	OR A
 121+ 55DE               IF (0 == 1)
 122+ 55DE ~            	JP Z, OUT_OF_DATA ; player not initialized, throw error
 123+ 55DE               ENDIF
 124+ 55DE               IF (1 == 1)
 125+ 55DE 28 08        	JR Z,.ERR
 126+ 55E0               ENDIF
 127+ 55E0              .L1:
 128+ 55E0 32 A8 55     	LD (SOUND_ENABLED), A
 129+ 55E3              	; disable key click
 130+ 55E3 AF           	XOR A
 131+ 55E4 32 DB F3     	LD (CLIKSW), A
 132+ 55E7 C9           	RET
 133+ 55E8              .ERR:
 134+ 55E8 3E 01        	LD A,1
 135+ 55EA C9           	RET
 136+ 55EB              ; *******************************************************************************************************
 137+ 55EB
 138+ 55EB              ; *******************************************************************************************************
 139+ 55EB              ; function to handle CALL SNDPLYOFF basic extension
 140+ 55EB              ; disables sound player
 141+ 55EB              ; _SNDPLYOFF
 142+ 55EB              ; sets SOUND_ENABLED variable to 0
 143+ 55EB              ; calls AKG to stop music and SFX on all channels if initialized
 144+ 55EB              SNDPLYOFF_DEFUSR:
 145+ 55EB              SNDPLYOFF:
 146+ 55EB 3A A8 55     	LD A, (SOUND_ENABLED)
 147+ 55EE B7           	OR A
 148+ 55EF C8           	RET Z ; already stopped
 149+ 55F0 AF           	XOR A
 150+ 55F1 32 A8 55     	LD (SOUND_ENABLED), A
 151+ 55F4 E5           	PUSH HL
 152+ 55F5 CD 24 42     	CALL PLY_AKG_STOP
 153+ 55F8 3A A7 55     	LD A, (SFX_INIT_STATUS)
 154+ 55FB B7           	OR A
 155+ 55FC 28 0E        	JR Z, .EXIT ; SFX not in use
 156+ 55FE AF           	XOR A
 157+ 55FF CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 158+ 5602 3E 01        	LD A, 1
 159+ 5604 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 160+ 5607 3E 02        	LD A, 2
 161+ 5609 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 162+ 560C              .EXIT:
 163+ 560C E1           	POP HL
 164+ 560D AF           	XOR A ; success
 165+ 560E C9           	RET
 166+ 560F              ; *******************************************************************************************************
 167+ 560F
 168+ 560F               IF (0 == 1)
 169+ 560F ~            ; *******************************************************************************************************
 170+ 560F ~            ; function to handle CALL SNDSFX basic extension
 171+ 560F ~            ; plays a sound effect
 172+ 560F ~            ; _SNDSFX ( BYTE sfx_number, >0
 173+ 560F ~            ;			BYTE channel, = 0,1 or 2
 174+ 560F ~            ;			BYTE inverted_volume = 0-16, 0 being full volume
 175+ 560F ~            ; will put ram in page 0 also, page 1 is already there
 176+ 560F ~            ; if sound off throws illegal function call
 177+ 560F ~            ; if sfx not initialized, throws out of data
 178+ 560F ~            SNDSFX:
 179+ 560F ~            	; opening (
 180+ 560F ~            	CALL CHKCHAR
 181+ 560F ~            	DB '('
 182+ 560F ~            	; get sfx_number
 183+ 560F ~            	LD IX, GETBYT
 184+ 560F ~            	CALL CALBAS
 185+ 560F ~            	PUSH DE
 186+ 560F ~            	; comma
 187+ 560F ~            	CALL CHKCHAR
 188+ 560F ~            	DB ','
 189+ 560F ~            	; get sfx address
 190+ 560F ~            	LD IX, GETBYT
 191+ 560F ~            	CALL CALBAS
 192+ 560F ~            	PUSH DE
 193+ 560F ~            	; comma
 194+ 560F ~            	CALL CHKCHAR
 195+ 560F ~            	DB ','
 196+ 560F ~            	; get inverted volume
 197+ 560F ~            	LD IX, GETBYT
 198+ 560F ~            	CALL CALBAS
 199+ 560F ~            	PUSH DE
 200+ 560F ~            	; ending )
 201+ 560F ~            	CALL CHKCHAR
 202+ 560F ~            	DB ')'
 203+ 560F ~
 204+ 560F ~            	LD A, (SOUND_ENABLED)
 205+ 560F ~            	OR A
 206+ 560F ~            	JR NZ, .L1
 207+ 560F ~            	; sound disabled, throw illegal function call
 208+ 560F ~            	LD E, 5
 209+ 560F ~            	JP THROW_ERROR
 210+ 560F ~            .L1:
 211+ 560F ~            	LD A, (SFX_INIT_STATUS)
 212+ 560F ~            	OR A
 213+ 560F ~            	JR NZ, .L2
 214+ 560F ~            	; sfx data not initialized, throw out of data
 215+ 560F ~            	LD E, 4
 216+ 560F ~            	JP THROW_ERROR
 217+ 560F ~            .L2:
 218+ 560F ~            	; pop  parameters and store away for later
 219+ 560F ~            	POP DE ; inverted volume
 220+ 560F ~            	LD B, E
 221+ 560F ~            	POP DE ; channel
 222+ 560F ~            	LD C, E
 223+ 560F ~            	POP DE
 224+ 560F ~            	LD A, E
 225+ 560F ~            	EX AF, AF'
 226+ 560F ~            	PUSH HL ; basic text location
 227+ 560F ~            	EXX
 228+ 560F ~            	LD IY, .RET
 229+ 560F ~            	JP ENABLE_PAGE0
 230+ 560F ~            .RET:
 231+ 560F ~            	EXX
 232+ 560F ~            	EX AF, AF'
 233+ 560F ~            	CALL PLY_AKG_PLAYSOUNDEFFECT
 234+ 560F ~
 235+ 560F ~                POP DE
 236+ 560F ~                POP BC
 237+ 560F ~                CALL RESTORE_PAGE_INFO
 238+ 560F ~            	XOR A
 239+ 560F ~            	POP HL
 240+ 560F ~            	RET
 241+ 560F ~            ; *******************************************************************************************************
 242+ 560F               ENDIF
 243+ 560F
 244+ 560F               IF (1 == 1)
 245+ 560F              ; *******************************************************************************************************
 246+ 560F              ; same as SNDSFX but for DEFUSR approach
 247+ 560F              ; input IX=pointer to input array, real data from +2
 248+ 560F              ; +2 = SFX number
 249+ 560F              ; +4 = channel
 250+ 560F              ; +6 = volume
 251+ 560F              SNDSFX_DEFUSR:
 252+ 560F 3A A8 55     	LD A, (SOUND_ENABLED)
 253+ 5612 B7           	OR A
 254+ 5613 C8           	RET Z ; sound disabled, just exit
 255+ 5614 3A A7 55     	LD A, (SFX_INIT_STATUS)
 256+ 5617 B7           	OR A
 257+ 5618 C8           	RET Z ; sfx data not initialized, just exit
 258+ 5619 FD 21 20 56  	LD IY, .RET
 259+ 561D C3 7F 60     	JP ENABLE_PAGE0
 260+ 5620              .RET:
 261+ 5620 FB           	EI
 262+ 5621 DD 7E 02     	LD A,(IX+2) ; SFX number
 263+ 5624 DD 4E 04     	LD C,(IX+4) ; channel
 264+ 5627 DD 46 06     	LD B,(IX+6) ; volume
 265+ 562A CD 24 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
 266+ 562D C3 95 5F     	JP COMMON_EXIT_CODE
 267+ 5630              ; *******************************************************************************************************
 268+ 5630               ENDIF
# file closed: asm\SOUND.asm
 148  5630               ENDIF
 149  5630
 150  5630               IF (VRAM_CMDS == 1)
 151  5630               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
   1+ 5630               IF (0 == 1)
   2+ 5630 ~            ; *******************************************************************************************************
   3+ 5630 ~            ; function to handle CALL FILVRM basic extension
   4+ 5630 ~            ; FILVRM ( INT offset,
   5+ 5630 ~            ;		   INT count,
   6+ 5630 ~            ;		   BYTE value,
   7+ 5630 ~            ;		   BYTE wait_vsync) >0 = true
   8+ 5630 ~            ; wait_vsync will issue HALT before copying
   9+ 5630 ~            FILVRM:
  10+ 5630 ~            	; opening (
  11+ 5630 ~            	CALL CHKCHAR
  12+ 5630 ~            	DB '('
  13+ 5630 ~            	; get offset address
  14+ 5630 ~            	LD IX, FRMQNT
  15+ 5630 ~            	CALL CALBAS
  16+ 5630 ~            	PUSH DE
  17+ 5630 ~            	; comma
  18+ 5630 ~            	CALL CHKCHAR
  19+ 5630 ~            	DB ','
  20+ 5630 ~            	; get count
  21+ 5630 ~            	LD IX, FRMQNT
  22+ 5630 ~            	CALL CALBAS
  23+ 5630 ~            	PUSH DE
  24+ 5630 ~            	; comma
  25+ 5630 ~            	CALL CHKCHAR
  26+ 5630 ~            	DB ','
  27+ 5630 ~            	; get value
  28+ 5630 ~            	LD IX, GETBYT
  29+ 5630 ~            	CALL CALBAS
  30+ 5630 ~            	PUSH AF
  31+ 5630 ~            	; comma
  32+ 5630 ~            	CALL CHKCHAR
  33+ 5630 ~            	DB ','
  34+ 5630 ~            	; get vsync wait
  35+ 5630 ~            	LD IX, GETBYT
  36+ 5630 ~            	CALL CALBAS
  37+ 5630 ~            	PUSH AF
  38+ 5630 ~            	; ending )
  39+ 5630 ~            	CALL CHKCHAR
  40+ 5630 ~            	DB ')'
  41+ 5630 ~
  42+ 5630 ~            	; save position
  43+ 5630 ~            	PUSH HL
  44+ 5630 ~            	POP IX
  45+ 5630 ~
  46+ 5630 ~            	; syntax ok
  47+ 5630 ~            	; wait for vsync if needed
  48+ 5630 ~            	POP AF
  49+ 5630 ~            	OR A
  50+ 5630 ~            	JR Z, .L1
  51+ 5630 ~            	HALT
  52+ 5630 ~
  53+ 5630 ~            .L1:
  54+ 5630 ~            	LD A,1
  55+ 5630 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  56+ 5630 ~                POP AF ; value
  57+ 5630 ~                POP BC ; count
  58+ 5630 ~                POP HL ; offset
  59+ 5630 ~                CALL BIOS_FILVRM
  60+ 5630 ~            	XOR A
  61+ 5630 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  62+ 5630 ~
  63+ 5630 ~            .L3:
  64+ 5630 ~            	PUSH IX
  65+ 5630 ~            	POP HL
  66+ 5630 ~            	RET
  67+ 5630 ~            ; *******************************************************************************************************
  68+ 5630               ENDIF
  69+ 5630
  70+ 5630               IF (1 == 1)
  71+ 5630              ; *******************************************************************************************************
  72+ 5630              ; same as FILVRM but for DEFUSR approach
  73+ 5630              ; input IX=pointer to input array, real data from +2
  74+ 5630              ; +2 = offset
  75+ 5630              ; +4 = count
  76+ 5630              ; +6 = value
  77+ 5630              ; +8 = halt flag
  78+ 5630              FILVRM_DEFUSR:
  79+ 5630 DD 7E 08     	LD A,(IX+8)
  80+ 5633 B7           	OR A
  81+ 5634 28 01        	JR Z,.L0
  82+ 5636 76           	HALT
  83+ 5637              .L0:
  84+ 5637 3E 01        	LD A,1
  85+ 5639 32 52 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
  86+ 563C DD 6E 02     	LD L,(IX+2)
  87+ 563F DD 66 03     	LD H,(IX+3)
  88+ 5642 DD 4E 04     	LD C,(IX+4)
  89+ 5645 DD 46 05     	LD B,(IX+5)
  90+ 5648 DD 7E 06     	LD A,(IX+6)
  91+ 564B CD 56 00     	CALL BIOS_FILVRM
  92+ 564E AF           	XOR A
  93+ 564F 32 52 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
  94+ 5652 C9           	RET
  95+ 5653              ; *******************************************************************************************************
  96+ 5653               ENDIF
  97+ 5653
  98+ 5653               IF (0 == 1)
  99+ 5653 ~            ; *******************************************************************************************************
 100+ 5653 ~            ; function to handle CALL MEMVRM basic extension
 101+ 5653 ~            ; copies from RAM to VRAM
 102+ 5653 ~            ; if flag != 0 it will issue HALT before copying
 103+ 5653 ~            ; if bit 1 of flag set and sprite system initialized it will set sprite update flag
 104+ 5653 ~            ; _MEMVRM ( INT source,
 105+ 5653 ~            ;			INT destination,
 106+ 5653 ~            ;			INT count,
 107+ 5653 ~            ;			BYTE flag)
 108+ 5653 ~            ; will put ram in page 0 also, page 1 is already there
 109+ 5653 ~            MEMVRM:
 110+ 5653 ~            	; opening (
 111+ 5653 ~            	CALL CHKCHAR
 112+ 5653 ~            	DB '('
 113+ 5653 ~            	; get source address
 114+ 5653 ~            	LD IX, FRMQNT
 115+ 5653 ~            	CALL CALBAS
 116+ 5653 ~            	PUSH DE
 117+ 5653 ~            	; comma
 118+ 5653 ~            	CALL CHKCHAR
 119+ 5653 ~            	DB ','
 120+ 5653 ~            	; get destination address
 121+ 5653 ~            	LD IX, FRMQNT
 122+ 5653 ~            	CALL CALBAS
 123+ 5653 ~            	PUSH DE
 124+ 5653 ~            	; comma
 125+ 5653 ~            	CALL CHKCHAR
 126+ 5653 ~            	DB ','
 127+ 5653 ~            	; get length
 128+ 5653 ~            	LD IX, FRMQNT
 129+ 5653 ~            	CALL CALBAS
 130+ 5653 ~            	PUSH DE
 131+ 5653 ~            	; comma
 132+ 5653 ~            	CALL CHKCHAR
 133+ 5653 ~            	DB ','
 134+ 5653 ~            	; get vsync wait
 135+ 5653 ~            	LD IX, GETBYT
 136+ 5653 ~            	CALL CALBAS
 137+ 5653 ~            	PUSH AF
 138+ 5653 ~            	; ending )
 139+ 5653 ~            	CALL CHKCHAR
 140+ 5653 ~            	DB ')'
 141+ 5653 ~
 142+ 5653 ~                ; save position in BASIC text
 143+ 5653 ~            	PUSH HL
 144+ 5653 ~            	POP IX
 145+ 5653 ~
 146+ 5653 ~            	POP AF ; wait vsync
 147+ 5653 ~            	OR A
 148+ 5653 ~            	JR Z, .L1
 149+ 5653 ~            	; check for special case to set sprite update flag
 150+ 5653 ~            	IF (SPRITE_CMDS == 1)
 151+ 5653 ~            		AND 2
 152+ 5653 ~            		JR Z,.L2
 153+ 5653 ~            		LD A, (SPRATR_INIT_STATUS)
 154+ 5653 ~            		OR A
 155+ 5653 ~            		JR Z,.L2
 156+ 5653 ~            		LD HL,(SPRATR_UPDATE_FLAG)
 157+ 5653 ~            		LD (HL),A
 158+ 5653 ~            	ENDIF
 159+ 5653 ~            .L2:
 160+ 5653 ~            	HALT
 161+ 5653 ~            .L1:
 162+ 5653 ~            	; pop LDIR parameters and store away for later
 163+ 5653 ~            	POP BC ; count
 164+ 5653 ~            	POP DE ; vram destination
 165+ 5653 ~            	POP HL ; ram source
 166+ 5653 ~            	EXX
 167+ 5653 ~             	LD IY, .RET
 168+ 5653 ~            	JP ENABLE_PAGE0
 169+ 5653 ~            .RET:
 170+ 5653 ~            	EI
 171+ 5653 ~            	EXX
 172+ 5653 ~            	CALL VRAM_LDIRVM
 173+ 5653 ~            	JP COMMON_EXIT_CODE_IX
 174+ 5653 ~            ; *******************************************************************************************************
 175+ 5653               ENDIF
 176+ 5653
 177+ 5653               IF (1 == 1)
 178+ 5653              ; *******************************************************************************************************
 179+ 5653              ; same as MEMVRM but for DEFUSR approach
 180+ 5653              ; input IX=pointer to input array, real data from +2
 181+ 5653              ; +2 = source address
 182+ 5653              ; +4 = destination address
 183+ 5653              ; +6 = lenght
 184+ 5653              ; +8 = flag
 185+ 5653              MEMVRM_DEFUSR:
 186+ 5653 DD 7E 08     	LD A,(IX+8)
 187+ 5656 B7           	OR A
 188+ 5657 28 0F        	JR Z,.L0
 189+ 5659              	IF (SPRITE_CMDS == 1)
 190+ 5659 E6 02        		AND 2
 191+ 565B 28 0A        		JR Z,.L2
 192+ 565D 3A 86 4D     		LD A, (SPRATR_INIT_STATUS)
 193+ 5660 B7           		OR A
 194+ 5661 28 04        		JR Z,.L2
 195+ 5663 2A 87 4D     		LD HL,(SPRATR_UPDATE_FLAG)
 196+ 5666 77           		LD (HL),A
 197+ 5667              	ENDIF
 198+ 5667              .L2:
 199+ 5667 76           	HALT
 200+ 5668              .L0:
 201+ 5668              	; enable page 0
 202+ 5668 FD 21 6F 56  	LD IY, .RET
 203+ 566C C3 7F 60     	JP ENABLE_PAGE0
 204+ 566F              .RET:
 205+ 566F FB           	EI
 206+ 5670 DD 6E 02     	LD L,(IX+2)
 207+ 5673 DD 66 03     	LD H,(IX+3)
 208+ 5676 DD 5E 04     	LD E,(IX+4)
 209+ 5679 DD 56 05     	LD D,(IX+5)
 210+ 567C DD 4E 06     	LD C,(IX+6)
 211+ 567F DD 46 07     	LD B,(IX+7)
 212+ 5682 CD 88 56     	CALL VRAM_LDIRVM
 213+ 5685 C3 95 5F         JP COMMON_EXIT_CODE
 214+ 5688              ; *******************************************************************************************************
 215+ 5688               ENDIF
 216+ 5688
 217+ 5688              ; *******************************************************************************************************
 218+ 5688              ; common code to copy from memory to VRAM
 219+ 5688              ; input HL=RAM source
 220+ 5688              ; input DE=VRAM destination
 221+ 5688              ; BC=count
 222+ 5688              VRAM_LDIRVM:
 223+ 5688 3E 01        	LD A,1
 224+ 568A 32 52 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 225+ 568D EB           	EX DE, HL
 226+ 568E F3           	DI
 227+ 568F CD 9C 5F     	CALL SETWRT_LOCAL_WRITE
 228+ 5692 FB           	EI
 229+ 5693 EB           	EX DE, HL
 230+ 5694 78           	LD A, B
 231+ 5695 B7           	OR A
 232+ 5696 28 0D        	JR Z, .L3
 233+ 5698 C5           	PUSH BC
 234+ 5699 0E 98        	LD C, #98
 235+ 569B              .L2:
 236+ 569B 50           	LD D, B
 237+ 569C 06 00        	LD B, 0
 238+ 569E CD B3 5F     	CALL BBYTECOPY_NO_C
 239+ 56A1 42           	LD B, D
 240+ 56A2 10 F7        	DJNZ .L2
 241+ 56A4 C1           	POP BC
 242+ 56A5              .L3:
 243+ 56A5 79           	LD A, C
 244+ 56A6 B7           	OR A
 245+ 56A7 28 04        	JR Z,.L4
 246+ 56A9 41           	LD B, C
 247+ 56AA CD B1 5F     	CALL BBYTECOPY
 248+ 56AD              .L4:
 249+ 56AD AF           	XOR A
 250+ 56AE 32 52 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 251+ 56B1 C9           	RET
 252+ 56B2              ; *******************************************************************************************************
 253+ 56B2
 254+ 56B2               IF (0 == 1)
 255+ 56B2 ~            ; *******************************************************************************************************
 256+ 56B2 ~            ; function to handle CALL VRMMEM basic extension
 257+ 56B2 ~            ; copies from VRAM to RAM
 258+ 56B2 ~            ; _VRMMEM ( INT source,
 259+ 56B2 ~            ;			INT destination,
 260+ 56B2 ~            ;			INT count
 261+ 56B2 ~            ; will put ram in page 0 also, page 1 is already there
 262+ 56B2 ~            VRMMEM:
 263+ 56B2 ~            	; opening (
 264+ 56B2 ~            	CALL CHKCHAR
 265+ 56B2 ~            	DB '('
 266+ 56B2 ~            	; get source address
 267+ 56B2 ~            	LD IX, FRMQNT
 268+ 56B2 ~            	CALL CALBAS
 269+ 56B2 ~            	PUSH DE
 270+ 56B2 ~            	; comma
 271+ 56B2 ~            	CALL CHKCHAR
 272+ 56B2 ~            	DB ','
 273+ 56B2 ~            	; get destination address
 274+ 56B2 ~            	LD IX, FRMQNT
 275+ 56B2 ~            	CALL CALBAS
 276+ 56B2 ~            	PUSH DE
 277+ 56B2 ~            	; comma
 278+ 56B2 ~            	CALL CHKCHAR
 279+ 56B2 ~            	DB ','
 280+ 56B2 ~            	; get length
 281+ 56B2 ~            	LD IX, FRMQNT
 282+ 56B2 ~            	CALL CALBAS
 283+ 56B2 ~            	PUSH DE
 284+ 56B2 ~            	; ending )
 285+ 56B2 ~            	CALL CHKCHAR
 286+ 56B2 ~            	DB ')'
 287+ 56B2 ~
 288+ 56B2 ~                ; save position in BASIC text
 289+ 56B2 ~            	PUSH HL
 290+ 56B2 ~            	POP IX
 291+ 56B2 ~
 292+ 56B2 ~            	POP BC ; count
 293+ 56B2 ~            	POP DE ; destination
 294+ 56B2 ~            	POP HL ; source
 295+ 56B2 ~            	EXX
 296+ 56B2 ~            	LD IY, .RET
 297+ 56B2 ~            	JP ENABLE_PAGE0
 298+ 56B2 ~            .RET:
 299+ 56B2 ~            	EI
 300+ 56B2 ~            	EXX
 301+ 56B2 ~            	CALL VRAM_LDIRMV
 302+ 56B2 ~            	JP COMMON_EXIT_CODE_IX
 303+ 56B2 ~            ; *******************************************************************************************************
 304+ 56B2               ENDIF
 305+ 56B2
 306+ 56B2               IF (1 == 1)
 307+ 56B2              ; *******************************************************************************************************
 308+ 56B2              ; same as VRMMEM but for DEFUSR approach
 309+ 56B2              ; input IX=pointer to input array, real data from +2
 310+ 56B2              ; +2 = source address
 311+ 56B2              ; +4 = destination address
 312+ 56B2              ; +6 = count
 313+ 56B2              VRMMEM_DEFUSR:
 314+ 56B2              	; enable page 0
 315+ 56B2 FD 21 B9 56  	LD IY, .RET
 316+ 56B6 C3 7F 60     	JP ENABLE_PAGE0
 317+ 56B9              .RET:
 318+ 56B9 FB           	EI
 319+ 56BA DD 6E 02     	LD L,(IX+2)
 320+ 56BD DD 66 03     	LD H,(IX+3)
 321+ 56C0 DD 5E 04     	LD E,(IX+4)
 322+ 56C3 DD 56 05     	LD D,(IX+5)
 323+ 56C6 DD 4E 06     	LD C,(IX+6)
 324+ 56C9 DD 46 07     	LD B,(IX+7)
 325+ 56CC CD D2 56     	CALL VRAM_LDIRMV
 326+ 56CF C3 95 5F     	JP COMMON_EXIT_CODE
 327+ 56D2              ; *******************************************************************************************************
 328+ 56D2               ENDIF
 329+ 56D2
 330+ 56D2              ; *******************************************************************************************************
 331+ 56D2              ; common code to copy from VRAM to RAM
 332+ 56D2              ; input HL=VRAM source
 333+ 56D2              ; input DE=RAM destination
 334+ 56D2              ; BC=count
 335+ 56D2              VRAM_LDIRMV:
 336+ 56D2 3E 01        	LD A,1
 337+ 56D4 32 52 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 338+ 56D7 7D           	LD	A, L
 339+ 56D8 F3           	DI
 340+ 56D9 CD A7 5F     	CALL SETWRT_LOCAL_READ
 341+ 56DC FB           	EI
 342+ 56DD 00           	NOP
 343+ 56DE 00           	NOP
 344+ 56DF 00           	NOP ; too fast VDP access per openMSX
 345+ 56E0              .L4:
 346+ 56E0 DB 98            IN A, (#98)
 347+ 56E2 12           	LD (DE), A
 348+ 56E3 13               INC DE
 349+ 56E4 0B               DEC BC
 350+ 56E5 79               LD A, C
 351+ 56E6 B0               OR B
 352+ 56E7 20 F7            JR NZ, .L4
 353+ 56E9 AF           	XOR A
 354+ 56EA 32 52 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 355+ 56ED C9               RET
 356+ 56EE              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
 152  56EE               ENDIF
 153  56EE
 154  56EE               IF (GENCAL_CMD == 1)
 155  56EE               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
   1+ 56EE               IF (1 == 1)
   2+ 56EE              ; *******************************************************************************************************
   3+ 56EE              ; same as GENCAL but for DEFUSR approach
   4+ 56EE              ; input IX=pointer to input array, real data from +2
   5+ 56EE              ; +2 = function address to call
   6+ 56EE              ; +4 = register list array pointer
   7+ 56EE              GENCAL_DEFUSR:
   8+ 56EE DD 6E 02         LD L,(IX+2)
   9+ 56F1 DD 66 03         LD H,(IX+3)
  10+ 56F4 E5               PUSH HL
  11+ 56F5 DD 6E 04         LD L,(IX+4)
  12+ 56F8 DD 66 05         LD H,(IX+5)
  13+ 56FB E5               PUSH HL
  14+ 56FC 18 00            JR GENCAL.COMMON
  15+ 56FE              ; *******************************************************************************************************
  16+ 56FE               ENDIF
  17+ 56FE
  18+ 56FE              ; *******************************************************************************************************
  19+ 56FE              ; function to handle CALL GENCAL basic extension
  20+ 56FE              ; GENCAL ( INT fn_addr, = address of the function to call
  21+ 56FE              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
  22+ 56FE              ; output values of registers will also be stored at reg_list_ptr
  23+ 56FE              GENCAL:
  24+ 56FE               IF (0 == 1)
  25+ 56FE ~            	; opening (
  26+ 56FE ~            	CALL CHKCHAR
  27+ 56FE ~            	DB '('
  28+ 56FE ~            	; get function address
  29+ 56FE ~            	LD IX, FRMQNT
  30+ 56FE ~            	CALL CALBAS
  31+ 56FE ~            	PUSH DE
  32+ 56FE ~            	; comma
  33+ 56FE ~            	CALL CHKCHAR
  34+ 56FE ~            	DB ','
  35+ 56FE ~            	; get pointer to register list
  36+ 56FE ~                LD A,2
  37+ 56FE ~                LD B,1
  38+ 56FE ~                LD DE,#0500
  39+ 56FE ~                CALL GET_BASIC_ARRAY_DATA_POINTER
  40+ 56FE ~            	PUSH BC
  41+ 56FE ~            	; ending )
  42+ 56FE ~            	CALL CHKCHAR
  43+ 56FE ~            	DB ')'
  44+ 56FE               ENDIF
  45+ 56FE              .COMMON:
  46+ 56FE              	; save BASIC token position
  47+ 56FE E5           	PUSH HL
  48+ 56FF D9               EXX
  49+ 5700 E1           	POP HL ; HL'=next basic token
  50+ 5701 D9               EXX
  51+ 5702
  52+ 5702 E1               POP HL ; get pointer to register values
  53+ 5703 F3           	DI
  54+ 5704 ED 73 41 5F      LD (TMP_STRUCT), SP
  55+ 5708 F9               LD SP, HL
  56+ 5709 F1               POP AF
  57+ 570A C1               POP BC
  58+ 570B D1               POP DE
  59+ 570C E1               POP HL
  60+ 570D DD E1            POP IX
  61+ 570F FD E1            POP IY
  62+ 5711 D9               EXX
  63+ 5712 ED 73 43 5F      LD (TMP_STRUCT+2), SP
  64+ 5716 ED 7B 41 5F      LD SP, (TMP_STRUCT)
  65+ 571A FB               EI
  66+ 571B D1               POP DE ; get function to call
  67+ 571C E5               PUSH HL
  68+ 571D CD 39 57         CALL .EXXDECALL
  69+ 5720 F3               DI
  70+ 5721 ED 73 41 5F      LD (TMP_STRUCT), SP
  71+ 5725 ED 7B 43 5F      LD SP, (TMP_STRUCT+2)
  72+ 5729 FD E5            PUSH IY
  73+ 572B DD E5            PUSH IX
  74+ 572D E5               PUSH HL
  75+ 572E D5               PUSH DE
  76+ 572F C5               PUSH BC
  77+ 5730 F5               PUSH AF
  78+ 5731 ED 7B 41 5F      LD SP, (TMP_STRUCT)
  79+ 5735 FB               EI
  80+ 5736 E1               POP HL
  81+ 5737 AF               XOR A ; success
  82+ 5738 C9           	RET
  83+ 5739
  84+ 5739              .EXXDECALL:
  85+ 5739 D5               PUSH DE
  86+ 573A D9               EXX
  87+ 573B C9               RET
  88+ 573C              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
 156  573C               ENDIF
 157  573C
 158  573C               IF (BOX_CMDS == 1)
 159  573C               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
   1+ 573C              ; *******************************************************************************************************
   2+ 573C              ; generic function to implement rectangle data copy
   3+ 573C              ; should be modified to call appropriate function for memory or vram
   4+ 573C              ; input IX=pointer to following structure
   5+ 573C              ; +00 source data pointer
   6+ 573C              ; +02 num bytes in a row
   7+ 573C              ; +04 number of rows
   8+ 573C              ; +06 source add-to value till next row
   9+ 573C              ; +08 destination address
  10+ 573C              ; +10 destination add-to value till next row
  11+ 573C              ; modifies AF, BC, DE, HL
  12+ 573C              RECTANGLE_COPY:
  13+ 573C DD 6E 00     	LD L, (IX+0)
  14+ 573F DD 66 01     	LD H, (IX+1) ; source address
  15+ 5742 DD 5E 08     	LD E, (IX+8)
  16+ 5745 DD 56 09     	LD D, (IX+9) ; destination
  17+ 5748 DD 46 04     	LD B, (IX+4) ; row number
  18+ 574B              .L1:
  19+ 574B C5           	PUSH BC
  20+ 574C E5           		PUSH HL
  21+ 574D D5           			PUSH DE
  22+ 574E DD 4E 02     				LD C, (IX+2)
  23+ 5751 DD 46 03     				LD B, (IX+3) ; num bytes in a row
  24+ 5754              .CALL1:
  25+ 5754 CD 00 00     				CALL 0 ; set destination address from DE
  26+ 5757              .CALL2:
  27+ 5757 CD 00 00     				CALL 0 ; copy data fn
  28+ 575A E1           			POP HL
  29+ 575B DD 4E 0A     			LD C, (IX+10)
  30+ 575E DD 46 0B     			LD B, (IX+11) ; destination add-to
  31+ 5761 09           			ADD HL, BC
  32+ 5762 EB           			EX DE, HL
  33+ 5763 E1           		POP HL
  34+ 5764 DD 4E 06     		LD C, (IX+6)
  35+ 5767 DD 46 07     		LD B, (IX+7) ; src add-to
  36+ 576A 09           		ADD HL, BC
  37+ 576B C1           	POP BC
  38+ 576C 10 DD        	DJNZ .L1
  39+ 576E C9           	RET
  40+ 576F              ; *******************************************************************************************************
  41+ 576F
  42+ 576F               IF (0 == 1)
  43+ 576F ~            ; *******************************************************************************************************
  44+ 576F ~            ; function to handle CALL BOXMEMCPY basic extension
  45+ 576F ~            ; copies data with window like boundaries within ram
  46+ 576F ~            ; BOXMEMCPY ( INT source data pointer,
  47+ 576F ~            ;			  INT source number of bytes in a row,
  48+ 576F ~            ;			  INT number of rows,
  49+ 576F ~            ;			  INT source add-to value till next row,
  50+ 576F ~            ; 			  INT destination pointer,
  51+ 576F ~            ;			  INT destination add-to value till next row )
  52+ 576F ~            ; request_data_ptr described in RECTANGLE_COPY
  53+ 576F ~            ; will put ram in page 0 also, page 1 is already there
  54+ 576F ~            BOXMEMCPY:
  55+ 576F ~            	LD DE,BOXMEMCPY_COMMON
  56+ 576F ~            	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
  57+ 576F ~            	JP BOX_EXTENSION_PARAMS_COMMON
  58+ 576F               ENDIF
  59+ 576F
  60+ 576F               IF (1 == 1)
  61+ 576F              ; *******************************************************************************************************
  62+ 576F              ; same as BOXMEMCPY but for DEFUSR approach
  63+ 576F              ; input IX=pointer to input array, real data from +2
  64+ 576F              ; +02 = source data pointer
  65+ 576F              ; +04 = source number of bytes in a row
  66+ 576F              ; +06 = number of rows
  67+ 576F              ; +08 = source add-to value till next row
  68+ 576F              ; +10 = destination pointer
  69+ 576F              ; +12 = destination add-to value till next row
  70+ 576F              BOXMEMCPY_DEFUSR:
  71+ 576F 21 7C 57     	LD HL,BOXMEMCPY_COMMON
  72+ 5772 22 92 57     	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
  73+ 5775 DD 23        	INC IX
  74+ 5777 DD 23        	INC IX
  75+ 5779 C3 8F 57     	JP BOXCOMMON_DEFUSR
  76+ 577C               ENDIF
  77+ 577C
  78+ 577C              BOXMEMCPY_COMMON:
  79+ 577C FB           	EI
  80+ 577D              	; set RAM functions to call
  81+ 577D 21 00 00     	LD HL, 0
  82+ 5780 22 54 57     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
  83+ 5783 22 56 57     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
  84+ 5786 21 ED B0     	LD HL, #B0ED ; LDIR
  85+ 5789 22 58 57     	LD (RECTANGLE_COPY.CALL1+4), HL
  86+ 578C C3 97 57     	JP BOXCOMMON_DEFUSR.CALL
  87+ 578F              ; *******************************************************************************************************
  88+ 578F
  89+ 578F               IF (0 == 1)
  90+ 578F ~            ; *******************************************************************************************************
  91+ 578F ~            ; common parts of BOX commands to load parameters
  92+ 578F ~            BOX_EXTENSION_PARAMS_COMMON:
  93+ 578F ~            	; opening (
  94+ 578F ~            	CALL CHKCHAR
  95+ 578F ~            	DB '('
  96+ 578F ~            	; get source data pointer
  97+ 578F ~            	LD IX, FRMQNT
  98+ 578F ~            	CALL CALBAS
  99+ 578F ~            	LD (TMP_STRUCT+0), DE
 100+ 578F ~            	; comma
 101+ 578F ~            	CALL CHKCHAR
 102+ 578F ~            	DB ','
 103+ 578F ~            	; source number of bytes in a row
 104+ 578F ~            	LD IX, FRMQNT
 105+ 578F ~            	CALL CALBAS
 106+ 578F ~            	LD (TMP_STRUCT+2), DE
 107+ 578F ~            	; comma
 108+ 578F ~            	CALL CHKCHAR
 109+ 578F ~            	DB ','
 110+ 578F ~            	; number of rows
 111+ 578F ~            	LD IX, FRMQNT
 112+ 578F ~            	CALL CALBAS
 113+ 578F ~            	LD (TMP_STRUCT+4), DE
 114+ 578F ~            	; comma
 115+ 578F ~            	CALL CHKCHAR
 116+ 578F ~            	DB ','
 117+ 578F ~            	; source add-to value till next row
 118+ 578F ~            	LD IX, FRMQNT
 119+ 578F ~            	CALL CALBAS
 120+ 578F ~            	LD (TMP_STRUCT+6), DE
 121+ 578F ~            	; comma
 122+ 578F ~            	CALL CHKCHAR
 123+ 578F ~            	DB ','
 124+ 578F ~            	; destination pointer
 125+ 578F ~            	LD IX, FRMQNT
 126+ 578F ~            	CALL CALBAS
 127+ 578F ~            	LD (TMP_STRUCT+8), DE
 128+ 578F ~            	; comma
 129+ 578F ~            	CALL CHKCHAR
 130+ 578F ~            	DB ','
 131+ 578F ~            	; destination add-to value till next row
 132+ 578F ~            	LD IX, FRMQNT
 133+ 578F ~            	CALL CALBAS
 134+ 578F ~            	LD (TMP_STRUCT+10), DE
 135+ 578F ~            	; ending )
 136+ 578F ~            	CALL CHKCHAR
 137+ 578F ~            	DB ')'
 138+ 578F ~            	LD IX,TMP_STRUCT
 139+ 578F               ENDIF
 140+ 578F              BOXCOMMON_DEFUSR:
 141+ 578F E5           	PUSH HL ; save position in BASIC buffer
 142+ 5790              .ADDR:
 143+ 5790 FD 21 00 00  	LD IY, 0 ; modified by code
 144+ 5794 C3 7F 60     	JP ENABLE_PAGE0
 145+ 5797              .CALL:
 146+ 5797 CD 3C 57     	CALL RECTANGLE_COPY
 147+ 579A AF           	XOR A
 148+ 579B 32 52 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 149+ 579E C3 95 5F         JP COMMON_EXIT_CODE
 150+ 57A1              ; *******************************************************************************************************
 151+ 57A1
 152+ 57A1               IF (0 == 1)
 153+ 57A1 ~            ; *******************************************************************************************************
 154+ 57A1 ~            ; function to handle CALL BOXMEMVRM basic extension
 155+ 57A1 ~            ; copies data with window like boundaries from ram to Vram
 156+ 57A1 ~            ; BOXMEMVRM ( INT source data pointer,
 157+ 57A1 ~            ;			  INT source number of bytes in a row,
 158+ 57A1 ~            ;			  INT number of rows,
 159+ 57A1 ~            ;			  INT source add-to value till next row,
 160+ 57A1 ~            ; 			  INT destination pointer,
 161+ 57A1 ~            ;			  INT destination add-to value till next row )
 162+ 57A1 ~            ; request_data_ptr described in RECTANGLE_COPY
 163+ 57A1 ~            ; will put ram in page 0 also, page 1 is already there
 164+ 57A1 ~            BOXMEMVRM:
 165+ 57A1 ~            	LD DE,BOXMEMVRM_COMMON
 166+ 57A1 ~            	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
 167+ 57A1 ~            	JP BOX_EXTENSION_PARAMS_COMMON
 168+ 57A1               ENDIF
 169+ 57A1
 170+ 57A1               IF (1 == 1)
 171+ 57A1              ; *******************************************************************************************************
 172+ 57A1              ; same as BOXMEMVRM but for DEFUSR approach
 173+ 57A1              ; input IX=pointer to input array, real data from +2
 174+ 57A1              ; +02 = source data pointer
 175+ 57A1              ; +04 = source number of bytes in a row
 176+ 57A1              ; +06 = number of rows
 177+ 57A1              ; +08 = source add-to value till next row
 178+ 57A1              ; +10 = destination pointer
 179+ 57A1              ; +12 = destination add-to value till next row
 180+ 57A1              BOXMEMVRM_DEFUSR:
 181+ 57A1 21 AE 57     	LD HL,BOXMEMVRM_COMMON
 182+ 57A4 22 92 57     	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
 183+ 57A7 DD 23        	INC IX
 184+ 57A9 DD 23        	INC IX
 185+ 57AB C3 8F 57     	JP BOXCOMMON_DEFUSR
 186+ 57AE               ENDIF
 187+ 57AE
 188+ 57AE              BOXMEMVRM_COMMON:
 189+ 57AE FB           	EI
 190+ 57AF              	; set RAM functions to call
 191+ 57AF 21 C9 57     	LD HL, .SETDEST
 192+ 57B2 22 55 57     	LD (RECTANGLE_COPY.CALL1+1), HL
 193+ 57B5 21 D1 57     	LD HL, .COPYDATA
 194+ 57B8 22 58 57     	LD (RECTANGLE_COPY.CALL2+1), HL
 195+ 57BB 3E CD        	LD A, #CD ; CALL
 196+ 57BD 32 54 57     	LD (RECTANGLE_COPY.CALL1), A
 197+ 57C0 32 57 57     	LD (RECTANGLE_COPY.CALL2), A
 198+ 57C3              	;LD A,1
 199+ 57C3 32 52 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 200+ 57C6 C3 97 57     	JP BOXCOMMON_DEFUSR.CALL
 201+ 57C9              .SETDEST:
 202+ 57C9 EB           	EX DE, HL
 203+ 57CA F3           	DI
 204+ 57CB CD 9C 5F     	CALL SETWRT_LOCAL_WRITE
 205+ 57CE FB           	EI
 206+ 57CF EB           	EX DE, HL
 207+ 57D0 C9           	RET
 208+ 57D1              .COPYDATA:
 209+ 57D1 41           	LD B, C
 210+ 57D2 C3 B1 5F     	JP BBYTECOPY
 211+ 57D5              ; *******************************************************************************************************
# file closed: asm\BOX.asm
 160  57D5               ENDIF
 161  57D5
 162  57D5               IF (BLIT_CMDS == 1)
 163  57D5               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
   1+ 57D5              ; *******************************************************************************************************
   2+ 57D5              ; function rotates mask and data of several characters and applies to background data
   3+ 57D5              ; this handles x-shift from 0 to 4
   4+ 57D5              ; contains self-modifying code that is set-up from external function
   5+ 57D5              ; input HL=pointer to mask data
   6+ 57D5              ; input HL'=pointer to character data
   7+ 57D5              ; input DE=output buffer containing background data
   8+ 57D5              ; input BC=DE+8
   9+ 57D5              ; input A=number of characters to process
  10+ 57D5              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  11+ 57D5              SHIFT04:
  12+ 57D5 08           	EX AF, AF'
  13+ 57D6 7E           	LD A, (HL) ; get mask
  14+ 57D7 D9           	EXX
  15+ 57D8 57           	LD D, A
  16+ 57D9 1E FF        	LD E, #FF
  17+ 57DB 37           	SCF
  18+ 57DC              .M1:
  19+ 57DC 18 FE        	JR .M1 ; this is self-modifying part
  20+ 57DE CB 1A        	RR D
  21+ 57E0 CB 1B        	RR E
  22+ 57E2 CB 1A        	RR D
  23+ 57E4 CB 1B        	RR E
  24+ 57E6 CB 1A        	RR D
  25+ 57E8 CB 1B        	RR E
  26+ 57EA CB 1A        	RR D
  27+ 57EC CB 1B        	RR E
  28+ 57EE
  29+ 57EE 46           	LD B, (HL) ; get data
  30+ 57EF 0E 00        	LD C, 0
  31+ 57F1              .M2:
  32+ 57F1 18 FE        	JR .M2 ; also self-modifying part
  33+ 57F3 CB 38        	SRL B
  34+ 57F5 CB 19        	RR C
  35+ 57F7 CB 38        	SRL B
  36+ 57F9 CB 19        	RR C
  37+ 57FB CB 38        	SRL B
  38+ 57FD CB 19        	RR C
  39+ 57FF CB 38        	SRL B
  40+ 5801 CB 19        	RR C
  41+ 5803
  42+ 5803 D9           	EXX
  43+ 5804 1A           	LD A, (DE) ; background
  44+ 5805 D9           	EXX
  45+ 5806 A2           	AND D
  46+ 5807 B0           	OR B
  47+ 5808 D9           	EXX
  48+ 5809 12           	LD (DE), A
  49+ 580A
  50+ 580A 0A           	LD A, (BC)
  51+ 580B D9           	EXX
  52+ 580C A3           	AND E
  53+ 580D B1           	OR C
  54+ 580E 23           	INC HL
  55+ 580F D9           	EXX
  56+ 5810 02           	LD (BC), A
  57+ 5811
  58+ 5811 23           	INC HL
  59+ 5812 13           	INC DE
  60+ 5813 03           	INC BC
  61+ 5814
  62+ 5814 08           	EX AF, AF'
  63+ 5815 3D           	DEC A
  64+ 5816 C2 D5 57     	JP NZ, SHIFT04
  65+ 5819 C9           	RET
  66+ 581A              ; *******************************************************************************************************
  67+ 581A
  68+ 581A              ; *******************************************************************************************************
  69+ 581A              ; function rotates mask and data of several characters and applies to background data
  70+ 581A              ; this handles x-shift from 5 to 8
  71+ 581A              ; contains self-modifying code that is set-up from external function
  72+ 581A              ; input HL=pointer to mask data
  73+ 581A              ; input HL'=pointer to character data
  74+ 581A              ; input DE=output buffer containing background data
  75+ 581A              ; input BC=DE+8
  76+ 581A              ; input A=number of characters to process
  77+ 581A              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  78+ 581A              SHIFT58:
  79+ 581A 08           	EX AF, AF'
  80+ 581B 7E           	LD A, (HL) ; get mask
  81+ 581C D9           	EXX
  82+ 581D 57           	LD D, A
  83+ 581E 1E FF        	LD E, #FF
  84+ 5820 37           	SCF
  85+ 5821              .M1:
  86+ 5821 18 FE        	JR .M1 ; this is self-modifying part
  87+ 5823 CB 12        	RL D
  88+ 5825 CB 13        	RL E
  89+ 5827 CB 12        	RL D
  90+ 5829 CB 13        	RL E
  91+ 582B CB 12        	RL D
  92+ 582D CB 13        	RL E
  93+ 582F
  94+ 582F 46           	LD B, (HL)
  95+ 5830 0E 00        	LD C, 0
  96+ 5832              .M2:
  97+ 5832 18 FE        	JR .M2 ; also self-modifying part
  98+ 5834 CB 20        	SLA B
  99+ 5836 CB 11        	RL C
 100+ 5838 CB 20        	SLA B
 101+ 583A CB 11        	RL C
 102+ 583C CB 20        	SLA B
 103+ 583E CB 11        	RL C
 104+ 5840
 105+ 5840 D9           	EXX
 106+ 5841 1A           	LD A, (DE) ; background
 107+ 5842 D9           	EXX
 108+ 5843 A3           	AND E
 109+ 5844 B1           	OR C
 110+ 5845 D9           	EXX
 111+ 5846 12           	LD (DE), A
 112+ 5847
 113+ 5847 0A           	LD A, (BC)
 114+ 5848 D9           	EXX
 115+ 5849 A2           	AND D
 116+ 584A B0           	OR B
 117+ 584B 23           	INC HL
 118+ 584C D9           	EXX
 119+ 584D 02           	LD (BC), A
 120+ 584E
 121+ 584E 23           	INC HL
 122+ 584F 13           	INC DE
 123+ 5850 03           	INC BC
 124+ 5851
 125+ 5851 08           	EX AF, AF'
 126+ 5852 3D           	DEC A
 127+ 5853 C2 1A 58     	JP NZ, SHIFT58
 128+ 5856 C9           	RET
 129+ 5857              ; *******************************************************************************************************
 130+ 5857
 131+ 5857              ; *******************************************************************************************************
 132+ 5857              ; routine that shifts one row of characters
 133+ 5857              ; contains self-modifying code that is set-up from external function
 134+ 5857              ; input HL=pointer to mask data
 135+ 5857              ; input HL'=pointer to character data
 136+ 5857              ; input DE=output buffer containing background data
 137+ 5857              ; input A=number of characters to process
 138+ 5857              ; input IX=pointer to structure describing input data
 139+ 5857              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 140+ 5857              SHIFT_ROW:
 141+ 5857 F5           	PUSH AF
 142+ 5858 ED 53 3D 5F  		LD (BLIT_TMP1), DE
 143+ 585C E5           		PUSH HL
 144+ 585D CD A0 58     			CALL .ADDYSHIFT
 145+ 5860 E1           		POP HL
 146+ 5861 ED 53 3F 5F  		LD (BLIT_TMP2), DE ; DE+vertical shift
 147+ 5865              .L1:
 148+ 5865 3E 08        		LD A, 8
 149+ 5867 DD 96 02     		SUB (IX+2) ; y shift
 150+ 586A              .CALL1:
 151+ 586A CD 00 00     		CALL 0
 152+ 586D DD 7E 02     		LD A, (IX+2); y shift
 153+ 5870 B7           		OR A
 154+ 5871 28 26        		JR Z, .DONE
 155+ 5873 ED 5B 3D 5F  		LD DE, (BLIT_TMP1)
 156+ 5877 E5           		PUSH HL
 157+ 5878 CD AE 58     			CALL .DETONEXTROW
 158+ 587B E1           		POP HL
 159+ 587C              .CALL2:
 160+ 587C CD 00 00     		CALL 0
 161+ 587F ED 5B 3D 5F  		LD DE, (BLIT_TMP1)
 162+ 5883 E5           		PUSH HL
 163+ 5884 CD A8 58     			CALL .ADD8
 164+ 5887 E1           		POP HL
 165+ 5888 ED 53 3D 5F  		LD (BLIT_TMP1), DE
 166+ 588C ED 5B 3F 5F  		LD DE, (BLIT_TMP2)
 167+ 5890 E5           		PUSH HL
 168+ 5891 CD A8 58     			CALL .ADD8
 169+ 5894 E1           		POP HL
 170+ 5895 ED 53 3F 5F  		LD (BLIT_TMP2), DE ; DE+vertical shift
 171+ 5899              .DONE:
 172+ 5899 F1           	POP AF
 173+ 589A 3D           	DEC A
 174+ 589B C8           	RET Z
 175+ 589C F5           	PUSH AF
 176+ 589D C3 65 58     	JP .L1
 177+ 58A0              .ADDYSHIFT:
 178+ 58A0 EB           	EX DE, HL
 179+ 58A1 16 00        	LD D, 0
 180+ 58A3 DD 5E 02     	LD E, (IX+2); y shift
 181+ 58A6 18 0C        	JR .MOVDEBC
 182+ 58A8              .ADD8:
 183+ 58A8 21 08 00     	LD HL, 8
 184+ 58AB C3 B4 58     	JP .MOVDEBC
 185+ 58AE              .DETONEXTROW:
 186+ 58AE DD 6E 06     	LD L, (IX+6)
 187+ 58B1 DD 66 07     	LD H, (IX+7) ; bkg add to value
 188+ 58B4              .MOVDEBC:
 189+ 58B4 19           	ADD HL, DE
 190+ 58B5 54           	LD D, H
 191+ 58B6 5D           	LD E, L
 192+ 58B7 01 08 00     	LD BC, 8
 193+ 58BA 09           	ADD HL, BC
 194+ 58BB 44           	LD B, H
 195+ 58BC 4D           	LD C, L
 196+ 58BD C9           	RET
 197+ 58BE              ; *******************************************************************************************************
 198+ 58BE
 199+ 58BE              ; *******************************************************************************************************
 200+ 58BE              ; function rotates mask and character data and applies it to background
 201+ 58BE              ; input IX=pointer to structure describing input data
 202+ 58BE              ; +0  DW horizontal shift count 0-7 (low byte used)
 203+ 58BE              ; +2  DW vertical shift count 0-7 (low byte used)
 204+ 58BE              ; +4  DW background data start;
 205+ 58BE              ; +6  DW background add to value to next row of background data
 206+ 58BE              ; +8  DW mask data start;
 207+ 58BE              ; +10  DW character data start;
 208+ 58BE              ; +12 DW character&mask add to value to next row of data
 209+ 58BE              ; +14 DW columns (low byte used)
 210+ 58BE              ; +16 DW rows (low byte used)
 211+ 58BE              SHIFT_MERGE_CHARACTER:
 212+ 58BE DD 7E 00     	LD A, (IX) ; shift
 213+ 58C1 FE 05        	CP 5
 214+ 58C3 38 25        	JR C, .RIGHT
 215+ 58C5              	; shifts 5-7, use rotate towards left 1-3
 216+ 58C5 21 1A 58     	LD HL, SHIFT58
 217+ 58C8 22 6B 58     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 218+ 58CB 22 7D 58     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 219+ 58CE D6 05        	SUB 5
 220+ 58D0 28 0D        	JR Z, .L1
 221+ 58D2 87           	ADD A, A
 222+ 58D3 87           	ADD A, A
 223+ 58D4 67           	LD H, A
 224+ 58D5 2E 18        	LD L, #18 ; JR opcode
 225+ 58D7 22 21 58     	LD (SHIFT58.M1), HL
 226+ 58DA 22 32 58     	LD (SHIFT58.M2), HL
 227+ 58DD 18 32        	JR .DO
 228+ 58DF              .L1:
 229+ 58DF 21 00 00     	LD HL, 0 ; 2xNOP opcode
 230+ 58E2 22 21 58     	LD (SHIFT58.M1), HL
 231+ 58E5 22 32 58     	LD (SHIFT58.M2), HL
 232+ 58E8 18 27        	JR .DO
 233+ 58EA              .RIGHT:
 234+ 58EA              	; shifts 0-4, rotate towards right
 235+ 58EA 21 D5 57     	LD HL, SHIFT04
 236+ 58ED 22 6B 58     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 237+ 58F0 22 7D 58     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 238+ 58F3 FE 04        	CP 4
 239+ 58F5 28 11        	JR Z, .R1
 240+ 58F7 D6 04        	SUB 4
 241+ 58F9 ED 44        	NEG
 242+ 58FB 87           	ADD A, A
 243+ 58FC 87           	ADD A, A
 244+ 58FD 67           	LD H, A
 245+ 58FE 2E 18        	LD L, #18 ; JR opcode
 246+ 5900 22 DC 57     	LD (SHIFT04.M1), HL
 247+ 5903 22 F1 57     	LD (SHIFT04.M2), HL
 248+ 5906 18 09        	JR .DO
 249+ 5908              .R1:
 250+ 5908 21 00 00     	LD HL, 0 ; 2xNOP opcode
 251+ 590B 22 DC 57     	LD (SHIFT04.M1), HL
 252+ 590E 22 F1 57     	LD (SHIFT04.M2), HL
 253+ 5911              .DO:
 254+ 5911 DD 46 10     	LD B, (IX+16) ; rows
 255+ 5914 DD 6E 08     	LD L, (IX+8)
 256+ 5917 DD 66 09     	LD H, (IX+9) ; mask data
 257+ 591A DD 5E 04     	LD E, (IX+4)
 258+ 591D DD 56 05     	LD D, (IX+5) ; background data
 259+ 5920 D9           	EXX
 260+ 5921 DD 6E 0A     	LD L, (IX+10)
 261+ 5924 DD 66 0B     	LD H, (IX+11) ; character data
 262+ 5927 D9           	EXX
 263+ 5928              .LOOP:
 264+ 5928 C5           	PUSH BC
 265+ 5929 E5           		PUSH HL
 266+ 592A D5           			PUSH DE
 267+ 592B D9           				EXX
 268+ 592C E5           				PUSH HL
 269+ 592D D9           					EXX
 270+ 592E DD 7E 0E     					LD A, (IX+14) ; columns
 271+ 5931              .CALL:
 272+ 5931 CD 57 58     					CALL SHIFT_ROW
 273+ 5934 E1           				POP HL
 274+ 5935 DD 5E 0C     				LD E, (IX+12)
 275+ 5938 DD 56 0D     				LD D, (IX+13) ; char data to next row
 276+ 593B 19           				ADD HL, DE
 277+ 593C D9           				EXX
 278+ 593D E1           			POP HL
 279+ 593E DD 5E 06     			LD E, (IX+6)
 280+ 5941 DD 56 07     			LD D, (IX+7) ; background to next row
 281+ 5944 19           			ADD HL, DE
 282+ 5945 EB           			EX DE, HL
 283+ 5946 E1           		POP HL
 284+ 5947 DD 4E 0C     		LD C, (IX+12)
 285+ 594A DD 46 0D     		LD B, (IX+13) ; char data to next row
 286+ 594D 09           		ADD HL, BC
 287+ 594E C1           	POP BC
 288+ 594F 10 D7        	DJNZ .LOOP
 289+ 5951 C9           	RET
 290+ 5952              ; *******************************************************************************************************
 291+ 5952
 292+ 5952              ; *******************************************************************************************************
 293+ 5952              ; helper function DE \ 8
 294+ 5952              DEdiv8:
 295+ 5952 7B           	LD A,E
 296+ 5953 CB 2A        	SRA D
 297+ 5955 CB 1F            RR  A
 298+ 5957 CB 2A            SRA D
 299+ 5959 CB 1F            RR  A
 300+ 595B CB 2A            SRA D
 301+ 595D CB 1F            RR  A
 302+ 595F C9           	RET
 303+ 5960              ; *******************************************************************************************************
 304+ 5960
 305+ 5960               IF (1 == 1)
 306+ 5960              ; *******************************************************************************************************
 307+ 5960              ; function to handle BLIT basic extension through DEFUSR call in RAW format
 308+ 5960              ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 309+ 5960              ; +2  DW horizontal shift count 0-7 (low byte used)
 310+ 5960              ; +4  DW vertical shift count 0-7 (low byte used)
 311+ 5960              ; +6  DW background data start;
 312+ 5960              ; +8  DW background add to value to next row of background data
 313+ 5960              ; +10  DW mask data start;
 314+ 5960              ; +12  DW character data start;
 315+ 5960              ; +14 DW character&mask add to value to next row of data
 316+ 5960              ; +16 DW columns (low byte used)
 317+ 5960              ; +18 DW rows (low byte used)
 318+ 5960              ; will put ram in page 0 also, page 1 is already there
 319+ 5960              ;BLIT_DEFUSR:
 320+ 5960              ;	DI
 321+ 5960              ;	LD IY, .RET
 322+ 5960              ;	JP ENABLE_PAGE0
 323+ 5960              ;.RET:
 324+ 5960              ;	EI
 325+ 5960              ;	INC IX
 326+ 5960              ;	INC IX
 327+ 5960              ;	CALL SHIFT_MERGE_CHARACTER
 328+ 5960              ;
 329+ 5960              ;   POP DE
 330+ 5960              ;    POP BC
 331+ 5960              ;    JP RESTORE_PAGE_INFO
 332+ 5960              ; *******************************************************************************************************
 333+ 5960
 334+ 5960              ; *******************************************************************************************************
 335+ 5960              ; function to handle CALL BLIT basic extension in DEFUSR form
 336+ 5960              ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 337+ 5960              ; +02 x
 338+ 5960              ; +04 y
 339+ 5960              ; +06 char_data_pointer
 340+ 5960              ; +08 mask_data_pointer
 341+ 5960              ; +10 width
 342+ 5960              ; +12 height
 343+ 5960              ; +14 background_pointer
 344+ 5960              ; +16 background_width
 345+ 5960              ; BLIT ( INT x,
 346+ 5960              ;		 INT y,
 347+ 5960              ;		 INT char_data_pointer,
 348+ 5960              ;		 INT mask_data_pointer,
 349+ 5960              ;		 INT width (in characters),
 350+ 5960              ;		 INT height (in characters),
 351+ 5960              ;		 INT background_pointer (top left),
 352+ 5960              ;		 INT background_width (in characters),
 353+ 5960              BLIT_DEFUSR:
 354+ 5960 DD 5E 02     	LD E,(IX+2)
 355+ 5963 DD 56 03     	LD D,(IX+3)
 356+ 5966 7B           	LD A,E
 357+ 5967 E6 07        	AND 7
 358+ 5969 32 41 5F     	LD (TMP_STRUCT+0),A
 359+ 596C CD 52 59     	CALL DEdiv8
 360+ 596F 32 3D 5F     	LD (BLIT_TMP+0),A
 361+ 5972 DD 5E 04     	LD E,(IX+4)
 362+ 5975 DD 56 05     	LD D,(IX+5)
 363+ 5978 7B           	LD A,E
 364+ 5979 E6 07        	AND 7
 365+ 597B 32 43 5F     	LD (TMP_STRUCT+2),A
 366+ 597E CD 52 59     	CALL DEdiv8
 367+ 5981 32 3E 5F     	LD (BLIT_TMP+1),A
 368+ 5984 DD 6E 06     	LD L,(IX+6)
 369+ 5987 DD 66 07     	LD H,(IX+7)
 370+ 598A 22 4B 5F     	LD (TMP_STRUCT+10),HL
 371+ 598D DD 6E 08     	LD L,(IX+8)
 372+ 5990 DD 66 09     	LD H,(IX+9)
 373+ 5993 22 49 5F     	LD (TMP_STRUCT+8),HL
 374+ 5996 DD 7E 0A     	LD A,(IX+10)
 375+ 5999 32 4F 5F     	LD (TMP_STRUCT+14),A
 376+ 599C DD 7E 0C     	LD A,(IX+12)
 377+ 599F 32 51 5F     	LD (TMP_STRUCT+16),A
 378+ 59A2 DD 6E 0E     	LD L,(IX+14)
 379+ 59A5 DD 66 0F     	LD H,(IX+15)
 380+ 59A8 22 45 5F     	LD (TMP_STRUCT+4),HL
 381+ 59AB              	;LD A,(IX+16)
 382+ 59AB              	;LD (BLIT_TMP+2),A
 383+ 59AB
 384+ 59AB              	; calculate char&mask add to value
 385+ 59AB 26 00        	LD H,0
 386+ 59AD 3A 4F 5F     	LD A,(TMP_STRUCT+14)
 387+ 59B0 6F           	LD L,A
 388+ 59B1 CD BB 5F     	CALL HLx8
 389+ 59B4 22 4D 5F     	LD (TMP_STRUCT+12),HL
 390+ 59B7              	; calculate background add to value
 391+ 59B7 26 00        	LD H,0
 392+ 59B9 DD 6E 10     	LD L,(IX+16)
 393+ 59BC CD BB 5F     	CALL HLx8
 394+ 59BF 22 47 5F     	LD (TMP_STRUCT+6),HL
 395+ 59C2              	; calculate pointer to background location
 396+ 59C2 21 00 00     	LD HL,0
 397+ 59C5 3A 3E 5F     	LD A,(BLIT_TMP+1)
 398+ 59C8 B7           	OR A
 399+ 59C9 28 08        	JR Z, .L1
 400+ 59CB 47           	LD B,A
 401+ 59CC ED 5B 47 5F  	LD DE,(TMP_STRUCT+6)
 402+ 59D0              .L0:
 403+ 59D0 19           	ADD HL, DE
 404+ 59D1 10 FD        	DJNZ .L0
 405+ 59D3              .L1:
 406+ 59D3 EB           	EX DE,HL
 407+ 59D4 26 00        	LD H,0
 408+ 59D6 3A 3D 5F     	LD A,(BLIT_TMP+0)
 409+ 59D9 6F           	LD L,A
 410+ 59DA CD BB 5F     	CALL HLx8
 411+ 59DD 19           	ADD HL,DE
 412+ 59DE ED 5B 45 5F  	LD DE,(TMP_STRUCT+4)
 413+ 59E2 19           	ADD HL,DE
 414+ 59E3 22 45 5F     	LD (TMP_STRUCT+4),HL
 415+ 59E6
 416+ 59E6 FD 21 ED 59  	LD IY, .RET
 417+ 59EA C3 7F 60     	JP ENABLE_PAGE0
 418+ 59ED              .RET:
 419+ 59ED FB           	EI
 420+ 59EE DD 21 41 5F  	LD IX, TMP_STRUCT
 421+ 59F2 CD BE 58     	CALL SHIFT_MERGE_CHARACTER
 422+ 59F5 C3 95 5F         JP COMMON_EXIT_CODE
 423+ 59F8              ; *******************************************************************************************************
 424+ 59F8               ENDIF
 425+ 59F8
 426+ 59F8               IF (0 == 1)
 427+ 59F8 ~            ; *******************************************************************************************************
 428+ 59F8 ~            ; function to handle CALL BLIT basic extension
 429+ 59F8 ~            ; rotates 1-bit character drawing horizontally with mask and character data and
 430+ 59F8 ~            ; fuses with background data and applies vertical shift too
 431+ 59F8 ~            ; in form without pointers
 432+ 59F8 ~            ; BLIT ( INT x,
 433+ 59F8 ~            ;		 INT y,
 434+ 59F8 ~            ;		 INT char_data_pointer,
 435+ 59F8 ~            ;		 INT mask_data_pointer,
 436+ 59F8 ~            ;		 INT width (in characters),
 437+ 59F8 ~            ;		 INT height (in characters),
 438+ 59F8 ~            ;		 INT background_pointer (top left),
 439+ 59F8 ~            ;		 INT background_width (in characters),
 440+ 59F8 ~            ; will put ram in page 0 also, page 1 is already there
 441+ 59F8 ~            BLIT:
 442+ 59F8 ~            	; opening (
 443+ 59F8 ~            	CALL CHKCHAR
 444+ 59F8 ~            	DB '('
 445+ 59F8 ~            	; get x coordinate
 446+ 59F8 ~            	LD IX, FRMQNT
 447+ 59F8 ~            	CALL CALBAS
 448+ 59F8 ~            	LD A, E
 449+ 59F8 ~            	AND 7
 450+ 59F8 ~            	LD (TMP_STRUCT+0), A
 451+ 59F8 ~            	CALL DEdiv8
 452+ 59F8 ~            	LD (BLIT_TMP+0),A
 453+ 59F8 ~            	; comma
 454+ 59F8 ~            	CALL CHKCHAR
 455+ 59F8 ~            	DB ','
 456+ 59F8 ~            	; get y coordinate
 457+ 59F8 ~            	LD IX, FRMQNT
 458+ 59F8 ~            	CALL CALBAS
 459+ 59F8 ~            	LD A, E
 460+ 59F8 ~            	AND 7
 461+ 59F8 ~            	LD (TMP_STRUCT+2), A
 462+ 59F8 ~            	CALL DEdiv8
 463+ 59F8 ~            	LD (BLIT_TMP+1),A
 464+ 59F8 ~            	; comma
 465+ 59F8 ~            	CALL CHKCHAR
 466+ 59F8 ~            	DB ','
 467+ 59F8 ~            	; get char data pointer
 468+ 59F8 ~            	LD IX, FRMQNT
 469+ 59F8 ~            	CALL CALBAS
 470+ 59F8 ~            	LD (TMP_STRUCT+10), DE
 471+ 59F8 ~            	; comma
 472+ 59F8 ~            	CALL CHKCHAR
 473+ 59F8 ~            	DB ','
 474+ 59F8 ~            	; get mask data pointer
 475+ 59F8 ~            	LD IX, FRMQNT
 476+ 59F8 ~            	CALL CALBAS
 477+ 59F8 ~            	LD (TMP_STRUCT+8), DE
 478+ 59F8 ~            	; comma
 479+ 59F8 ~            	CALL CHKCHAR
 480+ 59F8 ~            	DB ','
 481+ 59F8 ~            	; get width
 482+ 59F8 ~            	LD IX, FRMQNT
 483+ 59F8 ~            	CALL CALBAS
 484+ 59F8 ~            	LD A, E
 485+ 59F8 ~            	LD (TMP_STRUCT+14), A
 486+ 59F8 ~            	; comma
 487+ 59F8 ~            	CALL CHKCHAR
 488+ 59F8 ~            	DB ','
 489+ 59F8 ~            	; get height
 490+ 59F8 ~            	LD IX, FRMQNT
 491+ 59F8 ~            	CALL CALBAS
 492+ 59F8 ~            	LD A, E
 493+ 59F8 ~            	LD (TMP_STRUCT+16), A
 494+ 59F8 ~            	; comma
 495+ 59F8 ~            	CALL CHKCHAR
 496+ 59F8 ~            	DB ','
 497+ 59F8 ~            	; get background pointer
 498+ 59F8 ~            	LD IX, FRMQNT
 499+ 59F8 ~            	CALL CALBAS
 500+ 59F8 ~            	LD (TMP_STRUCT+4), DE
 501+ 59F8 ~            	; comma
 502+ 59F8 ~            	CALL CHKCHAR
 503+ 59F8 ~            	DB ','
 504+ 59F8 ~            	; get background width
 505+ 59F8 ~            	LD IX, FRMQNT
 506+ 59F8 ~            	CALL CALBAS
 507+ 59F8 ~            	LD A, E
 508+ 59F8 ~            	LD (BLIT_TMP+2), A
 509+ 59F8 ~            	; ending )
 510+ 59F8 ~            	CALL CHKCHAR
 511+ 59F8 ~            	DB ')'
 512+ 59F8 ~
 513+ 59F8 ~            	PUSH HL ; save position in BASIC buffer
 514+ 59F8 ~
 515+ 59F8 ~            	; calculate char&mask add to value
 516+ 59F8 ~            	LD H, 0
 517+ 59F8 ~            	LD A, (TMP_STRUCT+14)
 518+ 59F8 ~            	LD L, A
 519+ 59F8 ~            	CALL HLx8
 520+ 59F8 ~            	LD (TMP_STRUCT+12), HL
 521+ 59F8 ~            	; calculate background add to value
 522+ 59F8 ~            	LD H, 0
 523+ 59F8 ~            	LD A, (BLIT_TMP+2)
 524+ 59F8 ~            	LD L, A
 525+ 59F8 ~            	CALL HLx8
 526+ 59F8 ~            	LD (TMP_STRUCT+6), HL
 527+ 59F8 ~            	; calculate pointer to background location
 528+ 59F8 ~            	LD HL, 0
 529+ 59F8 ~            	LD A,(BLIT_TMP+1)
 530+ 59F8 ~            	OR A
 531+ 59F8 ~            	JR Z, .L1
 532+ 59F8 ~            	LD B,A
 533+ 59F8 ~            	LD DE,(TMP_STRUCT+6)
 534+ 59F8 ~            .L0:
 535+ 59F8 ~            	ADD HL, DE
 536+ 59F8 ~            	DJNZ .L0
 537+ 59F8 ~            .L1:
 538+ 59F8 ~            	EX DE,HL
 539+ 59F8 ~            	LD H,0
 540+ 59F8 ~            	LD A,(BLIT_TMP+0)
 541+ 59F8 ~            	LD L,A
 542+ 59F8 ~            	CALL HLx8
 543+ 59F8 ~            	ADD HL,DE
 544+ 59F8 ~            	LD DE,(TMP_STRUCT+4)
 545+ 59F8 ~            	ADD HL,DE
 546+ 59F8 ~            	LD (TMP_STRUCT+4),HL
 547+ 59F8 ~
 548+ 59F8 ~            	LD IY, .RET
 549+ 59F8 ~            	JP ENABLE_PAGE0
 550+ 59F8 ~            .RET:
 551+ 59F8 ~            	EI
 552+ 59F8 ~            	LD IX, TMP_STRUCT
 553+ 59F8 ~            	CALL SHIFT_MERGE_CHARACTER
 554+ 59F8 ~
 555+ 59F8 ~                POP DE
 556+ 59F8 ~                POP BC
 557+ 59F8 ~                CALL RESTORE_PAGE_INFO
 558+ 59F8 ~            	XOR A
 559+ 59F8 ~            	POP HL
 560+ 59F8 ~            	RET
 561+ 59F8 ~            ; *******************************************************************************************************
 562+ 59F8               ENDIF
# file closed: asm\BLIT.asm
 164  59F8               ENDIF
 165  59F8
 166  59F8               IF (TILE_CMDS == 1)
 167  59F8               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
   1+ 59F8              ; *******************************************************************************************************
   2+ 59F8              ; generic function to implement tiling
   3+ 59F8              ; should be modified to call appropriate function for memory or vram
   4+ 59F8              ; input IX=pointer to following structure
   5+ 59F8              ; +00 tile_data_ptr
   6+ 59F8              ; +02 tile_rows
   7+ 59F8              ; +04 tile_columns
   8+ 59F8              ; +06 destination_address
   9+ 59F8              ; +08 dest_to_next_row_add_to_value
  10+ 59F8              ; +10 num_horizontal_tiles
  11+ 59F8              ; +12 num_vertical_tiles
  12+ 59F8              ; modifies AF, BC, DE, HL
  13+ 59F8              TILE:
  14+ 59F8 DD 6E 06     	LD L, (IX+6)
  15+ 59FB DD 66 07     	LD H, (IX+7) ; destination address
  16+ 59FE 22 3D 5F     	LD (TILETMP1), HL
  17+ 5A01 DD 46 0C     	LD B, (IX+12) ; vertical tile number
  18+ 5A04              .L1:
  19+ 5A04 C5           	PUSH BC
  20+ 5A05 DD 6E 00     		LD L, (IX+0)
  21+ 5A08 DD 66 01     		LD H, (IX+1) ; tile address
  22+ 5A0B 22 3F 5F     		LD (TILETMP2), HL
  23+ 5A0E DD 46 02     		LD B, (IX+2) ; tile rows
  24+ 5A11              .L2:
  25+ 5A11 C5           		PUSH BC
  26+ 5A12 CD 00 00     .CALL1:		CALL 0
  27+ 5A15 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
  28+ 5A18              .L3:
  29+ 5A18 C5           			PUSH BC
  30+ 5A19 2A 3F 5F     				LD HL, (TILETMP2)
  31+ 5A1C DD 46 04     				LD B, (IX+4) ; tile columns
  32+ 5A1F              .L4:
  33+ 5A1F C5           				PUSH BC
  34+ 5A20              .CALL2:
  35+ 5A20 CD 00 00     					CALL 0
  36+ 5A23 C1           				POP BC
  37+ 5A24 10 F9        				DJNZ .L4
  38+ 5A26 C1           			POP BC
  39+ 5A27 10 EF        			DJNZ .L3
  40+ 5A29 22 3F 5F     			LD (TILETMP2), HL
  41+ 5A2C 2A 3D 5F     			LD HL, (TILETMP1)
  42+ 5A2F DD 5E 08     			LD E, (IX+8)
  43+ 5A32 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
  44+ 5A35 19           			ADD HL, DE
  45+ 5A36 22 3D 5F     			LD (TILETMP1), HL
  46+ 5A39 C1           		POP BC
  47+ 5A3A 10 D5        		DJNZ .L2
  48+ 5A3C C1           	POP BC
  49+ 5A3D 10 C5        	DJNZ .L1
  50+ 5A3F C9           	RET
  51+ 5A40              ; *******************************************************************************************************
  52+ 5A40
  53+ 5A40               IF (1 == 1)
  54+ 5A40              ; *******************************************************************************************************
  55+ 5A40              ; same as TILERAM but for DEFUSR approach
  56+ 5A40              ; input IX=pointer to input array, real data from +2
  57+ 5A40              ; +02 = tile data pointer
  58+ 5A40              ; +04 = tile columns
  59+ 5A40              ; +06 = tile rows
  60+ 5A40              ; +08 = destination pointer
  61+ 5A40              ; +10 = destination columns
  62+ 5A40              ; +12 = destination rows
  63+ 5A40              ; +14 = destination begin column
  64+ 5A40              ; +16 = destination begin row
  65+ 5A40              ; +18 = number of tiles horizontally
  66+ 5A40              ; +20 = number of tiles vertically
  67+ 5A40              ; *******************************************************************************************************
  68+ 5A40              TILERAM_DEFUSR:
  69+ 5A40              	; tile data pointer
  70+ 5A40 DD 6E 02     	LD L,(IX+2)
  71+ 5A43 DD 66 03     	LD H,(IX+3)
  72+ 5A46 22 41 5F     	LD (TMP_STRUCT+0),HL
  73+ 5A49              	; tile columns
  74+ 5A49 DD 6E 04     	LD L,(IX+4)
  75+ 5A4C DD 66 05     	LD H,(IX+5)
  76+ 5A4F 22 45 5F     	LD (TMP_STRUCT+4),HL
  77+ 5A52              	; tile rows
  78+ 5A52 DD 6E 06     	LD L,(IX+6)
  79+ 5A55 DD 66 07     	LD H,(IX+7)
  80+ 5A58 22 43 5F     	LD (TMP_STRUCT+2),HL
  81+ 5A5B              	; destintion pointer
  82+ 5A5B DD 6E 08     	LD L,(IX+8)
  83+ 5A5E DD 66 09     	LD H,(IX+9)
  84+ 5A61 22 47 5F     	LD (TMP_STRUCT+6),HL
  85+ 5A64              	; destination columns
  86+ 5A64 DD 7E 0A     	LD A,(IX+10)
  87+ 5A67 32 3D 5F     	LD (BLIT_TMP+0),A
  88+ 5A6A              	; destination rows
  89+ 5A6A DD 7E 0C     	LD A,(IX+12)
  90+ 5A6D 32 3E 5F     	LD (BLIT_TMP+1),A
  91+ 5A70              	; destination begin column
  92+ 5A70 DD 7E 0E     	LD A,(IX+14)
  93+ 5A73 32 3F 5F     	LD (BLIT_TMP+2),A
  94+ 5A76              	; destination begin row
  95+ 5A76 DD 7E 10     	LD A,(IX+16)
  96+ 5A79 32 40 5F     	LD (BLIT_TMP+3),A
  97+ 5A7C              	; number of tiles horizontally
  98+ 5A7C DD 6E 12     	LD L,(IX+18)
  99+ 5A7F DD 66 13     	LD H,(IX+19)
 100+ 5A82 22 4B 5F     	LD (TMP_STRUCT+10),HL
 101+ 5A85              	; number of tiles vertically
 102+ 5A85 DD 6E 14     	LD L,(IX+20)
 103+ 5A88 DD 66 15     	LD H,(IX+21)
 104+ 5A8B 22 4D 5F     	LD (TMP_STRUCT+12),HL
 105+ 5A8E               IF (0 == 1) ; otherwise we just continue with code below
 106+ 5A8E ~            	JP TILERAM.COMMON
 107+ 5A8E               ENDIF
 108+ 5A8E               ENDIF
 109+ 5A8E
 110+ 5A8E              ; *******************************************************************************************************
 111+ 5A8E              ; function to handle CALL TILERAM basic extension
 112+ 5A8E              ; fills memory with tiles
 113+ 5A8E              ; TILERAM ( INT tile_data_pointer,
 114+ 5A8E              ;			INT tile_columns,
 115+ 5A8E              ;			INT tile_rows,
 116+ 5A8E              ;			INT destination_pointer,
 117+ 5A8E              ;			INT destination_columns,
 118+ 5A8E              ;			INT destination_rows,
 119+ 5A8E              ;			INT destination_begin_column,
 120+ 5A8E              ;			INT destination_begin_row,
 121+ 5A8E              ;			INT number_of_tiles_horizontally,
 122+ 5A8E              ;			INT	number_of_tiles_vertically )
 123+ 5A8E              ; will put ram in page 0 also, page 1 is already there
 124+ 5A8E              TILERAM:
 125+ 5A8E               IF (0 == 1)
 126+ 5A8E ~            	; opening (
 127+ 5A8E ~            	CALL CHKCHAR
 128+ 5A8E ~            	DB '('
 129+ 5A8E ~            	; get tile data pointer coordinate
 130+ 5A8E ~            	LD IX, FRMQNT
 131+ 5A8E ~            	CALL CALBAS
 132+ 5A8E ~            	LD (TMP_STRUCT+0), DE
 133+ 5A8E ~            	; comma
 134+ 5A8E ~            	CALL CHKCHAR
 135+ 5A8E ~            	DB ','
 136+ 5A8E ~            	; get tile columns
 137+ 5A8E ~            	LD IX, FRMQNT
 138+ 5A8E ~            	CALL CALBAS
 139+ 5A8E ~            	LD (TMP_STRUCT+4), DE
 140+ 5A8E ~            	; comma
 141+ 5A8E ~            	CALL CHKCHAR
 142+ 5A8E ~            	DB ','
 143+ 5A8E ~            	; get tile columns
 144+ 5A8E ~            	LD IX, FRMQNT
 145+ 5A8E ~            	CALL CALBAS
 146+ 5A8E ~            	LD (TMP_STRUCT+2), DE
 147+ 5A8E ~            	; comma
 148+ 5A8E ~            	CALL CHKCHAR
 149+ 5A8E ~            	DB ','
 150+ 5A8E ~            	; get destintion pointer
 151+ 5A8E ~            	LD IX, FRMQNT
 152+ 5A8E ~            	CALL CALBAS
 153+ 5A8E ~            	LD (TMP_STRUCT+6), DE
 154+ 5A8E ~            	; comma
 155+ 5A8E ~            	CALL CHKCHAR
 156+ 5A8E ~            	DB ','
 157+ 5A8E ~            	; get destination columns
 158+ 5A8E ~            	LD IX, FRMQNT
 159+ 5A8E ~            	CALL CALBAS
 160+ 5A8E ~            	LD A, E
 161+ 5A8E ~            	LD (BLIT_TMP+0), A
 162+ 5A8E ~            	; comma
 163+ 5A8E ~            	CALL CHKCHAR
 164+ 5A8E ~            	DB ','
 165+ 5A8E ~            	; get destination rows
 166+ 5A8E ~            	LD IX, FRMQNT
 167+ 5A8E ~            	CALL CALBAS
 168+ 5A8E ~            	LD A, E
 169+ 5A8E ~            	LD (BLIT_TMP+1), A
 170+ 5A8E ~            	; comma
 171+ 5A8E ~            	CALL CHKCHAR
 172+ 5A8E ~            	DB ','
 173+ 5A8E ~            	; get destination begin column
 174+ 5A8E ~            	LD IX, FRMQNT
 175+ 5A8E ~            	CALL CALBAS
 176+ 5A8E ~            	LD A, E
 177+ 5A8E ~            	LD (BLIT_TMP+2), A
 178+ 5A8E ~            	; comma
 179+ 5A8E ~            	CALL CHKCHAR
 180+ 5A8E ~            	DB ','
 181+ 5A8E ~            	; get destination begin row
 182+ 5A8E ~            	LD IX, FRMQNT
 183+ 5A8E ~            	CALL CALBAS
 184+ 5A8E ~            	LD A, E
 185+ 5A8E ~            	LD (BLIT_TMP+3), A
 186+ 5A8E ~            	; comma
 187+ 5A8E ~            	CALL CHKCHAR
 188+ 5A8E ~            	DB ','
 189+ 5A8E ~            	; get number of tiles horizontally
 190+ 5A8E ~            	LD IX, FRMQNT
 191+ 5A8E ~            	CALL CALBAS
 192+ 5A8E ~            	LD (TMP_STRUCT+10), DE
 193+ 5A8E ~            	; comma
 194+ 5A8E ~            	CALL CHKCHAR
 195+ 5A8E ~            	DB ','
 196+ 5A8E ~            	; get number of tiles vertically
 197+ 5A8E ~            	LD IX, FRMQNT
 198+ 5A8E ~            	CALL CALBAS
 199+ 5A8E ~            	LD (TMP_STRUCT+12), DE
 200+ 5A8E ~            	; ending )
 201+ 5A8E ~            	CALL CHKCHAR
 202+ 5A8E ~            	DB ')'
 203+ 5A8E               ENDIF
 204+ 5A8E              .COMMON:
 205+ 5A8E E5           	PUSH HL ; save position in BASIC buffer
 206+ 5A8F
 207+ 5A8F              	; calculate destination add to value
 208+ 5A8F 26 00        	LD H, 0
 209+ 5A91 3A 3D 5F     	LD A, (BLIT_TMP+0)
 210+ 5A94 6F           	LD L, A
 211+ 5A95 CD BB 5F     	CALL HLx8
 212+ 5A98 22 49 5F     	LD (TMP_STRUCT+8), HL
 213+ 5A9B              	; calculate pointer to background location
 214+ 5A9B 21 00 00     	LD HL, 0
 215+ 5A9E 3A 40 5F     	LD A,(BLIT_TMP+3)
 216+ 5AA1 B7           	OR A
 217+ 5AA2 28 08        	JR Z, .L1
 218+ 5AA4 47           	LD B,A
 219+ 5AA5 ED 5B 49 5F  	LD DE,(TMP_STRUCT+8)
 220+ 5AA9              .L0:
 221+ 5AA9 19           	ADD HL, DE
 222+ 5AAA 10 FD        	DJNZ .L0
 223+ 5AAC              .L1:
 224+ 5AAC EB           	EX DE,HL
 225+ 5AAD 26 00        	LD H,0
 226+ 5AAF 3A 3F 5F     	LD A,(BLIT_TMP+2)
 227+ 5AB2 6F           	LD L,A
 228+ 5AB3 CD BB 5F     	CALL HLx8
 229+ 5AB6 19           	ADD HL,DE
 230+ 5AB7 ED 5B 47 5F  	LD DE,(TMP_STRUCT+6)
 231+ 5ABB 19           	ADD HL,DE
 232+ 5ABC 22 47 5F     	LD (TMP_STRUCT+6),HL
 233+ 5ABF FD 21 C6 5A  	LD IY, .RET
 234+ 5AC3 C3 7F 60     	JP ENABLE_PAGE0
 235+ 5AC6              .RET:
 236+ 5AC6 FB           	EI
 237+ 5AC7              	; set RAM functions to call
 238+ 5AC7 21 DD 5A     	LD HL, .TILECOPY
 239+ 5ACA 22 21 5A     	LD (TILE.CALL2+1), HL
 240+ 5ACD 21 EE 5A     	LD HL, .SETDESTROW
 241+ 5AD0 22 13 5A     	LD (TILE.CALL1+1), HL
 242+ 5AD3 DD 21 41 5F  	LD IX,TMP_STRUCT
 243+ 5AD7 CD F8 59     	CALL TILE
 244+ 5ADA C3 95 5F     	JP COMMON_EXIT_CODE
 245+ 5ADD              .TILECOPY:
 246+ 5ADD ED A0       > LDI
 246+ 5ADF ED A0       > LDI
 246+ 5AE1 ED A0       > LDI
 246+ 5AE3 ED A0       > LDI
 246+ 5AE5 ED A0       > LDI
 246+ 5AE7 ED A0       > LDI
 246+ 5AE9 ED A0       > LDI
 246+ 5AEB ED A0       > LDI
 247+ 5AED C9           	RET
 248+ 5AEE              .SETDESTROW:
 249+ 5AEE ED 5B 3D 5F  	LD DE, (TILETMP1)
 250+ 5AF2 C9           	RET
 251+ 5AF3              ; *******************************************************************************************************
 252+ 5AF3
 253+ 5AF3               IF (1 == 1)
 254+ 5AF3              ; *******************************************************************************************************
 255+ 5AF3              ; same as TILEVRM but for DEFUSR approach
 256+ 5AF3              ; input IX=pointer to input array, real data from +2
 257+ 5AF3              ; +02 = tile data pointer
 258+ 5AF3              ; +04 = tile columns
 259+ 5AF3              ; +06 = tile rows
 260+ 5AF3              ; +08 = destination begin column
 261+ 5AF3              ; +10 = destination begin row
 262+ 5AF3              ; +12 = number of tiles horizontally
 263+ 5AF3              ; +14 = number of tiles vertically
 264+ 5AF3              ; *******************************************************************************************************
 265+ 5AF3              TILEVRM_DEFUSR:
 266+ 5AF3              	; tile data pointer
 267+ 5AF3 DD 6E 02     	LD L,(IX+2)
 268+ 5AF6 DD 66 03     	LD H,(IX+3)
 269+ 5AF9 22 41 5F     	LD (TMP_STRUCT+0),HL
 270+ 5AFC              	; tile columns
 271+ 5AFC DD 6E 04     	LD L,(IX+4)
 272+ 5AFF DD 66 05     	LD H,(IX+5)
 273+ 5B02 22 45 5F     	LD (TMP_STRUCT+4),HL
 274+ 5B05              	; tile rows
 275+ 5B05 DD 6E 06     	LD L,(IX+6)
 276+ 5B08 DD 66 07     	LD H,(IX+7)
 277+ 5B0B 22 43 5F     	LD (TMP_STRUCT+2),HL
 278+ 5B0E              	; destination begin column
 279+ 5B0E DD 7E 08     	LD A,(IX+8)
 280+ 5B11 32 3F 5F     	LD (BLIT_TMP+2),A
 281+ 5B14              	; destination begin row
 282+ 5B14 DD 7E 0A     	LD A,(IX+10)
 283+ 5B17 32 40 5F     	LD (BLIT_TMP+3),A
 284+ 5B1A              	; number of tiles horizontally
 285+ 5B1A DD 6E 0C     	LD L,(IX+12)
 286+ 5B1D DD 66 0D     	LD H,(IX+13)
 287+ 5B20 22 4B 5F     	LD (TMP_STRUCT+10),HL
 288+ 5B23              	; number of tiles vertically
 289+ 5B23 DD 6E 0E     	LD L,(IX+14)
 290+ 5B26 DD 66 0F     	LD H,(IX+15)
 291+ 5B29 22 4D 5F     	LD (TMP_STRUCT+12),HL
 292+ 5B2C               IF (0 == 1) ; otherwise we just continue with code below
 293+ 5B2C ~            	JP TILEVRM.COMMON
 294+ 5B2C               ENDIF
 295+ 5B2C               ENDIF
 296+ 5B2C
 297+ 5B2C              ; *******************************************************************************************************
 298+ 5B2C              ; function to handle CALL TILEVRM basic extension
 299+ 5B2C              ; fills vram with tiles
 300+ 5B2C              ; TILEVRM ( INT tile_data_pointer,
 301+ 5B2C              ;			INT tile_columns,
 302+ 5B2C              ;			INT tile_rows,
 303+ 5B2C              ;			INT destination_begin_column,
 304+ 5B2C              ;			INT destination_begin_row,
 305+ 5B2C              ;			INT number_of_tiles_horizontally,
 306+ 5B2C              ;			INT	number_of_tiles_vertically )
 307+ 5B2C              ; will put ram in page 0 also, page 1 is already there
 308+ 5B2C              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
 309+ 5B2C              TILEVRM:
 310+ 5B2C               IF (0 == 1)
 311+ 5B2C ~            	; opening (
 312+ 5B2C ~            	CALL CHKCHAR
 313+ 5B2C ~            	DB '('
 314+ 5B2C ~            	; get tile data pointer coordinate
 315+ 5B2C ~            	LD IX, FRMQNT
 316+ 5B2C ~            	CALL CALBAS
 317+ 5B2C ~            	LD (TMP_STRUCT+0), DE
 318+ 5B2C ~            	; comma
 319+ 5B2C ~            	CALL CHKCHAR
 320+ 5B2C ~            	DB ','
 321+ 5B2C ~            	; get tile columns
 322+ 5B2C ~            	LD IX, FRMQNT
 323+ 5B2C ~            	CALL CALBAS
 324+ 5B2C ~            	LD (TMP_STRUCT+4), DE
 325+ 5B2C ~            	; comma
 326+ 5B2C ~            	CALL CHKCHAR
 327+ 5B2C ~            	DB ','
 328+ 5B2C ~            	; get tile columns
 329+ 5B2C ~            	LD IX, FRMQNT
 330+ 5B2C ~            	CALL CALBAS
 331+ 5B2C ~            	LD (TMP_STRUCT+2), DE
 332+ 5B2C ~            	; comma
 333+ 5B2C ~            	CALL CHKCHAR
 334+ 5B2C ~            	DB ','
 335+ 5B2C ~            	; get destination begin column
 336+ 5B2C ~            	LD IX, FRMQNT
 337+ 5B2C ~            	CALL CALBAS
 338+ 5B2C ~            	LD A, E
 339+ 5B2C ~            	LD (BLIT_TMP+2), A
 340+ 5B2C ~            	; comma
 341+ 5B2C ~            	CALL CHKCHAR
 342+ 5B2C ~            	DB ','
 343+ 5B2C ~            	; get destination begin row
 344+ 5B2C ~            	LD IX, FRMQNT
 345+ 5B2C ~            	CALL CALBAS
 346+ 5B2C ~            	LD A, E
 347+ 5B2C ~            	LD (BLIT_TMP+3), A
 348+ 5B2C ~            	; comma
 349+ 5B2C ~            	CALL CHKCHAR
 350+ 5B2C ~            	DB ','
 351+ 5B2C ~            	; get number of tiles horizontally
 352+ 5B2C ~            	LD IX, FRMQNT
 353+ 5B2C ~            	CALL CALBAS
 354+ 5B2C ~            	LD (TMP_STRUCT+10), DE
 355+ 5B2C ~            	; comma
 356+ 5B2C ~            	CALL CHKCHAR
 357+ 5B2C ~            	DB ','
 358+ 5B2C ~            	; get number of tiles vertically
 359+ 5B2C ~            	LD IX, FRMQNT
 360+ 5B2C ~            	CALL CALBAS
 361+ 5B2C ~            	LD (TMP_STRUCT+12), DE
 362+ 5B2C ~            	; ending )
 363+ 5B2C ~            	CALL CHKCHAR
 364+ 5B2C ~            	DB ')'
 365+ 5B2C               ENDIF
 366+ 5B2C
 367+ 5B2C              .COMMON:
 368+ 5B2C E5           	PUSH HL ; save position in BASIC buffer
 369+ 5B2D
 370+ 5B2D              	; calculate destination add to value
 371+ 5B2D 21 00 01     	LD HL, 256
 372+ 5B30 22 49 5F     	LD (TMP_STRUCT+8), HL
 373+ 5B33              	; calculate pointer to background location
 374+ 5B33 3A 40 5F     	LD A,(BLIT_TMP+3)
 375+ 5B36 67           	LD H,A
 376+ 5B37 2E 00        	LD L,0
 377+ 5B39 EB           	EX DE,HL
 378+ 5B3A 26 00        	LD H,0
 379+ 5B3C 3A 3F 5F     	LD A,(BLIT_TMP+2)
 380+ 5B3F 6F           	LD L,A
 381+ 5B40 CD BB 5F     	CALL HLx8
 382+ 5B43 19           	ADD HL,DE
 383+ 5B44 ED 5B CB F3  	LD DE,(GRPCGP)
 384+ 5B48 19           	ADD HL,DE
 385+ 5B49 22 47 5F     	LD (TMP_STRUCT+6),HL
 386+ 5B4C FD 21 53 5B  	LD IY, .RET
 387+ 5B50 C3 7F 60     	JP ENABLE_PAGE0
 388+ 5B53              .RET:
 389+ 5B53 FB           	EI
 390+ 5B54              	; set RAM functions to call
 391+ 5B54 21 6A 5B     	LD HL, .TILECOPY
 392+ 5B57 22 21 5A     	LD (TILE.CALL2+1), HL
 393+ 5B5A 21 70 5B     	LD HL, .SETDESTROW
 394+ 5B5D 22 13 5A     	LD (TILE.CALL1+1), HL
 395+ 5B60 DD 21 41 5F  	LD IX,TMP_STRUCT
 396+ 5B64 CD F8 59     	CALL TILE
 397+ 5B67 C3 95 5F     	JP COMMON_EXIT_CODE
 398+ 5B6A              .TILECOPY:
 399+ 5B6A 01 98 08     	LD BC, #0898
 400+ 5B6D C3 B3 5F     	JP BBYTECOPY_NO_C
 401+ 5B70              .SETDESTROW:
 402+ 5B70 2A 3D 5F     	LD HL, (TILETMP1)
 403+ 5B73 F3           	DI
 404+ 5B74 CD 9C 5F     	CALL SETWRT_LOCAL_WRITE
 405+ 5B77 FB           	EI
 406+ 5B78 C9           	RET
 407+ 5B79              ; *******************************************************************************************************
 408+ 5B79
# file closed: asm\TILE.asm
 168  5B79               ENDIF
 169  5B79
 170  5B79               IF (COLL_CMD == 1)
 171  5B79               INCLUDE "COLLISION.asm"
# file opened: asm\COLLISION.asm
   1+ 5B79              ; generic collision checking routines
   2+ 5B79              ; in BASIC we use rectangle structure array DIM R%(7,n) of the format
   3+ 5B79              ; R%(0,n) is active flag, <>0 active / 0 skipped in checks
   4+ 5B79              ; R%(1,n) is either upper left x coordinate or sprite id (0-31) depending on R(7,n)
   5+ 5B79              ; R%(2,n) is either upper left y coordinate or unused depending on R(7,n)
   6+ 5B79              ; R%(3,n) x offset where rectangle begins
   7+ 5B79              ; R%(4,n) y offset where rectangle begins
   8+ 5B79              ; R%(5,n) is width
   9+ 5B79              ; R%(6,n) is height
  10+ 5B79              ; R%(7,0) is type, 0=generic where R%(1,0) contains x coordinate
  11+ 5B79              ;                  <>0 sprite where R%(1,0) contains sprite id
  12+ 5B79              ; for type sprite, upper left coordinates are taken from sprite attribute array
  13+ 5B79
  14+ 5B79              ; ************************************************************************************************
  15+ 5B79              ; quick test if HL<=DE<=HL+BC
  16+ 5B79              ; input BC=width, DE=x, HL=min
  17+ 5B79              ; if not true flag C set
  18+ 5B79              ; modifies AF
  19+ 5B79              GENERIC_INNER_CHECK:
  20+ 5B79 E5               PUSH HL
  21+ 5B7A D5               PUSH DE
  22+ 5B7B EB               EX DE,HL
  23+ 5B7C A7               AND A
  24+ 5B7D ED 52            SBC HL, DE
  25+ 5B7F FA 8D 5B         JP M, .GENERIC_INNER_CHECK_NOT
  26+ 5B82 A7               AND A
  27+ 5B83 ED 42            SBC HL, BC
  28+ 5B85 28 03            JR Z, .L2
  29+ 5B87 F2 8D 5B         JP P, .GENERIC_INNER_CHECK_NOT
  30+ 5B8A              .L2:
  31+ 5B8A A7               AND A
  32+ 5B8B 18 01            JR .EXIT
  33+ 5B8D              .GENERIC_INNER_CHECK_NOT:
  34+ 5B8D 37               SCF
  35+ 5B8E              .EXIT:
  36+ 5B8E D1               POP DE
  37+ 5B8F E1               POP HL
  38+ 5B90 C9               RET
  39+ 5B91              ; ************************************************************************************************
  40+ 5B91
  41+ 5B91              ; ************************************************************************************************
  42+ 5B91              ; function to check if rectangles are overlapping
  43+ 5B91              ; input IX=IY=pointer to struct
  44+ 5B91              ;  +00 active flag
  45+ 5B91              ;  +02 x coordinate
  46+ 5B91              ;  +04 y coordinate
  47+ 5B91              ;  +06 x offset where rectangle begins
  48+ 5B91              ;  +08 y offset where rectangle begins
  49+ 5B91              ;  +10 width
  50+ 5B91              ;  +12 height
  51+ 5B91              ; where IY is used to read +2 and +4, and IX to read +6, +8, +10 and +12
  52+ 5B91              ; this is a hack to allow location being taken from sprite attributes table
  53+ 5B91              ; input TMP_STRUCT data
  54+ 5B91              ;  +00 x coordinate
  55+ 5B91              ;  +02 y coordinate
  56+ 5B91              ;  +04 width
  57+ 5B91              ;  +06 height
  58+ 5B91              ; returns CF=1 if not overlapping, CF=0 if overlapping
  59+ 5B91              RECTANGLE_OVERLAP_CHECK:
  60+ 5B91                  ; first check which rectangle is higher
  61+ 5B91 DD 6E 0C         LD L,(IX+12)
  62+ 5B94 DD 66 0D         LD H,(IX+13)
  63+ 5B97 ED 5B 47 5F      LD DE,(TMP_STRUCT+6)
  64+ 5B9B A7               AND A
  65+ 5B9C ED 52            SBC HL,DE
  66+ 5B9E FD 6E 04         LD L,(IY+4)
  67+ 5BA1 FD 66 05         LD H,(IY+5)
  68+ 5BA4 DD 5E 08         LD E,(IX+8)
  69+ 5BA7 DD 56 09         LD D,(IX+9)
  70+ 5BAA FA CA 5B         JP M,.L1
  71+ 5BAD                  ; equally high or IX defined one higher
  72+ 5BAD                  ; check upper boundary
  73+ 5BAD 19               ADD HL,DE
  74+ 5BAE ED 5B 43 5F      LD DE,(TMP_STRUCT+2)
  75+ 5BB2 DD 4E 0C         LD C,(IX+12)
  76+ 5BB5 DD 46 0D         LD B,(IX+13)
  77+ 5BB8 CD 79 5B         CALL GENERIC_INNER_CHECK
  78+ 5BBB 30 29            JR NC,.INSIDE
  79+ 5BBD                  ; check lower boundary
  80+ 5BBD E5               PUSH HL
  81+ 5BBE 2A 47 5F         LD HL,(TMP_STRUCT+6)
  82+ 5BC1 19               ADD HL,DE
  83+ 5BC2 EB               EX DE,HL
  84+ 5BC3 E1               POP HL
  85+ 5BC4 CD 79 5B         CALL GENERIC_INNER_CHECK
  86+ 5BC7 30 1D            JR NC,.INSIDE
  87+ 5BC9 C9               RET ; not overlapping
  88+ 5BCA              .L1:
  89+ 5BCA                  ; rectangle defined in TMP_STRUCT is higher
  90+ 5BCA 19               ADD HL,DE
  91+ 5BCB EB               EX DE,HL
  92+ 5BCC 2A 43 5F         LD HL,(TMP_STRUCT+2)
  93+ 5BCF ED 4B 47 5F      LD BC,(TMP_STRUCT+6)
  94+ 5BD3 CD 79 5B         CALL GENERIC_INNER_CHECK
  95+ 5BD6 30 0E            JR NC,.INSIDE
  96+ 5BD8 E5               PUSH HL
  97+ 5BD9 DD 6E 0C         LD L,(IX+12)
  98+ 5BDC DD 66 0D         LD H,(IX+13)
  99+ 5BDF 19               ADD HL,DE
 100+ 5BE0 EB               EX DE,HL
 101+ 5BE1 E1               POP HL
 102+ 5BE2 CD 79 5B         CALL GENERIC_INNER_CHECK
 103+ 5BE5 D8               RET C
 104+ 5BE6              .INSIDE:
 105+ 5BE6                  ; check x coordinate
 106+ 5BE6                  ; first check which rectangle is wider
 107+ 5BE6 DD 6E 0A         LD L,(IX+10)
 108+ 5BE9 DD 66 0B         LD H,(IX+11)
 109+ 5BEC ED 5B 45 5F      LD DE,(TMP_STRUCT+4)
 110+ 5BF0 A7               AND A
 111+ 5BF1 ED 52            SBC HL,DE
 112+ 5BF3 FD 6E 02         LD L,(IY+2)
 113+ 5BF6 FD 66 03         LD H,(IY+3)
 114+ 5BF9 DD 5E 06         LD E,(IX+6)
 115+ 5BFC DD 56 07         LD D,(IX+7)
 116+ 5BFF FA 1B 5C         JP M,.L2
 117+ 5C02                  ; equally wide or IX defined one wider
 118+ 5C02                  ; check left boundary
 119+ 5C02 19               ADD HL,DE
 120+ 5C03 ED 5B 41 5F      LD DE,(TMP_STRUCT+0)
 121+ 5C07 DD 4E 0A         LD C,(IX+10)
 122+ 5C0A DD 46 0B         LD B,(IX+11)
 123+ 5C0D CD 79 5B         CALL GENERIC_INNER_CHECK
 124+ 5C10 D0               RET NC ; overlap
 125+ 5C11                  ; check right boundary
 126+ 5C11 E5               PUSH HL
 127+ 5C12 2A 45 5F         LD HL,(TMP_STRUCT+4)
 128+ 5C15 19               ADD HL,DE
 129+ 5C16 EB               EX DE,HL
 130+ 5C17 E1               POP HL
 131+ 5C18 C3 79 5B         JP GENERIC_INNER_CHECK ; CF and result set by fn call
 132+ 5C1B              .L2:
 133+ 5C1B                  ; rectangle defined in TMP_STRUCT is higher
 134+ 5C1B 19               ADD HL,DE
 135+ 5C1C EB               EX DE,HL
 136+ 5C1D 2A 41 5F         LD HL,(TMP_STRUCT+0)
 137+ 5C20 ED 4B 45 5F      LD BC,(TMP_STRUCT+4)
 138+ 5C24 CD 79 5B         CALL GENERIC_INNER_CHECK
 139+ 5C27 D0               RET NC ; overlap
 140+ 5C28 E5               PUSH HL
 141+ 5C29 DD 6E 0A         LD L,(IX+10)
 142+ 5C2C DD 66 0B         LD H,(IX+11)
 143+ 5C2F 19               ADD HL,DE
 144+ 5C30 EB               EX DE,HL
 145+ 5C31 E1               POP HL
 146+ 5C32 C3 79 5B         JP GENERIC_INNER_CHECK
 147+ 5C35              ; ************************************************************************************************
 148+ 5C35
 149+ 5C35              ; ************************************************************************************************
 150+ 5C35              ; function tries to find rectangle overlap and returns an index if found
 151+ 5C35              ; input TMP_STRUCT data
 152+ 5C35              ;  +00 x coordinate
 153+ 5C35              ;  +02 y coordinate
 154+ 5C35              ;  +04 width
 155+ 5C35              ;  +06 height
 156+ 5C35              ;  +08 number of items in a list, described under RECTANGLE_OVERLAP_CHECK
 157+ 5C35              ;  +09 pointer to first element of R%(7,n)
 158+ 5C35              ;  +11 pointer to INT result variable
 159+ 5C35              ; returns CF=1 if not overlapping
 160+ 5C35              ; returns A=list index and CF=0 if overlapping
 161+ 5C35              FIND_OVERLAP:
 162+ 5C35 3A 49 5F         LD A,(TMP_STRUCT+8)
 163+ 5C38 47               LD B,A
 164+ 5C39 DD 2A 4A 5F      LD IX,(TMP_STRUCT+9)
 165+ 5C3D              .L1:
 166+ 5C3D C5               PUSH BC
 167+ 5C3E                  ; check active flag
 168+ 5C3E DD 7E 00         LD A,(IX)
 169+ 5C41 DD B6 01         OR (IX+1)
 170+ 5C44 28 18            JR Z,.NEXT
 171+ 5C46                  ; check type
 172+ 5C46 DD 7E 0E         LD A,(IX+14)
 173+ 5C49 DD B6 0F         OR (IX+15)
 174+ 5C4C 20 1A            JR NZ,.L2
 175+ 5C4E DD E5            PUSH IX
 176+ 5C50 FD E1            POP IY
 177+ 5C52              .L3:
 178+ 5C52 CD 91 5B         CALL RECTANGLE_OVERLAP_CHECK
 179+ 5C55 38 07            JR C,.NEXT
 180+ 5C57                  ; found
 181+ 5C57 C1               POP BC
 182+ 5C58 3A 49 5F         LD A,(TMP_STRUCT+8)
 183+ 5C5B 90               SUB B
 184+ 5C5C A7               AND A
 185+ 5C5D C9               RET
 186+ 5C5E              .NEXT:
 187+ 5C5E 11 10 00         LD DE,16
 188+ 5C61 DD 19            ADD IX,DE
 189+ 5C63 C1               POP BC
 190+ 5C64 10 D7            DJNZ .L1
 191+ 5C66 37               SCF
 192+ 5C67 C9               RET
 193+ 5C68              .L2:
 194+ 5C68                  ; sprite, need to build a temporary data struct since x and y values are inversed
 195+ 5C68                  ; at TMP_STRUCT+13
 196+ 5C68 DD 7E 02         LD A,(IX+2) ; sprite ID
 197+ 5C6B CD 90 4D         CALL GETnthSPRATTR
 198+ 5C6E FD 21 4C 5F      LD IY,TMP_STRUCT+11
 199+ 5C72 7E               LD A,(HL)
 200+ 5C73 FD 77 04         LD (IY+4),A
 201+ 5C76 23               INC HL
 202+ 5C77 7E               LD A,(HL)
 203+ 5C78 FD 77 05         LD (IY+5),A
 204+ 5C7B 23               INC HL
 205+ 5C7C 7E               LD A,(HL)
 206+ 5C7D FD 77 02         LD (IY+2),A
 207+ 5C80 23               INC HL
 208+ 5C81 7E               LD A,(HL)
 209+ 5C82 FD 77 03         LD (IY+3),A
 210+ 5C85 18 CB            JR .L3
 211+ 5C87              ; ************************************************************************************************
 212+ 5C87
 213+ 5C87               IF (0 == 1)
 214+ 5C87 ~            ; ************************************************************************************************
 215+ 5C87 ~            ; function to handle CALL COLL basic extension
 216+ 5C87 ~            ; checks for collision between player and other rectangles
 217+ 5C87 ~            ; COLL ( INT result variable,
 218+ 5C87 ~            ;	     INT player x value,
 219+ 5C87 ~            ;	     INT player y value,
 220+ 5C87 ~            ;	     INT player width,
 221+ 5C87 ~            ;	     INT player height,
 222+ 5C87 ~            ;	     INT number of items in a list,
 223+ 5C87 ~            ;		 INT[6][n] rectangle struct )
 224+ 5C87 ~            ; will fill result variable with index or -1 if no collision
 225+ 5C87 ~            ; rectangle struct described under RECTANGLE_OVERLAP_CHECK
 226+ 5C87 ~            COLL:
 227+ 5C87 ~            	; opening (
 228+ 5C87 ~            	CALL CHKCHAR
 229+ 5C87 ~            	DB '('
 230+ 5C87 ~            	; get address of result variable
 231+ 5C87 ~            	LD IX, PTRGET
 232+ 5C87 ~            	CALL CALBAS
 233+ 5C87 ~            	LD (TMP_STRUCT+11),DE
 234+ 5C87 ~            	; comma
 235+ 5C87 ~            	CALL CHKCHAR
 236+ 5C87 ~            	DB ','
 237+ 5C87 ~            	; get x
 238+ 5C87 ~            	LD IX, FRMQNT
 239+ 5C87 ~            	CALL CALBAS
 240+ 5C87 ~            	LD (TMP_STRUCT+0),DE
 241+ 5C87 ~            	; comma
 242+ 5C87 ~            	CALL CHKCHAR
 243+ 5C87 ~            	DB ','
 244+ 5C87 ~            	; get y
 245+ 5C87 ~            	LD IX, FRMQNT
 246+ 5C87 ~            	CALL CALBAS
 247+ 5C87 ~            	LD (TMP_STRUCT+2),DE
 248+ 5C87 ~            	; comma
 249+ 5C87 ~            	CALL CHKCHAR
 250+ 5C87 ~            	DB ','
 251+ 5C87 ~            	; get width
 252+ 5C87 ~            	LD IX, FRMQNT
 253+ 5C87 ~            	CALL CALBAS
 254+ 5C87 ~            	LD (TMP_STRUCT+4),DE
 255+ 5C87 ~            	; comma
 256+ 5C87 ~            	CALL CHKCHAR
 257+ 5C87 ~            	DB ','
 258+ 5C87 ~            	; get height
 259+ 5C87 ~            	LD IX, FRMQNT
 260+ 5C87 ~            	CALL CALBAS
 261+ 5C87 ~            	LD (TMP_STRUCT+6),DE
 262+ 5C87 ~            	; comma
 263+ 5C87 ~            	CALL CHKCHAR
 264+ 5C87 ~            	DB ','
 265+ 5C87 ~            	; get number of items in a list
 266+ 5C87 ~            	LD IX, GETBYT
 267+ 5C87 ~            	CALL CALBAS
 268+ 5C87 ~            	LD (TMP_STRUCT+8),A
 269+ 5C87 ~            	; comma
 270+ 5C87 ~            	CALL CHKCHAR
 271+ 5C87 ~            	DB ','
 272+ 5C87 ~            	; get address of rectangle structure array DIM R%(7,n)
 273+ 5C87 ~            	LD A,(TMP_STRUCT+8)
 274+ 5C87 ~                LD E,A
 275+ 5C87 ~                LD A,2
 276+ 5C87 ~            	LD B,A
 277+ 5C87 ~            	LD D,7
 278+ 5C87 ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
 279+ 5C87 ~            	LD (TMP_STRUCT+9),BC
 280+ 5C87 ~            	; ending )
 281+ 5C87 ~            	CALL CHKCHAR
 282+ 5C87 ~            	DB ')'
 283+ 5C87 ~
 284+ 5C87 ~                PUSH HL
 285+ 5C87 ~                CALL FIND_OVERLAP
 286+ 5C87 ~                LD HL,(TMP_STRUCT+11)
 287+ 5C87 ~                JR C,.NOTFOUND
 288+ 5C87 ~                LD (HL),A
 289+ 5C87 ~                INC HL
 290+ 5C87 ~                LD (HL),0
 291+ 5C87 ~                POP HL
 292+ 5C87 ~                RET
 293+ 5C87 ~            .NOTFOUND:
 294+ 5C87 ~                LD (HL),#FF
 295+ 5C87 ~                INC HL
 296+ 5C87 ~                LD (HL),#FF
 297+ 5C87 ~                POP HL
 298+ 5C87 ~                RET
 299+ 5C87 ~            ; ************************************************************************************************
 300+ 5C87               ENDIF
 301+ 5C87
 302+ 5C87               IF (1 == 1)
 303+ 5C87              ; *******************************************************************************************************
 304+ 5C87              ; same as COLL but for DEFUSR approach
 305+ 5C87              ; input IX=pointer to input array, real data from +2
 306+ 5C87              ; +02 = pointer to result variable
 307+ 5C87              ; +04 = player X
 308+ 5C87              ; +06 = player Y
 309+ 5C87              ; +08 = player width
 310+ 5C87              ; +10 = player height
 311+ 5C87              ; +12 = number of list items
 312+ 5C87              ; +14 = pointer to list of collidable objects
 313+ 5C87              COLL_DEFUSR:
 314+ 5C87 DD E5            PUSH IX
 315+ 5C89 E1               POP HL
 316+ 5C8A 23          > INC HL ; skip over to player x
 316+ 5C8B 23          > INC HL
 316+ 5C8C 23          > INC HL
 316+ 5C8D 23          > INC HL
 317+ 5C8E 11 41 5F         LD DE,TMP_STRUCT
 318+ 5C91 01 09 00         LD BC,9
 319+ 5C94 ED B0            LDIR ; copy over x,y,w,h,list item number
 320+ 5C96 DD 7E 0E         LD A,(IX+14)
 321+ 5C99 32 4A 5F         LD (TMP_STRUCT+9),A
 322+ 5C9C DD 7E 0F         LD A,(IX+15)
 323+ 5C9F 32 4B 5F         LD (TMP_STRUCT+10),A ; address to collidable objects array
 324+ 5CA2 DD 7E 02         LD A,(IX+2)
 325+ 5CA5 32 4C 5F         LD (TMP_STRUCT+11),A
 326+ 5CA8 DD 7E 03         LD A,(IX+3)
 327+ 5CAB 32 4D 5F         LD (TMP_STRUCT+12),A ; address to results variable
 328+ 5CAE DD E5            PUSH IX
 329+ 5CB0 CD 35 5C         CALL FIND_OVERLAP
 330+ 5CB3 DD E1            POP IX
 331+ 5CB5 DD 6E 02         LD L,(IX+2)
 332+ 5CB8 DD 66 03         LD H,(IX+3)
 333+ 5CBB 38 06            JR C,.NOTFOUND
 334+ 5CBD 77               LD (HL),A
 335+ 5CBE 23               INC HL
 336+ 5CBF 36 00            LD (HL),0
 337+ 5CC1              .EXIT:
 338+ 5CC1 AF               XOR A ; success
 339+ 5CC2 C9               RET
 340+ 5CC3              .NOTFOUND:
 341+ 5CC3 36 FF            LD (HL),#FF
 342+ 5CC5 23               INC HL
 343+ 5CC6 36 FF            LD (HL),#FF
 344+ 5CC8 18 F7            JR .EXIT
 345+ 5CCA              ; *******************************************************************************************************
 346+ 5CCA               ENDIF
 347+ 5CCA
# file closed: asm\COLLISION.asm
 172  5CCA               ENDIF
 173  5CCA
 174  5CCA               IF (DECOMP_CMDS == 1)
 175  5CCA               INCLUDE "decomp.asm"
# file opened: asm\decomp.asm
   1+ 5CCA              ; -----------------------------------------------------------------------------
   2+ 5CCA              ; ZX0 decoder by Einar Saukas & Urusergi
   3+ 5CCA              ; "Standard" version (68 bytes only)
   4+ 5CCA              ; -----------------------------------------------------------------------------
   5+ 5CCA              ; Parameters:
   6+ 5CCA              ;   HL: source address (compressed data)
   7+ 5CCA              ;   DE: destination address (decompressing)
   8+ 5CCA              ; -----------------------------------------------------------------------------
   9+ 5CCA
  10+ 5CCA              dzx0_standard:
  11+ 5CCA 01 FF FF             ld      bc, $ffff               ; preserve default offset 1
  12+ 5CCD C5                   push    bc
  13+ 5CCE 03                   inc     bc
  14+ 5CCF 3E 80                ld      a, $80
  15+ 5CD1              dzx0s_literals:
  16+ 5CD1 CD 01 5D             call    dzx0s_elias             ; obtain length
  17+ 5CD4              dzx0_ldir_1:
  18+ 5CD4 ED B0                ldir                            ; copy literals
  19+ 5CD6 00                   nop                             ; placeholder for call
  20+ 5CD7 87                   add     a, a                    ; copy from last offset or new offset?
  21+ 5CD8 38 0E                jr      c, dzx0s_new_offset
  22+ 5CDA CD 01 5D             call    dzx0s_elias             ; obtain length
  23+ 5CDD              dzx0s_copy:
  24+ 5CDD E3                   ex      (sp), hl                ; preserve source, restore offset
  25+ 5CDE E5                   push    hl                      ; preserve offset
  26+ 5CDF 19                   add     hl, de                  ; calculate destination - offset
  27+ 5CE0              dzx0_ldir_2:
  28+ 5CE0 ED B0                ldir                            ; copy from offset
  29+ 5CE2 00                   nop                             ; placeholder for call
  30+ 5CE3 E1                   pop     hl                      ; restore offset
  31+ 5CE4 E3                   ex      (sp), hl                ; preserve offset, restore source
  32+ 5CE5 87                   add     a, a                    ; copy from literals or new offset?
  33+ 5CE6 30 E9                jr      nc, dzx0s_literals
  34+ 5CE8              dzx0s_new_offset:
  35+ 5CE8 C1                   pop     bc                      ; discard last offset
  36+ 5CE9 0E FE                ld      c, $fe                  ; prepare negative offset
  37+ 5CEB CD 02 5D             call    dzx0s_elias_loop        ; obtain offset MSB
  38+ 5CEE 0C                   inc     c
  39+ 5CEF C8                   ret     z                       ; check end marker
  40+ 5CF0 41                   ld      b, c
  41+ 5CF1 4E                   ld      c, (hl)                 ; obtain offset LSB
  42+ 5CF2 23                   inc     hl
  43+ 5CF3 CB 18                rr      b                       ; last offset bit becomes first length bit
  44+ 5CF5 CB 19                rr      c
  45+ 5CF7 C5                   push    bc                      ; preserve new offset
  46+ 5CF8 01 01 00             ld      bc, 1                   ; obtain length
  47+ 5CFB D4 09 5D             call    nc, dzx0s_elias_backtrack
  48+ 5CFE 03                   inc     bc
  49+ 5CFF 18 DC                jr      dzx0s_copy
  50+ 5D01              dzx0s_elias:
  51+ 5D01 0C                   inc     c                       ; interlaced Elias gamma coding
  52+ 5D02              dzx0s_elias_loop:
  53+ 5D02 87                   add     a, a
  54+ 5D03 20 03                jr      nz, dzx0s_elias_skip
  55+ 5D05 7E                   ld      a, (hl)                 ; load another group of 8 bits
  56+ 5D06 23                   inc     hl
  57+ 5D07 17                   rla
  58+ 5D08              dzx0s_elias_skip:
  59+ 5D08 D8                   ret     c
  60+ 5D09              dzx0s_elias_backtrack:
  61+ 5D09 87                   add     a, a
  62+ 5D0A CB 11                rl      c
  63+ 5D0C CB 10                rl      b
  64+ 5D0E 18 F2                jr      dzx0s_elias_loop
  65+ 5D10              ; -----------------------------------------------------------------------------
  66+ 5D10
  67+ 5D10              ; *******************************************************************************************************
  68+ 5D10              ; helper function for VRAM unpack to save AF prior to calling copy to VRAM fn
  69+ 5D10              ; also simulates register states as if LDIR was called
  70+ 5D10              LDIR_TO_VRAM:
  71+ 5D10 F5                   PUSH AF ; save AF used by algorithm
  72+ 5D11 D5                   PUSH DE
  73+ 5D12 C5                   PUSH BC
  74+ 5D13 CD 88 56             CALL VRAM_LDIRVM
  75+ 5D16 C1                   POP BC
  76+ 5D17 EB                   EX DE,HL
  77+ 5D18 E1                   POP HL
  78+ 5D19 09                   ADD HL,BC
  79+ 5D1A EB                   EX DE,HL
  80+ 5D1B 01 00 00             LD BC,0
  81+ 5D1E F1                   POP AF
  82+ 5D1F C9                   RET
  83+ 5D20              ; *******************************************************************************************************
  84+ 5D20
  85+ 5D20              ; *******************************************************************************************************
  86+ 5D20              ; helper function to get a byte from VRAM address at HL and place it at DE also in VRAM
  87+ 5D20              VPOKE_VPEEK:
  88+ 5D20 F3                   DI
  89+ 5D21 CD A7 5F             CALL SETWRT_LOCAL_READ
  90+ 5D24 E3                   EX (SP),HL
  91+ 5D25 E3                   EX (SP),HL
  92+ 5D26 DB 98                IN A,(#98)
  93+ 5D28                      ;IN A,(#98) ; WHY IS THIS NEEDED ?
  94+ 5D28 F5                   PUSH AF
  95+ 5D29 EB                   EX DE,HL
  96+ 5D2A CD 9C 5F             CALL SETWRT_LOCAL_WRITE
  97+ 5D2D E3                   EX (SP),HL
  98+ 5D2E E3                   EX (SP),HL
  99+ 5D2F EB                   EX DE,HL
 100+ 5D30 F1                   POP AF
 101+ 5D31 D3 98                OUT (#98),A
 102+ 5D33 FB                   EI
 103+ 5D34 C9                   RET
 104+ 5D35              ; *******************************************************************************************************
 105+ 5D35
 106+ 5D35              ; *******************************************************************************************************
 107+ 5D35              ; helper fn VRAM variant of LDIR
 108+ 5D35              ; input HL = source, DE = destination, BC = count
 109+ 5D35              VRAM_LDIR:
 110+ 5D35 F5                   PUSH AF
 111+ 5D36              _L0:
 112+ 5D36 CD 20 5D             CALL VPOKE_VPEEK
 113+ 5D39 23                   INC HL
 114+ 5D3A 13                   INC DE
 115+ 5D3B 0B                   DEC BC
 116+ 5D3C 78                   LD A, B
 117+ 5D3D B1                   OR C
 118+ 5D3E 20 F6                JR NZ, _L0
 119+ 5D40 F1                   POP AF
 120+ 5D41 C9                   RET
 121+ 5D42              ; *******************************************************************************************************
 122+ 5D42
 123+ 5D42               IF (0 == 1)
 124+ 5D42 ~            ; *******************************************************************************************************
 125+ 5D42 ~            ; function to handle CALL VUNPACK basic extension
 126+ 5D42 ~            ; _VUNPACK ( INT source,
 127+ 5D42 ~            ;			 INT destination )
 128+ 5D42 ~            ; will put ram in page 0 also, page 1 is already there
 129+ 5D42 ~            ; *******************************************************************************************************
 130+ 5D42 ~            VUNPACK:
 131+ 5D42 ~                LD A, #CD ; CALL
 132+ 5D42 ~                LD (dzx0_ldir_1), A
 133+ 5D42 ~                LD (dzx0_ldir_2), A
 134+ 5D42 ~                LD DE, LDIR_TO_VRAM
 135+ 5D42 ~                LD (dzx0_ldir_1 + 1), DE
 136+ 5D42 ~                LD DE, VRAM_LDIR
 137+ 5D42 ~                LD (dzx0_ldir_2 + 1), DE
 138+ 5D42 ~                JR UNPACK_COMMON
 139+ 5D42 ~            ; function to handle CALL UNPACK basic extension
 140+ 5D42 ~            ; _UNPACK ( INT source,
 141+ 5D42 ~            ;			INT destination )
 142+ 5D42 ~            ; will put ram in page 0 also, page 1 is already there
 143+ 5D42 ~            UNPACK:
 144+ 5D42 ~                LD DE, #B0ED ; LDIR
 145+ 5D42 ~                LD (dzx0_ldir_1), DE
 146+ 5D42 ~                LD (dzx0_ldir_2), DE
 147+ 5D42 ~                XOR A ; NOP
 148+ 5D42 ~                LD (dzx0_ldir_1 + 2), A
 149+ 5D42 ~                LD (dzx0_ldir_2 + 2), A
 150+ 5D42 ~            UNPACK_COMMON:
 151+ 5D42 ~            	; opening (
 152+ 5D42 ~            	CALL CHKCHAR
 153+ 5D42 ~            	DB '('
 154+ 5D42 ~            	; get source address
 155+ 5D42 ~            	LD IX, FRMQNT
 156+ 5D42 ~            	CALL CALBAS
 157+ 5D42 ~            	PUSH DE
 158+ 5D42 ~            	; comma
 159+ 5D42 ~            	CALL CHKCHAR
 160+ 5D42 ~            	DB ','
 161+ 5D42 ~            	; get destination address
 162+ 5D42 ~            	LD IX, FRMQNT
 163+ 5D42 ~            	CALL CALBAS
 164+ 5D42 ~            	PUSH DE
 165+ 5D42 ~            	; ending )
 166+ 5D42 ~            	CALL CHKCHAR
 167+ 5D42 ~            	DB ')'
 168+ 5D42 ~
 169+ 5D42 ~            	; save position
 170+ 5D42 ~            	PUSH HL
 171+ 5D42 ~            	POP IX
 172+ 5D42 ~
 173+ 5D42 ~            	POP DE ; destination
 174+ 5D42 ~            	POP HL ; source
 175+ 5D42 ~            	EXX
 176+ 5D42 ~            	; enable page 0
 177+ 5D42 ~            	LD IY, .RET
 178+ 5D42 ~            	JP ENABLE_PAGE0
 179+ 5D42 ~            .RET:
 180+ 5D42 ~            	EI
 181+ 5D42 ~            	EXX
 182+ 5D42 ~            	CALL dzx0_standard
 183+ 5D42 ~                    JP COMMON_EXIT_CODE_IX
 184+ 5D42 ~            ; *******************************************************************************************************
 185+ 5D42               ENDIF
 186+ 5D42
 187+ 5D42               IF (1 == 1)
 188+ 5D42              ; *******************************************************************************************************
 189+ 5D42              ; same as VUNPACK but for DEFUSR approach
 190+ 5D42              ; input IX=pointer to input array, real data from +2
 191+ 5D42              ; +2 = source address
 192+ 5D42              ; +4 = destination address
 193+ 5D42              ; *******************************************************************************************************
 194+ 5D42              VUNPACK_DEFUSR:
 195+ 5D42 3E CD            LD A, #CD ; CALL
 196+ 5D44 32 D4 5C         LD (dzx0_ldir_1), A
 197+ 5D47 32 E0 5C         LD (dzx0_ldir_2), A
 198+ 5D4A 21 10 5D         LD HL, LDIR_TO_VRAM
 199+ 5D4D 22 D5 5C         LD (dzx0_ldir_1 + 1), HL
 200+ 5D50 21 35 5D         LD HL, VRAM_LDIR
 201+ 5D53 22 E1 5C         LD (dzx0_ldir_2 + 1), HL
 202+ 5D56 18 10            JR UNPACK_DEFUSR_COMMON
 203+ 5D58              ; same as UNPACK but for DEFUSR approach
 204+ 5D58              ; input IX=pointer to input array, real data from +2
 205+ 5D58              ; +2 = source address
 206+ 5D58              ; +4 = destination address
 207+ 5D58              UNPACK_DEFUSR:
 208+ 5D58 21 ED B0         LD HL, #B0ED ; LDIR
 209+ 5D5B 22 D4 5C         LD (dzx0_ldir_1), HL
 210+ 5D5E 22 E0 5C         LD (dzx0_ldir_2), HL
 211+ 5D61 AF               XOR A ; NOP
 212+ 5D62 32 D6 5C         LD (dzx0_ldir_1 + 2), A
 213+ 5D65 32 E2 5C         LD (dzx0_ldir_2 + 2), A
 214+ 5D68              UNPACK_DEFUSR_COMMON:
 215+ 5D68                  ; enable page 0
 216+ 5D68 FD 21 6F 5D      LD IY, .RET
 217+ 5D6C C3 7F 60         JP ENABLE_PAGE0
 218+ 5D6F              .RET:
 219+ 5D6F FB               EI
 220+ 5D70 DD 6E 02         LD L,(IX+2)
 221+ 5D73 DD 66 03         LD H,(IX+3)
 222+ 5D76 DD 5E 04         LD E,(IX+4)
 223+ 5D79 DD 56 05         LD D,(IX+5)
 224+ 5D7C CD CA 5C         CALL dzx0_standard
 225+ 5D7F C3 95 5F         JP COMMON_EXIT_CODE
 226+ 5D82              ; *******************************************************************************************************
 227+ 5D82               ENDIF
# file closed: asm\decomp.asm
 176  5D82               ENDIF
 177  5D82
 178  5D82               IF (DLOAD_CMD == 1)
 179  5D82               INCLUDE "DLOAD.asm"
# file opened: asm\DLOAD.asm
   1+ 5D82              BDOS_SETDTA     EQU #1A
   2+ 5D82              BDOS_OPEN       EQU #0F
   3+ 5D82              BDOS_CLOSE      EQU #10
   4+ 5D82              BDOS_RDBLK      EQU #27
   5+ 5D82
   6+ 5D82              ; *******************************************************************************************************
   7+ 5D82              ; function processes file name
   8+ 5D82              ; filenames supported are D:FILENAME.EXT, FILENAME.EXT, D:FILENAME, FILENAME
   9+ 5D82              ; FCB 0 will be zeroed out
  10+ 5D82              ; FCB 0 will be populated with drive info 0=default or 1-8 for drives A-H
  11+ 5D82              ; FCB 0 will be populated with file name
  12+ 5D82              ; input HL=pointer to expression
  13+ 5D82              ; input B=length
  14+ 5D82              ; returns CF=1 if bad filename
  15+ 5D82              DLOAD_PROCESS_FILENAME:
  16+ 5D82                  ; check for zero size
  17+ 5D82 78               LD A,B
  18+ 5D83 B7               OR A
  19+ 5D84 28 6B            JR Z, .BADFILENAME
  20+ 5D86                  ; check for more than 2+8+1+3=14
  21+ 5D86 FE 0F            CP 15
  22+ 5D88 30 67            JR NC, .BADFILENAME
  23+ 5D8A                  ; check if more than 2 letters
  24+ 5D8A FE 03            CP 3
  25+ 5D8C 38 1C            JR C, .L7 ; no drive
  26+ 5D8E                  ; check for : at proper place
  27+ 5D8E 5E               LD E, (HL)
  28+ 5D8F 23               INC HL
  29+ 5D90 7E               LD A, (HL)
  30+ 5D91 FE 3A            CP ':'
  31+ 5D93 20 14            JR NZ, .L1
  32+ 5D95                  ; so we have : , check for letters A-H
  33+ 5D95 7B               LD A,E
  34+ 5D96 CD EB 60         CALL UPPER
  35+ 5D99 D6 41            SUB 'A'
  36+ 5D9B FE 09            CP 9
  37+ 5D9D 30 52            JR NC, .BADFILENAME
  38+ 5D9F 23               INC HL
  39+ 5DA0 05               DEC B ; consume two characters
  40+ 5DA1 05               DEC B
  41+ 5DA2              .L2:
  42+ 5DA2 ED 5B 53 F3      LD DE, (FCB0)
  43+ 5DA6 12               LD (DE), A
  44+ 5DA7 18 04            JR .PROCESS_FILENAME
  45+ 5DA9              .L1:
  46+ 5DA9                  ; no drive specified
  47+ 5DA9 2B               DEC HL
  48+ 5DAA              .L7:
  49+ 5DAA AF               XOR A
  50+ 5DAB 18 F5            JR .L2
  51+ 5DAD              .PROCESS_FILENAME:
  52+ 5DAD                  ; HL is pointing to rest of the name
  53+ 5DAD 13               INC DE ; 8-character filename location, needs to be padded with blanks
  54+ 5DAE 0E 08            LD C,8 ; filename length
  55+ 5DB0              .L4:
  56+ 5DB0 CD F3 5D         CALL .GETCHAR
  57+ 5DB3 FE 2E            CP '.'
  58+ 5DB5 28 31            JR Z, .L6 ; if dot, fill rest with blanks
  59+ 5DB7 12               LD (DE),A
  60+ 5DB8 13               INC DE
  61+ 5DB9 0D               DEC C
  62+ 5DBA 20 F4            JR NZ, .L4
  63+ 5DBC                  ; so we cleared filename part
  64+ 5DBC 78               LD A,B ; no more letters. just fill extension with blanks
  65+ 5DBD B7               OR A
  66+ 5DBE 28 07            JR Z, .L8
  67+ 5DC0 CD F3 5D         CALL .GETCHAR ; here we must have . for a valid name
  68+ 5DC3 FE 2E            CP '.'
  69+ 5DC5 20 2A            JR NZ, .BADFILENAME
  70+ 5DC7              .L8:
  71+ 5DC7 0E 03            LD C,3
  72+ 5DC9              .L5:
  73+ 5DC9 CD F3 5D         CALL .GETCHAR
  74+ 5DCC 12               LD (DE),A
  75+ 5DCD 13               INC DE
  76+ 5DCE 0D               DEC C
  77+ 5DCF 20 F8            JR NZ, .L5
  78+ 5DD1 78               LD A,B ; nothing must be left in buffer
  79+ 5DD2 B7               OR A
  80+ 5DD3 20 1C            JR NZ, .BADFILENAME
  81+ 5DD5                  ; file name correct, now zero out the rest of FCB 0
  82+ 5DD5 2A 53 F3         LD HL,(FCB0)
  83+ 5DD8 11 0C 00         LD DE,12
  84+ 5DDB 19               ADD HL,DE
  85+ 5DDC 36 00            LD (HL),0
  86+ 5DDE 54               LD D,H
  87+ 5DDF 5D               LD E,L
  88+ 5DE0 13               INC DE
  89+ 5DE1 01 18 00         LD BC,37-12-1
  90+ 5DE4 ED B0            LDIR
  91+ 5DE6 AF               XOR A ; clear carry flag
  92+ 5DE7 C9               RET
  93+ 5DE8              .L6:
  94+ 5DE8 3E 20            LD A,' '
  95+ 5DEA              .L9:
  96+ 5DEA 12               LD (DE),A
  97+ 5DEB 13               INC DE
  98+ 5DEC 0D               DEC C
  99+ 5DED 20 FB            JR NZ, .L9
 100+ 5DEF 18 D6            JR .L8
 101+ 5DF1              .BADFILENAME:
 102+ 5DF1 37               SCF
 103+ 5DF2 C9               RET
 104+ 5DF3              .GETCHAR: ; gets a character, returns blank if we read past input
 105+ 5DF3 78               LD A,B
 106+ 5DF4 B7               OR A
 107+ 5DF5 28 07            JR Z, .BLANK
 108+ 5DF7 7E               LD A,(HL)
 109+ 5DF8 CD EB 60         CALL UPPER
 110+ 5DFB 23               INC HL
 111+ 5DFC 05               DEC B
 112+ 5DFD C9               RET
 113+ 5DFE              .BLANK:
 114+ 5DFE 3E 20            LD A,' '
 115+ 5E00 C9               RET
 116+ 5E01              ; *******************************************************************************************************
 117+ 5E01
 118+ 5E01              ; *******************************************************************************************************
 119+ 5E01              ; function sets disk buffer from NULBUF
 120+ 5E01              ; input none
 121+ 5E01              ; returns ZF!=1 on error
 122+ 5E01              DLOAD_SETDTA:
 123+ 5E01 ED 5B 62 F8      LD DE,(NULBUF)
 124+ 5E05 0E 1A            LD C, BDOS_SETDTA
 125+ 5E07 18 24            JR BDOS_CALL
 126+ 5E09              ; *******************************************************************************************************
 127+ 5E09
 128+ 5E09              ; *******************************************************************************************************
 129+ 5E09              ; function opens a file using FCB 0
 130+ 5E09              ; input none
 131+ 5E09              ; returns ZF!=1 on error
 132+ 5E09              DLOAD_OPENFILE:
 133+ 5E09 ED 5B 53 F3      LD DE,(FCB0)
 134+ 5E0D 0E 0F            LD C, BDOS_OPEN
 135+ 5E0F 18 1C            JR BDOS_CALL
 136+ 5E11              ; *******************************************************************************************************
 137+ 5E11
 138+ 5E11              ; *******************************************************************************************************
 139+ 5E11              ; function makes a file seek and sets record size to 1 byte
 140+ 5E11              ; input none
 141+ 5E11              ; output node
 142+ 5E11              DLOAD_SEEK:
 143+ 5E11 2A 41 5F         LD HL,(TMP_STRUCT)
 144+ 5E14 DD 2A 53 F3      LD IX,(FCB0)
 145+ 5E18 DD 75 21         LD (IX+33),L
 146+ 5E1B DD 74 22         LD (IX+34),H
 147+ 5E1E DD 36 0E 01      LD (IX+14),1
 148+ 5E22 DD 36 0F 00      LD (IX+15),0
 149+ 5E26 C9               RET
 150+ 5E27              ; *******************************************************************************************************
 151+ 5E27
 152+ 5E27              ; *******************************************************************************************************
 153+ 5E27              ; function reads a number of bytes from a file using FCB 0 to (NULBUF) buffer
 154+ 5E27              ; input HL=number of bytes to read
 155+ 5E27              ; returns HL=number of bytes read
 156+ 5E27              ; returns ZF!=1 on error
 157+ 5E27              DLOAD_READ:
 158+ 5E27 ED 5B 53 F3      LD DE,(FCB0)
 159+ 5E2B 0E 27            LD C,BDOS_RDBLK
 160+ 5E2D              BDOS_CALL:
 161+ 5E2D CD 7D F3         CALL BDOS
 162+ 5E30 B7               OR A
 163+ 5E31 C9               RET
 164+ 5E32              ; *******************************************************************************************************
 165+ 5E32
 166+ 5E32              ; *******************************************************************************************************
 167+ 5E32              ; function closes a file FCB 0
 168+ 5E32              ; input none
 169+ 5E32              ; returns ZF!=1 on error
 170+ 5E32              DLOAD_CLOSE:
 171+ 5E32 AF               XOR A
 172+ 5E33 ED 5B 53 F3      LD DE,(FCB0)
 173+ 5E37 0E 10            LD C,BDOS_CLOSE
 174+ 5E39 18 F2            JR BDOS_CALL
 175+ 5E3B              ; *******************************************************************************************************
 176+ 5E3B
 177+ 5E3B              ; *******************************************************************************************************
 178+ 5E3B              ; function copies data from (NULBUF) to destination, enables RAM in page 0
 179+ 5E3B              ; input BC=number of bytes to copy
 180+ 5E3B              ; output none
 181+ 5E3B              DLOAD_TRANSFERBLOCK:
 182+ 5E3B D9               EXX ; save BC
 183+ 5E3C              	; enable page 0
 184+ 5E3C FD 21 43 5E  	LD IY, .RET
 185+ 5E40 C3 7F 60     	JP ENABLE_PAGE0
 186+ 5E43              .RET:
 187+ 5E43 FB           	EI
 188+ 5E44 D9               EXX
 189+ 5E45 ED 5B 43 5F      LD DE,(TMP_STRUCT+2)
 190+ 5E49 2A 62 F8         LD HL,(NULBUF)
 191+ 5E4C ED B0        	LDIR
 192+ 5E4E ED 53 43 5F      LD (TMP_STRUCT+2),DE
 193+ 5E52 D1               POP DE
 194+ 5E53 C1               POP BC
 195+ 5E54 C3 F6 5F         JP RESTORE_PAGE_INFO
 196+ 5E57              ; *******************************************************************************************************
 197+ 5E57
 198+ 5E57              ; *******************************************************************************************************
 199+ 5E57              ; function opens and loads a file in FCB 0
 200+ 5E57              ; file name needs to be already set in FCB 0
 201+ 5E57              ; input none
 202+ 5E57              ; returns ZF!=1 on error
 203+ 5E57              DLOAD_LOADFILE:
 204+ 5E57 CD 01 5E         CALL DLOAD_SETDTA
 205+ 5E5A CD 09 5E         CALL DLOAD_OPENFILE
 206+ 5E5D C0               RET NZ
 207+ 5E5E CD 11 5E         CALL DLOAD_SEEK
 208+ 5E61 ED 4B 45 5F      LD BC,(TMP_STRUCT+4)
 209+ 5E65              .L1:
 210+ 5E65 78               LD A,B
 211+ 5E66 B7               OR A
 212+ 5E67 28 12            JR Z,.REST
 213+ 5E69 05               DEC B
 214+ 5E6A 21 00 01         LD HL,256
 215+ 5E6D              .L2:
 216+ 5E6D C5               PUSH BC
 217+ 5E6E E5               PUSH HL
 218+ 5E6F CD 27 5E         CALL DLOAD_READ
 219+ 5E72 C1               POP BC
 220+ 5E73 20 10            JR NZ,.ERRREAD
 221+ 5E75 CD 3B 5E         CALL DLOAD_TRANSFERBLOCK
 222+ 5E78 C1               POP BC
 223+ 5E79 18 EA            JR .L1
 224+ 5E7B              .REST:
 225+ 5E7B 79               LD A,C
 226+ 5E7C B7               OR A
 227+ 5E7D 28 07            JR Z,.EXIT
 228+ 5E7F 26 00            LD H,0
 229+ 5E81 69               LD L,C
 230+ 5E82 4C               LD C,H
 231+ 5E83 18 E8            JR .L2
 232+ 5E85              .ERRREAD:
 233+ 5E85 C1               POP BC
 234+ 5E86              .EXIT:
 235+ 5E86 F5               PUSH AF
 236+ 5E87 CD 32 5E         CALL DLOAD_CLOSE
 237+ 5E8A F1               POP AF
 238+ 5E8B C9               RET
 239+ 5E8C              ; *******************************************************************************************************
 240+ 5E8C
 241+ 5E8C               IF (0 == 1)
 242+ 5E8C ~
 243+ 5E8C ~            ; *******************************************************************************************************
 244+ 5E8C ~            ; function to handle CALL DLOAD basic extension
 245+ 5E8C ~            ; _DLOAD ( STRING filename,
 246+ 5E8C ~            ;		   INT offset,
 247+ 5E8C ~            ;		   INT destination,
 248+ 5E8C ~            ;          INT size )
 249+ 5E8C ~            ; will put ram in page 0 also, page 1 is already there
 250+ 5E8C ~            DLOAD:
 251+ 5E8C ~            	; opening (
 252+ 5E8C ~            	CALL CHKCHAR
 253+ 5E8C ~            	DB '('
 254+ 5E8C ~                CALL EVALTXTPARAM
 255+ 5E8C ~                PUSH HL
 256+ 5E8C ~                CALL GETSTRPNT
 257+ 5E8C ~                CALL DLOAD_PROCESS_FILENAME
 258+ 5E8C ~                JP C, BAD_FILENAME
 259+ 5E8C ~                POP HL
 260+ 5E8C ~            	; comma
 261+ 5E8C ~            	CALL CHKCHAR
 262+ 5E8C ~            	DB ','
 263+ 5E8C ~            	; get offset
 264+ 5E8C ~            	LD IX, FRMQNT
 265+ 5E8C ~            	CALL CALBAS
 266+ 5E8C ~            	LD (TMP_STRUCT), DE
 267+ 5E8C ~            	; comma
 268+ 5E8C ~            	CALL CHKCHAR
 269+ 5E8C ~            	DB ','
 270+ 5E8C ~            	; get destination
 271+ 5E8C ~            	LD IX, FRMQNT
 272+ 5E8C ~            	CALL CALBAS
 273+ 5E8C ~            	LD (TMP_STRUCT+2), DE
 274+ 5E8C ~            	; comma
 275+ 5E8C ~            	CALL CHKCHAR
 276+ 5E8C ~            	DB ','
 277+ 5E8C ~            	; get size
 278+ 5E8C ~            	LD IX, FRMQNT
 279+ 5E8C ~            	CALL CALBAS
 280+ 5E8C ~            	LD (TMP_STRUCT+4), DE
 281+ 5E8C ~            	; ending )
 282+ 5E8C ~            	CALL CHKCHAR
 283+ 5E8C ~            	DB ')'
 284+ 5E8C ~
 285+ 5E8C ~                PUSH HL
 286+ 5E8C ~                CALL DLOAD_LOADFILE
 287+ 5E8C ~                JP NZ, DISKIOERR
 288+ 5E8C ~                POP HL
 289+ 5E8C ~                RET
 290+ 5E8C ~            ; *******************************************************************************************************
 291+ 5E8C ~
 292+ 5E8C               ENDIF
 293+ 5E8C
 294+ 5E8C               IF (1 == 1)
 295+ 5E8C              ; *******************************************************************************************************
 296+ 5E8C              ; same as DLOAD but for DEFUSR approach
 297+ 5E8C              ; input IX=pointer to input array, real data from +2
 298+ 5E8C              ; +2 = string pointer
 299+ 5E8C              ; +4 = offset
 300+ 5E8C              ; +6 = destination
 301+ 5E8C              ; +8 = size
 302+ 5E8C              ; output A=0 on success
 303+ 5E8C              ; *******************************************************************************************************
 304+ 5E8C              DLOAD_DEFUSR:
 305+ 5E8C DD 6E 02         LD L,(IX+2)
 306+ 5E8F DD 66 03         LD H,(IX+3)
 307+ 5E92 46               LD B,(HL) ; string length
 308+ 5E93 23               INC HL
 309+ 5E94 5E               LD E,(HL)
 310+ 5E95 23               INC HL
 311+ 5E96 56               LD D,(HL)
 312+ 5E97 EB               EX DE,HL ; pointer to ASCIIZ text
 313+ 5E98 CD 82 5D         CALL DLOAD_PROCESS_FILENAME
 314+ 5E9B 38 22            JR C,.ERR ; exit on error
 315+ 5E9D DD 6E 04         LD L,(IX+4)
 316+ 5EA0 DD 66 05         LD H,(IX+5)
 317+ 5EA3 22 41 5F         LD (TMP_STRUCT),HL ; offset
 318+ 5EA6 DD 6E 06         LD L,(IX+6)
 319+ 5EA9 DD 66 07         LD H,(IX+7)
 320+ 5EAC 22 43 5F         LD (TMP_STRUCT+2),HL ; destination
 321+ 5EAF DD 6E 08         LD L,(IX+8)
 322+ 5EB2 DD 66 09         LD H,(IX+9)
 323+ 5EB5 22 45 5F         LD (TMP_STRUCT+4),HL ; size
 324+ 5EB8 CD 57 5E         CALL DLOAD_LOADFILE
 325+ 5EBB 20 02            JR NZ,.ERR
 326+ 5EBD AF               XOR A
 327+ 5EBE C9               RET
 328+ 5EBF              .ERR:
 329+ 5EBF 3E 01            LD A,1
 330+ 5EC1 C9               RET
 331+ 5EC2              ; *******************************************************************************************************
 332+ 5EC2
 333+ 5EC2               ENDIF
 334+ 5EC2
# file closed: asm\DLOAD.asm
 180  5EC2               ENDIF
 181  5EC2
 182  5EC2               IF (1 == 1)
 183  5EC2               INCLUDE "DEFUSR.asm"
# file opened: asm\DEFUSR.asm
   1+ 5EC2              ; entry function that handles call using CALLF
   2+ 5EC2              ; pointer to data structure is expected at DAC+2
   3+ 5EC2              ; first entry must be function id followed by function specific parameters
   4+ 5EC2
   5+ 5EC2              DEFUSR_TABLE_ENTRIES    EQU 41
   6+ 5EC2
   7+ 5EC2              DEFUSR_JUMP_TABLE:
   8+ 5EC2               IF (SPRITE_CMDS == 1)
   9+ 5EC2 75 4E         DW SPRENABLE_DEFUSR        ; 0
  10+ 5EC4               ELSE
  11+ 5EC4 ~             DW NOACTION_DEFUSR
  12+ 5EC4               ENDIF
  13+ 5EC4
  14+ 5EC4               IF (SPRITE_CMDS == 1)
  15+ 5EC4 9A 4E         DW SPRDISABLE_DEFUSR        ; 1
  16+ 5EC6               ELSE
  17+ 5EC6 ~             DW NOACTION_DEFUSR
  18+ 5EC6               ENDIF
  19+ 5EC6
  20+ 5EC6               IF (RAM_CMDS == 1)
  21+ 5EC6 5C 55         DW MEMCPY_DEFUSR           ; 2
  22+ 5EC8               ELSE
  23+ 5EC8 ~             DW NOACTION_DEFUSR
  24+ 5EC8               ENDIF
  25+ 5EC8
  26+ 5EC8               IF (VRAM_CMDS == 1)        ; 3
  27+ 5EC8 53 56         DW MEMVRM_DEFUSR
  28+ 5ECA               ELSE
  29+ 5ECA ~             DW NOACTION_DEFUSR
  30+ 5ECA               ENDIF
  31+ 5ECA
  32+ 5ECA               IF (BLIT_CMDS == 1)        ; 4
  33+ 5ECA 60 59         DW BLIT_DEFUSR
  34+ 5ECC               ELSE
  35+ 5ECC ~             DW NOACTION_DEFUSR
  36+ 5ECC               ENDIF
  37+ 5ECC
  38+ 5ECC               IF (ANIM_CMDS == 1)        ; 5
  39+ 5ECC 36 54         DW SGAM_DEFUSR
  40+ 5ECE               ELSE
  41+ 5ECE ~             DW NOACTION_DEFUSR
  42+ 5ECE               ENDIF
  43+ 5ECE
  44+ 5ECE               IF (SPRITE_CMDS == 1)
  45+ 5ECE DD 4E         DW SPRGRPMOV_DEFUSR        ; 6
  46+ 5ED0               ELSE
  47+ 5ED0 ~             DW NOACTION_DEFUSR
  48+ 5ED0               ENDIF
  49+ 5ED0
  50+ 5ED0               IF (COLL_CMD == 1)
  51+ 5ED0 87 5C         DW COLL_DEFUSR             ; 7
  52+ 5ED2               ELSE
  53+ 5ED2 ~             DW NOACTION_DEFUSR
  54+ 5ED2               ENDIF
  55+ 5ED2
  56+ 5ED2               IF (SOUND_CMDS == 1)
  57+ 5ED2 0F 56         DW SNDSFX_DEFUSR             ; 8
  58+ 5ED4               ELSE
  59+ 5ED4 ~             DW NOACTION_DEFUSR
  60+ 5ED4               ENDIF
  61+ 5ED4
  62+ 5ED4               IF (ANIM_CMDS == 1)
  63+ 5ED4 C7 52         DW ANIMSTEP_SINGLE_DEFUSR      ; 9
  64+ 5ED6 D7 52         DW ANIMSTEP_MULTI_DEFUSR       ; 10
  65+ 5ED8 E8 52         DW ANIMSTART_SINGLE_DEFUSR     ; 11
  66+ 5EDA FA 52         DW ANIMSTART_MULTI_DEFUSR      ; 12
  67+ 5EDC FF 52         DW ANIMSTOP_SINGLE_DEFUSR      ; 13
  68+ 5EDE 09 53         DW ANIMSTOP_MULTI_DEFUSR       ; 14
  69+ 5EE0               ELSE
  70+ 5EE0 ~             DW NOACTION_DEFUSR
  71+ 5EE0 ~             DW NOACTION_DEFUSR
  72+ 5EE0 ~             DW NOACTION_DEFUSR
  73+ 5EE0 ~             DW NOACTION_DEFUSR
  74+ 5EE0 ~             DW NOACTION_DEFUSR
  75+ 5EE0 ~             DW NOACTION_DEFUSR
  76+ 5EE0               ENDIF
  77+ 5EE0
  78+ 5EE0               IF (BOX_CMDS == 1)
  79+ 5EE0 6F 57         DW BOXMEMCPY_DEFUSR            ; 15
  80+ 5EE2 A1 57         DW BOXMEMVRM_DEFUSR            ; 16
  81+ 5EE4               ELSE
  82+ 5EE4 ~             DW NOACTION_DEFUSR
  83+ 5EE4 ~             DW NOACTION_DEFUSR
  84+ 5EE4               ENDIF
  85+ 5EE4
  86+ 5EE4               IF (ANIM_CMDS == 1)
  87+ 5EE4 3D 4F         DW MAXANIMITEMS_DEFUSR         ; 17
  88+ 5EE6 59 50         DW MAXANIMDEFS_DEFUSR          ; 18
  89+ 5EE8 BE 50         DW MAXANIMSPRS_DEFUSR          ; 19
  90+ 5EEA 8D 51         DW MAXAUTOSGAMS_DEFUSR         ; 20
  91+ 5EEC 05 50         DW ANIMITEMPAT_DEFUSR          ; 21
  92+ 5EEE 2F 50         DW ANIMITEMPTR_DEFUSR          ; 22
  93+ 5EF0 93 50         DW ANIMDEF_DEFUSR              ; 23
  94+ 5EF2 0E 51         DW ANIMSPRITE_DEFUSR           ; 24
  95+ 5EF4 4C 51         DW ANIMCHAR_DEFUSR             ; 25
  96+ 5EF6 E1 51         DW AUTOSGAMDEF_DEFUSR          ; 26
  97+ 5EF8 77 52         DW AUTOSGAMSTART_DEFUSR        ; 27
  98+ 5EFA A3 52         DW AUTOSGAMSTOP_DEFUSR         ; 28
  99+ 5EFC               ELSE
 100+ 5EFC ~             DW NOACTION_DEFUSR
 101+ 5EFC ~             DW NOACTION_DEFUSR
 102+ 5EFC ~             DW NOACTION_DEFUSR
 103+ 5EFC ~             DW NOACTION_DEFUSR
 104+ 5EFC ~             DW NOACTION_DEFUSR
 105+ 5EFC ~             DW NOACTION_DEFUSR
 106+ 5EFC ~             DW NOACTION_DEFUSR
 107+ 5EFC ~             DW NOACTION_DEFUSR
 108+ 5EFC ~             DW NOACTION_DEFUSR
 109+ 5EFC ~             DW NOACTION_DEFUSR
 110+ 5EFC ~             DW NOACTION_DEFUSR
 111+ 5EFC ~             DW NOACTION_DEFUSR
 112+ 5EFC               ENDIF
 113+ 5EFC
 114+ 5EFC               IF (GENCAL_CMD == 1)
 115+ 5EFC EE 56         DW GENCAL_DEFUSR               ; 29
 116+ 5EFE               ELSE
 117+ 5EFE ~             DW NOACTION_DEFUSR
 118+ 5EFE               ENDIF
 119+ 5EFE
 120+ 5EFE               IF (RAM_CMDS == 1)
 121+ 5EFE 7B 55         DW FILRAM_DEFUSR               ; 30
 122+ 5F00               ELSE
 123+ 5F00 ~             DW NOACTION_DEFUSR
 124+ 5F00               ENDIF
 125+ 5F00
 126+ 5F00               IF (SOUND_CMDS == 1)
 127+ 5F00 A9 55         DW SNDPLYINI_DEFUSR            ; 31
 128+ 5F02 DA 55         DW SNDPLYON_DEFUSR             ; 32
 129+ 5F04 EB 55         DW SNDPLYOFF_DEFUSR            ; 33
 130+ 5F06               ELSE
 131+ 5F06 ~             DW NOACTION_DEFUSR
 132+ 5F06 ~             DW NOACTION_DEFUSR
 133+ 5F06 ~             DW NOACTION_DEFUSR
 134+ 5F06               ENDIF
 135+ 5F06
 136+ 5F06               IF (TILE_CMDS == 1)
 137+ 5F06 40 5A         DW TILERAM_DEFUSR              ; 34
 138+ 5F08 F3 5A         DW TILEVRM_DEFUSR              ; 35
 139+ 5F0A               ELSE
 140+ 5F0A ~             DW NOACTION_DEFUSR
 141+ 5F0A ~             DW NOACTION_DEFUSR
 142+ 5F0A               ENDIF
 143+ 5F0A
 144+ 5F0A               IF (VRAM_CMDS == 1)
 145+ 5F0A 30 56         DW FILVRM_DEFUSR               ; 36
 146+ 5F0C B2 56         DW VRMMEM_DEFUSR               ; 37
 147+ 5F0E               ELSE
 148+ 5F0E ~             DW NOACTION_DEFUSR
 149+ 5F0E ~             DW NOACTION_DEFUSR
 150+ 5F0E               ENDIF
 151+ 5F0E
 152+ 5F0E               IF (DECOMP_CMDS == 1)
 153+ 5F0E 58 5D         DW UNPACK_DEFUSR               ; 38
 154+ 5F10               IF (VRAM_CMDS == 1)
 155+ 5F10 42 5D          DW VUNPACK_DEFUSR             ; 39
 156+ 5F12               ELSE
 157+ 5F12 ~              DW NOACTION_DEFUSR
 158+ 5F12               ENDIF
 159+ 5F12               ELSE
 160+ 5F12 ~             DW NOACTION_DEFUSR
 161+ 5F12 ~             DW NOACTION_DEFUSR
 162+ 5F12               ENDIF
 163+ 5F12
 164+ 5F12               IF (DLOAD_CMD == 1)
 165+ 5F12 8C 5E         DW DLOAD_DEFUSR               ; 40
 166+ 5F14               ELSE
 167+ 5F14 ~             DW NOACTION_DEFUSR
 168+ 5F14               ENDIF
 169+ 5F14
 170+ 5F14              ; *******************************************************************************************************
 171+ 5F14              ; function jumps to specified function based on inputs and returns success flag in (DAC+2) of type integer
 172+ 5F14              ; input INT(DAC+2) function ID = 0..DEFUSR_TABLE_ENTRIES-1
 173+ 5F14              ; input function specific parameters after the function ID, these are handled later in a called fn
 174+ 5F14              ; output stores back A to (DAC+2) and set type to INT, A=0 success
 175+ 5F14              DEFUSR_ENTRY:
 176+ 5F14 FB               EI
 177+ 5F15 DD 2A F8 F7      LD IX,(DAC+2)
 178+ 5F19 DD 7E 00         LD A,(IX)
 179+ 5F1C FE 29            CP DEFUSR_TABLE_ENTRIES
 180+ 5F1E 30 11            JR NC,.RET ; return if an undefined function requested
 181+ 5F20 26 00            LD H,0
 182+ 5F22 6F               LD L,A
 183+ 5F23 29               ADD HL,HL
 184+ 5F24 11 C2 5E         LD DE,DEFUSR_JUMP_TABLE
 185+ 5F27 19               ADD HL,DE
 186+ 5F28 7E               LD A,(HL)
 187+ 5F29 23               INC HL
 188+ 5F2A 66               LD H,(HL)
 189+ 5F2B 6F               LD L,A
 190+ 5F2C 11 31 5F         LD DE,.RET
 191+ 5F2F D5               PUSH DE
 192+ 5F30 E9               JP (HL) ; call function with IX=pointer to data array
 193+ 5F31              .RET:
 194+ 5F31 26 00            LD H,0
 195+ 5F33 6F               LD L,A
 196+ 5F34 22 F8 F7         LD (DAC+2),HL
 197+ 5F37 3E 02            LD A,2 ; INT
 198+ 5F39 32 63 F6         LD (VALTYP),A
 199+ 5F3C C9               RET
 200+ 5F3D
 201+ 5F3D
# file closed: asm\DEFUSR.asm
 184  5F3D               ENDIF
 185  5F3D
 186  5F3D              ; temp variables for various fuctions
 187  5F3D              ; name historically from usage by BLIT, but since then
 188  5F3D              BLIT_TMP:
 189  5F3D              TILETMP1:
 190  5F3D              BLIT_TMP1:
 191  5F3D 00 00         DW 0
 192  5F3F              TILETMP2:
 193  5F3F              BLIT_TMP2:
 194  5F3F 00 00         DW 0
 195  5F41              TMP_STRUCT:
 196  5F41 00 00 00...   DS 17
 197  5F52
 198  5F52               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 199  5F52              VRAM_UPDATE_IN_PROGRESS:
 200  5F52 00            DB 0
 201  5F53               ENDIF
 202  5F53
 203  5F53              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 204  5F53              ; per starting letter, if no commands with this letter, NULL value
 205  5F53              CMDS:
 206  5F53 87 5F        	DW CMDS_A ; always present due to ARTINFO
 207  5F55               IF (BLIT_CMDS + BOX_CMDS > 0) && (0 == 1)
 208  5F55 ~                DW CMDS_B ; B
 209  5F55               ELSE
 210  5F55 00 00        	DW 0
 211  5F57               ENDIF
 212  5F57               IF (COLL_CMD == 1) && (0 == 1)
 213  5F57 ~            	DW CMDS_C ;
 214  5F57               ELSE
 215  5F57 00 00            DW 0 ; C
 216  5F59               ENDIF
 217  5F59               IF (DLOAD_CMD > 0) && (0 == 1)
 218  5F59 ~                DW CMDS_D ; D
 219  5F59               ELSE
 220  5F59 00 00        	DW 0
 221  5F5B               ENDIF
 222  5F5B 00 00            DW 0 ; E
 223  5F5D               IF (VRAM_CMDS + RAM_CMDS > 0) && (0 == 1)
 224  5F5D ~                DW CMDS_F; F
 225  5F5D               ELSE
 226  5F5D 00 00        	DW 0
 227  5F5F               ENDIF
 228  5F5F               IF (GENCAL_CMD > 0) && (0 == 1)
 229  5F5F ~                DW CMDS_G; G
 230  5F5F               ELSE
 231  5F5F 00 00        	DW 0
 232  5F61               ENDIF
 233  5F61 00 00            DW 0 ; H
 234  5F63 00 00            DW 0 ; I
 235  5F65 00 00            DW 0 ; J
 236  5F67 00 00            DW 0 ; K
 237  5F69 00 00            DW 0 ; L
 238  5F6B               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0) && (0 == 1)
 239  5F6B ~                DW CMDS_M ; M
 240  5F6B               ELSE
 241  5F6B 00 00        	DW 0
 242  5F6D               ENDIF
 243  5F6D 00 00            DW 0 ; N
 244  5F6F 00 00            DW 0 ; O
 245  5F71 00 00            DW 0 ; P
 246  5F73 00 00            DW 0 ; Q
 247  5F75 00 00            DW 0 ; R
 248  5F77               IF (SOUND_CMDS + SPRITE_CMDS > 0) && (0 == 1)
 249  5F77 ~                DW CMDS_S ; S
 250  5F77               ELSE
 251  5F77 00 00        	DW 0
 252  5F79               ENDIF
 253  5F79               IF (TILE_CMDS > 0) && (0 == 1)
 254  5F79 ~                DW CMDS_T ; T
 255  5F79               ELSE
 256  5F79 00 00        	DW 0
 257  5F7B               ENDIF
 258  5F7B               IF (DECOMP_CMDS > 0) && (0 == 1)
 259  5F7B ~                DW CMDS_U ; U
 260  5F7B               ELSE
 261  5F7B 00 00        	DW 0
 262  5F7D               ENDIF
 263  5F7D               IF ((VRAM_CMDS > 0) || (VRAM_CMDS + DECOMP_CMDS > 1)) && (0 == 1)
 264  5F7D ~                DW CMDS_V ; V
 265  5F7D               ELSE
 266  5F7D 00 00        	DW 0
 267  5F7F               ENDIF
 268  5F7F 00 00            DW 0 ; W
 269  5F81 00 00            DW 0 ; X
 270  5F83 00 00            DW 0 ; Y
 271  5F85 00 00            DW 0 ; Z
 272  5F87
 273  5F87               IF (0 == 1)
 274  5F87 ~             IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 275  5F87 ~            CMDS_M:
 276  5F87 ~             IF (VRAM_CMDS == 1)
 277  5F87 ~                DB "MEMVRM", 0
 278  5F87 ~                DW MEMVRM
 279  5F87 ~             ENDIF
 280  5F87 ~             IF (RAM_CMDS == 1)
 281  5F87 ~            	DB "MEMCPY", 0
 282  5F87 ~            	DW MEMCPY
 283  5F87 ~             ENDIF
 284  5F87 ~             IF (ANIM_CMDS == 1)
 285  5F87 ~            	DB "MAXANIMITEMS",0
 286  5F87 ~            	DW MAXANIMITEMS
 287  5F87 ~            	DB "MAXANIMDEFS",0
 288  5F87 ~            	DW MAXANIMDEFS
 289  5F87 ~            	DB "MAXANIMSPRS",0
 290  5F87 ~            	DW MAXANIMSPRS
 291  5F87 ~               DB "MAXAUTOSGAMS",0
 292  5F87 ~               DW MAXAUTOSGAMS
 293  5F87 ~             ENDIF
 294  5F87 ~             ENDIF
 295  5F87 ~
 296  5F87 ~             IF (VRAM_CMDS + RAM_CMDS > 0)
 297  5F87 ~            CMDS_F:
 298  5F87 ~             IF (VRAM_CMDS == 1)
 299  5F87 ~                DB "FILVRM", 0
 300  5F87 ~                DW FILVRM
 301  5F87 ~             ENDIF
 302  5F87 ~             IF (RAM_CMDS == 1)
 303  5F87 ~                DB "FILRAM", 0
 304  5F87 ~                DW FILRAM
 305  5F87 ~             ENDIF
 306  5F87 ~             ENDIF
 307  5F87 ~
 308  5F87 ~             IF (GENCAL_CMD > 0)
 309  5F87 ~            CMDS_G:
 310  5F87 ~             IF (GENCAL_CMD == 1)
 311  5F87 ~                DB "GENCAL", 0
 312  5F87 ~                DW GENCAL
 313  5F87 ~             ENDIF
 314  5F87 ~             ENDIF
 315  5F87 ~
 316  5F87 ~             IF (VRAM_CMDS > 0)
 317  5F87 ~            CMDS_V:
 318  5F87 ~             IF (VRAM_CMDS == 1)
 319  5F87 ~            	DB "VRMMEM", 0
 320  5F87 ~            	DW VRMMEM
 321  5F87 ~             ENDIF
 322  5F87 ~             IF (DECOMP_CMDS == 1)
 323  5F87 ~            	DB "VUNPACK", 0
 324  5F87 ~            	DW VUNPACK
 325  5F87 ~             ENDIF
 326  5F87 ~             ENDIF
 327  5F87 ~
 328  5F87 ~             IF (SOUND_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 329  5F87 ~            CMDS_S:
 330  5F87 ~             IF (SPRITE_CMDS + ANIM_CMDS > 0)
 331  5F87 ~                DB "SGAM",0
 332  5F87 ~                DW SGAM
 333  5F87 ~             ENDIF
 334  5F87 ~             IF (SPRITE_CMDS == 1)
 335  5F87 ~            	DB "SPRGRPMOV", 0
 336  5F87 ~            	DW SPRGRPMOV
 337  5F87 ~             ENDIF
 338  5F87 ~             IF (SOUND_CMDS == 1)
 339  5F87 ~            	DB "SNDSFX", 0
 340  5F87 ~            	DW SNDSFX
 341  5F87 ~            	DB "SNDPLYON", 0
 342  5F87 ~            	DW SNDPLYON
 343  5F87 ~            	DB "SNDPLYOFF", 0
 344  5F87 ~            	DW SNDPLYOFF
 345  5F87 ~            	DB "SNDPLYINI", 0
 346  5F87 ~            	DW SNDPLYINIT
 347  5F87 ~             ENDIF
 348  5F87 ~             IF (SPRITE_CMDS == 1)
 349  5F87 ~            	DB "SPRENABLE", 0
 350  5F87 ~            	DW SPRENABLE
 351  5F87 ~            	DB "SPRDISABLE", 0
 352  5F87 ~            	DW SPRDISABLE
 353  5F87 ~             ENDIF
 354  5F87 ~             ENDIF
 355  5F87 ~
 356  5F87 ~             IF (BLIT_CMDS + BOX_CMDS > 0)
 357  5F87 ~            CMDS_B:
 358  5F87 ~             IF (BLIT_CMDS == 1)
 359  5F87 ~            	DB "BLIT", 0
 360  5F87 ~            	DW BLIT
 361  5F87 ~             ENDIF
 362  5F87 ~             IF (BOX_CMDS == 1)
 363  5F87 ~            	DB "BOXMEMCPY", 0
 364  5F87 ~            	DW BOXMEMCPY
 365  5F87 ~            	DB "BOXMEMVRM", 0
 366  5F87 ~            	DW BOXMEMVRM
 367  5F87 ~             ENDIF
 368  5F87 ~             ENDIF
 369  5F87 ~
 370  5F87 ~             IF (TILE_CMDS > 0)
 371  5F87 ~            CMDS_T:
 372  5F87 ~             IF (TILE_CMDS == 1)
 373  5F87 ~            	DB "TILERAM", 0
 374  5F87 ~            	DW TILERAM
 375  5F87 ~            	DB "TILEVRM", 0
 376  5F87 ~            	DW TILEVRM
 377  5F87 ~             ENDIF
 378  5F87 ~             ENDIF
 379  5F87 ~
 380  5F87 ~             IF (COLL_CMD > 0)
 381  5F87 ~            CMDS_C:
 382  5F87 ~             IF (COLL_CMD == 1)
 383  5F87 ~                DB "COLL", 0
 384  5F87 ~                DW COLL
 385  5F87 ~             ENDIF
 386  5F87 ~             ENDIF
 387  5F87 ~
 388  5F87 ~             IF (DECOMP_CMDS > 0)
 389  5F87 ~            CMDS_U:
 390  5F87 ~             IF (DECOMP_CMDS == 1)
 391  5F87 ~                DB "UNPACK", 0
 392  5F87 ~                DW UNPACK
 393  5F87 ~             ENDIF
 394  5F87 ~             ENDIF
 395  5F87 ~
 396  5F87 ~             IF (DLOAD_CMD > 0)
 397  5F87 ~            CMDS_D:
 398  5F87 ~             IF (DLOAD_CMD == 1)
 399  5F87 ~                DB "DLOAD", 0
 400  5F87 ~                DW DLOAD
 401  5F87 ~             ENDIF
 402  5F87 ~             ENDIF
 403  5F87 ~
 404  5F87 ~            CMDS_A:
 405  5F87 ~             IF (ANIM_CMDS == 1)
 406  5F87 ~               DB "ANIMSTEP",0
 407  5F87 ~               DW ANIMSTEP
 408  5F87 ~            	DB "ANIMSTART",0
 409  5F87 ~            	DW ANIMSTART
 410  5F87 ~            	DB "ANIMSTOP",0
 411  5F87 ~            	DW ANIMSTOP
 412  5F87 ~            	DB "ANIMITEMPAT",0
 413  5F87 ~            	DW ANIMITEMPAT
 414  5F87 ~            	DB "ANIMITEMPTR",0
 415  5F87 ~            	DW ANIMITEMPTR_CMD
 416  5F87 ~            	DB "ANIMDEF",0
 417  5F87 ~            	DW ANIMDEF
 418  5F87 ~            	DB "ANIMSPRITE",0
 419  5F87 ~            	DW ANIMSPRITE
 420  5F87 ~               DB "ANIMCHAR",0
 421  5F87 ~               DW ANIMCHAR
 422  5F87 ~               DB "AUTOSGAMDEF",0
 423  5F87 ~               DW AUTOSGAMDEF
 424  5F87 ~               DB "AUTOSGAMSTART",0
 425  5F87 ~               DW AUTOSGAMSTART
 426  5F87 ~               DB "AUTOSGAMSTOP",0
 427  5F87 ~               DW AUTOSGAMSTOP
 428  5F87 ~             ENDIF
 429  5F87 ~               DB "ARTINFO",0
 430  5F87 ~               DW ARTINFO
 431  5F87 ~            	DB 0
 432  5F87               ELSE // if not BASIC extension
 433  5F87              CMDS_A:
 434  5F87 41 52 54 49     DB "ARTINFO",0
 434  5F8B 4E 46 4F 00
 435  5F8F F4 60           DW ARTINFO
 436  5F91 00           	DB 0
 437  5F92               ENDIF
 438  5F92
 439  5F92              ; ****************************************************************************************************
 440  5F92              ; some common exit code
 441  5F92              ; returns ROM in page 0
 442  5F92              ; sets exit status to 0 in A
 443  5F92              COMMON_EXIT_CODE_IX:
 444  5F92 DD E5           PUSH IX
 445  5F94 E1              POP HL
 446  5F95              COMMON_EXIT_CODE:
 447  5F95 D1              POP DE
 448  5F96 C1              POP BC
 449  5F97 CD F6 5F        CALL RESTORE_PAGE_INFO
 450  5F9A AF           	XOR A ; success
 451  5F9B C9           	RET
 452  5F9C              ; ****************************************************************************************************
 453  5F9C
 454  5F9C               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 455  5F9C              ; ****************************************************************************************************
 456  5F9C              ; function sets VRAM address for writing
 457  5F9C              ; input HL=address
 458  5F9C              ; modifies AF
 459  5F9C              SETWRT_LOCAL_WRITE:
 460  5F9C 7D           	LD	A,L
 461  5F9D D3 99        	OUT (#99),A
 462  5F9F 7C           	LD	A,H
 463  5FA0 E6 3F        	AND #3F
 464  5FA2 F6 40        	OR	#40
 465  5FA4 D3 99        	OUT (#99),A
 466  5FA6 C9           	RET
 467  5FA7              ; ****************************************************************************************************
 468  5FA7
 469  5FA7              ; ****************************************************************************************************
 470  5FA7              ; function sets VRAM address for reading
 471  5FA7              ; input HL=address
 472  5FA7              ; modifies AF
 473  5FA7              SETWRT_LOCAL_READ:
 474  5FA7 7D           	LD	A,L
 475  5FA8 D3 99        	OUT (#99),A
 476  5FAA 7C           	LD	A,H
 477  5FAB E6 3F        	AND #3F
 478  5FAD 00              NOP
 479  5FAE D3 99        	OUT (#99),A
 480  5FB0 C9           	RET
 481  5FB1              ; ****************************************************************************************************
 482  5FB1               ENDIF
 483  5FB1
 484  5FB1               IF (VRAM_CMDS + TILE_CMDS > 0)
 485  5FB1              ; ****************************************************************************************************
 486  5FB1              ; function copies data from RAM to VRAM
 487  5FB1              ; input HL=address in RAM
 488  5FB1              ; input B=count
 489  5FB1              ; modifies AF, BC, HL
 490  5FB1              BBYTECOPY:
 491  5FB1 0E 98        	LD C,#98
 492  5FB3              BBYTECOPY_NO_C:
 493  5FB3 ED A3        	OUTI
 494  5FB5 C2 B3 5F     	JP	NZ, BBYTECOPY_NO_C
 495  5FB8 C9           	RET
 496  5FB9              ; ****************************************************************************************************
 497  5FB9               ENDIF
 498  5FB9
 499  5FB9              ; ****************************************************************************************************
 500  5FB9              ; function multiplies HL by 32
 501  5FB9              HLx32:
 502  5FB9 29           	ADD HL,HL
 503  5FBA              ; ****************************************************************************************************
 504  5FBA              ; function multiplies HL by 16
 505  5FBA              HLx16:
 506  5FBA 29           	ADD HL,HL
 507  5FBB              ; ****************************************************************************************************
 508  5FBB              ; function multiplies HL by 8
 509  5FBB              HLx8:
 510  5FBB 29          > ADD HL, HL
 510  5FBC 29          > ADD HL, HL
 510  5FBD 29          > ADD HL, HL
 511  5FBE C9           	RET
 512  5FBF              ; ****************************************************************************************************
 513  5FBF
 514  5FBF              ; ****************************************************************************************************
 515  5FBF              ; function gets slot and subslot data for specific page
 516  5FBF              ; input A=page (0, 1 or 2)
 517  5FBF              ; output B = 0A8H register value
 518  5FBF              ; output D = 0 is no subslots, 1 if yes
 519  5FBF              ; output C = 0A8H value when page 3 slot equals to requested page slot
 520  5FBF              ; output E = subslot value if present
 521  5FBF              ; modifies AF, BC, DE, HL
 522  5FBF              GET_PAGE_INFO:
 523  5FBF 6F               LD L, A
 524  5FC0 C6 C1            ADD A, low (EXPTBL)
 525  5FC2 32 CC 5F         LD (GET_PAGE_INFO_L1+1), A
 526  5FC5 DB A8            IN A, (0A8H)
 527  5FC7 47               LD B, A
 528  5FC8 E6 3F            AND 03FH
 529  5FCA 4F               LD C, A
 530  5FCB              GET_PAGE_INFO_L1:
 531  5FCB 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 532  5FCE E6 80            AND 080H
 533  5FD0 28 1B            JR Z, GET_PAGE_INFO_L2
 534  5FD2                  ; expanded
 535  5FD2 2D               DEC L
 536  5FD3 FA F2 5F         JP M, GET_PAGE_INFO_L3
 537  5FD6 2D               DEC L
 538  5FD7 FA F0 5F         JP M, GET_PAGE_INFO_L4
 539  5FDA                  ; page 2
 540  5FDA 07               RLCA
 541  5FDB 07               RLCA
 542  5FDC              GET_PAGE_INFO_L5:
 543  5FDC E6 C0            AND 0C0H
 544  5FDE B1               OR C
 545  5FDF D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 546  5FE1 4F               LD C, A
 547  5FE2 3A FF FF         LD A, (0FFFFH)
 548  5FE5 2F               CPL
 549  5FE6 5F               LD E, A
 550  5FE7 16 01            LD D, 1
 551  5FE9 78               LD A, B ; return stack
 552  5FEA D3 A8            OUT (0A8H), A
 553  5FEC C9               RET
 554  5FED              GET_PAGE_INFO_L2:
 555  5FED                  ; not expanded
 556  5FED 16 00            LD D, 0
 557  5FEF C9               RET
 558  5FF0              GET_PAGE_INFO_L4:
 559  5FF0                  ; page 1
 560  5FF0 0F               RRCA
 561  5FF1 0F               RRCA
 562  5FF2              GET_PAGE_INFO_L3:
 563  5FF2                  ; page 0
 564  5FF2 0F               RRCA
 565  5FF3 0F               RRCA
 566  5FF4 18 E6            JR GET_PAGE_INFO_L5
 567  5FF6              ; ****************************************************************************************************
 568  5FF6
 569  5FF6              ; ****************************************************************************************************
 570  5FF6              ; function returns original slot and subslot info
 571  5FF6              ; input B = 0A8H register value
 572  5FF6              ; input D = 0 is no subslots, 1 if yes
 573  5FF6              ; input C = 0A8H value when page 3 slot equals to requested page slot
 574  5FF6              ; input E = subslot value if present
 575  5FF6              ; modifies AF, disables interrupts
 576  5FF6              RESTORE_PAGE_INFO:
 577  5FF6 F3              DI
 578  5FF7 7A              LD A, D
 579  5FF8 B7              OR A
 580  5FF9 28 07           JR Z, RESTORE_PAGE_INFO_L1
 581  5FFB 79              LD A, C
 582  5FFC D3 A8           OUT (0A8H), A
 583  5FFE 7B              LD A, E
 584  5FFF 32 FF FF        LD (0FFFFH), A
 585  6002              RESTORE_PAGE_INFO_L1:
 586  6002 78              LD A, B
 587  6003 D3 A8           OUT (0A8H), A
 588  6005              NOACTION_DEFUSR: ; just a safe RET for use when DEFUSR table has an empty entry
 589  6005 C9              RET
 590  6006              ; ****************************************************************************************************
 591  6006
 592  6006              ; *******************************************************************************************************
 593  6006              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 594  6006              ; INPUT:  A = SLOT ID: EXXXSSPP
 595  6006              ; E = EXPANDED FLAG
 596  6006              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 597  6006              ; PP = PRIMARY SLOT NUMBER
 598  6006              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 599  6006              ; CHANGES: AF, BC, DE
 600  6006
 601  6006              LOCAL_ENASLT:
 602  6006 CD 26 60         CALL L0353
 603  6009 FA 13 60         JP M, L0340
 604  600C DB A8            IN A, (0A8H)
 605  600E A1               AND C
 606  600F B0               OR B
 607  6010 D3 A8            OUT (0A8H), A
 608  6012 C9               RET
 609  6013              L0340:
 610  6013 E5               PUSH HL
 611  6014 CD 4B 60         CALL L0378
 612  6017 4F               LD C, A
 613  6018 06 00            LD B, 0
 614  601A 7D               LD A, L
 615  601B A4               AND H
 616  601C B2               OR D
 617  601D 21 C5 FC         LD HL, 0FCC5H
 618  6020 09               ADD HL, BC
 619  6021 77               LD (HL), A
 620  6022 E1               POP HL
 621  6023 79               LD A, C
 622  6024 18 E0            JR LOCAL_ENASLT
 623  6026              L0353:
 624  6026 F3               DI
 625  6027 F5               PUSH AF
 626  6028 7C               LD A, H
 627  6029 07               RLCA
 628  602A 07               RLCA
 629  602B E6 03            AND 3
 630  602D 5F               LD E, A
 631  602E 3E C0            LD A, 0C0H
 632  6030              L035D:
 633  6030 07               RLCA
 634  6031 07               RLCA
 635  6032 1D               DEC E
 636  6033 F2 30 60         JP P, L035D
 637  6036 5F               LD E, A
 638  6037 2F               CPL
 639  6038 4F               LD C, A
 640  6039 F1               POP AF
 641  603A F5               PUSH AF
 642  603B E6 03            AND 3
 643  603D 3C               INC A
 644  603E 47               LD B, A
 645  603F 3E AB            LD A, 0ABH
 646  6041              L036E:
 647  6041 C6 55            ADD A, 055H
 648  6043 10 FC            DJNZ L036E
 649  6045 57               LD D, A
 650  6046 A3               AND E
 651  6047 47               LD B, A
 652  6048 F1               POP AF
 653  6049 A7               AND A
 654  604A C9               RET
 655  604B              L0378:
 656  604B F5               PUSH AF
 657  604C 7A               LD A, D
 658  604D E6 C0            AND 0C0H
 659  604F 4F               LD C, A
 660  6050 F1               POP AF
 661  6051 F5               PUSH AF
 662  6052 57               LD D, A
 663  6053 DB A8            IN A, (0A8H)
 664  6055 47               LD B, A
 665  6056 E6 3F            AND 03FH
 666  6058 B1               OR C
 667  6059 D3 A8            OUT (0A8H), A
 668  605B 7A               LD A, D
 669  605C 0F               RRCA
 670  605D 0F               RRCA
 671  605E E6 03            AND 3
 672  6060 57               LD D, A
 673  6061 3E AB            LD A, 0ABH
 674  6063              L0390:
 675  6063 C6 55            ADD A, 055H
 676  6065 15               DEC D
 677  6066 F2 63 60         JP P, L0390
 678  6069 A3               AND E
 679  606A 57               LD D, A
 680  606B 7B               LD A, E
 681  606C 2F               CPL
 682  606D 67               LD H, A
 683  606E 3A FF FF         LD A, (0FFFFH)
 684  6071 2F               CPL
 685  6072 6F               LD L, A
 686  6073 A4               AND H
 687  6074 B2               OR D
 688  6075 32 FF FF         LD (0FFFFH), A
 689  6078 78               LD A, B
 690  6079 D3 A8            OUT (0A8H), A
 691  607B F1               POP AF
 692  607C E6 03            AND 3
 693  607E C9               RET
 694  607F              ; *******************************************************************************************************
 695  607F
 696  607F              ; *******************************************************************************************************
 697  607F              ; some common code to activate page 0 and place values needed to restore original page on stack
 698  607F              ; input IY=return address
 699  607F              ENABLE_PAGE0:
 700  607F F3              DI
 701  6080 AF              XOR A
 702  6081 CD BF 5F        CALL GET_PAGE_INFO
 703  6084 C5              PUSH BC
 704  6085 D5              PUSH DE
 705  6086 3A 41 F3        LD A, (RAMAD0)
 706  6089 26 00           LD H, 0
 707  608B CD 06 60        CALL LOCAL_ENASLT
 708  608E FD E9        	JP (IY)
 709  6090              ; *******************************************************************************************************
 710  6090
 711  6090              ; General BASIC CALL-instruction handler
 712  6090              CALLHAND:
 713  6090 FB              EI
 714  6091 E5           	PUSH HL
 715  6092 21 53 5F     	LD	HL, CMDS ; pointer table based on starting letter
 716  6095 3A 89 FD        LD A, (PROCNM)
 717  6098 D6 41           SUB 'A'
 718  609A 87              ADD A, A
 719  609B 16 00           LD D, 0
 720  609D 5F              LD E, A
 721  609E 19              ADD HL, DE
 722  609F 5E              LD E, (HL)
 723  60A0 23              INC HL
 724  60A1 56              LD D, (HL)
 725  60A2 7A              LD A, D
 726  60A3 B3              OR E
 727  60A4 28 23           JR Z, .CMDNOTRECOGNIZED
 728  60A6 EB              EX DE, HL
 729  60A7              .CHKCMD:
 730  60A7 11 89 FD     	LD	DE, PROCNM
 731  60AA              .LOOP:
 732  60AA 1A              LD	A,(DE)
 733  60AB BE           	CP	(HL)
 734  60AC 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 735  60AE 13           	INC	DE
 736  60AF 23           	INC	HL
 737  60B0 A7           	AND	A
 738  60B1 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 739  60B3 5E           	LD	E,(HL)
 740  60B4 23           	INC	HL
 741  60B5 56           	LD	D,(HL)
 742  60B6 E1           	POP	HL		; routine address
 743  60B7 CD D8 60     	CALL	GETPREVCHAR
 744  60BA CD CC 60     	CALL	.CALLDE		; Call routine
 745  60BD A7           	AND	A
 746  60BE C9           	RET
 747  60BF
 748  60BF              .TONEXTCMD:
 749  60BF 0E FF        	LD	C,0FFH
 750  60C1 AF           	XOR	A
 751  60C2 ED B1        	CPIR			; Skip to end of instruction name
 752  60C4 23           	INC	HL
 753  60C5 23           	INC	HL		; Skip address
 754  60C6 BE           	CP	(HL)
 755  60C7 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 756  60C9              .CMDNOTRECOGNIZED:
 757  60C9 E1           	POP	HL
 758  60CA 37              SCF
 759  60CB C9           	RET
 760  60CC
 761  60CC              .CALLDE:
 762  60CC D5           	PUSH	DE
 763  60CD C9           	RET
 764  60CE
 765  60CE              ;---------------------------
 766  60CE
 767  60CE              CHKCHAR:
 768  60CE CD D8 60     	CALL	GETPREVCHAR	; Get previous basic char
 769  60D1 E3           	EX	(SP),HL
 770  60D2 BE           	CP	(HL) 	        ; Check if good char
 771  60D3 20 0D        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 772  60D5 23           	INC	HL
 773  60D6 E3           	EX	(SP),HL
 774  60D7 23           	INC	HL		; Get next basic char
 775  60D8
 776  60D8              GETPREVCHAR:
 777  60D8 2B           	DEC HL
 778  60D9 DD 21 66 46  	LD	IX,CHRGTR
 779  60DD CD 59 01     	CALL CALBAS
 780  60E0 FB              EI
 781  60E1 C9              RET
 782  60E2
 783  60E2               IF (0 == 1)
 784  60E2 ~             IF (DLOAD_CMD == 1)
 785  60E2 ~            BAD_FILENAME:
 786  60E2 ~               LD E,56
 787  60E2 ~               JR THROW_ERROR
 788  60E2 ~            DISKIOERR:
 789  60E2 ~               LD E,69
 790  60E2 ~               JR THROW_ERROR
 791  60E2 ~             ENDIF
 792  60E2 ~            OUT_OF_DATA:
 793  60E2 ~               LD E, 4
 794  60E2 ~               JR THROW_ERROR
 795  60E2 ~            TYPE_MISMATCH:
 796  60E2 ~               LD E, 13 ; Type mismatch
 797  60E2 ~               JR THROW_ERROR
 798  60E2 ~            SUBSCRIPT_OUT_OF_RANGE:
 799  60E2 ~               LD E,9 ; subscript out of range
 800  60E2 ~            	JR THROW_ERROR
 801  60E2 ~            OVERFLOW:
 802  60E2 ~            	LD E,6
 803  60E2 ~            	JR THROW_ERROR
 804  60E2 ~            ILLEGAL_FUNCTION:
 805  60E2 ~               LD E, 5 ; illegal function call
 806  60E2 ~               JR THROW_ERROR
 807  60E2               ENDIF
 808  60E2              SYNTAX_ERROR:
 809  60E2 1E 02           LD E, 2 ; Syntax error
 810  60E4              THROW_ERROR:
 811  60E4 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 812  60E8 C3 59 01     	JP	CALBAS
 813  60EB
 814  60EB
 815  60EB              ;---------------------------
 816  60EB
 817  60EB               IF (DLOAD_CMD == 1)
 818  60EB              ; *******************************************************************************************************
 819  60EB              ; helper function to make an uppercase letter
 820  60EB              ; input A=character
 821  60EB              ; output A=uppercase version of input
 822  60EB              UPPER:
 823  60EB FE 61           CP "a"
 824  60ED D8              RET C
 825  60EE FE 7B           CP "z"+1
 826  60F0 D0              RET NC
 827  60F1 E6 5F           AND 5FH
 828  60F3 C9              RET
 829  60F4              ; *******************************************************************************************************
 830  60F4               ENDIF
 831  60F4
 832  60F4               IF (0 == 1)
 833  60F4 ~
 834  60F4 ~             IF (DLOAD_CMD == 1)
 835  60F4 ~            ; *******************************************************************************************************
 836  60F4 ~            ; helper function to return string pointer and length
 837  60F4 ~            ; returns HL = String Address
 838  60F4 ~            ; returns B  = Lenght
 839  60F4 ~            ; modifies BC, DE, HL
 840  60F4 ~            GETSTRPNT:
 841  60F4 ~               LD      HL,(USR)
 842  60F4 ~               LD      B,(HL)
 843  60F4 ~               INC     HL
 844  60F4 ~               LD      E,(HL)
 845  60F4 ~               INC     HL
 846  60F4 ~               LD      D,(HL)
 847  60F4 ~               EX      DE,HL
 848  60F4 ~               RET
 849  60F4 ~            ; *******************************************************************************************************
 850  60F4 ~
 851  60F4 ~            ; *******************************************************************************************************
 852  60F4 ~            ; helper function to get string parameter
 853  60F4 ~            ; throws error if incorrect type
 854  60F4 ~            ; input HL=basic text
 855  60F4 ~            EVALTXTPARAM:
 856  60F4 ~            	LD	IX,FRMEVL
 857  60F4 ~            	CALL CALBAS		; Evaluate expression
 858  60F4 ~               LD A,(VALTYP)
 859  60F4 ~               CP 3               ; Text type?
 860  60F4 ~               JP NZ,TYPE_MISMATCH
 861  60F4 ~               PUSH HL
 862  60F4 ~               LD	IX,FRESTR         ; Free the temporary string
 863  60F4 ~               CALL CALBAS
 864  60F4 ~               POP HL
 865  60F4 ~               RET
 866  60F4 ~            ; *******************************************************************************************************
 867  60F4 ~
 868  60F4 ~             ENDIF
 869  60F4 ~
 870  60F4 ~            ; *******************************************************************************************************
 871  60F4 ~            ; helper function to get pointer to BASIC array data
 872  60F4 ~            ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
 873  60F4 ~            ; input B=dimensions (1 or 2)
 874  60F4 ~            ; input D=minimal first dimension
 875  60F4 ~            ; input E=minimal second dimension, if applicable
 876  60F4 ~            ; returns BC=pointer to first data element
 877  60F4 ~            ; throws BASIC error if invalid type
 878  60F4 ~            GET_BASIC_ARRAY_DATA_POINTER:
 879  60F4 ~            	PUSH DE
 880  60F4 ~            	PUSH BC
 881  60F4 ~            	PUSH AF
 882  60F4 ~               LD A,1
 883  60F4 ~               LD (SUBFLG),A ; search for arrays only
 884  60F4 ~            	LD IX, PTRGET
 885  60F4 ~            	CALL CALBAS
 886  60F4 ~               XOR A
 887  60F4 ~               LD (SUBFLG),A ; if not reset will cause syntax errors
 888  60F4 ~            	LD A,(VALTYP)
 889  60F4 ~            	POP DE ; required type
 890  60F4 ~            	CP D
 891  60F4 ~            	JP NZ,TYPE_MISMATCH
 892  60F4 ~            	LD A,(BC)
 893  60F4 ~            	INC BC
 894  60F4 ~            	POP DE ; required number of dimensions
 895  60F4 ~            	CP D
 896  60F4 ~            	JP NZ,TYPE_MISMATCH
 897  60F4 ~            	POP DE ; required minimal array dimensions
 898  60F4 ~            	DEC A
 899  60F4 ~            	JR Z,.ONE_DIMENSION
 900  60F4 ~            	; 2-dimension array
 901  60F4 ~            	LD A,(BC)
 902  60F4 ~            	.2 INC BC
 903  60F4 ~            	CP E
 904  60F4 ~            	JP C,SUBSCRIPT_OUT_OF_RANGE
 905  60F4 ~            .ONE_DIMENSION:
 906  60F4 ~            	LD A,(BC)
 907  60F4 ~            	.2 INC BC
 908  60F4 ~            	CP D
 909  60F4 ~            	JP C,SUBSCRIPT_OUT_OF_RANGE
 910  60F4 ~            	RET
 911  60F4 ~            ; *******************************************************************************************************
 912  60F4               ENDIF
 913  60F4
 914  60F4              ; *******************************************************************************************************
 915  60F4              ; function to handle CALL ARTINFO basic extension
 916  60F4              ; returns info about the extension
 917  60F4              ; _ARTINFO ( INT variable version,
 918  60F4              ;			    INT variable build_flags,
 919  60F4              ;			    INT variable free_memory_ptr )
 920  60F4              ; this function is always available and can be used to test if the extension is active
 921  60F4              ARTINFO:
 922  60F4              	; opening (
 923  60F4 CD CE 60     	CALL CHKCHAR
 924  60F7 28           	DB '('
 925  60F8              	; get address of version variable
 926  60F8 DD 21 A4 5E  	LD IX, PTRGET
 927  60FC CD 59 01     	CALL CALBAS
 928  60FF 3A 12 40     	LD A,(VERSION)
 929  6102 12              LD (DE),A
 930  6103 13              INC DE
 931  6104 3A 13 40        LD A,(VERSION+1)
 932  6107 12              LD (DE),A
 933  6108              	; comma
 934  6108 CD CE 60     	CALL CHKCHAR
 935  610B 2C           	DB ','
 936  610C              	; get address of build flags variable
 937  610C DD 21 A4 5E  	LD IX, PTRGET
 938  6110 CD 59 01     	CALL CALBAS
 939  6113 E5              PUSH HL
 940  6114 21 FF 3B        LD HL,SOUND_CMDS+2*RAM_CMDS+4*VRAM_CMDS+8*BLIT_CMDS+16*SPRITE_CMDS+32*GENCAL_CMD+64*TILE_CMDS+128*BOX_CMDS+256*ANIM_CMDS+512*COLL_CMD+1024*0+2048*1+4096*DECOMP_CMDS+8192*DLOAD_CMD
 941  6117 EB              EX DE,HL
 942  6118 73              LD (HL),E
 943  6119 23              INC HL
 944  611A 72              LD (HL),D
 945  611B E1              POP HL
 946  611C              	; comma
 947  611C CD CE 60     	CALL CHKCHAR
 948  611F 2C           	DB ','
 949  6120              	; get address of free memory variable
 950  6120 DD 21 A4 5E  	LD IX, PTRGET
 951  6124 CD 59 01     	CALL CALBAS
 952  6127 3A 10 40     	LD A,(FREEMEMPTR)
 953  612A 12              LD (DE),A
 954  612B 13              INC DE
 955  612C 3A 11 40        LD A,(FREEMEMPTR+1)
 956  612F 12              LD (DE),A
 957  6130              	; ending )
 958  6130 CD CE 60     	CALL CHKCHAR
 959  6133 29           	DB ')'
 960  6134 C9           	RET
 961  6135              ; *******************************************************************************************************
 962  6135
 963  6135              EXT_END:
 964  6135
# file closed: asm\main.asm
