# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		   EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000              COLL_CMD       EQU 1
  14  4000              DECOMP_CMDS    EQU 1
  15  4000              DLOAD_CMD      EQU 1
  16  4000
  17  4000              ; what to compile, provided in sjasmplus command line
  18  4000              ;BASIC_EXTENSION   EQU 1
  19  4000              ;DEFUSR_EXTENSION  EQU 0
  20  4000
  21  4000              CHPUT   EQU    #A2
  22  4000              CALBAS  EQU		#159
  23  4000              ERRHAND EQU    #406F
  24  4000              FRMEVL  EQU    #4C64
  25  4000              FRESTR  EQU		#67D0
  26  4000              ; FRMQNT = formula quantificator
  27  4000              ; input HL=pointer to current program expression
  28  4000              ; output HL=next address
  29  4000              ; output DE=integer datum
  30  4000              FRMQNT	EQU		#542F
  31  4000              ; GETBYT = get byte parameter
  32  4000              ; input HL=pointer to current program expression
  33  4000              ; output HL=next address
  34  4000              ; output A=E=byte read
  35  4000              GETBYT		EQU	#521C
  36  4000              CHRGTR  	   EQU   #4666
  37  4000              PTRGET		EQU 	#5EA4
  38  4000              SUBFLG		EQU	#F6A5
  39  4000              SYNCHR		EQU	#558C
  40  4000              VALTYP  	   EQU   #F663
  41  4000              DAC         EQU   #F7F6
  42  4000              USR     	   EQU   #F7F8
  43  4000              PROCNM		EQU	#FD89
  44  4000              BIOS_FILVRM EQU   #0056
  45  4000              CLIKSW		EQU	#F3DB
  46  4000
  47  4000              RAMAD0	   EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  48  4000              RAMAD1	   EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  49  4000              RAMAD2	   EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  50  4000              RAMAD3	   EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  51  4000              EXPTBL	   EQU   #FCC1
  52  4000              SCRMOD	   EQU   #FCAF ; current screen mode
  53  4000              REG1SAV     EQU   #F3E0 ; VDP(1)
  54  4000              JIFFY	      EQU   #FC9E
  55  4000              GRPPAT	   EQU   #F3CF ; SCREEN 2 sprite generator table address
  56  4000              GRPCGP		EQU	#F3CB ; SCREEN 2 pattern generator table address
  57  4000              GRPATR      EQU   #F3CD ; SCREEN 2 sprite attribute table address
  58  4000              T32PAT	   EQU   #F3C5 ; SCREEN 1 sprite generator table address
  59  4000              T32CGP      EQU   #F3C1 ; SCREEN 1 pattern ganarator table address
  60  4000              T32ATR      EQU   #F3C3 ; SCREEN 1 sprite attribute table address
  61  4000
  62  4000              FCB0        EQU   #F353 ; location of FCB 0
  63  4000              BDOS        EQU   #F37D ; disk functions
  64  4000              NULBUF      EQU   #F862 ; disk buffer of 256 bytes address
  65  4000
  66  4000              ; BASIC error codes
  67  4000              ;01 NEXT without FOR
  68  4000              ;02 Syntax error
  69  4000              ;03 RETURN without GOSUB
  70  4000              ;04 Out of DATA
  71  4000              ;05 Illegal function call
  72  4000              ;06 Overflow
  73  4000              ;07 Out of memory
  74  4000              ;08 Undefined line number
  75  4000              ;09 Subscript out of range
  76  4000              ;10 Redimensioned array
  77  4000              ;11 Division by zero
  78  4000              ;12 Illegal direct
  79  4000              ;13 Type mismatch
  80  4000              ;14 Out of string space
  81  4000              ;15 String too long
  82  4000              ;16 String formula too complex
  83  4000              ;17 Can't CONTINUE
  84  4000              ;18 Undefined user function
  85  4000              ;19 Device I/O error
  86  4000              ;20 Verify error
  87  4000              ;21 No RESUME
  88  4000              ;22 RESUME without error
  89  4000              ;23 Unprintable error
  90  4000              ;24 Missing operand
  91  4000              ;25 Line buffer overflow
  92  4000              ;50 FIELD overflow
  93  4000              ;51 Internal error
  94  4000              ;52 Bad file number
  95  4000              ;53 File not found
  96  4000              ;54 File already open
  97  4000              ;55 Input past end
  98  4000              ;56 Bad file name
  99  4000              ;57 Direct statement in file
 100  4000              ;58 Sequential I/O only
 101  4000              ;59 File not OPEN
 102  4000
 103  4000
 104  4000               ; simulate cartridge with BASIC extension
 105  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
 105  4004 B5 60 00 00
 105  4008 00 00 00 00
 105  400C 00 00 00 00
 106  4010
 107  4010              ; this location #4010 stores last location used by basic extension
 108  4010              ; free memory after that point
 109  4010              FREEMEMPTR:
 110  4010 5A 61         DW EXT_END
 111  4012
 112  4012              ; this location #4012 stores extension version in DAA format
 113  4012              ; first byte is major version and second minor
 114  4012              VERSION:
 115  4012 00 93         DB #00, #93
 116  4014
 117  4014              ; this location #4014 contains a jump to entry point for DEFUSR approach
 118  4014              ; if excluded it contains 3xRET so that sound player can be at aspecific spot
 119  4014               IF (1 == 1)
 120  4014 C3 43 5F        JP DEFUSR_ENTRY
 121  4017               ELSE
 122  4017 ~               .3 RET
 123  4017               ENDIF
 124  4017
 125  4017              ; binary included AKG player compiled at #4017
 126  4017               IF (SOUND_CMDS == 1)
 127  4017              	INCBIN "bin/AKG.bin"
 128  4CF3              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF3              MAIN_PLAYER_START EQU 04017H
   2+ 4CF3              PLY_AKG_START EQU 04017H
   3+ 4CF3              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 04020H
   4+ 4CF3              PLY_AKG_INITSOUNDEFFECTS EQU 04020H
   5+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04024H
   6+ 4CF3              PLY_AKG_PLAYSOUNDEFFECT EQU 04024H
   7+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04025H
   8+ 4CF3              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04025H
   9+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 0404CH
  10+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 0404CH
  11+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 0405AH
  12+ 4CF3              PLY_AKG_PSES_PLAY EQU 04093H
  13+ 4CF3              PLY_AKG_PSES_READFIRSTBYTE EQU 0409CH
  14+ 4CF3              PLY_AKG_PSES_S_ENDORLOOP EQU 040B4H
  15+ 4CF3              PLY_AKG_PSES_S_LOOP EQU 040BFH
  16+ 4CF3              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C5H
  17+ 4CF3              PLY_AKG_PSES_NOTREACHED EQU 040D8H
  18+ 4CF3              PLY_AKG_PSES_HARDWAREONLY EQU 040DCH
  19+ 4CF3              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E3H
  20+ 4CF3              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F5H
  21+ 4CF3              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FFH
  22+ 4CF3              PLY_AKG_PSES_H_AFTERRETRIG EQU 04109H
  23+ 4CF3              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411DH
  24+ 4CF3              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 04122H
  25+ 4CF3              PLY_AKG_PSES_READHARDWAREPERIOD EQU 0412AH
  26+ 4CF3              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04135H
  27+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 04141H
  28+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04143H
  29+ 4CF3              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04149H
  30+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414DH
  31+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414DH
  32+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414FH
  33+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414FH
  34+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414FH
  35+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 04150H
  36+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 04151H
  37+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04155H
  38+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04155H
  39+ 4CF3              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04155H
  40+ 4CF3              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415DH
  41+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04165H
  42+ 4CF3              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04165H
  43+ 4CF3              PLY_AKG_INIT EQU 04165H
  44+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04165H
  45+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04193H
  46+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A7H
  47+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B9H
  48+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D8H
  49+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E5H
  50+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL EQU 041EBH
  51+ 4CF3              PLY_AKG_INITTABLE0 EQU 041EEH
  52+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EEH
  53+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04208H
  54+ 4CF3              PLY_AKG_INITTABLE0_END EQU 04208H
  55+ 4CF3              PLY_AKG_INITTABLE1 EQU 04208H
  56+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04208H
  57+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 0420CH
  58+ 4CF3              PLY_AKG_INITTABLE1_END EQU 0420CH
  59+ 4CF3              PLY_AKG_INITTABLEORA EQU 0420CH
  60+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 0420CH
  61+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04224H
  62+ 4CF3              PLY_AKG_INITTABLEORA_END EQU 04224H
  63+ 4CF3              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04224H
  64+ 4CF3              PLY_AKG_STOP EQU 04224H
  65+ 4CF3              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04236H
  66+ 4CF3              PLY_AKG_PLAY EQU 04236H
  67+ 4CF3              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423EH
  68+ 4CF3              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04244H
  69+ 4CF3              PLY_AKG_READLINKER EQU 04249H
  70+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04249H
  71+ 4CF3              PLY_AKG_READLINKER_PTLINKER EQU 04249H
  72+ 4CF3              PLY_AKG_READLINKER_NOLOOP EQU 04254H
  73+ 4CF3              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428DH
  74+ 4CF3              PLY_AKG_READLINE EQU 04290H
  75+ 4CF3              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 04290H
  76+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04296H
  77+ 4CF3              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04296H
  78+ 4CF3              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A3H
  79+ 4CF3              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A7H
  80+ 4CF3              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042AAH
  81+ 4CF3              PLY_AKG_SPEEDTRACK_END EQU 042ADH
  82+ 4CF3              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042ADH
  83+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B3H
  84+ 4CF3              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B3H
  85+ 4CF3              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042C0H
  86+ 4CF3              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C4H
  87+ 4CF3              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C7H
  88+ 4CF3              PLY_AKG_EVENTTRACK_END EQU 042CAH
  89+ 4CF3              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042CAH
  90+ 4CF3              PLY_AKG_CHANNEL1_READTRACK EQU 042D6H
  91+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D6H
  92+ 4CF3              PLY_AKG_CHANNEL1_PTTRACK EQU 042D6H
  93+ 4CF3              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042F1H
  94+ 4CF3              PLY_AKG_CHANNEL1_WAIT EQU 042FCH
  95+ 4CF3              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04303H
  96+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04303H
  97+ 4CF3              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04303H
  98+ 4CF3              PLY_AKG_CHANNEL1_NOTE EQU 0430CH
  99+ 4CF3              PLY_AKG_BASENOTEINDEX EQU 0430CH
 100+ 4CF3              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430EH
 101+ 4CF3              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430EH
 102+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431EH
 103+ 4CF3              PLY_AKG_INSTRUMENTSTABLE EQU 0431EH
 104+ 4CF3              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 04330H
 105+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 04340H
 106+ 4CF3              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04368H
 107+ 4CF3              PLY_AKG_CHANNEL1_READCELLEND EQU 0436BH
 108+ 4CF3              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 0436BH
 109+ 4CF3              PLY_AKG_CHANNEL2_READTRACK EQU 04377H
 110+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04377H
 111+ 4CF3              PLY_AKG_CHANNEL2_PTTRACK EQU 04377H
 112+ 4CF3              PLY_AKG_CHANNEL2_SMALLWAIT EQU 04392H
 113+ 4CF3              PLY_AKG_CHANNEL2_WAIT EQU 0439DH
 114+ 4CF3              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A4H
 115+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A4H
 116+ 4CF3              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A4H
 117+ 4CF3              PLY_AKG_CHANNEL2_NOTE EQU 043ADH
 118+ 4CF3              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043B2H
 119+ 4CF3              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043B2H
 120+ 4CF3              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D4H
 121+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E4H
 122+ 4CF3              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 0440CH
 123+ 4CF3              PLY_AKG_CHANNEL2_READCELLEND EQU 0440FH
 124+ 4CF3              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440FH
 125+ 4CF3              PLY_AKG_CHANNEL3_READTRACK EQU 0441BH
 126+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 0441BH
 127+ 4CF3              PLY_AKG_CHANNEL3_PTTRACK EQU 0441BH
 128+ 4CF3              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04436H
 129+ 4CF3              PLY_AKG_CHANNEL3_WAIT EQU 04441H
 130+ 4CF3              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04448H
 131+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04448H
 132+ 4CF3              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04448H
 133+ 4CF3              PLY_AKG_CHANNEL3_NOTE EQU 04451H
 134+ 4CF3              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04456H
 135+ 4CF3              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04456H
 136+ 4CF3              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04478H
 137+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04488H
 138+ 4CF3              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044B0H
 139+ 4CF3              PLY_AKG_CHANNEL3_READCELLEND EQU 044B3H
 140+ 4CF3              PLY_AKG_CURRENTSPEED EQU 044B3H
 141+ 4CF3              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B5H
 142+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B8H
 143+ 4CF3              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B8H
 144+ 4CF3              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044BBH
 145+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BEH
 146+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BEH
 147+ 4CF3              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044CAH
 148+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044D1H
 149+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D4H
 150+ 4CF3              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044DAH
 151+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DDH
 152+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DDH
 153+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044EBH
 154+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044F0H
 155+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044FBH
 156+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FEH
 157+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FEH
 158+ 4CF3              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 04501H
 159+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04504H
 160+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04504H
 161+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450DH
 162+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04517H
 163+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 0451AH
 164+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 0451AH
 165+ 4CF3              PLY_AKG_CHANNEL1_PITCH EQU 0451AH
 166+ 4CF3              PLY_AKG_CHANNEL1_ISPITCH EQU 0451DH
 167+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 04522H
 168+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACK EQU 04522H
 169+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04526H
 170+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04528H
 171+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 0452AH
 172+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 04531H
 173+ 4CF3              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 04532H
 174+ 4CF3              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04535H
 175+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04535H
 176+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 04551H
 177+ 4CF3              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 04551H
 178+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455EH
 179+ 4CF3              PLY_AKG_CHANNEL1_GLIDEOVER EQU 04562H
 180+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 04572H
 181+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 04572H
 182+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04573H
 183+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04574H
 184+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04576H
 185+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04576H
 186+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04576H
 187+ 4CF3              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04577H
 188+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04578H
 189+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 0457AH
 190+ 4CF3              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 0457AH
 191+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 0457AH
 192+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 0457AH
 193+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 0457AH
 194+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457DH
 195+ 4CF3              PLY_AKG_CHANNEL1_PITCH_END EQU 0457FH
 196+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04587H
 197+ 4CF3              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04587H
 198+ 4CF3              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 0458AH
 199+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458DH
 200+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458DH
 201+ 4CF3              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04599H
 202+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 045A0H
 203+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A3H
 204+ 4CF3              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A9H
 205+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045ACH
 206+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045ACH
 207+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045BAH
 208+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BFH
 209+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045CAH
 210+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CDH
 211+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CDH
 212+ 4CF3              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045D0H
 213+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D3H
 214+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D3H
 215+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045DCH
 216+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E6H
 217+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E9H
 218+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E9H
 219+ 4CF3              PLY_AKG_CHANNEL2_PITCH EQU 045E9H
 220+ 4CF3              PLY_AKG_CHANNEL2_ISPITCH EQU 045ECH
 221+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045F1H
 222+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045F1H
 223+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F5H
 224+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F7H
 225+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F9H
 226+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 04600H
 227+ 4CF3              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 04601H
 228+ 4CF3              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04604H
 229+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04604H
 230+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 04620H
 231+ 4CF3              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 04620H
 232+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462DH
 233+ 4CF3              PLY_AKG_CHANNEL2_GLIDEOVER EQU 04631H
 234+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 04641H
 235+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 04641H
 236+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 04642H
 237+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04643H
 238+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04645H
 239+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04645H
 240+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04645H
 241+ 4CF3              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04646H
 242+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04647H
 243+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04649H
 244+ 4CF3              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04649H
 245+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04649H
 246+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04649H
 247+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04649H
 248+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_END EQU 0464CH
 249+ 4CF3              PLY_AKG_CHANNEL2_PITCH_END EQU 0464EH
 250+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04656H
 251+ 4CF3              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04656H
 252+ 4CF3              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04659H
 253+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 0465CH
 254+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 0465CH
 255+ 4CF3              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04668H
 256+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466FH
 257+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 04672H
 258+ 4CF3              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04678H
 259+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 0467BH
 260+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 0467BH
 261+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04689H
 262+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468EH
 263+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04699H
 264+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 0469CH
 265+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 0469CH
 266+ 4CF3              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469FH
 267+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 046A2H
 268+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE EQU 046A2H
 269+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046ABH
 270+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B5H
 271+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B8H
 272+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B8H
 273+ 4CF3              PLY_AKG_CHANNEL3_PITCH EQU 046B8H
 274+ 4CF3              PLY_AKG_CHANNEL3_ISPITCH EQU 046BBH
 275+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046C0H
 276+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046C0H
 277+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C4H
 278+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C6H
 279+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C8H
 280+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CFH
 281+ 4CF3              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046D0H
 282+ 4CF3              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D3H
 283+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D3H
 284+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046EFH
 285+ 4CF3              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046EFH
 286+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046FCH
 287+ 4CF3              PLY_AKG_CHANNEL3_GLIDEOVER EQU 04700H
 288+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 04710H
 289+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 04710H
 290+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 04711H
 291+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 04712H
 292+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04714H
 293+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04714H
 294+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04714H
 295+ 4CF3              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04715H
 296+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04716H
 297+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04718H
 298+ 4CF3              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04718H
 299+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04718H
 300+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04718H
 301+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04718H
 302+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_END EQU 0471BH
 303+ 4CF3              PLY_AKG_CHANNEL3_PITCH_END EQU 0471DH
 304+ 4CF3              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04729H
 305+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04729H
 306+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04729H
 307+ 4CF3              PLY_AKG_CHANNEL1_TRACKNOTE EQU 0472CH
 308+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472EH
 309+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04734H
 310+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04737H
 311+ 4CF3              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04737H
 312+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 0473AH
 313+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04743H
 314+ 4CF3              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 0474BH
 315+ 4CF3              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04758H
 316+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04758H
 317+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04758H
 318+ 4CF3              PLY_AKG_CHANNEL2_TRACKNOTE EQU 0475BH
 319+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475DH
 320+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04763H
 321+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04766H
 322+ 4CF3              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04766H
 323+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04769H
 324+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 04772H
 325+ 4CF3              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 0477AH
 326+ 4CF3              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04788H
 327+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04788H
 328+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04788H
 329+ 4CF3              PLY_AKG_CHANNEL3_TRACKNOTE EQU 0478BH
 330+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478DH
 331+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04793H
 332+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04796H
 333+ 4CF3              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04796H
 334+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04799H
 335+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 047A2H
 336+ 4CF3              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047AAH
 337+ 4CF3              PLY_AKG_SENDPSGREGISTERS EQU 047B9H
 338+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047C1H
 339+ 4CF3              PLY_AKG_PSGREG01_INSTR EQU 047C1H
 340+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047D1H
 341+ 4CF3              PLY_AKG_PSGREG23_INSTR EQU 047D1H
 342+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047E2H
 343+ 4CF3              PLY_AKG_PSGREG45_INSTR EQU 047E2H
 344+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F3H
 345+ 4CF3              PLY_AKG_PSGREG6_8_INSTR EQU 047F3H
 346+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04804H
 347+ 4CF3              PLY_AKG_PSGREG9_10_INSTR EQU 04804H
 348+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04815H
 349+ 4CF3              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04815H
 350+ 4CF3              PLY_AKG_PSGREG13_OLDVALUE EQU 0482AH
 351+ 4CF3              PLY_AKG_RETRIG EQU 0482CH
 352+ 4CF3              PLY_AKG_PSGREG13_INSTR EQU 0482EH
 353+ 4CF3              PLY_AKG_PSGREG13_END EQU 0483DH
 354+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483DH
 355+ 4CF3              PLY_AKG_SAVESP EQU 0483DH
 356+ 4CF3              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 04841H
 357+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTS EQU 04849H
 358+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04856H
 359+ 4CF3              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04856H
 360+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485EH
 361+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 0486BH
 362+ 4CF3              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 0486BH
 363+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTS EQU 04873H
 364+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487EH
 365+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS EQU 0487EH
 366+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488DH
 367+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488DH
 368+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04894H
 369+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A4H
 370+ 4CF3              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A4H
 371+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048ABH
 372+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048ABH
 373+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048AEH
 374+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B7H
 375+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B7H
 376+ 4CF3              PLY_AKG_READINSTRUMENTCELL EQU 048BDH
 377+ 4CF3              PLY_AKG_NOSOFTNOHARD EQU 048CAH
 378+ 4CF3              PLY_AKG_NSNH_NONOISE EQU 048DFH
 379+ 4CF3              PLY_AKG_SOFT EQU 048E2H
 380+ 4CF3              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E9H
 381+ 4CF3              PLY_AKG_S_NOTSIMPLE EQU 048F1H
 382+ 4CF3              PLY_AKG_S_AFTERSIMPLETEST EQU 048F4H
 383+ 4CF3              PLY_AKG_HARDTOSOFT EQU 04901H
 384+ 4CF3              PLY_AKG_HS_JUMPRATIO EQU 0490CH
 385+ 4CF3              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04939H
 386+ 4CF3              PLY_AKG_ENDWITHOUTLOOP EQU 0493BH
 387+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 0493BH
 388+ 4CF3              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 0493BH
 389+ 4CF3              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04943H
 390+ 4CF3              PLY_AKG_SH_JUMPRATIO EQU 04950H
 391+ 4CF3              PLY_AKG_SH_JUMPRATIOEND EQU 04971H
 392+ 4CF3              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 04980H
 393+ 4CF3              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04986H
 394+ 4CF3              PLY_AKG_H_OR_ENDWITHLOOP EQU 049A0H
 395+ 4CF3              PLY_AKG_H_RETRIGEND EQU 049B2H
 396+ 4CF3              PLY_AKG_H_AFTERRETRIG EQU 049B3H
 397+ 4CF3              PLY_AKG_ENDWITHLOOP EQU 049C5H
 398+ 4CF3              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049CCH
 399+ 4CF3              PLY_AKG_S_OR_H_NEXTBYTE EQU 049E2H
 400+ 4CF3              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049F0H
 401+ 4CF3              PLY_AKG_S_OR_H_AFTERPITCH EQU 04A00H
 402+ 4CF3              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0EH
 403+ 4CF3              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1DH
 404+ 4CF3              PLY_AKG_SHOHS_RETRIGEND EQU 04A2CH
 405+ 4CF3              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2DH
 406+ 4CF3              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3FH
 407+ 4CF3              PLY_AKG_EFFECTTABLE EQU 04A4DH
 408+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4DH
 409+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A71H
 410+ 4CF3              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A71H
 411+ 4CF3              PLY_AKG_EFFECT_RESET EQU 04A74H
 412+ 4CF3              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A76H
 413+ 4CF3              PLY_AKG_EFFECT_VOLUME EQU 04A91H
 414+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9DH
 415+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA3H
 416+ 4CF3              PLY_AKG_ARPEGGIOSTABLE EQU 04AA3H
 417+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04ACAH
 418+ 4CF3              PLY_AKG_EFFECT_PITCHTABLE EQU 04AD1H
 419+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD7H
 420+ 4CF3              PLY_AKG_PITCHESTABLE EQU 04AD7H
 421+ 4CF3              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFEH
 422+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B05H
 423+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B16H
 424+ 4CF3              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1DH
 425+ 4CF3              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2DH
 426+ 4CF3              PLY_AKG_EFFECT_PITCHUP EQU 04B42H
 427+ 4CF3              PLY_AKG_EFFECT_PITCHSTOP EQU 04B54H
 428+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B5BH
 429+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B85H
 430+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B85H
 431+ 4CF3              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9EH
 432+ 4CF3              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9EH
 433+ 4CF3              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BB0H
 434+ 4CF3              PLY_AKG_EFFECT_LEGATO EQU 04BC6H
 435+ 4CF3              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BDAH
 436+ 4CF3              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BE2H
 437+ 4CF3              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BEAH
 438+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BF2H
 439+ 4CF3              PLY_AKG_EVENT EQU 04BF2H
 440+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF3H
 441+ 4CF3              PLY_AKG_PERIODTABLE EQU 04BF3H
 442+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF3H
 443+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF3H
 444+ 4CF3              PLY_AKG_PERIODTABLE_END EQU 04CF3H
 445+ 4CF3              PLY_AKG_END EQU 04CF3H
 446+ 4CF3              MAIN_PLAYER_END EQU 04CF3H
 447+ 4CF3              TESTEREND EQU 04CF3H
 448+ 4CF3
# file closed: ./symbol/AKG.sym
 129  4CF3               ENDIF
 130  4CF3
 131  4CF3               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
   1+ 4CF3              ORIG.HTIMI:
   2+ 4CF3 00 00 00 00  	DB 0, 0, 0, 0, 0
   2+ 4CF7 00
   3+ 4CF8               EXPORT ORIG.HTIMI
   4+ 4CF8
   5+ 4CF8              ; *******************************************************************************************************
   6+ 4CF8              ; interrupt handler when page 0 enabled
   7+ 4CF8              ; we are here only if one of the extended basic commands have paged in page 0
   8+ 4CF8              ; which means we arrived from BASIC so page 2 is already good
   9+ 4CF8              VBLANK:
  10+ 4CF8              	EXPORT VBLANK
  11+ 4CF8
  12+ 4CF8 F5               PUSH AF
  13+ 4CF9              	; is VDP originator ?
  14+ 4CF9 DB 99        	IN	A, (099H)
  15+ 4CFB A7           	AND	A
  16+ 4CFC F2 2A 4D     	JP P, .EXIT
  17+ 4CFF
  18+ 4CFF               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  19+ 4CFF C5               PUSH BC
  20+ 4D00 D5               PUSH DE
  21+ 4D01 E5               PUSH HL
  22+ 4D02 08               EX AF, AF'
  23+ 4D03 D9               EXX
  24+ 4D04 F5               PUSH AF
  25+ 4D05 C5               PUSH BC
  26+ 4D06 D5               PUSH DE
  27+ 4D07 E5               PUSH HL
  28+ 4D08 DD E5            PUSH IX
  29+ 4D0A FD E5            PUSH IY
  30+ 4D0C
  31+ 4D0C               IF (SPRITE_CMDS == 1)
  32+ 4D0C CD 64 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  33+ 4D0F               ENDIF
  34+ 4D0F
  35+ 4D0F               IF (SOUND_CMDS == 1)
  36+ 4D0F 3A B5 55     	LD A, (SOUND_ENABLED)
  37+ 4D12 B7           	OR A
  38+ 4D13 C4 36 42     	CALL NZ,PLY_AKG_PLAY
  39+ 4D16               ENDIF
  40+ 4D16
  41+ 4D16                  ; increase JIFFY
  42+ 4D16 2A 9E FC         LD HL,(JIFFY)
  43+ 4D19 23               INC HL
  44+ 4D1A 22 9E FC         LD (JIFFY),HL
  45+ 4D1D
  46+ 4D1D FD E1            POP IY
  47+ 4D1F DD E1            POP IX
  48+ 4D21 E1               POP HL
  49+ 4D22 D1               POP DE
  50+ 4D23 C1               POP BC
  51+ 4D24 F1               POP AF
  52+ 4D25 08               EX AF, AF'
  53+ 4D26 D9               EXX
  54+ 4D27 E1               POP HL
  55+ 4D28 D1               POP DE
  56+ 4D29 C1               POP BC
  57+ 4D2A               ENDIF
  58+ 4D2A
  59+ 4D2A              .EXIT:
  60+ 4D2A F1           	POP AF
  61+ 4D2B FB           	EI
  62+ 4D2C ED 4D        	RETI
  63+ 4D2E              ; *******************************************************************************************************
  64+ 4D2E
  65+ 4D2E              ; *******************************************************************************************************
  66+ 4D2E              ; H.TIMI function
  67+ 4D2E              ; we can end up here from anywhere so page in both page 0 and 2
  68+ 4D2E              MBGE_HTIMI:
  69+ 4D2E               EXPORT MBGE_HTIMI
  70+ 4D2E
  71+ 4D2E               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  72+ 4D2E
  73+ 4D2E F5           	PUSH AF
  74+ 4D2F
  75+ 4D2F              	; enable page 2
  76+ 4D2F 3E 02            LD A, 2
  77+ 4D31 CD E4 5F         CALL GET_PAGE_INFO
  78+ 4D34 C5               PUSH BC
  79+ 4D35 D5               PUSH DE
  80+ 4D36 3A 43 F3         LD A, (RAMAD2)
  81+ 4D39 26 80            LD H, 080H
  82+ 4D3B CD 2B 60         CALL LOCAL_ENASLT
  83+ 4D3E              	; enable page 0
  84+ 4D3E AF               XOR A
  85+ 4D3F CD E4 5F         CALL GET_PAGE_INFO
  86+ 4D42 C5               PUSH BC
  87+ 4D43 D5               PUSH DE
  88+ 4D44 3A 41 F3         LD A, (RAMAD0)
  89+ 4D47 26 00            LD H, 0
  90+ 4D49 CD 2B 60         CALL LOCAL_ENASLT
  91+ 4D4C
  92+ 4D4C               IF (SPRITE_CMDS == 1)
  93+ 4D4C CD 64 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  94+ 4D4F               ENDIF
  95+ 4D4F
  96+ 4D4F               IF (SOUND_CMDS == 1)
  97+ 4D4F 3A B5 55     	LD A, (SOUND_ENABLED)
  98+ 4D52 B7           	OR A
  99+ 4D53 C4 36 42     	CALL NZ,PLY_AKG_PLAY
 100+ 4D56               ENDIF
 101+ 4D56
 102+ 4D56              	; restore page 0
 103+ 4D56 D1               POP DE
 104+ 4D57 C1               POP BC
 105+ 4D58 CD 1B 60         CALL RESTORE_PAGE_INFO
 106+ 4D5B              	; restore page 2
 107+ 4D5B D1               POP DE
 108+ 4D5C C1               POP BC
 109+ 4D5D CD 1B 60         CALL RESTORE_PAGE_INFO
 110+ 4D60
 111+ 4D60 F1           	POP AF
 112+ 4D61               ENDIF
 113+ 4D61 C3 F3 4C     	JP ORIG.HTIMI
 114+ 4D64              ; *******************************************************************************************************
 115+ 4D64
 116+ 4D64              ; *******************************************************************************************************
 117+ 4D64              ; function checks if the sprite system is initialized and what screen mode we are running
 118+ 4D64              ; also checks if some VRAM modifying command is running
 119+ 4D64              ; when that checks out calls sprite updates and animation processing
 120+ 4D64              ; if in an unsupported mode disables sprite handling
 121+ 4D64              PROCESS_SPRITES_AND_ANIMATIONS:
 122+ 4D64              	; check if initialized
 123+ 4D64 3A 86 4D     	LD A, (SPRATR_INIT_STATUS)
 124+ 4D67 B7           	OR A
 125+ 4D68 C8           	RET Z
 126+ 4D69              	; check screen mode
 127+ 4D69 3A AF FC     	LD A, (SCRMOD)
 128+ 4D6C 3D           	DEC A
 129+ 4D6D 28 08        	JR Z, .L0 ; screen 1
 130+ 4D6F 3D           	DEC A
 131+ 4D70 28 05            JR Z, .L0 ; screen 2
 132+ 4D72              	; unsupported screen mode, disable
 133+ 4D72 AF               XOR A
 134+ 4D73 32 86 4D         LD (SPRATR_INIT_STATUS),A
 135+ 4D76 C9               RET
 136+ 4D77              .L0:
 137+ 4D77                  ; check if anyone else is working with VRAM
 138+ 4D77 3A 81 5F         LD A,(VRAM_UPDATE_IN_PROGRESS)
 139+ 4D7A B7               OR A
 140+ 4D7B C0               RET NZ
 141+ 4D7C
 142+ 4D7C CD 9C 4D         CALL SPRATR_UPDATE
 143+ 4D7F
 144+ 4D7F               IF (ANIM_CMDS == 1)
 145+ 4D7F CD 0E 53         CALL PROCESS_ANIMATIONS
 146+ 4D82 CD 6F 54         CALL PROCESS_AUTOSGAMS
 147+ 4D85               ENDIF
 148+ 4D85 C9               RET
 149+ 4D86              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
 132  4D86
 133  4D86               IF (SPRITE_CMDS == 1)
 134  4D86               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4D86              ; commands and variables related to sprites
   2+ 4D86
   3+ 4D86              SPRATR_INIT_STATUS:
   4+ 4D86 00            DB 0
   5+ 4D87              SPRATR_UPDATE_FLAG:
   6+ 4D87 00 00         DW 0
   7+ 4D89              SPRATR_DATA:
   8+ 4D89 00 00         DW 0
   9+ 4D8B              SPRFLICKER_ENABLED:
  10+ 4D8B 00            DB 0
  11+ 4D8C              ; to support sprite flicker
  12+ 4D8C              FLICKER:
  13+ 4D8C 00            DB 0
  14+ 4D8D              NUM_SPRITES_HANDLED:
  15+ 4D8D 20            DB 32
  16+ 4D8E
  17+ 4D8E              ; to temporarily store stack pointer
  18+ 4D8E              TMPSP:
  19+ 4D8E 00 00         DW 0
  20+ 4D90
  21+ 4D90              ; *******************************************************************************************************
  22+ 4D90              ; helper function gets pointer to n-th entry in sprite attributes
  23+ 4D90              ; changes HL,DE
  24+ 4D90              GETnthSPRATTR:
  25+ 4D90 26 00            LD H,0
  26+ 4D92 6F               LD L,A
  27+ 4D93 CD E0 5F         CALL HLx8
  28+ 4D96 ED 5B 89 4D      LD DE,(SPRATR_DATA)
  29+ 4D9A 19               ADD HL,DE
  30+ 4D9B C9               RET
  31+ 4D9C              ; *******************************************************************************************************
  32+ 4D9C
  33+ 4D9C              ; *******************************************************************************************************
  34+ 4D9C              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  35+ 4D9C              ; struct {
  36+ 4D9C              ; DW y
  37+ 4D9C              ; DW x
  38+ 4D9C              ; DW pattern (0-63)
  39+ 4D9C              ; DW color
  40+ 4D9C              ; } [32]
  41+ 4D9C              ; will hide sprites whose location is outside of visible area
  42+ 4D9C              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  43+ 4D9C              ; modifies AF, AF', BC, DE, HL, IX
  44+ 4D9C              SPRATR_UPDATE:
  45+ 4D9C              	; check if update requested
  46+ 4D9C 2A 87 4D     	LD HL, (SPRATR_UPDATE_FLAG)
  47+ 4D9F 7E           	LD A, (HL)
  48+ 4DA0 B7           	OR A
  49+ 4DA1 C8           	RET Z
  50+ 4DA2
  51+ 4DA2 DD 21 8D 4D  	LD IX,NUM_SPRITES_HANDLED
  52+ 4DA6 DD 46 00     	LD B, (IX) ; sprite number
  53+ 4DA9 0E 98        	LD C, #98 ; register for vdp data output
  54+ 4DAB              	; set VDP address
  55+ 4DAB 3A AF FC         LD A,(SCRMOD)
  56+ 4DAE 3D               DEC A
  57+ 4DAF 20 05            JR NZ,.L4
  58+ 4DB1 2A C3 F3         LD HL, (T32ATR)
  59+ 4DB4 18 03            JR .L5
  60+ 4DB6              .L4:
  61+ 4DB6 2A CD F3         LD HL, (GRPATR)
  62+ 4DB9              .L5:
  63+ 4DB9 3A 8B 4D     	LD A, (SPRFLICKER_ENABLED)
  64+ 4DBC B7           	OR A
  65+ 4DBD 28 03        	JR Z, .L3
  66+ 4DBF 3A 8C 4D     	LD A, (FLICKER)
  67+ 4DC2              .L3:
  68+ 4DC2 5F           	LD E, A
  69+ 4DC3 08           	EX AF, AF'
  70+ 4DC4 7B           	LD A, E
  71+ 4DC5 87           	ADD A, A
  72+ 4DC6 87           	ADD A, A
  73+ 4DC7 16 00        	LD D, 0
  74+ 4DC9 5F           	LD E, A
  75+ 4DCA 19           	ADD HL, DE
  76+ 4DCB CD C1 5F     	CALL SETWRT_LOCAL_WRITE
  77+ 4DCE ED 73 8E 4D  	LD (TMPSP), SP
  78+ 4DD2 ED 7B 89 4D  	LD SP, (SPRATR_DATA)
  79+ 4DD6
  80+ 4DD6              .LOOP:
  81+ 4DD6 E1           	POP HL
  82+ 4DD7 24           	INC H
  83+ 4DD8 28 0D        	JR Z, .L1 ; negative number between -256 and -1
  84+ 4DDA 25           	DEC H
  85+ 4DDB 20 15        	JR NZ, .OUT3 ; sprite vertically can't be visible
  86+ 4DDD 7D           	LD A, L
  87+ 4DDE FE C0        	CP 192
  88+ 4DE0 30 10        	JR NC, .OUT3
  89+ 4DE2 3D           	DEC A ; due to VDP rule that top of screen is -1
  90+ 4DE3 57           	LD D, A
  91+ 4DE4 C3 0B 4E     	JP .X
  92+ 4DE7              .L1:
  93+ 4DE7 7D           	LD A, L
  94+ 4DE8 C6 10        	ADD 16
  95+ 4DEA FA F2 4D     	JP M, .OUT3 ; below -16
  96+ 4DED 2D           	DEC L ; due to VDP rule that top of screen is -1
  97+ 4DEE 55           	LD D, L
  98+ 4DEF C3 0B 4E     	JP .X
  99+ 4DF2              .OUT3:
 100+ 4DF2 E1           	POP HL ; skip x value
 101+ 4DF3              .OUT2:
 102+ 4DF3 E1           	POP HL ; skip pattern
 103+ 4DF4 E1           	POP HL ; skip color
 104+ 4DF5 3E D1        	LD A, #D1
 105+ 4DF7 ED 79        	OUT (C), A ; sprite hidden
 106+ 4DF9 00          > NOP
 106+ 4DFA 00          > NOP
 106+ 4DFB 00          > NOP
 107+ 4DFC ED 79        	OUT (C), A ; value unimportant
 108+ 4DFE 00          > NOP
 108+ 4DFF 00          > NOP
 108+ 4E00 00          > NOP
 109+ 4E01 ED 79        	OUT (C), A ; value unimportant
 110+ 4E03 00          > NOP
 110+ 4E04 00          > NOP
 110+ 4E05 00          > NOP
 111+ 4E06 ED 79        	OUT (C), A ; value unimportant
 112+ 4E08 C3 36 4E     	JP .NEXT
 113+ 4E0B              .X:
 114+ 4E0B E1           	POP HL
 115+ 4E0C 24           	INC H
 116+ 4E0D 28 08        	JR Z, .L2
 117+ 4E0F 25           	DEC H
 118+ 4E10 20 E1        	JR NZ, .OUT2
 119+ 4E12 1E 00        	LD E, 0 ; EC bit
 120+ 4E14 C3 20 4E     	JP .XY
 121+ 4E17              .L2:
 122+ 4E17 7D           	LD A, L
 123+ 4E18 C6 20        	ADD 32
 124+ 4E1A FA F3 4D     	JP M, .OUT2
 125+ 4E1D 6F           	LD L, A
 126+ 4E1E 1E 80        	LD E, #80
 127+ 4E20              .XY:
 128+ 4E20 ED 51        	OUT (C), D
 129+ 4E22 3A E0 F3     	LD A, (REG1SAV)
 130+ 4E25 E6 02        	AND 2
 131+ 4E27 ED 69        	OUT (C), L
 132+ 4E29 E1           	POP HL ; pattern
 133+ 4E2A 7D           	LD A, L
 134+ 4E2B 28 02        	JR Z, .SMALLSPRITES
 135+ 4E2D 87           	ADD A, A
 136+ 4E2E 87           	ADD A, A ; needs to go at 4x
 137+ 4E2F              .SMALLSPRITES:
 138+ 4E2F D3 98        	OUT (#98), A
 139+ 4E31 E1           	POP HL ; color
 140+ 4E32 7D           	LD A, L
 141+ 4E33 B3           	OR E
 142+ 4E34 D3 98        	OUT (#98), A
 143+ 4E36              .NEXT:
 144+ 4E36 08           	EX AF, AF'
 145+ 4E37 3C           	INC A ; increase current sprite
 146+ 4E38 DD BE 00     	CP (IX) ; compare to maximum handled
 147+ 4E3B C2 5B 4E     	JP NZ, .NEXT2 ; continue if not over
 148+ 4E3E AF           	XOR A ; back to zero
 149+ 4E3F 08           	EX AF, AF'
 150+ 4E40 3A AF FC         LD A,(SCRMOD)
 151+ 4E43 3D               DEC A
 152+ 4E44 20 05            JR NZ,.L6
 153+ 4E46 2A C3 F3         LD HL, (T32ATR)
 154+ 4E49 18 03            JR .L7
 155+ 4E4B              .L6:
 156+ 4E4B 2A CD F3         LD HL, (GRPATR)
 157+ 4E4E              .L7:
 158+ 4E4E              	; CALL SETWRT_LOCAL not allowed as SP modified
 159+ 4E4E 7D           	LD	A, L
 160+ 4E4F D3 99        	OUT	(099H), A
 161+ 4E51 7C           	LD	A, H
 162+ 4E52 E6 3F        	AND	03FH
 163+ 4E54 F6 40        	OR	040H
 164+ 4E56 D3 99        	OUT	(099H), A
 165+ 4E58 C3 5C 4E     	JP .NEXT3
 166+ 4E5B              .NEXT2:
 167+ 4E5B 08           	EX AF, AF'
 168+ 4E5C              .NEXT3:
 169+ 4E5C 05           	DEC B
 170+ 4E5D C2 D6 4D     	JP NZ, .LOOP
 171+ 4E60 08           	EX AF, AF'
 172+ 4E61 3C           	INC A ; increase flicker to start at the next one on next vblank
 173+ 4E62 DD BE 00     	CP (IX)
 174+ 4E65 20 01        	JR NZ,.L8
 175+ 4E67 AF           	XOR A
 176+ 4E68              .L8:
 177+ 4E68 32 8C 4D     	LD (FLICKER), A
 178+ 4E6B
 179+ 4E6B ED 7B 8E 4D  	LD SP, (TMPSP)
 180+ 4E6F 2A 87 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 181+ 4E72 36 00        	LD (HL), 0 ; zero out update flag
 182+ 4E74 C9           	RET
 183+ 4E75              ; *******************************************************************************************************
 184+ 4E75
 185+ 4E75               IF (0 == 1)
 186+ 4E75 ~            ; *******************************************************************************************************
 187+ 4E75 ~            ; function to handle CALL SPRENABLE basic extension
 188+ 4E75 ~            ; initializes sprites handler
 189+ 4E75 ~            ; _SPRENABLE ( INT[3][31] variable sprites_attributes,
 190+ 4E75 ~            ;			   INT variable update_variable,
 191+ 4E75 ~            ;			   BYTE sprite_flicker_enabled,
 192+ 4E75 ~            ;			   BYTE num_sprites_handled )
 193+ 4E75 ~            ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA, SPRFLICKER_ENABLED and NUM_SPRITES_HANDLED
 194+ 4E75 ~            SPRENABLE:
 195+ 4E75 ~            	; opening (
 196+ 4E75 ~            	CALL CHKCHAR
 197+ 4E75 ~            	DB '('
 198+ 4E75 ~            	; get address of sprite attribute table DIM SA%(3,31)
 199+ 4E75 ~            	LD A,2
 200+ 4E75 ~            	LD B,2
 201+ 4E75 ~            	LD DE,#0420
 202+ 4E75 ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
 203+ 4E75 ~            	LD (SPRATR_DATA), BC
 204+ 4E75 ~            	; comma
 205+ 4E75 ~            	CALL CHKCHAR
 206+ 4E75 ~            	DB ','
 207+ 4E75 ~            	; get address of sprite update flag
 208+ 4E75 ~            	LD IX, PTRGET
 209+ 4E75 ~            	CALL CALBAS
 210+ 4E75 ~            	LD (SPRATR_UPDATE_FLAG), DE
 211+ 4E75 ~            	; comma
 212+ 4E75 ~            	CALL CHKCHAR
 213+ 4E75 ~            	DB ','
 214+ 4E75 ~            	; get flicker enabled flag
 215+ 4E75 ~            	LD IX, GETBYT
 216+ 4E75 ~            	CALL CALBAS
 217+ 4E75 ~            	LD (SPRFLICKER_ENABLED), A
 218+ 4E75 ~            	; comma
 219+ 4E75 ~            	CALL CHKCHAR
 220+ 4E75 ~            	DB ','
 221+ 4E75 ~            	; get number of handled sprites
 222+ 4E75 ~            	LD IX, GETBYT
 223+ 4E75 ~            	CALL CALBAS
 224+ 4E75 ~            	LD (NUM_SPRITES_HANDLED),A
 225+ 4E75 ~            	; ending )
 226+ 4E75 ~            	CALL CHKCHAR
 227+ 4E75 ~            	DB ')'
 228+ 4E75 ~            .L0:
 229+ 4E75 ~            	LD A, 1
 230+ 4E75 ~            	LD (SPRATR_INIT_STATUS), A
 231+ 4E75 ~            	RET
 232+ 4E75 ~            ; *******************************************************************************************************
 233+ 4E75               ENDIF
 234+ 4E75
 235+ 4E75               IF (1 == 1)
 236+ 4E75              ; same as SPRENABLE but for DEFUSR approach
 237+ 4E75              ; input IX=pointer to input array, real data from +2
 238+ 4E75              ; +2 = pointer to sprite attributes array data
 239+ 4E75              ; +4 = pointer to sprite update variable
 240+ 4E75              ; +6 = flicker flag
 241+ 4E75              ; +8 = number of sprites to handle
 242+ 4E75              SPRENABLE_DEFUSR:
 243+ 4E75 DD 6E 02     	LD L,(IX+2)
 244+ 4E78 DD 66 03     	LD H,(IX+3)
 245+ 4E7B 22 89 4D     	LD (SPRATR_DATA),HL
 246+ 4E7E DD 6E 04     	LD L,(IX+4)
 247+ 4E81 DD 66 05     	LD H,(IX+5)
 248+ 4E84 22 87 4D     	LD (SPRATR_UPDATE_FLAG),HL
 249+ 4E87 DD 7E 06     	LD A,(IX+6)
 250+ 4E8A 32 8B 4D     	LD (SPRFLICKER_ENABLED),A
 251+ 4E8D DD 7E 08     	LD A,(IX+8)
 252+ 4E90 32 8D 4D     	LD (NUM_SPRITES_HANDLED),A
 253+ 4E93 3E 01        	LD A, 1
 254+ 4E95 32 86 4D     	LD (SPRATR_INIT_STATUS), A
 255+ 4E98 AF           	XOR A ; success
 256+ 4E99 C9           	RET
 257+ 4E9A               ENDIF
 258+ 4E9A
 259+ 4E9A               IF (1 + 0 > 0)
 260+ 4E9A              ; *******************************************************************************************************
 261+ 4E9A              ; function to handle CALL SPRDISABLE basic extension
 262+ 4E9A              ; disables sprites handling
 263+ 4E9A              ; _SPRDISABLE
 264+ 4E9A              ; resets variable SPRATR_INIT_STATUS
 265+ 4E9A              SPRDISABLE:
 266+ 4E9A              SPRDISABLE_DEFUSR:
 267+ 4E9A AF           	XOR A
 268+ 4E9B 32 86 4D     	LD (SPRATR_INIT_STATUS), A
 269+ 4E9E C9           	RET
 270+ 4E9F              ; *******************************************************************************************************
 271+ 4E9F               ENDIF
 272+ 4E9F
 273+ 4E9F              ; *******************************************************************************************************
 274+ 4E9F              ; function to handle CALL SPRSET basic extension
 275+ 4E9F              ; sets position, and optionally pattern and color of sprite
 276+ 4E9F              ; _SPRSET ( BYTE sprite_num , valid 0-31
 277+ 4E9F              ;			INT x,
 278+ 4E9F              ;			INT y,
 279+ 4E9F              ;			INT pattern, valid 0-63, otherwise ignored
 280+ 4E9F              ;			INT color, valid 0-15, otherwise ignored
 281+ 4E9F              ;SPRSET:
 282+ 4E9F              ;	LD A, (SPRATR_INIT_STATUS)
 283+ 4E9F              ;	OR A
 284+ 4E9F              ;	JR NZ, .L1
 285+ 4E9F              ;	LD E, 5 ; illegal function call
 286+ 4E9F              ;	JP THROW_ERROR
 287+ 4E9F              ;.L1:
 288+ 4E9F              ;	; opening (
 289+ 4E9F              ;	CALL CHKCHAR
 290+ 4E9F              ;	DB '('
 291+ 4E9F              ;	; get sprite number
 292+ 4E9F              ;	LD IX, GETBYT
 293+ 4E9F              ;	CALL CALBAS
 294+ 4E9F              ;	PUSH AF
 295+ 4E9F              ;	; comma
 296+ 4E9F              ;	CALL CHKCHAR
 297+ 4E9F              ;	DB ','
 298+ 4E9F              ;	; get x
 299+ 4E9F              ;	LD IX, FRMQNT
 300+ 4E9F              ;	CALL CALBAS
 301+ 4E9F              ;	PUSH DE
 302+ 4E9F              ;	; comma
 303+ 4E9F              ;	CALL CHKCHAR
 304+ 4E9F              ;	DB ','
 305+ 4E9F              ;	; get y
 306+ 4E9F              ;	LD IX, FRMQNT
 307+ 4E9F              ;	CALL CALBAS
 308+ 4E9F              ;	PUSH DE
 309+ 4E9F              ;	; comma
 310+ 4E9F              ;	CALL CHKCHAR
 311+ 4E9F              ;	DB ','
 312+ 4E9F              ;	; get pattern
 313+ 4E9F              ;	LD IX, FRMQNT
 314+ 4E9F              ;	CALL CALBAS
 315+ 4E9F              ;	PUSH DE
 316+ 4E9F              ;	; comma
 317+ 4E9F              ;	CALL CHKCHAR
 318+ 4E9F              ;	DB ','
 319+ 4E9F              ;	; get color
 320+ 4E9F              ;	LD IX, FRMQNT
 321+ 4E9F              ;	CALL CALBAS
 322+ 4E9F              ;	PUSH DE
 323+ 4E9F              ;	; ending )
 324+ 4E9F              ;	CALL CHKCHAR
 325+ 4E9F              ;	DB ')'
 326+ 4E9F              ;
 327+ 4E9F              ;   ; save position in BASIC text
 328+ 4E9F              ;	PUSH HL
 329+ 4E9F              ;	POP IX
 330+ 4E9F              ;
 331+ 4E9F              ;	POP BC ; color
 332+ 4E9F              ;	POP DE ; pattern
 333+ 4E9F              ;	EXX
 334+ 4E9F              ;	POP BC ; y
 335+ 4E9F              ;	POP DE ; x
 336+ 4E9F              ;	POP AF ; sprite number
 337+ 4E9F              ;	CP 32
 338+ 4E9F              ;	JR C, .L2
 339+ 4E9F              ;	LD E, 5 ; illegal function call
 340+ 4E9F              ;	JP THROW_ERROR
 341+ 4E9F              ;.L2:
 342+ 4E9F              ;	; find location in sprite attributes table
 343+ 4E9F              ;	PUSH DE
 344+ 4E9F              ;	CALL GETnthSPRATTR
 345+ 4E9F              ;	POP DE
 346+ 4E9F              ;	DI
 347+ 4E9F              ;	; set y
 348+ 4E9F              ;	LD (HL), C
 349+ 4E9F              ;	INC HL
 350+ 4E9F              ;	LD (HL), B
 351+ 4E9F              ;	INC HL
 352+ 4E9F              ;	; set x
 353+ 4E9F              ;	LD (HL), E
 354+ 4E9F              ;	INC HL
 355+ 4E9F              ;	LD (HL), D
 356+ 4E9F              ;	INC HL
 357+ 4E9F              ;	PUSH HL
 358+ 4E9F              ;	EXX
 359+ 4E9F              ;	POP HL
 360+ 4E9F              ;	; check if 0<=pattern<64
 361+ 4E9F              ;	LD A, D
 362+ 4E9F              ;	OR A
 363+ 4E9F              ;	JR NZ, .L3
 364+ 4E9F              ;	LD A, E
 365+ 4E9F              ;	CP 64
 366+ 4E9F              ;	JR NC, .L3
 367+ 4E9F              ;	; set pattern
 368+ 4E9F              ;	;ADD A, A
 369+ 4E9F              ;	;ADD A, A
 370+ 4E9F              ;	;ADD A, A
 371+ 4E9F              ;	LD (HL), A
 372+ 4E9F              ;	INC HL
 373+ 4E9F              ;	LD (HL), D
 374+ 4E9F              ;	INC HL
 375+ 4E9F              ;	JR .L4
 376+ 4E9F              ;.L3:
 377+ 4E9F              ;	; skip pattern
 378+ 4E9F              ;	.2 INC HL
 379+ 4E9F              ;.L4:
 380+ 4E9F              ;	; check if 0<=color<16
 381+ 4E9F              ;	LD A, B
 382+ 4E9F              ;	OR A
 383+ 4E9F              ;	JR NZ, .L5
 384+ 4E9F              ;	LD A, C
 385+ 4E9F              ;	CP 16
 386+ 4E9F              ;	JR NC, .L5
 387+ 4E9F              ;	; set color
 388+ 4E9F              ;	LD (HL), C
 389+ 4E9F              ;	INC HL
 390+ 4E9F              ;	LD (HL), B
 391+ 4E9F              ;
 392+ 4E9F              ;.L5:
 393+ 4E9F              ;	EI
 394+ 4E9F              ;	PUSH IX
 395+ 4E9F              ;	POP HL
 396+ 4E9F              ;	RET
 397+ 4E9F              ; *******************************************************************************************************
 398+ 4E9F
 399+ 4E9F              ; *******************************************************************************************************
 400+ 4E9F              ; function sets sprite location based on initial coordinates and offset provided
 401+ 4E9F              ; input A=sprite number in SPRATR_DATA , 0-31
 402+ 4E9F              ; input DE=initial x
 403+ 4E9F              ; input BC=initial y
 404+ 4E9F              ; input IY=location where delta y,x are located
 405+ 4E9F              ; modifies AF, HL, IX
 406+ 4E9F              SPRSET_DELTA_POS:
 407+ 4E9F D5           	PUSH DE
 408+ 4EA0 CD 90 4D     	CALL GETnthSPRATTR
 409+ 4EA3 E5           	PUSH HL
 410+ 4EA4 DD E1        	POP IX
 411+ 4EA6 D1           	POP DE
 412+ 4EA7              	; IX=sprite's y location
 413+ 4EA7 FD 6E 00     	LD L, (IY)
 414+ 4EAA FD 66 01     	LD H, (IY+1)
 415+ 4EAD 09           	ADD HL, BC
 416+ 4EAE DD 75 00     	LD (IX), L
 417+ 4EB1 DD 74 01     	LD (IX+1), H
 418+ 4EB4 FD 6E 02     	LD L, (IY+2)
 419+ 4EB7 FD 66 03     	LD H, (IY+3)
 420+ 4EBA 19           	ADD HL, DE
 421+ 4EBB DD 75 02     	LD (IX+2), L
 422+ 4EBE DD 74 03     	LD (IX+3), H
 423+ 4EC1 C9           	RET
 424+ 4EC2              ; *******************************************************************************************************
 425+ 4EC2
 426+ 4EC2              ; *******************************************************************************************************
 427+ 4EC2              ; helper function to set new locations for a set of sprites
 428+ 4EC2              ; input B=number of sprites
 429+ 4EC2              ; HL=pointer to list of sprites and offsets
 430+ 4EC2              SPR_UPDATE_LOC:
 431+ 4EC2 3E 01        	LD A,1
 432+ 4EC4 32 81 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 433+ 4EC7 7E           	LD A, (HL)
 434+ 4EC8 23           	INC HL
 435+ 4EC9 23           	INC HL
 436+ 4ECA E5           	PUSH HL
 437+ 4ECB FD E1        	POP IY
 438+ 4ECD D9           	EXX
 439+ 4ECE CD 9F 4E     	CALL SPRSET_DELTA_POS
 440+ 4ED1 D9           	EXX
 441+ 4ED2 23          > INC HL
 441+ 4ED3 23          > INC HL
 441+ 4ED4 23          > INC HL
 441+ 4ED5 23          > INC HL
 442+ 4ED6 10 EA        	DJNZ SPR_UPDATE_LOC
 443+ 4ED8 AF           	XOR A
 444+ 4ED9 32 81 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 445+ 4EDC C9           	RET
 446+ 4EDD              ; *******************************************************************************************************
 447+ 4EDD
 448+ 4EDD               IF (0 == 1)
 449+ 4EDD ~            ; *******************************************************************************************************
 450+ 4EDD ~            ; function to handle CALL SPRGRPMOV basic extension
 451+ 4EDD ~            ; sets position of a group of sprites described with
 452+ 4EDD ~            ; { int sprite_num, int delta_y, int delta_x } [count]
 453+ 4EDD ~            ; _SPRGRPMOV ( INT x,
 454+ 4EDD ~            ;			   INT y,
 455+ 4EDD ~            ;			   BYTE count,
 456+ 4EDD ~            ;			   INT[2][count] data_ptr
 457+ 4EDD ~            SPRGRPMOV:
 458+ 4EDD ~            	LD A, (SPRATR_INIT_STATUS)
 459+ 4EDD ~            	OR A
 460+ 4EDD ~            	JP Z,ILLEGAL_FUNCTION
 461+ 4EDD ~            	; opening (
 462+ 4EDD ~            	CALL CHKCHAR
 463+ 4EDD ~            	DB '('
 464+ 4EDD ~            	; get x
 465+ 4EDD ~            	LD IX, FRMQNT
 466+ 4EDD ~            	CALL CALBAS
 467+ 4EDD ~            	LD (BLIT_STRUCT),DE
 468+ 4EDD ~            	; comma
 469+ 4EDD ~            	CALL CHKCHAR
 470+ 4EDD ~            	DB ','
 471+ 4EDD ~            	; get y
 472+ 4EDD ~            	LD IX, FRMQNT
 473+ 4EDD ~            	CALL CALBAS
 474+ 4EDD ~            	LD (BLIT_STRUCT+2),DE
 475+ 4EDD ~            	; comma
 476+ 4EDD ~            	CALL CHKCHAR
 477+ 4EDD ~            	DB ','
 478+ 4EDD ~            	; get count
 479+ 4EDD ~            	LD IX, GETBYT
 480+ 4EDD ~            	CALL CALBAS
 481+ 4EDD ~            	LD (BLIT_STRUCT+4),A
 482+ 4EDD ~            	; comma
 483+ 4EDD ~            	CALL CHKCHAR
 484+ 4EDD ~            	DB ','
 485+ 4EDD ~            	; get sprite group definition array data pointer
 486+ 4EDD ~            	LD A,(BLIT_STRUCT+4)
 487+ 4EDD ~            	LD E,A
 488+ 4EDD ~            	LD D,3
 489+ 4EDD ~            	LD A,2
 490+ 4EDD ~            	LD B,A
 491+ 4EDD ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
 492+ 4EDD ~            	LD (BLIT_STRUCT+5),BC
 493+ 4EDD ~            	; ending )
 494+ 4EDD ~            	CALL CHKCHAR
 495+ 4EDD ~            	DB ')'
 496+ 4EDD ~
 497+ 4EDD ~            	PUSH HL
 498+ 4EDD ~
 499+ 4EDD ~                EXX
 500+ 4EDD ~                LD DE,(BLIT_STRUCT) ; initial x
 501+ 4EDD ~                LD BC,(BLIT_STRUCT+2) ; initial y
 502+ 4EDD ~                EXX
 503+ 4EDD ~                LD HL,(BLIT_STRUCT+5) ; pointer to data
 504+ 4EDD ~                LD A,(BLIT_STRUCT+4) ; number of entries
 505+ 4EDD ~                LD B,A
 506+ 4EDD ~            	CALL SPR_UPDATE_LOC
 507+ 4EDD ~
 508+ 4EDD ~            	POP HL
 509+ 4EDD ~            	RET
 510+ 4EDD ~            ; *******************************************************************************************************
 511+ 4EDD               ENDIF
 512+ 4EDD
 513+ 4EDD               IF (1 == 1)
 514+ 4EDD              ; *******************************************************************************************************
 515+ 4EDD              ; same as SPRGRPMOV but for DEFUSR approach
 516+ 4EDD              ; input IX=pointer to input array, real data from +2
 517+ 4EDD              ; +2 = X
 518+ 4EDD              ; +4 = Y
 519+ 4EDD              ; +6 = count
 520+ 4EDD              ; +8 = data pointer
 521+ 4EDD              SPRGRPMOV_DEFUSR:
 522+ 4EDD D9               EXX
 523+ 4EDE DD 5E 02     	LD E,(IX+2)
 524+ 4EE1 DD 56 03     	LD D,(IX+3) ; initial x
 525+ 4EE4 DD 4E 04     	LD C,(IX+4)
 526+ 4EE7 DD 46 05     	LD B,(IX+5) ; initial y
 527+ 4EEA D9               EXX
 528+ 4EEB DD 6E 08     	LD L,(IX+8)
 529+ 4EEE DD 66 09     	LD H,(IX+9) ; pointer to data
 530+ 4EF1 DD 46 06         LD B,(IX+6) ; count
 531+ 4EF4 C3 C2 4E         JP SPR_UPDATE_LOC
 532+ 4EF7              ; *******************************************************************************************************
 533+ 4EF7               ENDIF
# file closed: asm\SPRITES.asm
 135  4EF7               ENDIF
 136  4EF7
 137  4EF7               IF (ANIM_CMDS == 1)
 138  4EF7               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4EF7              ; sprite animation routines
   2+ 4EF7
   3+ 4EF7              ; number of animation items and pointer
   4+ 4EF7              ANIMITEMNUM:
   5+ 4EF7 00            DB 0
   6+ 4EF8              ANIMITEMPTR:
   7+ 4EF8 5A 61         DW EXT_END
   8+ 4EFA              ; number of animation definitions and pointer
   9+ 4EFA              ANIMDEFNUM:
  10+ 4EFA 00            DB 0
  11+ 4EFB              ANIMDEFPTR:
  12+ 4EFB 5A 61         DW EXT_END
  13+ 4EFD              ; number of links between sprite and animation definitions
  14+ 4EFD              ANIMSPRNUM:
  15+ 4EFD 00            DB 0
  16+ 4EFE              ANIMSPRPTR:
  17+ 4EFE 5A 61         DW EXT_END
  18+ 4F00              ; number of automatic sprite group move and animate structures
  19+ 4F00              AUTOSGAMNUM:
  20+ 4F00 00            DB 0
  21+ 4F01              AUTOSGAMPTR:
  22+ 4F01 5A 61         DW EXT_END
  23+ 4F03
  24+ 4F03              ; ANIMATION ITEM
  25+ 4F03              ; byte type = [0 - pattern and color change
  26+ 4F03              ;              1 - pattern definition change ]
  27+ 4F03              ; word ticks - number of ticks to hold this state
  28+ 4F03              ; for type = 0
  29+ 4F03              ;   byte pattern;
  30+ 4F03              ;   byte color;
  31+ 4F03              ; for type = 1
  32+ 4F03              ;   work data_pointer;
  33+ 4F03              ; total size = 5b
  34+ 4F03
  35+ 4F03              ; ANIMATION DEFINITION
  36+ 4F03              ; byte number of items 1-15
  37+ 4F03              ; byte[15] anim_item;
  38+ 4F03              ; total size = 16b
  39+ 4F03
  40+ 4F03              ; SPRITE/CHAR ANIMATION
  41+ 4F03              ; +00 byte sprite/char number;
  42+ 4F03              ; +01 word time;
  43+ 4F03              ; +03 byte current item;
  44+ 4F03              ; +04 byte animation definition;
  45+ 4F03              ; +05 byte cyclic;
  46+ 4F03              ; +06 byte active;
  47+ 4F03              ; +07 byte 0=sprite, 1-3 character bank
  48+ 4F03              ; total size = 8b
  49+ 4F03
  50+ 4F03              ; AUTOMATIC SPRITE GROUP MOVE AND ANIMATE structure
  51+ 4F03              ; +00 pointer to X variable
  52+ 4F03              ; +02 pointer to Y variable
  53+ 4F03              ; +04 minimum value
  54+ 4F03              ; +06 maximal value
  55+ 4F03              ; +08 delta value
  56+ 4F03              ; +10 direction 0=horizontal, <>0 = vertical
  57+ 4F03              ; +11 sprite group size
  58+ 4F03              ; +12 sprite group pointer
  59+ 4F03              ; +14 animation list size
  60+ 4F03              ; +15 animation list pointer for negative delta values
  61+ 4F03              ; +17 animation list pointer for positive delta values
  62+ 4F03              ; +19 active flag
  63+ 4F03              ; +20 ticks for movement
  64+ 4F03              ; +22 timer
  65+ 4F03              ; total = 24b
  66+ 4F03
  67+ 4F03              ; *******************************************************************************************************
  68+ 4F03              ; helper function HL=A*5
  69+ 4F03              ; changes HL,DE
  70+ 4F03              Ax5:
  71+ 4F03 26 00            LD H,0
  72+ 4F05 6F               LD L,A
  73+ 4F06 54               LD D,H
  74+ 4F07 5D               LD E,L
  75+ 4F08 29               ADD HL,HL
  76+ 4F09 29               ADD HL,HL
  77+ 4F0A 19               ADD HL,DE
  78+ 4F0B C9               RET
  79+ 4F0C              ; *******************************************************************************************************
  80+ 4F0C
  81+ 4F0C              ; *******************************************************************************************************
  82+ 4F0C              ; helper function gets pointer to n-th animation item
  83+ 4F0C              ; changes HL,DE
  84+ 4F0C              GETnthANIMITEM:
  85+ 4F0C CD 03 4F         CALL Ax5
  86+ 4F0F ED 5B F8 4E      LD DE,(ANIMITEMPTR)
  87+ 4F13 19               ADD HL,DE
  88+ 4F14 C9               RET
  89+ 4F15              ; *******************************************************************************************************
  90+ 4F15
  91+ 4F15              ; *******************************************************************************************************
  92+ 4F15              ; helper function gets pointer to n-th entry in animation definition
  93+ 4F15              ; changes HL,DE
  94+ 4F15              GETnthANIMDEF:
  95+ 4F15 26 00            LD H,0
  96+ 4F17 6F               LD L,A
  97+ 4F18 CD DF 5F         CALL HLx16
  98+ 4F1B ED 5B FB 4E      LD DE,(ANIMDEFPTR)
  99+ 4F1F 19               ADD HL,DE
 100+ 4F20 C9               RET
 101+ 4F21              ; *******************************************************************************************************
 102+ 4F21
 103+ 4F21              ; *******************************************************************************************************
 104+ 4F21              ; helper function gets pointer to n-th entry in sprite animation
 105+ 4F21              ; changes HL,DE
 106+ 4F21              GETnthSPRANIM:
 107+ 4F21 26 00            LD H,0
 108+ 4F23 6F               LD L,A
 109+ 4F24 CD E0 5F         CALL HLx8
 110+ 4F27 ED 5B FE 4E      LD DE,(ANIMSPRPTR)
 111+ 4F2B 19               ADD HL,DE
 112+ 4F2C C9               RET
 113+ 4F2D              ; *******************************************************************************************************
 114+ 4F2D
 115+ 4F2D              ; *******************************************************************************************************
 116+ 4F2D              ; helper function gets pointer to n-th entry in autosgam table
 117+ 4F2D              ; changes HL,DE
 118+ 4F2D              GETnthAUTOSGAM:
 119+ 4F2D 26 00            LD H,0
 120+ 4F2F 6F               LD L,A
 121+ 4F30 CD E0 5F         CALL HLx8
 122+ 4F33 54               LD D,H
 123+ 4F34 5D               LD E,L
 124+ 4F35 29               ADD HL,HL
 125+ 4F36 19               ADD HL,DE
 126+ 4F37 ED 5B 01 4F      LD DE,(AUTOSGAMPTR)
 127+ 4F3B 19               ADD HL,DE
 128+ 4F3C C9               RET
 129+ 4F3D              ; *******************************************************************************************************
 130+ 4F3D
 131+ 4F3D               IF (1 == 1)
 132+ 4F3D              ; *******************************************************************************************************
 133+ 4F3D              ; same as MAXIANIMITEMS but for DEFUSR approach
 134+ 4F3D              ; input IX=pointer to input array, real data from +2
 135+ 4F3D              ; +2 = number
 136+ 4F3D              MAXANIMITEMS_DEFUSR:
 137+ 4F3D DD 7E 02         LD A,(IX+2)
 138+ 4F40 CD 45 4F         CALL MAXANIMITEMS.COMMON
 139+ 4F43 AF               XOR A ; success
 140+ 4F44 C9               RET
 141+ 4F45              ; *******************************************************************************************************
 142+ 4F45               ENDIF
 143+ 4F45
 144+ 4F45              ; *******************************************************************************************************
 145+ 4F45              ; function to handle CALL MAXANIMITEMS basic extension
 146+ 4F45              ; MAXANIMITEMS (BYTE number)
 147+ 4F45              ; sets new number and moves memory buffers as needed
 148+ 4F45              MAXANIMITEMS:
 149+ 4F45               IF (0 == 1)
 150+ 4F45 ~            	; opening (
 151+ 4F45 ~            	CALL CHKCHAR
 152+ 4F45 ~            	DB '('
 153+ 4F45 ~            	; get value
 154+ 4F45 ~            	LD IX, GETBYT
 155+ 4F45 ~            	CALL CALBAS
 156+ 4F45 ~                PUSH AF
 157+ 4F45 ~            	; ending )
 158+ 4F45 ~            	CALL CHKCHAR
 159+ 4F45 ~            	DB ')'
 160+ 4F45 ~                POP AF
 161+ 4F45               ENDIF
 162+ 4F45              .COMMON: ; entry for DEFUSR part, A=number
 163+ 4F45 F3               DI
 164+ 4F46              	; save position
 165+ 4F46 E5           	PUSH HL
 166+ 4F47              .ENTRY:
 167+ 4F47 47               LD B,A
 168+ 4F48 3A F7 4E         LD A,(ANIMITEMNUM)
 169+ 4F4B 90               SUB B
 170+ 4F4C 28 28            JR Z, .EXIT; same value as before
 171+ 4F4E FD 21 FB 4E      LD IY,ANIMDEFPTR
 172+ 4F52 FA 79 4F         JP M, .INCREASE
 173+ 4F55                  ; new value is lower than previous one
 174+ 4F55 CD 98 4F         CALL .SIZEDIFF
 175+ 4F58 CD B3 4F         CALL .DECREASE_COMMON
 176+ 4F5B 2A FE 4E         LD HL,(ANIMSPRPTR)
 177+ 4F5E AF               XOR A
 178+ 4F5F ED 42            SBC HL,BC
 179+ 4F61 22 FE 4E         LD (ANIMSPRPTR),HL
 180+ 4F64              .E1:
 181+ 4F64 2A 01 4F         LD HL,(AUTOSGAMPTR)
 182+ 4F67 AF               XOR A
 183+ 4F68 ED 42            SBC HL,BC
 184+ 4F6A 22 01 4F         LD (AUTOSGAMPTR),HL
 185+ 4F6D              .E3:
 186+ 4F6D 2A 10 40         LD HL,(FREEMEMPTR)
 187+ 4F70 AF               XOR A
 188+ 4F71 ED 42            SBC HL,BC
 189+ 4F73 22 10 40         LD (FREEMEMPTR),HL
 190+ 4F76              .EXIT:
 191+ 4F76 FB               EI
 192+ 4F77 E1           	POP HL
 193+ 4F78 C9           	RET
 194+ 4F79              .INCREASE:
 195+ 4F79 ED 44            NEG
 196+ 4F7B CD 98 4F         CALL .SIZEDIFF
 197+ 4F7E CD DF 4F         CALL .INCREASE_COMMON
 198+ 4F81 2A FE 4E         LD HL,(ANIMSPRPTR)
 199+ 4F84 09               ADD HL,BC
 200+ 4F85 22 FE 4E         LD (ANIMSPRPTR),HL
 201+ 4F88              .E2:
 202+ 4F88 2A 01 4F         LD HL,(AUTOSGAMPTR)
 203+ 4F8B 09               ADD HL,BC
 204+ 4F8C 22 01 4F         LD (AUTOSGAMPTR),HL
 205+ 4F8F              .E4:
 206+ 4F8F 2A 10 40         LD HL,(FREEMEMPTR)
 207+ 4F92 09               ADD HL,BC
 208+ 4F93 22 10 40         LD (FREEMEMPTR),HL
 209+ 4F96 18 DE            JR .EXIT
 210+ 4F98              .SIZEDIFF:
 211+ 4F98 CD 03 4F         CALL Ax5
 212+ 4F9B 78               LD A,B
 213+ 4F9C 32 F7 4E         LD (ANIMITEMNUM),A
 214+ 4F9F 44               LD B,H
 215+ 4FA0 4D               LD C,L
 216+ 4FA1 C9               RET ; BC=size difference in bytes
 217+ 4FA2              .SIZETOMOVE:
 218+ 4FA2 D5               PUSH DE
 219+ 4FA3 2A 10 40         LD HL,(FREEMEMPTR)
 220+ 4FA6 FD 5E 00         LD E,(IY)
 221+ 4FA9 FD 56 01         LD D,(IY+1)
 222+ 4FAC AF               XOR A
 223+ 4FAD ED 52            SBC HL,DE
 224+ 4FAF 44               LD B,H
 225+ 4FB0 4D               LD C,L
 226+ 4FB1 D1               POP DE
 227+ 4FB2 C9               RET
 228+ 4FB3              .DECREASE_COMMON:
 229+ 4FB3 FD 6E 00         LD L,(IY)
 230+ 4FB6 FD 66 01         LD H,(IY+1)
 231+ 4FB9 AF               XOR A
 232+ 4FBA ED 42            SBC HL,BC
 233+ 4FBC EB               EX DE,HL
 234+ 4FBD C5               PUSH BC
 235+ 4FBE CD A2 4F         CALL .SIZETOMOVE
 236+ 4FC1 F3               DI
 237+ 4FC2 78               LD A,B
 238+ 4FC3 B1               OR C
 239+ 4FC4 28 08            JR Z,.L1
 240+ 4FC6 FD 6E 00         LD L,(IY)
 241+ 4FC9 FD 66 01         LD H,(IY+1)
 242+ 4FCC ED B0            LDIR
 243+ 4FCE              .L1:
 244+ 4FCE C1               POP BC
 245+ 4FCF FD 6E 00         LD L,(IY)
 246+ 4FD2 FD 66 01         LD H,(IY+1)
 247+ 4FD5 AF               XOR A
 248+ 4FD6 ED 42            SBC HL,BC
 249+ 4FD8 FD 75 00         LD (IY),L
 250+ 4FDB FD 74 01         LD (IY+1),H
 251+ 4FDE C9               RET
 252+ 4FDF              .INCREASE_COMMON:
 253+ 4FDF 2A 10 40         LD HL,(FREEMEMPTR)
 254+ 4FE2 2B               DEC HL
 255+ 4FE3 AF               XOR A
 256+ 4FE4 ED 42            SBC HL,BC
 257+ 4FE6 EB               EX DE,HL
 258+ 4FE7 C5               PUSH BC
 259+ 4FE8 CD A2 4F         CALL .SIZETOMOVE
 260+ 4FEB F3               DI
 261+ 4FEC 78               LD A,B
 262+ 4FED B1               OR C
 263+ 4FEE 28 06            JR Z,.L2
 264+ 4FF0 2A 10 40         LD HL,(FREEMEMPTR)
 265+ 4FF3 2B               DEC HL
 266+ 4FF4 ED B8            LDDR
 267+ 4FF6              .L2:
 268+ 4FF6 C1               POP BC
 269+ 4FF7 FD 6E 00         LD L,(IY)
 270+ 4FFA FD 66 01         LD H,(IY+1)
 271+ 4FFD 09               ADD HL,BC
 272+ 4FFE FD 75 00         LD (IY),L
 273+ 5001 FD 74 01         LD (IY+1),H
 274+ 5004 C9               RET
 275+ 5005              ; *******************************************************************************************************
 276+ 5005
 277+ 5005               IF (0 == 1)
 278+ 5005 ~            ; *******************************************************************************************************
 279+ 5005 ~            ; function to handle CALL ANIMITEMPAT basic extension
 280+ 5005 ~            ; ANIMITEMPAT ( BYTE id,
 281+ 5005 ~            ;               INT ticks >0,
 282+ 5005 ~            ;               BYTE pattern,
 283+ 5005 ~            ;               BYTE color )
 284+ 5005 ~            ; fills animation item data, returns an error if ID out of bounds
 285+ 5005 ~            ANIMITEMPAT:
 286+ 5005 ~                ; opening (
 287+ 5005 ~            	CALL CHKCHAR
 288+ 5005 ~            	DB '('
 289+ 5005 ~            	; get id
 290+ 5005 ~            	LD IX, GETBYT
 291+ 5005 ~            	CALL CALBAS
 292+ 5005 ~                PUSH AF
 293+ 5005 ~                ; check if out of bounds
 294+ 5005 ~                INC A
 295+ 5005 ~                LD C,A
 296+ 5005 ~                LD A,(ANIMITEMNUM)
 297+ 5005 ~                CP C
 298+ 5005 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 299+ 5005 ~            	; comma
 300+ 5005 ~            	CALL CHKCHAR
 301+ 5005 ~            	DB ','
 302+ 5005 ~            	; get ticks
 303+ 5005 ~            	LD IX, FRMQNT
 304+ 5005 ~            	CALL CALBAS
 305+ 5005 ~                LD A,D
 306+ 5005 ~                OR E
 307+ 5005 ~                JP Z, OVERFLOW
 308+ 5005 ~            	PUSH DE
 309+ 5005 ~            	; comma
 310+ 5005 ~            	CALL CHKCHAR
 311+ 5005 ~            	DB ','
 312+ 5005 ~            	; get pattern
 313+ 5005 ~            	LD IX, GETBYT
 314+ 5005 ~            	CALL CALBAS
 315+ 5005 ~                PUSH AF
 316+ 5005 ~            	; comma
 317+ 5005 ~            	CALL CHKCHAR
 318+ 5005 ~            	DB ','
 319+ 5005 ~            	; get color
 320+ 5005 ~            	LD IX, GETBYT
 321+ 5005 ~            	CALL CALBAS
 322+ 5005 ~                PUSH AF
 323+ 5005 ~            	; ending )
 324+ 5005 ~            	CALL CHKCHAR
 325+ 5005 ~            	DB ')'
 326+ 5005 ~            .ENTRY:
 327+ 5005 ~                PUSH HL
 328+ 5005 ~                POP IX
 329+ 5005 ~                EXX
 330+ 5005 ~                POP BC ; color
 331+ 5005 ~                POP DE ; pattern
 332+ 5005 ~                POP HL ; ticks
 333+ 5005 ~                EXX
 334+ 5005 ~                POP AF
 335+ 5005 ~                CALL GETnthANIMITEM
 336+ 5005 ~                PUSH HL
 337+ 5005 ~                POP IY
 338+ 5005 ~                EXX
 339+ 5005 ~                LD (IY),0 ; type=0
 340+ 5005 ~                LD (IY+1),L
 341+ 5005 ~                LD (IY+2),H
 342+ 5005 ~                LD (IY+3),D
 343+ 5005 ~                LD (IY+4),B
 344+ 5005 ~
 345+ 5005 ~                PUSH IX
 346+ 5005 ~                POP HL
 347+ 5005 ~                RET
 348+ 5005 ~            ; *******************************************************************************************************
 349+ 5005               ENDIF
 350+ 5005
 351+ 5005               IF (1 == 1)
 352+ 5005              ; *******************************************************************************************************
 353+ 5005              ; same as ANIMITEMPAT but for DEFUSR approach
 354+ 5005              ; input IX=pointer to input array, real data from +2
 355+ 5005              ; +02 = ID
 356+ 5005              ; +04 = ticks
 357+ 5005              ; +06 = pattern
 358+ 5005              ; +08 = color
 359+ 5005              ANIMITEMPAT_DEFUSR:
 360+ 5005                  ; check if out of bounds
 361+ 5005 DD 4E 02         LD C,(IX+2)
 362+ 5008 0C               INC C
 363+ 5009 3A F7 4E         LD A,(ANIMITEMNUM)
 364+ 500C B9               CP C
 365+ 500D 38 1D            JR C,.ERR ; out of bounds, prevent memory corruption
 366+ 500F 79               LD A,C
 367+ 5010 3D               DEC A
 368+ 5011 CD 0C 4F         CALL GETnthANIMITEM
 369+ 5014 36 00            LD (HL),0 ; type=0
 370+ 5016 23               INC HL
 371+ 5017 DD 7E 04         LD A,(IX+4) ; ticks low
 372+ 501A 77               LD (HL),A
 373+ 501B 23               INC HL
 374+ 501C DD 7E 05         LD A,(IX+5) ; ticks high
 375+ 501F 77               LD (HL),A
 376+ 5020 23               INC HL
 377+ 5021 DD 7E 06         LD A,(IX+6) ; pattern
 378+ 5024 77               LD (HL),A
 379+ 5025 23               INC HL
 380+ 5026 DD 7E 08         LD A,(IX+8) ; color
 381+ 5029 77               LD (HL),A
 382+ 502A AF               XOR A ; success
 383+ 502B C9               RET
 384+ 502C              .ERR:
 385+ 502C 3E 01            LD A,1
 386+ 502E C9               RET
 387+ 502F              ; *******************************************************************************************************
 388+ 502F               ENDIF
 389+ 502F
 390+ 502F               IF (0 == 1)
 391+ 502F ~            ; *******************************************************************************************************
 392+ 502F ~            ; function to handle CALL ANIMITEMPTR basic extension
 393+ 502F ~            ; ANIMITEMPTR ( BYTE id,
 394+ 502F ~            ;               INT ticks,
 395+ 502F ~            ;               INT pointer,
 396+ 502F ~            ; fills animation item data, returns an error if ID out of bounds
 397+ 502F ~            ANIMITEMPTR_CMD:
 398+ 502F ~                ; opening (
 399+ 502F ~            	CALL CHKCHAR
 400+ 502F ~            	DB '('
 401+ 502F ~            	; get id
 402+ 502F ~            	LD IX, GETBYT
 403+ 502F ~            	CALL CALBAS
 404+ 502F ~                PUSH AF
 405+ 502F ~                ; check if out of bounds
 406+ 502F ~                INC A
 407+ 502F ~                LD C,A
 408+ 502F ~                LD A,(ANIMITEMNUM)
 409+ 502F ~                CP C
 410+ 502F ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 411+ 502F ~            	; comma
 412+ 502F ~            	CALL CHKCHAR
 413+ 502F ~            	DB ','
 414+ 502F ~            	; get ticks
 415+ 502F ~            	LD IX, FRMQNT
 416+ 502F ~            	CALL CALBAS
 417+ 502F ~                LD A,D
 418+ 502F ~                OR E
 419+ 502F ~                JP Z,OVERFLOW
 420+ 502F ~            	PUSH DE
 421+ 502F ~            	; comma
 422+ 502F ~            	CALL CHKCHAR
 423+ 502F ~            	DB ','
 424+ 502F ~            	; get pointer
 425+ 502F ~            	LD IX, FRMQNT
 426+ 502F ~            	CALL CALBAS
 427+ 502F ~            	PUSH DE
 428+ 502F ~            	; ending )
 429+ 502F ~            	CALL CHKCHAR
 430+ 502F ~            	DB ')'
 431+ 502F ~            .ENTRY:
 432+ 502F ~                PUSH HL
 433+ 502F ~                POP IX
 434+ 502F ~                EXX
 435+ 502F ~                POP DE ; pointer
 436+ 502F ~                POP HL ; ticks
 437+ 502F ~                EXX
 438+ 502F ~                POP AF
 439+ 502F ~                CALL GETnthANIMITEM
 440+ 502F ~                PUSH HL
 441+ 502F ~                POP IY
 442+ 502F ~                EXX
 443+ 502F ~                LD (IY),1 ; type=1
 444+ 502F ~                LD (IY+1),L
 445+ 502F ~                LD (IY+2),H
 446+ 502F ~                LD (IY+3),E
 447+ 502F ~                LD (IY+4),D
 448+ 502F ~
 449+ 502F ~                PUSH IX
 450+ 502F ~                POP HL
 451+ 502F ~                RET
 452+ 502F ~            ; *******************************************************************************************************
 453+ 502F               ENDIF
 454+ 502F
 455+ 502F               IF (1 == 1)
 456+ 502F              ; *******************************************************************************************************
 457+ 502F              ; same as ANIMITEMPTR but for DEFUSR approach
 458+ 502F              ; input IX=pointer to input array, real data from +2
 459+ 502F              ; +02 = ID
 460+ 502F              ; +04 = ticks
 461+ 502F              ; +06 = pointer
 462+ 502F              ANIMITEMPTR_DEFUSR:
 463+ 502F                  ; check if out of bounds
 464+ 502F DD 4E 02         LD C,(IX+2)
 465+ 5032 0C               INC C
 466+ 5033 3A F7 4E         LD A,(ANIMITEMNUM)
 467+ 5036 B9               CP C
 468+ 5037 38 1D            JR C,.ERR ; out of bounds, prevent memory corruption
 469+ 5039 79               LD A,C
 470+ 503A 3D               DEC A
 471+ 503B CD 0C 4F         CALL GETnthANIMITEM
 472+ 503E 36 01            LD (HL),1 ; type=1
 473+ 5040 23               INC HL
 474+ 5041 DD 7E 04         LD A,(IX+4) ; ticks low
 475+ 5044 77               LD (HL),A
 476+ 5045 23               INC HL
 477+ 5046 DD 7E 05         LD A,(IX+5) ; ticks high
 478+ 5049 77               LD (HL),A
 479+ 504A 23               INC HL
 480+ 504B DD 7E 06         LD A,(IX+6) ; pointer low
 481+ 504E 77               LD (HL),A
 482+ 504F 23               INC HL
 483+ 5050 DD 7E 07         LD A,(IX+7) ; pointer high
 484+ 5053 77               LD (HL),A
 485+ 5054 AF               XOR A ; success
 486+ 5055 C9               RET
 487+ 5056              .ERR:
 488+ 5056 3E 01            LD A,1
 489+ 5058 C9               RET
 490+ 5059              ; *******************************************************************************************************
 491+ 5059               ENDIF
 492+ 5059
 493+ 5059               IF (1 == 1)
 494+ 5059              ; *******************************************************************************************************
 495+ 5059              ; same as MAXANIMDEFS but for DEFUSR approach
 496+ 5059              ; input IX=pointer to input array, real data from +2
 497+ 5059              ; +2 = number
 498+ 5059              MAXANIMDEFS_DEFUSR:
 499+ 5059 DD 7E 02         LD A,(IX+2)
 500+ 505C CD 61 50         CALL MAXANIMDEFS.COMMON
 501+ 505F AF               XOR A ; success
 502+ 5060 C9               RET
 503+ 5061              ; *******************************************************************************************************
 504+ 5061               ENDIF
 505+ 5061
 506+ 5061              ; *******************************************************************************************************
 507+ 5061              ; function to handle CALL MAXANIMDEFS basic extension
 508+ 5061              ; MAXANIMDEFS (BYTE number)
 509+ 5061              ; sets new number and moves memory buffers as needed
 510+ 5061              MAXANIMDEFS:
 511+ 5061               IF (0 == 1)
 512+ 5061 ~            	; opening (
 513+ 5061 ~            	CALL CHKCHAR
 514+ 5061 ~            	DB '('
 515+ 5061 ~            	; get value
 516+ 5061 ~            	LD IX, GETBYT
 517+ 5061 ~            	CALL CALBAS
 518+ 5061 ~                PUSH AF
 519+ 5061 ~            	; ending )
 520+ 5061 ~            	CALL CHKCHAR
 521+ 5061 ~            	DB ')'
 522+ 5061 ~                POP AF
 523+ 5061               ENDIF
 524+ 5061              .COMMON:
 525+ 5061 F3               DI
 526+ 5062              	; save position
 527+ 5062 E5           	PUSH HL
 528+ 5063              .ENTRY:
 529+ 5063 47               LD B,A
 530+ 5064 3A FA 4E         LD A,(ANIMDEFNUM)
 531+ 5067 90               SUB B
 532+ 5068 CA 76 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 533+ 506B FD 21 FE 4E      LD IY,ANIMSPRPTR
 534+ 506F FA 7B 50         JP M, .INCREASE
 535+ 5072                  ; new value is lower than previous one
 536+ 5072 CD 86 50         CALL .SIZEDIFF
 537+ 5075 CD B3 4F         CALL MAXANIMITEMS.DECREASE_COMMON
 538+ 5078 C3 64 4F         JP MAXANIMITEMS.E1
 539+ 507B              .INCREASE:
 540+ 507B ED 44            NEG
 541+ 507D CD 86 50         CALL .SIZEDIFF
 542+ 5080 CD DF 4F         CALL MAXANIMITEMS.INCREASE_COMMON
 543+ 5083 C3 88 4F         JP MAXANIMITEMS.E2
 544+ 5086              .SIZEDIFF:
 545+ 5086 26 00            LD H,0
 546+ 5088 6F               LD L,A
 547+ 5089 CD DF 5F         CALL HLx16
 548+ 508C 78               LD A,B
 549+ 508D 32 FA 4E         LD (ANIMDEFNUM),A
 550+ 5090 44               LD B,H
 551+ 5091 4D               LD C,L
 552+ 5092 C9               RET ; BC=size difference in bytes
 553+ 5093              ; *******************************************************************************************************
 554+ 5093
 555+ 5093               IF (0 == 1)
 556+ 5093 ~            ; *******************************************************************************************************
 557+ 5093 ~            ; function to handle CALL ANIMDEF basic extension
 558+ 5093 ~            ; ANIMITEMPAT ( BYTE id,
 559+ 5093 ~            ;               BYTE size,
 560+ 5093 ~            ;               INT[] list )
 561+ 5093 ~            ; fills animation definition data, returns an error if out of bounds, or invalid type
 562+ 5093 ~            ANIMDEF:
 563+ 5093 ~                ; opening (
 564+ 5093 ~            	CALL CHKCHAR
 565+ 5093 ~            	DB '('
 566+ 5093 ~            	; get id
 567+ 5093 ~            	LD IX, GETBYT
 568+ 5093 ~            	CALL CALBAS
 569+ 5093 ~                PUSH AF
 570+ 5093 ~                ; check if out of bounds
 571+ 5093 ~                INC A
 572+ 5093 ~                LD C,A
 573+ 5093 ~                LD A,(ANIMDEFNUM)
 574+ 5093 ~                CP C
 575+ 5093 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 576+ 5093 ~            	; comma
 577+ 5093 ~            	CALL CHKCHAR
 578+ 5093 ~            	DB ','
 579+ 5093 ~            	; get size
 580+ 5093 ~            	LD IX, GETBYT
 581+ 5093 ~            	CALL CALBAS
 582+ 5093 ~                CP 16
 583+ 5093 ~                JP NC, OVERFLOW
 584+ 5093 ~                OR A
 585+ 5093 ~                JP Z, OVERFLOW
 586+ 5093 ~            	PUSH AF
 587+ 5093 ~            	; comma
 588+ 5093 ~            	CALL CHKCHAR
 589+ 5093 ~            	DB ','
 590+ 5093 ~            	; get pointer to a list of animation items in integer array format
 591+ 5093 ~                ; get array pointer
 592+ 5093 ~                POP DE
 593+ 5093 ~                PUSH DE
 594+ 5093 ~                LD A,2
 595+ 5093 ~                LD B,1
 596+ 5093 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
 597+ 5093 ~                PUSH BC
 598+ 5093 ~            	; ending )
 599+ 5093 ~            	CALL CHKCHAR
 600+ 5093 ~            	DB ')'
 601+ 5093 ~            .ENTRY:
 602+ 5093 ~                PUSH HL
 603+ 5093 ~                POP IX
 604+ 5093 ~                POP DE ; pointer to INT array
 605+ 5093 ~                POP BC ; B=item number
 606+ 5093 ~                POP AF ; id
 607+ 5093 ~                PUSH DE
 608+ 5093 ~                CALL GETnthANIMDEF
 609+ 5093 ~                POP DE
 610+ 5093 ~                LD (HL),B
 611+ 5093 ~            .L1:
 612+ 5093 ~                INC HL
 613+ 5093 ~                LD A,(DE)
 614+ 5093 ~                .2 INC DE
 615+ 5093 ~                LD (HL),A
 616+ 5093 ~                DJNZ .L1
 617+ 5093 ~                PUSH IX
 618+ 5093 ~                POP HL
 619+ 5093 ~                RET
 620+ 5093 ~            ; *******************************************************************************************************
 621+ 5093               ENDIF
 622+ 5093
 623+ 5093               IF (1 == 1)
 624+ 5093              ; *******************************************************************************************************
 625+ 5093              ; same as ANIMDEF but for DEFUSR approach
 626+ 5093              ; input IX=pointer to input array, real data from +2
 627+ 5093              ; +02 = ID
 628+ 5093              ; +04 = list size
 629+ 5093              ; +06 = list pointer
 630+ 5093              ANIMDEF_DEFUSR:
 631+ 5093                  ; check if out of bounds
 632+ 5093 DD 4E 02         LD C,(IX+2)
 633+ 5096 0C               INC C
 634+ 5097 3A FA 4E         LD A,(ANIMDEFNUM)
 635+ 509A B9               CP C
 636+ 509B 38 1E            JR C,.ERR ; invalid id
 637+ 509D              	; get size
 638+ 509D DD 7E 04         LD A,(IX+4)
 639+ 50A0 FE 10            CP 16
 640+ 50A2 D0               RET NC ; overflow
 641+ 50A3 B7               OR A
 642+ 50A4 C8               RET Z ; ID=0, invalid
 643+ 50A5 47               LD B,A
 644+ 50A6 79               LD A,C
 645+ 50A7 3D               DEC A
 646+ 50A8 CD 15 4F         CALL GETnthANIMDEF
 647+ 50AB 70               LD (HL),B
 648+ 50AC DD 5E 06         LD E,(IX+6)
 649+ 50AF DD 56 07         LD D,(IX+7)
 650+ 50B2              .L1:
 651+ 50B2 23               INC HL
 652+ 50B3 1A               LD A,(DE)
 653+ 50B4 13          > INC DE
 653+ 50B5 13          > INC DE
 654+ 50B6 77               LD (HL),A
 655+ 50B7 10 F9            DJNZ .L1
 656+ 50B9 AF               XOR A ; success
 657+ 50BA C9               RET
 658+ 50BB              .ERR:
 659+ 50BB 3E 01            LD A,1
 660+ 50BD C9               RET
 661+ 50BE              ; *******************************************************************************************************
 662+ 50BE               ENDIF
 663+ 50BE
 664+ 50BE               IF (1 == 1)
 665+ 50BE              ; *******************************************************************************************************
 666+ 50BE              ; same as MAXANIMSPRS but for DEFUSR approach
 667+ 50BE              ; input IX=pointer to input array, real data from +2
 668+ 50BE              ; +2 = number
 669+ 50BE              MAXANIMSPRS_DEFUSR:
 670+ 50BE DD 7E 02         LD A,(IX+2)
 671+ 50C1 CD C6 50         CALL MAXANIMSPRS.COMMON
 672+ 50C4 AF               XOR A ; success
 673+ 50C5 C9               RET
 674+ 50C6              ; *******************************************************************************************************
 675+ 50C6               ENDIF
 676+ 50C6
 677+ 50C6              ; *******************************************************************************************************
 678+ 50C6              ; function to handle CALL MAXANIMSPRS basic extension
 679+ 50C6              ; MAXANIMSPRS (BYTE number)
 680+ 50C6              ; sets new number and moves memory buffers as needed
 681+ 50C6              MAXANIMSPRS:
 682+ 50C6               IF (0 == 1)
 683+ 50C6 ~            	; opening (
 684+ 50C6 ~            	CALL CHKCHAR
 685+ 50C6 ~            	DB '('
 686+ 50C6 ~            	; get value
 687+ 50C6 ~            	LD IX, GETBYT
 688+ 50C6 ~            	CALL CALBAS
 689+ 50C6 ~                PUSH AF
 690+ 50C6 ~            	; ending )
 691+ 50C6 ~            	CALL CHKCHAR
 692+ 50C6 ~            	DB ')'
 693+ 50C6 ~                POP AF
 694+ 50C6               ENDIF
 695+ 50C6              .COMMON:
 696+ 50C6 F3               DI
 697+ 50C7              	; save position
 698+ 50C7 E5           	PUSH HL
 699+ 50C8              .ENTRY:
 700+ 50C8 47               LD B,A
 701+ 50C9 3A FD 4E         LD A,(ANIMSPRNUM)
 702+ 50CC 90               SUB B
 703+ 50CD CA 76 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 704+ 50D0 FD 21 01 4F      LD IY,AUTOSGAMPTR
 705+ 50D4 FA E0 50         JP M, .INCREASE
 706+ 50D7                  ; new value is lower than previous one
 707+ 50D7 CD 01 51         CALL .SIZEDIFF
 708+ 50DA CD B3 4F         CALL MAXANIMITEMS.DECREASE_COMMON
 709+ 50DD C3 6D 4F         JP MAXANIMITEMS.E3
 710+ 50E0              .INCREASE:
 711+ 50E0 ED 44            NEG
 712+ 50E2 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 713+ 50E3 CD 01 51         CALL .SIZEDIFF
 714+ 50E6 CD DF 4F         CALL MAXANIMITEMS.INCREASE_COMMON
 715+ 50E9 AF               XOR A
 716+ 50EA ED 42            SBC HL,BC ; location of new stuff
 717+ 50EC F1               POP AF
 718+ 50ED C5               PUSH BC
 719+ 50EE 47               LD B,A
 720+ 50EF 11 08 00         LD DE,8
 721+ 50F2 E5               PUSH HL
 722+ 50F3 DD E1            POP IX
 723+ 50F5              .L1:
 724+ 50F5 DD 36 06 00      LD (IX+6),0 ; active flag
 725+ 50F9 DD 19            ADD IX,DE
 726+ 50FB 10 F8            DJNZ .L1
 727+ 50FD C1               POP BC
 728+ 50FE C3 8F 4F         JP MAXANIMITEMS.E4
 729+ 5101              .SIZEDIFF:
 730+ 5101 26 00            LD H,0
 731+ 5103 6F               LD L,A
 732+ 5104 CD E0 5F         CALL HLx8
 733+ 5107 78               LD A,B
 734+ 5108 32 FD 4E         LD (ANIMSPRNUM),A
 735+ 510B 44               LD B,H
 736+ 510C 4D               LD C,L
 737+ 510D C9               RET ; BC=size difference in bytes
 738+ 510E              ; *******************************************************************************************************
 739+ 510E
 740+ 510E               IF (0 == 1)
 741+ 510E ~            ; *******************************************************************************************************
 742+ 510E ~            ; function to handle CALL ANIMSPRITE basic extension
 743+ 510E ~            ; ANIMSPRITE ( BYTE id,
 744+ 510E ~            ;              BYTE sprite_number,
 745+ 510E ~            ;              BYTE animation_definition_id,
 746+ 510E ~            ;              BYTE cyclic_flag )
 747+ 510E ~            ; fills sprite animation data, returns an error if out of bounds, or invalid type
 748+ 510E ~            ANIMSPRITE:
 749+ 510E ~                ; opening (
 750+ 510E ~            	CALL CHKCHAR
 751+ 510E ~            	DB '('
 752+ 510E ~            	; get sprite animation id
 753+ 510E ~            	LD IX, GETBYT
 754+ 510E ~            	CALL CALBAS
 755+ 510E ~                PUSH AF
 756+ 510E ~                INC A
 757+ 510E ~                LD C,A
 758+ 510E ~                LD A,(ANIMSPRNUM)
 759+ 510E ~                CP C
 760+ 510E ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 761+ 510E ~            	; comma
 762+ 510E ~            	CALL CHKCHAR
 763+ 510E ~            	DB ','
 764+ 510E ~            	; get sprite number
 765+ 510E ~            	LD IX, GETBYT
 766+ 510E ~            	CALL CALBAS
 767+ 510E ~                PUSH AF
 768+ 510E ~                ; check if out of bounds
 769+ 510E ~                CP 32
 770+ 510E ~                JP NC, SUBSCRIPT_OUT_OF_RANGE
 771+ 510E ~            	; comma
 772+ 510E ~            	CALL CHKCHAR
 773+ 510E ~            	DB ','
 774+ 510E ~            	; get animation definition id
 775+ 510E ~            	LD IX, GETBYT
 776+ 510E ~            	CALL CALBAS
 777+ 510E ~                PUSH AF
 778+ 510E ~                INC A
 779+ 510E ~                LD C,A
 780+ 510E ~                LD A,(ANIMDEFNUM)
 781+ 510E ~                CP C
 782+ 510E ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 783+ 510E ~            	; comma
 784+ 510E ~            	CALL CHKCHAR
 785+ 510E ~            	DB ','
 786+ 510E ~            	; get cyclic flag
 787+ 510E ~            	LD IX, GETBYT
 788+ 510E ~                CALL CALBAS
 789+ 510E ~            	PUSH AF
 790+ 510E ~            	; ending )
 791+ 510E ~            	CALL CHKCHAR
 792+ 510E ~            	DB ')'
 793+ 510E ~            .ENTRY:
 794+ 510E ~                PUSH HL
 795+ 510E ~                POP IX
 796+ 510E ~                EXX
 797+ 510E ~                POP DE ; cyclic
 798+ 510E ~                POP BC ; animation definition id
 799+ 510E ~                POP HL ; sprite number
 800+ 510E ~                EXX
 801+ 510E ~                POP AF ; sprite animation id
 802+ 510E ~                CALL GETnthSPRANIM
 803+ 510E ~                PUSH HL
 804+ 510E ~                POP IY
 805+ 510E ~                EXX
 806+ 510E ~                LD (IY),H
 807+ 510E ~                LD (IY+4),B
 808+ 510E ~                LD (IY+5),D
 809+ 510E ~                ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 810+ 510E ~                ; following will do preparation for ANIMSTEP situation
 811+ 510E ~                ; current item set to above limit and timer to 1
 812+ 510E ~                ; any call to ANIMSTEP will switch and setup to first item for cyclic
 813+ 510E ~                LD (IY+3),255
 814+ 510E ~                LD (IY+1),1
 815+ 510E ~                LD (IY+2),0
 816+ 510E ~                ; mark as sprite animation
 817+ 510E ~                LD (IY+7),0
 818+ 510E ~                PUSH IX
 819+ 510E ~                POP HL
 820+ 510E ~                RET
 821+ 510E ~            ; *******************************************************************************************************
 822+ 510E               ENDIF
 823+ 510E
 824+ 510E               IF (1 == 1)
 825+ 510E              ; *******************************************************************************************************
 826+ 510E              ; same as ANIMSPRITE but for DEFUSR approach
 827+ 510E              ; input IX=pointer to input array, real data from +2
 828+ 510E              ; +02 = ID
 829+ 510E              ; +04 = sprite number
 830+ 510E              ; +06 = animation definition id
 831+ 510E              ; +08 = cyclic flag
 832+ 510E              ANIMSPRITE_DEFUSR:
 833+ 510E DD 4E 02         LD C,(IX+2)
 834+ 5111 0C               INC C
 835+ 5112 3A FD 4E         LD A,(ANIMSPRNUM)
 836+ 5115 B9               CP C
 837+ 5116 38 31            JR C,.ERR ; invalid id
 838+ 5118              	; get sprite number
 839+ 5118 DD 7E 04         LD A,(IX+4)
 840+ 511B FE 20            CP 32
 841+ 511D 30 2A            JR NC,.ERR ; invalid sprite id
 842+ 511F DD 46 06         LD B,(IX+6)
 843+ 5122 04               INC B
 844+ 5123 3A FA 4E         LD A,(ANIMDEFNUM)
 845+ 5126 B8               CP B
 846+ 5127 38 20            JR C,.ERR ; invalid animation definition id
 847+ 5129 79               LD A,C
 848+ 512A 3D               DEC A
 849+ 512B CD 21 4F         CALL GETnthSPRANIM
 850+ 512E DD 7E 04         LD A,(IX+4)
 851+ 5131 77               LD (HL),A ; +0
 852+ 5132 23               INC HL
 853+ 5133 36 01            LD (HL),1 ; +1
 854+ 5135 23               INC HL
 855+ 5136 36 00            LD (HL),0 ; +2
 856+ 5138 23               INC HL
 857+ 5139 36 FF            LD (HL),255 ; +3
 858+ 513B 23               INC HL
 859+ 513C 05               DEC B
 860+ 513D 70               LD (HL),B ; +4
 861+ 513E 23               INC HL
 862+ 513F DD 7E 08         LD A,(IX+8) ; +5
 863+ 5142 77               LD (HL),A
 864+ 5143 23               INC HL
 865+ 5144 23               INC HL
 866+ 5145 36 00            LD (HL),0 ; +7
 867+ 5147 AF               XOR A ; success
 868+ 5148 C9               RET
 869+ 5149              .ERR:
 870+ 5149 3E 01            LD A,1
 871+ 514B C9               RET
 872+ 514C              ; *******************************************************************************************************
 873+ 514C               ENDIF
 874+ 514C
 875+ 514C
 876+ 514C               IF (0 == 1)
 877+ 514C ~            ; *******************************************************************************************************
 878+ 514C ~            ; function to handle CALL ANIMCHAR basic extension
 879+ 514C ~            ; ANIMCHAR ( BYTE id,
 880+ 514C ~            ;            INT character number 0-767,
 881+ 514C ~            ;            BYTE animation_definition_id,
 882+ 514C ~            ;            BYTE cyclic_flag )
 883+ 514C ~            ; fills sprite animation data, returns an error if out of bounds, or invalid type
 884+ 514C ~            ANIMCHAR:
 885+ 514C ~                ; opening (
 886+ 514C ~            	CALL CHKCHAR
 887+ 514C ~            	DB '('
 888+ 514C ~            	; get sprite animation id
 889+ 514C ~            	LD IX, GETBYT
 890+ 514C ~            	CALL CALBAS
 891+ 514C ~                PUSH AF
 892+ 514C ~                INC A
 893+ 514C ~                LD C,A
 894+ 514C ~                LD A,(ANIMSPRNUM)
 895+ 514C ~                CP C
 896+ 514C ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 897+ 514C ~            	; comma
 898+ 514C ~            	CALL CHKCHAR
 899+ 514C ~            	DB ','
 900+ 514C ~            	; get character number
 901+ 514C ~            	LD IX, FRMQNT
 902+ 514C ~            	CALL CALBAS
 903+ 514C ~                PUSH DE
 904+ 514C ~                ; check if out of bounds
 905+ 514C ~                LD A,D
 906+ 514C ~                CP 3
 907+ 514C ~                JP NC, SUBSCRIPT_OUT_OF_RANGE
 908+ 514C ~            	; comma
 909+ 514C ~            	CALL CHKCHAR
 910+ 514C ~            	DB ','
 911+ 514C ~            	; get animation definition id
 912+ 514C ~            	LD IX, GETBYT
 913+ 514C ~            	CALL CALBAS
 914+ 514C ~                PUSH AF
 915+ 514C ~                INC A
 916+ 514C ~                LD C,A
 917+ 514C ~                LD A,(ANIMDEFNUM)
 918+ 514C ~                CP C
 919+ 514C ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 920+ 514C ~            	; comma
 921+ 514C ~            	CALL CHKCHAR
 922+ 514C ~            	DB ','
 923+ 514C ~            	; get cyclic flag
 924+ 514C ~            	LD IX, GETBYT
 925+ 514C ~                CALL CALBAS
 926+ 514C ~            	PUSH AF
 927+ 514C ~            	; ending )
 928+ 514C ~            	CALL CHKCHAR
 929+ 514C ~            	DB ')'
 930+ 514C ~            .ENTRY:
 931+ 514C ~                PUSH HL
 932+ 514C ~                POP IX
 933+ 514C ~                EXX
 934+ 514C ~                POP DE ; cyclic
 935+ 514C ~                POP BC ; animation definition id
 936+ 514C ~                POP HL ; character number
 937+ 514C ~                EXX
 938+ 514C ~                POP AF ; sprite animation id
 939+ 514C ~                CALL GETnthSPRANIM
 940+ 514C ~                PUSH HL
 941+ 514C ~                POP IY
 942+ 514C ~                EXX
 943+ 514C ~                LD (IY),L
 944+ 514C ~                INC H ; save character bank+1
 945+ 514C ~                LD (IY+7),H
 946+ 514C ~                LD (IY+4),B
 947+ 514C ~                LD (IY+5),D
 948+ 514C ~                ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 949+ 514C ~                ; following will do preparation for ANIMSTEP situation
 950+ 514C ~                ; current item set to above limit and timer to 1
 951+ 514C ~                ; any call to ANIMSTEP will switch and setup to first item for cyclic
 952+ 514C ~                LD (IY+3),255
 953+ 514C ~                LD (IY+1),1
 954+ 514C ~                LD (IY+2),0
 955+ 514C ~                PUSH IX
 956+ 514C ~                POP HL
 957+ 514C ~                RET
 958+ 514C ~            ; *******************************************************************************************************
 959+ 514C               ENDIF
 960+ 514C
 961+ 514C               IF (1 == 1)
 962+ 514C              ; *******************************************************************************************************
 963+ 514C              ; same as ANIMCHAR but for DEFUSR approach
 964+ 514C              ; input IX=pointer to input array, real data from +2
 965+ 514C              ; +02 = ID
 966+ 514C              ; +04 = character number
 967+ 514C              ; +06 = animation definition id
 968+ 514C              ; +08 = cyclic flag
 969+ 514C              ANIMCHAR_DEFUSR:
 970+ 514C DD 4E 02         LD C,(IX+2)
 971+ 514F 0C               INC C
 972+ 5150 3A FD 4E         LD A,(ANIMSPRNUM)
 973+ 5153 B9               CP C
 974+ 5154 38 34            JR C,.ERR ; invalid id
 975+ 5156              	; get sprite number
 976+ 5156 DD 7E 05         LD A,(IX+5)
 977+ 5159 FE 03            CP 3
 978+ 515B 30 2D            JR NC,.ERR ; invalid character (>767)
 979+ 515D DD 46 06         LD B,(IX+6)
 980+ 5160 04               INC B
 981+ 5161 3A FA 4E         LD A,(ANIMDEFNUM)
 982+ 5164 B8               CP B
 983+ 5165 38 23            JR C,.ERR ; invalid animation definition id
 984+ 5167 79               LD A,C
 985+ 5168 3D               DEC A
 986+ 5169 CD 21 4F         CALL GETnthSPRANIM
 987+ 516C DD 7E 04         LD A,(IX+4)
 988+ 516F 77               LD (HL),A ; +0
 989+ 5170 23               INC HL
 990+ 5171 36 01            LD (HL),1 ; +1
 991+ 5173 23               INC HL
 992+ 5174 36 00            LD (HL),0 ; +2
 993+ 5176 23               INC HL
 994+ 5177 36 FF            LD (HL),255 ; +3
 995+ 5179 23               INC HL
 996+ 517A 05               DEC B
 997+ 517B 70               LD (HL),B ; +4
 998+ 517C 23               INC HL
 999+ 517D DD 7E 08         LD A,(IX+8) ; +5
1000+ 5180 77               LD (HL),A
1001+ 5181 23               INC HL
1002+ 5182 23               INC HL
1003+ 5183 DD 7E 05         LD A,(IX+5)
1004+ 5186 3C               INC A
1005+ 5187 77               LD (HL),A ; +7
1006+ 5188 AF               XOR A ; success
1007+ 5189 C9               RET
1008+ 518A              .ERR:
1009+ 518A 3E 01            LD A,1
1010+ 518C C9               RET
1011+ 518D              ; *******************************************************************************************************
1012+ 518D               ENDIF
1013+ 518D
1014+ 518D               IF (1 == 1)
1015+ 518D              ; *******************************************************************************************************
1016+ 518D              ; same as MAXAUTOSGAMS but for DEFUSR approach
1017+ 518D              ; input IX=pointer to input array, real data from +2
1018+ 518D              ; +2 = number
1019+ 518D              MAXAUTOSGAMS_DEFUSR:
1020+ 518D DD 7E 02         LD A,(IX+2)
1021+ 5190 CD 95 51         CALL MAXAUTOSGAMS.COMMON
1022+ 5193 AF               XOR A ; success
1023+ 5194 C9               RET
1024+ 5195              ; *******************************************************************************************************
1025+ 5195               ENDIF
1026+ 5195
1027+ 5195              ; *******************************************************************************************************
1028+ 5195              ; function to handle CALL MAXAUTOSGAMS basic extension
1029+ 5195              ; MAXAUTOSGAMS (BYTE number)
1030+ 5195              ; sets new number and moves memory buffers as needed
1031+ 5195              MAXAUTOSGAMS:
1032+ 5195               IF (0 == 1)
1033+ 5195 ~            	; opening (
1034+ 5195 ~            	CALL CHKCHAR
1035+ 5195 ~            	DB '('
1036+ 5195 ~            	; get value
1037+ 5195 ~            	LD IX, GETBYT
1038+ 5195 ~            	CALL CALBAS
1039+ 5195 ~                PUSH AF
1040+ 5195 ~            	; ending )
1041+ 5195 ~            	CALL CHKCHAR
1042+ 5195 ~            	DB ')'
1043+ 5195 ~                POP AF
1044+ 5195               ENDIF
1045+ 5195              .COMMON:
1046+ 5195 F3               DI
1047+ 5196              	; save position
1048+ 5196 E5           	PUSH HL
1049+ 5197              .ENTRY:
1050+ 5197 47               LD B,A
1051+ 5198 3A 00 4F         LD A,(AUTOSGAMNUM)
1052+ 519B 90               SUB B
1053+ 519C CA 76 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
1054+ 519F FD 21 10 40      LD IY,FREEMEMPTR
1055+ 51A3 FA AF 51         JP M, .INCREASE
1056+ 51A6                  ; new value is lower than previous one
1057+ 51A6 CD D0 51         CALL .SIZEDIFF
1058+ 51A9 CD B3 4F         CALL MAXANIMITEMS.DECREASE_COMMON
1059+ 51AC C3 76 4F         JP MAXANIMITEMS.EXIT
1060+ 51AF              .INCREASE:
1061+ 51AF ED 44            NEG
1062+ 51B1 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
1063+ 51B2 CD D0 51         CALL .SIZEDIFF
1064+ 51B5 CD DF 4F         CALL MAXANIMITEMS.INCREASE_COMMON
1065+ 51B8 AF               XOR A
1066+ 51B9 ED 42            SBC HL,BC ; location of new stuff
1067+ 51BB F1               POP AF
1068+ 51BC C5               PUSH BC
1069+ 51BD 47               LD B,A
1070+ 51BE 11 18 00         LD DE,24
1071+ 51C1 E5               PUSH HL
1072+ 51C2 DD E1            POP IX
1073+ 51C4              .L1:
1074+ 51C4 DD 36 13 00      LD (IX+19),0 ; active flag
1075+ 51C8 DD 19            ADD IX,DE
1076+ 51CA 10 F8            DJNZ .L1
1077+ 51CC C1               POP BC
1078+ 51CD C3 76 4F         JP MAXANIMITEMS.EXIT
1079+ 51D0              .SIZEDIFF:
1080+ 51D0 26 00            LD H,0
1081+ 51D2 6F               LD L,A
1082+ 51D3 CD E0 5F         CALL HLx8
1083+ 51D6 54               LD D,H
1084+ 51D7 5D               LD E,L
1085+ 51D8 29               ADD HL,HL
1086+ 51D9 19               ADD HL,DE
1087+ 51DA 78               LD A,B
1088+ 51DB 32 00 4F         LD (AUTOSGAMNUM),A
1089+ 51DE 44               LD B,H
1090+ 51DF 4D               LD C,L
1091+ 51E0 C9               RET ; BC=size difference in bytes
1092+ 51E1              ; *******************************************************************************************************
1093+ 51E1
1094+ 51E1               IF (0 == 1)
1095+ 51E1 ~            ; *******************************************************************************************************
1096+ 51E1 ~            ; function to handle CALL AUTOSGAMDEF basic extension
1097+ 51E1 ~            ; AUTOSGAMDEF ( BYTE id,
1098+ 51E1 ~            ;               INT VARIABLE x, INT VARIABLE y,
1099+ 51E1 ~            ;               INT minimum, INT maximum, INT delta,
1100+ 51E1 ~            ;               INT direction =0 horizontal,
1101+ 51E1 ~            ;               INT ticks,
1102+ 51E1 ~            ;               BYTE sprite_group_count,
1103+ 51E1 ~            ;               INT[2][sprite_group_count] VARIABLE sprite_group,
1104+ 51E1 ~            ;               BYTE item_number,
1105+ 51E1 ~            ;               INT[] VARIABLE sprite_animations_negative_direction,
1106+ 51E1 ~            ;               INT[] VARIABLE sprite_animations_positive_direction
1107+ 51E1 ~            AUTOSGAMDEF:
1108+ 51E1 ~                ; opening (
1109+ 51E1 ~            	CALL CHKCHAR
1110+ 51E1 ~            	DB '('
1111+ 51E1 ~            	; get sprite animation id
1112+ 51E1 ~            	LD IX, GETBYT
1113+ 51E1 ~            	CALL CALBAS
1114+ 51E1 ~                PUSH AF
1115+ 51E1 ~                INC A
1116+ 51E1 ~                LD C,A
1117+ 51E1 ~                LD A,(AUTOSGAMNUM)
1118+ 51E1 ~                CP C
1119+ 51E1 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
1120+ 51E1 ~                POP AF
1121+ 51E1 ~                PUSH HL
1122+ 51E1 ~                CALL GETnthAUTOSGAM
1123+ 51E1 ~                LD (BLIT_TMP),HL ; for later
1124+ 51E1 ~                POP HL
1125+ 51E1 ~            	; comma
1126+ 51E1 ~            	CALL CHKCHAR
1127+ 51E1 ~            	DB ','
1128+ 51E1 ~            	; get address of the X coordinate variable
1129+ 51E1 ~            	LD IX, PTRGET
1130+ 51E1 ~            	CALL CALBAS
1131+ 51E1 ~            	LD IX,(BLIT_TMP)
1132+ 51E1 ~                LD (IX+0),E
1133+ 51E1 ~                LD (IX+1),D
1134+ 51E1 ~            	; comma
1135+ 51E1 ~            	CALL CHKCHAR
1136+ 51E1 ~            	DB ','
1137+ 51E1 ~            	; get address of the Y coordinate variable
1138+ 51E1 ~            	LD IX, PTRGET
1139+ 51E1 ~            	CALL CALBAS
1140+ 51E1 ~            	LD IX,(BLIT_TMP)
1141+ 51E1 ~                LD (IX+2),E
1142+ 51E1 ~                LD (IX+3),D
1143+ 51E1 ~            	; comma
1144+ 51E1 ~            	CALL CHKCHAR
1145+ 51E1 ~            	DB ','
1146+ 51E1 ~            	; get minimum value
1147+ 51E1 ~            	LD IX, FRMQNT
1148+ 51E1 ~            	CALL CALBAS
1149+ 51E1 ~            	LD IX,(BLIT_TMP)
1150+ 51E1 ~                LD (IX+4),E
1151+ 51E1 ~                LD (IX+5),D
1152+ 51E1 ~            	; comma
1153+ 51E1 ~            	CALL CHKCHAR
1154+ 51E1 ~            	DB ','
1155+ 51E1 ~            	; get maximum value
1156+ 51E1 ~            	LD IX, FRMQNT
1157+ 51E1 ~            	CALL CALBAS
1158+ 51E1 ~            	LD IX,(BLIT_TMP)
1159+ 51E1 ~                LD (IX+6),E
1160+ 51E1 ~                LD (IX+7),D
1161+ 51E1 ~            	; comma
1162+ 51E1 ~            	CALL CHKCHAR
1163+ 51E1 ~            	DB ','
1164+ 51E1 ~            	; get delta value
1165+ 51E1 ~            	LD IX, FRMQNT
1166+ 51E1 ~            	CALL CALBAS
1167+ 51E1 ~            	LD IX,(BLIT_TMP)
1168+ 51E1 ~                LD (IX+8),E
1169+ 51E1 ~                LD (IX+9),D
1170+ 51E1 ~            	; comma
1171+ 51E1 ~            	CALL CHKCHAR
1172+ 51E1 ~            	DB ','
1173+ 51E1 ~            	; get direction value
1174+ 51E1 ~            	LD IX, FRMQNT
1175+ 51E1 ~            	CALL CALBAS
1176+ 51E1 ~            	LD IX,(BLIT_TMP)
1177+ 51E1 ~                LD (IX+10),E
1178+ 51E1 ~            	; comma
1179+ 51E1 ~            	CALL CHKCHAR
1180+ 51E1 ~            	DB ','
1181+ 51E1 ~            	; get ticks value
1182+ 51E1 ~            	LD IX, FRMQNT
1183+ 51E1 ~            	CALL CALBAS
1184+ 51E1 ~            	LD IX,(BLIT_TMP)
1185+ 51E1 ~                LD (IX+20),E
1186+ 51E1 ~                LD (IX+21),D
1187+ 51E1 ~            	; comma
1188+ 51E1 ~            	CALL CHKCHAR
1189+ 51E1 ~            	DB ','
1190+ 51E1 ~            	; get sprite group count
1191+ 51E1 ~            	LD IX, GETBYT
1192+ 51E1 ~            	CALL CALBAS
1193+ 51E1 ~                OR A
1194+ 51E1 ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
1195+ 51E1 ~            	LD IX,(BLIT_TMP)
1196+ 51E1 ~                LD (IX+11),A
1197+ 51E1 ~            	; comma
1198+ 51E1 ~            	CALL CHKCHAR
1199+ 51E1 ~            	DB ','
1200+ 51E1 ~            	; get sprite group definition array data pointer
1201+ 51E1 ~            	LD IX,(BLIT_TMP)
1202+ 51E1 ~                LD E,(IX+11)
1203+ 51E1 ~            	LD D,3
1204+ 51E1 ~            	LD A,2
1205+ 51E1 ~            	LD B,A
1206+ 51E1 ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
1207+ 51E1 ~            	LD IX,(BLIT_TMP)
1208+ 51E1 ~            	LD (IX+12),C
1209+ 51E1 ~                LD (IX+13),B
1210+ 51E1 ~            	; comma
1211+ 51E1 ~            	CALL CHKCHAR
1212+ 51E1 ~            	DB ','
1213+ 51E1 ~            	; get sprite animation array size
1214+ 51E1 ~            	LD IX,GETBYT
1215+ 51E1 ~            	CALL CALBAS
1216+ 51E1 ~            	LD IX,(BLIT_TMP)
1217+ 51E1 ~                LD (IX+14),A
1218+ 51E1 ~                OR A
1219+ 51E1 ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
1220+ 51E1 ~            	; comma
1221+ 51E1 ~            	CALL CHKCHAR
1222+ 51E1 ~            	DB ','
1223+ 51E1 ~                ; get array pointer for negative direction
1224+ 51E1 ~            	LD IX,(BLIT_TMP)
1225+ 51E1 ~                LD D,(IX+14)
1226+ 51E1 ~                LD A,2
1227+ 51E1 ~                LD B,1
1228+ 51E1 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
1229+ 51E1 ~            	LD IX,(BLIT_TMP)
1230+ 51E1 ~                LD (IX+15),C
1231+ 51E1 ~                LD (IX+16),B
1232+ 51E1 ~            	; comma
1233+ 51E1 ~            	CALL CHKCHAR
1234+ 51E1 ~            	DB ','
1235+ 51E1 ~                ; get array pointer for positive direction
1236+ 51E1 ~            	LD IX,(BLIT_TMP)
1237+ 51E1 ~                LD D,(IX+14)
1238+ 51E1 ~                LD A,2
1239+ 51E1 ~                LD B,1
1240+ 51E1 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
1241+ 51E1 ~            	LD IX,(BLIT_TMP)
1242+ 51E1 ~                LD (IX+17),C
1243+ 51E1 ~                LD (IX+18),B
1244+ 51E1 ~            	; ending )
1245+ 51E1 ~            	CALL CHKCHAR
1246+ 51E1 ~            	DB ')'
1247+ 51E1 ~                RET
1248+ 51E1 ~            ; *******************************************************************************************************
1249+ 51E1               ENDIF
1250+ 51E1
1251+ 51E1               IF (1 == 1)
1252+ 51E1              ; *******************************************************************************************************
1253+ 51E1              ; same as AUTOSGAMDEF but for DEFUSR approach
1254+ 51E1              ; input IX=pointer to input array, real data from +2
1255+ 51E1              ; +02 = ID
1256+ 51E1              ; +04 = pointer to X variable
1257+ 51E1              ; +06 = pointer to Y variable
1258+ 51E1              ; +08 = minimum
1259+ 51E1              ; +10 = maximum
1260+ 51E1              ; +12 = delta
1261+ 51E1              ; +14 = direction
1262+ 51E1              ; +16 = ticks
1263+ 51E1              ; +18 = sprite group count
1264+ 51E1              ; +20 = sprite group array pointer
1265+ 51E1              ; +22 = item number
1266+ 51E1              ; +24 = sprite animations negative direction array pointer
1267+ 51E1              ; +26 = sprite animations positive direction array pointer
1268+ 51E1              AUTOSGAMDEF_DEFUSR:
1269+ 51E1 DD 4E 02         LD C,(IX+2)
1270+ 51E4 0C               INC C
1271+ 51E5 3A 00 4F         LD A,(AUTOSGAMNUM)
1272+ 51E8 B9               CP C
1273+ 51E9 DA 74 52         JP C,.ERR ; invalid id
1274+ 51EC 79               LD A,C
1275+ 51ED 3D               DEC A
1276+ 51EE CD 2D 4F         CALL GETnthAUTOSGAM
1277+ 51F1 E5               PUSH HL
1278+ 51F2 FD E1            POP IY
1279+ 51F4                  ; X variable
1280+ 51F4 DD 7E 04         LD A,(IX+4)
1281+ 51F7 FD 77 00         LD (IY+0),A
1282+ 51FA DD 7E 05         LD A,(IX+5)
1283+ 51FD FD 77 01         LD (IY+1),A
1284+ 5200              	; Y variable
1285+ 5200 DD 7E 06         LD A,(IX+6)
1286+ 5203 FD 77 02         LD (IY+2),A
1287+ 5206 DD 7E 07         LD A,(IX+7)
1288+ 5209 FD 77 03         LD (IY+3),A
1289+ 520C              	; get minimum value
1290+ 520C DD 7E 08         LD A,(IX+8)
1291+ 520F FD 77 04         LD (IY+4),A
1292+ 5212 DD 7E 09         LD A,(IX+9)
1293+ 5215 FD 77 05         LD (IY+5),A
1294+ 5218              	; get maximum value
1295+ 5218 DD 7E 0A         LD A,(IX+10)
1296+ 521B FD 77 06         LD (IY+6),A
1297+ 521E DD 7E 0B         LD A,(IX+11)
1298+ 5221 FD 77 07         LD (IY+7),A
1299+ 5224              	; get delta value
1300+ 5224 DD 7E 0C         LD A,(IX+12)
1301+ 5227 FD 77 08         LD (IY+8),A
1302+ 522A DD 7E 0D         LD A,(IX+13)
1303+ 522D FD 77 09         LD (IY+9),A
1304+ 5230              	; get direction value
1305+ 5230 DD 7E 0E         LD A,(IX+14)
1306+ 5233 FD 77 0A         LD (IY+10),A
1307+ 5236              	; get ticks value
1308+ 5236 DD 7E 10         LD A,(IX+16)
1309+ 5239 FD 77 14         LD (IY+20),A
1310+ 523C DD 7E 11         LD A,(IX+17)
1311+ 523F FD 77 15         LD (IY+21),A
1312+ 5242              	; get sprite group count
1313+ 5242 DD 7E 12         LD A,(IX+18)
1314+ 5245 FD 77 0B         LD (IY+11),A
1315+ 5248              	; get sprite group definition array data pointer
1316+ 5248 DD 7E 14         LD A,(IX+20)
1317+ 524B FD 77 0C         LD (IY+12),A
1318+ 524E DD 7E 15         LD A,(IX+21)
1319+ 5251 FD 77 0D         LD (IY+13),A
1320+ 5254              	; get sprite animation array size
1321+ 5254 DD 7E 16         LD A,(IX+22)
1322+ 5257 FD 77 0E         LD (IY+14),A
1323+ 525A                  ; get array pointer for negative direction
1324+ 525A DD 7E 18         LD A,(IX+24)
1325+ 525D FD 77 0F         LD (IY+15),A
1326+ 5260 DD 7E 19         LD A,(IX+25)
1327+ 5263 FD 77 10         LD (IY+16),A
1328+ 5266                  ; get array pointer for positive direction
1329+ 5266 DD 7E 1A         LD A,(IX+26)
1330+ 5269 FD 77 11         LD (IY+17),A
1331+ 526C DD 7E 1B         LD A,(IX+27)
1332+ 526F FD 77 12         LD (IY+18),A
1333+ 5272 AF               XOR A ; success
1334+ 5273 C9               RET
1335+ 5274              .ERR:
1336+ 5274 3E 01            LD A,1
1337+ 5276 C9               RET
1338+ 5277              ; *******************************************************************************************************
1339+ 5277               ENDIF
1340+ 5277
1341+ 5277               IF (0 == 1)
1342+ 5277 ~            ; *******************************************************************************************************
1343+ 5277 ~            ; function to handle CALL AUTOSGAMSTART basic extension
1344+ 5277 ~            ; AUTOSGAMSTART ( BYTE id )
1345+ 5277 ~            AUTOSGAMSTART:
1346+ 5277 ~                LD A,1
1347+ 5277 ~            .COMMON:
1348+ 5277 ~                LD (.SETVALUE+3),A
1349+ 5277 ~                ; opening (
1350+ 5277 ~            	CALL CHKCHAR
1351+ 5277 ~            	DB '('
1352+ 5277 ~            	; get sprite animation id
1353+ 5277 ~            	LD IX, GETBYT
1354+ 5277 ~            	CALL CALBAS
1355+ 5277 ~                PUSH AF
1356+ 5277 ~                INC A
1357+ 5277 ~                LD C,A
1358+ 5277 ~                LD A,(AUTOSGAMNUM)
1359+ 5277 ~                CP C
1360+ 5277 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
1361+ 5277 ~                POP AF
1362+ 5277 ~                PUSH HL
1363+ 5277 ~                CALL GETnthAUTOSGAM
1364+ 5277 ~                PUSH HL
1365+ 5277 ~                POP IX
1366+ 5277 ~                POP HL
1367+ 5277 ~                PUSH IX
1368+ 5277 ~            	; ending )
1369+ 5277 ~            	CALL CHKCHAR
1370+ 5277 ~            	DB ')'
1371+ 5277 ~
1372+ 5277 ~                ; so syntax is fine
1373+ 5277 ~                POP IX
1374+ 5277 ~            .SETVALUE:
1375+ 5277 ~                LD (IX+19),1 ; active flag
1376+ 5277 ~                ; set initial timer
1377+ 5277 ~                LD A,(IX+20)
1378+ 5277 ~                LD (IX+22),A
1379+ 5277 ~                LD A,(IX+21)
1380+ 5277 ~                LD (IX+23),A
1381+ 5277 ~                RET
1382+ 5277 ~            ; *******************************************************************************************************
1383+ 5277 ~
1384+ 5277 ~            ; *******************************************************************************************************
1385+ 5277 ~            ; function to handle CALL AUTOSGAMSTOP basic extension
1386+ 5277 ~            ; AUTOSGAMSTOP ( BYTE id )
1387+ 5277 ~            AUTOSGAMSTOP:
1388+ 5277 ~                XOR A
1389+ 5277 ~                JR AUTOSGAMSTART.COMMON
1390+ 5277 ~            ; *******************************************************************************************************
1391+ 5277               ENDIF
1392+ 5277
1393+ 5277               IF (1 == 1)
1394+ 5277              ; *******************************************************************************************************
1395+ 5277              ; function to handle CALL AUTOSGAMSTART basic extension in DEFUSR mode
1396+ 5277              ; input IX=pointer to input array, real data from +2
1397+ 5277              ; +2 = source address
1398+ 5277              AUTOSGAMSTART_DEFUSR:
1399+ 5277 3E 01            LD A,1
1400+ 5279              .COMMON:
1401+ 5279 32 91 52         LD (.SETVALUE+3),A
1402+ 527C DD 4E 02         LD C,(IX+2)
1403+ 527F 0C               INC C
1404+ 5280 3A 00 4F         LD A,(AUTOSGAMNUM)
1405+ 5283 B9               CP C
1406+ 5284 38 1A            JR C,.ERR ; invalid id
1407+ 5286 79               LD A,C
1408+ 5287 3D               DEC A
1409+ 5288 CD 2D 4F         CALL GETnthAUTOSGAM
1410+ 528B E5               PUSH HL
1411+ 528C DD E1            POP IX
1412+ 528E              .SETVALUE:
1413+ 528E DD 36 13 01      LD (IX+19),1 ; active flag
1414+ 5292                  ; set initial timer
1415+ 5292 DD 7E 14         LD A,(IX+20)
1416+ 5295 DD 77 16         LD (IX+22),A
1417+ 5298 DD 7E 15         LD A,(IX+21)
1418+ 529B DD 77 17         LD (IX+23),A
1419+ 529E AF               XOR A ; success
1420+ 529F C9               RET
1421+ 52A0              .ERR:
1422+ 52A0 3E 01            LD A,1
1423+ 52A2 C9               RET
1424+ 52A3              ; *******************************************************************************************************
1425+ 52A3
1426+ 52A3              ; *******************************************************************************************************
1427+ 52A3              ; function to handle CALL AUTOSGAMSTOP basic extension in DEFUSR mode
1428+ 52A3              ; input IX=pointer to input array, real data from +2
1429+ 52A3              ; +2 = source address
1430+ 52A3              AUTOSGAMSTOP_DEFUSR:
1431+ 52A3 AF               XOR A
1432+ 52A4 18 D3            JR AUTOSGAMSTART_DEFUSR.COMMON
1433+ 52A6              ; *******************************************************************************************************
1434+ 52A6               ENDIF
1435+ 52A6
1436+ 52A6               IF (0 == 1)
1437+ 52A6 ~            ; *******************************************************************************************************
1438+ 52A6 ~            ; function to handle CALL ANIMSTEP basic extension
1439+ 52A6 ~            ; two forms
1440+ 52A6 ~            ; ANIMSTEP ( BYTE id )
1441+ 52A6 ~            ; or
1442+ 52A6 ~            ; ANIMSTEP ( BYTE item_number,
1443+ 52A6 ~            ;            INT[] sprite_animations )
1444+ 52A6 ~            ANIMSTEP:
1445+ 52A6 ~                LD DE,ANIMSTARTSTOP_COMMON.STEP
1446+ 52A6 ~                JR ANIMSTARTSTOP_COMMON
1447+ 52A6 ~            ; *******************************************************************************************************
1448+ 52A6 ~            ; *******************************************************************************************************
1449+ 52A6 ~            ; function to handle CALL ANIMSTART basic extension
1450+ 52A6 ~            ; two forms
1451+ 52A6 ~            ; ANIMSTART ( BYTE id )
1452+ 52A6 ~            ; or
1453+ 52A6 ~            ; ANIMSTART ( BYTE item_number,
1454+ 52A6 ~            ;             INT[] sprite_animations )
1455+ 52A6 ~            ; sets active flag to 1
1456+ 52A6 ~            ANIMSTART:
1457+ 52A6 ~                LD DE,ANIMSTARTSTOP_COMMON.START
1458+ 52A6 ~                JR ANIMSTARTSTOP_COMMON
1459+ 52A6 ~            ; *******************************************************************************************************
1460+ 52A6 ~            ; *******************************************************************************************************
1461+ 52A6 ~            ; function to handle CALL ANIMSTOP basic extension
1462+ 52A6 ~            ; two forms
1463+ 52A6 ~            ; ANIMSTOP ( BYTE id )
1464+ 52A6 ~            ; or
1465+ 52A6 ~            ; ANIMSTOP ( BYTE item_number,
1466+ 52A6 ~            ;            INT[] sprite_animations )
1467+ 52A6 ~            ; sets active flag to 0
1468+ 52A6 ~            ANIMSTOP:
1469+ 52A6 ~                LD DE,ANIMSTARTSTOP_COMMON.STOP
1470+ 52A6 ~            ; *******************************************************************************************************
1471+ 52A6 ~            ANIMSTARTSTOP_COMMON:
1472+ 52A6 ~                LD (ANIMSTARTSTOP_COMMON.FN+1),DE
1473+ 52A6 ~                ; opening (
1474+ 52A6 ~            	CALL CHKCHAR
1475+ 52A6 ~            	DB '('
1476+ 52A6 ~            	; get sprite animation id or array size
1477+ 52A6 ~            	LD IX,GETBYT
1478+ 52A6 ~            	CALL CALBAS
1479+ 52A6 ~                PUSH AF
1480+ 52A6 ~                ; check if comma present
1481+ 52A6 ~                CALL GETPREVCHAR
1482+ 52A6 ~                INC HL
1483+ 52A6 ~                CP ','
1484+ 52A6 ~                JR Z,.L1
1485+ 52A6 ~                CP ')'
1486+ 52A6 ~                JP NZ,SYNTAX_ERROR
1487+ 52A6 ~                ; ok so single argument variant
1488+ 52A6 ~                POP AF
1489+ 52A6 ~                PUSH HL
1490+ 52A6 ~                DI
1491+ 52A6 ~                CALL .SETVALUE
1492+ 52A6 ~                EI
1493+ 52A6 ~                POP HL
1494+ 52A6 ~                RET
1495+ 52A6 ~            .L1:
1496+ 52A6 ~                ; get array pointer
1497+ 52A6 ~                POP DE
1498+ 52A6 ~                PUSH DE
1499+ 52A6 ~                LD A,2
1500+ 52A6 ~                LD B,1
1501+ 52A6 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
1502+ 52A6 ~                PUSH BC
1503+ 52A6 ~            	; ending )
1504+ 52A6 ~            	CALL CHKCHAR
1505+ 52A6 ~            	DB ')'
1506+ 52A6 ~                POP DE ; array pointer
1507+ 52A6 ~                POP BC ; number of items
1508+ 52A6 ~                LD A,B
1509+ 52A6 ~                OR A
1510+ 52A6 ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
1511+ 52A6 ~                PUSH HL
1512+ 52A6 ~                DI
1513+ 52A6 ~            .L2:
1514+ 52A6 ~                PUSH BC
1515+ 52A6 ~                LD A,(DE)
1516+ 52A6 ~                .2 INC DE
1517+ 52A6 ~                PUSH DE
1518+ 52A6 ~                CALL .SETVALUE
1519+ 52A6 ~                POP DE
1520+ 52A6 ~                POP BC
1521+ 52A6 ~                DJNZ .L2
1522+ 52A6 ~                EI
1523+ 52A6 ~                POP HL
1524+ 52A6 ~                RET
1525+ 52A6 ~
1526+ 52A6 ~            .SETVALUE:
1527+ 52A6 ~                LD B,A
1528+ 52A6 ~                INC A
1529+ 52A6 ~                LD C,A
1530+ 52A6 ~                LD A,(ANIMSPRNUM)
1531+ 52A6 ~                CP C
1532+ 52A6 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
1533+ 52A6 ~                LD A,B
1534+ 52A6 ~                CALL GETnthSPRANIM
1535+ 52A6 ~                PUSH HL
1536+ 52A6 ~                POP IX
1537+ 52A6 ~            .FN:
1538+ 52A6 ~                JP 0
1539+ 52A6 ~            .START:
1540+ 52A6 ~                LD (IX+6),1 ; active flag
1541+ 52A6 ~                LD (IX+3),0 ; current item
1542+ 52A6 ~                LD B,0 ; setup timer
1543+ 52A6 ~                JP SETUP_ANIM_STEP
1544+ 52A6 ~            .STOP:
1545+ 52A6 ~                LD (IX+6),0 ; active flag
1546+ 52A6 ~                RET
1547+ 52A6 ~            .STEP:
1548+ 52A6 ~                LD B,0
1549+ 52A6 ~                JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1550+ 52A6 ~            ; *******************************************************************************************************
1551+ 52A6               ENDIF
1552+ 52A6
1553+ 52A6              ; *******************************************************************************************************
1554+ 52A6              ; helper function to locate single animation and execute operation
1555+ 52A6              ; needs to have jump set to a correct function
1556+ 52A6              ; used by SGAM helper routines so always needed
1557+ 52A6              ; input A=animation item
1558+ 52A6              ANIM_SETVALUE:
1559+ 52A6 47               LD B,A
1560+ 52A7 3C               INC A
1561+ 52A8 4F               LD C,A
1562+ 52A9 3A FD 4E         LD A,(ANIMSPRNUM)
1563+ 52AC B9               CP C
1564+ 52AD D8               RET C ; out of range, so do nothing
1565+ 52AE 78               LD A,B
1566+ 52AF CD 21 4F         CALL GETnthSPRANIM
1567+ 52B2 E5               PUSH HL
1568+ 52B3 DD E1            POP IX
1569+ 52B5              .FN:
1570+ 52B5 C3 00 00         JP 0
1571+ 52B8              ; *******************************************************************************************************
1572+ 52B8
1573+ 52B8               IF (1 == 1)
1574+ 52B8              ; *******************************************************************************************************
1575+ 52B8              ; helper function to set values of multiple animations
1576+ 52B8              ; needs to have jump set to a correct function
1577+ 52B8              ; input B=number of animation item
1578+ 52B8              ; input DE=animation item array
1579+ 52B8              ANIM_LIST_SETVALUE:
1580+ 52B8 F3               DI
1581+ 52B9 C5               PUSH BC
1582+ 52BA 1A               LD A,(DE)
1583+ 52BB 13          > INC DE
1583+ 52BC 13          > INC DE
1584+ 52BD D5               PUSH DE
1585+ 52BE CD A6 52         CALL ANIM_SETVALUE
1586+ 52C1 D1               POP DE
1587+ 52C2 C1               POP BC
1588+ 52C3 10 F3            DJNZ ANIM_LIST_SETVALUE
1589+ 52C5 FB               EI
1590+ 52C6 C9               RET
1591+ 52C7              ; *******************************************************************************************************
1592+ 52C7
1593+ 52C7              ; *******************************************************************************************************
1594+ 52C7              ; function to handle single item ANIMSTEP in DEFUSR mode
1595+ 52C7              ; input IX=pointer to input array, real data from +2
1596+ 52C7              ; +2 = animation id
1597+ 52C7              ANIMSTEP_SINGLE_DEFUSR:
1598+ 52C7 21 D2 52         LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1599+ 52CA              .L1:
1600+ 52CA 22 B6 52         LD (ANIM_SETVALUE.FN+1),HL
1601+ 52CD DD 7E 02         LD A,(IX+2)
1602+ 52D0 18 D4            JR ANIM_SETVALUE
1603+ 52D2              .STEP:
1604+ 52D2 06 00            LD B,0
1605+ 52D4 C3 2C 53         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1606+ 52D7              ; *******************************************************************************************************
1607+ 52D7
1608+ 52D7              ; *******************************************************************************************************
1609+ 52D7              ; function to handle multi item ANIMSTEP in DEFUSR mode
1610+ 52D7              ; input IX=pointer to input array, real data from +2
1611+ 52D7              ; +2 = list size
1612+ 52D7              ; +4 = array pointer holding items
1613+ 52D7              ANIMSTEP_MULTI_DEFUSR:
1614+ 52D7 21 D2 52         LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1615+ 52DA              .L1:
1616+ 52DA 22 B6 52         LD (ANIM_SETVALUE.FN+1),HL
1617+ 52DD DD 46 02         LD B,(IX+2)
1618+ 52E0 DD 5E 04         LD E,(IX+4)
1619+ 52E3 DD 56 05         LD D,(IX+5)
1620+ 52E6 18 D0            JR ANIM_LIST_SETVALUE
1621+ 52E8              ; *******************************************************************************************************
1622+ 52E8
1623+ 52E8              ; *******************************************************************************************************
1624+ 52E8              ; function to handle single item ANIMSTART in DEFUSR mode
1625+ 52E8              ; input IX=pointer to input array, real data from +2
1626+ 52E8              ; +2 = animation id
1627+ 52E8              ANIMSTART_SINGLE_DEFUSR:
1628+ 52E8 21 ED 52         LD HL,ANIMSTART_SINGLE_DEFUSR.START
1629+ 52EB 18 DD            JR ANIMSTEP_SINGLE_DEFUSR.L1
1630+ 52ED              .START:
1631+ 52ED DD 36 06 01      LD (IX+6),1 ; active flag
1632+ 52F1 DD 36 03 00      LD (IX+3),0 ; current item
1633+ 52F5 06 00            LD B,0 ; setup timer
1634+ 52F7 C3 88 53         JP SETUP_ANIM_STEP
1635+ 52FA              ; *******************************************************************************************************
1636+ 52FA
1637+ 52FA              ; *******************************************************************************************************
1638+ 52FA              ; function to handle multi item ANIMSTART in DEFUSR mode
1639+ 52FA              ; input IX=pointer to input array, real data from +2
1640+ 52FA              ; +2 = list size
1641+ 52FA              ; +4 = array pointer holding items
1642+ 52FA              ANIMSTART_MULTI_DEFUSR:
1643+ 52FA 21 ED 52         LD HL,ANIMSTART_SINGLE_DEFUSR.START
1644+ 52FD 18 DB            JR ANIMSTEP_MULTI_DEFUSR.L1
1645+ 52FF              ; *******************************************************************************************************
1646+ 52FF
1647+ 52FF              ; *******************************************************************************************************
1648+ 52FF              ; function to handle single item ANIMSTOP in DEFUSR mode
1649+ 52FF              ; input IX=pointer to input array, real data from +2
1650+ 52FF              ; +2 = animation id
1651+ 52FF              ANIMSTOP_SINGLE_DEFUSR:
1652+ 52FF 21 04 53         LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1653+ 5302 18 C6            JR ANIMSTEP_SINGLE_DEFUSR.L1
1654+ 5304              .STOP:
1655+ 5304 DD 36 06 00      LD (IX+6),0 ; active flag
1656+ 5308 C9               RET
1657+ 5309              ; *******************************************************************************************************
1658+ 5309
1659+ 5309              ; *******************************************************************************************************
1660+ 5309              ; function to handle multi item ANIMSTOP in DEFUSR mode
1661+ 5309              ; input IX=pointer to input array, real data from +2
1662+ 5309              ; +2 = list size
1663+ 5309              ; +4 = array pointer holding items
1664+ 5309              ANIMSTOP_MULTI_DEFUSR:
1665+ 5309 21 04 53         LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1666+ 530C 18 CC            JR ANIMSTEP_MULTI_DEFUSR.L1
1667+ 530E              ; *******************************************************************************************************
1668+ 530E               ENDIF
1669+ 530E
1670+ 530E              ; *******************************************************************************************************
1671+ 530E              ; function processes animations during vblank period
1672+ 530E              PROCESS_ANIMATIONS:
1673+ 530E 3A FD 4E         LD A,(ANIMSPRNUM)
1674+ 5311 B7               OR A
1675+ 5312 C8               RET Z; no animations defined
1676+ 5313 47               LD B,A
1677+ 5314 DD 2A FE 4E      LD IX,(ANIMSPRPTR)
1678+ 5318              .L1:
1679+ 5318 C5               PUSH BC
1680+ 5319 06 00            LD B,0 ; normal mode, change on timer expiry only
1681+ 531B CD 27 53         CALL PROCESS_SINGLE_ANIMATION
1682+ 531E 11 08 00         LD DE,8
1683+ 5321 DD 19            ADD IX,DE
1684+ 5323 C1               POP BC
1685+ 5324 10 F2            DJNZ .L1
1686+ 5326 C9               RET
1687+ 5327              ; *******************************************************************************************************
1688+ 5327
1689+ 5327              ; *******************************************************************************************************
1690+ 5327              ; processes single sprite animation
1691+ 5327              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
1692+ 5327              ; on timer expiry goes to next animation item
1693+ 5327              ; input IX=sprite animation pointer
1694+ 5327              ; input B=1 force mode, activate animation action regardless of expired timer
1695+ 5327              PROCESS_SINGLE_ANIMATION:
1696+ 5327 DD 7E 06         LD A,(IX+6); active
1697+ 532A B7               OR A
1698+ 532B C8               RET Z ; inactive animation
1699+ 532C              .INACTIVE_TOO:
1700+ 532C DD 6E 01         LD L,(IX+1)
1701+ 532F DD 66 02         LD H,(IX+2) ; HL=end time
1702+ 5332 2B               DEC HL
1703+ 5333 DD 75 01         LD (IX+1),L
1704+ 5336 DD 74 02         LD (IX+2),H
1705+ 5339 7D               LD A,L
1706+ 533A B4               OR H
1707+ 533B 28 06            JR Z,.STEP
1708+ 533D 05               DEC B
1709+ 533E 04               INC B
1710+ 533F C8               RET Z ; not forced mode, return
1711+ 5340 C3 88 53         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
1712+ 5343              .STEP:
1713+ 5343 06 00            LD B,0; setup timer
1714+ 5345 DD 34 03         INC (IX+3) ; current animation item
1715+ 5348 C3 88 53         JP SETUP_ANIM_STEP
1716+ 534B              ; *******************************************************************************************************
1717+ 534B
1718+ 534B              ; *******************************************************************************************************
1719+ 534B              ; function will setup sprite animation after current item change
1720+ 534B              ; input A=current animation definition
1721+ 534B              ; input IX=pointer to sprite animation
1722+ 534B              ; input B=1 skip timer setup
1723+ 534B              ; output IY=pointer to animation item
1724+ 534B              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
1725+ 534B              ; basically sets new end time for current animation
1726+ 534B              INIT_CURRENT_ANIMATION:
1727+ 534B CD 15 4F         CALL GETnthANIMDEF
1728+ 534E DD 7E 03         LD A,(IX+3) ; current animation item
1729+ 5351 BE               CP (HL) ; number of animation items in the animation definition
1730+ 5352 38 0A            JR C,.L3 ; last item not reached
1731+ 5354                  ; last item reached
1732+ 5354 DD 7E 05         LD A,(IX+5) ; cyclic flag
1733+ 5357 B7               OR A
1734+ 5358 28 2C            JR Z,.ERROR ; non-cyclic animation
1735+ 535A                  ; cyclic animation, restart
1736+ 535A DD 36 03 00      LD (IX+3),0; current item
1737+ 535E              .L3:
1738+ 535E                  ; HL = animation definition
1739+ 535E 23               INC HL ; skip animation definition size field
1740+ 535F 16 00            LD D,0
1741+ 5361 DD 5E 03         LD E,(IX+3); current item
1742+ 5364 19               ADD HL,DE
1743+ 5365 4E               LD C,(HL) ; current animation item
1744+ 5366 0C               INC C
1745+ 5367 3A F7 4E         LD A,(ANIMITEMNUM)
1746+ 536A B9               CP C
1747+ 536B 38 19            JR C,.ERROR ; invalid animation item, stop animation
1748+ 536D 0D               DEC C
1749+ 536E 79               LD A,C
1750+ 536F CD 0C 4F         CALL GETnthANIMITEM
1751+ 5372 E5               PUSH HL
1752+ 5373 FD E1            POP IY ; IY=animation item
1753+ 5375 05               DEC B
1754+ 5376 28 0C            JR Z,.EXIT
1755+ 5378 FD 5E 01         LD E,(IY+1)
1756+ 537B FD 56 02         LD D,(IY+2) ; duration
1757+ 537E DD 73 01         LD (IX+1),E
1758+ 5381 DD 72 02         LD (IX+2),D
1759+ 5384              .EXIT:
1760+ 5384 AF               XOR A
1761+ 5385 C9               RET
1762+ 5386              .ERROR:
1763+ 5386 37               SCF
1764+ 5387 C9               RET
1765+ 5388              ; *******************************************************************************************************
1766+ 5388
1767+ 5388              ; *******************************************************************************************************
1768+ 5388              ; function will display currect item and set up expiry time
1769+ 5388              ; it will also stop the animation if expired
1770+ 5388              ; sets sprite update flag if any changes in sprite data made
1771+ 5388              ; input IX=current sprite animation
1772+ 5388              ; input B=1 skip timer setup
1773+ 5388              SETUP_ANIM_STEP:
1774+ 5388 DD 4E 04         LD C,(IX+4) ; animation definition ID
1775+ 538B 0C               INC C
1776+ 538C 3A FA 4E         LD A,(ANIMDEFNUM)
1777+ 538F B9               CP C
1778+ 5390 30 05            JR NC,.L2
1779+ 5392                  ; given animation item is outside of bounds, deactivate animation
1780+ 5392              .STOPANIM:
1781+ 5392 DD 36 06 00      LD (IX+6),0
1782+ 5396 C9               RET
1783+ 5397              .L2:
1784+ 5397 0D               DEC C
1785+ 5398 79               LD A,C
1786+ 5399 CD 4B 53         CALL INIT_CURRENT_ANIMATION
1787+ 539C 38 F4            JR C, .STOPANIM
1788+ 539E FD 7E 00         LD A,(IY) ; type of animation item
1789+ 53A1 B7               OR A
1790+ 53A2 28 44            JR Z,.L4 ; change pattern and/or color
1791+ 53A4              .PAT:
1792+ 53A4                  ; change pattern definition
1793+ 53A4                  ; check if sprite or character
1794+ 53A4 DD 7E 07         LD A,(IX+7)
1795+ 53A7 B7               OR A
1796+ 53A8 20 58            JR NZ,.CHAR
1797+ 53AA DD 7E 00         LD A,(IX) ; sprite number
1798+ 53AD CD 90 4D         CALL GETnthSPRATTR
1799+ 53B0 23          > INC HL ; skip y and x
1799+ 53B1 23          > INC HL
1799+ 53B2 23          > INC HL
1799+ 53B3 23          > INC HL
1800+ 53B4 7E               LD A,(HL); current pattern
1801+ 53B5 26 00            LD H,0
1802+ 53B7 6F               LD L,A
1803+ 53B8 3A E0 F3         LD A,(REG1SAV)
1804+ 53BB E6 02            AND 2
1805+ 53BD 20 07            JR NZ,.L6
1806+ 53BF                  ; 8x8 sprite
1807+ 53BF CD E0 5F         CALL HLx8
1808+ 53C2 06 08            LD B,8
1809+ 53C4 18 05            JR .L5
1810+ 53C6              .L6:
1811+ 53C6 CD DE 5F         CALL HLx32
1812+ 53C9 06 20            LD B,32
1813+ 53CB              .L5:
1814+ 53CB 3A AF FC         LD A,(SCRMOD)
1815+ 53CE 3D               DEC A
1816+ 53CF 20 06            JR NZ,.L10
1817+ 53D1 ED 5B C5 F3      LD DE,(T32PAT)
1818+ 53D5 18 04            JR .L7
1819+ 53D7              .L10:
1820+ 53D7 ED 5B CF F3      LD DE,(GRPPAT)
1821+ 53DB              .L7:
1822+ 53DB 19               ADD HL,DE
1823+ 53DC CD C1 5F         CALL SETWRT_LOCAL_WRITE
1824+ 53DF FD 6E 03         LD L,(IY+3)
1825+ 53E2 FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
1826+ 53E5 C3 D6 5F         JP BBYTECOPY
1827+ 53E8              .L4:
1828+ 53E8                  ; change pattern and color in sprite attributes table
1829+ 53E8 DD 7E 00         LD A,(IX) ; sprite number
1830+ 53EB CD 90 4D         CALL GETnthSPRATTR
1831+ 53EE 23          > INC HL ; skip y and x
1831+ 53EF 23          > INC HL
1831+ 53F0 23          > INC HL
1831+ 53F1 23          > INC HL
1832+ 53F2 FD 7E 03         LD A,(IY+3) ; new pattern
1833+ 53F5 77               LD (HL),A
1834+ 53F6 23          > INC HL
1834+ 53F7 23          > INC HL
1835+ 53F8 FD 7E 04         LD A,(IY+4) ; new color
1836+ 53FB 77               LD (HL),A
1837+ 53FC 2A 87 4D         LD HL,(SPRATR_UPDATE_FLAG)
1838+ 53FF 36 01            LD (HL),1
1839+ 5401 C9               RET
1840+ 5402              .CHAR:
1841+ 5402 DD 6E 00         LD L,(IX)
1842+ 5405 3D               DEC A
1843+ 5406 67               LD H,A
1844+ 5407 CD E0 5F         CALL HLx8
1845+ 540A 3A AF FC         LD A,(SCRMOD)
1846+ 540D 3D               DEC A
1847+ 540E 20 06            JR NZ,.L8
1848+ 5410 ED 5B C1 F3      LD DE,(T32CGP)
1849+ 5414 18 04            JR .L9
1850+ 5416              .L8:
1851+ 5416 ED 5B CB F3      LD DE,(GRPCGP)
1852+ 541A              .L9:
1853+ 541A 06 08            LD B,8
1854+ 541C 18 BD            JR .L7
1855+ 541E              ; *******************************************************************************************************
1856+ 541E
# file closed: asm\ANIMATION.asm
 139  541E               INCLUDE "SGAM.asm"
# file opened: asm\SGAM.asm
   1+ 541E              ; Sprite Group Animate and Move
   2+ 541E
   3+ 541E              ; *******************************************************************************************************
   4+ 541E              ; shared function to process a list of animations
   5+ 541E              ; input B=list size
   6+ 541E              ; input DE=list pointer
   7+ 541E              SGAM_PROCESS_ANIM_LIST:
   8+ 541E 21 31 54         LD HL,.STEP
   9+ 5421 22 B6 52         LD (ANIM_SETVALUE.FN+1),HL
  10+ 5424              .L1:
  11+ 5424 C5               PUSH BC
  12+ 5425 1A               LD A,(DE)
  13+ 5426 13          > INC DE
  13+ 5427 13          > INC DE
  14+ 5428 D5               PUSH DE
  15+ 5429 CD A6 52         CALL ANIM_SETVALUE
  16+ 542C D1               POP DE
  17+ 542D C1               POP BC
  18+ 542E 10 F4            DJNZ .L1
  19+ 5430 C9           	RET
  20+ 5431              .STEP:
  21+ 5431 06 01            LD B,1
  22+ 5433 C3 2C 53         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
  23+ 5436              ; *******************************************************************************************************
  24+ 5436
  25+ 5436               IF (0 == 1)
  26+ 5436 ~            ; *******************************************************************************************************
  27+ 5436 ~            ; function to handle CALL SGAM basic extension
  28+ 5436 ~            ; sets position of a group of sprites as described in SPRGRPMOV
  29+ 5436 ~            ; and manually animate a list of animations
  30+ 5436 ~            ; _SGAM ( INT x,
  31+ 5436 ~            ;	      INT y,
  32+ 5436 ~            ;		  BYTE count,
  33+ 5436 ~            ;		  INT[2][count] data_ptr,
  34+ 5436 ~            ;         BYTE item_number,
  35+ 5436 ~            ;         INT[] sprite_animations )
  36+ 5436 ~            ; will put ram in page 0 also, page 1 is already there
  37+ 5436 ~            SGAM:
  38+ 5436 ~            	LD A, (SPRATR_INIT_STATUS)
  39+ 5436 ~            	OR A
  40+ 5436 ~            	JP Z,ILLEGAL_FUNCTION
  41+ 5436 ~            	; opening (
  42+ 5436 ~            	CALL CHKCHAR
  43+ 5436 ~            	DB '('
  44+ 5436 ~            	; get x
  45+ 5436 ~            	LD IX, FRMQNT
  46+ 5436 ~            	CALL CALBAS
  47+ 5436 ~            	LD (BLIT_STRUCT),DE
  48+ 5436 ~            	; comma
  49+ 5436 ~            	CALL CHKCHAR
  50+ 5436 ~            	DB ','
  51+ 5436 ~            	; get y
  52+ 5436 ~            	LD IX, FRMQNT
  53+ 5436 ~            	CALL CALBAS
  54+ 5436 ~            	LD (BLIT_STRUCT+2),DE
  55+ 5436 ~            	; comma
  56+ 5436 ~            	CALL CHKCHAR
  57+ 5436 ~            	DB ','
  58+ 5436 ~            	; get count
  59+ 5436 ~            	LD IX, GETBYT
  60+ 5436 ~            	CALL CALBAS
  61+ 5436 ~                OR A
  62+ 5436 ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
  63+ 5436 ~            	LD (BLIT_STRUCT+4),A
  64+ 5436 ~            	; comma
  65+ 5436 ~            	CALL CHKCHAR
  66+ 5436 ~            	DB ','
  67+ 5436 ~            	; get sprite group definition array data pointer
  68+ 5436 ~                LD A,(BLIT_STRUCT+4)
  69+ 5436 ~            	LD E,A
  70+ 5436 ~            	LD D,3
  71+ 5436 ~            	LD A,2
  72+ 5436 ~            	LD B,A
  73+ 5436 ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
  74+ 5436 ~            	LD (BLIT_STRUCT+5),BC
  75+ 5436 ~            	; comma
  76+ 5436 ~            	CALL CHKCHAR
  77+ 5436 ~            	DB ','
  78+ 5436 ~            	; get sprite animation array size
  79+ 5436 ~            	LD IX,GETBYT
  80+ 5436 ~            	CALL CALBAS
  81+ 5436 ~                LD (BLIT_STRUCT+7),A
  82+ 5436 ~                OR A
  83+ 5436 ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
  84+ 5436 ~            	; comma
  85+ 5436 ~            	CALL CHKCHAR
  86+ 5436 ~            	DB ','
  87+ 5436 ~                ; get array pointer
  88+ 5436 ~                LD A,(BLIT_STRUCT+7)
  89+ 5436 ~                LD D,A
  90+ 5436 ~                LD A,2
  91+ 5436 ~                LD B,1
  92+ 5436 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
  93+ 5436 ~                LD (BLIT_STRUCT+8),BC
  94+ 5436 ~            	; ending )
  95+ 5436 ~            	CALL CHKCHAR
  96+ 5436 ~            	DB ')'
  97+ 5436 ~            .ENTRY:
  98+ 5436 ~                PUSH HL
  99+ 5436 ~
 100+ 5436 ~            	; enable page 0
 101+ 5436 ~            	LD IY, .RET
 102+ 5436 ~            	JP ENABLE_PAGE0
 103+ 5436 ~            .RET:
 104+ 5436 ~                EXX
 105+ 5436 ~                LD DE,(BLIT_STRUCT) ; initial x
 106+ 5436 ~                LD BC,(BLIT_STRUCT+2) ; initial y
 107+ 5436 ~                EXX
 108+ 5436 ~                LD HL,(BLIT_STRUCT+5) ; pointer to data
 109+ 5436 ~                LD A,(BLIT_STRUCT+4) ; number of entries
 110+ 5436 ~                LD B,A
 111+ 5436 ~                CALL SPR_UPDATE_LOC
 112+ 5436 ~
 113+ 5436 ~                LD A,(BLIT_STRUCT+7) ; anim number
 114+ 5436 ~                LD B,A
 115+ 5436 ~                LD DE,(BLIT_STRUCT+8) ; anim list
 116+ 5436 ~            	CALL SGAM_PROCESS_ANIM_LIST
 117+ 5436 ~
 118+ 5436 ~                POP DE
 119+ 5436 ~                POP BC
 120+ 5436 ~                CALL RESTORE_PAGE_INFO
 121+ 5436 ~                EI
 122+ 5436 ~                POP HL
 123+ 5436 ~                RET
 124+ 5436 ~            ; *******************************************************************************************************
 125+ 5436               ENDIF
 126+ 5436
 127+ 5436               IF (1 == 1)
 128+ 5436              ; *******************************************************************************************************
 129+ 5436              ; same as SGAM but for DEFUSR approach
 130+ 5436              ; input IX=pointer to input array, real data from +2
 131+ 5436              ; +02 = X
 132+ 5436              ; +04 = Y
 133+ 5436              ; +06 = count
 134+ 5436              ; +08 = data pointer
 135+ 5436              ; +10 = anim number
 136+ 5436              ; +12 = sprite animations
 137+ 5436              SGAM_DEFUSR:
 138+ 5436              	; enable page 0
 139+ 5436 FD 21 3D 54  	LD IY, .RET
 140+ 543A C3 A4 60     	JP ENABLE_PAGE0
 141+ 543D              .RET:
 142+ 543D FB           	EI
 143+ 543E D9               EXX
 144+ 543F DD 5E 02     	LD E,(IX+2)
 145+ 5442 DD 56 03     	LD D,(IX+3) ; initial x
 146+ 5445 DD 4E 04     	LD C,(IX+4)
 147+ 5448 DD 46 05     	LD B,(IX+5) ; initial y
 148+ 544B D9               EXX
 149+ 544C DD 6E 08     	LD L,(IX+8)
 150+ 544F DD 66 09     	LD H,(IX+9) ; pointer to data
 151+ 5452 DD 46 06         LD B,(IX+6) ; count
 152+ 5455 DD E5        	PUSH IX
 153+ 5457 CD C2 4E         CALL SPR_UPDATE_LOC
 154+ 545A DD E1        	POP IX
 155+ 545C DD 46 0A         LD B,(IX+10) ; anim number
 156+ 545F DD 5E 0C     	LD E,(IX+12)
 157+ 5462 DD 56 0D     	LD D,(IX+13)
 158+ 5465 CD 1E 54     	CALL SGAM_PROCESS_ANIM_LIST
 159+ 5468
 160+ 5468 D1               POP DE
 161+ 5469 C1               POP BC
 162+ 546A CD 1B 60         CALL RESTORE_PAGE_INFO
 163+ 546D AF           	XOR A ; success
 164+ 546E C9           	RET
 165+ 546F              ; *******************************************************************************************************
 166+ 546F               ENDIF
 167+ 546F
 168+ 546F              ; *******************************************************************************************************
 169+ 546F              ; handles automatic move and animate sprite groups during interrupt
 170+ 546F              PROCESS_AUTOSGAMS:
 171+ 546F 3A 00 4F     	LD A,(AUTOSGAMNUM)
 172+ 5472 B7           	OR A
 173+ 5473 C8           	RET Z
 174+ 5474 47           	LD B,A
 175+ 5475 DD 2A 01 4F  	LD IX,(AUTOSGAMPTR)
 176+ 5479              .L1:
 177+ 5479 C5           	PUSH BC
 178+ 547A DD 7E 13     	LD A,(IX+19) ; active flag
 179+ 547D B7           	OR A
 180+ 547E 28 28        	JR Z,.LOOPEND
 181+ 5480              	; active, check timer
 182+ 5480 DD 6E 16     	LD L,(IX+22)
 183+ 5483 DD 66 17     	LD H,(IX+23) ; timer
 184+ 5486 2B           	DEC HL
 185+ 5487 7C           	LD A,H
 186+ 5488 B5           	OR L
 187+ 5489 28 08        	JR Z,.L2
 188+ 548B              	; not expired
 189+ 548B DD 75 16     	LD (IX+22),L
 190+ 548E DD 74 17     	LD (IX+23),H
 191+ 5491 18 15        	JR .LOOPEND
 192+ 5493              .L2:
 193+ 5493              	; expired, process
 194+ 5493
 195+ 5493                  ; set initial timer
 196+ 5493 DD 7E 14         LD A,(IX+20)
 197+ 5496 DD 77 16         LD (IX+22),A
 198+ 5499 DD 7E 15         LD A,(IX+21)
 199+ 549C DD 77 17         LD (IX+23),A
 200+ 549F
 201+ 549F CD B1 54     	CALL .MOVE
 202+ 54A2 CD 1C 55     	CALL .UPDATELOC
 203+ 54A5 CD 41 55     	CALL .PROCESS_ANIM_LIST
 204+ 54A8
 205+ 54A8              .LOOPEND:
 206+ 54A8 11 18 00     	LD DE,24
 207+ 54AB DD 19        	ADD IX,DE
 208+ 54AD C1           	POP BC
 209+ 54AE 10 C9        	DJNZ .L1
 210+ 54B0 C9           	RET
 211+ 54B1
 212+ 54B1              .MOVE:
 213+ 54B1              	; process movement
 214+ 54B1 DD 7E 0A     	LD A,(IX+10) ; direction
 215+ 54B4 B7           	OR A
 216+ 54B5 28 08        	JR Z, .MOVE_L1
 217+ 54B7              	; vertical
 218+ 54B7 DD 6E 02     	LD L,(IX+2)
 219+ 54BA DD 66 03     	LD H,(IX+3) ; vertical variable pointer
 220+ 54BD 18 06        	JR .MOVE_L2
 221+ 54BF              .MOVE_L1:
 222+ 54BF              	; horizontal
 223+ 54BF DD 6E 00     	LD L,(IX+0)
 224+ 54C2 DD 66 01     	LD H,(IX+1) ; horizontal variable pointer
 225+ 54C5              .MOVE_L2:
 226+ 54C5 E5           	PUSH HL
 227+ 54C6 FD E1        	POP IY
 228+ 54C8 FD 6E 00     	LD L,(IY+0)
 229+ 54CB FD 66 01     	LD H,(IY+1)
 230+ 54CE DD 5E 08     	LD E,(IX+8)
 231+ 54D1 DD 56 09     	LD D,(IX+9) ; delta value
 232+ 54D4 19           	ADD HL,DE
 233+ 54D5 E5           	PUSH HL
 234+ 54D6 DD 5E 04     	LD E,(IX+4)
 235+ 54D9 DD 56 05     	LD D,(IX+5) ; minimum value
 236+ 54DC A7           	AND A
 237+ 54DD ED 52        	SBC HL,DE
 238+ 54DF FA F9 54     	JP M,.MOVE_L3 ; below minimum
 239+ 54E2 E1           	POP HL
 240+ 54E3 E5           	PUSH HL
 241+ 54E4 DD 5E 06     	LD E,(IX+6)
 242+ 54E7 DD 56 07     	LD D,(IX+7) ; maximum value
 243+ 54EA EB           	EX DE,HL
 244+ 54EB A7           	AND A
 245+ 54EC ED 52        	SBC HL,DE
 246+ 54EE FA 01 55     	JP M,.MOVE_L4 ; above maximum
 247+ 54F1 E1           	POP HL
 248+ 54F2              	; within bounds
 249+ 54F2              .MOVE_L5:
 250+ 54F2 FD 75 00     	LD (IY+0),L
 251+ 54F5 FD 74 01     	LD (IY+1),H
 252+ 54F8 C9           	RET
 253+ 54F9              .MOVE_L3:
 254+ 54F9 E1           	POP HL
 255+ 54FA CD 0D 55     	CALL .INVERSE_DELTA
 256+ 54FD 6B           	LD L,E
 257+ 54FE 62           	LD H,D
 258+ 54FF 18 F1        	JR .MOVE_L5
 259+ 5501              .MOVE_L4:
 260+ 5501 E1           	POP HL
 261+ 5502 CD 0D 55     	CALL .INVERSE_DELTA
 262+ 5505 DD 6E 06     	LD L,(IX+6)
 263+ 5508 DD 66 07     	LD H,(IX+7) ; maximum
 264+ 550B 18 E5        	JR .MOVE_L5
 265+ 550D              .INVERSE_DELTA:
 266+ 550D AF           	XOR A
 267+ 550E DD 96 08     	SUB (IX+8)
 268+ 5511 DD 77 08     	LD (IX+8),A
 269+ 5514 9F           	SBC A,A
 270+ 5515 DD 96 09     	SUB (IX+9)
 271+ 5518 DD 77 09     	LD (IX+9),A
 272+ 551B C9           	RET
 273+ 551C
 274+ 551C              .UPDATELOC:
 275+ 551C DD E5        	PUSH IX
 276+ 551E D9           	EXX
 277+ 551F DD 6E 00     	LD L,(IX+0)
 278+ 5522 DD 66 01     	LD H,(IX+1)
 279+ 5525 5E           	LD E,(HL)
 280+ 5526 23           	INC HL
 281+ 5527 56           	LD D,(HL)
 282+ 5528 DD 6E 02     	LD L,(IX+2)
 283+ 552B DD 66 03     	LD H,(IX+3)
 284+ 552E 4E           	LD C,(HL)
 285+ 552F 23           	INC HL
 286+ 5530 46           	LD B,(HL)
 287+ 5531 D9           	EXX
 288+ 5532 DD 6E 0C     	LD L,(IX+12)
 289+ 5535 DD 66 0D     	LD H,(IX+13) ; pointer to sprite group data
 290+ 5538 DD 46 0B     	LD B,(IX+11) ; sprite group size
 291+ 553B CD C2 4E     	CALL SPR_UPDATE_LOC
 292+ 553E DD E1        	POP IX
 293+ 5540 C9           	RET
 294+ 5541
 295+ 5541              .PROCESS_ANIM_LIST:
 296+ 5541 DD E5        	PUSH IX
 297+ 5543 DD 46 0E         LD B,(IX+14) ; anim list size
 298+ 5546 DD CB 09 7E  	BIT 7,(IX+9)
 299+ 554A 28 08        	JR Z,.PROCESS_ANIM_LIST_L1
 300+ 554C              	; negative direction
 301+ 554C DD 5E 0F     	LD E,(IX+15)
 302+ 554F DD 56 10     	LD D,(IX+16)
 303+ 5552 18 06        	JR .PROCESS_ANIM_LIST_L2
 304+ 5554              .PROCESS_ANIM_LIST_L1:
 305+ 5554              	; positive direction
 306+ 5554 DD 5E 11     	LD E,(IX+17)
 307+ 5557 DD 56 12     	LD D,(IX+18)
 308+ 555A              .PROCESS_ANIM_LIST_L2:
 309+ 555A CD 1E 54     	CALL SGAM_PROCESS_ANIM_LIST
 310+ 555D DD E1        	POP IX
 311+ 555F C9           	RET
 312+ 5560              ; *******************************************************************************************************
 313+ 5560
# file closed: asm\SGAM.asm
 140  5560               ENDIF
 141  5560
 142  5560               IF (RAM_CMDS == 1)
 143  5560               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
   1+ 5560               IF (0 == 1)
   2+ 5560 ~            ; *******************************************************************************************************
   3+ 5560 ~            ; function to handle CALL MEMCPY basic extension
   4+ 5560 ~            ; _MEMCPY ( INT source,
   5+ 5560 ~            ;			INT destination,
   6+ 5560 ~            ;			INT count,
   7+ 5560 ~            ; will put ram in page 0 also, page 1 is already there
   8+ 5560 ~            MEMCPY:
   9+ 5560 ~            	; opening (
  10+ 5560 ~            	CALL CHKCHAR
  11+ 5560 ~            	DB '('
  12+ 5560 ~            	; get source address
  13+ 5560 ~            	LD IX, FRMQNT
  14+ 5560 ~            	CALL CALBAS
  15+ 5560 ~            	PUSH DE
  16+ 5560 ~            	; comma
  17+ 5560 ~            	CALL CHKCHAR
  18+ 5560 ~            	DB ','
  19+ 5560 ~            	; get destination address
  20+ 5560 ~            	LD IX, FRMQNT
  21+ 5560 ~            	CALL CALBAS
  22+ 5560 ~            	PUSH DE
  23+ 5560 ~            	; comma
  24+ 5560 ~            	CALL CHKCHAR
  25+ 5560 ~            	DB ','
  26+ 5560 ~            	; get length
  27+ 5560 ~            	LD IX, FRMQNT
  28+ 5560 ~            	CALL CALBAS
  29+ 5560 ~            	PUSH DE
  30+ 5560 ~            	; ending )
  31+ 5560 ~            	CALL CHKCHAR
  32+ 5560 ~            	DB ')'
  33+ 5560 ~
  34+ 5560 ~            	; save position
  35+ 5560 ~            	PUSH HL
  36+ 5560 ~            	POP IX
  37+ 5560 ~
  38+ 5560 ~            	POP BC ; count
  39+ 5560 ~            	POP DE ; destination
  40+ 5560 ~            	POP HL ; source
  41+ 5560 ~            	EXX
  42+ 5560 ~            	; enable page 0
  43+ 5560 ~            	LD IY, .RET
  44+ 5560 ~            	JP ENABLE_PAGE0
  45+ 5560 ~            .RET:
  46+ 5560 ~            	EI
  47+ 5560 ~            	EXX
  48+ 5560 ~            	LDIR
  49+ 5560 ~                POP DE
  50+ 5560 ~                POP BC
  51+ 5560 ~                CALL RESTORE_PAGE_INFO
  52+ 5560 ~            	PUSH IX
  53+ 5560 ~            	POP HL
  54+ 5560 ~            	RET
  55+ 5560 ~            ; *******************************************************************************************************
  56+ 5560               ENDIF
  57+ 5560
  58+ 5560               IF (1 == 1)
  59+ 5560              ; *******************************************************************************************************
  60+ 5560              ; same as MEMCPY but for DEFUSR approach
  61+ 5560              ; input IX=pointer to input array, real data from +2
  62+ 5560              ; +2 = source address
  63+ 5560              ; +4 = destination address
  64+ 5560              ; +6 = lenght
  65+ 5560              MEMCPY_DEFUSR:
  66+ 5560              	; enable page 0
  67+ 5560 FD 21 67 55  	LD IY, .RET
  68+ 5564 C3 A4 60     	JP ENABLE_PAGE0
  69+ 5567              .RET:
  70+ 5567 FB           	EI
  71+ 5568 DD 6E 02     	LD L,(IX+2)
  72+ 556B DD 66 03     	LD H,(IX+3)
  73+ 556E DD 5E 04     	LD E,(IX+4)
  74+ 5571 DD 56 05     	LD D,(IX+5)
  75+ 5574 DD 4E 06     	LD C,(IX+6)
  76+ 5577 DD 46 07     	LD B,(IX+7)
  77+ 557A ED B0        	LDIR
  78+ 557C D1               POP DE
  79+ 557D C1               POP BC
  80+ 557E CD 1B 60         CALL RESTORE_PAGE_INFO
  81+ 5581 AF           	XOR A ; success
  82+ 5582 C9           	RET
  83+ 5583              ; *******************************************************************************************************
  84+ 5583               ENDIF
  85+ 5583
  86+ 5583               IF (0 == 1)
  87+ 5583 ~            ; *******************************************************************************************************
  88+ 5583 ~            ; function to handle CALL FILRAM basic extension
  89+ 5583 ~            ; FILRAM ( INT start address,
  90+ 5583 ~            ;		   INT count,
  91+ 5583 ~            ;		   BYTE value )
  92+ 5583 ~            ; will put ram in page 0 also, page 1 is already there
  93+ 5583 ~            FILRAM:
  94+ 5583 ~            	; opening (
  95+ 5583 ~            	CALL CHKCHAR
  96+ 5583 ~            	DB '('
  97+ 5583 ~            	; get start address
  98+ 5583 ~            	LD IX, FRMQNT
  99+ 5583 ~            	CALL CALBAS
 100+ 5583 ~            	PUSH DE
 101+ 5583 ~            	; comma
 102+ 5583 ~            	CALL CHKCHAR
 103+ 5583 ~            	DB ','
 104+ 5583 ~            	; get count
 105+ 5583 ~            	LD IX, FRMQNT
 106+ 5583 ~            	CALL CALBAS
 107+ 5583 ~            	PUSH DE
 108+ 5583 ~            	; comma
 109+ 5583 ~            	CALL CHKCHAR
 110+ 5583 ~            	DB ','
 111+ 5583 ~            	; get value
 112+ 5583 ~            	LD IX, GETBYT
 113+ 5583 ~            	CALL CALBAS
 114+ 5583 ~            	PUSH AF
 115+ 5583 ~            	; ending )
 116+ 5583 ~            	CALL CHKCHAR
 117+ 5583 ~            	DB ')'
 118+ 5583 ~
 119+ 5583 ~            	; save position
 120+ 5583 ~            	PUSH HL
 121+ 5583 ~            	POP IX
 122+ 5583 ~
 123+ 5583 ~            	POP DE ; actually AF
 124+ 5583 ~            	POP BC ; count
 125+ 5583 ~            	POP HL ; start address
 126+ 5583 ~            	LD A, B
 127+ 5583 ~            	OR C
 128+ 5583 ~            	JR Z, .EXIT ; 0 bytes to fill, skip
 129+ 5583 ~            	EXX
 130+ 5583 ~            	; enable page 0
 131+ 5583 ~            	LD IY, .RET
 132+ 5583 ~            	JP ENABLE_PAGE0
 133+ 5583 ~            .RET:
 134+ 5583 ~            	EI
 135+ 5583 ~            	EXX
 136+ 5583 ~            	CALL FILVRM_FILLVALUE
 137+ 5583 ~                POP DE
 138+ 5583 ~                POP BC
 139+ 5583 ~                CALL RESTORE_PAGE_INFO
 140+ 5583 ~            .EXIT:
 141+ 5583 ~            	PUSH IX
 142+ 5583 ~            	POP HL
 143+ 5583 ~            	RET
 144+ 5583 ~            ; *******************************************************************************************************
 145+ 5583               ENDIF
 146+ 5583
 147+ 5583               IF (1 == 1)
 148+ 5583              ; *******************************************************************************************************
 149+ 5583              ; same as FILVRM but for DEFUSR approach
 150+ 5583              ; input IX=pointer to input array, real data from +2
 151+ 5583              ; +2 = start address
 152+ 5583              ; +4 = count
 153+ 5583              ; +6 = value
 154+ 5583              FILRAM_DEFUSR:
 155+ 5583              	; enable page 0
 156+ 5583 FD 21 8A 55  	LD IY, .RET
 157+ 5587 C3 A4 60     	JP ENABLE_PAGE0
 158+ 558A              .RET:
 159+ 558A FB           	EI
 160+ 558B DD 6E 02     	LD L,(IX+2)
 161+ 558E DD 66 03     	LD H,(IX+3)
 162+ 5591 DD 4E 04     	LD C,(IX+4)
 163+ 5594 DD 46 05     	LD B,(IX+5)
 164+ 5597 78           	LD A,B
 165+ 5598 B1           	OR C
 166+ 5599 28 06        	JR Z,.EXIT
 167+ 559B DD 56 06     	LD D,(IX+6)
 168+ 559E CD A8 55     	CALL FILVRM_FILLVALUE
 169+ 55A1              .EXIT:
 170+ 55A1 D1               POP DE
 171+ 55A2 C1               POP BC
 172+ 55A3 CD 1B 60         CALL RESTORE_PAGE_INFO
 173+ 55A6 AF           	XOR A ; success
 174+ 55A7 C9           	RET
 175+ 55A8              ; *******************************************************************************************************
 176+ 55A8               ENDIF
 177+ 55A8
 178+ 55A8              ; *******************************************************************************************************
 179+ 55A8              ; common function to fill RAM
 180+ 55A8              FILVRM_FILLVALUE:
 181+ 55A8 72               LD (HL), D
 182+ 55A9 54               LD D, H
 183+ 55AA 5D               LD E, L
 184+ 55AB 13               INC DE
 185+ 55AC 0B               DEC BC
 186+ 55AD 78           	LD A,B
 187+ 55AE B1           	OR C
 188+ 55AF C8           	RET Z ; if count was 1
 189+ 55B0 ED B0            LDIR
 190+ 55B2 C9               RET
 191+ 55B3              ; *******************************************************************************************************
# file closed: asm\MEMORY.asm
 144  55B3               ENDIF
 145  55B3
 146  55B3               IF (SOUND_CMDS == 1)
 147  55B3               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
   1+ 55B3              MUSIC_INIT_STATUS:
   2+ 55B3 00            DB 0
   3+ 55B4              SFX_INIT_STATUS:
   4+ 55B4 00            DB 0
   5+ 55B5              SOUND_ENABLED:
   6+ 55B5 00            DB 0
   7+ 55B6
   8+ 55B6               IF (0 == 1)
   9+ 55B6 ~            ; *******************************************************************************************************
  10+ 55B6 ~            ; function to handle CALL SNDPLYINIT basic extension
  11+ 55B6 ~            ; initializes sound player
  12+ 55B6 ~            ; _SNDPLYINIT ( INT music_offset,
  13+ 55B6 ~            ;				INT sfx_offset, can be -1 if no SFX
  14+ 55B6 ~            ; will put ram in page 0 also, page 1 is already there
  15+ 55B6 ~            ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
  16+ 55B6 ~            SNDPLYINIT:
  17+ 55B6 ~            	; opening (
  18+ 55B6 ~            	CALL CHKCHAR
  19+ 55B6 ~            	DB '('
  20+ 55B6 ~            	; get music address
  21+ 55B6 ~            	LD IX, FRMQNT
  22+ 55B6 ~            	CALL CALBAS
  23+ 55B6 ~            	PUSH DE
  24+ 55B6 ~            	; comma
  25+ 55B6 ~            	CALL CHKCHAR
  26+ 55B6 ~            	DB ','
  27+ 55B6 ~            	; get sfx address
  28+ 55B6 ~            	LD IX, FRMQNT
  29+ 55B6 ~            	CALL CALBAS
  30+ 55B6 ~            	PUSH DE
  31+ 55B6 ~            	; ending )
  32+ 55B6 ~            	CALL CHKCHAR
  33+ 55B6 ~            	DB ')'
  34+ 55B6 ~
  35+ 55B6 ~                ; save position in BASIC text
  36+ 55B6 ~            	LD B, H
  37+ 55B6 ~            	LD C, L
  38+ 55B6 ~
  39+ 55B6 ~            	; pop LDIR parameters and store away for later
  40+ 55B6 ~            	POP DE ; sfx address
  41+ 55B6 ~            	POP HL ; music address
  42+ 55B6 ~            	PUSH BC ; basic text location
  43+ 55B6 ~            	EXX
  44+ 55B6 ~            	LD IY, .RET
  45+ 55B6 ~            	JP ENABLE_PAGE0
  46+ 55B6 ~            .RET:
  47+ 55B6 ~            	EXX
  48+ 55B6 ~
  49+ 55B6 ~            	PUSH DE
  50+ 55B6 ~            	XOR A
  51+ 55B6 ~            	; HL = music location
  52+ 55B6 ~            	CALL PLY_AKG_INIT
  53+ 55B6 ~            	LD A, 1
  54+ 55B6 ~            	LD (MUSIC_INIT_STATUS), A
  55+ 55B6 ~
  56+ 55B6 ~            	POP HL ; SFX
  57+ 55B6 ~            	; check if SFX address -1
  58+ 55B6 ~            	INC HL
  59+ 55B6 ~            	LD A, L
  60+ 55B6 ~            	OR H
  61+ 55B6 ~            	JR Z,.L1
  62+ 55B6 ~            	DEC HL
  63+ 55B6 ~            	CALL PLY_AKG_INITSOUNDEFFECTS
  64+ 55B6 ~            	LD A, 1
  65+ 55B6 ~            	LD (SFX_INIT_STATUS), A
  66+ 55B6 ~            .L1:
  67+ 55B6 ~                POP DE
  68+ 55B6 ~                POP BC
  69+ 55B6 ~                CALL RESTORE_PAGE_INFO
  70+ 55B6 ~
  71+ 55B6 ~            	POP HL
  72+ 55B6 ~            	RET
  73+ 55B6 ~            ; *******************************************************************************************************
  74+ 55B6               ENDIF
  75+ 55B6
  76+ 55B6               IF (1 == 1)
  77+ 55B6              ; *******************************************************************************************************
  78+ 55B6              ; same as SNDPLYINI but for DEFUSR approach
  79+ 55B6              ; input IX=pointer to input array, real data from +2
  80+ 55B6              ; +2 = music address
  81+ 55B6              ; +4 = sfx address
  82+ 55B6              SNDPLYINI_DEFUSR:
  83+ 55B6 FD 21 BD 55  	LD IY, .RET
  84+ 55BA C3 A4 60     	JP ENABLE_PAGE0
  85+ 55BD              .RET:
  86+ 55BD AF           	XOR A
  87+ 55BE DD 6E 02     	LD L,(IX+2)
  88+ 55C1 DD 66 03     	LD H,(IX+3)
  89+ 55C4 DD E5        	PUSH IX
  90+ 55C6 CD 65 41     	CALL PLY_AKG_INIT
  91+ 55C9 DD E1        	POP IX
  92+ 55CB 3E 01        	LD A, 1
  93+ 55CD 32 B3 55     	LD (MUSIC_INIT_STATUS), A
  94+ 55D0
  95+ 55D0 DD 6E 04     	LD L,(IX+4)
  96+ 55D3 DD 66 05     	LD H,(IX+5)
  97+ 55D6              	; check if SFX address -1
  98+ 55D6 23           	INC HL
  99+ 55D7 7D           	LD A, L
 100+ 55D8 B4           	OR H
 101+ 55D9 28 09        	JR Z,.L1
 102+ 55DB 2B           	DEC HL
 103+ 55DC CD 20 40     	CALL PLY_AKG_INITSOUNDEFFECTS
 104+ 55DF 3E 01        	LD A, 1
 105+ 55E1 32 B4 55     	LD (SFX_INIT_STATUS), A
 106+ 55E4              .L1:
 107+ 55E4 D1               POP DE
 108+ 55E5 C1               POP BC
 109+ 55E6 CD 1B 60         CALL RESTORE_PAGE_INFO
 110+ 55E9 AF           	XOR A ; success
 111+ 55EA C9           	RET
 112+ 55EB              ; *******************************************************************************************************
 113+ 55EB               ENDIF
 114+ 55EB
 115+ 55EB              ; *******************************************************************************************************
 116+ 55EB              ; function to handle CALL SNDPLYON basic extension
 117+ 55EB              ; enables sound player
 118+ 55EB              ; _SNDPLYON
 119+ 55EB              ; sets SOUND_ENABLED variable to 1 if init call was done
 120+ 55EB              ; if not throws out of data error
 121+ 55EB              SNDPLYON_DEFUSR:
 122+ 55EB              SNDPLYON:
 123+ 55EB 3A B3 55     	LD A, (MUSIC_INIT_STATUS)
 124+ 55EE B7           	OR A
 125+ 55EF               IF (0 == 1)
 126+ 55EF ~            	JP Z, OUT_OF_DATA ; player not initialized, throw error
 127+ 55EF               ENDIF
 128+ 55EF               IF (1 == 1)
 129+ 55EF 28 08        	JR Z,.ERR
 130+ 55F1               ENDIF
 131+ 55F1              .L1:
 132+ 55F1 32 B5 55     	LD (SOUND_ENABLED), A
 133+ 55F4              	; disable key click
 134+ 55F4 AF           	XOR A
 135+ 55F5 32 DB F3     	LD (CLIKSW), A
 136+ 55F8 C9           	RET
 137+ 55F9              .ERR:
 138+ 55F9 3E 01        	LD A,1
 139+ 55FB C9           	RET
 140+ 55FC              ; *******************************************************************************************************
 141+ 55FC
 142+ 55FC              ; *******************************************************************************************************
 143+ 55FC              ; function to handle CALL SNDPLYOFF basic extension
 144+ 55FC              ; disables sound player
 145+ 55FC              ; _SNDPLYOFF
 146+ 55FC              ; sets SOUND_ENABLED variable to 0
 147+ 55FC              ; calls AKG to stop music and SFX on all channels if initialized
 148+ 55FC              SNDPLYOFF_DEFUSR:
 149+ 55FC              SNDPLYOFF:
 150+ 55FC 3A B5 55     	LD A, (SOUND_ENABLED)
 151+ 55FF B7           	OR A
 152+ 5600 C8           	RET Z ; already stopped
 153+ 5601 AF           	XOR A
 154+ 5602 32 B5 55     	LD (SOUND_ENABLED), A
 155+ 5605 E5           	PUSH HL
 156+ 5606 CD 24 42     	CALL PLY_AKG_STOP
 157+ 5609 3A B4 55     	LD A, (SFX_INIT_STATUS)
 158+ 560C B7           	OR A
 159+ 560D 28 0E        	JR Z, .EXIT ; SFX not in use
 160+ 560F AF           	XOR A
 161+ 5610 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 162+ 5613 3E 01        	LD A, 1
 163+ 5615 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 164+ 5618 3E 02        	LD A, 2
 165+ 561A CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 166+ 561D              .EXIT:
 167+ 561D E1           	POP HL
 168+ 561E AF           	XOR A ; success
 169+ 561F C9           	RET
 170+ 5620              ; *******************************************************************************************************
 171+ 5620
 172+ 5620               IF (0 == 1)
 173+ 5620 ~            ; *******************************************************************************************************
 174+ 5620 ~            ; function to handle CALL SNDSFX basic extension
 175+ 5620 ~            ; plays a sound effect
 176+ 5620 ~            ; _SNDSFX ( BYTE sfx_number, >0
 177+ 5620 ~            ;			BYTE channel, = 0,1 or 2
 178+ 5620 ~            ;			BYTE inverted_volume = 0-16, 0 being full volume
 179+ 5620 ~            ; will put ram in page 0 also, page 1 is already there
 180+ 5620 ~            ; if sound off throws illegal function call
 181+ 5620 ~            ; if sfx not initialized, throws out of data
 182+ 5620 ~            SNDSFX:
 183+ 5620 ~            	; opening (
 184+ 5620 ~            	CALL CHKCHAR
 185+ 5620 ~            	DB '('
 186+ 5620 ~            	; get sfx_number
 187+ 5620 ~            	LD IX, GETBYT
 188+ 5620 ~            	CALL CALBAS
 189+ 5620 ~            	PUSH DE
 190+ 5620 ~            	; comma
 191+ 5620 ~            	CALL CHKCHAR
 192+ 5620 ~            	DB ','
 193+ 5620 ~            	; get sfx address
 194+ 5620 ~            	LD IX, GETBYT
 195+ 5620 ~            	CALL CALBAS
 196+ 5620 ~            	PUSH DE
 197+ 5620 ~            	; comma
 198+ 5620 ~            	CALL CHKCHAR
 199+ 5620 ~            	DB ','
 200+ 5620 ~            	; get inverted volume
 201+ 5620 ~            	LD IX, GETBYT
 202+ 5620 ~            	CALL CALBAS
 203+ 5620 ~            	PUSH DE
 204+ 5620 ~            	; ending )
 205+ 5620 ~            	CALL CHKCHAR
 206+ 5620 ~            	DB ')'
 207+ 5620 ~
 208+ 5620 ~            	LD A, (SOUND_ENABLED)
 209+ 5620 ~            	OR A
 210+ 5620 ~            	JR NZ, .L1
 211+ 5620 ~            	; sound disabled, throw illegal function call
 212+ 5620 ~            	LD E, 5
 213+ 5620 ~            	JP THROW_ERROR
 214+ 5620 ~            .L1:
 215+ 5620 ~            	LD A, (SFX_INIT_STATUS)
 216+ 5620 ~            	OR A
 217+ 5620 ~            	JR NZ, .L2
 218+ 5620 ~            	; sfx data not initialized, throw out of data
 219+ 5620 ~            	LD E, 4
 220+ 5620 ~            	JP THROW_ERROR
 221+ 5620 ~            .L2:
 222+ 5620 ~            	; pop  parameters and store away for later
 223+ 5620 ~            	POP DE ; inverted volume
 224+ 5620 ~            	LD B, E
 225+ 5620 ~            	POP DE ; channel
 226+ 5620 ~            	LD C, E
 227+ 5620 ~            	POP DE
 228+ 5620 ~            	LD A, E
 229+ 5620 ~            	EX AF, AF'
 230+ 5620 ~            	PUSH HL ; basic text location
 231+ 5620 ~            	EXX
 232+ 5620 ~            	LD IY, .RET
 233+ 5620 ~            	JP ENABLE_PAGE0
 234+ 5620 ~            .RET:
 235+ 5620 ~            	EXX
 236+ 5620 ~            	EX AF, AF'
 237+ 5620 ~            	CALL PLY_AKG_PLAYSOUNDEFFECT
 238+ 5620 ~
 239+ 5620 ~                POP DE
 240+ 5620 ~                POP BC
 241+ 5620 ~                CALL RESTORE_PAGE_INFO
 242+ 5620 ~
 243+ 5620 ~            	POP HL
 244+ 5620 ~            	RET
 245+ 5620 ~            ; *******************************************************************************************************
 246+ 5620               ENDIF
 247+ 5620
 248+ 5620               IF (1 == 1)
 249+ 5620              ; *******************************************************************************************************
 250+ 5620              ; same as SNDSFX but for DEFUSR approach
 251+ 5620              ; input IX=pointer to input array, real data from +2
 252+ 5620              ; +2 = SFX number
 253+ 5620              ; +4 = channel
 254+ 5620              ; +6 = volume
 255+ 5620              SNDSFX_DEFUSR:
 256+ 5620 3A B5 55     	LD A, (SOUND_ENABLED)
 257+ 5623 B7           	OR A
 258+ 5624 C8           	RET Z ; sound disabled, just exit
 259+ 5625 3A B4 55     	LD A, (SFX_INIT_STATUS)
 260+ 5628 B7           	OR A
 261+ 5629 C8           	RET Z ; sfx data not initialized, just exit
 262+ 562A FD 21 31 56  	LD IY, .RET
 263+ 562E C3 A4 60     	JP ENABLE_PAGE0
 264+ 5631              .RET:
 265+ 5631 FB           	EI
 266+ 5632 DD 7E 02     	LD A,(IX+2) ; SFX number
 267+ 5635 DD 4E 04     	LD C,(IX+4) ; channel
 268+ 5638 DD 46 06     	LD B,(IX+6) ; volume
 269+ 563B CD 24 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
 270+ 563E D1               POP DE
 271+ 563F C1               POP BC
 272+ 5640 CD 1B 60         CALL RESTORE_PAGE_INFO
 273+ 5643 AF           	XOR A ; success
 274+ 5644 C9           	RET
 275+ 5645              ; *******************************************************************************************************
 276+ 5645               ENDIF
# file closed: asm\SOUND.asm
 148  5645               ENDIF
 149  5645
 150  5645               IF (VRAM_CMDS == 1)
 151  5645               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
   1+ 5645               IF (0 == 1)
   2+ 5645 ~            ; *******************************************************************************************************
   3+ 5645 ~            ; function to handle CALL FILVRM basic extension
   4+ 5645 ~            ; FILVRM ( INT offset,
   5+ 5645 ~            ;		   INT count,
   6+ 5645 ~            ;		   BYTE value,
   7+ 5645 ~            ;		   BYTE wait_vsync) >0 = true
   8+ 5645 ~            ; wait_vsync will issue HALT before copying
   9+ 5645 ~            FILVRM:
  10+ 5645 ~            	; opening (
  11+ 5645 ~            	CALL CHKCHAR
  12+ 5645 ~            	DB '('
  13+ 5645 ~            	; get offset address
  14+ 5645 ~            	LD IX, FRMQNT
  15+ 5645 ~            	CALL CALBAS
  16+ 5645 ~            	PUSH DE
  17+ 5645 ~            	; comma
  18+ 5645 ~            	CALL CHKCHAR
  19+ 5645 ~            	DB ','
  20+ 5645 ~            	; get count
  21+ 5645 ~            	LD IX, FRMQNT
  22+ 5645 ~            	CALL CALBAS
  23+ 5645 ~            	PUSH DE
  24+ 5645 ~            	; comma
  25+ 5645 ~            	CALL CHKCHAR
  26+ 5645 ~            	DB ','
  27+ 5645 ~            	; get value
  28+ 5645 ~            	LD IX, GETBYT
  29+ 5645 ~            	CALL CALBAS
  30+ 5645 ~            	PUSH AF
  31+ 5645 ~            	; comma
  32+ 5645 ~            	CALL CHKCHAR
  33+ 5645 ~            	DB ','
  34+ 5645 ~            	; get vsync wait
  35+ 5645 ~            	LD IX, GETBYT
  36+ 5645 ~            	CALL CALBAS
  37+ 5645 ~            	PUSH AF
  38+ 5645 ~            	; ending )
  39+ 5645 ~            	CALL CHKCHAR
  40+ 5645 ~            	DB ')'
  41+ 5645 ~
  42+ 5645 ~            	; save position
  43+ 5645 ~            	PUSH HL
  44+ 5645 ~            	POP IX
  45+ 5645 ~
  46+ 5645 ~            	; syntax ok
  47+ 5645 ~            	; wait for vsync if needed
  48+ 5645 ~            	POP AF
  49+ 5645 ~            	OR A
  50+ 5645 ~            	JR Z, .L1
  51+ 5645 ~            	HALT
  52+ 5645 ~
  53+ 5645 ~            .L1:
  54+ 5645 ~            	LD A,1
  55+ 5645 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  56+ 5645 ~                POP AF ; value
  57+ 5645 ~                POP BC ; count
  58+ 5645 ~                POP HL ; offset
  59+ 5645 ~                CALL BIOS_FILVRM
  60+ 5645 ~            	XOR A
  61+ 5645 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  62+ 5645 ~
  63+ 5645 ~            .L3:
  64+ 5645 ~            	PUSH IX
  65+ 5645 ~            	POP HL
  66+ 5645 ~            	RET
  67+ 5645 ~            ; *******************************************************************************************************
  68+ 5645               ENDIF
  69+ 5645
  70+ 5645               IF (1 == 1)
  71+ 5645              ; *******************************************************************************************************
  72+ 5645              ; same as FILVRM but for DEFUSR approach
  73+ 5645              ; input IX=pointer to input array, real data from +2
  74+ 5645              ; +2 = offset
  75+ 5645              ; +4 = count
  76+ 5645              ; +6 = value
  77+ 5645              ; +8 = halt flag
  78+ 5645              FILVRM_DEFUSR:
  79+ 5645 DD 7E 08     	LD A,(IX+8)
  80+ 5648 B7           	OR A
  81+ 5649 28 01        	JR Z,.L0
  82+ 564B 76           	HALT
  83+ 564C              .L0:
  84+ 564C 3E 01        	LD A,1
  85+ 564E 32 81 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
  86+ 5651 DD 6E 02     	LD L,(IX+2)
  87+ 5654 DD 66 03     	LD H,(IX+3)
  88+ 5657 DD 4E 04     	LD C,(IX+4)
  89+ 565A DD 46 05     	LD B,(IX+5)
  90+ 565D DD 7E 06     	LD A,(IX+6)
  91+ 5660 CD 56 00     	CALL BIOS_FILVRM
  92+ 5663 AF           	XOR A
  93+ 5664 32 81 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
  94+ 5667 C9           	RET
  95+ 5668              ; *******************************************************************************************************
  96+ 5668               ENDIF
  97+ 5668
  98+ 5668               IF (0 == 1)
  99+ 5668 ~            ; *******************************************************************************************************
 100+ 5668 ~            ; function to handle CALL MEMVRM basic extension
 101+ 5668 ~            ; copies from RAM to VRAM
 102+ 5668 ~            ; if flag != 0 it will issue HALT before copying
 103+ 5668 ~            ; if bit 1 of flag set and sprite system initialized it will set sprite update flag
 104+ 5668 ~            ; _MEMVRM ( INT source,
 105+ 5668 ~            ;			INT destination,
 106+ 5668 ~            ;			INT count,
 107+ 5668 ~            ;			BYTE flag)
 108+ 5668 ~            ; will put ram in page 0 also, page 1 is already there
 109+ 5668 ~            MEMVRM:
 110+ 5668 ~            	; opening (
 111+ 5668 ~            	CALL CHKCHAR
 112+ 5668 ~            	DB '('
 113+ 5668 ~            	; get source address
 114+ 5668 ~            	LD IX, FRMQNT
 115+ 5668 ~            	CALL CALBAS
 116+ 5668 ~            	PUSH DE
 117+ 5668 ~            	; comma
 118+ 5668 ~            	CALL CHKCHAR
 119+ 5668 ~            	DB ','
 120+ 5668 ~            	; get destination address
 121+ 5668 ~            	LD IX, FRMQNT
 122+ 5668 ~            	CALL CALBAS
 123+ 5668 ~            	PUSH DE
 124+ 5668 ~            	; comma
 125+ 5668 ~            	CALL CHKCHAR
 126+ 5668 ~            	DB ','
 127+ 5668 ~            	; get length
 128+ 5668 ~            	LD IX, FRMQNT
 129+ 5668 ~            	CALL CALBAS
 130+ 5668 ~            	PUSH DE
 131+ 5668 ~            	; comma
 132+ 5668 ~            	CALL CHKCHAR
 133+ 5668 ~            	DB ','
 134+ 5668 ~            	; get vsync wait
 135+ 5668 ~            	LD IX, GETBYT
 136+ 5668 ~            	CALL CALBAS
 137+ 5668 ~            	PUSH AF
 138+ 5668 ~            	; ending )
 139+ 5668 ~            	CALL CHKCHAR
 140+ 5668 ~            	DB ')'
 141+ 5668 ~
 142+ 5668 ~                ; save position in BASIC text
 143+ 5668 ~            	PUSH HL
 144+ 5668 ~            	POP IX
 145+ 5668 ~
 146+ 5668 ~            	POP AF ; wait vsync
 147+ 5668 ~            	OR A
 148+ 5668 ~            	JR Z, .L1
 149+ 5668 ~            	; check for special case to set sprite update flag
 150+ 5668 ~            	IF (SPRITE_CMDS == 1)
 151+ 5668 ~            		AND 2
 152+ 5668 ~            		JR Z,.L2
 153+ 5668 ~            		LD A, (SPRATR_INIT_STATUS)
 154+ 5668 ~            		OR A
 155+ 5668 ~            		JR Z,.L2
 156+ 5668 ~            		LD HL,(SPRATR_UPDATE_FLAG)
 157+ 5668 ~            		LD (HL),A
 158+ 5668 ~            	ENDIF
 159+ 5668 ~            .L2:
 160+ 5668 ~            	HALT
 161+ 5668 ~            .L1:
 162+ 5668 ~            	; pop LDIR parameters and store away for later
 163+ 5668 ~            	POP BC ; count
 164+ 5668 ~            	POP DE ; vram destination
 165+ 5668 ~            	POP HL ; ram source
 166+ 5668 ~            	EXX
 167+ 5668 ~             	LD IY, .RET
 168+ 5668 ~            	JP ENABLE_PAGE0
 169+ 5668 ~            .RET:
 170+ 5668 ~            	EI
 171+ 5668 ~            	EXX
 172+ 5668 ~            	CALL VRAM_LDIRVM
 173+ 5668 ~                POP DE
 174+ 5668 ~                POP BC
 175+ 5668 ~                CALL RESTORE_PAGE_INFO
 176+ 5668 ~            	PUSH IX
 177+ 5668 ~            	POP HL
 178+ 5668 ~            	RET
 179+ 5668 ~            ; *******************************************************************************************************
 180+ 5668               ENDIF
 181+ 5668
 182+ 5668               IF (1 == 1)
 183+ 5668              ; *******************************************************************************************************
 184+ 5668              ; same as MEMVRM but for DEFUSR approach
 185+ 5668              ; input IX=pointer to input array, real data from +2
 186+ 5668              ; +2 = source address
 187+ 5668              ; +4 = destination address
 188+ 5668              ; +6 = lenght
 189+ 5668              ; +8 = flag
 190+ 5668              MEMVRM_DEFUSR:
 191+ 5668 DD 7E 08     	LD A,(IX+8)
 192+ 566B B7           	OR A
 193+ 566C 28 0F        	JR Z,.L0
 194+ 566E              	IF (SPRITE_CMDS == 1)
 195+ 566E E6 02        		AND 2
 196+ 5670 28 0A        		JR Z,.L2
 197+ 5672 3A 86 4D     		LD A, (SPRATR_INIT_STATUS)
 198+ 5675 B7           		OR A
 199+ 5676 28 04        		JR Z,.L2
 200+ 5678 2A 87 4D     		LD HL,(SPRATR_UPDATE_FLAG)
 201+ 567B 77           		LD (HL),A
 202+ 567C              	ENDIF
 203+ 567C              .L2:
 204+ 567C 76           	HALT
 205+ 567D              .L0:
 206+ 567D              	; enable page 0
 207+ 567D FD 21 84 56  	LD IY, .RET
 208+ 5681 C3 A4 60     	JP ENABLE_PAGE0
 209+ 5684              .RET:
 210+ 5684 FB           	EI
 211+ 5685 DD 6E 02     	LD L,(IX+2)
 212+ 5688 DD 66 03     	LD H,(IX+3)
 213+ 568B DD 5E 04     	LD E,(IX+4)
 214+ 568E DD 56 05     	LD D,(IX+5)
 215+ 5691 DD 4E 06     	LD C,(IX+6)
 216+ 5694 DD 46 07     	LD B,(IX+7)
 217+ 5697 CD A1 56     	CALL VRAM_LDIRVM
 218+ 569A              .COMMON:
 219+ 569A D1               POP DE
 220+ 569B C1               POP BC
 221+ 569C CD 1B 60         CALL RESTORE_PAGE_INFO
 222+ 569F AF           	XOR A ; success
 223+ 56A0 C9           	RET
 224+ 56A1              ; *******************************************************************************************************
 225+ 56A1               ENDIF
 226+ 56A1
 227+ 56A1              ; *******************************************************************************************************
 228+ 56A1              ; common code to copy from memory to VRAM
 229+ 56A1              ; input HL=RAM source
 230+ 56A1              ; input DE=VRAM destination
 231+ 56A1              ; BC=count
 232+ 56A1              VRAM_LDIRVM:
 233+ 56A1 3E 01        	LD A,1
 234+ 56A3 32 81 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 235+ 56A6 EB           	EX DE, HL
 236+ 56A7 F3           	DI
 237+ 56A8 CD C1 5F     	CALL SETWRT_LOCAL_WRITE
 238+ 56AB FB           	EI
 239+ 56AC EB           	EX DE, HL
 240+ 56AD 78           	LD A, B
 241+ 56AE B7           	OR A
 242+ 56AF 28 0D        	JR Z, .L3
 243+ 56B1 C5           	PUSH BC
 244+ 56B2 0E 98        	LD C, #98
 245+ 56B4              .L2:
 246+ 56B4 50           	LD D, B
 247+ 56B5 06 00        	LD B, 0
 248+ 56B7 CD D8 5F     	CALL BBYTECOPY_NO_C
 249+ 56BA 42           	LD B, D
 250+ 56BB 10 F7        	DJNZ .L2
 251+ 56BD C1           	POP BC
 252+ 56BE              .L3:
 253+ 56BE 79           	LD A, C
 254+ 56BF B7           	OR A
 255+ 56C0 28 04        	JR Z,.L4
 256+ 56C2 41           	LD B, C
 257+ 56C3 CD D6 5F     	CALL BBYTECOPY
 258+ 56C6              .L4:
 259+ 56C6 AF           	XOR A
 260+ 56C7 32 81 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 261+ 56CA C9           	RET
 262+ 56CB              ; *******************************************************************************************************
 263+ 56CB
 264+ 56CB               IF (0 == 1)
 265+ 56CB ~            ; *******************************************************************************************************
 266+ 56CB ~            ; function to handle CALL VRMMEM basic extension
 267+ 56CB ~            ; copies from VRAM to RAM
 268+ 56CB ~            ; _VRMMEM ( INT source,
 269+ 56CB ~            ;			INT destination,
 270+ 56CB ~            ;			INT count
 271+ 56CB ~            ; will put ram in page 0 also, page 1 is already there
 272+ 56CB ~            VRMMEM:
 273+ 56CB ~            	; opening (
 274+ 56CB ~            	CALL CHKCHAR
 275+ 56CB ~            	DB '('
 276+ 56CB ~            	; get source address
 277+ 56CB ~            	LD IX, FRMQNT
 278+ 56CB ~            	CALL CALBAS
 279+ 56CB ~            	PUSH DE
 280+ 56CB ~            	; comma
 281+ 56CB ~            	CALL CHKCHAR
 282+ 56CB ~            	DB ','
 283+ 56CB ~            	; get destination address
 284+ 56CB ~            	LD IX, FRMQNT
 285+ 56CB ~            	CALL CALBAS
 286+ 56CB ~            	PUSH DE
 287+ 56CB ~            	; comma
 288+ 56CB ~            	CALL CHKCHAR
 289+ 56CB ~            	DB ','
 290+ 56CB ~            	; get length
 291+ 56CB ~            	LD IX, FRMQNT
 292+ 56CB ~            	CALL CALBAS
 293+ 56CB ~            	PUSH DE
 294+ 56CB ~            	; ending )
 295+ 56CB ~            	CALL CHKCHAR
 296+ 56CB ~            	DB ')'
 297+ 56CB ~
 298+ 56CB ~                ; save position in BASIC text
 299+ 56CB ~            	PUSH HL
 300+ 56CB ~            	POP IX
 301+ 56CB ~
 302+ 56CB ~            	POP BC ; count
 303+ 56CB ~            	POP DE ; destination
 304+ 56CB ~            	POP HL ; source
 305+ 56CB ~            	EXX
 306+ 56CB ~            	LD IY, .RET
 307+ 56CB ~            	JP ENABLE_PAGE0
 308+ 56CB ~            .RET:
 309+ 56CB ~            	EI
 310+ 56CB ~            	EXX
 311+ 56CB ~            	CALL VRAM_LDIRMV
 312+ 56CB ~                POP DE
 313+ 56CB ~                POP BC
 314+ 56CB ~                CALL RESTORE_PAGE_INFO
 315+ 56CB ~            	PUSH IX
 316+ 56CB ~            	POP HL
 317+ 56CB ~            	RET
 318+ 56CB ~            ; *******************************************************************************************************
 319+ 56CB               ENDIF
 320+ 56CB
 321+ 56CB               IF (1 == 1)
 322+ 56CB              ; *******************************************************************************************************
 323+ 56CB              ; same as VRMMEM but for DEFUSR approach
 324+ 56CB              ; input IX=pointer to input array, real data from +2
 325+ 56CB              ; +2 = source address
 326+ 56CB              ; +4 = destination address
 327+ 56CB              ; +6 = count
 328+ 56CB              VRMMEM_DEFUSR:
 329+ 56CB              	; enable page 0
 330+ 56CB FD 21 D2 56  	LD IY, .RET
 331+ 56CF C3 A4 60     	JP ENABLE_PAGE0
 332+ 56D2              .RET:
 333+ 56D2 FB           	EI
 334+ 56D3 DD 6E 02     	LD L,(IX+2)
 335+ 56D6 DD 66 03     	LD H,(IX+3)
 336+ 56D9 DD 5E 04     	LD E,(IX+4)
 337+ 56DC DD 56 05     	LD D,(IX+5)
 338+ 56DF DD 4E 06     	LD C,(IX+6)
 339+ 56E2 DD 46 07     	LD B,(IX+7)
 340+ 56E5 CD EA 56     	CALL VRAM_LDIRMV
 341+ 56E8 18 B0        	JR MEMVRM_DEFUSR.COMMON
 342+ 56EA              ; *******************************************************************************************************
 343+ 56EA               ENDIF
 344+ 56EA
 345+ 56EA              ; *******************************************************************************************************
 346+ 56EA              ; common code to copy from VRAM to RAM
 347+ 56EA              ; input HL=VRAM source
 348+ 56EA              ; input DE=RAM destination
 349+ 56EA              ; BC=count
 350+ 56EA              VRAM_LDIRMV:
 351+ 56EA 3E 01        	LD A,1
 352+ 56EC 32 81 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 353+ 56EF 7D           	LD	A, L
 354+ 56F0 F3           	DI
 355+ 56F1 CD CC 5F     	CALL SETWRT_LOCAL_READ
 356+ 56F4 FB           	EI
 357+ 56F5 00           	NOP
 358+ 56F6 00           	NOP
 359+ 56F7 00           	NOP ; too fast VDP access per openMSX
 360+ 56F8              .L4:
 361+ 56F8 DB 98            IN A, (#98)
 362+ 56FA 12           	LD (DE), A
 363+ 56FB 13               INC DE
 364+ 56FC 0B               DEC BC
 365+ 56FD 79               LD A, C
 366+ 56FE B0               OR B
 367+ 56FF 20 F7            JR NZ, .L4
 368+ 5701 AF           	XOR A
 369+ 5702 32 81 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 370+ 5705 C9               RET
 371+ 5706              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
 152  5706               ENDIF
 153  5706
 154  5706               IF (GENCAL_CMD == 1)
 155  5706               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
   1+ 5706               IF (1 == 1)
   2+ 5706              ; *******************************************************************************************************
   3+ 5706              ; same as GENCAL but for DEFUSR approach
   4+ 5706              ; input IX=pointer to input array, real data from +2
   5+ 5706              ; +2 = function address to call
   6+ 5706              ; +4 = register list array pointer
   7+ 5706              GENCAL_DEFUSR:
   8+ 5706 DD 6E 02         LD L,(IX+2)
   9+ 5709 DD 66 03         LD H,(IX+3)
  10+ 570C E5               PUSH HL
  11+ 570D DD 6E 04         LD L,(IX+4)
  12+ 5710 DD 66 05         LD H,(IX+5)
  13+ 5713 E5               PUSH HL
  14+ 5714 18 00            JR GENCAL.COMMON
  15+ 5716              ; *******************************************************************************************************
  16+ 5716               ENDIF
  17+ 5716
  18+ 5716              ; *******************************************************************************************************
  19+ 5716              ; function to handle CALL GENCAL basic extension
  20+ 5716              ; GENCAL ( INT fn_addr, = address of the function to call
  21+ 5716              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
  22+ 5716              ; output values of registers will also be stored at reg_list_ptr
  23+ 5716              GENCAL:
  24+ 5716               IF (0 == 1)
  25+ 5716 ~            	; opening (
  26+ 5716 ~            	CALL CHKCHAR
  27+ 5716 ~            	DB '('
  28+ 5716 ~            	; get function address
  29+ 5716 ~            	LD IX, FRMQNT
  30+ 5716 ~            	CALL CALBAS
  31+ 5716 ~            	PUSH DE
  32+ 5716 ~            	; comma
  33+ 5716 ~            	CALL CHKCHAR
  34+ 5716 ~            	DB ','
  35+ 5716 ~            	; get pointer to register list
  36+ 5716 ~                LD A,2
  37+ 5716 ~                LD B,1
  38+ 5716 ~                LD DE,#0500
  39+ 5716 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
  40+ 5716 ~            	PUSH BC
  41+ 5716 ~            	; ending )
  42+ 5716 ~            	CALL CHKCHAR
  43+ 5716 ~            	DB ')'
  44+ 5716               ENDIF
  45+ 5716              .COMMON:
  46+ 5716              	; save BASIC token position
  47+ 5716 E5           	PUSH HL
  48+ 5717 D9               EXX
  49+ 5718 E1           	POP HL ; HL'=next basic token
  50+ 5719 D9               EXX
  51+ 571A
  52+ 571A E1               POP HL ; get pointer to register values
  53+ 571B F3           	DI
  54+ 571C ED 73 70 5F      LD (BLIT_STRUCT), SP
  55+ 5720 F9               LD SP, HL
  56+ 5721 F1               POP AF
  57+ 5722 C1               POP BC
  58+ 5723 D1               POP DE
  59+ 5724 E1               POP HL
  60+ 5725 DD E1            POP IX
  61+ 5727 FD E1            POP IY
  62+ 5729 D9               EXX
  63+ 572A ED 73 72 5F      LD (BLIT_STRUCT+2), SP
  64+ 572E ED 7B 70 5F      LD SP, (BLIT_STRUCT)
  65+ 5732 FB               EI
  66+ 5733 D1               POP DE ; get function to call
  67+ 5734 E5               PUSH HL
  68+ 5735 CD 51 57         CALL .EXXDECALL
  69+ 5738 F3               DI
  70+ 5739 ED 73 70 5F      LD (BLIT_STRUCT), SP
  71+ 573D ED 7B 72 5F      LD SP, (BLIT_STRUCT+2)
  72+ 5741 FD E5            PUSH IY
  73+ 5743 DD E5            PUSH IX
  74+ 5745 E5               PUSH HL
  75+ 5746 D5               PUSH DE
  76+ 5747 C5               PUSH BC
  77+ 5748 F5               PUSH AF
  78+ 5749 ED 7B 70 5F      LD SP, (BLIT_STRUCT)
  79+ 574D FB               EI
  80+ 574E E1               POP HL
  81+ 574F AF               XOR A ; success
  82+ 5750 C9           	RET
  83+ 5751
  84+ 5751              .EXXDECALL:
  85+ 5751 D5               PUSH DE
  86+ 5752 D9               EXX
  87+ 5753 C9               RET
  88+ 5754              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
 156  5754               ENDIF
 157  5754
 158  5754               IF (BOX_CMDS == 1)
 159  5754               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
   1+ 5754              ; *******************************************************************************************************
   2+ 5754              ; generic function to implement rectangle data copy
   3+ 5754              ; should be modified to call appropriate function for memory or vram
   4+ 5754              ; input IX=pointer to following structure
   5+ 5754              ; +00 source data pointer
   6+ 5754              ; +02 num bytes in a row
   7+ 5754              ; +04 number of rows
   8+ 5754              ; +06 source add-to value till next row
   9+ 5754              ; +08 destination address
  10+ 5754              ; +10 destination add-to value till next row
  11+ 5754              ; modifies AF, BC, DE, HL
  12+ 5754              RECTANGLE_COPY:
  13+ 5754 DD 6E 00     	LD L, (IX+0)
  14+ 5757 DD 66 01     	LD H, (IX+1) ; source address
  15+ 575A DD 5E 08     	LD E, (IX+8)
  16+ 575D DD 56 09     	LD D, (IX+9) ; destination
  17+ 5760 DD 46 04     	LD B, (IX+4) ; row number
  18+ 5763              .L1:
  19+ 5763 C5           	PUSH BC
  20+ 5764 E5           		PUSH HL
  21+ 5765 D5           			PUSH DE
  22+ 5766 DD 4E 02     				LD C, (IX+2)
  23+ 5769 DD 46 03     				LD B, (IX+3) ; num bytes in a row
  24+ 576C              .CALL1:
  25+ 576C CD 00 00     				CALL 0 ; set destination address from DE
  26+ 576F              .CALL2:
  27+ 576F CD 00 00     				CALL 0 ; copy data fn
  28+ 5772 E1           			POP HL
  29+ 5773 DD 4E 0A     			LD C, (IX+10)
  30+ 5776 DD 46 0B     			LD B, (IX+11) ; destination add-to
  31+ 5779 09           			ADD HL, BC
  32+ 577A EB           			EX DE, HL
  33+ 577B E1           		POP HL
  34+ 577C DD 4E 06     		LD C, (IX+6)
  35+ 577F DD 46 07     		LD B, (IX+7) ; src add-to
  36+ 5782 09           		ADD HL, BC
  37+ 5783 C1           	POP BC
  38+ 5784 10 DD        	DJNZ .L1
  39+ 5786 C9           	RET
  40+ 5787              ; *******************************************************************************************************
  41+ 5787
  42+ 5787               IF (0 == 1)
  43+ 5787 ~            ; *******************************************************************************************************
  44+ 5787 ~            ; function to handle CALL BOXMEMCPY basic extension
  45+ 5787 ~            ; copies data with window like boundaries within ram
  46+ 5787 ~            ; BOXMEMCPY ( INT source data pointer,
  47+ 5787 ~            ;			  INT source number of bytes in a row,
  48+ 5787 ~            ;			  INT number of rows,
  49+ 5787 ~            ;			  INT source add-to value till next row,
  50+ 5787 ~            ; 			  INT destination pointer,
  51+ 5787 ~            ;			  INT destination add-to value till next row )
  52+ 5787 ~            ; request_data_ptr described in RECTANGLE_COPY
  53+ 5787 ~            ; will put ram in page 0 also, page 1 is already there
  54+ 5787 ~            BOXMEMCPY:
  55+ 5787 ~            	LD DE,BOXMEMCPY_COMMON
  56+ 5787 ~            	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
  57+ 5787 ~            	JP BOX_EXTENSION_PARAMS_COMMON
  58+ 5787               ENDIF
  59+ 5787
  60+ 5787               IF (1 == 1)
  61+ 5787              ; *******************************************************************************************************
  62+ 5787              ; same as BOXMEMCPY but for DEFUSR approach
  63+ 5787              ; input IX=pointer to input array, real data from +2
  64+ 5787              ; +02 = source data pointer
  65+ 5787              ; +04 = source number of bytes in a row
  66+ 5787              ; +06 = number of rows
  67+ 5787              ; +08 = source add-to value till next row
  68+ 5787              ; +10 = destination pointer
  69+ 5787              ; +12 = destination add-to value till next row
  70+ 5787              BOXMEMCPY_DEFUSR:
  71+ 5787 21 94 57     	LD HL,BOXMEMCPY_COMMON
  72+ 578A 22 AA 57     	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
  73+ 578D DD 23        	INC IX
  74+ 578F DD 23        	INC IX
  75+ 5791 C3 A7 57     	JP BOXCOMMON_DEFUSR
  76+ 5794               ENDIF
  77+ 5794
  78+ 5794              BOXMEMCPY_COMMON:
  79+ 5794 FB           	EI
  80+ 5795              	; set RAM functions to call
  81+ 5795 21 00 00     	LD HL, 0
  82+ 5798 22 6C 57     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
  83+ 579B 22 6E 57     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
  84+ 579E 21 ED B0     	LD HL, #B0ED ; LDIR
  85+ 57A1 22 70 57     	LD (RECTANGLE_COPY.CALL1+4), HL
  86+ 57A4 C3 AF 57     	JP BOXCOMMON_DEFUSR.CALL
  87+ 57A7              ; *******************************************************************************************************
  88+ 57A7
  89+ 57A7               IF (0 == 1)
  90+ 57A7 ~            ; *******************************************************************************************************
  91+ 57A7 ~            ; common parts of BOX commands to load parameters
  92+ 57A7 ~            BOX_EXTENSION_PARAMS_COMMON:
  93+ 57A7 ~            	; opening (
  94+ 57A7 ~            	CALL CHKCHAR
  95+ 57A7 ~            	DB '('
  96+ 57A7 ~            	; get source data pointer
  97+ 57A7 ~            	LD IX, FRMQNT
  98+ 57A7 ~            	CALL CALBAS
  99+ 57A7 ~            	LD (BLIT_STRUCT+0), DE
 100+ 57A7 ~            	; comma
 101+ 57A7 ~            	CALL CHKCHAR
 102+ 57A7 ~            	DB ','
 103+ 57A7 ~            	; source number of bytes in a row
 104+ 57A7 ~            	LD IX, FRMQNT
 105+ 57A7 ~            	CALL CALBAS
 106+ 57A7 ~            	LD (BLIT_STRUCT+2), DE
 107+ 57A7 ~            	; comma
 108+ 57A7 ~            	CALL CHKCHAR
 109+ 57A7 ~            	DB ','
 110+ 57A7 ~            	; number of rows
 111+ 57A7 ~            	LD IX, FRMQNT
 112+ 57A7 ~            	CALL CALBAS
 113+ 57A7 ~            	LD (BLIT_STRUCT+4), DE
 114+ 57A7 ~            	; comma
 115+ 57A7 ~            	CALL CHKCHAR
 116+ 57A7 ~            	DB ','
 117+ 57A7 ~            	; source add-to value till next row
 118+ 57A7 ~            	LD IX, FRMQNT
 119+ 57A7 ~            	CALL CALBAS
 120+ 57A7 ~            	LD (BLIT_STRUCT+6), DE
 121+ 57A7 ~            	; comma
 122+ 57A7 ~            	CALL CHKCHAR
 123+ 57A7 ~            	DB ','
 124+ 57A7 ~            	; destination pointer
 125+ 57A7 ~            	LD IX, FRMQNT
 126+ 57A7 ~            	CALL CALBAS
 127+ 57A7 ~            	LD (BLIT_STRUCT+8), DE
 128+ 57A7 ~            	; comma
 129+ 57A7 ~            	CALL CHKCHAR
 130+ 57A7 ~            	DB ','
 131+ 57A7 ~            	; destination add-to value till next row
 132+ 57A7 ~            	LD IX, FRMQNT
 133+ 57A7 ~            	CALL CALBAS
 134+ 57A7 ~            	LD (BLIT_STRUCT+10), DE
 135+ 57A7 ~            	; ending )
 136+ 57A7 ~            	CALL CHKCHAR
 137+ 57A7 ~            	DB ')'
 138+ 57A7 ~            	LD IX,BLIT_STRUCT
 139+ 57A7               ENDIF
 140+ 57A7              BOXCOMMON_DEFUSR:
 141+ 57A7 E5           	PUSH HL ; save position in BASIC buffer
 142+ 57A8              .ADDR:
 143+ 57A8 FD 21 00 00  	LD IY, 0 ; modified by code
 144+ 57AC C3 A4 60     	JP ENABLE_PAGE0
 145+ 57AF              .CALL:
 146+ 57AF CD 54 57     	CALL RECTANGLE_COPY
 147+ 57B2 AF           	XOR A
 148+ 57B3 32 81 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 149+ 57B6
 150+ 57B6 D1               POP DE
 151+ 57B7 C1               POP BC
 152+ 57B8 CD 1B 60         CALL RESTORE_PAGE_INFO
 153+ 57BB
 154+ 57BB E1           	POP HL
 155+ 57BC AF           	XOR A ; success
 156+ 57BD C9           	RET
 157+ 57BE              ; *******************************************************************************************************
 158+ 57BE
 159+ 57BE               IF (0 == 1)
 160+ 57BE ~            ; *******************************************************************************************************
 161+ 57BE ~            ; function to handle CALL BOXMEMVRM basic extension
 162+ 57BE ~            ; copies data with window like boundaries from ram to Vram
 163+ 57BE ~            ; BOXMEMVRM ( INT source data pointer,
 164+ 57BE ~            ;			  INT source number of bytes in a row,
 165+ 57BE ~            ;			  INT number of rows,
 166+ 57BE ~            ;			  INT source add-to value till next row,
 167+ 57BE ~            ; 			  INT destination pointer,
 168+ 57BE ~            ;			  INT destination add-to value till next row )
 169+ 57BE ~            ; request_data_ptr described in RECTANGLE_COPY
 170+ 57BE ~            ; will put ram in page 0 also, page 1 is already there
 171+ 57BE ~            BOXMEMVRM:
 172+ 57BE ~            	LD DE,BOXMEMVRM_COMMON
 173+ 57BE ~            	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
 174+ 57BE ~            	JP BOX_EXTENSION_PARAMS_COMMON
 175+ 57BE               ENDIF
 176+ 57BE
 177+ 57BE               IF (1 == 1)
 178+ 57BE              ; *******************************************************************************************************
 179+ 57BE              ; same as BOXMEMVRM but for DEFUSR approach
 180+ 57BE              ; input IX=pointer to input array, real data from +2
 181+ 57BE              ; +02 = source data pointer
 182+ 57BE              ; +04 = source number of bytes in a row
 183+ 57BE              ; +06 = number of rows
 184+ 57BE              ; +08 = source add-to value till next row
 185+ 57BE              ; +10 = destination pointer
 186+ 57BE              ; +12 = destination add-to value till next row
 187+ 57BE              BOXMEMVRM_DEFUSR:
 188+ 57BE 21 CB 57     	LD HL,BOXMEMVRM_COMMON
 189+ 57C1 22 AA 57     	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
 190+ 57C4 DD 23        	INC IX
 191+ 57C6 DD 23        	INC IX
 192+ 57C8 C3 A7 57     	JP BOXCOMMON_DEFUSR
 193+ 57CB               ENDIF
 194+ 57CB
 195+ 57CB              BOXMEMVRM_COMMON:
 196+ 57CB FB           	EI
 197+ 57CC              	; set RAM functions to call
 198+ 57CC 21 E6 57     	LD HL, .SETDEST
 199+ 57CF 22 6D 57     	LD (RECTANGLE_COPY.CALL1+1), HL
 200+ 57D2 21 EE 57     	LD HL, .COPYDATA
 201+ 57D5 22 70 57     	LD (RECTANGLE_COPY.CALL2+1), HL
 202+ 57D8 3E CD        	LD A, #CD ; CALL
 203+ 57DA 32 6C 57     	LD (RECTANGLE_COPY.CALL1), A
 204+ 57DD 32 6F 57     	LD (RECTANGLE_COPY.CALL2), A
 205+ 57E0              	;LD A,1
 206+ 57E0 32 81 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 207+ 57E3 C3 AF 57     	JP BOXCOMMON_DEFUSR.CALL
 208+ 57E6              .SETDEST:
 209+ 57E6 EB           	EX DE, HL
 210+ 57E7 F3           	DI
 211+ 57E8 CD C1 5F     	CALL SETWRT_LOCAL_WRITE
 212+ 57EB FB           	EI
 213+ 57EC EB           	EX DE, HL
 214+ 57ED C9           	RET
 215+ 57EE              .COPYDATA:
 216+ 57EE 41           	LD B, C
 217+ 57EF C3 D6 5F     	JP BBYTECOPY
 218+ 57F2              ; *******************************************************************************************************
# file closed: asm\BOX.asm
 160  57F2               ENDIF
 161  57F2
 162  57F2               IF (BLIT_CMDS == 1)
 163  57F2               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
   1+ 57F2              ; *******************************************************************************************************
   2+ 57F2              ; function rotates mask and data of several characters and applies to background data
   3+ 57F2              ; this handles x-shift from 0 to 4
   4+ 57F2              ; contains self-modifying code that is set-up from external function
   5+ 57F2              ; input HL=pointer to mask data
   6+ 57F2              ; input HL'=pointer to character data
   7+ 57F2              ; input DE=output buffer containing background data
   8+ 57F2              ; input BC=DE+8
   9+ 57F2              ; input A=number of characters to process
  10+ 57F2              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  11+ 57F2              SHIFT04:
  12+ 57F2 08           	EX AF, AF'
  13+ 57F3 7E           	LD A, (HL) ; get mask
  14+ 57F4 D9           	EXX
  15+ 57F5 57           	LD D, A
  16+ 57F6 1E FF        	LD E, #FF
  17+ 57F8 37           	SCF
  18+ 57F9              .M1:
  19+ 57F9 18 FE        	JR .M1 ; this is self-modifying part
  20+ 57FB CB 1A        	RR D
  21+ 57FD CB 1B        	RR E
  22+ 57FF CB 1A        	RR D
  23+ 5801 CB 1B        	RR E
  24+ 5803 CB 1A        	RR D
  25+ 5805 CB 1B        	RR E
  26+ 5807 CB 1A        	RR D
  27+ 5809 CB 1B        	RR E
  28+ 580B
  29+ 580B 46           	LD B, (HL) ; get data
  30+ 580C 0E 00        	LD C, 0
  31+ 580E              .M2:
  32+ 580E 18 FE        	JR .M2 ; also self-modifying part
  33+ 5810 CB 38        	SRL B
  34+ 5812 CB 19        	RR C
  35+ 5814 CB 38        	SRL B
  36+ 5816 CB 19        	RR C
  37+ 5818 CB 38        	SRL B
  38+ 581A CB 19        	RR C
  39+ 581C CB 38        	SRL B
  40+ 581E CB 19        	RR C
  41+ 5820
  42+ 5820 D9           	EXX
  43+ 5821 1A           	LD A, (DE) ; background
  44+ 5822 D9           	EXX
  45+ 5823 A2           	AND D
  46+ 5824 B0           	OR B
  47+ 5825 D9           	EXX
  48+ 5826 12           	LD (DE), A
  49+ 5827
  50+ 5827 0A           	LD A, (BC)
  51+ 5828 D9           	EXX
  52+ 5829 A3           	AND E
  53+ 582A B1           	OR C
  54+ 582B 23           	INC HL
  55+ 582C D9           	EXX
  56+ 582D 02           	LD (BC), A
  57+ 582E
  58+ 582E 23           	INC HL
  59+ 582F 13           	INC DE
  60+ 5830 03           	INC BC
  61+ 5831
  62+ 5831 08           	EX AF, AF'
  63+ 5832 3D           	DEC A
  64+ 5833 C2 F2 57     	JP NZ, SHIFT04
  65+ 5836 C9           	RET
  66+ 5837              ; *******************************************************************************************************
  67+ 5837
  68+ 5837              ; *******************************************************************************************************
  69+ 5837              ; function rotates mask and data of several characters and applies to background data
  70+ 5837              ; this handles x-shift from 5 to 8
  71+ 5837              ; contains self-modifying code that is set-up from external function
  72+ 5837              ; input HL=pointer to mask data
  73+ 5837              ; input HL'=pointer to character data
  74+ 5837              ; input DE=output buffer containing background data
  75+ 5837              ; input BC=DE+8
  76+ 5837              ; input A=number of characters to process
  77+ 5837              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  78+ 5837              SHIFT58:
  79+ 5837 08           	EX AF, AF'
  80+ 5838 7E           	LD A, (HL) ; get mask
  81+ 5839 D9           	EXX
  82+ 583A 57           	LD D, A
  83+ 583B 1E FF        	LD E, #FF
  84+ 583D 37           	SCF
  85+ 583E              .M1:
  86+ 583E 18 FE        	JR .M1 ; this is self-modifying part
  87+ 5840 CB 12        	RL D
  88+ 5842 CB 13        	RL E
  89+ 5844 CB 12        	RL D
  90+ 5846 CB 13        	RL E
  91+ 5848 CB 12        	RL D
  92+ 584A CB 13        	RL E
  93+ 584C
  94+ 584C 46           	LD B, (HL)
  95+ 584D 0E 00        	LD C, 0
  96+ 584F              .M2:
  97+ 584F 18 FE        	JR .M2 ; also self-modifying part
  98+ 5851 CB 20        	SLA B
  99+ 5853 CB 11        	RL C
 100+ 5855 CB 20        	SLA B
 101+ 5857 CB 11        	RL C
 102+ 5859 CB 20        	SLA B
 103+ 585B CB 11        	RL C
 104+ 585D
 105+ 585D D9           	EXX
 106+ 585E 1A           	LD A, (DE) ; background
 107+ 585F D9           	EXX
 108+ 5860 A3           	AND E
 109+ 5861 B1           	OR C
 110+ 5862 D9           	EXX
 111+ 5863 12           	LD (DE), A
 112+ 5864
 113+ 5864 0A           	LD A, (BC)
 114+ 5865 D9           	EXX
 115+ 5866 A2           	AND D
 116+ 5867 B0           	OR B
 117+ 5868 23           	INC HL
 118+ 5869 D9           	EXX
 119+ 586A 02           	LD (BC), A
 120+ 586B
 121+ 586B 23           	INC HL
 122+ 586C 13           	INC DE
 123+ 586D 03           	INC BC
 124+ 586E
 125+ 586E 08           	EX AF, AF'
 126+ 586F 3D           	DEC A
 127+ 5870 C2 37 58     	JP NZ, SHIFT58
 128+ 5873 C9           	RET
 129+ 5874              ; *******************************************************************************************************
 130+ 5874
 131+ 5874              ; *******************************************************************************************************
 132+ 5874              ; routine that shifts one row of characters
 133+ 5874              ; contains self-modifying code that is set-up from external function
 134+ 5874              ; input HL=pointer to mask data
 135+ 5874              ; input HL'=pointer to character data
 136+ 5874              ; input DE=output buffer containing background data
 137+ 5874              ; input A=number of characters to process
 138+ 5874              ; input IX=pointer to structure describing input data
 139+ 5874              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 140+ 5874              SHIFT_ROW:
 141+ 5874 F5           	PUSH AF
 142+ 5875 ED 53 6C 5F  		LD (BLIT_TMP1), DE
 143+ 5879 E5           		PUSH HL
 144+ 587A CD BD 58     			CALL .ADDYSHIFT
 145+ 587D E1           		POP HL
 146+ 587E ED 53 6E 5F  		LD (BLIT_TMP2), DE ; DE+vertical shift
 147+ 5882              .L1:
 148+ 5882 3E 08        		LD A, 8
 149+ 5884 DD 96 02     		SUB (IX+2) ; y shift
 150+ 5887              .CALL1:
 151+ 5887 CD 00 00     		CALL 0
 152+ 588A DD 7E 02     		LD A, (IX+2); y shift
 153+ 588D B7           		OR A
 154+ 588E 28 26        		JR Z, .DONE
 155+ 5890 ED 5B 6C 5F  		LD DE, (BLIT_TMP1)
 156+ 5894 E5           		PUSH HL
 157+ 5895 CD CB 58     			CALL .DETONEXTROW
 158+ 5898 E1           		POP HL
 159+ 5899              .CALL2:
 160+ 5899 CD 00 00     		CALL 0
 161+ 589C ED 5B 6C 5F  		LD DE, (BLIT_TMP1)
 162+ 58A0 E5           		PUSH HL
 163+ 58A1 CD C5 58     			CALL .ADD8
 164+ 58A4 E1           		POP HL
 165+ 58A5 ED 53 6C 5F  		LD (BLIT_TMP1), DE
 166+ 58A9 ED 5B 6E 5F  		LD DE, (BLIT_TMP2)
 167+ 58AD E5           		PUSH HL
 168+ 58AE CD C5 58     			CALL .ADD8
 169+ 58B1 E1           		POP HL
 170+ 58B2 ED 53 6E 5F  		LD (BLIT_TMP2), DE ; DE+vertical shift
 171+ 58B6              .DONE:
 172+ 58B6 F1           	POP AF
 173+ 58B7 3D           	DEC A
 174+ 58B8 C8           	RET Z
 175+ 58B9 F5           	PUSH AF
 176+ 58BA C3 82 58     	JP .L1
 177+ 58BD              .ADDYSHIFT:
 178+ 58BD EB           	EX DE, HL
 179+ 58BE 16 00        	LD D, 0
 180+ 58C0 DD 5E 02     	LD E, (IX+2); y shift
 181+ 58C3 18 0C        	JR .MOVDEBC
 182+ 58C5              .ADD8:
 183+ 58C5 21 08 00     	LD HL, 8
 184+ 58C8 C3 D1 58     	JP .MOVDEBC
 185+ 58CB              .DETONEXTROW:
 186+ 58CB DD 6E 06     	LD L, (IX+6)
 187+ 58CE DD 66 07     	LD H, (IX+7) ; bkg add to value
 188+ 58D1              .MOVDEBC:
 189+ 58D1 19           	ADD HL, DE
 190+ 58D2 54           	LD D, H
 191+ 58D3 5D           	LD E, L
 192+ 58D4 01 08 00     	LD BC, 8
 193+ 58D7 09           	ADD HL, BC
 194+ 58D8 44           	LD B, H
 195+ 58D9 4D           	LD C, L
 196+ 58DA C9           	RET
 197+ 58DB              ; *******************************************************************************************************
 198+ 58DB
 199+ 58DB              ; *******************************************************************************************************
 200+ 58DB              ; function rotates mask and character data and applies it to background
 201+ 58DB              ; input IX=pointer to structure describing input data
 202+ 58DB              ; +0  DW horizontal shift count 0-7 (low byte used)
 203+ 58DB              ; +2  DW vertical shift count 0-7 (low byte used)
 204+ 58DB              ; +4  DW background data start;
 205+ 58DB              ; +6  DW background add to value to next row of background data
 206+ 58DB              ; +8  DW mask data start;
 207+ 58DB              ; +10  DW character data start;
 208+ 58DB              ; +12 DW character&mask add to value to next row of data
 209+ 58DB              ; +14 DW columns (low byte used)
 210+ 58DB              ; +16 DW rows (low byte used)
 211+ 58DB              SHIFT_MERGE_CHARACTER:
 212+ 58DB DD 7E 00     	LD A, (IX) ; shift
 213+ 58DE FE 05        	CP 5
 214+ 58E0 38 25        	JR C, .RIGHT
 215+ 58E2              	; shifts 5-7, use rotate towards left 1-3
 216+ 58E2 21 37 58     	LD HL, SHIFT58
 217+ 58E5 22 88 58     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 218+ 58E8 22 9A 58     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 219+ 58EB D6 05        	SUB 5
 220+ 58ED 28 0D        	JR Z, .L1
 221+ 58EF 87           	ADD A, A
 222+ 58F0 87           	ADD A, A
 223+ 58F1 67           	LD H, A
 224+ 58F2 2E 18        	LD L, #18 ; JR opcode
 225+ 58F4 22 3E 58     	LD (SHIFT58.M1), HL
 226+ 58F7 22 4F 58     	LD (SHIFT58.M2), HL
 227+ 58FA 18 32        	JR .DO
 228+ 58FC              .L1:
 229+ 58FC 21 00 00     	LD HL, 0 ; 2xNOP opcode
 230+ 58FF 22 3E 58     	LD (SHIFT58.M1), HL
 231+ 5902 22 4F 58     	LD (SHIFT58.M2), HL
 232+ 5905 18 27        	JR .DO
 233+ 5907              .RIGHT:
 234+ 5907              	; shifts 0-4, rotate towards right
 235+ 5907 21 F2 57     	LD HL, SHIFT04
 236+ 590A 22 88 58     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 237+ 590D 22 9A 58     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 238+ 5910 FE 04        	CP 4
 239+ 5912 28 11        	JR Z, .R1
 240+ 5914 D6 04        	SUB 4
 241+ 5916 ED 44        	NEG
 242+ 5918 87           	ADD A, A
 243+ 5919 87           	ADD A, A
 244+ 591A 67           	LD H, A
 245+ 591B 2E 18        	LD L, #18 ; JR opcode
 246+ 591D 22 F9 57     	LD (SHIFT04.M1), HL
 247+ 5920 22 0E 58     	LD (SHIFT04.M2), HL
 248+ 5923 18 09        	JR .DO
 249+ 5925              .R1:
 250+ 5925 21 00 00     	LD HL, 0 ; 2xNOP opcode
 251+ 5928 22 F9 57     	LD (SHIFT04.M1), HL
 252+ 592B 22 0E 58     	LD (SHIFT04.M2), HL
 253+ 592E              .DO:
 254+ 592E DD 46 10     	LD B, (IX+16) ; rows
 255+ 5931 DD 6E 08     	LD L, (IX+8)
 256+ 5934 DD 66 09     	LD H, (IX+9) ; mask data
 257+ 5937 DD 5E 04     	LD E, (IX+4)
 258+ 593A DD 56 05     	LD D, (IX+5) ; background data
 259+ 593D D9           	EXX
 260+ 593E DD 6E 0A     	LD L, (IX+10)
 261+ 5941 DD 66 0B     	LD H, (IX+11) ; character data
 262+ 5944 D9           	EXX
 263+ 5945              .LOOP:
 264+ 5945 C5           	PUSH BC
 265+ 5946 E5           		PUSH HL
 266+ 5947 D5           			PUSH DE
 267+ 5948 D9           				EXX
 268+ 5949 E5           				PUSH HL
 269+ 594A D9           					EXX
 270+ 594B DD 7E 0E     					LD A, (IX+14) ; columns
 271+ 594E              .CALL:
 272+ 594E CD 74 58     					CALL SHIFT_ROW
 273+ 5951 E1           				POP HL
 274+ 5952 DD 5E 0C     				LD E, (IX+12)
 275+ 5955 DD 56 0D     				LD D, (IX+13) ; char data to next row
 276+ 5958 19           				ADD HL, DE
 277+ 5959 D9           				EXX
 278+ 595A E1           			POP HL
 279+ 595B DD 5E 06     			LD E, (IX+6)
 280+ 595E DD 56 07     			LD D, (IX+7) ; background to next row
 281+ 5961 19           			ADD HL, DE
 282+ 5962 EB           			EX DE, HL
 283+ 5963 E1           		POP HL
 284+ 5964 DD 4E 0C     		LD C, (IX+12)
 285+ 5967 DD 46 0D     		LD B, (IX+13) ; char data to next row
 286+ 596A 09           		ADD HL, BC
 287+ 596B C1           	POP BC
 288+ 596C 10 D7        	DJNZ .LOOP
 289+ 596E C9           	RET
 290+ 596F              ; *******************************************************************************************************
 291+ 596F
 292+ 596F              ; *******************************************************************************************************
 293+ 596F              ; helper function DE \ 8
 294+ 596F              DEdiv8:
 295+ 596F 7B           	LD A,E
 296+ 5970 CB 2A        	SRA D
 297+ 5972 CB 1F            RR  A
 298+ 5974 CB 2A            SRA D
 299+ 5976 CB 1F            RR  A
 300+ 5978 CB 2A            SRA D
 301+ 597A CB 1F            RR  A
 302+ 597C C9           	RET
 303+ 597D              ; *******************************************************************************************************
 304+ 597D
 305+ 597D               IF (1 == 1)
 306+ 597D              ; *******************************************************************************************************
 307+ 597D              ; function to handle BLIT basic extension through DEFUSR call in RAW format
 308+ 597D              ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 309+ 597D              ; +2  DW horizontal shift count 0-7 (low byte used)
 310+ 597D              ; +4  DW vertical shift count 0-7 (low byte used)
 311+ 597D              ; +6  DW background data start;
 312+ 597D              ; +8  DW background add to value to next row of background data
 313+ 597D              ; +10  DW mask data start;
 314+ 597D              ; +12  DW character data start;
 315+ 597D              ; +14 DW character&mask add to value to next row of data
 316+ 597D              ; +16 DW columns (low byte used)
 317+ 597D              ; +18 DW rows (low byte used)
 318+ 597D              ; will put ram in page 0 also, page 1 is already there
 319+ 597D              ;BLIT_DEFUSR:
 320+ 597D              ;	DI
 321+ 597D              ;	LD IY, .RET
 322+ 597D              ;	JP ENABLE_PAGE0
 323+ 597D              ;.RET:
 324+ 597D              ;	EI
 325+ 597D              ;	INC IX
 326+ 597D              ;	INC IX
 327+ 597D              ;	CALL SHIFT_MERGE_CHARACTER
 328+ 597D              ;
 329+ 597D              ;   POP DE
 330+ 597D              ;    POP BC
 331+ 597D              ;    JP RESTORE_PAGE_INFO
 332+ 597D              ; *******************************************************************************************************
 333+ 597D
 334+ 597D              ; *******************************************************************************************************
 335+ 597D              ; function to handle CALL BLIT basic extension in DEFUSR form
 336+ 597D              ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 337+ 597D              ; +02 x
 338+ 597D              ; +04 y
 339+ 597D              ; +06 char_data_pointer
 340+ 597D              ; +08 mask_data_pointer
 341+ 597D              ; +10 width
 342+ 597D              ; +12 height
 343+ 597D              ; +14 background_pointer
 344+ 597D              ; +16 background_width
 345+ 597D              ; BLIT ( INT x,
 346+ 597D              ;		 INT y,
 347+ 597D              ;		 INT char_data_pointer,
 348+ 597D              ;		 INT mask_data_pointer,
 349+ 597D              ;		 INT width (in characters),
 350+ 597D              ;		 INT height (in characters),
 351+ 597D              ;		 INT background_pointer (top left),
 352+ 597D              ;		 INT background_width (in characters),
 353+ 597D              BLIT_DEFUSR:
 354+ 597D DD 5E 02     	LD E,(IX+2)
 355+ 5980 DD 56 03     	LD D,(IX+3)
 356+ 5983 7B           	LD A,E
 357+ 5984 E6 07        	AND 7
 358+ 5986 32 70 5F     	LD (BLIT_STRUCT+0),A
 359+ 5989 CD 6F 59     	CALL DEdiv8
 360+ 598C 32 6C 5F     	LD (BLIT_TMP+0),A
 361+ 598F DD 5E 04     	LD E,(IX+4)
 362+ 5992 DD 56 05     	LD D,(IX+5)
 363+ 5995 7B           	LD A,E
 364+ 5996 E6 07        	AND 7
 365+ 5998 32 72 5F     	LD (BLIT_STRUCT+2),A
 366+ 599B CD 6F 59     	CALL DEdiv8
 367+ 599E 32 6D 5F     	LD (BLIT_TMP+1),A
 368+ 59A1 DD 6E 06     	LD L,(IX+6)
 369+ 59A4 DD 66 07     	LD H,(IX+7)
 370+ 59A7 22 7A 5F     	LD (BLIT_STRUCT+10),HL
 371+ 59AA DD 6E 08     	LD L,(IX+8)
 372+ 59AD DD 66 09     	LD H,(IX+9)
 373+ 59B0 22 78 5F     	LD (BLIT_STRUCT+8),HL
 374+ 59B3 DD 7E 0A     	LD A,(IX+10)
 375+ 59B6 32 7E 5F     	LD (BLIT_STRUCT+14),A
 376+ 59B9 DD 7E 0C     	LD A,(IX+12)
 377+ 59BC 32 80 5F     	LD (BLIT_STRUCT+16),A
 378+ 59BF DD 6E 0E     	LD L,(IX+14)
 379+ 59C2 DD 66 0F     	LD H,(IX+15)
 380+ 59C5 22 74 5F     	LD (BLIT_STRUCT+4),HL
 381+ 59C8              	;LD A,(IX+16)
 382+ 59C8              	;LD (BLIT_TMP+2),A
 383+ 59C8
 384+ 59C8              	; calculate char&mask add to value
 385+ 59C8 26 00        	LD H,0
 386+ 59CA 3A 7E 5F     	LD A,(BLIT_STRUCT+14)
 387+ 59CD 6F           	LD L,A
 388+ 59CE CD E0 5F     	CALL HLx8
 389+ 59D1 22 7C 5F     	LD (BLIT_STRUCT+12),HL
 390+ 59D4              	; calculate background add to value
 391+ 59D4 26 00        	LD H,0
 392+ 59D6 DD 6E 10     	LD L,(IX+16)
 393+ 59D9 CD E0 5F     	CALL HLx8
 394+ 59DC 22 76 5F     	LD (BLIT_STRUCT+6),HL
 395+ 59DF              	; calculate pointer to background location
 396+ 59DF 21 00 00     	LD HL,0
 397+ 59E2 3A 6D 5F     	LD A,(BLIT_TMP+1)
 398+ 59E5 B7           	OR A
 399+ 59E6 28 08        	JR Z, .L1
 400+ 59E8 47           	LD B,A
 401+ 59E9 ED 5B 76 5F  	LD DE,(BLIT_STRUCT+6)
 402+ 59ED              .L0:
 403+ 59ED 19           	ADD HL, DE
 404+ 59EE 10 FD        	DJNZ .L0
 405+ 59F0              .L1:
 406+ 59F0 EB           	EX DE,HL
 407+ 59F1 26 00        	LD H,0
 408+ 59F3 3A 6C 5F     	LD A,(BLIT_TMP+0)
 409+ 59F6 6F           	LD L,A
 410+ 59F7 CD E0 5F     	CALL HLx8
 411+ 59FA 19           	ADD HL,DE
 412+ 59FB ED 5B 74 5F  	LD DE,(BLIT_STRUCT+4)
 413+ 59FF 19           	ADD HL,DE
 414+ 5A00 22 74 5F     	LD (BLIT_STRUCT+4),HL
 415+ 5A03
 416+ 5A03 FD 21 0A 5A  	LD IY, .RET
 417+ 5A07 C3 A4 60     	JP ENABLE_PAGE0
 418+ 5A0A              .RET:
 419+ 5A0A FB           	EI
 420+ 5A0B DD 21 70 5F  	LD IX, BLIT_STRUCT
 421+ 5A0F CD DB 58     	CALL SHIFT_MERGE_CHARACTER
 422+ 5A12
 423+ 5A12 D1               POP DE
 424+ 5A13 C1               POP BC
 425+ 5A14 CD 1B 60         CALL RESTORE_PAGE_INFO
 426+ 5A17 AF           	XOR A ; success
 427+ 5A18 C9           	RET
 428+ 5A19              ; *******************************************************************************************************
 429+ 5A19               ENDIF
 430+ 5A19
 431+ 5A19               IF (0 == 1)
 432+ 5A19 ~            ; *******************************************************************************************************
 433+ 5A19 ~            ; function to handle CALL BLIT basic extension
 434+ 5A19 ~            ; rotates 1-bit character drawing horizontally with mask and character data and
 435+ 5A19 ~            ; fuses with background data and applies vertical shift too
 436+ 5A19 ~            ; in form without pointers
 437+ 5A19 ~            ; BLIT ( INT x,
 438+ 5A19 ~            ;		 INT y,
 439+ 5A19 ~            ;		 INT char_data_pointer,
 440+ 5A19 ~            ;		 INT mask_data_pointer,
 441+ 5A19 ~            ;		 INT width (in characters),
 442+ 5A19 ~            ;		 INT height (in characters),
 443+ 5A19 ~            ;		 INT background_pointer (top left),
 444+ 5A19 ~            ;		 INT background_width (in characters),
 445+ 5A19 ~            ; will put ram in page 0 also, page 1 is already there
 446+ 5A19 ~            BLIT:
 447+ 5A19 ~            	; opening (
 448+ 5A19 ~            	CALL CHKCHAR
 449+ 5A19 ~            	DB '('
 450+ 5A19 ~            	; get x coordinate
 451+ 5A19 ~            	LD IX, FRMQNT
 452+ 5A19 ~            	CALL CALBAS
 453+ 5A19 ~            	LD A, E
 454+ 5A19 ~            	AND 7
 455+ 5A19 ~            	LD (BLIT_STRUCT+0), A
 456+ 5A19 ~            	CALL DEdiv8
 457+ 5A19 ~            	LD (BLIT_TMP+0),A
 458+ 5A19 ~            	; comma
 459+ 5A19 ~            	CALL CHKCHAR
 460+ 5A19 ~            	DB ','
 461+ 5A19 ~            	; get y coordinate
 462+ 5A19 ~            	LD IX, FRMQNT
 463+ 5A19 ~            	CALL CALBAS
 464+ 5A19 ~            	LD A, E
 465+ 5A19 ~            	AND 7
 466+ 5A19 ~            	LD (BLIT_STRUCT+2), A
 467+ 5A19 ~            	CALL DEdiv8
 468+ 5A19 ~            	LD (BLIT_TMP+1),A
 469+ 5A19 ~            	; comma
 470+ 5A19 ~            	CALL CHKCHAR
 471+ 5A19 ~            	DB ','
 472+ 5A19 ~            	; get char data pointer
 473+ 5A19 ~            	LD IX, FRMQNT
 474+ 5A19 ~            	CALL CALBAS
 475+ 5A19 ~            	LD (BLIT_STRUCT+10), DE
 476+ 5A19 ~            	; comma
 477+ 5A19 ~            	CALL CHKCHAR
 478+ 5A19 ~            	DB ','
 479+ 5A19 ~            	; get mask data pointer
 480+ 5A19 ~            	LD IX, FRMQNT
 481+ 5A19 ~            	CALL CALBAS
 482+ 5A19 ~            	LD (BLIT_STRUCT+8), DE
 483+ 5A19 ~            	; comma
 484+ 5A19 ~            	CALL CHKCHAR
 485+ 5A19 ~            	DB ','
 486+ 5A19 ~            	; get width
 487+ 5A19 ~            	LD IX, FRMQNT
 488+ 5A19 ~            	CALL CALBAS
 489+ 5A19 ~            	LD A, E
 490+ 5A19 ~            	LD (BLIT_STRUCT+14), A
 491+ 5A19 ~            	; comma
 492+ 5A19 ~            	CALL CHKCHAR
 493+ 5A19 ~            	DB ','
 494+ 5A19 ~            	; get height
 495+ 5A19 ~            	LD IX, FRMQNT
 496+ 5A19 ~            	CALL CALBAS
 497+ 5A19 ~            	LD A, E
 498+ 5A19 ~            	LD (BLIT_STRUCT+16), A
 499+ 5A19 ~            	; comma
 500+ 5A19 ~            	CALL CHKCHAR
 501+ 5A19 ~            	DB ','
 502+ 5A19 ~            	; get background pointer
 503+ 5A19 ~            	LD IX, FRMQNT
 504+ 5A19 ~            	CALL CALBAS
 505+ 5A19 ~            	LD (BLIT_STRUCT+4), DE
 506+ 5A19 ~            	; comma
 507+ 5A19 ~            	CALL CHKCHAR
 508+ 5A19 ~            	DB ','
 509+ 5A19 ~            	; get background width
 510+ 5A19 ~            	LD IX, FRMQNT
 511+ 5A19 ~            	CALL CALBAS
 512+ 5A19 ~            	LD A, E
 513+ 5A19 ~            	LD (BLIT_TMP+2), A
 514+ 5A19 ~            	; ending )
 515+ 5A19 ~            	CALL CHKCHAR
 516+ 5A19 ~            	DB ')'
 517+ 5A19 ~
 518+ 5A19 ~            	PUSH HL ; save position in BASIC buffer
 519+ 5A19 ~
 520+ 5A19 ~            	; calculate char&mask add to value
 521+ 5A19 ~            	LD H, 0
 522+ 5A19 ~            	LD A, (BLIT_STRUCT+14)
 523+ 5A19 ~            	LD L, A
 524+ 5A19 ~            	CALL HLx8
 525+ 5A19 ~            	LD (BLIT_STRUCT+12), HL
 526+ 5A19 ~            	; calculate background add to value
 527+ 5A19 ~            	LD H, 0
 528+ 5A19 ~            	LD A, (BLIT_TMP+2)
 529+ 5A19 ~            	LD L, A
 530+ 5A19 ~            	CALL HLx8
 531+ 5A19 ~            	LD (BLIT_STRUCT+6), HL
 532+ 5A19 ~            	; calculate pointer to background location
 533+ 5A19 ~            	LD HL, 0
 534+ 5A19 ~            	LD A,(BLIT_TMP+1)
 535+ 5A19 ~            	OR A
 536+ 5A19 ~            	JR Z, .L1
 537+ 5A19 ~            	LD B,A
 538+ 5A19 ~            	LD DE,(BLIT_STRUCT+6)
 539+ 5A19 ~            .L0:
 540+ 5A19 ~            	ADD HL, DE
 541+ 5A19 ~            	DJNZ .L0
 542+ 5A19 ~            .L1:
 543+ 5A19 ~            	EX DE,HL
 544+ 5A19 ~            	LD H,0
 545+ 5A19 ~            	LD A,(BLIT_TMP+0)
 546+ 5A19 ~            	LD L,A
 547+ 5A19 ~            	CALL HLx8
 548+ 5A19 ~            	ADD HL,DE
 549+ 5A19 ~            	LD DE,(BLIT_STRUCT+4)
 550+ 5A19 ~            	ADD HL,DE
 551+ 5A19 ~            	LD (BLIT_STRUCT+4),HL
 552+ 5A19 ~
 553+ 5A19 ~            	LD IY, .RET
 554+ 5A19 ~            	JP ENABLE_PAGE0
 555+ 5A19 ~            .RET:
 556+ 5A19 ~            	EI
 557+ 5A19 ~            	LD IX, BLIT_STRUCT
 558+ 5A19 ~            	CALL SHIFT_MERGE_CHARACTER
 559+ 5A19 ~
 560+ 5A19 ~                POP DE
 561+ 5A19 ~                POP BC
 562+ 5A19 ~                CALL RESTORE_PAGE_INFO
 563+ 5A19 ~
 564+ 5A19 ~            	POP HL
 565+ 5A19 ~            	RET
 566+ 5A19 ~            ; *******************************************************************************************************
 567+ 5A19               ENDIF
# file closed: asm\BLIT.asm
 164  5A19               ENDIF
 165  5A19
 166  5A19               IF (TILE_CMDS == 1)
 167  5A19               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
   1+ 5A19              ; *******************************************************************************************************
   2+ 5A19              ; generic function to implement tiling
   3+ 5A19              ; should be modified to call appropriate function for memory or vram
   4+ 5A19              ; input IX=pointer to following structure
   5+ 5A19              ; +00 tile_data_ptr
   6+ 5A19              ; +02 tile_rows
   7+ 5A19              ; +04 tile_columns
   8+ 5A19              ; +06 destination_address
   9+ 5A19              ; +08 dest_to_next_row_add_to_value
  10+ 5A19              ; +10 num_horizontal_tiles
  11+ 5A19              ; +12 num_vertical_tiles
  12+ 5A19              ; modifies AF, BC, DE, HL
  13+ 5A19              TILE:
  14+ 5A19 DD 6E 06     	LD L, (IX+6)
  15+ 5A1C DD 66 07     	LD H, (IX+7) ; destination address
  16+ 5A1F 22 6C 5F     	LD (TILETMP1), HL
  17+ 5A22 DD 46 0C     	LD B, (IX+12) ; vertical tile number
  18+ 5A25              .L1:
  19+ 5A25 C5           	PUSH BC
  20+ 5A26 DD 6E 00     		LD L, (IX+0)
  21+ 5A29 DD 66 01     		LD H, (IX+1) ; tile address
  22+ 5A2C 22 6E 5F     		LD (TILETMP2), HL
  23+ 5A2F DD 46 02     		LD B, (IX+2) ; tile rows
  24+ 5A32              .L2:
  25+ 5A32 C5           		PUSH BC
  26+ 5A33 CD 00 00     .CALL1:		CALL 0
  27+ 5A36 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
  28+ 5A39              .L3:
  29+ 5A39 C5           			PUSH BC
  30+ 5A3A 2A 6E 5F     				LD HL, (TILETMP2)
  31+ 5A3D DD 46 04     				LD B, (IX+4) ; tile columns
  32+ 5A40              .L4:
  33+ 5A40 C5           				PUSH BC
  34+ 5A41              .CALL2:
  35+ 5A41 CD 00 00     					CALL 0
  36+ 5A44 C1           				POP BC
  37+ 5A45 10 F9        				DJNZ .L4
  38+ 5A47 C1           			POP BC
  39+ 5A48 10 EF        			DJNZ .L3
  40+ 5A4A 22 6E 5F     			LD (TILETMP2), HL
  41+ 5A4D 2A 6C 5F     			LD HL, (TILETMP1)
  42+ 5A50 DD 5E 08     			LD E, (IX+8)
  43+ 5A53 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
  44+ 5A56 19           			ADD HL, DE
  45+ 5A57 22 6C 5F     			LD (TILETMP1), HL
  46+ 5A5A C1           		POP BC
  47+ 5A5B 10 D5        		DJNZ .L2
  48+ 5A5D C1           	POP BC
  49+ 5A5E 10 C5        	DJNZ .L1
  50+ 5A60 C9           	RET
  51+ 5A61              ; *******************************************************************************************************
  52+ 5A61
  53+ 5A61               IF (1 == 1)
  54+ 5A61              ; *******************************************************************************************************
  55+ 5A61              ; same as TILERAM but for DEFUSR approach
  56+ 5A61              ; input IX=pointer to input array, real data from +2
  57+ 5A61              ; +02 = tile data pointer
  58+ 5A61              ; +04 = tile columns
  59+ 5A61              ; +06 = tile rows
  60+ 5A61              ; +08 = destination pointer
  61+ 5A61              ; +10 = destination columns
  62+ 5A61              ; +12 = destination rows
  63+ 5A61              ; +14 = destination begin column
  64+ 5A61              ; +16 = destination begin row
  65+ 5A61              ; +18 = number of tiles horizontally
  66+ 5A61              ; +20 = number of tiles vertically
  67+ 5A61              ; *******************************************************************************************************
  68+ 5A61              TILERAM_DEFUSR:
  69+ 5A61              	; tile data pointer
  70+ 5A61 DD 6E 02     	LD L,(IX+2)
  71+ 5A64 DD 66 03     	LD H,(IX+3)
  72+ 5A67 22 70 5F     	LD (BLIT_STRUCT+0),HL
  73+ 5A6A              	; tile columns
  74+ 5A6A DD 6E 04     	LD L,(IX+4)
  75+ 5A6D DD 66 05     	LD H,(IX+5)
  76+ 5A70 22 74 5F     	LD (BLIT_STRUCT+4),HL
  77+ 5A73              	; tile rows
  78+ 5A73 DD 6E 06     	LD L,(IX+6)
  79+ 5A76 DD 66 07     	LD H,(IX+7)
  80+ 5A79 22 72 5F     	LD (BLIT_STRUCT+2),HL
  81+ 5A7C              	; destintion pointer
  82+ 5A7C DD 6E 08     	LD L,(IX+8)
  83+ 5A7F DD 66 09     	LD H,(IX+9)
  84+ 5A82 22 76 5F     	LD (BLIT_STRUCT+6),HL
  85+ 5A85              	; destination columns
  86+ 5A85 DD 7E 0A     	LD A,(IX+10)
  87+ 5A88 32 6C 5F     	LD (BLIT_TMP+0),A
  88+ 5A8B              	; destination rows
  89+ 5A8B DD 7E 0C     	LD A,(IX+12)
  90+ 5A8E 32 6D 5F     	LD (BLIT_TMP+1),A
  91+ 5A91              	; destination begin column
  92+ 5A91 DD 7E 0E     	LD A,(IX+14)
  93+ 5A94 32 6E 5F     	LD (BLIT_TMP+2),A
  94+ 5A97              	; destination begin row
  95+ 5A97 DD 7E 10     	LD A,(IX+16)
  96+ 5A9A 32 6F 5F     	LD (BLIT_TMP+3),A
  97+ 5A9D              	; number of tiles horizontally
  98+ 5A9D DD 6E 12     	LD L,(IX+18)
  99+ 5AA0 DD 66 13     	LD H,(IX+19)
 100+ 5AA3 22 7A 5F     	LD (BLIT_STRUCT+10),HL
 101+ 5AA6              	; number of tiles vertically
 102+ 5AA6 DD 6E 14     	LD L,(IX+20)
 103+ 5AA9 DD 66 15     	LD H,(IX+21)
 104+ 5AAC 22 7C 5F     	LD (BLIT_STRUCT+12),HL
 105+ 5AAF               IF (0 == 1) ; otherwise we just continue with code below
 106+ 5AAF ~            	JP TILERAM.COMMON
 107+ 5AAF               ENDIF
 108+ 5AAF               ENDIF
 109+ 5AAF
 110+ 5AAF              ; *******************************************************************************************************
 111+ 5AAF              ; function to handle CALL TILERAM basic extension
 112+ 5AAF              ; fills memory with tiles
 113+ 5AAF              ; TILERAM ( INT tile_data_pointer,
 114+ 5AAF              ;			INT tile_columns,
 115+ 5AAF              ;			INT tile_rows,
 116+ 5AAF              ;			INT destination_pointer,
 117+ 5AAF              ;			INT destination_columns,
 118+ 5AAF              ;			INT destination_rows,
 119+ 5AAF              ;			INT destination_begin_column,
 120+ 5AAF              ;			INT destination_begin_row,
 121+ 5AAF              ;			INT number_of_tiles_horizontally,
 122+ 5AAF              ;			INT	number_of_tiles_vertically )
 123+ 5AAF              ; will put ram in page 0 also, page 1 is already there
 124+ 5AAF              TILERAM:
 125+ 5AAF               IF (0 == 1)
 126+ 5AAF ~            	; opening (
 127+ 5AAF ~            	CALL CHKCHAR
 128+ 5AAF ~            	DB '('
 129+ 5AAF ~            	; get tile data pointer coordinate
 130+ 5AAF ~            	LD IX, FRMQNT
 131+ 5AAF ~            	CALL CALBAS
 132+ 5AAF ~            	LD (BLIT_STRUCT+0), DE
 133+ 5AAF ~            	; comma
 134+ 5AAF ~            	CALL CHKCHAR
 135+ 5AAF ~            	DB ','
 136+ 5AAF ~            	; get tile columns
 137+ 5AAF ~            	LD IX, FRMQNT
 138+ 5AAF ~            	CALL CALBAS
 139+ 5AAF ~            	LD (BLIT_STRUCT+4), DE
 140+ 5AAF ~            	; comma
 141+ 5AAF ~            	CALL CHKCHAR
 142+ 5AAF ~            	DB ','
 143+ 5AAF ~            	; get tile columns
 144+ 5AAF ~            	LD IX, FRMQNT
 145+ 5AAF ~            	CALL CALBAS
 146+ 5AAF ~            	LD (BLIT_STRUCT+2), DE
 147+ 5AAF ~            	; comma
 148+ 5AAF ~            	CALL CHKCHAR
 149+ 5AAF ~            	DB ','
 150+ 5AAF ~            	; get destintion pointer
 151+ 5AAF ~            	LD IX, FRMQNT
 152+ 5AAF ~            	CALL CALBAS
 153+ 5AAF ~            	LD (BLIT_STRUCT+6), DE
 154+ 5AAF ~            	; comma
 155+ 5AAF ~            	CALL CHKCHAR
 156+ 5AAF ~            	DB ','
 157+ 5AAF ~            	; get destination columns
 158+ 5AAF ~            	LD IX, FRMQNT
 159+ 5AAF ~            	CALL CALBAS
 160+ 5AAF ~            	LD A, E
 161+ 5AAF ~            	LD (BLIT_TMP+0), A
 162+ 5AAF ~            	; comma
 163+ 5AAF ~            	CALL CHKCHAR
 164+ 5AAF ~            	DB ','
 165+ 5AAF ~            	; get destination rows
 166+ 5AAF ~            	LD IX, FRMQNT
 167+ 5AAF ~            	CALL CALBAS
 168+ 5AAF ~            	LD A, E
 169+ 5AAF ~            	LD (BLIT_TMP+1), A
 170+ 5AAF ~            	; comma
 171+ 5AAF ~            	CALL CHKCHAR
 172+ 5AAF ~            	DB ','
 173+ 5AAF ~            	; get destination begin column
 174+ 5AAF ~            	LD IX, FRMQNT
 175+ 5AAF ~            	CALL CALBAS
 176+ 5AAF ~            	LD A, E
 177+ 5AAF ~            	LD (BLIT_TMP+2), A
 178+ 5AAF ~            	; comma
 179+ 5AAF ~            	CALL CHKCHAR
 180+ 5AAF ~            	DB ','
 181+ 5AAF ~            	; get destination begin row
 182+ 5AAF ~            	LD IX, FRMQNT
 183+ 5AAF ~            	CALL CALBAS
 184+ 5AAF ~            	LD A, E
 185+ 5AAF ~            	LD (BLIT_TMP+3), A
 186+ 5AAF ~            	; comma
 187+ 5AAF ~            	CALL CHKCHAR
 188+ 5AAF ~            	DB ','
 189+ 5AAF ~            	; get number of tiles horizontally
 190+ 5AAF ~            	LD IX, FRMQNT
 191+ 5AAF ~            	CALL CALBAS
 192+ 5AAF ~            	LD (BLIT_STRUCT+10), DE
 193+ 5AAF ~            	; comma
 194+ 5AAF ~            	CALL CHKCHAR
 195+ 5AAF ~            	DB ','
 196+ 5AAF ~            	; get number of tiles vertically
 197+ 5AAF ~            	LD IX, FRMQNT
 198+ 5AAF ~            	CALL CALBAS
 199+ 5AAF ~            	LD (BLIT_STRUCT+12), DE
 200+ 5AAF ~            	; ending )
 201+ 5AAF ~            	CALL CHKCHAR
 202+ 5AAF ~            	DB ')'
 203+ 5AAF               ENDIF
 204+ 5AAF              .COMMON:
 205+ 5AAF E5           	PUSH HL ; save position in BASIC buffer
 206+ 5AB0
 207+ 5AB0              	; calculate destination add to value
 208+ 5AB0 26 00        	LD H, 0
 209+ 5AB2 3A 6C 5F     	LD A, (BLIT_TMP+0)
 210+ 5AB5 6F           	LD L, A
 211+ 5AB6 CD E0 5F     	CALL HLx8
 212+ 5AB9 22 78 5F     	LD (BLIT_STRUCT+8), HL
 213+ 5ABC              	; calculate pointer to background location
 214+ 5ABC 21 00 00     	LD HL, 0
 215+ 5ABF 3A 6F 5F     	LD A,(BLIT_TMP+3)
 216+ 5AC2 B7           	OR A
 217+ 5AC3 28 08        	JR Z, .L1
 218+ 5AC5 47           	LD B,A
 219+ 5AC6 ED 5B 78 5F  	LD DE,(BLIT_STRUCT+8)
 220+ 5ACA              .L0:
 221+ 5ACA 19           	ADD HL, DE
 222+ 5ACB 10 FD        	DJNZ .L0
 223+ 5ACD              .L1:
 224+ 5ACD EB           	EX DE,HL
 225+ 5ACE 26 00        	LD H,0
 226+ 5AD0 3A 6E 5F     	LD A,(BLIT_TMP+2)
 227+ 5AD3 6F           	LD L,A
 228+ 5AD4 CD E0 5F     	CALL HLx8
 229+ 5AD7 19           	ADD HL,DE
 230+ 5AD8 ED 5B 76 5F  	LD DE,(BLIT_STRUCT+6)
 231+ 5ADC 19           	ADD HL,DE
 232+ 5ADD 22 76 5F     	LD (BLIT_STRUCT+6),HL
 233+ 5AE0 FD 21 E7 5A  	LD IY, .RET
 234+ 5AE4 C3 A4 60     	JP ENABLE_PAGE0
 235+ 5AE7              .RET:
 236+ 5AE7 FB           	EI
 237+ 5AE8              	; set RAM functions to call
 238+ 5AE8 21 03 5B     	LD HL, .TILECOPY
 239+ 5AEB 22 42 5A     	LD (TILE.CALL2+1), HL
 240+ 5AEE 21 14 5B     	LD HL, .SETDESTROW
 241+ 5AF1 22 34 5A     	LD (TILE.CALL1+1), HL
 242+ 5AF4 DD 21 70 5F  	LD IX,BLIT_STRUCT
 243+ 5AF8 CD 19 5A     	CALL TILE
 244+ 5AFB
 245+ 5AFB D1               POP DE
 246+ 5AFC C1               POP BC
 247+ 5AFD CD 1B 60         CALL RESTORE_PAGE_INFO
 248+ 5B00
 249+ 5B00 E1           	POP HL
 250+ 5B01 AF           	XOR A ; success
 251+ 5B02 C9           	RET
 252+ 5B03              .TILECOPY:
 253+ 5B03 ED A0       > LDI
 253+ 5B05 ED A0       > LDI
 253+ 5B07 ED A0       > LDI
 253+ 5B09 ED A0       > LDI
 253+ 5B0B ED A0       > LDI
 253+ 5B0D ED A0       > LDI
 253+ 5B0F ED A0       > LDI
 253+ 5B11 ED A0       > LDI
 254+ 5B13 C9           	RET
 255+ 5B14              .SETDESTROW:
 256+ 5B14 ED 5B 6C 5F  	LD DE, (TILETMP1)
 257+ 5B18 C9           	RET
 258+ 5B19              ; *******************************************************************************************************
 259+ 5B19
 260+ 5B19               IF (1 == 1)
 261+ 5B19              ; *******************************************************************************************************
 262+ 5B19              ; same as TILEVRM but for DEFUSR approach
 263+ 5B19              ; input IX=pointer to input array, real data from +2
 264+ 5B19              ; +02 = tile data pointer
 265+ 5B19              ; +04 = tile columns
 266+ 5B19              ; +06 = tile rows
 267+ 5B19              ; +08 = destination begin column
 268+ 5B19              ; +10 = destination begin row
 269+ 5B19              ; +12 = number of tiles horizontally
 270+ 5B19              ; +14 = number of tiles vertically
 271+ 5B19              ; *******************************************************************************************************
 272+ 5B19              TILEVRM_DEFUSR:
 273+ 5B19              	; tile data pointer
 274+ 5B19 DD 6E 02     	LD L,(IX+2)
 275+ 5B1C DD 66 03     	LD H,(IX+3)
 276+ 5B1F 22 70 5F     	LD (BLIT_STRUCT+0),HL
 277+ 5B22              	; tile columns
 278+ 5B22 DD 6E 04     	LD L,(IX+4)
 279+ 5B25 DD 66 05     	LD H,(IX+5)
 280+ 5B28 22 74 5F     	LD (BLIT_STRUCT+4),HL
 281+ 5B2B              	; tile rows
 282+ 5B2B DD 6E 06     	LD L,(IX+6)
 283+ 5B2E DD 66 07     	LD H,(IX+7)
 284+ 5B31 22 72 5F     	LD (BLIT_STRUCT+2),HL
 285+ 5B34              	; destination begin column
 286+ 5B34 DD 7E 08     	LD A,(IX+8)
 287+ 5B37 32 6E 5F     	LD (BLIT_TMP+2),A
 288+ 5B3A              	; destination begin row
 289+ 5B3A DD 7E 0A     	LD A,(IX+10)
 290+ 5B3D 32 6F 5F     	LD (BLIT_TMP+3),A
 291+ 5B40              	; number of tiles horizontally
 292+ 5B40 DD 6E 0C     	LD L,(IX+12)
 293+ 5B43 DD 66 0D     	LD H,(IX+13)
 294+ 5B46 22 7A 5F     	LD (BLIT_STRUCT+10),HL
 295+ 5B49              	; number of tiles vertically
 296+ 5B49 DD 6E 0E     	LD L,(IX+14)
 297+ 5B4C DD 66 0F     	LD H,(IX+15)
 298+ 5B4F 22 7C 5F     	LD (BLIT_STRUCT+12),HL
 299+ 5B52               IF (0 == 1) ; otherwise we just continue with code below
 300+ 5B52 ~            	JP TILEVRM.COMMON
 301+ 5B52               ENDIF
 302+ 5B52               ENDIF
 303+ 5B52
 304+ 5B52              ; *******************************************************************************************************
 305+ 5B52              ; function to handle CALL TILEVRM basic extension
 306+ 5B52              ; fills vram with tiles
 307+ 5B52              ; TILEVRM ( INT tile_data_pointer,
 308+ 5B52              ;			INT tile_columns,
 309+ 5B52              ;			INT tile_rows,
 310+ 5B52              ;			INT destination_begin_column,
 311+ 5B52              ;			INT destination_begin_row,
 312+ 5B52              ;			INT number_of_tiles_horizontally,
 313+ 5B52              ;			INT	number_of_tiles_vertically )
 314+ 5B52              ; will put ram in page 0 also, page 1 is already there
 315+ 5B52              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
 316+ 5B52              TILEVRM:
 317+ 5B52               IF (0 == 1)
 318+ 5B52 ~            	; opening (
 319+ 5B52 ~            	CALL CHKCHAR
 320+ 5B52 ~            	DB '('
 321+ 5B52 ~            	; get tile data pointer coordinate
 322+ 5B52 ~            	LD IX, FRMQNT
 323+ 5B52 ~            	CALL CALBAS
 324+ 5B52 ~            	LD (BLIT_STRUCT+0), DE
 325+ 5B52 ~            	; comma
 326+ 5B52 ~            	CALL CHKCHAR
 327+ 5B52 ~            	DB ','
 328+ 5B52 ~            	; get tile columns
 329+ 5B52 ~            	LD IX, FRMQNT
 330+ 5B52 ~            	CALL CALBAS
 331+ 5B52 ~            	LD (BLIT_STRUCT+4), DE
 332+ 5B52 ~            	; comma
 333+ 5B52 ~            	CALL CHKCHAR
 334+ 5B52 ~            	DB ','
 335+ 5B52 ~            	; get tile columns
 336+ 5B52 ~            	LD IX, FRMQNT
 337+ 5B52 ~            	CALL CALBAS
 338+ 5B52 ~            	LD (BLIT_STRUCT+2), DE
 339+ 5B52 ~            	; comma
 340+ 5B52 ~            	CALL CHKCHAR
 341+ 5B52 ~            	DB ','
 342+ 5B52 ~            	; get destination begin column
 343+ 5B52 ~            	LD IX, FRMQNT
 344+ 5B52 ~            	CALL CALBAS
 345+ 5B52 ~            	LD A, E
 346+ 5B52 ~            	LD (BLIT_TMP+2), A
 347+ 5B52 ~            	; comma
 348+ 5B52 ~            	CALL CHKCHAR
 349+ 5B52 ~            	DB ','
 350+ 5B52 ~            	; get destination begin row
 351+ 5B52 ~            	LD IX, FRMQNT
 352+ 5B52 ~            	CALL CALBAS
 353+ 5B52 ~            	LD A, E
 354+ 5B52 ~            	LD (BLIT_TMP+3), A
 355+ 5B52 ~            	; comma
 356+ 5B52 ~            	CALL CHKCHAR
 357+ 5B52 ~            	DB ','
 358+ 5B52 ~            	; get number of tiles horizontally
 359+ 5B52 ~            	LD IX, FRMQNT
 360+ 5B52 ~            	CALL CALBAS
 361+ 5B52 ~            	LD (BLIT_STRUCT+10), DE
 362+ 5B52 ~            	; comma
 363+ 5B52 ~            	CALL CHKCHAR
 364+ 5B52 ~            	DB ','
 365+ 5B52 ~            	; get number of tiles vertically
 366+ 5B52 ~            	LD IX, FRMQNT
 367+ 5B52 ~            	CALL CALBAS
 368+ 5B52 ~            	LD (BLIT_STRUCT+12), DE
 369+ 5B52 ~            	; ending )
 370+ 5B52 ~            	CALL CHKCHAR
 371+ 5B52 ~            	DB ')'
 372+ 5B52               ENDIF
 373+ 5B52
 374+ 5B52              .COMMON:
 375+ 5B52 E5           	PUSH HL ; save position in BASIC buffer
 376+ 5B53
 377+ 5B53              	; calculate destination add to value
 378+ 5B53 21 00 01     	LD HL, 256
 379+ 5B56 22 78 5F     	LD (BLIT_STRUCT+8), HL
 380+ 5B59              	; calculate pointer to background location
 381+ 5B59 3A 6F 5F     	LD A,(BLIT_TMP+3)
 382+ 5B5C 67           	LD H,A
 383+ 5B5D 2E 00        	LD L,0
 384+ 5B5F EB           	EX DE,HL
 385+ 5B60 26 00        	LD H,0
 386+ 5B62 3A 6E 5F     	LD A,(BLIT_TMP+2)
 387+ 5B65 6F           	LD L,A
 388+ 5B66 CD E0 5F     	CALL HLx8
 389+ 5B69 19           	ADD HL,DE
 390+ 5B6A ED 5B CB F3  	LD DE,(GRPCGP)
 391+ 5B6E 19           	ADD HL,DE
 392+ 5B6F 22 76 5F     	LD (BLIT_STRUCT+6),HL
 393+ 5B72 FD 21 79 5B  	LD IY, .RET
 394+ 5B76 C3 A4 60     	JP ENABLE_PAGE0
 395+ 5B79              .RET:
 396+ 5B79 FB           	EI
 397+ 5B7A              	; set RAM functions to call
 398+ 5B7A 21 95 5B     	LD HL, .TILECOPY
 399+ 5B7D 22 42 5A     	LD (TILE.CALL2+1), HL
 400+ 5B80 21 9B 5B     	LD HL, .SETDESTROW
 401+ 5B83 22 34 5A     	LD (TILE.CALL1+1), HL
 402+ 5B86 DD 21 70 5F  	LD IX,BLIT_STRUCT
 403+ 5B8A CD 19 5A     	CALL TILE
 404+ 5B8D
 405+ 5B8D D1               POP DE
 406+ 5B8E C1               POP BC
 407+ 5B8F CD 1B 60         CALL RESTORE_PAGE_INFO
 408+ 5B92
 409+ 5B92 E1           	POP HL
 410+ 5B93 AF           	XOR A ; success
 411+ 5B94 C9           	RET
 412+ 5B95              .TILECOPY:
 413+ 5B95 01 98 08     	LD BC, #0898
 414+ 5B98 C3 D8 5F     	JP BBYTECOPY_NO_C
 415+ 5B9B              .SETDESTROW:
 416+ 5B9B 2A 6C 5F     	LD HL, (TILETMP1)
 417+ 5B9E F3           	DI
 418+ 5B9F CD C1 5F     	CALL SETWRT_LOCAL_WRITE
 419+ 5BA2 FB           	EI
 420+ 5BA3 C9           	RET
 421+ 5BA4              ; *******************************************************************************************************
 422+ 5BA4
# file closed: asm\TILE.asm
 168  5BA4               ENDIF
 169  5BA4
 170  5BA4               IF (COLL_CMD == 1)
 171  5BA4               INCLUDE "COLLISION.asm"
# file opened: asm\COLLISION.asm
   1+ 5BA4              ; generic collision checking routines
   2+ 5BA4              ; in BASIC we use rectangle structure array DIM R%(7,n) of the format
   3+ 5BA4              ; R%(0,n) is active flag, <>0 active / 0 skipped in checks
   4+ 5BA4              ; R%(1,n) is either upper left x coordinate or sprite id (0-31) depending on R(7,n)
   5+ 5BA4              ; R%(2,n) is either upper left y coordinate or unused depending on R(7,n)
   6+ 5BA4              ; R%(3,n) x offset where rectangle begins
   7+ 5BA4              ; R%(4,n) y offset where rectangle begins
   8+ 5BA4              ; R%(5,n) is width
   9+ 5BA4              ; R%(6,n) is height
  10+ 5BA4              ; R%(7,0) is type, 0=generic where R%(1,0) contains x coordinate
  11+ 5BA4              ;                  <>0 sprite where R%(1,0) contains sprite id
  12+ 5BA4              ; for type sprite, upper left coordinates are taken from sprite attribute array
  13+ 5BA4
  14+ 5BA4              ; ************************************************************************************************
  15+ 5BA4              ; quick test if HL<=DE<=HL+BC
  16+ 5BA4              ; input BC=width, DE=x, HL=min
  17+ 5BA4              ; if not true flag C set
  18+ 5BA4              ; modifies AF
  19+ 5BA4              GENERIC_INNER_CHECK:
  20+ 5BA4 E5               PUSH HL
  21+ 5BA5 D5               PUSH DE
  22+ 5BA6 EB               EX DE,HL
  23+ 5BA7 A7               AND A
  24+ 5BA8 ED 52            SBC HL, DE
  25+ 5BAA FA B8 5B         JP M, .GENERIC_INNER_CHECK_NOT
  26+ 5BAD A7               AND A
  27+ 5BAE ED 42            SBC HL, BC
  28+ 5BB0 28 03            JR Z, .L2
  29+ 5BB2 F2 B8 5B         JP P, .GENERIC_INNER_CHECK_NOT
  30+ 5BB5              .L2:
  31+ 5BB5 A7               AND A
  32+ 5BB6 18 01            JR .EXIT
  33+ 5BB8              .GENERIC_INNER_CHECK_NOT:
  34+ 5BB8 37               SCF
  35+ 5BB9              .EXIT:
  36+ 5BB9 D1               POP DE
  37+ 5BBA E1               POP HL
  38+ 5BBB C9               RET
  39+ 5BBC              ; ************************************************************************************************
  40+ 5BBC
  41+ 5BBC              ; ************************************************************************************************
  42+ 5BBC              ; function to check if rectangles are overlapping
  43+ 5BBC              ; input IX=IY=pointer to struct
  44+ 5BBC              ;  +00 active flag
  45+ 5BBC              ;  +02 x coordinate
  46+ 5BBC              ;  +04 y coordinate
  47+ 5BBC              ;  +06 x offset where rectangle begins
  48+ 5BBC              ;  +08 y offset where rectangle begins
  49+ 5BBC              ;  +10 width
  50+ 5BBC              ;  +12 height
  51+ 5BBC              ; where IY is used to read +2 and +4, and IX to read +6, +8, +10 and +12
  52+ 5BBC              ; this is a hack to allow location being taken from sprite attributes table
  53+ 5BBC              ; input BLIT_STRUCT data
  54+ 5BBC              ;  +00 x coordinate
  55+ 5BBC              ;  +02 y coordinate
  56+ 5BBC              ;  +04 width
  57+ 5BBC              ;  +06 height
  58+ 5BBC              ; returns CF=1 if not overlapping, CF=0 if overlapping
  59+ 5BBC              RECTANGLE_OVERLAP_CHECK:
  60+ 5BBC                  ; first check which rectangle is higher
  61+ 5BBC DD 6E 0C         LD L,(IX+12)
  62+ 5BBF DD 66 0D         LD H,(IX+13)
  63+ 5BC2 ED 5B 76 5F      LD DE,(BLIT_STRUCT+6)
  64+ 5BC6 A7               AND A
  65+ 5BC7 ED 52            SBC HL,DE
  66+ 5BC9 FD 6E 04         LD L,(IY+4)
  67+ 5BCC FD 66 05         LD H,(IY+5)
  68+ 5BCF DD 5E 08         LD E,(IX+8)
  69+ 5BD2 DD 56 09         LD D,(IX+9)
  70+ 5BD5 FA F5 5B         JP M,.L1
  71+ 5BD8                  ; equally high or IX defined one higher
  72+ 5BD8                  ; check upper boundary
  73+ 5BD8 19               ADD HL,DE
  74+ 5BD9 ED 5B 72 5F      LD DE,(BLIT_STRUCT+2)
  75+ 5BDD DD 4E 0C         LD C,(IX+12)
  76+ 5BE0 DD 46 0D         LD B,(IX+13)
  77+ 5BE3 CD A4 5B         CALL GENERIC_INNER_CHECK
  78+ 5BE6 30 29            JR NC,.INSIDE
  79+ 5BE8                  ; check lower boundary
  80+ 5BE8 E5               PUSH HL
  81+ 5BE9 2A 76 5F         LD HL,(BLIT_STRUCT+6)
  82+ 5BEC 19               ADD HL,DE
  83+ 5BED EB               EX DE,HL
  84+ 5BEE E1               POP HL
  85+ 5BEF CD A4 5B         CALL GENERIC_INNER_CHECK
  86+ 5BF2 30 1D            JR NC,.INSIDE
  87+ 5BF4 C9               RET ; not overlapping
  88+ 5BF5              .L1:
  89+ 5BF5                  ; rectangle defined in BLIT_STRUCT is higher
  90+ 5BF5 19               ADD HL,DE
  91+ 5BF6 EB               EX DE,HL
  92+ 5BF7 2A 72 5F         LD HL,(BLIT_STRUCT+2)
  93+ 5BFA ED 4B 76 5F      LD BC,(BLIT_STRUCT+6)
  94+ 5BFE CD A4 5B         CALL GENERIC_INNER_CHECK
  95+ 5C01 30 0E            JR NC,.INSIDE
  96+ 5C03 E5               PUSH HL
  97+ 5C04 DD 6E 0C         LD L,(IX+12)
  98+ 5C07 DD 66 0D         LD H,(IX+13)
  99+ 5C0A 19               ADD HL,DE
 100+ 5C0B EB               EX DE,HL
 101+ 5C0C E1               POP HL
 102+ 5C0D CD A4 5B         CALL GENERIC_INNER_CHECK
 103+ 5C10 D8               RET C
 104+ 5C11              .INSIDE:
 105+ 5C11                  ; check x coordinate
 106+ 5C11                  ; first check which rectangle is wider
 107+ 5C11 DD 6E 0A         LD L,(IX+10)
 108+ 5C14 DD 66 0B         LD H,(IX+11)
 109+ 5C17 ED 5B 74 5F      LD DE,(BLIT_STRUCT+4)
 110+ 5C1B A7               AND A
 111+ 5C1C ED 52            SBC HL,DE
 112+ 5C1E FD 6E 02         LD L,(IY+2)
 113+ 5C21 FD 66 03         LD H,(IY+3)
 114+ 5C24 DD 5E 06         LD E,(IX+6)
 115+ 5C27 DD 56 07         LD D,(IX+7)
 116+ 5C2A FA 46 5C         JP M,.L2
 117+ 5C2D                  ; equally wide or IX defined one wider
 118+ 5C2D                  ; check left boundary
 119+ 5C2D 19               ADD HL,DE
 120+ 5C2E ED 5B 70 5F      LD DE,(BLIT_STRUCT+0)
 121+ 5C32 DD 4E 0A         LD C,(IX+10)
 122+ 5C35 DD 46 0B         LD B,(IX+11)
 123+ 5C38 CD A4 5B         CALL GENERIC_INNER_CHECK
 124+ 5C3B D0               RET NC ; overlap
 125+ 5C3C                  ; check right boundary
 126+ 5C3C E5               PUSH HL
 127+ 5C3D 2A 74 5F         LD HL,(BLIT_STRUCT+4)
 128+ 5C40 19               ADD HL,DE
 129+ 5C41 EB               EX DE,HL
 130+ 5C42 E1               POP HL
 131+ 5C43 C3 A4 5B         JP GENERIC_INNER_CHECK ; CF and result set by fn call
 132+ 5C46              .L2:
 133+ 5C46                  ; rectangle defined in BLIT_STRUCT is higher
 134+ 5C46 19               ADD HL,DE
 135+ 5C47 EB               EX DE,HL
 136+ 5C48 2A 70 5F         LD HL,(BLIT_STRUCT+0)
 137+ 5C4B ED 4B 74 5F      LD BC,(BLIT_STRUCT+4)
 138+ 5C4F CD A4 5B         CALL GENERIC_INNER_CHECK
 139+ 5C52 D0               RET NC ; overlap
 140+ 5C53 E5               PUSH HL
 141+ 5C54 DD 6E 0A         LD L,(IX+10)
 142+ 5C57 DD 66 0B         LD H,(IX+11)
 143+ 5C5A 19               ADD HL,DE
 144+ 5C5B EB               EX DE,HL
 145+ 5C5C E1               POP HL
 146+ 5C5D C3 A4 5B         JP GENERIC_INNER_CHECK
 147+ 5C60              ; ************************************************************************************************
 148+ 5C60
 149+ 5C60              ; ************************************************************************************************
 150+ 5C60              ; function tries to find rectangle overlap and returns an index if found
 151+ 5C60              ; input BLIT_STRUCT data
 152+ 5C60              ;  +00 x coordinate
 153+ 5C60              ;  +02 y coordinate
 154+ 5C60              ;  +04 width
 155+ 5C60              ;  +06 height
 156+ 5C60              ;  +08 number of items in a list, described under RECTANGLE_OVERLAP_CHECK
 157+ 5C60              ;  +09 pointer to first element of R%(7,n)
 158+ 5C60              ;  +11 pointer to INT result variable
 159+ 5C60              ; returns CF=1 if not overlapping
 160+ 5C60              ; returns A=list index and CF=0 if overlapping
 161+ 5C60              FIND_OVERLAP:
 162+ 5C60 3A 78 5F         LD A,(BLIT_STRUCT+8)
 163+ 5C63 47               LD B,A
 164+ 5C64 DD 2A 79 5F      LD IX,(BLIT_STRUCT+9)
 165+ 5C68              .L1:
 166+ 5C68 C5               PUSH BC
 167+ 5C69                  ; check active flag
 168+ 5C69 DD 7E 00         LD A,(IX)
 169+ 5C6C DD B6 01         OR (IX+1)
 170+ 5C6F 28 18            JR Z,.NEXT
 171+ 5C71                  ; check type
 172+ 5C71 DD 7E 0E         LD A,(IX+14)
 173+ 5C74 DD B6 0F         OR (IX+15)
 174+ 5C77 20 1A            JR NZ,.L2
 175+ 5C79 DD E5            PUSH IX
 176+ 5C7B FD E1            POP IY
 177+ 5C7D              .L3:
 178+ 5C7D CD BC 5B         CALL RECTANGLE_OVERLAP_CHECK
 179+ 5C80 38 07            JR C,.NEXT
 180+ 5C82                  ; found
 181+ 5C82 C1               POP BC
 182+ 5C83 3A 78 5F         LD A,(BLIT_STRUCT+8)
 183+ 5C86 90               SUB B
 184+ 5C87 A7               AND A
 185+ 5C88 C9               RET
 186+ 5C89              .NEXT:
 187+ 5C89 11 10 00         LD DE,16
 188+ 5C8C DD 19            ADD IX,DE
 189+ 5C8E C1               POP BC
 190+ 5C8F 10 D7            DJNZ .L1
 191+ 5C91 37               SCF
 192+ 5C92 C9               RET
 193+ 5C93              .L2:
 194+ 5C93                  ; sprite, need to build a temporary data struct since x and y values are inversed
 195+ 5C93                  ; at BLIT_STRUCT+13
 196+ 5C93 DD 7E 02         LD A,(IX+2) ; sprite ID
 197+ 5C96 CD 90 4D         CALL GETnthSPRATTR
 198+ 5C99 FD 21 7B 5F      LD IY,BLIT_STRUCT+11
 199+ 5C9D 7E               LD A,(HL)
 200+ 5C9E FD 77 04         LD (IY+4),A
 201+ 5CA1 23               INC HL
 202+ 5CA2 7E               LD A,(HL)
 203+ 5CA3 FD 77 05         LD (IY+5),A
 204+ 5CA6 23               INC HL
 205+ 5CA7 7E               LD A,(HL)
 206+ 5CA8 FD 77 02         LD (IY+2),A
 207+ 5CAB 23               INC HL
 208+ 5CAC 7E               LD A,(HL)
 209+ 5CAD FD 77 03         LD (IY+3),A
 210+ 5CB0 18 CB            JR .L3
 211+ 5CB2              ; ************************************************************************************************
 212+ 5CB2
 213+ 5CB2               IF (0 == 1)
 214+ 5CB2 ~            ; ************************************************************************************************
 215+ 5CB2 ~            ; function to handle CALL COLL basic extension
 216+ 5CB2 ~            ; checks for collision between player and other rectangles
 217+ 5CB2 ~            ; COLL ( INT result variable,
 218+ 5CB2 ~            ;	     INT player x value,
 219+ 5CB2 ~            ;	     INT player y value,
 220+ 5CB2 ~            ;	     INT player width,
 221+ 5CB2 ~            ;	     INT player height,
 222+ 5CB2 ~            ;	     INT number of items in a list,
 223+ 5CB2 ~            ;		 INT[6][n] rectangle struct )
 224+ 5CB2 ~            ; will fill result variable with index or -1 if no collision
 225+ 5CB2 ~            ; rectangle struct described under RECTANGLE_OVERLAP_CHECK
 226+ 5CB2 ~            COLL:
 227+ 5CB2 ~            	; opening (
 228+ 5CB2 ~            	CALL CHKCHAR
 229+ 5CB2 ~            	DB '('
 230+ 5CB2 ~            	; get address of result variable
 231+ 5CB2 ~            	LD IX, PTRGET
 232+ 5CB2 ~            	CALL CALBAS
 233+ 5CB2 ~            	LD (BLIT_STRUCT+11),DE
 234+ 5CB2 ~            	; comma
 235+ 5CB2 ~            	CALL CHKCHAR
 236+ 5CB2 ~            	DB ','
 237+ 5CB2 ~            	; get x
 238+ 5CB2 ~            	LD IX, FRMQNT
 239+ 5CB2 ~            	CALL CALBAS
 240+ 5CB2 ~            	LD (BLIT_STRUCT+0),DE
 241+ 5CB2 ~            	; comma
 242+ 5CB2 ~            	CALL CHKCHAR
 243+ 5CB2 ~            	DB ','
 244+ 5CB2 ~            	; get y
 245+ 5CB2 ~            	LD IX, FRMQNT
 246+ 5CB2 ~            	CALL CALBAS
 247+ 5CB2 ~            	LD (BLIT_STRUCT+2),DE
 248+ 5CB2 ~            	; comma
 249+ 5CB2 ~            	CALL CHKCHAR
 250+ 5CB2 ~            	DB ','
 251+ 5CB2 ~            	; get width
 252+ 5CB2 ~            	LD IX, FRMQNT
 253+ 5CB2 ~            	CALL CALBAS
 254+ 5CB2 ~            	LD (BLIT_STRUCT+4),DE
 255+ 5CB2 ~            	; comma
 256+ 5CB2 ~            	CALL CHKCHAR
 257+ 5CB2 ~            	DB ','
 258+ 5CB2 ~            	; get height
 259+ 5CB2 ~            	LD IX, FRMQNT
 260+ 5CB2 ~            	CALL CALBAS
 261+ 5CB2 ~            	LD (BLIT_STRUCT+6),DE
 262+ 5CB2 ~            	; comma
 263+ 5CB2 ~            	CALL CHKCHAR
 264+ 5CB2 ~            	DB ','
 265+ 5CB2 ~            	; get number of items in a list
 266+ 5CB2 ~            	LD IX, GETBYT
 267+ 5CB2 ~            	CALL CALBAS
 268+ 5CB2 ~            	LD (BLIT_STRUCT+8),A
 269+ 5CB2 ~            	; comma
 270+ 5CB2 ~            	CALL CHKCHAR
 271+ 5CB2 ~            	DB ','
 272+ 5CB2 ~            	; get address of rectangle structure array DIM R%(7,n)
 273+ 5CB2 ~            	LD A,(BLIT_STRUCT+8)
 274+ 5CB2 ~                LD E,A
 275+ 5CB2 ~                LD A,2
 276+ 5CB2 ~            	LD B,A
 277+ 5CB2 ~            	LD D,7
 278+ 5CB2 ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
 279+ 5CB2 ~            	LD (BLIT_STRUCT+9),BC
 280+ 5CB2 ~            	; ending )
 281+ 5CB2 ~            	CALL CHKCHAR
 282+ 5CB2 ~            	DB ')'
 283+ 5CB2 ~
 284+ 5CB2 ~                PUSH HL
 285+ 5CB2 ~                CALL FIND_OVERLAP
 286+ 5CB2 ~                LD HL,(BLIT_STRUCT+11)
 287+ 5CB2 ~                JR C,.NOTFOUND
 288+ 5CB2 ~                LD (HL),A
 289+ 5CB2 ~                INC HL
 290+ 5CB2 ~                LD (HL),0
 291+ 5CB2 ~                POP HL
 292+ 5CB2 ~                RET
 293+ 5CB2 ~            .NOTFOUND:
 294+ 5CB2 ~                LD (HL),#FF
 295+ 5CB2 ~                INC HL
 296+ 5CB2 ~                LD (HL),#FF
 297+ 5CB2 ~                POP HL
 298+ 5CB2 ~                RET
 299+ 5CB2 ~            ; ************************************************************************************************
 300+ 5CB2               ENDIF
 301+ 5CB2
 302+ 5CB2               IF (1 == 1)
 303+ 5CB2              ; *******************************************************************************************************
 304+ 5CB2              ; same as COLL but for DEFUSR approach
 305+ 5CB2              ; input IX=pointer to input array, real data from +2
 306+ 5CB2              ; +02 = pointer to result variable
 307+ 5CB2              ; +04 = player X
 308+ 5CB2              ; +06 = player Y
 309+ 5CB2              ; +08 = player width
 310+ 5CB2              ; +10 = player height
 311+ 5CB2              ; +12 = number of list items
 312+ 5CB2              ; +14 = pointer to list of collidable objects
 313+ 5CB2              COLL_DEFUSR:
 314+ 5CB2 DD E5            PUSH IX
 315+ 5CB4 E1               POP HL
 316+ 5CB5 23          > INC HL ; skip over to player x
 316+ 5CB6 23          > INC HL
 316+ 5CB7 23          > INC HL
 316+ 5CB8 23          > INC HL
 317+ 5CB9 11 70 5F         LD DE,BLIT_STRUCT
 318+ 5CBC 01 09 00         LD BC,9
 319+ 5CBF ED B0            LDIR ; copy over x,y,w,h,list item number
 320+ 5CC1 DD 7E 0E         LD A,(IX+14)
 321+ 5CC4 32 79 5F         LD (BLIT_STRUCT+9),A
 322+ 5CC7 DD 7E 0F         LD A,(IX+15)
 323+ 5CCA 32 7A 5F         LD (BLIT_STRUCT+10),A ; address to collidable objects array
 324+ 5CCD DD 7E 02         LD A,(IX+2)
 325+ 5CD0 32 7B 5F         LD (BLIT_STRUCT+11),A
 326+ 5CD3 DD 7E 03         LD A,(IX+3)
 327+ 5CD6 32 7C 5F         LD (BLIT_STRUCT+12),A ; address to results variable
 328+ 5CD9 DD E5            PUSH IX
 329+ 5CDB CD 60 5C         CALL FIND_OVERLAP
 330+ 5CDE DD E1            POP IX
 331+ 5CE0 DD 6E 02         LD L,(IX+2)
 332+ 5CE3 DD 66 03         LD H,(IX+3)
 333+ 5CE6 38 06            JR C,.NOTFOUND
 334+ 5CE8 77               LD (HL),A
 335+ 5CE9 23               INC HL
 336+ 5CEA 36 00            LD (HL),0
 337+ 5CEC              .EXIT:
 338+ 5CEC AF               XOR A ; success
 339+ 5CED C9               RET
 340+ 5CEE              .NOTFOUND:
 341+ 5CEE 36 FF            LD (HL),#FF
 342+ 5CF0 23               INC HL
 343+ 5CF1 36 FF            LD (HL),#FF
 344+ 5CF3 18 F7            JR .EXIT
 345+ 5CF5              ; *******************************************************************************************************
 346+ 5CF5               ENDIF
 347+ 5CF5
# file closed: asm\COLLISION.asm
 172  5CF5               ENDIF
 173  5CF5
 174  5CF5               IF (DECOMP_CMDS == 1)
 175  5CF5               INCLUDE "decomp.asm"
# file opened: asm\decomp.asm
   1+ 5CF5              ; -----------------------------------------------------------------------------
   2+ 5CF5              ; ZX0 decoder by Einar Saukas & Urusergi
   3+ 5CF5              ; "Standard" version (68 bytes only)
   4+ 5CF5              ; -----------------------------------------------------------------------------
   5+ 5CF5              ; Parameters:
   6+ 5CF5              ;   HL: source address (compressed data)
   7+ 5CF5              ;   DE: destination address (decompressing)
   8+ 5CF5              ; -----------------------------------------------------------------------------
   9+ 5CF5
  10+ 5CF5              dzx0_standard:
  11+ 5CF5 01 FF FF             ld      bc, $ffff               ; preserve default offset 1
  12+ 5CF8 C5                   push    bc
  13+ 5CF9 03                   inc     bc
  14+ 5CFA 3E 80                ld      a, $80
  15+ 5CFC              dzx0s_literals:
  16+ 5CFC CD 2C 5D             call    dzx0s_elias             ; obtain length
  17+ 5CFF              dzx0_ldir_1:
  18+ 5CFF ED B0                ldir                            ; copy literals
  19+ 5D01 00                   nop                             ; placeholder for call
  20+ 5D02 87                   add     a, a                    ; copy from last offset or new offset?
  21+ 5D03 38 0E                jr      c, dzx0s_new_offset
  22+ 5D05 CD 2C 5D             call    dzx0s_elias             ; obtain length
  23+ 5D08              dzx0s_copy:
  24+ 5D08 E3                   ex      (sp), hl                ; preserve source, restore offset
  25+ 5D09 E5                   push    hl                      ; preserve offset
  26+ 5D0A 19                   add     hl, de                  ; calculate destination - offset
  27+ 5D0B              dzx0_ldir_2:
  28+ 5D0B ED B0                ldir                            ; copy from offset
  29+ 5D0D 00                   nop                             ; placeholder for call
  30+ 5D0E E1                   pop     hl                      ; restore offset
  31+ 5D0F E3                   ex      (sp), hl                ; preserve offset, restore source
  32+ 5D10 87                   add     a, a                    ; copy from literals or new offset?
  33+ 5D11 30 E9                jr      nc, dzx0s_literals
  34+ 5D13              dzx0s_new_offset:
  35+ 5D13 C1                   pop     bc                      ; discard last offset
  36+ 5D14 0E FE                ld      c, $fe                  ; prepare negative offset
  37+ 5D16 CD 2D 5D             call    dzx0s_elias_loop        ; obtain offset MSB
  38+ 5D19 0C                   inc     c
  39+ 5D1A C8                   ret     z                       ; check end marker
  40+ 5D1B 41                   ld      b, c
  41+ 5D1C 4E                   ld      c, (hl)                 ; obtain offset LSB
  42+ 5D1D 23                   inc     hl
  43+ 5D1E CB 18                rr      b                       ; last offset bit becomes first length bit
  44+ 5D20 CB 19                rr      c
  45+ 5D22 C5                   push    bc                      ; preserve new offset
  46+ 5D23 01 01 00             ld      bc, 1                   ; obtain length
  47+ 5D26 D4 34 5D             call    nc, dzx0s_elias_backtrack
  48+ 5D29 03                   inc     bc
  49+ 5D2A 18 DC                jr      dzx0s_copy
  50+ 5D2C              dzx0s_elias:
  51+ 5D2C 0C                   inc     c                       ; interlaced Elias gamma coding
  52+ 5D2D              dzx0s_elias_loop:
  53+ 5D2D 87                   add     a, a
  54+ 5D2E 20 03                jr      nz, dzx0s_elias_skip
  55+ 5D30 7E                   ld      a, (hl)                 ; load another group of 8 bits
  56+ 5D31 23                   inc     hl
  57+ 5D32 17                   rla
  58+ 5D33              dzx0s_elias_skip:
  59+ 5D33 D8                   ret     c
  60+ 5D34              dzx0s_elias_backtrack:
  61+ 5D34 87                   add     a, a
  62+ 5D35 CB 11                rl      c
  63+ 5D37 CB 10                rl      b
  64+ 5D39 18 F2                jr      dzx0s_elias_loop
  65+ 5D3B              ; -----------------------------------------------------------------------------
  66+ 5D3B
  67+ 5D3B              ; *******************************************************************************************************
  68+ 5D3B              ; helper function for VRAM unpack to save AF prior to calling copy to VRAM fn
  69+ 5D3B              ; also simulates register states as if LDIR was called
  70+ 5D3B              LDIR_TO_VRAM:
  71+ 5D3B F5                   PUSH AF ; save AF used by algorithm
  72+ 5D3C D5                   PUSH DE
  73+ 5D3D C5                   PUSH BC
  74+ 5D3E CD A1 56             CALL VRAM_LDIRVM
  75+ 5D41 C1                   POP BC
  76+ 5D42 EB                   EX DE,HL
  77+ 5D43 E1                   POP HL
  78+ 5D44 09                   ADD HL,BC
  79+ 5D45 EB                   EX DE,HL
  80+ 5D46 01 00 00             LD BC,0
  81+ 5D49 F1                   POP AF
  82+ 5D4A C9                   RET
  83+ 5D4B              ; *******************************************************************************************************
  84+ 5D4B
  85+ 5D4B              ; *******************************************************************************************************
  86+ 5D4B              ; helper function to get a byte from VRAM address at HL and place it at DE also in VRAM
  87+ 5D4B              VPOKE_VPEEK:
  88+ 5D4B F3                   DI
  89+ 5D4C CD CC 5F             CALL SETWRT_LOCAL_READ
  90+ 5D4F E3                   EX (SP),HL
  91+ 5D50 E3                   EX (SP),HL
  92+ 5D51 DB 98                IN A,(#98)
  93+ 5D53                      ;IN A,(#98) ; WHY IS THIS NEEDED ?
  94+ 5D53 F5                   PUSH AF
  95+ 5D54 EB                   EX DE,HL
  96+ 5D55 CD C1 5F             CALL SETWRT_LOCAL_WRITE
  97+ 5D58 E3                   EX (SP),HL
  98+ 5D59 E3                   EX (SP),HL
  99+ 5D5A EB                   EX DE,HL
 100+ 5D5B F1                   POP AF
 101+ 5D5C D3 98                OUT (#98),A
 102+ 5D5E FB                   EI
 103+ 5D5F C9                   RET
 104+ 5D60              ; *******************************************************************************************************
 105+ 5D60
 106+ 5D60              ; *******************************************************************************************************
 107+ 5D60              ; helper fn VRAM variant of LDIR
 108+ 5D60              ; input HL = source, DE = destination, BC = count
 109+ 5D60              VRAM_LDIR:
 110+ 5D60 F5                   PUSH AF
 111+ 5D61              _L0:
 112+ 5D61 CD 4B 5D             CALL VPOKE_VPEEK
 113+ 5D64 23                   INC HL
 114+ 5D65 13                   INC DE
 115+ 5D66 0B                   DEC BC
 116+ 5D67 78                   LD A, B
 117+ 5D68 B1                   OR C
 118+ 5D69 20 F6                JR NZ, _L0
 119+ 5D6B F1                   POP AF
 120+ 5D6C C9                   RET
 121+ 5D6D              ; *******************************************************************************************************
 122+ 5D6D
 123+ 5D6D               IF (0 == 1)
 124+ 5D6D ~            ; *******************************************************************************************************
 125+ 5D6D ~            ; function to handle CALL VUNPACK basic extension
 126+ 5D6D ~            ; _VUNPACK ( INT source,
 127+ 5D6D ~            ;			 INT destination )
 128+ 5D6D ~            ; will put ram in page 0 also, page 1 is already there
 129+ 5D6D ~            ; *******************************************************************************************************
 130+ 5D6D ~            VUNPACK:
 131+ 5D6D ~                LD A, #CD ; CALL
 132+ 5D6D ~                LD (dzx0_ldir_1), A
 133+ 5D6D ~                LD (dzx0_ldir_2), A
 134+ 5D6D ~                LD DE, LDIR_TO_VRAM
 135+ 5D6D ~                LD (dzx0_ldir_1 + 1), DE
 136+ 5D6D ~                LD DE, VRAM_LDIR
 137+ 5D6D ~                LD (dzx0_ldir_2 + 1), DE
 138+ 5D6D ~                JR UNPACK_COMMON
 139+ 5D6D ~            ; function to handle CALL UNPACK basic extension
 140+ 5D6D ~            ; _UNPACK ( INT source,
 141+ 5D6D ~            ;			INT destination )
 142+ 5D6D ~            ; will put ram in page 0 also, page 1 is already there
 143+ 5D6D ~            UNPACK:
 144+ 5D6D ~                LD DE, #B0ED ; LDIR
 145+ 5D6D ~                LD (dzx0_ldir_1), DE
 146+ 5D6D ~                LD (dzx0_ldir_2), DE
 147+ 5D6D ~                XOR A ; NOP
 148+ 5D6D ~                LD (dzx0_ldir_1 + 2), A
 149+ 5D6D ~                LD (dzx0_ldir_2 + 2), A
 150+ 5D6D ~            UNPACK_COMMON:
 151+ 5D6D ~            	; opening (
 152+ 5D6D ~            	CALL CHKCHAR
 153+ 5D6D ~            	DB '('
 154+ 5D6D ~            	; get source address
 155+ 5D6D ~            	LD IX, FRMQNT
 156+ 5D6D ~            	CALL CALBAS
 157+ 5D6D ~            	PUSH DE
 158+ 5D6D ~            	; comma
 159+ 5D6D ~            	CALL CHKCHAR
 160+ 5D6D ~            	DB ','
 161+ 5D6D ~            	; get destination address
 162+ 5D6D ~            	LD IX, FRMQNT
 163+ 5D6D ~            	CALL CALBAS
 164+ 5D6D ~            	PUSH DE
 165+ 5D6D ~            	; ending )
 166+ 5D6D ~            	CALL CHKCHAR
 167+ 5D6D ~            	DB ')'
 168+ 5D6D ~
 169+ 5D6D ~            	; save position
 170+ 5D6D ~            	PUSH HL
 171+ 5D6D ~            	POP IX
 172+ 5D6D ~
 173+ 5D6D ~            	POP DE ; destination
 174+ 5D6D ~            	POP HL ; source
 175+ 5D6D ~            	EXX
 176+ 5D6D ~            	; enable page 0
 177+ 5D6D ~            	LD IY, .RET
 178+ 5D6D ~            	JP ENABLE_PAGE0
 179+ 5D6D ~            .RET:
 180+ 5D6D ~            	EI
 181+ 5D6D ~            	EXX
 182+ 5D6D ~            	CALL dzx0_standard
 183+ 5D6D ~                    POP DE
 184+ 5D6D ~                    POP BC
 185+ 5D6D ~                    CALL RESTORE_PAGE_INFO
 186+ 5D6D ~            	PUSH IX
 187+ 5D6D ~            	POP HL
 188+ 5D6D ~            	RET
 189+ 5D6D ~            ; *******************************************************************************************************
 190+ 5D6D               ENDIF
 191+ 5D6D
 192+ 5D6D               IF (1 == 1)
 193+ 5D6D              ; *******************************************************************************************************
 194+ 5D6D              ; same as VUNPACK but for DEFUSR approach
 195+ 5D6D              ; input IX=pointer to input array, real data from +2
 196+ 5D6D              ; +2 = source address
 197+ 5D6D              ; +4 = destination address
 198+ 5D6D              ; *******************************************************************************************************
 199+ 5D6D              VUNPACK_DEFUSR:
 200+ 5D6D 3E CD            LD A, #CD ; CALL
 201+ 5D6F 32 FF 5C         LD (dzx0_ldir_1), A
 202+ 5D72 32 0B 5D         LD (dzx0_ldir_2), A
 203+ 5D75 21 3B 5D         LD HL, LDIR_TO_VRAM
 204+ 5D78 22 00 5D         LD (dzx0_ldir_1 + 1), HL
 205+ 5D7B 21 60 5D         LD HL, VRAM_LDIR
 206+ 5D7E 22 0C 5D         LD (dzx0_ldir_2 + 1), HL
 207+ 5D81 18 10            JR UNPACK_DEFUSR_COMMON
 208+ 5D83              ; same as UNPACK but for DEFUSR approach
 209+ 5D83              ; input IX=pointer to input array, real data from +2
 210+ 5D83              ; +2 = source address
 211+ 5D83              ; +4 = destination address
 212+ 5D83              UNPACK_DEFUSR:
 213+ 5D83 21 ED B0         LD HL, #B0ED ; LDIR
 214+ 5D86 22 FF 5C         LD (dzx0_ldir_1), HL
 215+ 5D89 22 0B 5D         LD (dzx0_ldir_2), HL
 216+ 5D8C AF               XOR A ; NOP
 217+ 5D8D 32 01 5D         LD (dzx0_ldir_1 + 2), A
 218+ 5D90 32 0D 5D         LD (dzx0_ldir_2 + 2), A
 219+ 5D93              UNPACK_DEFUSR_COMMON:
 220+ 5D93              	; enable page 0
 221+ 5D93 FD 21 9A 5D  	LD IY, .RET
 222+ 5D97 C3 A4 60     	JP ENABLE_PAGE0
 223+ 5D9A              .RET:
 224+ 5D9A FB           	EI
 225+ 5D9B DD 6E 02     	LD L,(IX+2)
 226+ 5D9E DD 66 03     	LD H,(IX+3)
 227+ 5DA1 DD 5E 04     	LD E,(IX+4)
 228+ 5DA4 DD 56 05     	LD D,(IX+5)
 229+ 5DA7 CD F5 5C     	CALL dzx0_standard
 230+ 5DAA D1               POP DE
 231+ 5DAB C1               POP BC
 232+ 5DAC CD 1B 60         CALL RESTORE_PAGE_INFO
 233+ 5DAF AF               XOR A ; success
 234+ 5DB0 C9               RET
 235+ 5DB1              ; *******************************************************************************************************
 236+ 5DB1               ENDIF
# file closed: asm\decomp.asm
 176  5DB1               ENDIF
 177  5DB1
 178  5DB1               IF (DLOAD_CMD == 1)
 179  5DB1               INCLUDE "DLOAD.asm"
# file opened: asm\DLOAD.asm
   1+ 5DB1              BDOS_SETDTA     EQU #1A
   2+ 5DB1              BDOS_OPEN       EQU #0F
   3+ 5DB1              BDOS_CLOSE      EQU #10
   4+ 5DB1              BDOS_RDBLK      EQU #27
   5+ 5DB1
   6+ 5DB1              ; *******************************************************************************************************
   7+ 5DB1              ; function processes file name
   8+ 5DB1              ; filenames supported are D:FILENAME.EXT, FILENAME.EXT, D:FILENAME, FILENAME
   9+ 5DB1              ; FCB 0 will be zeroed out
  10+ 5DB1              ; FCB 0 will be populated with drive info 0=default or 1-8 for drives A-H
  11+ 5DB1              ; FCB 0 will be populated with file name
  12+ 5DB1              ; input HL=pointer to expression
  13+ 5DB1              ; input B=length
  14+ 5DB1              ; returns CF=1 if bad filename
  15+ 5DB1              DLOAD_PROCESS_FILENAME:
  16+ 5DB1                  ; check for zero size
  17+ 5DB1 78               LD A,B
  18+ 5DB2 B7               OR A
  19+ 5DB3 28 6B            JR Z, .BADFILENAME
  20+ 5DB5                  ; check for more than 2+8+1+3=14
  21+ 5DB5 FE 0F            CP 15
  22+ 5DB7 30 67            JR NC, .BADFILENAME
  23+ 5DB9                  ; check if more than 2 letters
  24+ 5DB9 FE 03            CP 3
  25+ 5DBB 38 1C            JR C, .L7 ; no drive
  26+ 5DBD                  ; check for : at proper place
  27+ 5DBD 5E               LD E, (HL)
  28+ 5DBE 23               INC HL
  29+ 5DBF 7E               LD A, (HL)
  30+ 5DC0 FE 3A            CP ':'
  31+ 5DC2 20 14            JR NZ, .L1
  32+ 5DC4                  ; so we have : , check for letters A-H
  33+ 5DC4 7B               LD A,E
  34+ 5DC5 CD 10 61         CALL UPPER
  35+ 5DC8 D6 41            SUB 'A'
  36+ 5DCA FE 09            CP 9
  37+ 5DCC 30 52            JR NC, .BADFILENAME
  38+ 5DCE 23               INC HL
  39+ 5DCF 05               DEC B ; consume two characters
  40+ 5DD0 05               DEC B
  41+ 5DD1              .L2:
  42+ 5DD1 ED 5B 53 F3      LD DE, (FCB0)
  43+ 5DD5 12               LD (DE), A
  44+ 5DD6 18 04            JR .PROCESS_FILENAME
  45+ 5DD8              .L1:
  46+ 5DD8                  ; no drive specified
  47+ 5DD8 2B               DEC HL
  48+ 5DD9              .L7:
  49+ 5DD9 AF               XOR A
  50+ 5DDA 18 F5            JR .L2
  51+ 5DDC              .PROCESS_FILENAME:
  52+ 5DDC                  ; HL is pointing to rest of the name
  53+ 5DDC 13               INC DE ; 8-character filename location, needs to be padded with blanks
  54+ 5DDD 0E 08            LD C,8 ; filename length
  55+ 5DDF              .L4:
  56+ 5DDF CD 22 5E         CALL .GETCHAR
  57+ 5DE2 FE 2E            CP '.'
  58+ 5DE4 28 31            JR Z, .L6 ; if dot, fill rest with blanks
  59+ 5DE6 12               LD (DE),A
  60+ 5DE7 13               INC DE
  61+ 5DE8 0D               DEC C
  62+ 5DE9 20 F4            JR NZ, .L4
  63+ 5DEB                  ; so we cleared filename part
  64+ 5DEB 78               LD A,B ; no more letters. just fill extension with blanks
  65+ 5DEC B7               OR A
  66+ 5DED 28 07            JR Z, .L8
  67+ 5DEF CD 22 5E         CALL .GETCHAR ; here we must have . for a valid name
  68+ 5DF2 FE 2E            CP '.'
  69+ 5DF4 20 2A            JR NZ, .BADFILENAME
  70+ 5DF6              .L8:
  71+ 5DF6 0E 03            LD C,3
  72+ 5DF8              .L5:
  73+ 5DF8 CD 22 5E         CALL .GETCHAR
  74+ 5DFB 12               LD (DE),A
  75+ 5DFC 13               INC DE
  76+ 5DFD 0D               DEC C
  77+ 5DFE 20 F8            JR NZ, .L5
  78+ 5E00 78               LD A,B ; nothing must be left in buffer
  79+ 5E01 B7               OR A
  80+ 5E02 20 1C            JR NZ, .BADFILENAME
  81+ 5E04                  ; file name correct, now zero out the rest of FCB 0
  82+ 5E04 2A 53 F3         LD HL,(FCB0)
  83+ 5E07 11 0C 00         LD DE,12
  84+ 5E0A 19               ADD HL,DE
  85+ 5E0B 36 00            LD (HL),0
  86+ 5E0D 54               LD D,H
  87+ 5E0E 5D               LD E,L
  88+ 5E0F 13               INC DE
  89+ 5E10 01 18 00         LD BC,37-12-1
  90+ 5E13 ED B0            LDIR
  91+ 5E15 AF               XOR A ; clear carry flag
  92+ 5E16 C9               RET
  93+ 5E17              .L6:
  94+ 5E17 3E 20            LD A,' '
  95+ 5E19              .L9:
  96+ 5E19 12               LD (DE),A
  97+ 5E1A 13               INC DE
  98+ 5E1B 0D               DEC C
  99+ 5E1C 20 FB            JR NZ, .L9
 100+ 5E1E 18 D6            JR .L8
 101+ 5E20              .BADFILENAME:
 102+ 5E20 37               SCF
 103+ 5E21 C9               RET
 104+ 5E22              .GETCHAR: ; gets a character, returns blank if we read past input
 105+ 5E22 78               LD A,B
 106+ 5E23 B7               OR A
 107+ 5E24 28 07            JR Z, .BLANK
 108+ 5E26 7E               LD A,(HL)
 109+ 5E27 CD 10 61         CALL UPPER
 110+ 5E2A 23               INC HL
 111+ 5E2B 05               DEC B
 112+ 5E2C C9               RET
 113+ 5E2D              .BLANK:
 114+ 5E2D 3E 20            LD A,' '
 115+ 5E2F C9               RET
 116+ 5E30              ; *******************************************************************************************************
 117+ 5E30
 118+ 5E30              ; *******************************************************************************************************
 119+ 5E30              ; function sets disk buffer from NULBUF
 120+ 5E30              ; input none
 121+ 5E30              ; returns ZF!=1 on error
 122+ 5E30              DLOAD_SETDTA:
 123+ 5E30 ED 5B 62 F8      LD DE,(NULBUF)
 124+ 5E34 0E 1A            LD C, BDOS_SETDTA
 125+ 5E36 18 24            JR BDOS_CALL
 126+ 5E38              ; *******************************************************************************************************
 127+ 5E38
 128+ 5E38              ; *******************************************************************************************************
 129+ 5E38              ; function opens a file using FCB 0
 130+ 5E38              ; input none
 131+ 5E38              ; returns ZF!=1 on error
 132+ 5E38              DLOAD_OPENFILE:
 133+ 5E38 ED 5B 53 F3      LD DE,(FCB0)
 134+ 5E3C 0E 0F            LD C, BDOS_OPEN
 135+ 5E3E 18 1C            JR BDOS_CALL
 136+ 5E40              ; *******************************************************************************************************
 137+ 5E40
 138+ 5E40              ; *******************************************************************************************************
 139+ 5E40              ; function makes a file seek and sets record size to 1 byte
 140+ 5E40              ; input none
 141+ 5E40              ; output node
 142+ 5E40              DLOAD_SEEK:
 143+ 5E40 2A 70 5F         LD HL,(BLIT_STRUCT)
 144+ 5E43 DD 2A 53 F3      LD IX,(FCB0)
 145+ 5E47 DD 75 21         LD (IX+33),L
 146+ 5E4A DD 74 22         LD (IX+34),H
 147+ 5E4D DD 36 0E 01      LD (IX+14),1
 148+ 5E51 DD 36 0F 00      LD (IX+15),0
 149+ 5E55 C9               RET
 150+ 5E56              ; *******************************************************************************************************
 151+ 5E56
 152+ 5E56              ; *******************************************************************************************************
 153+ 5E56              ; function reads a number of bytes from a file using FCB 0 to (NULBUF) buffer
 154+ 5E56              ; input HL=number of bytes to read
 155+ 5E56              ; returns HL=number of bytes read
 156+ 5E56              ; returns ZF!=1 on error
 157+ 5E56              DLOAD_READ:
 158+ 5E56 ED 5B 53 F3      LD DE,(FCB0)
 159+ 5E5A 0E 27            LD C,BDOS_RDBLK
 160+ 5E5C              BDOS_CALL:
 161+ 5E5C CD 7D F3         CALL BDOS
 162+ 5E5F B7               OR A
 163+ 5E60 C9               RET
 164+ 5E61              ; *******************************************************************************************************
 165+ 5E61
 166+ 5E61              ; *******************************************************************************************************
 167+ 5E61              ; function closes a file FCB 0
 168+ 5E61              ; input none
 169+ 5E61              ; returns ZF!=1 on error
 170+ 5E61              DLOAD_CLOSE:
 171+ 5E61 AF               XOR A
 172+ 5E62 ED 5B 53 F3      LD DE,(FCB0)
 173+ 5E66 0E 10            LD C,BDOS_CLOSE
 174+ 5E68 18 F2            JR BDOS_CALL
 175+ 5E6A              ; *******************************************************************************************************
 176+ 5E6A
 177+ 5E6A              ; *******************************************************************************************************
 178+ 5E6A              ; function copies data from (NULBUF) to destination, enables RAM in page 0
 179+ 5E6A              ; input BC=number of bytes to copy
 180+ 5E6A              ; output none
 181+ 5E6A              DLOAD_TRANSFERBLOCK:
 182+ 5E6A D9               EXX ; save BC
 183+ 5E6B              	; enable page 0
 184+ 5E6B FD 21 72 5E  	LD IY, .RET
 185+ 5E6F C3 A4 60     	JP ENABLE_PAGE0
 186+ 5E72              .RET:
 187+ 5E72 FB           	EI
 188+ 5E73 D9               EXX
 189+ 5E74 ED 5B 72 5F      LD DE,(BLIT_STRUCT+2)
 190+ 5E78 2A 62 F8         LD HL,(NULBUF)
 191+ 5E7B ED B0        	LDIR
 192+ 5E7D ED 53 72 5F      LD (BLIT_STRUCT+2),DE
 193+ 5E81 D1               POP DE
 194+ 5E82 C1               POP BC
 195+ 5E83 C3 1B 60         JP RESTORE_PAGE_INFO
 196+ 5E86              ; *******************************************************************************************************
 197+ 5E86
 198+ 5E86              ; *******************************************************************************************************
 199+ 5E86              ; function opens and loads a file in FCB 0
 200+ 5E86              ; file name needs to be already set in FCB 0
 201+ 5E86              ; input none
 202+ 5E86              ; returns ZF!=1 on error
 203+ 5E86              DLOAD_LOADFILE:
 204+ 5E86 CD 30 5E         CALL DLOAD_SETDTA
 205+ 5E89 CD 38 5E         CALL DLOAD_OPENFILE
 206+ 5E8C C0               RET NZ
 207+ 5E8D CD 40 5E         CALL DLOAD_SEEK
 208+ 5E90 ED 4B 74 5F      LD BC,(BLIT_STRUCT+4)
 209+ 5E94              .L1:
 210+ 5E94 78               LD A,B
 211+ 5E95 B7               OR A
 212+ 5E96 28 12            JR Z,.REST
 213+ 5E98 05               DEC B
 214+ 5E99 21 00 01         LD HL,256
 215+ 5E9C              .L2:
 216+ 5E9C C5               PUSH BC
 217+ 5E9D E5               PUSH HL
 218+ 5E9E CD 56 5E         CALL DLOAD_READ
 219+ 5EA1 C1               POP BC
 220+ 5EA2 20 10            JR NZ,.ERRREAD
 221+ 5EA4 CD 6A 5E         CALL DLOAD_TRANSFERBLOCK
 222+ 5EA7 C1               POP BC
 223+ 5EA8 18 EA            JR .L1
 224+ 5EAA              .REST:
 225+ 5EAA 79               LD A,C
 226+ 5EAB B7               OR A
 227+ 5EAC 28 07            JR Z,.EXIT
 228+ 5EAE 26 00            LD H,0
 229+ 5EB0 69               LD L,C
 230+ 5EB1 4C               LD C,H
 231+ 5EB2 18 E8            JR .L2
 232+ 5EB4              .ERRREAD:
 233+ 5EB4 C1               POP BC
 234+ 5EB5              .EXIT:
 235+ 5EB5 F5               PUSH AF
 236+ 5EB6 CD 61 5E         CALL DLOAD_CLOSE
 237+ 5EB9 F1               POP AF
 238+ 5EBA C9               RET
 239+ 5EBB              ; *******************************************************************************************************
 240+ 5EBB
 241+ 5EBB               IF (0 == 1)
 242+ 5EBB ~
 243+ 5EBB ~            ; *******************************************************************************************************
 244+ 5EBB ~            ; function to handle CALL DLOAD basic extension
 245+ 5EBB ~            ; _DLOAD ( STRING filename,
 246+ 5EBB ~            ;		   INT offset,
 247+ 5EBB ~            ;		   INT destination,
 248+ 5EBB ~            ;          INT size )
 249+ 5EBB ~            ; will put ram in page 0 also, page 1 is already there
 250+ 5EBB ~            DLOAD:
 251+ 5EBB ~            	; opening (
 252+ 5EBB ~            	CALL CHKCHAR
 253+ 5EBB ~            	DB '('
 254+ 5EBB ~                CALL EVALTXTPARAM
 255+ 5EBB ~                PUSH HL
 256+ 5EBB ~                CALL GETSTRPNT
 257+ 5EBB ~                CALL DLOAD_PROCESS_FILENAME
 258+ 5EBB ~                JP C, BAD_FILENAME
 259+ 5EBB ~                POP HL
 260+ 5EBB ~            	; comma
 261+ 5EBB ~            	CALL CHKCHAR
 262+ 5EBB ~            	DB ','
 263+ 5EBB ~            	; get offset
 264+ 5EBB ~            	LD IX, FRMQNT
 265+ 5EBB ~            	CALL CALBAS
 266+ 5EBB ~            	LD (BLIT_STRUCT), DE
 267+ 5EBB ~            	; comma
 268+ 5EBB ~            	CALL CHKCHAR
 269+ 5EBB ~            	DB ','
 270+ 5EBB ~            	; get destination
 271+ 5EBB ~            	LD IX, FRMQNT
 272+ 5EBB ~            	CALL CALBAS
 273+ 5EBB ~            	LD (BLIT_STRUCT+2), DE
 274+ 5EBB ~            	; comma
 275+ 5EBB ~            	CALL CHKCHAR
 276+ 5EBB ~            	DB ','
 277+ 5EBB ~            	; get size
 278+ 5EBB ~            	LD IX, FRMQNT
 279+ 5EBB ~            	CALL CALBAS
 280+ 5EBB ~            	LD (BLIT_STRUCT+4), DE
 281+ 5EBB ~            	; ending )
 282+ 5EBB ~            	CALL CHKCHAR
 283+ 5EBB ~            	DB ')'
 284+ 5EBB ~
 285+ 5EBB ~                PUSH HL
 286+ 5EBB ~                CALL DLOAD_LOADFILE
 287+ 5EBB ~                JP NZ, DISKIOERR
 288+ 5EBB ~                POP HL
 289+ 5EBB ~                RET
 290+ 5EBB ~            ; *******************************************************************************************************
 291+ 5EBB ~
 292+ 5EBB               ENDIF
 293+ 5EBB
 294+ 5EBB               IF (1 == 1)
 295+ 5EBB              ; *******************************************************************************************************
 296+ 5EBB              ; same as DLOAD but for DEFUSR approach
 297+ 5EBB              ; input IX=pointer to input array, real data from +2
 298+ 5EBB              ; +2 = string pointer
 299+ 5EBB              ; +4 = offset
 300+ 5EBB              ; +6 = destination
 301+ 5EBB              ; +8 = size
 302+ 5EBB              ; output A=0 on success
 303+ 5EBB              ; *******************************************************************************************************
 304+ 5EBB              DLOAD_DEFUSR:
 305+ 5EBB DD 6E 02         LD L,(IX+2)
 306+ 5EBE DD 66 03         LD H,(IX+3)
 307+ 5EC1 46               LD B,(HL) ; string length
 308+ 5EC2 23               INC HL
 309+ 5EC3 5E               LD E,(HL)
 310+ 5EC4 23               INC HL
 311+ 5EC5 56               LD D,(HL)
 312+ 5EC6 EB               EX DE,HL ; pointer to ASCIIZ text
 313+ 5EC7 CD B1 5D         CALL DLOAD_PROCESS_FILENAME
 314+ 5ECA 38 22            JR C,.ERR ; exit on error
 315+ 5ECC DD 6E 04         LD L,(IX+4)
 316+ 5ECF DD 66 05         LD H,(IX+5)
 317+ 5ED2 22 70 5F         LD (BLIT_STRUCT),HL ; offset
 318+ 5ED5 DD 6E 06         LD L,(IX+6)
 319+ 5ED8 DD 66 07         LD H,(IX+7)
 320+ 5EDB 22 72 5F         LD (BLIT_STRUCT+2),HL ; destination
 321+ 5EDE DD 6E 08         LD L,(IX+8)
 322+ 5EE1 DD 66 09         LD H,(IX+9)
 323+ 5EE4 22 74 5F         LD (BLIT_STRUCT+4),HL ; size
 324+ 5EE7 CD 86 5E         CALL DLOAD_LOADFILE
 325+ 5EEA 20 02            JR NZ,.ERR
 326+ 5EEC AF               XOR A
 327+ 5EED C9               RET
 328+ 5EEE              .ERR:
 329+ 5EEE 3E 01            LD A,1
 330+ 5EF0 C9               RET
 331+ 5EF1              ; *******************************************************************************************************
 332+ 5EF1
 333+ 5EF1               ENDIF
 334+ 5EF1
# file closed: asm\DLOAD.asm
 180  5EF1               ENDIF
 181  5EF1
 182  5EF1               IF (1 == 1)
 183  5EF1               INCLUDE "DEFUSR.asm"
# file opened: asm\DEFUSR.asm
   1+ 5EF1              ; entry function that handles call using CALLF
   2+ 5EF1              ; pointer to data structure is expected at DAC+2
   3+ 5EF1              ; first entry must be function id followed by function specific parameters
   4+ 5EF1
   5+ 5EF1              DEFUSR_TABLE_ENTRIES    EQU 41
   6+ 5EF1
   7+ 5EF1              DEFUSR_JUMP_TABLE:
   8+ 5EF1               IF (SPRITE_CMDS == 1)
   9+ 5EF1 75 4E         DW SPRENABLE_DEFUSR        ; 0
  10+ 5EF3               ELSE
  11+ 5EF3 ~             DW NOACTION_DEFUSR
  12+ 5EF3               ENDIF
  13+ 5EF3
  14+ 5EF3               IF (SPRITE_CMDS == 1)
  15+ 5EF3 9A 4E         DW SPRDISABLE_DEFUSR        ; 1
  16+ 5EF5               ELSE
  17+ 5EF5 ~             DW NOACTION_DEFUSR
  18+ 5EF5               ENDIF
  19+ 5EF5
  20+ 5EF5               IF (RAM_CMDS == 1)
  21+ 5EF5 60 55         DW MEMCPY_DEFUSR           ; 2
  22+ 5EF7               ELSE
  23+ 5EF7 ~             DW NOACTION_DEFUSR
  24+ 5EF7               ENDIF
  25+ 5EF7
  26+ 5EF7               IF (VRAM_CMDS == 1)        ; 3
  27+ 5EF7 68 56         DW MEMVRM_DEFUSR
  28+ 5EF9               ELSE
  29+ 5EF9 ~             DW NOACTION_DEFUSR
  30+ 5EF9               ENDIF
  31+ 5EF9
  32+ 5EF9               IF (BLIT_CMDS == 1)        ; 4
  33+ 5EF9 7D 59         DW BLIT_DEFUSR
  34+ 5EFB               ELSE
  35+ 5EFB ~             DW NOACTION_DEFUSR
  36+ 5EFB               ENDIF
  37+ 5EFB
  38+ 5EFB               IF (ANIM_CMDS == 1)        ; 5
  39+ 5EFB 36 54         DW SGAM_DEFUSR
  40+ 5EFD               ELSE
  41+ 5EFD ~             DW NOACTION_DEFUSR
  42+ 5EFD               ENDIF
  43+ 5EFD
  44+ 5EFD               IF (SPRITE_CMDS == 1)
  45+ 5EFD DD 4E         DW SPRGRPMOV_DEFUSR        ; 6
  46+ 5EFF               ELSE
  47+ 5EFF ~             DW NOACTION_DEFUSR
  48+ 5EFF               ENDIF
  49+ 5EFF
  50+ 5EFF               IF (COLL_CMD == 1)
  51+ 5EFF B2 5C         DW COLL_DEFUSR             ; 7
  52+ 5F01               ELSE
  53+ 5F01 ~             DW NOACTION_DEFUSR
  54+ 5F01               ENDIF
  55+ 5F01
  56+ 5F01               IF (SOUND_CMDS == 1)
  57+ 5F01 20 56         DW SNDSFX_DEFUSR             ; 8
  58+ 5F03               ELSE
  59+ 5F03 ~             DW NOACTION_DEFUSR
  60+ 5F03               ENDIF
  61+ 5F03
  62+ 5F03               IF (ANIM_CMDS == 1)
  63+ 5F03 C7 52         DW ANIMSTEP_SINGLE_DEFUSR      ; 9
  64+ 5F05 D7 52         DW ANIMSTEP_MULTI_DEFUSR       ; 10
  65+ 5F07 E8 52         DW ANIMSTART_SINGLE_DEFUSR     ; 11
  66+ 5F09 FA 52         DW ANIMSTART_MULTI_DEFUSR      ; 12
  67+ 5F0B FF 52         DW ANIMSTOP_SINGLE_DEFUSR      ; 13
  68+ 5F0D 09 53         DW ANIMSTOP_MULTI_DEFUSR       ; 14
  69+ 5F0F               ELSE
  70+ 5F0F ~             DW NOACTION_DEFUSR
  71+ 5F0F ~             DW NOACTION_DEFUSR
  72+ 5F0F ~             DW NOACTION_DEFUSR
  73+ 5F0F ~             DW NOACTION_DEFUSR
  74+ 5F0F ~             DW NOACTION_DEFUSR
  75+ 5F0F ~             DW NOACTION_DEFUSR
  76+ 5F0F               ENDIF
  77+ 5F0F
  78+ 5F0F               IF (BOX_CMDS == 1)
  79+ 5F0F 87 57         DW BOXMEMCPY_DEFUSR            ; 15
  80+ 5F11 BE 57         DW BOXMEMVRM_DEFUSR            ; 16
  81+ 5F13               ELSE
  82+ 5F13 ~             DW NOACTION_DEFUSR
  83+ 5F13 ~             DW NOACTION_DEFUSR
  84+ 5F13               ENDIF
  85+ 5F13
  86+ 5F13               IF (ANIM_CMDS == 1)
  87+ 5F13 3D 4F         DW MAXANIMITEMS_DEFUSR         ; 17
  88+ 5F15 59 50         DW MAXANIMDEFS_DEFUSR          ; 18
  89+ 5F17 BE 50         DW MAXANIMSPRS_DEFUSR          ; 19
  90+ 5F19 8D 51         DW MAXAUTOSGAMS_DEFUSR         ; 20
  91+ 5F1B 05 50         DW ANIMITEMPAT_DEFUSR          ; 21
  92+ 5F1D 2F 50         DW ANIMITEMPTR_DEFUSR          ; 22
  93+ 5F1F 93 50         DW ANIMDEF_DEFUSR              ; 23
  94+ 5F21 0E 51         DW ANIMSPRITE_DEFUSR           ; 24
  95+ 5F23 4C 51         DW ANIMCHAR_DEFUSR             ; 25
  96+ 5F25 E1 51         DW AUTOSGAMDEF_DEFUSR          ; 26
  97+ 5F27 77 52         DW AUTOSGAMSTART_DEFUSR        ; 27
  98+ 5F29 A3 52         DW AUTOSGAMSTOP_DEFUSR         ; 28
  99+ 5F2B               ELSE
 100+ 5F2B ~             DW NOACTION_DEFUSR
 101+ 5F2B ~             DW NOACTION_DEFUSR
 102+ 5F2B ~             DW NOACTION_DEFUSR
 103+ 5F2B ~             DW NOACTION_DEFUSR
 104+ 5F2B ~             DW NOACTION_DEFUSR
 105+ 5F2B ~             DW NOACTION_DEFUSR
 106+ 5F2B ~             DW NOACTION_DEFUSR
 107+ 5F2B ~             DW NOACTION_DEFUSR
 108+ 5F2B ~             DW NOACTION_DEFUSR
 109+ 5F2B ~             DW NOACTION_DEFUSR
 110+ 5F2B ~             DW NOACTION_DEFUSR
 111+ 5F2B ~             DW NOACTION_DEFUSR
 112+ 5F2B               ENDIF
 113+ 5F2B
 114+ 5F2B               IF (GENCAL_CMD == 1)
 115+ 5F2B 06 57         DW GENCAL_DEFUSR               ; 29
 116+ 5F2D               ELSE
 117+ 5F2D ~             DW NOACTION_DEFUSR
 118+ 5F2D               ENDIF
 119+ 5F2D
 120+ 5F2D               IF (RAM_CMDS == 1)
 121+ 5F2D 83 55         DW FILRAM_DEFUSR               ; 30
 122+ 5F2F               ELSE
 123+ 5F2F ~             DW NOACTION_DEFUSR
 124+ 5F2F               ENDIF
 125+ 5F2F
 126+ 5F2F               IF (SOUND_CMDS == 1)
 127+ 5F2F B6 55         DW SNDPLYINI_DEFUSR            ; 31
 128+ 5F31 EB 55         DW SNDPLYON_DEFUSR             ; 32
 129+ 5F33 FC 55         DW SNDPLYOFF_DEFUSR            ; 33
 130+ 5F35               ELSE
 131+ 5F35 ~             DW NOACTION_DEFUSR
 132+ 5F35 ~             DW NOACTION_DEFUSR
 133+ 5F35 ~             DW NOACTION_DEFUSR
 134+ 5F35               ENDIF
 135+ 5F35
 136+ 5F35               IF (TILE_CMDS == 1)
 137+ 5F35 61 5A         DW TILERAM_DEFUSR              ; 34
 138+ 5F37 19 5B         DW TILEVRM_DEFUSR              ; 35
 139+ 5F39               ELSE
 140+ 5F39 ~             DW NOACTION_DEFUSR
 141+ 5F39 ~             DW NOACTION_DEFUSR
 142+ 5F39               ENDIF
 143+ 5F39
 144+ 5F39               IF (VRAM_CMDS == 1)
 145+ 5F39 45 56         DW FILVRM_DEFUSR               ; 36
 146+ 5F3B CB 56         DW VRMMEM_DEFUSR               ; 37
 147+ 5F3D               ELSE
 148+ 5F3D ~             DW NOACTION_DEFUSR
 149+ 5F3D ~             DW NOACTION_DEFUSR
 150+ 5F3D               ENDIF
 151+ 5F3D
 152+ 5F3D               IF (DECOMP_CMDS == 1)
 153+ 5F3D 83 5D         DW UNPACK_DEFUSR               ; 38
 154+ 5F3F               IF (VRAM_CMDS == 1)
 155+ 5F3F 6D 5D          DW VUNPACK_DEFUSR             ; 39
 156+ 5F41               ELSE
 157+ 5F41 ~              DW NOACTION_DEFUSR
 158+ 5F41               ENDIF
 159+ 5F41               ELSE
 160+ 5F41 ~             DW NOACTION_DEFUSR
 161+ 5F41 ~             DW NOACTION_DEFUSR
 162+ 5F41               ENDIF
 163+ 5F41
 164+ 5F41               IF (DLOAD_CMD == 1)
 165+ 5F41 BB 5E         DW DLOAD_DEFUSR               ; 40
 166+ 5F43               ELSE
 167+ 5F43 ~             DW NOACTION_DEFUSR
 168+ 5F43               ENDIF
 169+ 5F43
 170+ 5F43              ; *******************************************************************************************************
 171+ 5F43              ; function jumps to specified function based on inputs and returns success flag in (DAC+2) of type integer
 172+ 5F43              ; input INT(DAC+2) function ID = 0..DEFUSR_TABLE_ENTRIES-1
 173+ 5F43              ; input function specific parameters after the function ID, these are handled later in a called fn
 174+ 5F43              ; output stores back A to (DAC+2) and set type to INT, A=0 success
 175+ 5F43              DEFUSR_ENTRY:
 176+ 5F43 FB               EI
 177+ 5F44 DD 2A F8 F7      LD IX,(DAC+2)
 178+ 5F48 DD 7E 00         LD A,(IX)
 179+ 5F4B FE 29            CP DEFUSR_TABLE_ENTRIES
 180+ 5F4D 30 11            JR NC,.RET ; return if an undefined function requested
 181+ 5F4F 26 00            LD H,0
 182+ 5F51 6F               LD L,A
 183+ 5F52 29               ADD HL,HL
 184+ 5F53 11 F1 5E         LD DE,DEFUSR_JUMP_TABLE
 185+ 5F56 19               ADD HL,DE
 186+ 5F57 7E               LD A,(HL)
 187+ 5F58 23               INC HL
 188+ 5F59 66               LD H,(HL)
 189+ 5F5A 6F               LD L,A
 190+ 5F5B 11 60 5F         LD DE,.RET
 191+ 5F5E D5               PUSH DE
 192+ 5F5F E9               JP (HL) ; call function with IX=pointer to data array
 193+ 5F60              .RET:
 194+ 5F60 26 00            LD H,0
 195+ 5F62 6F               LD L,A
 196+ 5F63 22 F8 F7         LD (DAC+2),HL
 197+ 5F66 3E 02            LD A,2 ; INT
 198+ 5F68 32 63 F6         LD (VALTYP),A
 199+ 5F6B C9               RET
 200+ 5F6C
 201+ 5F6C
# file closed: asm\DEFUSR.asm
 184  5F6C               ENDIF
 185  5F6C
 186  5F6C              ; temp variables for BLIT, TILE functions
 187  5F6C               IF (BLIT_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS + COLL_CMD + DLOAD_CMD > 0)
 188  5F6C              BLIT_TMP:
 189  5F6C              TILETMP1:
 190  5F6C              BLIT_TMP1:
 191  5F6C 00 00         DW 0
 192  5F6E              TILETMP2:
 193  5F6E              BLIT_TMP2:
 194  5F6E 00 00         DW 0
 195  5F70              BLIT_STRUCT:
 196  5F70 00 00 00...   DS 17
 197  5F74               ENDIF
 198  5F81
 199  5F81               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 200  5F81              VRAM_UPDATE_IN_PROGRESS:
 201  5F81 00            DB 0
 202  5F82               ENDIF
 203  5F82
 204  5F82              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 205  5F82              ; per starting letter, if no commands with this letter, NULL value
 206  5F82              CMDS:
 207  5F82 B6 5F        	DW CMDS_A ; always present due to ARTINFO
 208  5F84               IF (BLIT_CMDS + BOX_CMDS > 0) && (0 == 1)
 209  5F84 ~                DW CMDS_B ; B
 210  5F84               ELSE
 211  5F84 00 00        	DW 0
 212  5F86               ENDIF
 213  5F86               IF (COLL_CMD == 1) && (0 == 1)
 214  5F86 ~            	DW CMDS_C ;
 215  5F86               ELSE
 216  5F86 00 00            DW 0 ; C
 217  5F88               ENDIF
 218  5F88               IF (DLOAD_CMD > 0) && (0 == 1)
 219  5F88 ~                DW CMDS_D ; D
 220  5F88               ELSE
 221  5F88 00 00        	DW 0
 222  5F8A               ENDIF
 223  5F8A 00 00            DW 0 ; E
 224  5F8C               IF (VRAM_CMDS + RAM_CMDS > 0) && (0 == 1)
 225  5F8C ~                DW CMDS_F; F
 226  5F8C               ELSE
 227  5F8C 00 00        	DW 0
 228  5F8E               ENDIF
 229  5F8E               IF (GENCAL_CMD > 0) && (0 == 1)
 230  5F8E ~                DW CMDS_G; G
 231  5F8E               ELSE
 232  5F8E 00 00        	DW 0
 233  5F90               ENDIF
 234  5F90 00 00            DW 0 ; H
 235  5F92 00 00            DW 0 ; I
 236  5F94 00 00            DW 0 ; J
 237  5F96 00 00            DW 0 ; K
 238  5F98 00 00            DW 0 ; L
 239  5F9A               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0) && (0 == 1)
 240  5F9A ~                DW CMDS_M ; M
 241  5F9A               ELSE
 242  5F9A 00 00        	DW 0
 243  5F9C               ENDIF
 244  5F9C 00 00            DW 0 ; N
 245  5F9E 00 00            DW 0 ; O
 246  5FA0 00 00            DW 0 ; P
 247  5FA2 00 00            DW 0 ; Q
 248  5FA4 00 00            DW 0 ; R
 249  5FA6               IF (SOUND_CMDS + SPRITE_CMDS > 0) && (0 == 1)
 250  5FA6 ~                DW CMDS_S ; S
 251  5FA6               ELSE
 252  5FA6 00 00        	DW 0
 253  5FA8               ENDIF
 254  5FA8               IF (TILE_CMDS > 0) && (0 == 1)
 255  5FA8 ~                DW CMDS_T ; T
 256  5FA8               ELSE
 257  5FA8 00 00        	DW 0
 258  5FAA               ENDIF
 259  5FAA               IF (DECOMP_CMDS > 0) && (0 == 1)
 260  5FAA ~                DW CMDS_U ; U
 261  5FAA               ELSE
 262  5FAA 00 00        	DW 0
 263  5FAC               ENDIF
 264  5FAC               IF ((VRAM_CMDS > 0) || (VRAM_CMDS + DECOMP_CMDS > 1)) && (0 == 1)
 265  5FAC ~                DW CMDS_V ; V
 266  5FAC               ELSE
 267  5FAC 00 00        	DW 0
 268  5FAE               ENDIF
 269  5FAE 00 00            DW 0 ; W
 270  5FB0 00 00            DW 0 ; X
 271  5FB2 00 00            DW 0 ; Y
 272  5FB4 00 00            DW 0 ; Z
 273  5FB6
 274  5FB6               IF (0 == 1)
 275  5FB6 ~             IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 276  5FB6 ~            CMDS_M:
 277  5FB6 ~             IF (VRAM_CMDS == 1)
 278  5FB6 ~                DB "MEMVRM", 0
 279  5FB6 ~                DW MEMVRM
 280  5FB6 ~             ENDIF
 281  5FB6 ~             IF (RAM_CMDS == 1)
 282  5FB6 ~            	DB "MEMCPY", 0
 283  5FB6 ~            	DW MEMCPY
 284  5FB6 ~             ENDIF
 285  5FB6 ~             IF (ANIM_CMDS == 1)
 286  5FB6 ~            	DB "MAXANIMITEMS",0
 287  5FB6 ~            	DW MAXANIMITEMS
 288  5FB6 ~            	DB "MAXANIMDEFS",0
 289  5FB6 ~            	DW MAXANIMDEFS
 290  5FB6 ~            	DB "MAXANIMSPRS",0
 291  5FB6 ~            	DW MAXANIMSPRS
 292  5FB6 ~               DB "MAXAUTOSGAMS",0
 293  5FB6 ~               DW MAXAUTOSGAMS
 294  5FB6 ~             ENDIF
 295  5FB6 ~             ENDIF
 296  5FB6 ~
 297  5FB6 ~             IF (VRAM_CMDS + RAM_CMDS > 0)
 298  5FB6 ~            CMDS_F:
 299  5FB6 ~             IF (VRAM_CMDS == 1)
 300  5FB6 ~                DB "FILVRM", 0
 301  5FB6 ~                DW FILVRM
 302  5FB6 ~             ENDIF
 303  5FB6 ~             IF (RAM_CMDS == 1)
 304  5FB6 ~                DB "FILRAM", 0
 305  5FB6 ~                DW FILRAM
 306  5FB6 ~             ENDIF
 307  5FB6 ~             ENDIF
 308  5FB6 ~
 309  5FB6 ~             IF (GENCAL_CMD > 0)
 310  5FB6 ~            CMDS_G:
 311  5FB6 ~             IF (GENCAL_CMD == 1)
 312  5FB6 ~                DB "GENCAL", 0
 313  5FB6 ~                DW GENCAL
 314  5FB6 ~             ENDIF
 315  5FB6 ~             ENDIF
 316  5FB6 ~
 317  5FB6 ~             IF (VRAM_CMDS > 0)
 318  5FB6 ~            CMDS_V:
 319  5FB6 ~             IF (VRAM_CMDS == 1)
 320  5FB6 ~            	DB "VRMMEM", 0
 321  5FB6 ~            	DW VRMMEM
 322  5FB6 ~             ENDIF
 323  5FB6 ~             IF (DECOMP_CMDS == 1)
 324  5FB6 ~            	DB "VUNPACK", 0
 325  5FB6 ~            	DW VUNPACK
 326  5FB6 ~             ENDIF
 327  5FB6 ~             ENDIF
 328  5FB6 ~
 329  5FB6 ~             IF (SOUND_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 330  5FB6 ~            CMDS_S:
 331  5FB6 ~             IF (SPRITE_CMDS + ANIM_CMDS > 0)
 332  5FB6 ~                DB "SGAM",0
 333  5FB6 ~                DW SGAM
 334  5FB6 ~             ENDIF
 335  5FB6 ~             IF (SPRITE_CMDS == 1)
 336  5FB6 ~            	DB "SPRGRPMOV", 0
 337  5FB6 ~            	DW SPRGRPMOV
 338  5FB6 ~             ENDIF
 339  5FB6 ~             IF (SOUND_CMDS == 1)
 340  5FB6 ~            	DB "SNDSFX", 0
 341  5FB6 ~            	DW SNDSFX
 342  5FB6 ~            	DB "SNDPLYON", 0
 343  5FB6 ~            	DW SNDPLYON
 344  5FB6 ~            	DB "SNDPLYOFF", 0
 345  5FB6 ~            	DW SNDPLYOFF
 346  5FB6 ~            	DB "SNDPLYINI", 0
 347  5FB6 ~            	DW SNDPLYINIT
 348  5FB6 ~             ENDIF
 349  5FB6 ~             IF (SPRITE_CMDS == 1)
 350  5FB6 ~            	DB "SPRENABLE", 0
 351  5FB6 ~            	DW SPRENABLE
 352  5FB6 ~            	DB "SPRDISABLE", 0
 353  5FB6 ~            	DW SPRDISABLE
 354  5FB6 ~             ENDIF
 355  5FB6 ~             ENDIF
 356  5FB6 ~
 357  5FB6 ~             IF (BLIT_CMDS + BOX_CMDS > 0)
 358  5FB6 ~            CMDS_B:
 359  5FB6 ~             IF (BLIT_CMDS == 1)
 360  5FB6 ~            	DB "BLIT", 0
 361  5FB6 ~            	DW BLIT
 362  5FB6 ~             ENDIF
 363  5FB6 ~             IF (BOX_CMDS == 1)
 364  5FB6 ~            	DB "BOXMEMCPY", 0
 365  5FB6 ~            	DW BOXMEMCPY
 366  5FB6 ~            	DB "BOXMEMVRM", 0
 367  5FB6 ~            	DW BOXMEMVRM
 368  5FB6 ~             ENDIF
 369  5FB6 ~             ENDIF
 370  5FB6 ~
 371  5FB6 ~             IF (TILE_CMDS > 0)
 372  5FB6 ~            CMDS_T:
 373  5FB6 ~             IF (TILE_CMDS == 1)
 374  5FB6 ~            	DB "TILERAM", 0
 375  5FB6 ~            	DW TILERAM
 376  5FB6 ~            	DB "TILEVRM", 0
 377  5FB6 ~            	DW TILEVRM
 378  5FB6 ~             ENDIF
 379  5FB6 ~             ENDIF
 380  5FB6 ~
 381  5FB6 ~             IF (COLL_CMD > 0)
 382  5FB6 ~            CMDS_C:
 383  5FB6 ~             IF (COLL_CMD == 1)
 384  5FB6 ~                DB "COLL", 0
 385  5FB6 ~                DW COLL
 386  5FB6 ~             ENDIF
 387  5FB6 ~             ENDIF
 388  5FB6 ~
 389  5FB6 ~             IF (DECOMP_CMDS > 0)
 390  5FB6 ~            CMDS_U:
 391  5FB6 ~             IF (DECOMP_CMDS == 1)
 392  5FB6 ~                DB "UNPACK", 0
 393  5FB6 ~                DW UNPACK
 394  5FB6 ~             ENDIF
 395  5FB6 ~             ENDIF
 396  5FB6 ~
 397  5FB6 ~             IF (DLOAD_CMD > 0)
 398  5FB6 ~            CMDS_D:
 399  5FB6 ~             IF (DLOAD_CMD == 1)
 400  5FB6 ~                DB "DLOAD", 0
 401  5FB6 ~                DW DLOAD
 402  5FB6 ~             ENDIF
 403  5FB6 ~             ENDIF
 404  5FB6 ~
 405  5FB6 ~            CMDS_A:
 406  5FB6 ~             IF (ANIM_CMDS == 1)
 407  5FB6 ~               DB "ANIMSTEP",0
 408  5FB6 ~               DW ANIMSTEP
 409  5FB6 ~            	DB "ANIMSTART",0
 410  5FB6 ~            	DW ANIMSTART
 411  5FB6 ~            	DB "ANIMSTOP",0
 412  5FB6 ~            	DW ANIMSTOP
 413  5FB6 ~            	DB "ANIMITEMPAT",0
 414  5FB6 ~            	DW ANIMITEMPAT
 415  5FB6 ~            	DB "ANIMITEMPTR",0
 416  5FB6 ~            	DW ANIMITEMPTR_CMD
 417  5FB6 ~            	DB "ANIMDEF",0
 418  5FB6 ~            	DW ANIMDEF
 419  5FB6 ~            	DB "ANIMSPRITE",0
 420  5FB6 ~            	DW ANIMSPRITE
 421  5FB6 ~               DB "ANIMCHAR",0
 422  5FB6 ~               DW ANIMCHAR
 423  5FB6 ~               DB "AUTOSGAMDEF",0
 424  5FB6 ~               DW AUTOSGAMDEF
 425  5FB6 ~               DB "AUTOSGAMSTART",0
 426  5FB6 ~               DW AUTOSGAMSTART
 427  5FB6 ~               DB "AUTOSGAMSTOP",0
 428  5FB6 ~               DW AUTOSGAMSTOP
 429  5FB6 ~             ENDIF
 430  5FB6 ~               DB "ARTINFO",0
 431  5FB6 ~               DW ARTINFO
 432  5FB6 ~            	DB 0
 433  5FB6               ELSE // if not BASIC extension
 434  5FB6              CMDS_A:
 435  5FB6 41 52 54 49     DB "ARTINFO",0
 435  5FBA 4E 46 4F 00
 436  5FBE 19 61           DW ARTINFO
 437  5FC0 00           	DB 0
 438  5FC1               ENDIF
 439  5FC1
 440  5FC1               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 441  5FC1              ; ****************************************************************************************************
 442  5FC1              ; function sets VRAM address for writing
 443  5FC1              ; input HL=address
 444  5FC1              ; modifies AF
 445  5FC1              SETWRT_LOCAL_WRITE:
 446  5FC1 7D           	LD	A,L
 447  5FC2 D3 99        	OUT (#99),A
 448  5FC4 7C           	LD	A,H
 449  5FC5 E6 3F        	AND #3F
 450  5FC7 F6 40        	OR	#40
 451  5FC9 D3 99        	OUT (#99),A
 452  5FCB C9           	RET
 453  5FCC              ; ****************************************************************************************************
 454  5FCC
 455  5FCC              ; ****************************************************************************************************
 456  5FCC              ; function sets VRAM address for reading
 457  5FCC              ; input HL=address
 458  5FCC              ; modifies AF
 459  5FCC              SETWRT_LOCAL_READ:
 460  5FCC 7D           	LD	A,L
 461  5FCD D3 99        	OUT (#99),A
 462  5FCF 7C           	LD	A,H
 463  5FD0 E6 3F        	AND #3F
 464  5FD2 00              NOP
 465  5FD3 D3 99        	OUT (#99),A
 466  5FD5 C9           	RET
 467  5FD6              ; ****************************************************************************************************
 468  5FD6               ENDIF
 469  5FD6
 470  5FD6               IF (VRAM_CMDS + TILE_CMDS > 0)
 471  5FD6              ; ****************************************************************************************************
 472  5FD6              ; function copies data from RAM to VRAM
 473  5FD6              ; input HL=address in RAM
 474  5FD6              ; input B=count
 475  5FD6              ; modifies AF, BC, HL
 476  5FD6              BBYTECOPY:
 477  5FD6 0E 98        	LD C,#98
 478  5FD8              BBYTECOPY_NO_C:
 479  5FD8 ED A3        	OUTI
 480  5FDA C2 D8 5F     	JP	NZ, BBYTECOPY_NO_C
 481  5FDD C9           	RET
 482  5FDE              ; ****************************************************************************************************
 483  5FDE               ENDIF
 484  5FDE
 485  5FDE              ; ****************************************************************************************************
 486  5FDE              ; function multiplies HL by 32
 487  5FDE              HLx32:
 488  5FDE 29           	ADD HL,HL
 489  5FDF              ; ****************************************************************************************************
 490  5FDF              ; function multiplies HL by 16
 491  5FDF              HLx16:
 492  5FDF 29           	ADD HL,HL
 493  5FE0              ; ****************************************************************************************************
 494  5FE0              ; function multiplies HL by 8
 495  5FE0              HLx8:
 496  5FE0 29          > ADD HL, HL
 496  5FE1 29          > ADD HL, HL
 496  5FE2 29          > ADD HL, HL
 497  5FE3 C9           	RET
 498  5FE4              ; ****************************************************************************************************
 499  5FE4
 500  5FE4              ; ****************************************************************************************************
 501  5FE4              ; function gets slot and subslot data for specific page
 502  5FE4              ; input A=page (0, 1 or 2)
 503  5FE4              ; output B = 0A8H register value
 504  5FE4              ; output D = 0 is no subslots, 1 if yes
 505  5FE4              ; output C = 0A8H value when page 3 slot equals to requested page slot
 506  5FE4              ; output E = subslot value if present
 507  5FE4              ; modifies AF, BC, DE, HL
 508  5FE4              GET_PAGE_INFO:
 509  5FE4 6F               LD L, A
 510  5FE5 C6 C1            ADD A, low (EXPTBL)
 511  5FE7 32 F1 5F         LD (GET_PAGE_INFO_L1+1), A
 512  5FEA DB A8            IN A, (0A8H)
 513  5FEC 47               LD B, A
 514  5FED E6 3F            AND 03FH
 515  5FEF 4F               LD C, A
 516  5FF0              GET_PAGE_INFO_L1:
 517  5FF0 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 518  5FF3 E6 80            AND 080H
 519  5FF5 28 1B            JR Z, GET_PAGE_INFO_L2
 520  5FF7                  ; expanded
 521  5FF7 2D               DEC L
 522  5FF8 FA 17 60         JP M, GET_PAGE_INFO_L3
 523  5FFB 2D               DEC L
 524  5FFC FA 15 60         JP M, GET_PAGE_INFO_L4
 525  5FFF                  ; page 2
 526  5FFF 07               RLCA
 527  6000 07               RLCA
 528  6001              GET_PAGE_INFO_L5:
 529  6001 E6 C0            AND 0C0H
 530  6003 B1               OR C
 531  6004 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 532  6006 4F               LD C, A
 533  6007 3A FF FF         LD A, (0FFFFH)
 534  600A 2F               CPL
 535  600B 5F               LD E, A
 536  600C 16 01            LD D, 1
 537  600E 78               LD A, B ; return stack
 538  600F D3 A8            OUT (0A8H), A
 539  6011 C9               RET
 540  6012              GET_PAGE_INFO_L2:
 541  6012                  ; not expanded
 542  6012 16 00            LD D, 0
 543  6014 C9               RET
 544  6015              GET_PAGE_INFO_L4:
 545  6015                  ; page 1
 546  6015 0F               RRCA
 547  6016 0F               RRCA
 548  6017              GET_PAGE_INFO_L3:
 549  6017                  ; page 0
 550  6017 0F               RRCA
 551  6018 0F               RRCA
 552  6019 18 E6            JR GET_PAGE_INFO_L5
 553  601B              ; ****************************************************************************************************
 554  601B
 555  601B              ; ****************************************************************************************************
 556  601B              ; function returns original slot and subslot info
 557  601B              ; input B = 0A8H register value
 558  601B              ; input D = 0 is no subslots, 1 if yes
 559  601B              ; input C = 0A8H value when page 3 slot equals to requested page slot
 560  601B              ; input E = subslot value if present
 561  601B              ; modifies AF, disables interrupts
 562  601B              RESTORE_PAGE_INFO:
 563  601B F3              DI
 564  601C 7A              LD A, D
 565  601D B7              OR A
 566  601E 28 07           JR Z, RESTORE_PAGE_INFO_L1
 567  6020 79              LD A, C
 568  6021 D3 A8           OUT (0A8H), A
 569  6023 7B              LD A, E
 570  6024 32 FF FF        LD (0FFFFH), A
 571  6027              RESTORE_PAGE_INFO_L1:
 572  6027 78              LD A, B
 573  6028 D3 A8           OUT (0A8H), A
 574  602A              NOACTION_DEFUSR: ; just a safe RET for use when DEFUSR table has an empty entry
 575  602A C9              RET
 576  602B              ; ****************************************************************************************************
 577  602B
 578  602B              ; *******************************************************************************************************
 579  602B              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 580  602B              ; INPUT:  A = SLOT ID: EXXXSSPP
 581  602B              ; E = EXPANDED FLAG
 582  602B              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 583  602B              ; PP = PRIMARY SLOT NUMBER
 584  602B              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 585  602B              ; CHANGES: AF, BC, DE
 586  602B
 587  602B              LOCAL_ENASLT:
 588  602B CD 4B 60         CALL L0353
 589  602E FA 38 60         JP M, L0340
 590  6031 DB A8            IN A, (0A8H)
 591  6033 A1               AND C
 592  6034 B0               OR B
 593  6035 D3 A8            OUT (0A8H), A
 594  6037 C9               RET
 595  6038              L0340:
 596  6038 E5               PUSH HL
 597  6039 CD 70 60         CALL L0378
 598  603C 4F               LD C, A
 599  603D 06 00            LD B, 0
 600  603F 7D               LD A, L
 601  6040 A4               AND H
 602  6041 B2               OR D
 603  6042 21 C5 FC         LD HL, 0FCC5H
 604  6045 09               ADD HL, BC
 605  6046 77               LD (HL), A
 606  6047 E1               POP HL
 607  6048 79               LD A, C
 608  6049 18 E0            JR LOCAL_ENASLT
 609  604B              L0353:
 610  604B F3               DI
 611  604C F5               PUSH AF
 612  604D 7C               LD A, H
 613  604E 07               RLCA
 614  604F 07               RLCA
 615  6050 E6 03            AND 3
 616  6052 5F               LD E, A
 617  6053 3E C0            LD A, 0C0H
 618  6055              L035D:
 619  6055 07               RLCA
 620  6056 07               RLCA
 621  6057 1D               DEC E
 622  6058 F2 55 60         JP P, L035D
 623  605B 5F               LD E, A
 624  605C 2F               CPL
 625  605D 4F               LD C, A
 626  605E F1               POP AF
 627  605F F5               PUSH AF
 628  6060 E6 03            AND 3
 629  6062 3C               INC A
 630  6063 47               LD B, A
 631  6064 3E AB            LD A, 0ABH
 632  6066              L036E:
 633  6066 C6 55            ADD A, 055H
 634  6068 10 FC            DJNZ L036E
 635  606A 57               LD D, A
 636  606B A3               AND E
 637  606C 47               LD B, A
 638  606D F1               POP AF
 639  606E A7               AND A
 640  606F C9               RET
 641  6070              L0378:
 642  6070 F5               PUSH AF
 643  6071 7A               LD A, D
 644  6072 E6 C0            AND 0C0H
 645  6074 4F               LD C, A
 646  6075 F1               POP AF
 647  6076 F5               PUSH AF
 648  6077 57               LD D, A
 649  6078 DB A8            IN A, (0A8H)
 650  607A 47               LD B, A
 651  607B E6 3F            AND 03FH
 652  607D B1               OR C
 653  607E D3 A8            OUT (0A8H), A
 654  6080 7A               LD A, D
 655  6081 0F               RRCA
 656  6082 0F               RRCA
 657  6083 E6 03            AND 3
 658  6085 57               LD D, A
 659  6086 3E AB            LD A, 0ABH
 660  6088              L0390:
 661  6088 C6 55            ADD A, 055H
 662  608A 15               DEC D
 663  608B F2 88 60         JP P, L0390
 664  608E A3               AND E
 665  608F 57               LD D, A
 666  6090 7B               LD A, E
 667  6091 2F               CPL
 668  6092 67               LD H, A
 669  6093 3A FF FF         LD A, (0FFFFH)
 670  6096 2F               CPL
 671  6097 6F               LD L, A
 672  6098 A4               AND H
 673  6099 B2               OR D
 674  609A 32 FF FF         LD (0FFFFH), A
 675  609D 78               LD A, B
 676  609E D3 A8            OUT (0A8H), A
 677  60A0 F1               POP AF
 678  60A1 E6 03            AND 3
 679  60A3 C9               RET
 680  60A4              ; *******************************************************************************************************
 681  60A4
 682  60A4              ; *******************************************************************************************************
 683  60A4              ; some common code to activate page 0 and place values needed to restore original page on stack
 684  60A4              ; input IY=return address
 685  60A4              ENABLE_PAGE0:
 686  60A4 F3              DI
 687  60A5 AF              XOR A
 688  60A6 CD E4 5F        CALL GET_PAGE_INFO
 689  60A9 C5              PUSH BC
 690  60AA D5              PUSH DE
 691  60AB 3A 41 F3        LD A, (RAMAD0)
 692  60AE 26 00           LD H, 0
 693  60B0 CD 2B 60        CALL LOCAL_ENASLT
 694  60B3 FD E9        	JP (IY)
 695  60B5              ; *******************************************************************************************************
 696  60B5
 697  60B5              ; General BASIC CALL-instruction handler
 698  60B5              CALLHAND:
 699  60B5 FB              EI
 700  60B6 E5           	PUSH HL
 701  60B7 21 82 5F     	LD	HL, CMDS ; pointer table based on starting letter
 702  60BA 3A 89 FD        LD A, (PROCNM)
 703  60BD D6 41           SUB 'A'
 704  60BF 87              ADD A, A
 705  60C0 16 00           LD D, 0
 706  60C2 5F              LD E, A
 707  60C3 19              ADD HL, DE
 708  60C4 5E              LD E, (HL)
 709  60C5 23              INC HL
 710  60C6 56              LD D, (HL)
 711  60C7 7A              LD A, D
 712  60C8 B3              OR E
 713  60C9 28 23           JR Z, .CMDNOTRECOGNIZED
 714  60CB EB              EX DE, HL
 715  60CC              .CHKCMD:
 716  60CC 11 89 FD     	LD	DE, PROCNM
 717  60CF              .LOOP:
 718  60CF 1A              LD	A,(DE)
 719  60D0 BE           	CP	(HL)
 720  60D1 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 721  60D3 13           	INC	DE
 722  60D4 23           	INC	HL
 723  60D5 A7           	AND	A
 724  60D6 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 725  60D8 5E           	LD	E,(HL)
 726  60D9 23           	INC	HL
 727  60DA 56           	LD	D,(HL)
 728  60DB E1           	POP	HL		; routine address
 729  60DC CD FD 60     	CALL	GETPREVCHAR
 730  60DF CD F1 60     	CALL	.CALLDE		; Call routine
 731  60E2 A7           	AND	A
 732  60E3 C9           	RET
 733  60E4
 734  60E4              .TONEXTCMD:
 735  60E4 0E FF        	LD	C,0FFH
 736  60E6 AF           	XOR	A
 737  60E7 ED B1        	CPIR			; Skip to end of instruction name
 738  60E9 23           	INC	HL
 739  60EA 23           	INC	HL		; Skip address
 740  60EB BE           	CP	(HL)
 741  60EC 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 742  60EE              .CMDNOTRECOGNIZED:
 743  60EE E1           	POP	HL
 744  60EF 37              SCF
 745  60F0 C9           	RET
 746  60F1
 747  60F1              .CALLDE:
 748  60F1 D5           	PUSH	DE
 749  60F2 C9           	RET
 750  60F3
 751  60F3              ;---------------------------
 752  60F3
 753  60F3              CHKCHAR:
 754  60F3 CD FD 60     	CALL	GETPREVCHAR	; Get previous basic char
 755  60F6 E3           	EX	(SP),HL
 756  60F7 BE           	CP	(HL) 	        ; Check if good char
 757  60F8 20 0D        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 758  60FA 23           	INC	HL
 759  60FB E3           	EX	(SP),HL
 760  60FC 23           	INC	HL		; Get next basic char
 761  60FD
 762  60FD              GETPREVCHAR:
 763  60FD 2B           	DEC HL
 764  60FE DD 21 66 46  	LD	IX,CHRGTR
 765  6102 CD 59 01     	CALL CALBAS
 766  6105 FB              EI
 767  6106 C9              RET
 768  6107
 769  6107               IF (0 == 1)
 770  6107 ~             IF (DLOAD_CMD == 1)
 771  6107 ~            BAD_FILENAME:
 772  6107 ~               LD E,56
 773  6107 ~               JR THROW_ERROR
 774  6107 ~            DISKIOERR:
 775  6107 ~               LD E,69
 776  6107 ~               JR THROW_ERROR
 777  6107 ~             ENDIF
 778  6107 ~            OUT_OF_DATA:
 779  6107 ~               LD E, 4
 780  6107 ~               JR THROW_ERROR
 781  6107 ~            TYPE_MISMATCH:
 782  6107 ~               LD E, 13 ; Type mismatch
 783  6107 ~               JR THROW_ERROR
 784  6107 ~            SUBSCRIPT_OUT_OF_RANGE:
 785  6107 ~               LD E,9 ; subscript out of range
 786  6107 ~            	JR THROW_ERROR
 787  6107 ~            OVERFLOW:
 788  6107 ~            	LD E,6
 789  6107 ~            	JR THROW_ERROR
 790  6107 ~            ILLEGAL_FUNCTION:
 791  6107 ~               LD E, 5 ; illegal function call
 792  6107 ~               JR THROW_ERROR
 793  6107               ENDIF
 794  6107              SYNTAX_ERROR:
 795  6107 1E 02           LD E, 2 ; Syntax error
 796  6109              THROW_ERROR:
 797  6109 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 798  610D C3 59 01     	JP	CALBAS
 799  6110
 800  6110
 801  6110              ;---------------------------
 802  6110
 803  6110               IF (DLOAD_CMD == 1)
 804  6110              ; *******************************************************************************************************
 805  6110              ; helper function to make an uppercase letter
 806  6110              ; input A=character
 807  6110              ; output A=uppercase version of input
 808  6110              UPPER:
 809  6110 FE 61           CP "a"
 810  6112 D8              RET C
 811  6113 FE 7B           CP "z"+1
 812  6115 D0              RET NC
 813  6116 E6 5F           AND 5FH
 814  6118 C9              RET
 815  6119              ; *******************************************************************************************************
 816  6119               ENDIF
 817  6119
 818  6119               IF (0 == 1)
 819  6119 ~
 820  6119 ~             IF (DLOAD_CMD == 1)
 821  6119 ~            ; *******************************************************************************************************
 822  6119 ~            ; helper function to return string pointer and length
 823  6119 ~            ; returns HL = String Address
 824  6119 ~            ; returns B  = Lenght
 825  6119 ~            ; modifies BC, DE, HL
 826  6119 ~            GETSTRPNT:
 827  6119 ~               LD      HL,(USR)
 828  6119 ~               LD      B,(HL)
 829  6119 ~               INC     HL
 830  6119 ~               LD      E,(HL)
 831  6119 ~               INC     HL
 832  6119 ~               LD      D,(HL)
 833  6119 ~               EX      DE,HL
 834  6119 ~               RET
 835  6119 ~            ; *******************************************************************************************************
 836  6119 ~
 837  6119 ~            ; *******************************************************************************************************
 838  6119 ~            ; helper function to get string parameter
 839  6119 ~            ; throws error if incorrect type
 840  6119 ~            ; input HL=basic text
 841  6119 ~            EVALTXTPARAM:
 842  6119 ~            	LD	IX,FRMEVL
 843  6119 ~            	CALL CALBAS		; Evaluate expression
 844  6119 ~               LD A,(VALTYP)
 845  6119 ~               CP 3               ; Text type?
 846  6119 ~               JP NZ,TYPE_MISMATCH
 847  6119 ~               PUSH HL
 848  6119 ~               LD	IX,FRESTR         ; Free the temporary string
 849  6119 ~               CALL CALBAS
 850  6119 ~               POP HL
 851  6119 ~               RET
 852  6119 ~            ; *******************************************************************************************************
 853  6119 ~
 854  6119 ~             ENDIF
 855  6119 ~
 856  6119 ~            ; *******************************************************************************************************
 857  6119 ~            ; helper function to get pointer to BASIC array data
 858  6119 ~            ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
 859  6119 ~            ; input B=dimensions (1 or 2)
 860  6119 ~            ; input D=minimal first dimension
 861  6119 ~            ; input E=minimal second dimension, if applicable
 862  6119 ~            ; returns BC=pointer to first data element
 863  6119 ~            ; throws BASIC error if invalid type
 864  6119 ~            GET_BASIC_ARRAY_DATA_POINTER:
 865  6119 ~            	PUSH DE
 866  6119 ~            	PUSH BC
 867  6119 ~            	PUSH AF
 868  6119 ~               LD A,1
 869  6119 ~               LD (SUBFLG),A ; search for arrays only
 870  6119 ~            	LD IX, PTRGET
 871  6119 ~            	CALL CALBAS
 872  6119 ~               XOR A
 873  6119 ~               LD (SUBFLG),A ; if not reset will cause syntax errors
 874  6119 ~            	LD A,(VALTYP)
 875  6119 ~            	POP DE ; required type
 876  6119 ~            	CP D
 877  6119 ~            	JP NZ,TYPE_MISMATCH
 878  6119 ~            	LD A,(BC)
 879  6119 ~            	INC BC
 880  6119 ~            	POP DE ; required number of dimensions
 881  6119 ~            	CP D
 882  6119 ~            	JP NZ,TYPE_MISMATCH
 883  6119 ~            	POP DE ; required minimal array dimensions
 884  6119 ~            	DEC A
 885  6119 ~            	JR Z,.ONE_DIMENSION
 886  6119 ~            	; 2-dimension array
 887  6119 ~            	LD A,(BC)
 888  6119 ~            	.2 INC BC
 889  6119 ~            	CP E
 890  6119 ~            	JP C,SUBSCRIPT_OUT_OF_RANGE
 891  6119 ~            .ONE_DIMENSION:
 892  6119 ~            	LD A,(BC)
 893  6119 ~            	.2 INC BC
 894  6119 ~            	CP D
 895  6119 ~            	JP C,SUBSCRIPT_OUT_OF_RANGE
 896  6119 ~            	RET
 897  6119 ~            ; *******************************************************************************************************
 898  6119               ENDIF
 899  6119
 900  6119              ; *******************************************************************************************************
 901  6119              ; function to handle CALL ARTINFO basic extension
 902  6119              ; returns info about the extension
 903  6119              ; _ARTINFO ( INT variable version,
 904  6119              ;			    INT variable build_flags,
 905  6119              ;			    INT variable free_memory_ptr )
 906  6119              ; this function is always available and can be used to test if the extension is active
 907  6119              ARTINFO:
 908  6119              	; opening (
 909  6119 CD F3 60     	CALL CHKCHAR
 910  611C 28           	DB '('
 911  611D              	; get address of version variable
 912  611D DD 21 A4 5E  	LD IX, PTRGET
 913  6121 CD 59 01     	CALL CALBAS
 914  6124 3A 12 40     	LD A,(VERSION)
 915  6127 12              LD (DE),A
 916  6128 13              INC DE
 917  6129 3A 13 40        LD A,(VERSION+1)
 918  612C 12              LD (DE),A
 919  612D              	; comma
 920  612D CD F3 60     	CALL CHKCHAR
 921  6130 2C           	DB ','
 922  6131              	; get address of build flags variable
 923  6131 DD 21 A4 5E  	LD IX, PTRGET
 924  6135 CD 59 01     	CALL CALBAS
 925  6138 E5              PUSH HL
 926  6139 21 FF 3B        LD HL,SOUND_CMDS+2*RAM_CMDS+4*VRAM_CMDS+8*BLIT_CMDS+16*SPRITE_CMDS+32*GENCAL_CMD+64*TILE_CMDS+128*BOX_CMDS+256*ANIM_CMDS+512*COLL_CMD+1024*0+2048*1+4096*DECOMP_CMDS+8192*DLOAD_CMD
 927  613C EB              EX DE,HL
 928  613D 73              LD (HL),E
 929  613E 23              INC HL
 930  613F 72              LD (HL),D
 931  6140 E1              POP HL
 932  6141              	; comma
 933  6141 CD F3 60     	CALL CHKCHAR
 934  6144 2C           	DB ','
 935  6145              	; get address of free memory variable
 936  6145 DD 21 A4 5E  	LD IX, PTRGET
 937  6149 CD 59 01     	CALL CALBAS
 938  614C 3A 10 40     	LD A,(FREEMEMPTR)
 939  614F 12              LD (DE),A
 940  6150 13              INC DE
 941  6151 3A 11 40        LD A,(FREEMEMPTR+1)
 942  6154 12              LD (DE),A
 943  6155              	; ending )
 944  6155 CD F3 60     	CALL CHKCHAR
 945  6158 29           	DB ')'
 946  6159 C9           	RET
 947  615A              ; *******************************************************************************************************
 948  615A
 949  615A              EXT_END:
 950  615A
# file closed: asm\main.asm
