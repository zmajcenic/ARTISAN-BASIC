# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		   EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000              COLL_CMD       EQU 1
  14  4000              DECOMP_CMDS    EQU 1
  15  4000              DLOAD_CMD      EQU 1
  16  4000
  17  4000              ; what to compile, provided in sjasmplus command line
  18  4000              ;BASIC_EXTENSION   EQU 1
  19  4000              ;DEFUSR_EXTENSION  EQU 0
  20  4000
  21  4000              CHPUT   EQU    #A2
  22  4000              CALBAS  EQU		#159
  23  4000              ERRHAND EQU    #406F
  24  4000              FRMEVL  EQU    #4C64
  25  4000              FRESTR  EQU		#67D0
  26  4000              ; FRMQNT = formula quantificator
  27  4000              ; input HL=pointer to current program expression
  28  4000              ; output HL=next address
  29  4000              ; output DE=integer datum
  30  4000              FRMQNT	EQU		#542F
  31  4000              ; GETBYT = get byte parameter
  32  4000              ; input HL=pointer to current program expression
  33  4000              ; output HL=next address
  34  4000              ; output A=E=byte read
  35  4000              GETBYT		EQU	#521C
  36  4000              CHRGTR  	   EQU   #4666
  37  4000              PTRGET		EQU 	#5EA4
  38  4000              SUBFLG		EQU	#F6A5
  39  4000              SYNCHR		EQU	#558C
  40  4000              VALTYP  	   EQU   #F663
  41  4000              DAC         EQU   #F7F6
  42  4000              USR     	   EQU   #F7F8
  43  4000              PROCNM		EQU	#FD89
  44  4000              BIOS_FILVRM EQU   #0056
  45  4000              CLIKSW		EQU	#F3DB
  46  4000
  47  4000              RAMAD0	   EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  48  4000              RAMAD1	   EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  49  4000              RAMAD2	   EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  50  4000              RAMAD3	   EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  51  4000              EXPTBL	   EQU   #FCC1
  52  4000              SCRMOD	   EQU   #FCAF ; current screen mode
  53  4000              REG1SAV     EQU   #F3E0 ; VDP(1)
  54  4000              JIFFY	      EQU   #FC9E
  55  4000              GRPPAT	   EQU   #F3CF ; SCREEN 2 sprite generator table address
  56  4000              GRPCGP		EQU	#F3CB ; SCREEN 2 pattern generator table address
  57  4000              GRPATR      EQU   #F3CD ; SCREEN 2 sprite attribute table address
  58  4000              T32PAT	   EQU   #F3C5 ; SCREEN 1 sprite generator table address
  59  4000              T32CGP      EQU   #F3C1 ; SCREEN 1 pattern ganarator table address
  60  4000              T32ATR      EQU   #F3C3 ; SCREEN 1 sprite attribute table address
  61  4000
  62  4000              FCB0        EQU   #F353 ; location of FCB 0
  63  4000              BDOS        EQU   #F37D ; disk functions
  64  4000              NULBUF      EQU   #F862 ; disk buffer of 256 bytes address
  65  4000
  66  4000              ; BASIC error codes
  67  4000              ;01 NEXT without FOR
  68  4000              ;02 Syntax error
  69  4000              ;03 RETURN without GOSUB
  70  4000              ;04 Out of DATA
  71  4000              ;05 Illegal function call
  72  4000              ;06 Overflow
  73  4000              ;07 Out of memory
  74  4000              ;08 Undefined line number
  75  4000              ;09 Subscript out of range
  76  4000              ;10 Redimensioned array
  77  4000              ;11 Division by zero
  78  4000              ;12 Illegal direct
  79  4000              ;13 Type mismatch
  80  4000              ;14 Out of string space
  81  4000              ;15 String too long
  82  4000              ;16 String formula too complex
  83  4000              ;17 Can't CONTINUE
  84  4000              ;18 Undefined user function
  85  4000              ;19 Device I/O error
  86  4000              ;20 Verify error
  87  4000              ;21 No RESUME
  88  4000              ;22 RESUME without error
  89  4000              ;23 Unprintable error
  90  4000              ;24 Missing operand
  91  4000              ;25 Line buffer overflow
  92  4000              ;50 FIELD overflow
  93  4000              ;51 Internal error
  94  4000              ;52 Bad file number
  95  4000              ;53 File not found
  96  4000              ;54 File already open
  97  4000              ;55 Input past end
  98  4000              ;56 Bad file name
  99  4000              ;57 Direct statement in file
 100  4000              ;58 Sequential I/O only
 101  4000              ;59 File not OPEN
 102  4000
 103  4000
 104  4000               ; simulate cartridge with BASIC extension
 105  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
 105  4004 49 60 00 00
 105  4008 00 00 00 00
 105  400C 00 00 00 00
 106  4010
 107  4010              ; this location #4010 stores last location used by basic extension
 108  4010              ; free memory after that point
 109  4010              FREEMEMPTR:
 110  4010 EE 60         DW EXT_END
 111  4012
 112  4012              ; this location #4012 stores extension version in DAA format
 113  4012              ; first byte is major version and second minor
 114  4012              VERSION:
 115  4012 00 92         DB #00, #92
 116  4014
 117  4014              ; this location #4014 contains a jump to entry point for DEFUSR approach
 118  4014              ; if excluded it contains 3xRET so that sound player can be at aspecific spot
 119  4014               IF (1 == 1)
 120  4014 C3 E6 5E        JP DEFUSR_ENTRY
 121  4017               ELSE
 122  4017 ~               .3 RET
 123  4017               ENDIF
 124  4017
 125  4017              ; binary included AKG player compiled at #4017
 126  4017               IF (SOUND_CMDS == 1)
 127  4017              	INCBIN "bin/AKG.bin"
 128  4CF3              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF3              MAIN_PLAYER_START EQU 04017H
   2+ 4CF3              PLY_AKG_START EQU 04017H
   3+ 4CF3              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 04020H
   4+ 4CF3              PLY_AKG_INITSOUNDEFFECTS EQU 04020H
   5+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04024H
   6+ 4CF3              PLY_AKG_PLAYSOUNDEFFECT EQU 04024H
   7+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04025H
   8+ 4CF3              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04025H
   9+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 0404CH
  10+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 0404CH
  11+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 0405AH
  12+ 4CF3              PLY_AKG_PSES_PLAY EQU 04093H
  13+ 4CF3              PLY_AKG_PSES_READFIRSTBYTE EQU 0409CH
  14+ 4CF3              PLY_AKG_PSES_S_ENDORLOOP EQU 040B4H
  15+ 4CF3              PLY_AKG_PSES_S_LOOP EQU 040BFH
  16+ 4CF3              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C5H
  17+ 4CF3              PLY_AKG_PSES_NOTREACHED EQU 040D8H
  18+ 4CF3              PLY_AKG_PSES_HARDWAREONLY EQU 040DCH
  19+ 4CF3              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E3H
  20+ 4CF3              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F5H
  21+ 4CF3              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FFH
  22+ 4CF3              PLY_AKG_PSES_H_AFTERRETRIG EQU 04109H
  23+ 4CF3              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411DH
  24+ 4CF3              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 04122H
  25+ 4CF3              PLY_AKG_PSES_READHARDWAREPERIOD EQU 0412AH
  26+ 4CF3              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04135H
  27+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 04141H
  28+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04143H
  29+ 4CF3              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04149H
  30+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414DH
  31+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414DH
  32+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414FH
  33+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414FH
  34+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414FH
  35+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 04150H
  36+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 04151H
  37+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04155H
  38+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04155H
  39+ 4CF3              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04155H
  40+ 4CF3              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415DH
  41+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04165H
  42+ 4CF3              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04165H
  43+ 4CF3              PLY_AKG_INIT EQU 04165H
  44+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04165H
  45+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04193H
  46+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A7H
  47+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B9H
  48+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D8H
  49+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E5H
  50+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL EQU 041EBH
  51+ 4CF3              PLY_AKG_INITTABLE0 EQU 041EEH
  52+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EEH
  53+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04208H
  54+ 4CF3              PLY_AKG_INITTABLE0_END EQU 04208H
  55+ 4CF3              PLY_AKG_INITTABLE1 EQU 04208H
  56+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04208H
  57+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 0420CH
  58+ 4CF3              PLY_AKG_INITTABLE1_END EQU 0420CH
  59+ 4CF3              PLY_AKG_INITTABLEORA EQU 0420CH
  60+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 0420CH
  61+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04224H
  62+ 4CF3              PLY_AKG_INITTABLEORA_END EQU 04224H
  63+ 4CF3              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04224H
  64+ 4CF3              PLY_AKG_STOP EQU 04224H
  65+ 4CF3              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04236H
  66+ 4CF3              PLY_AKG_PLAY EQU 04236H
  67+ 4CF3              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423EH
  68+ 4CF3              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04244H
  69+ 4CF3              PLY_AKG_READLINKER EQU 04249H
  70+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04249H
  71+ 4CF3              PLY_AKG_READLINKER_PTLINKER EQU 04249H
  72+ 4CF3              PLY_AKG_READLINKER_NOLOOP EQU 04254H
  73+ 4CF3              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428DH
  74+ 4CF3              PLY_AKG_READLINE EQU 04290H
  75+ 4CF3              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 04290H
  76+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04296H
  77+ 4CF3              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04296H
  78+ 4CF3              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A3H
  79+ 4CF3              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A7H
  80+ 4CF3              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042AAH
  81+ 4CF3              PLY_AKG_SPEEDTRACK_END EQU 042ADH
  82+ 4CF3              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042ADH
  83+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B3H
  84+ 4CF3              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B3H
  85+ 4CF3              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042C0H
  86+ 4CF3              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C4H
  87+ 4CF3              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C7H
  88+ 4CF3              PLY_AKG_EVENTTRACK_END EQU 042CAH
  89+ 4CF3              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042CAH
  90+ 4CF3              PLY_AKG_CHANNEL1_READTRACK EQU 042D6H
  91+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D6H
  92+ 4CF3              PLY_AKG_CHANNEL1_PTTRACK EQU 042D6H
  93+ 4CF3              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042F1H
  94+ 4CF3              PLY_AKG_CHANNEL1_WAIT EQU 042FCH
  95+ 4CF3              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04303H
  96+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04303H
  97+ 4CF3              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04303H
  98+ 4CF3              PLY_AKG_CHANNEL1_NOTE EQU 0430CH
  99+ 4CF3              PLY_AKG_BASENOTEINDEX EQU 0430CH
 100+ 4CF3              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430EH
 101+ 4CF3              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430EH
 102+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431EH
 103+ 4CF3              PLY_AKG_INSTRUMENTSTABLE EQU 0431EH
 104+ 4CF3              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 04330H
 105+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 04340H
 106+ 4CF3              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04368H
 107+ 4CF3              PLY_AKG_CHANNEL1_READCELLEND EQU 0436BH
 108+ 4CF3              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 0436BH
 109+ 4CF3              PLY_AKG_CHANNEL2_READTRACK EQU 04377H
 110+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04377H
 111+ 4CF3              PLY_AKG_CHANNEL2_PTTRACK EQU 04377H
 112+ 4CF3              PLY_AKG_CHANNEL2_SMALLWAIT EQU 04392H
 113+ 4CF3              PLY_AKG_CHANNEL2_WAIT EQU 0439DH
 114+ 4CF3              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A4H
 115+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A4H
 116+ 4CF3              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A4H
 117+ 4CF3              PLY_AKG_CHANNEL2_NOTE EQU 043ADH
 118+ 4CF3              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043B2H
 119+ 4CF3              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043B2H
 120+ 4CF3              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D4H
 121+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E4H
 122+ 4CF3              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 0440CH
 123+ 4CF3              PLY_AKG_CHANNEL2_READCELLEND EQU 0440FH
 124+ 4CF3              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440FH
 125+ 4CF3              PLY_AKG_CHANNEL3_READTRACK EQU 0441BH
 126+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 0441BH
 127+ 4CF3              PLY_AKG_CHANNEL3_PTTRACK EQU 0441BH
 128+ 4CF3              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04436H
 129+ 4CF3              PLY_AKG_CHANNEL3_WAIT EQU 04441H
 130+ 4CF3              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04448H
 131+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04448H
 132+ 4CF3              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04448H
 133+ 4CF3              PLY_AKG_CHANNEL3_NOTE EQU 04451H
 134+ 4CF3              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04456H
 135+ 4CF3              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04456H
 136+ 4CF3              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04478H
 137+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04488H
 138+ 4CF3              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044B0H
 139+ 4CF3              PLY_AKG_CHANNEL3_READCELLEND EQU 044B3H
 140+ 4CF3              PLY_AKG_CURRENTSPEED EQU 044B3H
 141+ 4CF3              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B5H
 142+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B8H
 143+ 4CF3              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B8H
 144+ 4CF3              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044BBH
 145+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BEH
 146+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BEH
 147+ 4CF3              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044CAH
 148+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044D1H
 149+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D4H
 150+ 4CF3              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044DAH
 151+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DDH
 152+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DDH
 153+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044EBH
 154+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044F0H
 155+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044FBH
 156+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FEH
 157+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FEH
 158+ 4CF3              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 04501H
 159+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04504H
 160+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04504H
 161+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450DH
 162+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04517H
 163+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 0451AH
 164+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 0451AH
 165+ 4CF3              PLY_AKG_CHANNEL1_PITCH EQU 0451AH
 166+ 4CF3              PLY_AKG_CHANNEL1_ISPITCH EQU 0451DH
 167+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 04522H
 168+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACK EQU 04522H
 169+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04526H
 170+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04528H
 171+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 0452AH
 172+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 04531H
 173+ 4CF3              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 04532H
 174+ 4CF3              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04535H
 175+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04535H
 176+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 04551H
 177+ 4CF3              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 04551H
 178+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455EH
 179+ 4CF3              PLY_AKG_CHANNEL1_GLIDEOVER EQU 04562H
 180+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 04572H
 181+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 04572H
 182+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04573H
 183+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04574H
 184+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04576H
 185+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04576H
 186+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04576H
 187+ 4CF3              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04577H
 188+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04578H
 189+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 0457AH
 190+ 4CF3              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 0457AH
 191+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 0457AH
 192+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 0457AH
 193+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 0457AH
 194+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457DH
 195+ 4CF3              PLY_AKG_CHANNEL1_PITCH_END EQU 0457FH
 196+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04587H
 197+ 4CF3              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04587H
 198+ 4CF3              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 0458AH
 199+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458DH
 200+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458DH
 201+ 4CF3              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04599H
 202+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 045A0H
 203+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A3H
 204+ 4CF3              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A9H
 205+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045ACH
 206+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045ACH
 207+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045BAH
 208+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BFH
 209+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045CAH
 210+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CDH
 211+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CDH
 212+ 4CF3              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045D0H
 213+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D3H
 214+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D3H
 215+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045DCH
 216+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E6H
 217+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E9H
 218+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E9H
 219+ 4CF3              PLY_AKG_CHANNEL2_PITCH EQU 045E9H
 220+ 4CF3              PLY_AKG_CHANNEL2_ISPITCH EQU 045ECH
 221+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045F1H
 222+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045F1H
 223+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F5H
 224+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F7H
 225+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F9H
 226+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 04600H
 227+ 4CF3              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 04601H
 228+ 4CF3              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04604H
 229+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04604H
 230+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 04620H
 231+ 4CF3              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 04620H
 232+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462DH
 233+ 4CF3              PLY_AKG_CHANNEL2_GLIDEOVER EQU 04631H
 234+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 04641H
 235+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 04641H
 236+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 04642H
 237+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04643H
 238+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04645H
 239+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04645H
 240+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04645H
 241+ 4CF3              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04646H
 242+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04647H
 243+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04649H
 244+ 4CF3              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04649H
 245+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04649H
 246+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04649H
 247+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04649H
 248+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_END EQU 0464CH
 249+ 4CF3              PLY_AKG_CHANNEL2_PITCH_END EQU 0464EH
 250+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04656H
 251+ 4CF3              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04656H
 252+ 4CF3              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04659H
 253+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 0465CH
 254+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 0465CH
 255+ 4CF3              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04668H
 256+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466FH
 257+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 04672H
 258+ 4CF3              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04678H
 259+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 0467BH
 260+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 0467BH
 261+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04689H
 262+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468EH
 263+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04699H
 264+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 0469CH
 265+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 0469CH
 266+ 4CF3              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469FH
 267+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 046A2H
 268+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE EQU 046A2H
 269+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046ABH
 270+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B5H
 271+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B8H
 272+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B8H
 273+ 4CF3              PLY_AKG_CHANNEL3_PITCH EQU 046B8H
 274+ 4CF3              PLY_AKG_CHANNEL3_ISPITCH EQU 046BBH
 275+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046C0H
 276+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046C0H
 277+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C4H
 278+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C6H
 279+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C8H
 280+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CFH
 281+ 4CF3              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046D0H
 282+ 4CF3              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D3H
 283+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D3H
 284+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046EFH
 285+ 4CF3              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046EFH
 286+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046FCH
 287+ 4CF3              PLY_AKG_CHANNEL3_GLIDEOVER EQU 04700H
 288+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 04710H
 289+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 04710H
 290+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 04711H
 291+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 04712H
 292+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04714H
 293+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04714H
 294+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04714H
 295+ 4CF3              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04715H
 296+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04716H
 297+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04718H
 298+ 4CF3              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04718H
 299+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04718H
 300+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04718H
 301+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04718H
 302+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_END EQU 0471BH
 303+ 4CF3              PLY_AKG_CHANNEL3_PITCH_END EQU 0471DH
 304+ 4CF3              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04729H
 305+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04729H
 306+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04729H
 307+ 4CF3              PLY_AKG_CHANNEL1_TRACKNOTE EQU 0472CH
 308+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472EH
 309+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04734H
 310+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04737H
 311+ 4CF3              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04737H
 312+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 0473AH
 313+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04743H
 314+ 4CF3              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 0474BH
 315+ 4CF3              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04758H
 316+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04758H
 317+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04758H
 318+ 4CF3              PLY_AKG_CHANNEL2_TRACKNOTE EQU 0475BH
 319+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475DH
 320+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04763H
 321+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04766H
 322+ 4CF3              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04766H
 323+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04769H
 324+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 04772H
 325+ 4CF3              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 0477AH
 326+ 4CF3              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04788H
 327+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04788H
 328+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04788H
 329+ 4CF3              PLY_AKG_CHANNEL3_TRACKNOTE EQU 0478BH
 330+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478DH
 331+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04793H
 332+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04796H
 333+ 4CF3              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04796H
 334+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04799H
 335+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 047A2H
 336+ 4CF3              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047AAH
 337+ 4CF3              PLY_AKG_SENDPSGREGISTERS EQU 047B9H
 338+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047C1H
 339+ 4CF3              PLY_AKG_PSGREG01_INSTR EQU 047C1H
 340+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047D1H
 341+ 4CF3              PLY_AKG_PSGREG23_INSTR EQU 047D1H
 342+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047E2H
 343+ 4CF3              PLY_AKG_PSGREG45_INSTR EQU 047E2H
 344+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F3H
 345+ 4CF3              PLY_AKG_PSGREG6_8_INSTR EQU 047F3H
 346+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04804H
 347+ 4CF3              PLY_AKG_PSGREG9_10_INSTR EQU 04804H
 348+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04815H
 349+ 4CF3              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04815H
 350+ 4CF3              PLY_AKG_PSGREG13_OLDVALUE EQU 0482AH
 351+ 4CF3              PLY_AKG_RETRIG EQU 0482CH
 352+ 4CF3              PLY_AKG_PSGREG13_INSTR EQU 0482EH
 353+ 4CF3              PLY_AKG_PSGREG13_END EQU 0483DH
 354+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483DH
 355+ 4CF3              PLY_AKG_SAVESP EQU 0483DH
 356+ 4CF3              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 04841H
 357+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTS EQU 04849H
 358+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04856H
 359+ 4CF3              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04856H
 360+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485EH
 361+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 0486BH
 362+ 4CF3              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 0486BH
 363+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTS EQU 04873H
 364+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487EH
 365+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS EQU 0487EH
 366+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488DH
 367+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488DH
 368+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04894H
 369+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A4H
 370+ 4CF3              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A4H
 371+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048ABH
 372+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048ABH
 373+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048AEH
 374+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B7H
 375+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B7H
 376+ 4CF3              PLY_AKG_READINSTRUMENTCELL EQU 048BDH
 377+ 4CF3              PLY_AKG_NOSOFTNOHARD EQU 048CAH
 378+ 4CF3              PLY_AKG_NSNH_NONOISE EQU 048DFH
 379+ 4CF3              PLY_AKG_SOFT EQU 048E2H
 380+ 4CF3              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E9H
 381+ 4CF3              PLY_AKG_S_NOTSIMPLE EQU 048F1H
 382+ 4CF3              PLY_AKG_S_AFTERSIMPLETEST EQU 048F4H
 383+ 4CF3              PLY_AKG_HARDTOSOFT EQU 04901H
 384+ 4CF3              PLY_AKG_HS_JUMPRATIO EQU 0490CH
 385+ 4CF3              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04939H
 386+ 4CF3              PLY_AKG_ENDWITHOUTLOOP EQU 0493BH
 387+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 0493BH
 388+ 4CF3              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 0493BH
 389+ 4CF3              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04943H
 390+ 4CF3              PLY_AKG_SH_JUMPRATIO EQU 04950H
 391+ 4CF3              PLY_AKG_SH_JUMPRATIOEND EQU 04971H
 392+ 4CF3              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 04980H
 393+ 4CF3              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04986H
 394+ 4CF3              PLY_AKG_H_OR_ENDWITHLOOP EQU 049A0H
 395+ 4CF3              PLY_AKG_H_RETRIGEND EQU 049B2H
 396+ 4CF3              PLY_AKG_H_AFTERRETRIG EQU 049B3H
 397+ 4CF3              PLY_AKG_ENDWITHLOOP EQU 049C5H
 398+ 4CF3              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049CCH
 399+ 4CF3              PLY_AKG_S_OR_H_NEXTBYTE EQU 049E2H
 400+ 4CF3              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049F0H
 401+ 4CF3              PLY_AKG_S_OR_H_AFTERPITCH EQU 04A00H
 402+ 4CF3              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0EH
 403+ 4CF3              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1DH
 404+ 4CF3              PLY_AKG_SHOHS_RETRIGEND EQU 04A2CH
 405+ 4CF3              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2DH
 406+ 4CF3              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3FH
 407+ 4CF3              PLY_AKG_EFFECTTABLE EQU 04A4DH
 408+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4DH
 409+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A71H
 410+ 4CF3              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A71H
 411+ 4CF3              PLY_AKG_EFFECT_RESET EQU 04A74H
 412+ 4CF3              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A76H
 413+ 4CF3              PLY_AKG_EFFECT_VOLUME EQU 04A91H
 414+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9DH
 415+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA3H
 416+ 4CF3              PLY_AKG_ARPEGGIOSTABLE EQU 04AA3H
 417+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04ACAH
 418+ 4CF3              PLY_AKG_EFFECT_PITCHTABLE EQU 04AD1H
 419+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD7H
 420+ 4CF3              PLY_AKG_PITCHESTABLE EQU 04AD7H
 421+ 4CF3              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFEH
 422+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B05H
 423+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B16H
 424+ 4CF3              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1DH
 425+ 4CF3              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2DH
 426+ 4CF3              PLY_AKG_EFFECT_PITCHUP EQU 04B42H
 427+ 4CF3              PLY_AKG_EFFECT_PITCHSTOP EQU 04B54H
 428+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B5BH
 429+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B85H
 430+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B85H
 431+ 4CF3              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9EH
 432+ 4CF3              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9EH
 433+ 4CF3              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BB0H
 434+ 4CF3              PLY_AKG_EFFECT_LEGATO EQU 04BC6H
 435+ 4CF3              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BDAH
 436+ 4CF3              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BE2H
 437+ 4CF3              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BEAH
 438+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BF2H
 439+ 4CF3              PLY_AKG_EVENT EQU 04BF2H
 440+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF3H
 441+ 4CF3              PLY_AKG_PERIODTABLE EQU 04BF3H
 442+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF3H
 443+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF3H
 444+ 4CF3              PLY_AKG_PERIODTABLE_END EQU 04CF3H
 445+ 4CF3              PLY_AKG_END EQU 04CF3H
 446+ 4CF3              MAIN_PLAYER_END EQU 04CF3H
 447+ 4CF3              TESTEREND EQU 04CF3H
 448+ 4CF3
# file closed: ./symbol/AKG.sym
 129  4CF3               ENDIF
 130  4CF3
 131  4CF3               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
   1+ 4CF3              ORIG.HTIMI:
   2+ 4CF3 00 00 00 00  	DB 0, 0, 0, 0, 0
   2+ 4CF7 00
   3+ 4CF8               EXPORT ORIG.HTIMI
   4+ 4CF8
   5+ 4CF8              ; *******************************************************************************************************
   6+ 4CF8              ; interrupt handler when page 0 enabled
   7+ 4CF8              ; we are here only if one of the extended basic commands have paged in page 0
   8+ 4CF8              ; which means we arrived from BASIC so page 2 is already good
   9+ 4CF8              VBLANK:
  10+ 4CF8              	EXPORT VBLANK
  11+ 4CF8
  12+ 4CF8 F5               PUSH AF
  13+ 4CF9              	; is VDP originator ?
  14+ 4CF9 DB 99        	IN	A, (099H)
  15+ 4CFB A7           	AND	A
  16+ 4CFC F2 23 4D     	JP P, .EXIT
  17+ 4CFF
  18+ 4CFF               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  19+ 4CFF C5               PUSH BC
  20+ 4D00 D5               PUSH DE
  21+ 4D01 E5               PUSH HL
  22+ 4D02 08               EX AF, AF'
  23+ 4D03 D9               EXX
  24+ 4D04 F5               PUSH AF
  25+ 4D05 C5               PUSH BC
  26+ 4D06 D5               PUSH DE
  27+ 4D07 E5               PUSH HL
  28+ 4D08 DD E5            PUSH IX
  29+ 4D0A FD E5            PUSH IY
  30+ 4D0C
  31+ 4D0C               IF (SPRITE_CMDS == 1)
  32+ 4D0C CD 5D 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  33+ 4D0F               ENDIF
  34+ 4D0F
  35+ 4D0F               IF (SOUND_CMDS == 1)
  36+ 4D0F 3A 73 55     	LD A, (SOUND_ENABLED)
  37+ 4D12 B7           	OR A
  38+ 4D13 C4 36 42     	CALL NZ,PLY_AKG_PLAY
  39+ 4D16               ENDIF
  40+ 4D16
  41+ 4D16                  ; increase JIFFY
  42+ 4D16                  ;LD HL,(JIFFY)
  43+ 4D16                  ;INC HL
  44+ 4D16                  ;LD (JIFFY),HL
  45+ 4D16
  46+ 4D16 FD E1            POP IY
  47+ 4D18 DD E1            POP IX
  48+ 4D1A E1               POP HL
  49+ 4D1B D1               POP DE
  50+ 4D1C C1               POP BC
  51+ 4D1D F1               POP AF
  52+ 4D1E 08               EX AF, AF'
  53+ 4D1F D9               EXX
  54+ 4D20 E1               POP HL
  55+ 4D21 D1               POP DE
  56+ 4D22 C1               POP BC
  57+ 4D23               ENDIF
  58+ 4D23
  59+ 4D23              .EXIT:
  60+ 4D23 F1           	POP AF
  61+ 4D24 FB           	EI
  62+ 4D25 ED 4D        	RETI
  63+ 4D27              ; *******************************************************************************************************
  64+ 4D27
  65+ 4D27              ; *******************************************************************************************************
  66+ 4D27              ; H.TIMI function
  67+ 4D27              ; we can end up here from anywhere so page in both page 0 and 2
  68+ 4D27              MBGE_HTIMI:
  69+ 4D27               EXPORT MBGE_HTIMI
  70+ 4D27
  71+ 4D27               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  72+ 4D27
  73+ 4D27 F5           	PUSH AF
  74+ 4D28
  75+ 4D28              	; enable page 2
  76+ 4D28 3E 02            LD A, 2
  77+ 4D2A CD 78 5F         CALL GET_PAGE_INFO
  78+ 4D2D C5               PUSH BC
  79+ 4D2E D5               PUSH DE
  80+ 4D2F 3A 43 F3         LD A, (RAMAD2)
  81+ 4D32 26 80            LD H, 080H
  82+ 4D34 CD BF 5F         CALL LOCAL_ENASLT
  83+ 4D37              	; enable page 0
  84+ 4D37 AF               XOR A
  85+ 4D38 CD 78 5F         CALL GET_PAGE_INFO
  86+ 4D3B C5               PUSH BC
  87+ 4D3C D5               PUSH DE
  88+ 4D3D 3A 41 F3         LD A, (RAMAD0)
  89+ 4D40 26 00            LD H, 0
  90+ 4D42 CD BF 5F         CALL LOCAL_ENASLT
  91+ 4D45
  92+ 4D45               IF (SPRITE_CMDS == 1)
  93+ 4D45 CD 5D 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  94+ 4D48               ENDIF
  95+ 4D48
  96+ 4D48               IF (SOUND_CMDS == 1)
  97+ 4D48 3A 73 55     	LD A, (SOUND_ENABLED)
  98+ 4D4B B7           	OR A
  99+ 4D4C C4 36 42     	CALL NZ,PLY_AKG_PLAY
 100+ 4D4F               ENDIF
 101+ 4D4F
 102+ 4D4F              	; restore page 0
 103+ 4D4F D1               POP DE
 104+ 4D50 C1               POP BC
 105+ 4D51 CD AF 5F         CALL RESTORE_PAGE_INFO
 106+ 4D54              	; restore page 2
 107+ 4D54 D1               POP DE
 108+ 4D55 C1               POP BC
 109+ 4D56 CD AF 5F         CALL RESTORE_PAGE_INFO
 110+ 4D59
 111+ 4D59 F1           	POP AF
 112+ 4D5A               ENDIF
 113+ 4D5A C3 F3 4C     	JP ORIG.HTIMI
 114+ 4D5D              ; *******************************************************************************************************
 115+ 4D5D
 116+ 4D5D              ; *******************************************************************************************************
 117+ 4D5D              ; function checks if the sprite system is initialized and what screen mode we are running
 118+ 4D5D              ; also checks if some VRAM modifying command is running
 119+ 4D5D              ; when that checks out calls sprite updates and animation processing
 120+ 4D5D              ; if in an unsupported mode disables sprite handling
 121+ 4D5D              PROCESS_SPRITES_AND_ANIMATIONS:
 122+ 4D5D              	; check if initialized
 123+ 4D5D 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
 124+ 4D60 B7           	OR A
 125+ 4D61 C8           	RET Z
 126+ 4D62              	; check screen mode
 127+ 4D62 3A AF FC     	LD A, (SCRMOD)
 128+ 4D65 3D           	DEC A
 129+ 4D66 28 08        	JR Z, .L0 ; screen 1
 130+ 4D68 3D           	DEC A
 131+ 4D69 28 05            JR Z, .L0 ; screen 2
 132+ 4D6B              	; unsupported screen mode, disable
 133+ 4D6B AF               XOR A
 134+ 4D6C 32 7F 4D         LD (SPRATR_INIT_STATUS),A
 135+ 4D6F C9               RET
 136+ 4D70              .L0:
 137+ 4D70                  ; check if anyone else is working with VRAM
 138+ 4D70 3A 15 5F         LD A,(VRAM_UPDATE_IN_PROGRESS)
 139+ 4D73 B7               OR A
 140+ 4D74 C0               RET NZ
 141+ 4D75
 142+ 4D75 CD 95 4D         CALL SPRATR_UPDATE
 143+ 4D78
 144+ 4D78               IF (ANIM_CMDS == 1)
 145+ 4D78 CD D2 52         CALL PROCESS_ANIMATIONS
 146+ 4D7B CD 31 54         CALL PROCESS_AUTOSGAMS
 147+ 4D7E               ENDIF
 148+ 4D7E C9               RET
 149+ 4D7F              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
 132  4D7F
 133  4D7F               IF (SPRITE_CMDS == 1)
 134  4D7F               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4D7F              ; commands and variables related to sprites
   2+ 4D7F
   3+ 4D7F              SPRATR_INIT_STATUS:
   4+ 4D7F 00            DB 0
   5+ 4D80              SPRATR_UPDATE_FLAG:
   6+ 4D80 00 00         DW 0
   7+ 4D82              SPRATR_DATA:
   8+ 4D82 00 00         DW 0
   9+ 4D84              SPRFLICKER_ENABLED:
  10+ 4D84 00            DB 0
  11+ 4D85              ; to support sprite flicker
  12+ 4D85              FLICKER:
  13+ 4D85 00            DB 0
  14+ 4D86              NUM_SPRITES_HANDLED:
  15+ 4D86 20            DB 32
  16+ 4D87
  17+ 4D87              ; to temporarily store stack pointer
  18+ 4D87              TMPSP:
  19+ 4D87 00 00         DW 0
  20+ 4D89
  21+ 4D89              ; *******************************************************************************************************
  22+ 4D89              ; helper function gets pointer to n-th entry in sprite attributes
  23+ 4D89              ; changes HL,DE
  24+ 4D89              GETnthSPRATTR:
  25+ 4D89 26 00            LD H,0
  26+ 4D8B 6F               LD L,A
  27+ 4D8C CD 74 5F         CALL HLx8
  28+ 4D8F ED 5B 82 4D      LD DE,(SPRATR_DATA)
  29+ 4D93 19               ADD HL,DE
  30+ 4D94 C9               RET
  31+ 4D95              ; *******************************************************************************************************
  32+ 4D95
  33+ 4D95              ; *******************************************************************************************************
  34+ 4D95              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  35+ 4D95              ; struct {
  36+ 4D95              ; DW y
  37+ 4D95              ; DW x
  38+ 4D95              ; DW pattern (0-63)
  39+ 4D95              ; DW color
  40+ 4D95              ; } [32]
  41+ 4D95              ; will hide sprites whose location is outside of visible area
  42+ 4D95              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  43+ 4D95              ; modifies AF, AF', BC, DE, HL, IX
  44+ 4D95              SPRATR_UPDATE:
  45+ 4D95              	; check if update requested
  46+ 4D95 2A 80 4D     	LD HL, (SPRATR_UPDATE_FLAG)
  47+ 4D98 7E           	LD A, (HL)
  48+ 4D99 B7           	OR A
  49+ 4D9A C8           	RET Z
  50+ 4D9B
  51+ 4D9B DD 21 86 4D  	LD IX,NUM_SPRITES_HANDLED
  52+ 4D9F DD 46 00     	LD B, (IX) ; sprite number
  53+ 4DA2 0E 98        	LD C, #98 ; register for vdp data output
  54+ 4DA4              	; set VDP address
  55+ 4DA4 3A AF FC         LD A,(SCRMOD)
  56+ 4DA7 3D               DEC A
  57+ 4DA8 20 05            JR NZ,.L4
  58+ 4DAA 2A C3 F3         LD HL, (T32ATR)
  59+ 4DAD 18 03            JR .L5
  60+ 4DAF              .L4:
  61+ 4DAF 2A CD F3         LD HL, (GRPATR)
  62+ 4DB2              .L5:
  63+ 4DB2 3A 84 4D     	LD A, (SPRFLICKER_ENABLED)
  64+ 4DB5 B7           	OR A
  65+ 4DB6 28 03        	JR Z, .L3
  66+ 4DB8 3A 85 4D     	LD A, (FLICKER)
  67+ 4DBB              .L3:
  68+ 4DBB 5F           	LD E, A
  69+ 4DBC 08           	EX AF, AF'
  70+ 4DBD 7B           	LD A, E
  71+ 4DBE 87           	ADD A, A
  72+ 4DBF 87           	ADD A, A
  73+ 4DC0 16 00        	LD D, 0
  74+ 4DC2 5F           	LD E, A
  75+ 4DC3 19           	ADD HL, DE
  76+ 4DC4 CD 55 5F     	CALL SETWRT_LOCAL_WRITE
  77+ 4DC7 ED 73 87 4D  	LD (TMPSP), SP
  78+ 4DCB ED 7B 82 4D  	LD SP, (SPRATR_DATA)
  79+ 4DCF
  80+ 4DCF              .LOOP:
  81+ 4DCF E1           	POP HL
  82+ 4DD0 24           	INC H
  83+ 4DD1 28 0D        	JR Z, .L1 ; negative number between -256 and -1
  84+ 4DD3 25           	DEC H
  85+ 4DD4 20 15        	JR NZ, .OUT3 ; sprite vertically can't be visible
  86+ 4DD6 7D           	LD A, L
  87+ 4DD7 FE C0        	CP 192
  88+ 4DD9 30 10        	JR NC, .OUT3
  89+ 4DDB 3D           	DEC A ; due to VDP rule that top of screen is -1
  90+ 4DDC 57           	LD D, A
  91+ 4DDD C3 04 4E     	JP .X
  92+ 4DE0              .L1:
  93+ 4DE0 7D           	LD A, L
  94+ 4DE1 C6 10        	ADD 16
  95+ 4DE3 FA EB 4D     	JP M, .OUT3 ; below -16
  96+ 4DE6 2D           	DEC L ; due to VDP rule that top of screen is -1
  97+ 4DE7 55           	LD D, L
  98+ 4DE8 C3 04 4E     	JP .X
  99+ 4DEB              .OUT3:
 100+ 4DEB E1           	POP HL ; skip x value
 101+ 4DEC              .OUT2:
 102+ 4DEC E1           	POP HL ; skip pattern
 103+ 4DED E1           	POP HL ; skip color
 104+ 4DEE 3E D1        	LD A, #D1
 105+ 4DF0 ED 79        	OUT (C), A ; sprite hidden
 106+ 4DF2 00          > NOP
 106+ 4DF3 00          > NOP
 106+ 4DF4 00          > NOP
 107+ 4DF5 ED 79        	OUT (C), A ; value unimportant
 108+ 4DF7 00          > NOP
 108+ 4DF8 00          > NOP
 108+ 4DF9 00          > NOP
 109+ 4DFA ED 79        	OUT (C), A ; value unimportant
 110+ 4DFC 00          > NOP
 110+ 4DFD 00          > NOP
 110+ 4DFE 00          > NOP
 111+ 4DFF ED 79        	OUT (C), A ; value unimportant
 112+ 4E01 C3 2F 4E     	JP .NEXT
 113+ 4E04              .X:
 114+ 4E04 E1           	POP HL
 115+ 4E05 24           	INC H
 116+ 4E06 28 08        	JR Z, .L2
 117+ 4E08 25           	DEC H
 118+ 4E09 20 E1        	JR NZ, .OUT2
 119+ 4E0B 1E 00        	LD E, 0 ; EC bit
 120+ 4E0D C3 19 4E     	JP .XY
 121+ 4E10              .L2:
 122+ 4E10 7D           	LD A, L
 123+ 4E11 C6 20        	ADD 32
 124+ 4E13 FA EC 4D     	JP M, .OUT2
 125+ 4E16 6F           	LD L, A
 126+ 4E17 1E 80        	LD E, #80
 127+ 4E19              .XY:
 128+ 4E19 ED 51        	OUT (C), D
 129+ 4E1B 3A E0 F3     	LD A, (REG1SAV)
 130+ 4E1E E6 02        	AND 2
 131+ 4E20 ED 69        	OUT (C), L
 132+ 4E22 E1           	POP HL ; pattern
 133+ 4E23 7D           	LD A, L
 134+ 4E24 28 02        	JR Z, .SMALLSPRITES
 135+ 4E26 87           	ADD A, A
 136+ 4E27 87           	ADD A, A ; needs to go at 4x
 137+ 4E28              .SMALLSPRITES:
 138+ 4E28 D3 98        	OUT (#98), A
 139+ 4E2A E1           	POP HL ; color
 140+ 4E2B 7D           	LD A, L
 141+ 4E2C B3           	OR E
 142+ 4E2D D3 98        	OUT (#98), A
 143+ 4E2F              .NEXT:
 144+ 4E2F 08           	EX AF, AF'
 145+ 4E30 3C           	INC A ; increase current sprite
 146+ 4E31 DD BE 00     	CP (IX) ; compare to maximum handled
 147+ 4E34 C2 54 4E     	JP NZ, .NEXT2 ; continue if not over
 148+ 4E37 AF           	XOR A ; back to zero
 149+ 4E38 08           	EX AF, AF'
 150+ 4E39 3A AF FC         LD A,(SCRMOD)
 151+ 4E3C 3D               DEC A
 152+ 4E3D 20 05            JR NZ,.L6
 153+ 4E3F 2A C3 F3         LD HL, (T32ATR)
 154+ 4E42 18 03            JR .L7
 155+ 4E44              .L6:
 156+ 4E44 2A CD F3         LD HL, (GRPATR)
 157+ 4E47              .L7:
 158+ 4E47              	; CALL SETWRT_LOCAL not allowed as SP modified
 159+ 4E47 7D           	LD	A, L
 160+ 4E48 D3 99        	OUT	(099H), A
 161+ 4E4A 7C           	LD	A, H
 162+ 4E4B E6 3F        	AND	03FH
 163+ 4E4D F6 40        	OR	040H
 164+ 4E4F D3 99        	OUT	(099H), A
 165+ 4E51 C3 55 4E     	JP .NEXT3
 166+ 4E54              .NEXT2:
 167+ 4E54 08           	EX AF, AF'
 168+ 4E55              .NEXT3:
 169+ 4E55 05           	DEC B
 170+ 4E56 C2 CF 4D     	JP NZ, .LOOP
 171+ 4E59 08           	EX AF, AF'
 172+ 4E5A 3C           	INC A ; increase flicker to start at the next one on next vblank
 173+ 4E5B DD BE 00     	CP (IX)
 174+ 4E5E 20 01        	JR NZ,.L8
 175+ 4E60 AF           	XOR A
 176+ 4E61              .L8:
 177+ 4E61 32 85 4D     	LD (FLICKER), A
 178+ 4E64
 179+ 4E64 ED 7B 87 4D  	LD SP, (TMPSP)
 180+ 4E68 2A 80 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 181+ 4E6B 36 00        	LD (HL), 0 ; zero out update flag
 182+ 4E6D C9           	RET
 183+ 4E6E              ; *******************************************************************************************************
 184+ 4E6E
 185+ 4E6E               IF (0 == 1)
 186+ 4E6E ~            ; *******************************************************************************************************
 187+ 4E6E ~            ; function to handle CALL SPRENABLE basic extension
 188+ 4E6E ~            ; initializes sprites handler
 189+ 4E6E ~            ; _SPRENABLE ( INT[3][31] variable sprites_attributes,
 190+ 4E6E ~            ;			   INT variable update_variable,
 191+ 4E6E ~            ;			   BYTE sprite_flicker_enabled,
 192+ 4E6E ~            ;			   BYTE num_sprites_handled )
 193+ 4E6E ~            ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA, SPRFLICKER_ENABLED and NUM_SPRITES_HANDLED
 194+ 4E6E ~            SPRENABLE:
 195+ 4E6E ~            	; opening (
 196+ 4E6E ~            	CALL CHKCHAR
 197+ 4E6E ~            	DB '('
 198+ 4E6E ~            	; get address of sprite attribute table DIM SA%(3,31)
 199+ 4E6E ~            	LD A,2
 200+ 4E6E ~            	LD B,2
 201+ 4E6E ~            	LD DE,#0420
 202+ 4E6E ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
 203+ 4E6E ~            	LD (SPRATR_DATA), BC
 204+ 4E6E ~            	; comma
 205+ 4E6E ~            	CALL CHKCHAR
 206+ 4E6E ~            	DB ','
 207+ 4E6E ~            	; get address of sprite update flag
 208+ 4E6E ~            	LD IX, PTRGET
 209+ 4E6E ~            	CALL CALBAS
 210+ 4E6E ~            	LD (SPRATR_UPDATE_FLAG), DE
 211+ 4E6E ~            	; comma
 212+ 4E6E ~            	CALL CHKCHAR
 213+ 4E6E ~            	DB ','
 214+ 4E6E ~            	; get flicker enabled flag
 215+ 4E6E ~            	LD IX, GETBYT
 216+ 4E6E ~            	CALL CALBAS
 217+ 4E6E ~            	LD (SPRFLICKER_ENABLED), A
 218+ 4E6E ~            	; comma
 219+ 4E6E ~            	CALL CHKCHAR
 220+ 4E6E ~            	DB ','
 221+ 4E6E ~            	; get number of handled sprites
 222+ 4E6E ~            	LD IX, GETBYT
 223+ 4E6E ~            	CALL CALBAS
 224+ 4E6E ~            	LD (NUM_SPRITES_HANDLED),A
 225+ 4E6E ~            	; ending )
 226+ 4E6E ~            	CALL CHKCHAR
 227+ 4E6E ~            	DB ')'
 228+ 4E6E ~            .L0:
 229+ 4E6E ~            	LD A, 1
 230+ 4E6E ~            	LD (SPRATR_INIT_STATUS), A
 231+ 4E6E ~            	RET
 232+ 4E6E ~            ; *******************************************************************************************************
 233+ 4E6E               ENDIF
 234+ 4E6E
 235+ 4E6E               IF (1 == 1)
 236+ 4E6E              ; same as SPRENABLE but for DEFUSR approach
 237+ 4E6E              ; input IX=pointer to input array, real data from +2
 238+ 4E6E              ; +2 = pointer to sprite attributes array data
 239+ 4E6E              ; +4 = pointer to sprite update variable
 240+ 4E6E              ; +6 = flicker flag
 241+ 4E6E              ; +8 = number of sprites to handle
 242+ 4E6E              SPRENABLE_DEFUSR:
 243+ 4E6E DD 6E 02     	LD L,(IX+2)
 244+ 4E71 DD 66 03     	LD H,(IX+3)
 245+ 4E74 22 82 4D     	LD (SPRATR_DATA),HL
 246+ 4E77 DD 6E 04     	LD L,(IX+4)
 247+ 4E7A DD 66 05     	LD H,(IX+5)
 248+ 4E7D 22 80 4D     	LD (SPRATR_UPDATE_FLAG),HL
 249+ 4E80 DD 7E 06     	LD A,(IX+6)
 250+ 4E83 32 84 4D     	LD (SPRFLICKER_ENABLED),A
 251+ 4E86 DD 7E 08     	LD A,(IX+8)
 252+ 4E89 32 86 4D     	LD (NUM_SPRITES_HANDLED),A
 253+ 4E8C               IF (0 == 1)
 254+ 4E8C ~            	JR SPRENABLE.L0
 255+ 4E8C               ELSE
 256+ 4E8C 3E 01        	LD A, 1
 257+ 4E8E 32 7F 4D     	LD (SPRATR_INIT_STATUS), A
 258+ 4E91 C9           	RET
 259+ 4E92               ENDIF
 260+ 4E92               ENDIF
 261+ 4E92
 262+ 4E92               IF (1 + 0 > 0)
 263+ 4E92              ; *******************************************************************************************************
 264+ 4E92              ; function to handle CALL SPRDISABLE basic extension
 265+ 4E92              ; disables sprites handling
 266+ 4E92              ; _SPRDISABLE
 267+ 4E92              ; resets variable SPRATR_INIT_STATUS
 268+ 4E92              SPRDISABLE:
 269+ 4E92              SPRDISABLE_DEFUSR:
 270+ 4E92 AF           	XOR A
 271+ 4E93 32 7F 4D     	LD (SPRATR_INIT_STATUS), A
 272+ 4E96 C9           	RET
 273+ 4E97              ; *******************************************************************************************************
 274+ 4E97               ENDIF
 275+ 4E97
 276+ 4E97              ; *******************************************************************************************************
 277+ 4E97              ; function to handle CALL SPRSET basic extension
 278+ 4E97              ; sets position, and optionally pattern and color of sprite
 279+ 4E97              ; _SPRSET ( BYTE sprite_num , valid 0-31
 280+ 4E97              ;			INT x,
 281+ 4E97              ;			INT y,
 282+ 4E97              ;			INT pattern, valid 0-63, otherwise ignored
 283+ 4E97              ;			INT color, valid 0-15, otherwise ignored
 284+ 4E97              ;SPRSET:
 285+ 4E97              ;	LD A, (SPRATR_INIT_STATUS)
 286+ 4E97              ;	OR A
 287+ 4E97              ;	JR NZ, .L1
 288+ 4E97              ;	LD E, 5 ; illegal function call
 289+ 4E97              ;	JP THROW_ERROR
 290+ 4E97              ;.L1:
 291+ 4E97              ;	; opening (
 292+ 4E97              ;	CALL CHKCHAR
 293+ 4E97              ;	DB '('
 294+ 4E97              ;	; get sprite number
 295+ 4E97              ;	LD IX, GETBYT
 296+ 4E97              ;	CALL CALBAS
 297+ 4E97              ;	PUSH AF
 298+ 4E97              ;	; comma
 299+ 4E97              ;	CALL CHKCHAR
 300+ 4E97              ;	DB ','
 301+ 4E97              ;	; get x
 302+ 4E97              ;	LD IX, FRMQNT
 303+ 4E97              ;	CALL CALBAS
 304+ 4E97              ;	PUSH DE
 305+ 4E97              ;	; comma
 306+ 4E97              ;	CALL CHKCHAR
 307+ 4E97              ;	DB ','
 308+ 4E97              ;	; get y
 309+ 4E97              ;	LD IX, FRMQNT
 310+ 4E97              ;	CALL CALBAS
 311+ 4E97              ;	PUSH DE
 312+ 4E97              ;	; comma
 313+ 4E97              ;	CALL CHKCHAR
 314+ 4E97              ;	DB ','
 315+ 4E97              ;	; get pattern
 316+ 4E97              ;	LD IX, FRMQNT
 317+ 4E97              ;	CALL CALBAS
 318+ 4E97              ;	PUSH DE
 319+ 4E97              ;	; comma
 320+ 4E97              ;	CALL CHKCHAR
 321+ 4E97              ;	DB ','
 322+ 4E97              ;	; get color
 323+ 4E97              ;	LD IX, FRMQNT
 324+ 4E97              ;	CALL CALBAS
 325+ 4E97              ;	PUSH DE
 326+ 4E97              ;	; ending )
 327+ 4E97              ;	CALL CHKCHAR
 328+ 4E97              ;	DB ')'
 329+ 4E97              ;
 330+ 4E97              ;   ; save position in BASIC text
 331+ 4E97              ;	PUSH HL
 332+ 4E97              ;	POP IX
 333+ 4E97              ;
 334+ 4E97              ;	POP BC ; color
 335+ 4E97              ;	POP DE ; pattern
 336+ 4E97              ;	EXX
 337+ 4E97              ;	POP BC ; y
 338+ 4E97              ;	POP DE ; x
 339+ 4E97              ;	POP AF ; sprite number
 340+ 4E97              ;	CP 32
 341+ 4E97              ;	JR C, .L2
 342+ 4E97              ;	LD E, 5 ; illegal function call
 343+ 4E97              ;	JP THROW_ERROR
 344+ 4E97              ;.L2:
 345+ 4E97              ;	; find location in sprite attributes table
 346+ 4E97              ;	PUSH DE
 347+ 4E97              ;	CALL GETnthSPRATTR
 348+ 4E97              ;	POP DE
 349+ 4E97              ;	DI
 350+ 4E97              ;	; set y
 351+ 4E97              ;	LD (HL), C
 352+ 4E97              ;	INC HL
 353+ 4E97              ;	LD (HL), B
 354+ 4E97              ;	INC HL
 355+ 4E97              ;	; set x
 356+ 4E97              ;	LD (HL), E
 357+ 4E97              ;	INC HL
 358+ 4E97              ;	LD (HL), D
 359+ 4E97              ;	INC HL
 360+ 4E97              ;	PUSH HL
 361+ 4E97              ;	EXX
 362+ 4E97              ;	POP HL
 363+ 4E97              ;	; check if 0<=pattern<64
 364+ 4E97              ;	LD A, D
 365+ 4E97              ;	OR A
 366+ 4E97              ;	JR NZ, .L3
 367+ 4E97              ;	LD A, E
 368+ 4E97              ;	CP 64
 369+ 4E97              ;	JR NC, .L3
 370+ 4E97              ;	; set pattern
 371+ 4E97              ;	;ADD A, A
 372+ 4E97              ;	;ADD A, A
 373+ 4E97              ;	;ADD A, A
 374+ 4E97              ;	LD (HL), A
 375+ 4E97              ;	INC HL
 376+ 4E97              ;	LD (HL), D
 377+ 4E97              ;	INC HL
 378+ 4E97              ;	JR .L4
 379+ 4E97              ;.L3:
 380+ 4E97              ;	; skip pattern
 381+ 4E97              ;	.2 INC HL
 382+ 4E97              ;.L4:
 383+ 4E97              ;	; check if 0<=color<16
 384+ 4E97              ;	LD A, B
 385+ 4E97              ;	OR A
 386+ 4E97              ;	JR NZ, .L5
 387+ 4E97              ;	LD A, C
 388+ 4E97              ;	CP 16
 389+ 4E97              ;	JR NC, .L5
 390+ 4E97              ;	; set color
 391+ 4E97              ;	LD (HL), C
 392+ 4E97              ;	INC HL
 393+ 4E97              ;	LD (HL), B
 394+ 4E97              ;
 395+ 4E97              ;.L5:
 396+ 4E97              ;	EI
 397+ 4E97              ;	PUSH IX
 398+ 4E97              ;	POP HL
 399+ 4E97              ;	RET
 400+ 4E97              ; *******************************************************************************************************
 401+ 4E97
 402+ 4E97              ; *******************************************************************************************************
 403+ 4E97              ; function sets sprite location based on initial coordinates and offset provided
 404+ 4E97              ; input A=sprite number in SPRATR_DATA , 0-31
 405+ 4E97              ; input DE=initial x
 406+ 4E97              ; input BC=initial y
 407+ 4E97              ; input IY=location where delta y,x are located
 408+ 4E97              ; modifies AF, HL, IX
 409+ 4E97              SPRSET_DELTA_POS:
 410+ 4E97 D5           	PUSH DE
 411+ 4E98 CD 89 4D     	CALL GETnthSPRATTR
 412+ 4E9B E5           	PUSH HL
 413+ 4E9C DD E1        	POP IX
 414+ 4E9E D1           	POP DE
 415+ 4E9F              	; IX=sprite's y location
 416+ 4E9F FD 6E 00     	LD L, (IY)
 417+ 4EA2 FD 66 01     	LD H, (IY+1)
 418+ 4EA5 09           	ADD HL, BC
 419+ 4EA6 DD 75 00     	LD (IX), L
 420+ 4EA9 DD 74 01     	LD (IX+1), H
 421+ 4EAC FD 6E 02     	LD L, (IY+2)
 422+ 4EAF FD 66 03     	LD H, (IY+3)
 423+ 4EB2 19           	ADD HL, DE
 424+ 4EB3 DD 75 02     	LD (IX+2), L
 425+ 4EB6 DD 74 03     	LD (IX+3), H
 426+ 4EB9 C9           	RET
 427+ 4EBA              ; *******************************************************************************************************
 428+ 4EBA
 429+ 4EBA              ; *******************************************************************************************************
 430+ 4EBA              ; helper function to set new locations for a set of sprites
 431+ 4EBA              ; input B=number of sprites
 432+ 4EBA              ; HL=pointer to list of sprites and offsets
 433+ 4EBA              SPR_UPDATE_LOC:
 434+ 4EBA 3E 01        	LD A,1
 435+ 4EBC 32 15 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 436+ 4EBF 7E           	LD A, (HL)
 437+ 4EC0 23           	INC HL
 438+ 4EC1 23           	INC HL
 439+ 4EC2 E5           	PUSH HL
 440+ 4EC3 FD E1        	POP IY
 441+ 4EC5 D9           	EXX
 442+ 4EC6 CD 97 4E     	CALL SPRSET_DELTA_POS
 443+ 4EC9 D9           	EXX
 444+ 4ECA 23          > INC HL
 444+ 4ECB 23          > INC HL
 444+ 4ECC 23          > INC HL
 444+ 4ECD 23          > INC HL
 445+ 4ECE 10 EA        	DJNZ SPR_UPDATE_LOC
 446+ 4ED0 AF           	XOR A
 447+ 4ED1 32 15 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 448+ 4ED4 C9           	RET
 449+ 4ED5              ; *******************************************************************************************************
 450+ 4ED5
 451+ 4ED5               IF (0 == 1)
 452+ 4ED5 ~            ; *******************************************************************************************************
 453+ 4ED5 ~            ; function to handle CALL SPRGRPMOV basic extension
 454+ 4ED5 ~            ; sets position of a group of sprites described with
 455+ 4ED5 ~            ; { int sprite_num, int delta_y, int delta_x } [count]
 456+ 4ED5 ~            ; _SPRGRPMOV ( INT x,
 457+ 4ED5 ~            ;			   INT y,
 458+ 4ED5 ~            ;			   BYTE count,
 459+ 4ED5 ~            ;			   INT[2][count] data_ptr
 460+ 4ED5 ~            SPRGRPMOV:
 461+ 4ED5 ~            	LD A, (SPRATR_INIT_STATUS)
 462+ 4ED5 ~            	OR A
 463+ 4ED5 ~            	JP Z,ILLEGAL_FUNCTION
 464+ 4ED5 ~            	; opening (
 465+ 4ED5 ~            	CALL CHKCHAR
 466+ 4ED5 ~            	DB '('
 467+ 4ED5 ~            	; get x
 468+ 4ED5 ~            	LD IX, FRMQNT
 469+ 4ED5 ~            	CALL CALBAS
 470+ 4ED5 ~            	LD (BLIT_STRUCT),DE
 471+ 4ED5 ~            	; comma
 472+ 4ED5 ~            	CALL CHKCHAR
 473+ 4ED5 ~            	DB ','
 474+ 4ED5 ~            	; get y
 475+ 4ED5 ~            	LD IX, FRMQNT
 476+ 4ED5 ~            	CALL CALBAS
 477+ 4ED5 ~            	LD (BLIT_STRUCT+2),DE
 478+ 4ED5 ~            	; comma
 479+ 4ED5 ~            	CALL CHKCHAR
 480+ 4ED5 ~            	DB ','
 481+ 4ED5 ~            	; get count
 482+ 4ED5 ~            	LD IX, GETBYT
 483+ 4ED5 ~            	CALL CALBAS
 484+ 4ED5 ~            	LD (BLIT_STRUCT+4),A
 485+ 4ED5 ~            	; comma
 486+ 4ED5 ~            	CALL CHKCHAR
 487+ 4ED5 ~            	DB ','
 488+ 4ED5 ~            	; get sprite group definition array data pointer
 489+ 4ED5 ~            	LD A,(BLIT_STRUCT+4)
 490+ 4ED5 ~            	LD E,A
 491+ 4ED5 ~            	LD D,3
 492+ 4ED5 ~            	LD A,2
 493+ 4ED5 ~            	LD B,A
 494+ 4ED5 ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
 495+ 4ED5 ~            	LD (BLIT_STRUCT+5),BC
 496+ 4ED5 ~            	; ending )
 497+ 4ED5 ~            	CALL CHKCHAR
 498+ 4ED5 ~            	DB ')'
 499+ 4ED5 ~
 500+ 4ED5 ~            	PUSH HL
 501+ 4ED5 ~
 502+ 4ED5 ~                EXX
 503+ 4ED5 ~                LD DE,(BLIT_STRUCT) ; initial x
 504+ 4ED5 ~                LD BC,(BLIT_STRUCT+2) ; initial y
 505+ 4ED5 ~                EXX
 506+ 4ED5 ~                LD HL,(BLIT_STRUCT+5) ; pointer to data
 507+ 4ED5 ~                LD A,(BLIT_STRUCT+4) ; number of entries
 508+ 4ED5 ~                LD B,A
 509+ 4ED5 ~            	CALL SPR_UPDATE_LOC
 510+ 4ED5 ~
 511+ 4ED5 ~            	POP HL
 512+ 4ED5 ~            	RET
 513+ 4ED5 ~            ; *******************************************************************************************************
 514+ 4ED5               ENDIF
 515+ 4ED5
 516+ 4ED5               IF (1 == 1)
 517+ 4ED5              ; *******************************************************************************************************
 518+ 4ED5              ; same as SPRGRPMOV but for DEFUSR approach
 519+ 4ED5              ; input IX=pointer to input array, real data from +2
 520+ 4ED5              ; +2 = X
 521+ 4ED5              ; +4 = Y
 522+ 4ED5              ; +6 = count
 523+ 4ED5              ; +8 = data pointer
 524+ 4ED5              SPRGRPMOV_DEFUSR:
 525+ 4ED5 D9               EXX
 526+ 4ED6 DD 5E 02     	LD E,(IX+2)
 527+ 4ED9 DD 56 03     	LD D,(IX+3) ; initial x
 528+ 4EDC DD 4E 04     	LD C,(IX+4)
 529+ 4EDF DD 46 05     	LD B,(IX+5) ; initial y
 530+ 4EE2 D9               EXX
 531+ 4EE3 DD 6E 08     	LD L,(IX+8)
 532+ 4EE6 DD 66 09     	LD H,(IX+9) ; pointer to data
 533+ 4EE9 DD 46 06         LD B,(IX+6) ; count
 534+ 4EEC C3 BA 4E         JP SPR_UPDATE_LOC
 535+ 4EEF              ; *******************************************************************************************************
 536+ 4EEF               ENDIF
# file closed: asm\SPRITES.asm
 135  4EEF               ENDIF
 136  4EEF
 137  4EEF               IF (ANIM_CMDS == 1)
 138  4EEF               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4EEF              ; sprite animation routines
   2+ 4EEF
   3+ 4EEF              ; number of animation items and pointer
   4+ 4EEF              ANIMITEMNUM:
   5+ 4EEF 00            DB 0
   6+ 4EF0              ANIMITEMPTR:
   7+ 4EF0 EE 60         DW EXT_END
   8+ 4EF2              ; number of animation definitions and pointer
   9+ 4EF2              ANIMDEFNUM:
  10+ 4EF2 00            DB 0
  11+ 4EF3              ANIMDEFPTR:
  12+ 4EF3 EE 60         DW EXT_END
  13+ 4EF5              ; number of links between sprite and animation definitions
  14+ 4EF5              ANIMSPRNUM:
  15+ 4EF5 00            DB 0
  16+ 4EF6              ANIMSPRPTR:
  17+ 4EF6 EE 60         DW EXT_END
  18+ 4EF8              ; number of automatic sprite group move and animate structures
  19+ 4EF8              AUTOSGAMNUM:
  20+ 4EF8 00            DB 0
  21+ 4EF9              AUTOSGAMPTR:
  22+ 4EF9 EE 60         DW EXT_END
  23+ 4EFB
  24+ 4EFB              ; ANIMATION ITEM
  25+ 4EFB              ; byte type = [0 - pattern and color change
  26+ 4EFB              ;              1 - pattern definition change ]
  27+ 4EFB              ; word ticks - number of ticks to hold this state
  28+ 4EFB              ; for type = 0
  29+ 4EFB              ;   byte pattern;
  30+ 4EFB              ;   byte color;
  31+ 4EFB              ; for type = 1
  32+ 4EFB              ;   work data_pointer;
  33+ 4EFB              ; total size = 5b
  34+ 4EFB
  35+ 4EFB              ; ANIMATION DEFINITION
  36+ 4EFB              ; byte number of items 1-15
  37+ 4EFB              ; byte[15] anim_item;
  38+ 4EFB              ; total size = 16b
  39+ 4EFB
  40+ 4EFB              ; SPRITE/CHAR ANIMATION
  41+ 4EFB              ; +00 byte sprite/char number;
  42+ 4EFB              ; +01 word time;
  43+ 4EFB              ; +03 byte current item;
  44+ 4EFB              ; +04 byte animation definition;
  45+ 4EFB              ; +05 byte cyclic;
  46+ 4EFB              ; +06 byte active;
  47+ 4EFB              ; +07 byte 0=sprite, 1-3 character bank
  48+ 4EFB              ; total size = 8b
  49+ 4EFB
  50+ 4EFB              ; AUTOMATIC SPRITE GROUP MOVE AND ANIMATE structure
  51+ 4EFB              ; +00 pointer to X variable
  52+ 4EFB              ; +02 pointer to Y variable
  53+ 4EFB              ; +04 minimum value
  54+ 4EFB              ; +06 maximal value
  55+ 4EFB              ; +08 delta value
  56+ 4EFB              ; +10 direction 0=horizontal, <>0 = vertical
  57+ 4EFB              ; +11 sprite group size
  58+ 4EFB              ; +12 sprite group pointer
  59+ 4EFB              ; +14 animation list size
  60+ 4EFB              ; +15 animation list pointer for negative delta values
  61+ 4EFB              ; +17 animation list pointer for positive delta values
  62+ 4EFB              ; +19 active flag
  63+ 4EFB              ; +20 ticks for movement
  64+ 4EFB              ; +22 timer
  65+ 4EFB              ; total = 24b
  66+ 4EFB
  67+ 4EFB              ; *******************************************************************************************************
  68+ 4EFB              ; helper function HL=A*5
  69+ 4EFB              ; changes HL,DE
  70+ 4EFB              Ax5:
  71+ 4EFB 26 00            LD H,0
  72+ 4EFD 6F               LD L,A
  73+ 4EFE 54               LD D,H
  74+ 4EFF 5D               LD E,L
  75+ 4F00 29               ADD HL,HL
  76+ 4F01 29               ADD HL,HL
  77+ 4F02 19               ADD HL,DE
  78+ 4F03 C9               RET
  79+ 4F04              ; *******************************************************************************************************
  80+ 4F04
  81+ 4F04              ; *******************************************************************************************************
  82+ 4F04              ; helper function gets pointer to n-th animation item
  83+ 4F04              ; changes HL,DE
  84+ 4F04              GETnthANIMITEM:
  85+ 4F04 CD FB 4E         CALL Ax5
  86+ 4F07 ED 5B F0 4E      LD DE,(ANIMITEMPTR)
  87+ 4F0B 19               ADD HL,DE
  88+ 4F0C C9               RET
  89+ 4F0D              ; *******************************************************************************************************
  90+ 4F0D
  91+ 4F0D              ; *******************************************************************************************************
  92+ 4F0D              ; helper function gets pointer to n-th entry in animation definition
  93+ 4F0D              ; changes HL,DE
  94+ 4F0D              GETnthANIMDEF:
  95+ 4F0D 26 00            LD H,0
  96+ 4F0F 6F               LD L,A
  97+ 4F10 CD 73 5F         CALL HLx16
  98+ 4F13 ED 5B F3 4E      LD DE,(ANIMDEFPTR)
  99+ 4F17 19               ADD HL,DE
 100+ 4F18 C9               RET
 101+ 4F19              ; *******************************************************************************************************
 102+ 4F19
 103+ 4F19              ; *******************************************************************************************************
 104+ 4F19              ; helper function gets pointer to n-th entry in sprite animation
 105+ 4F19              ; changes HL,DE
 106+ 4F19              GETnthSPRANIM:
 107+ 4F19 26 00            LD H,0
 108+ 4F1B 6F               LD L,A
 109+ 4F1C CD 74 5F         CALL HLx8
 110+ 4F1F ED 5B F6 4E      LD DE,(ANIMSPRPTR)
 111+ 4F23 19               ADD HL,DE
 112+ 4F24 C9               RET
 113+ 4F25              ; *******************************************************************************************************
 114+ 4F25
 115+ 4F25              ; *******************************************************************************************************
 116+ 4F25              ; helper function gets pointer to n-th entry in autosgam table
 117+ 4F25              ; changes HL,DE
 118+ 4F25              GETnthAUTOSGAM:
 119+ 4F25 26 00            LD H,0
 120+ 4F27 6F               LD L,A
 121+ 4F28 CD 74 5F         CALL HLx8
 122+ 4F2B 54               LD D,H
 123+ 4F2C 5D               LD E,L
 124+ 4F2D 29               ADD HL,HL
 125+ 4F2E 19               ADD HL,DE
 126+ 4F2F ED 5B F9 4E      LD DE,(AUTOSGAMPTR)
 127+ 4F33 19               ADD HL,DE
 128+ 4F34 C9               RET
 129+ 4F35              ; *******************************************************************************************************
 130+ 4F35
 131+ 4F35               IF (1 == 1)
 132+ 4F35              ; *******************************************************************************************************
 133+ 4F35              ; same as MAXIANIMITEMS but for DEFUSR approach
 134+ 4F35              ; input IX=pointer to input array, real data from +2
 135+ 4F35              ; +2 = number
 136+ 4F35              MAXANIMITEMS_DEFUSR:
 137+ 4F35 DD 7E 02         LD A,(IX+2)
 138+ 4F38 18 00            JR MAXANIMITEMS.COMMON
 139+ 4F3A              ; *******************************************************************************************************
 140+ 4F3A               ENDIF
 141+ 4F3A
 142+ 4F3A              ; *******************************************************************************************************
 143+ 4F3A              ; function to handle CALL MAXANIMITEMS basic extension
 144+ 4F3A              ; MAXANIMITEMS (BYTE number)
 145+ 4F3A              ; sets new number and moves memory buffers as needed
 146+ 4F3A              MAXANIMITEMS:
 147+ 4F3A               IF (0 == 1)
 148+ 4F3A ~            	; opening (
 149+ 4F3A ~            	CALL CHKCHAR
 150+ 4F3A ~            	DB '('
 151+ 4F3A ~            	; get value
 152+ 4F3A ~            	LD IX, GETBYT
 153+ 4F3A ~            	CALL CALBAS
 154+ 4F3A ~                PUSH AF
 155+ 4F3A ~            	; ending )
 156+ 4F3A ~            	CALL CHKCHAR
 157+ 4F3A ~            	DB ')'
 158+ 4F3A ~                POP AF
 159+ 4F3A               ENDIF
 160+ 4F3A              .COMMON: ; entry for DEFUSR part, A=number
 161+ 4F3A F3               DI
 162+ 4F3B              	; save position
 163+ 4F3B E5           	PUSH HL
 164+ 4F3C              .ENTRY:
 165+ 4F3C 47               LD B,A
 166+ 4F3D 3A EF 4E         LD A,(ANIMITEMNUM)
 167+ 4F40 90               SUB B
 168+ 4F41 28 28            JR Z, .EXIT; same value as before
 169+ 4F43 FD 21 F3 4E      LD IY,ANIMDEFPTR
 170+ 4F47 FA 6E 4F         JP M, .INCREASE
 171+ 4F4A                  ; new value is lower than previous one
 172+ 4F4A CD 8D 4F         CALL .SIZEDIFF
 173+ 4F4D CD A8 4F         CALL .DECREASE_COMMON
 174+ 4F50 2A F6 4E         LD HL,(ANIMSPRPTR)
 175+ 4F53 AF               XOR A
 176+ 4F54 ED 42            SBC HL,BC
 177+ 4F56 22 F6 4E         LD (ANIMSPRPTR),HL
 178+ 4F59              .E1:
 179+ 4F59 2A F9 4E         LD HL,(AUTOSGAMPTR)
 180+ 4F5C AF               XOR A
 181+ 4F5D ED 42            SBC HL,BC
 182+ 4F5F 22 F9 4E         LD (AUTOSGAMPTR),HL
 183+ 4F62              .E3:
 184+ 4F62 2A 10 40         LD HL,(FREEMEMPTR)
 185+ 4F65 AF               XOR A
 186+ 4F66 ED 42            SBC HL,BC
 187+ 4F68 22 10 40         LD (FREEMEMPTR),HL
 188+ 4F6B              .EXIT:
 189+ 4F6B FB               EI
 190+ 4F6C E1           	POP HL
 191+ 4F6D C9           	RET
 192+ 4F6E              .INCREASE:
 193+ 4F6E ED 44            NEG
 194+ 4F70 CD 8D 4F         CALL .SIZEDIFF
 195+ 4F73 CD D4 4F         CALL .INCREASE_COMMON
 196+ 4F76 2A F6 4E         LD HL,(ANIMSPRPTR)
 197+ 4F79 09               ADD HL,BC
 198+ 4F7A 22 F6 4E         LD (ANIMSPRPTR),HL
 199+ 4F7D              .E2:
 200+ 4F7D 2A F9 4E         LD HL,(AUTOSGAMPTR)
 201+ 4F80 09               ADD HL,BC
 202+ 4F81 22 F9 4E         LD (AUTOSGAMPTR),HL
 203+ 4F84              .E4:
 204+ 4F84 2A 10 40         LD HL,(FREEMEMPTR)
 205+ 4F87 09               ADD HL,BC
 206+ 4F88 22 10 40         LD (FREEMEMPTR),HL
 207+ 4F8B 18 DE            JR .EXIT
 208+ 4F8D              .SIZEDIFF:
 209+ 4F8D CD FB 4E         CALL Ax5
 210+ 4F90 78               LD A,B
 211+ 4F91 32 EF 4E         LD (ANIMITEMNUM),A
 212+ 4F94 44               LD B,H
 213+ 4F95 4D               LD C,L
 214+ 4F96 C9               RET ; BC=size difference in bytes
 215+ 4F97              .SIZETOMOVE:
 216+ 4F97 D5               PUSH DE
 217+ 4F98 2A 10 40         LD HL,(FREEMEMPTR)
 218+ 4F9B FD 5E 00         LD E,(IY)
 219+ 4F9E FD 56 01         LD D,(IY+1)
 220+ 4FA1 AF               XOR A
 221+ 4FA2 ED 52            SBC HL,DE
 222+ 4FA4 44               LD B,H
 223+ 4FA5 4D               LD C,L
 224+ 4FA6 D1               POP DE
 225+ 4FA7 C9               RET
 226+ 4FA8              .DECREASE_COMMON:
 227+ 4FA8 FD 6E 00         LD L,(IY)
 228+ 4FAB FD 66 01         LD H,(IY+1)
 229+ 4FAE AF               XOR A
 230+ 4FAF ED 42            SBC HL,BC
 231+ 4FB1 EB               EX DE,HL
 232+ 4FB2 C5               PUSH BC
 233+ 4FB3 CD 97 4F         CALL .SIZETOMOVE
 234+ 4FB6 F3               DI
 235+ 4FB7 78               LD A,B
 236+ 4FB8 B1               OR C
 237+ 4FB9 28 08            JR Z,.L1
 238+ 4FBB FD 6E 00         LD L,(IY)
 239+ 4FBE FD 66 01         LD H,(IY+1)
 240+ 4FC1 ED B0            LDIR
 241+ 4FC3              .L1:
 242+ 4FC3 C1               POP BC
 243+ 4FC4 FD 6E 00         LD L,(IY)
 244+ 4FC7 FD 66 01         LD H,(IY+1)
 245+ 4FCA AF               XOR A
 246+ 4FCB ED 42            SBC HL,BC
 247+ 4FCD FD 75 00         LD (IY),L
 248+ 4FD0 FD 74 01         LD (IY+1),H
 249+ 4FD3 C9               RET
 250+ 4FD4              .INCREASE_COMMON:
 251+ 4FD4 2A 10 40         LD HL,(FREEMEMPTR)
 252+ 4FD7 2B               DEC HL
 253+ 4FD8 AF               XOR A
 254+ 4FD9 ED 42            SBC HL,BC
 255+ 4FDB EB               EX DE,HL
 256+ 4FDC C5               PUSH BC
 257+ 4FDD CD 97 4F         CALL .SIZETOMOVE
 258+ 4FE0 F3               DI
 259+ 4FE1 78               LD A,B
 260+ 4FE2 B1               OR C
 261+ 4FE3 28 06            JR Z,.L2
 262+ 4FE5 2A 10 40         LD HL,(FREEMEMPTR)
 263+ 4FE8 2B               DEC HL
 264+ 4FE9 ED B8            LDDR
 265+ 4FEB              .L2:
 266+ 4FEB C1               POP BC
 267+ 4FEC FD 6E 00         LD L,(IY)
 268+ 4FEF FD 66 01         LD H,(IY+1)
 269+ 4FF2 09               ADD HL,BC
 270+ 4FF3 FD 75 00         LD (IY),L
 271+ 4FF6 FD 74 01         LD (IY+1),H
 272+ 4FF9 C9               RET
 273+ 4FFA              ; *******************************************************************************************************
 274+ 4FFA
 275+ 4FFA               IF (0 == 1)
 276+ 4FFA ~            ; *******************************************************************************************************
 277+ 4FFA ~            ; function to handle CALL ANIMITEMPAT basic extension
 278+ 4FFA ~            ; ANIMITEMPAT ( BYTE id,
 279+ 4FFA ~            ;               INT ticks >0,
 280+ 4FFA ~            ;               BYTE pattern,
 281+ 4FFA ~            ;               BYTE color )
 282+ 4FFA ~            ; fills animation item data, returns an error if ID out of bounds
 283+ 4FFA ~            ANIMITEMPAT:
 284+ 4FFA ~                ; opening (
 285+ 4FFA ~            	CALL CHKCHAR
 286+ 4FFA ~            	DB '('
 287+ 4FFA ~            	; get id
 288+ 4FFA ~            	LD IX, GETBYT
 289+ 4FFA ~            	CALL CALBAS
 290+ 4FFA ~                PUSH AF
 291+ 4FFA ~                ; check if out of bounds
 292+ 4FFA ~                INC A
 293+ 4FFA ~                LD C,A
 294+ 4FFA ~                LD A,(ANIMITEMNUM)
 295+ 4FFA ~                CP C
 296+ 4FFA ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 297+ 4FFA ~            	; comma
 298+ 4FFA ~            	CALL CHKCHAR
 299+ 4FFA ~            	DB ','
 300+ 4FFA ~            	; get ticks
 301+ 4FFA ~            	LD IX, FRMQNT
 302+ 4FFA ~            	CALL CALBAS
 303+ 4FFA ~                LD A,D
 304+ 4FFA ~                OR E
 305+ 4FFA ~                JP Z, OVERFLOW
 306+ 4FFA ~            	PUSH DE
 307+ 4FFA ~            	; comma
 308+ 4FFA ~            	CALL CHKCHAR
 309+ 4FFA ~            	DB ','
 310+ 4FFA ~            	; get pattern
 311+ 4FFA ~            	LD IX, GETBYT
 312+ 4FFA ~            	CALL CALBAS
 313+ 4FFA ~                PUSH AF
 314+ 4FFA ~            	; comma
 315+ 4FFA ~            	CALL CHKCHAR
 316+ 4FFA ~            	DB ','
 317+ 4FFA ~            	; get color
 318+ 4FFA ~            	LD IX, GETBYT
 319+ 4FFA ~            	CALL CALBAS
 320+ 4FFA ~                PUSH AF
 321+ 4FFA ~            	; ending )
 322+ 4FFA ~            	CALL CHKCHAR
 323+ 4FFA ~            	DB ')'
 324+ 4FFA ~            .ENTRY:
 325+ 4FFA ~                PUSH HL
 326+ 4FFA ~                POP IX
 327+ 4FFA ~                EXX
 328+ 4FFA ~                POP BC ; color
 329+ 4FFA ~                POP DE ; pattern
 330+ 4FFA ~                POP HL ; ticks
 331+ 4FFA ~                EXX
 332+ 4FFA ~                POP AF
 333+ 4FFA ~                CALL GETnthANIMITEM
 334+ 4FFA ~                PUSH HL
 335+ 4FFA ~                POP IY
 336+ 4FFA ~                EXX
 337+ 4FFA ~                LD (IY),0 ; type=0
 338+ 4FFA ~                LD (IY+1),L
 339+ 4FFA ~                LD (IY+2),H
 340+ 4FFA ~                LD (IY+3),D
 341+ 4FFA ~                LD (IY+4),B
 342+ 4FFA ~
 343+ 4FFA ~                PUSH IX
 344+ 4FFA ~                POP HL
 345+ 4FFA ~                RET
 346+ 4FFA ~            ; *******************************************************************************************************
 347+ 4FFA               ENDIF
 348+ 4FFA
 349+ 4FFA               IF (1 == 1)
 350+ 4FFA              ; *******************************************************************************************************
 351+ 4FFA              ; same as ANIMITEMPAT but for DEFUSR approach
 352+ 4FFA              ; input IX=pointer to input array, real data from +2
 353+ 4FFA              ; +02 = ID
 354+ 4FFA              ; +04 = ticks
 355+ 4FFA              ; +06 = pattern
 356+ 4FFA              ; +08 = color
 357+ 4FFA              ANIMITEMPAT_DEFUSR:
 358+ 4FFA                  ; check if out of bounds
 359+ 4FFA DD 4E 02         LD C,(IX+2)
 360+ 4FFD 0C               INC C
 361+ 4FFE 3A EF 4E         LD A,(ANIMITEMNUM)
 362+ 5001 B9               CP C
 363+ 5002 D8               RET C ; out of bounds, prevent memory corruption
 364+ 5003 79               LD A,C
 365+ 5004 3D               DEC A
 366+ 5005 CD 04 4F         CALL GETnthANIMITEM
 367+ 5008 36 00            LD (HL),0 ; type=0
 368+ 500A 23               INC HL
 369+ 500B DD 7E 04         LD A,(IX+4) ; ticks low
 370+ 500E 77               LD (HL),A
 371+ 500F 23               INC HL
 372+ 5010 DD 7E 05         LD A,(IX+5) ; ticks high
 373+ 5013 77               LD (HL),A
 374+ 5014 23               INC HL
 375+ 5015 DD 7E 06         LD A,(IX+6) ; pattern
 376+ 5018 77               LD (HL),A
 377+ 5019 23               INC HL
 378+ 501A DD 7E 08         LD A,(IX+8) ; color
 379+ 501D 77               LD (HL),A
 380+ 501E C9               RET
 381+ 501F              ; *******************************************************************************************************
 382+ 501F               ENDIF
 383+ 501F
 384+ 501F               IF (0 == 1)
 385+ 501F ~            ; *******************************************************************************************************
 386+ 501F ~            ; function to handle CALL ANIMITEMPTR basic extension
 387+ 501F ~            ; ANIMITEMPTR ( BYTE id,
 388+ 501F ~            ;               INT ticks,
 389+ 501F ~            ;               INT pointer,
 390+ 501F ~            ; fills animation item data, returns an error if ID out of bounds
 391+ 501F ~            ANIMITEMPTR_CMD:
 392+ 501F ~                ; opening (
 393+ 501F ~            	CALL CHKCHAR
 394+ 501F ~            	DB '('
 395+ 501F ~            	; get id
 396+ 501F ~            	LD IX, GETBYT
 397+ 501F ~            	CALL CALBAS
 398+ 501F ~                PUSH AF
 399+ 501F ~                ; check if out of bounds
 400+ 501F ~                INC A
 401+ 501F ~                LD C,A
 402+ 501F ~                LD A,(ANIMITEMNUM)
 403+ 501F ~                CP C
 404+ 501F ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 405+ 501F ~            	; comma
 406+ 501F ~            	CALL CHKCHAR
 407+ 501F ~            	DB ','
 408+ 501F ~            	; get ticks
 409+ 501F ~            	LD IX, FRMQNT
 410+ 501F ~            	CALL CALBAS
 411+ 501F ~                LD A,D
 412+ 501F ~                OR E
 413+ 501F ~                JP Z,OVERFLOW
 414+ 501F ~            	PUSH DE
 415+ 501F ~            	; comma
 416+ 501F ~            	CALL CHKCHAR
 417+ 501F ~            	DB ','
 418+ 501F ~            	; get pointer
 419+ 501F ~            	LD IX, FRMQNT
 420+ 501F ~            	CALL CALBAS
 421+ 501F ~            	PUSH DE
 422+ 501F ~            	; ending )
 423+ 501F ~            	CALL CHKCHAR
 424+ 501F ~            	DB ')'
 425+ 501F ~            .ENTRY:
 426+ 501F ~                PUSH HL
 427+ 501F ~                POP IX
 428+ 501F ~                EXX
 429+ 501F ~                POP DE ; pointer
 430+ 501F ~                POP HL ; ticks
 431+ 501F ~                EXX
 432+ 501F ~                POP AF
 433+ 501F ~                CALL GETnthANIMITEM
 434+ 501F ~                PUSH HL
 435+ 501F ~                POP IY
 436+ 501F ~                EXX
 437+ 501F ~                LD (IY),1 ; type=1
 438+ 501F ~                LD (IY+1),L
 439+ 501F ~                LD (IY+2),H
 440+ 501F ~                LD (IY+3),E
 441+ 501F ~                LD (IY+4),D
 442+ 501F ~
 443+ 501F ~                PUSH IX
 444+ 501F ~                POP HL
 445+ 501F ~                RET
 446+ 501F ~            ; *******************************************************************************************************
 447+ 501F               ENDIF
 448+ 501F
 449+ 501F               IF (1 == 1)
 450+ 501F              ; *******************************************************************************************************
 451+ 501F              ; same as ANIMITEMPTR but for DEFUSR approach
 452+ 501F              ; input IX=pointer to input array, real data from +2
 453+ 501F              ; +02 = ID
 454+ 501F              ; +04 = ticks
 455+ 501F              ; +06 = pointer
 456+ 501F              ANIMITEMPTR_DEFUSR:
 457+ 501F                  ; check if out of bounds
 458+ 501F DD 4E 02         LD C,(IX+2)
 459+ 5022 0C               INC C
 460+ 5023 3A EF 4E         LD A,(ANIMITEMNUM)
 461+ 5026 B9               CP C
 462+ 5027 D8               RET C ; out of bounds, prevent memory corruption
 463+ 5028 79               LD A,C
 464+ 5029 3D               DEC A
 465+ 502A CD 04 4F         CALL GETnthANIMITEM
 466+ 502D 36 01            LD (HL),1 ; type=1
 467+ 502F 23               INC HL
 468+ 5030 DD 7E 04         LD A,(IX+4) ; ticks low
 469+ 5033 77               LD (HL),A
 470+ 5034 23               INC HL
 471+ 5035 DD 7E 05         LD A,(IX+5) ; ticks high
 472+ 5038 77               LD (HL),A
 473+ 5039 23               INC HL
 474+ 503A DD 7E 06         LD A,(IX+6) ; pointer low
 475+ 503D 77               LD (HL),A
 476+ 503E 23               INC HL
 477+ 503F DD 7E 07         LD A,(IX+7) ; pointer high
 478+ 5042 77               LD (HL),A
 479+ 5043 C9               RET
 480+ 5044              ; *******************************************************************************************************
 481+ 5044               ENDIF
 482+ 5044
 483+ 5044               IF (1 == 1)
 484+ 5044              ; *******************************************************************************************************
 485+ 5044              ; same as MAXANIMDEFS but for DEFUSR approach
 486+ 5044              ; input IX=pointer to input array, real data from +2
 487+ 5044              ; +2 = number
 488+ 5044              MAXANIMDEFS_DEFUSR:
 489+ 5044 DD 7E 02         LD A,(IX+2)
 490+ 5047 18 00            JR MAXANIMDEFS.COMMON
 491+ 5049              ; *******************************************************************************************************
 492+ 5049               ENDIF
 493+ 5049
 494+ 5049              ; *******************************************************************************************************
 495+ 5049              ; function to handle CALL MAXANIMDEFS basic extension
 496+ 5049              ; MAXANIMDEFS (BYTE number)
 497+ 5049              ; sets new number and moves memory buffers as needed
 498+ 5049              MAXANIMDEFS:
 499+ 5049               IF (0 == 1)
 500+ 5049 ~            	; opening (
 501+ 5049 ~            	CALL CHKCHAR
 502+ 5049 ~            	DB '('
 503+ 5049 ~            	; get value
 504+ 5049 ~            	LD IX, GETBYT
 505+ 5049 ~            	CALL CALBAS
 506+ 5049 ~                PUSH AF
 507+ 5049 ~            	; ending )
 508+ 5049 ~            	CALL CHKCHAR
 509+ 5049 ~            	DB ')'
 510+ 5049 ~                POP AF
 511+ 5049               ENDIF
 512+ 5049              .COMMON:
 513+ 5049 F3               DI
 514+ 504A              	; save position
 515+ 504A E5           	PUSH HL
 516+ 504B              .ENTRY:
 517+ 504B 47               LD B,A
 518+ 504C 3A F2 4E         LD A,(ANIMDEFNUM)
 519+ 504F 90               SUB B
 520+ 5050 CA 6B 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 521+ 5053 FD 21 F6 4E      LD IY,ANIMSPRPTR
 522+ 5057 FA 63 50         JP M, .INCREASE
 523+ 505A                  ; new value is lower than previous one
 524+ 505A CD 6E 50         CALL .SIZEDIFF
 525+ 505D CD A8 4F         CALL MAXANIMITEMS.DECREASE_COMMON
 526+ 5060 C3 59 4F         JP MAXANIMITEMS.E1
 527+ 5063              .INCREASE:
 528+ 5063 ED 44            NEG
 529+ 5065 CD 6E 50         CALL .SIZEDIFF
 530+ 5068 CD D4 4F         CALL MAXANIMITEMS.INCREASE_COMMON
 531+ 506B C3 7D 4F         JP MAXANIMITEMS.E2
 532+ 506E              .SIZEDIFF:
 533+ 506E 26 00            LD H,0
 534+ 5070 6F               LD L,A
 535+ 5071 CD 73 5F         CALL HLx16
 536+ 5074 78               LD A,B
 537+ 5075 32 F2 4E         LD (ANIMDEFNUM),A
 538+ 5078 44               LD B,H
 539+ 5079 4D               LD C,L
 540+ 507A C9               RET ; BC=size difference in bytes
 541+ 507B              ; *******************************************************************************************************
 542+ 507B
 543+ 507B               IF (0 == 1)
 544+ 507B ~            ; *******************************************************************************************************
 545+ 507B ~            ; function to handle CALL ANIMDEF basic extension
 546+ 507B ~            ; ANIMITEMPAT ( BYTE id,
 547+ 507B ~            ;               BYTE size,
 548+ 507B ~            ;               INT[] list )
 549+ 507B ~            ; fills animation definition data, returns an error if out of bounds, or invalid type
 550+ 507B ~            ANIMDEF:
 551+ 507B ~                ; opening (
 552+ 507B ~            	CALL CHKCHAR
 553+ 507B ~            	DB '('
 554+ 507B ~            	; get id
 555+ 507B ~            	LD IX, GETBYT
 556+ 507B ~            	CALL CALBAS
 557+ 507B ~                PUSH AF
 558+ 507B ~                ; check if out of bounds
 559+ 507B ~                INC A
 560+ 507B ~                LD C,A
 561+ 507B ~                LD A,(ANIMDEFNUM)
 562+ 507B ~                CP C
 563+ 507B ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 564+ 507B ~            	; comma
 565+ 507B ~            	CALL CHKCHAR
 566+ 507B ~            	DB ','
 567+ 507B ~            	; get size
 568+ 507B ~            	LD IX, GETBYT
 569+ 507B ~            	CALL CALBAS
 570+ 507B ~                CP 16
 571+ 507B ~                JP NC, OVERFLOW
 572+ 507B ~                OR A
 573+ 507B ~                JP Z, OVERFLOW
 574+ 507B ~            	PUSH AF
 575+ 507B ~            	; comma
 576+ 507B ~            	CALL CHKCHAR
 577+ 507B ~            	DB ','
 578+ 507B ~            	; get pointer to a list of animation items in integer array format
 579+ 507B ~                ; get array pointer
 580+ 507B ~                POP DE
 581+ 507B ~                PUSH DE
 582+ 507B ~                LD A,2
 583+ 507B ~                LD B,1
 584+ 507B ~                CALL GET_BASIC_ARRAY_DATA_POINTER
 585+ 507B ~                PUSH BC
 586+ 507B ~            	; ending )
 587+ 507B ~            	CALL CHKCHAR
 588+ 507B ~            	DB ')'
 589+ 507B ~            .ENTRY:
 590+ 507B ~                PUSH HL
 591+ 507B ~                POP IX
 592+ 507B ~                POP DE ; pointer to INT array
 593+ 507B ~                POP BC ; B=item number
 594+ 507B ~                POP AF ; id
 595+ 507B ~                PUSH DE
 596+ 507B ~                CALL GETnthANIMDEF
 597+ 507B ~                POP DE
 598+ 507B ~                LD (HL),B
 599+ 507B ~            .L1:
 600+ 507B ~                INC HL
 601+ 507B ~                LD A,(DE)
 602+ 507B ~                .2 INC DE
 603+ 507B ~                LD (HL),A
 604+ 507B ~                DJNZ .L1
 605+ 507B ~                PUSH IX
 606+ 507B ~                POP HL
 607+ 507B ~                RET
 608+ 507B ~            ; *******************************************************************************************************
 609+ 507B               ENDIF
 610+ 507B
 611+ 507B               IF (1 == 1)
 612+ 507B              ; *******************************************************************************************************
 613+ 507B              ; same as ANIMDEF but for DEFUSR approach
 614+ 507B              ; input IX=pointer to input array, real data from +2
 615+ 507B              ; +02 = ID
 616+ 507B              ; +04 = list size
 617+ 507B              ; +06 = list pointer
 618+ 507B              ANIMDEF_DEFUSR:
 619+ 507B                  ; check if out of bounds
 620+ 507B DD 4E 02         LD C,(IX+2)
 621+ 507E 0C               INC C
 622+ 507F 3A F2 4E         LD A,(ANIMDEFNUM)
 623+ 5082 B9               CP C
 624+ 5083 D8               RET C ; invalid id
 625+ 5084              	; get size
 626+ 5084 DD 7E 04         LD A,(IX+4)
 627+ 5087 FE 10            CP 16
 628+ 5089 D0               RET NC ; overflow
 629+ 508A B7               OR A
 630+ 508B C8               RET Z ; ID=0, invalid
 631+ 508C 47               LD B,A
 632+ 508D 79               LD A,C
 633+ 508E 3D               DEC A
 634+ 508F CD 0D 4F         CALL GETnthANIMDEF
 635+ 5092 70               LD (HL),B
 636+ 5093 DD 5E 06         LD E,(IX+6)
 637+ 5096 DD 56 07         LD D,(IX+7)
 638+ 5099              .L1:
 639+ 5099 23               INC HL
 640+ 509A 1A               LD A,(DE)
 641+ 509B 13          > INC DE
 641+ 509C 13          > INC DE
 642+ 509D 77               LD (HL),A
 643+ 509E 10 F9            DJNZ .L1
 644+ 50A0 C9               RET
 645+ 50A1              ; *******************************************************************************************************
 646+ 50A1               ENDIF
 647+ 50A1
 648+ 50A1               IF (1 == 1)
 649+ 50A1              ; *******************************************************************************************************
 650+ 50A1              ; same as MAXANIMSPRS but for DEFUSR approach
 651+ 50A1              ; input IX=pointer to input array, real data from +2
 652+ 50A1              ; +2 = number
 653+ 50A1              MAXANIMSPRS_DEFUSR:
 654+ 50A1 DD 7E 02         LD A,(IX+2)
 655+ 50A4 18 00            JR MAXANIMSPRS.COMMON
 656+ 50A6              ; *******************************************************************************************************
 657+ 50A6               ENDIF
 658+ 50A6
 659+ 50A6              ; *******************************************************************************************************
 660+ 50A6              ; function to handle CALL MAXANIMSPRS basic extension
 661+ 50A6              ; MAXANIMSPRS (BYTE number)
 662+ 50A6              ; sets new number and moves memory buffers as needed
 663+ 50A6              MAXANIMSPRS:
 664+ 50A6               IF (0 == 1)
 665+ 50A6 ~            	; opening (
 666+ 50A6 ~            	CALL CHKCHAR
 667+ 50A6 ~            	DB '('
 668+ 50A6 ~            	; get value
 669+ 50A6 ~            	LD IX, GETBYT
 670+ 50A6 ~            	CALL CALBAS
 671+ 50A6 ~                PUSH AF
 672+ 50A6 ~            	; ending )
 673+ 50A6 ~            	CALL CHKCHAR
 674+ 50A6 ~            	DB ')'
 675+ 50A6 ~                POP AF
 676+ 50A6               ENDIF
 677+ 50A6              .COMMON:
 678+ 50A6 F3               DI
 679+ 50A7              	; save position
 680+ 50A7 E5           	PUSH HL
 681+ 50A8              .ENTRY:
 682+ 50A8 47               LD B,A
 683+ 50A9 3A F5 4E         LD A,(ANIMSPRNUM)
 684+ 50AC 90               SUB B
 685+ 50AD CA 6B 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 686+ 50B0 FD 21 F9 4E      LD IY,AUTOSGAMPTR
 687+ 50B4 FA C0 50         JP M, .INCREASE
 688+ 50B7                  ; new value is lower than previous one
 689+ 50B7 CD E1 50         CALL .SIZEDIFF
 690+ 50BA CD A8 4F         CALL MAXANIMITEMS.DECREASE_COMMON
 691+ 50BD C3 62 4F         JP MAXANIMITEMS.E3
 692+ 50C0              .INCREASE:
 693+ 50C0 ED 44            NEG
 694+ 50C2 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 695+ 50C3 CD E1 50         CALL .SIZEDIFF
 696+ 50C6 CD D4 4F         CALL MAXANIMITEMS.INCREASE_COMMON
 697+ 50C9 AF               XOR A
 698+ 50CA ED 42            SBC HL,BC ; location of new stuff
 699+ 50CC F1               POP AF
 700+ 50CD C5               PUSH BC
 701+ 50CE 47               LD B,A
 702+ 50CF 11 08 00         LD DE,8
 703+ 50D2 E5               PUSH HL
 704+ 50D3 DD E1            POP IX
 705+ 50D5              .L1:
 706+ 50D5 DD 36 06 00      LD (IX+6),0 ; active flag
 707+ 50D9 DD 19            ADD IX,DE
 708+ 50DB 10 F8            DJNZ .L1
 709+ 50DD C1               POP BC
 710+ 50DE C3 84 4F         JP MAXANIMITEMS.E4
 711+ 50E1              .SIZEDIFF:
 712+ 50E1 26 00            LD H,0
 713+ 50E3 6F               LD L,A
 714+ 50E4 CD 74 5F         CALL HLx8
 715+ 50E7 78               LD A,B
 716+ 50E8 32 F5 4E         LD (ANIMSPRNUM),A
 717+ 50EB 44               LD B,H
 718+ 50EC 4D               LD C,L
 719+ 50ED C9               RET ; BC=size difference in bytes
 720+ 50EE              ; *******************************************************************************************************
 721+ 50EE
 722+ 50EE               IF (0 == 1)
 723+ 50EE ~            ; *******************************************************************************************************
 724+ 50EE ~            ; function to handle CALL ANIMSPRITE basic extension
 725+ 50EE ~            ; ANIMSPRITE ( BYTE id,
 726+ 50EE ~            ;              BYTE sprite_number,
 727+ 50EE ~            ;              BYTE animation_definition_id,
 728+ 50EE ~            ;              BYTE cyclic_flag )
 729+ 50EE ~            ; fills sprite animation data, returns an error if out of bounds, or invalid type
 730+ 50EE ~            ANIMSPRITE:
 731+ 50EE ~                ; opening (
 732+ 50EE ~            	CALL CHKCHAR
 733+ 50EE ~            	DB '('
 734+ 50EE ~            	; get sprite animation id
 735+ 50EE ~            	LD IX, GETBYT
 736+ 50EE ~            	CALL CALBAS
 737+ 50EE ~                PUSH AF
 738+ 50EE ~                INC A
 739+ 50EE ~                LD C,A
 740+ 50EE ~                LD A,(ANIMSPRNUM)
 741+ 50EE ~                CP C
 742+ 50EE ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 743+ 50EE ~            	; comma
 744+ 50EE ~            	CALL CHKCHAR
 745+ 50EE ~            	DB ','
 746+ 50EE ~            	; get sprite number
 747+ 50EE ~            	LD IX, GETBYT
 748+ 50EE ~            	CALL CALBAS
 749+ 50EE ~                PUSH AF
 750+ 50EE ~                ; check if out of bounds
 751+ 50EE ~                CP 32
 752+ 50EE ~                JP NC, SUBSCRIPT_OUT_OF_RANGE
 753+ 50EE ~            	; comma
 754+ 50EE ~            	CALL CHKCHAR
 755+ 50EE ~            	DB ','
 756+ 50EE ~            	; get animation definition id
 757+ 50EE ~            	LD IX, GETBYT
 758+ 50EE ~            	CALL CALBAS
 759+ 50EE ~                PUSH AF
 760+ 50EE ~                INC A
 761+ 50EE ~                LD C,A
 762+ 50EE ~                LD A,(ANIMDEFNUM)
 763+ 50EE ~                CP C
 764+ 50EE ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 765+ 50EE ~            	; comma
 766+ 50EE ~            	CALL CHKCHAR
 767+ 50EE ~            	DB ','
 768+ 50EE ~            	; get cyclic flag
 769+ 50EE ~            	LD IX, GETBYT
 770+ 50EE ~                CALL CALBAS
 771+ 50EE ~            	PUSH AF
 772+ 50EE ~            	; ending )
 773+ 50EE ~            	CALL CHKCHAR
 774+ 50EE ~            	DB ')'
 775+ 50EE ~            .ENTRY:
 776+ 50EE ~                PUSH HL
 777+ 50EE ~                POP IX
 778+ 50EE ~                EXX
 779+ 50EE ~                POP DE ; cyclic
 780+ 50EE ~                POP BC ; animation definition id
 781+ 50EE ~                POP HL ; sprite number
 782+ 50EE ~                EXX
 783+ 50EE ~                POP AF ; sprite animation id
 784+ 50EE ~                CALL GETnthSPRANIM
 785+ 50EE ~                PUSH HL
 786+ 50EE ~                POP IY
 787+ 50EE ~                EXX
 788+ 50EE ~                LD (IY),H
 789+ 50EE ~                LD (IY+4),B
 790+ 50EE ~                LD (IY+5),D
 791+ 50EE ~                ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 792+ 50EE ~                ; following will do preparation for ANIMSTEP situation
 793+ 50EE ~                ; current item set to above limit and timer to 1
 794+ 50EE ~                ; any call to ANIMSTEP will switch and setup to first item for cyclic
 795+ 50EE ~                LD (IY+3),255
 796+ 50EE ~                LD (IY+1),1
 797+ 50EE ~                LD (IY+2),0
 798+ 50EE ~                ; mark as sprite animation
 799+ 50EE ~                LD (IY+7),0
 800+ 50EE ~                PUSH IX
 801+ 50EE ~                POP HL
 802+ 50EE ~                RET
 803+ 50EE ~            ; *******************************************************************************************************
 804+ 50EE               ENDIF
 805+ 50EE
 806+ 50EE               IF (1 == 1)
 807+ 50EE              ; *******************************************************************************************************
 808+ 50EE              ; same as ANIMSPRITE but for DEFUSR approach
 809+ 50EE              ; input IX=pointer to input array, real data from +2
 810+ 50EE              ; +02 = ID
 811+ 50EE              ; +04 = sprite number
 812+ 50EE              ; +06 = animation definition id
 813+ 50EE              ; +08 = cyclic flag
 814+ 50EE              ANIMSPRITE_DEFUSR:
 815+ 50EE DD 4E 02         LD C,(IX+2)
 816+ 50F1 0C               INC C
 817+ 50F2 3A F5 4E         LD A,(ANIMSPRNUM)
 818+ 50F5 B9               CP C
 819+ 50F6 D8               RET C ; invalid id
 820+ 50F7              	; get sprite number
 821+ 50F7 DD 7E 04         LD A,(IX+4)
 822+ 50FA FE 20            CP 32
 823+ 50FC D0               RET NC ; invalid sprite id
 824+ 50FD DD 46 06         LD B,(IX+6)
 825+ 5100 04               INC B
 826+ 5101 3A F2 4E         LD A,(ANIMDEFNUM)
 827+ 5104 B8               CP B
 828+ 5105 D8               RET C ; invalid animation definition id
 829+ 5106 79               LD A,C
 830+ 5107 3D               DEC A
 831+ 5108 CD 19 4F         CALL GETnthSPRANIM
 832+ 510B DD 7E 04         LD A,(IX+4)
 833+ 510E 77               LD (HL),A ; +0
 834+ 510F 23               INC HL
 835+ 5110 36 01            LD (HL),1 ; +1
 836+ 5112 23               INC HL
 837+ 5113 36 00            LD (HL),0 ; +2
 838+ 5115 23               INC HL
 839+ 5116 36 FF            LD (HL),255 ; +3
 840+ 5118 23               INC HL
 841+ 5119 05               DEC B
 842+ 511A 70               LD (HL),B ; +4
 843+ 511B 23               INC HL
 844+ 511C DD 7E 08         LD A,(IX+8) ; +5
 845+ 511F 77               LD (HL),A
 846+ 5120 23               INC HL
 847+ 5121 23               INC HL
 848+ 5122 36 00            LD (HL),0 ; +7
 849+ 5124 C9               RET
 850+ 5125              ; *******************************************************************************************************
 851+ 5125               ENDIF
 852+ 5125
 853+ 5125
 854+ 5125               IF (0 == 1)
 855+ 5125 ~            ; *******************************************************************************************************
 856+ 5125 ~            ; function to handle CALL ANIMCHAR basic extension
 857+ 5125 ~            ; ANIMCHAR ( BYTE id,
 858+ 5125 ~            ;            INT character number 0-767,
 859+ 5125 ~            ;            BYTE animation_definition_id,
 860+ 5125 ~            ;            BYTE cyclic_flag )
 861+ 5125 ~            ; fills sprite animation data, returns an error if out of bounds, or invalid type
 862+ 5125 ~            ANIMCHAR:
 863+ 5125 ~                ; opening (
 864+ 5125 ~            	CALL CHKCHAR
 865+ 5125 ~            	DB '('
 866+ 5125 ~            	; get sprite animation id
 867+ 5125 ~            	LD IX, GETBYT
 868+ 5125 ~            	CALL CALBAS
 869+ 5125 ~                PUSH AF
 870+ 5125 ~                INC A
 871+ 5125 ~                LD C,A
 872+ 5125 ~                LD A,(ANIMSPRNUM)
 873+ 5125 ~                CP C
 874+ 5125 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 875+ 5125 ~            	; comma
 876+ 5125 ~            	CALL CHKCHAR
 877+ 5125 ~            	DB ','
 878+ 5125 ~            	; get character number
 879+ 5125 ~            	LD IX, FRMQNT
 880+ 5125 ~            	CALL CALBAS
 881+ 5125 ~                PUSH DE
 882+ 5125 ~                ; check if out of bounds
 883+ 5125 ~                LD A,D
 884+ 5125 ~                CP 3
 885+ 5125 ~                JP NC, SUBSCRIPT_OUT_OF_RANGE
 886+ 5125 ~            	; comma
 887+ 5125 ~            	CALL CHKCHAR
 888+ 5125 ~            	DB ','
 889+ 5125 ~            	; get animation definition id
 890+ 5125 ~            	LD IX, GETBYT
 891+ 5125 ~            	CALL CALBAS
 892+ 5125 ~                PUSH AF
 893+ 5125 ~                INC A
 894+ 5125 ~                LD C,A
 895+ 5125 ~                LD A,(ANIMDEFNUM)
 896+ 5125 ~                CP C
 897+ 5125 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 898+ 5125 ~            	; comma
 899+ 5125 ~            	CALL CHKCHAR
 900+ 5125 ~            	DB ','
 901+ 5125 ~            	; get cyclic flag
 902+ 5125 ~            	LD IX, GETBYT
 903+ 5125 ~                CALL CALBAS
 904+ 5125 ~            	PUSH AF
 905+ 5125 ~            	; ending )
 906+ 5125 ~            	CALL CHKCHAR
 907+ 5125 ~            	DB ')'
 908+ 5125 ~            .ENTRY:
 909+ 5125 ~                PUSH HL
 910+ 5125 ~                POP IX
 911+ 5125 ~                EXX
 912+ 5125 ~                POP DE ; cyclic
 913+ 5125 ~                POP BC ; animation definition id
 914+ 5125 ~                POP HL ; character number
 915+ 5125 ~                EXX
 916+ 5125 ~                POP AF ; sprite animation id
 917+ 5125 ~                CALL GETnthSPRANIM
 918+ 5125 ~                PUSH HL
 919+ 5125 ~                POP IY
 920+ 5125 ~                EXX
 921+ 5125 ~                LD (IY),L
 922+ 5125 ~                INC H ; save character bank+1
 923+ 5125 ~                LD (IY+7),H
 924+ 5125 ~                LD (IY+4),B
 925+ 5125 ~                LD (IY+5),D
 926+ 5125 ~                ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 927+ 5125 ~                ; following will do preparation for ANIMSTEP situation
 928+ 5125 ~                ; current item set to above limit and timer to 1
 929+ 5125 ~                ; any call to ANIMSTEP will switch and setup to first item for cyclic
 930+ 5125 ~                LD (IY+3),255
 931+ 5125 ~                LD (IY+1),1
 932+ 5125 ~                LD (IY+2),0
 933+ 5125 ~                PUSH IX
 934+ 5125 ~                POP HL
 935+ 5125 ~                RET
 936+ 5125 ~            ; *******************************************************************************************************
 937+ 5125               ENDIF
 938+ 5125
 939+ 5125               IF (1 == 1)
 940+ 5125              ; *******************************************************************************************************
 941+ 5125              ; same as ANIMCHAR but for DEFUSR approach
 942+ 5125              ; input IX=pointer to input array, real data from +2
 943+ 5125              ; +02 = ID
 944+ 5125              ; +04 = character number
 945+ 5125              ; +06 = animation definition id
 946+ 5125              ; +08 = cyclic flag
 947+ 5125              ANIMCHAR_DEFUSR:
 948+ 5125 DD 4E 02         LD C,(IX+2)
 949+ 5128 0C               INC C
 950+ 5129 3A F5 4E         LD A,(ANIMSPRNUM)
 951+ 512C B9               CP C
 952+ 512D D8               RET C ; invalid id
 953+ 512E              	; get sprite number
 954+ 512E DD 7E 05         LD A,(IX+5)
 955+ 5131 FE 03            CP 3
 956+ 5133 D0               RET NC ; invalid character (>767)
 957+ 5134 DD 46 06         LD B,(IX+6)
 958+ 5137 04               INC B
 959+ 5138 3A F2 4E         LD A,(ANIMDEFNUM)
 960+ 513B B8               CP B
 961+ 513C D8               RET C ; invalid animation definition id
 962+ 513D 79               LD A,C
 963+ 513E 3D               DEC A
 964+ 513F CD 19 4F         CALL GETnthSPRANIM
 965+ 5142 DD 7E 04         LD A,(IX+4)
 966+ 5145 77               LD (HL),A ; +0
 967+ 5146 23               INC HL
 968+ 5147 36 01            LD (HL),1 ; +1
 969+ 5149 23               INC HL
 970+ 514A 36 00            LD (HL),0 ; +2
 971+ 514C 23               INC HL
 972+ 514D 36 FF            LD (HL),255 ; +3
 973+ 514F 23               INC HL
 974+ 5150 05               DEC B
 975+ 5151 70               LD (HL),B ; +4
 976+ 5152 23               INC HL
 977+ 5153 DD 7E 08         LD A,(IX+8) ; +5
 978+ 5156 77               LD (HL),A
 979+ 5157 23               INC HL
 980+ 5158 23               INC HL
 981+ 5159 DD 7E 05         LD A,(IX+5)
 982+ 515C 3C               INC A
 983+ 515D 77               LD (HL),A ; +7
 984+ 515E C9               RET
 985+ 515F              ; *******************************************************************************************************
 986+ 515F               ENDIF
 987+ 515F
 988+ 515F               IF (1 == 1)
 989+ 515F              ; *******************************************************************************************************
 990+ 515F              ; same as MAXAUTOSGAMS but for DEFUSR approach
 991+ 515F              ; input IX=pointer to input array, real data from +2
 992+ 515F              ; +2 = number
 993+ 515F              MAXAUTOSGAMS_DEFUSR:
 994+ 515F DD 7E 02         LD A,(IX+2)
 995+ 5162 18 00            JR MAXAUTOSGAMS.COMMON
 996+ 5164              ; *******************************************************************************************************
 997+ 5164               ENDIF
 998+ 5164
 999+ 5164              ; *******************************************************************************************************
1000+ 5164              ; function to handle CALL MAXAUTOSGAMS basic extension
1001+ 5164              ; MAXAUTOSGAMS (BYTE number)
1002+ 5164              ; sets new number and moves memory buffers as needed
1003+ 5164              MAXAUTOSGAMS:
1004+ 5164               IF (0 == 1)
1005+ 5164 ~            	; opening (
1006+ 5164 ~            	CALL CHKCHAR
1007+ 5164 ~            	DB '('
1008+ 5164 ~            	; get value
1009+ 5164 ~            	LD IX, GETBYT
1010+ 5164 ~            	CALL CALBAS
1011+ 5164 ~                PUSH AF
1012+ 5164 ~            	; ending )
1013+ 5164 ~            	CALL CHKCHAR
1014+ 5164 ~            	DB ')'
1015+ 5164 ~                POP AF
1016+ 5164               ENDIF
1017+ 5164              .COMMON:
1018+ 5164 F3               DI
1019+ 5165              	; save position
1020+ 5165 E5           	PUSH HL
1021+ 5166              .ENTRY:
1022+ 5166 47               LD B,A
1023+ 5167 3A F8 4E         LD A,(AUTOSGAMNUM)
1024+ 516A 90               SUB B
1025+ 516B CA 6B 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
1026+ 516E FD 21 10 40      LD IY,FREEMEMPTR
1027+ 5172 FA 7E 51         JP M, .INCREASE
1028+ 5175                  ; new value is lower than previous one
1029+ 5175 CD 9F 51         CALL .SIZEDIFF
1030+ 5178 CD A8 4F         CALL MAXANIMITEMS.DECREASE_COMMON
1031+ 517B C3 6B 4F         JP MAXANIMITEMS.EXIT
1032+ 517E              .INCREASE:
1033+ 517E ED 44            NEG
1034+ 5180 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
1035+ 5181 CD 9F 51         CALL .SIZEDIFF
1036+ 5184 CD D4 4F         CALL MAXANIMITEMS.INCREASE_COMMON
1037+ 5187 AF               XOR A
1038+ 5188 ED 42            SBC HL,BC ; location of new stuff
1039+ 518A F1               POP AF
1040+ 518B C5               PUSH BC
1041+ 518C 47               LD B,A
1042+ 518D 11 18 00         LD DE,24
1043+ 5190 E5               PUSH HL
1044+ 5191 DD E1            POP IX
1045+ 5193              .L1:
1046+ 5193 DD 36 13 00      LD (IX+19),0 ; active flag
1047+ 5197 DD 19            ADD IX,DE
1048+ 5199 10 F8            DJNZ .L1
1049+ 519B C1               POP BC
1050+ 519C C3 6B 4F         JP MAXANIMITEMS.EXIT
1051+ 519F              .SIZEDIFF:
1052+ 519F 26 00            LD H,0
1053+ 51A1 6F               LD L,A
1054+ 51A2 CD 74 5F         CALL HLx8
1055+ 51A5 54               LD D,H
1056+ 51A6 5D               LD E,L
1057+ 51A7 29               ADD HL,HL
1058+ 51A8 19               ADD HL,DE
1059+ 51A9 78               LD A,B
1060+ 51AA 32 F8 4E         LD (AUTOSGAMNUM),A
1061+ 51AD 44               LD B,H
1062+ 51AE 4D               LD C,L
1063+ 51AF C9               RET ; BC=size difference in bytes
1064+ 51B0              ; *******************************************************************************************************
1065+ 51B0
1066+ 51B0               IF (0 == 1)
1067+ 51B0 ~            ; *******************************************************************************************************
1068+ 51B0 ~            ; function to handle CALL AUTOSGAMDEF basic extension
1069+ 51B0 ~            ; AUTOSGAMDEF ( BYTE id,
1070+ 51B0 ~            ;               INT VARIABLE x, INT VARIABLE y,
1071+ 51B0 ~            ;               INT minimum, INT maximum, INT delta,
1072+ 51B0 ~            ;               INT direction =0 horizontal,
1073+ 51B0 ~            ;               INT ticks,
1074+ 51B0 ~            ;               BYTE sprite_group_count,
1075+ 51B0 ~            ;               INT[2][sprite_group_count] VARIABLE sprite_group,
1076+ 51B0 ~            ;               BYTE item_number,
1077+ 51B0 ~            ;               INT[] VARIABLE sprite_animations_negative_direction,
1078+ 51B0 ~            ;               INT[] VARIABLE sprite_animations_positive_direction
1079+ 51B0 ~            AUTOSGAMDEF:
1080+ 51B0 ~                ; opening (
1081+ 51B0 ~            	CALL CHKCHAR
1082+ 51B0 ~            	DB '('
1083+ 51B0 ~            	; get sprite animation id
1084+ 51B0 ~            	LD IX, GETBYT
1085+ 51B0 ~            	CALL CALBAS
1086+ 51B0 ~                PUSH AF
1087+ 51B0 ~                INC A
1088+ 51B0 ~                LD C,A
1089+ 51B0 ~                LD A,(AUTOSGAMNUM)
1090+ 51B0 ~                CP C
1091+ 51B0 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
1092+ 51B0 ~                POP AF
1093+ 51B0 ~                PUSH HL
1094+ 51B0 ~                CALL GETnthAUTOSGAM
1095+ 51B0 ~                LD (BLIT_TMP),HL ; for later
1096+ 51B0 ~                POP HL
1097+ 51B0 ~            	; comma
1098+ 51B0 ~            	CALL CHKCHAR
1099+ 51B0 ~            	DB ','
1100+ 51B0 ~            	; get address of the X coordinate variable
1101+ 51B0 ~            	LD IX, PTRGET
1102+ 51B0 ~            	CALL CALBAS
1103+ 51B0 ~            	LD IX,(BLIT_TMP)
1104+ 51B0 ~                LD (IX+0),E
1105+ 51B0 ~                LD (IX+1),D
1106+ 51B0 ~            	; comma
1107+ 51B0 ~            	CALL CHKCHAR
1108+ 51B0 ~            	DB ','
1109+ 51B0 ~            	; get address of the Y coordinate variable
1110+ 51B0 ~            	LD IX, PTRGET
1111+ 51B0 ~            	CALL CALBAS
1112+ 51B0 ~            	LD IX,(BLIT_TMP)
1113+ 51B0 ~                LD (IX+2),E
1114+ 51B0 ~                LD (IX+3),D
1115+ 51B0 ~            	; comma
1116+ 51B0 ~            	CALL CHKCHAR
1117+ 51B0 ~            	DB ','
1118+ 51B0 ~            	; get minimum value
1119+ 51B0 ~            	LD IX, FRMQNT
1120+ 51B0 ~            	CALL CALBAS
1121+ 51B0 ~            	LD IX,(BLIT_TMP)
1122+ 51B0 ~                LD (IX+4),E
1123+ 51B0 ~                LD (IX+5),D
1124+ 51B0 ~            	; comma
1125+ 51B0 ~            	CALL CHKCHAR
1126+ 51B0 ~            	DB ','
1127+ 51B0 ~            	; get maximum value
1128+ 51B0 ~            	LD IX, FRMQNT
1129+ 51B0 ~            	CALL CALBAS
1130+ 51B0 ~            	LD IX,(BLIT_TMP)
1131+ 51B0 ~                LD (IX+6),E
1132+ 51B0 ~                LD (IX+7),D
1133+ 51B0 ~            	; comma
1134+ 51B0 ~            	CALL CHKCHAR
1135+ 51B0 ~            	DB ','
1136+ 51B0 ~            	; get delta value
1137+ 51B0 ~            	LD IX, FRMQNT
1138+ 51B0 ~            	CALL CALBAS
1139+ 51B0 ~            	LD IX,(BLIT_TMP)
1140+ 51B0 ~                LD (IX+8),E
1141+ 51B0 ~                LD (IX+9),D
1142+ 51B0 ~            	; comma
1143+ 51B0 ~            	CALL CHKCHAR
1144+ 51B0 ~            	DB ','
1145+ 51B0 ~            	; get direction value
1146+ 51B0 ~            	LD IX, FRMQNT
1147+ 51B0 ~            	CALL CALBAS
1148+ 51B0 ~            	LD IX,(BLIT_TMP)
1149+ 51B0 ~                LD (IX+10),E
1150+ 51B0 ~            	; comma
1151+ 51B0 ~            	CALL CHKCHAR
1152+ 51B0 ~            	DB ','
1153+ 51B0 ~            	; get ticks value
1154+ 51B0 ~            	LD IX, FRMQNT
1155+ 51B0 ~            	CALL CALBAS
1156+ 51B0 ~            	LD IX,(BLIT_TMP)
1157+ 51B0 ~                LD (IX+20),E
1158+ 51B0 ~                LD (IX+21),D
1159+ 51B0 ~            	; comma
1160+ 51B0 ~            	CALL CHKCHAR
1161+ 51B0 ~            	DB ','
1162+ 51B0 ~            	; get sprite group count
1163+ 51B0 ~            	LD IX, GETBYT
1164+ 51B0 ~            	CALL CALBAS
1165+ 51B0 ~                OR A
1166+ 51B0 ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
1167+ 51B0 ~            	LD IX,(BLIT_TMP)
1168+ 51B0 ~                LD (IX+11),A
1169+ 51B0 ~            	; comma
1170+ 51B0 ~            	CALL CHKCHAR
1171+ 51B0 ~            	DB ','
1172+ 51B0 ~            	; get sprite group definition array data pointer
1173+ 51B0 ~            	LD IX,(BLIT_TMP)
1174+ 51B0 ~                LD E,(IX+11)
1175+ 51B0 ~            	LD D,3
1176+ 51B0 ~            	LD A,2
1177+ 51B0 ~            	LD B,A
1178+ 51B0 ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
1179+ 51B0 ~            	LD IX,(BLIT_TMP)
1180+ 51B0 ~            	LD (IX+12),C
1181+ 51B0 ~                LD (IX+13),B
1182+ 51B0 ~            	; comma
1183+ 51B0 ~            	CALL CHKCHAR
1184+ 51B0 ~            	DB ','
1185+ 51B0 ~            	; get sprite animation array size
1186+ 51B0 ~            	LD IX,GETBYT
1187+ 51B0 ~            	CALL CALBAS
1188+ 51B0 ~            	LD IX,(BLIT_TMP)
1189+ 51B0 ~                LD (IX+14),A
1190+ 51B0 ~                OR A
1191+ 51B0 ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
1192+ 51B0 ~            	; comma
1193+ 51B0 ~            	CALL CHKCHAR
1194+ 51B0 ~            	DB ','
1195+ 51B0 ~                ; get array pointer for negative direction
1196+ 51B0 ~            	LD IX,(BLIT_TMP)
1197+ 51B0 ~                LD D,(IX+14)
1198+ 51B0 ~                LD A,2
1199+ 51B0 ~                LD B,1
1200+ 51B0 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
1201+ 51B0 ~            	LD IX,(BLIT_TMP)
1202+ 51B0 ~                LD (IX+15),C
1203+ 51B0 ~                LD (IX+16),B
1204+ 51B0 ~            	; comma
1205+ 51B0 ~            	CALL CHKCHAR
1206+ 51B0 ~            	DB ','
1207+ 51B0 ~                ; get array pointer for positive direction
1208+ 51B0 ~            	LD IX,(BLIT_TMP)
1209+ 51B0 ~                LD D,(IX+14)
1210+ 51B0 ~                LD A,2
1211+ 51B0 ~                LD B,1
1212+ 51B0 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
1213+ 51B0 ~            	LD IX,(BLIT_TMP)
1214+ 51B0 ~                LD (IX+17),C
1215+ 51B0 ~                LD (IX+18),B
1216+ 51B0 ~            	; ending )
1217+ 51B0 ~            	CALL CHKCHAR
1218+ 51B0 ~            	DB ')'
1219+ 51B0 ~                RET
1220+ 51B0 ~            ; *******************************************************************************************************
1221+ 51B0               ENDIF
1222+ 51B0
1223+ 51B0               IF (1 == 1)
1224+ 51B0              ; *******************************************************************************************************
1225+ 51B0              ; same as AUTOSGAMDEF but for DEFUSR approach
1226+ 51B0              ; input IX=pointer to input array, real data from +2
1227+ 51B0              ; +02 = ID
1228+ 51B0              ; +04 = pointer to X variable
1229+ 51B0              ; +06 = pointer to Y variable
1230+ 51B0              ; +08 = minimum
1231+ 51B0              ; +10 = maximum
1232+ 51B0              ; +12 = delta
1233+ 51B0              ; +14 = direction
1234+ 51B0              ; +16 = ticks
1235+ 51B0              ; +18 = sprite group count
1236+ 51B0              ; +20 = sprite group array pointer
1237+ 51B0              ; +22 = item number
1238+ 51B0              ; +24 = sprite animations negative direction array pointer
1239+ 51B0              ; +26 = sprite animations positive direction array pointer
1240+ 51B0              AUTOSGAMDEF_DEFUSR:
1241+ 51B0 DD 4E 02         LD C,(IX+2)
1242+ 51B3 0C               INC C
1243+ 51B4 3A F8 4E         LD A,(AUTOSGAMNUM)
1244+ 51B7 B9               CP C
1245+ 51B8 D8               RET C ; invalid id
1246+ 51B9 79               LD A,C
1247+ 51BA 3D               DEC A
1248+ 51BB CD 25 4F         CALL GETnthAUTOSGAM
1249+ 51BE E5               PUSH HL
1250+ 51BF FD E1            POP IY
1251+ 51C1                  ; X variable
1252+ 51C1 DD 7E 04         LD A,(IX+4)
1253+ 51C4 FD 77 00         LD (IY+0),A
1254+ 51C7 DD 7E 05         LD A,(IX+5)
1255+ 51CA FD 77 01         LD (IY+1),A
1256+ 51CD              	; Y variable
1257+ 51CD DD 7E 06         LD A,(IX+6)
1258+ 51D0 FD 77 02         LD (IY+2),A
1259+ 51D3 DD 7E 07         LD A,(IX+7)
1260+ 51D6 FD 77 03         LD (IY+3),A
1261+ 51D9              	; get minimum value
1262+ 51D9 DD 7E 08         LD A,(IX+8)
1263+ 51DC FD 77 04         LD (IY+4),A
1264+ 51DF DD 7E 09         LD A,(IX+9)
1265+ 51E2 FD 77 05         LD (IY+5),A
1266+ 51E5              	; get maximum value
1267+ 51E5 DD 7E 0A         LD A,(IX+10)
1268+ 51E8 FD 77 06         LD (IY+6),A
1269+ 51EB DD 7E 0B         LD A,(IX+11)
1270+ 51EE FD 77 07         LD (IY+7),A
1271+ 51F1              	; get delta value
1272+ 51F1 DD 7E 0C         LD A,(IX+12)
1273+ 51F4 FD 77 08         LD (IY+8),A
1274+ 51F7 DD 7E 0D         LD A,(IX+13)
1275+ 51FA FD 77 09         LD (IY+9),A
1276+ 51FD              	; get direction value
1277+ 51FD DD 7E 0E         LD A,(IX+14)
1278+ 5200 FD 77 0A         LD (IY+10),A
1279+ 5203              	; get ticks value
1280+ 5203 DD 7E 10         LD A,(IX+16)
1281+ 5206 FD 77 14         LD (IY+20),A
1282+ 5209 DD 7E 11         LD A,(IX+17)
1283+ 520C FD 77 15         LD (IY+21),A
1284+ 520F              	; get sprite group count
1285+ 520F DD 7E 12         LD A,(IX+18)
1286+ 5212 FD 77 0B         LD (IY+11),A
1287+ 5215              	; get sprite group definition array data pointer
1288+ 5215 DD 7E 14         LD A,(IX+20)
1289+ 5218 FD 77 0C         LD (IY+12),A
1290+ 521B DD 7E 15         LD A,(IX+21)
1291+ 521E FD 77 0D         LD (IY+13),A
1292+ 5221              	; get sprite animation array size
1293+ 5221 DD 7E 16         LD A,(IX+22)
1294+ 5224 FD 77 0E         LD (IY+14),A
1295+ 5227                  ; get array pointer for negative direction
1296+ 5227 DD 7E 18         LD A,(IX+24)
1297+ 522A FD 77 0F         LD (IY+15),A
1298+ 522D DD 7E 19         LD A,(IX+25)
1299+ 5230 FD 77 10         LD (IY+16),A
1300+ 5233                  ; get array pointer for positive direction
1301+ 5233 DD 7E 1A         LD A,(IX+26)
1302+ 5236 FD 77 11         LD (IY+17),A
1303+ 5239 DD 7E 1B         LD A,(IX+27)
1304+ 523C FD 77 12         LD (IY+18),A
1305+ 523F C9               RET
1306+ 5240              ; *******************************************************************************************************
1307+ 5240               ENDIF
1308+ 5240
1309+ 5240               IF (0 == 1)
1310+ 5240 ~            ; *******************************************************************************************************
1311+ 5240 ~            ; function to handle CALL AUTOSGAMSTART basic extension
1312+ 5240 ~            ; AUTOSGAMSTART ( BYTE id )
1313+ 5240 ~            AUTOSGAMSTART:
1314+ 5240 ~                LD A,1
1315+ 5240 ~            .COMMON:
1316+ 5240 ~                LD (.SETVALUE+3),A
1317+ 5240 ~                ; opening (
1318+ 5240 ~            	CALL CHKCHAR
1319+ 5240 ~            	DB '('
1320+ 5240 ~            	; get sprite animation id
1321+ 5240 ~            	LD IX, GETBYT
1322+ 5240 ~            	CALL CALBAS
1323+ 5240 ~                PUSH AF
1324+ 5240 ~                INC A
1325+ 5240 ~                LD C,A
1326+ 5240 ~                LD A,(AUTOSGAMNUM)
1327+ 5240 ~                CP C
1328+ 5240 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
1329+ 5240 ~                POP AF
1330+ 5240 ~                PUSH HL
1331+ 5240 ~                CALL GETnthAUTOSGAM
1332+ 5240 ~                PUSH HL
1333+ 5240 ~                POP IX
1334+ 5240 ~                POP HL
1335+ 5240 ~                PUSH IX
1336+ 5240 ~            	; ending )
1337+ 5240 ~            	CALL CHKCHAR
1338+ 5240 ~            	DB ')'
1339+ 5240 ~
1340+ 5240 ~                ; so syntax is fine
1341+ 5240 ~                POP IX
1342+ 5240 ~            .SETVALUE:
1343+ 5240 ~                LD (IX+19),1 ; active flag
1344+ 5240 ~                ; set initial timer
1345+ 5240 ~                LD A,(IX+20)
1346+ 5240 ~                LD (IX+22),A
1347+ 5240 ~                LD A,(IX+21)
1348+ 5240 ~                LD (IX+23),A
1349+ 5240 ~                RET
1350+ 5240 ~            ; *******************************************************************************************************
1351+ 5240 ~
1352+ 5240 ~            ; *******************************************************************************************************
1353+ 5240 ~            ; function to handle CALL AUTOSGAMSTOP basic extension
1354+ 5240 ~            ; AUTOSGAMSTOP ( BYTE id )
1355+ 5240 ~            AUTOSGAMSTOP:
1356+ 5240 ~                XOR A
1357+ 5240 ~                JR AUTOSGAMSTART.COMMON
1358+ 5240 ~            ; *******************************************************************************************************
1359+ 5240               ENDIF
1360+ 5240
1361+ 5240               IF (1 == 1)
1362+ 5240              ; *******************************************************************************************************
1363+ 5240              ; function to handle CALL AUTOSGAMSTART basic extension in DEFUSR mode
1364+ 5240              ; input IX=pointer to input array, real data from +2
1365+ 5240              ; +2 = source address
1366+ 5240              AUTOSGAMSTART_DEFUSR:
1367+ 5240 3E 01            LD A,1
1368+ 5242              .COMMON:
1369+ 5242 32 59 52         LD (.SETVALUE+3),A
1370+ 5245 DD 4E 02         LD C,(IX+2)
1371+ 5248 0C               INC C
1372+ 5249 3A F8 4E         LD A,(AUTOSGAMNUM)
1373+ 524C B9               CP C
1374+ 524D D8               RET C ; invalid id
1375+ 524E 79               LD A,C
1376+ 524F 3D               DEC A
1377+ 5250 CD 25 4F         CALL GETnthAUTOSGAM
1378+ 5253 E5               PUSH HL
1379+ 5254 DD E1            POP IX
1380+ 5256              .SETVALUE:
1381+ 5256 DD 36 13 01      LD (IX+19),1 ; active flag
1382+ 525A                  ; set initial timer
1383+ 525A DD 7E 14         LD A,(IX+20)
1384+ 525D DD 77 16         LD (IX+22),A
1385+ 5260 DD 7E 15         LD A,(IX+21)
1386+ 5263 DD 77 17         LD (IX+23),A
1387+ 5266 C9               RET
1388+ 5267              ; *******************************************************************************************************
1389+ 5267
1390+ 5267              ; *******************************************************************************************************
1391+ 5267              ; function to handle CALL AUTOSGAMSTOP basic extension in DEFUSR mode
1392+ 5267              ; input IX=pointer to input array, real data from +2
1393+ 5267              ; +2 = source address
1394+ 5267              AUTOSGAMSTOP_DEFUSR:
1395+ 5267 AF               XOR A
1396+ 5268 18 D8            JR AUTOSGAMSTART_DEFUSR.COMMON
1397+ 526A              ; *******************************************************************************************************
1398+ 526A               ENDIF
1399+ 526A
1400+ 526A               IF (0 == 1)
1401+ 526A ~            ; *******************************************************************************************************
1402+ 526A ~            ; function to handle CALL ANIMSTEP basic extension
1403+ 526A ~            ; two forms
1404+ 526A ~            ; ANIMSTEP ( BYTE id )
1405+ 526A ~            ; or
1406+ 526A ~            ; ANIMSTEP ( BYTE item_number,
1407+ 526A ~            ;            INT[] sprite_animations )
1408+ 526A ~            ANIMSTEP:
1409+ 526A ~                LD DE,ANIMSTARTSTOP_COMMON.STEP
1410+ 526A ~                JR ANIMSTARTSTOP_COMMON
1411+ 526A ~            ; *******************************************************************************************************
1412+ 526A ~            ; *******************************************************************************************************
1413+ 526A ~            ; function to handle CALL ANIMSTART basic extension
1414+ 526A ~            ; two forms
1415+ 526A ~            ; ANIMSTART ( BYTE id )
1416+ 526A ~            ; or
1417+ 526A ~            ; ANIMSTART ( BYTE item_number,
1418+ 526A ~            ;             INT[] sprite_animations )
1419+ 526A ~            ; sets active flag to 1
1420+ 526A ~            ANIMSTART:
1421+ 526A ~                LD DE,ANIMSTARTSTOP_COMMON.START
1422+ 526A ~                JR ANIMSTARTSTOP_COMMON
1423+ 526A ~            ; *******************************************************************************************************
1424+ 526A ~            ; *******************************************************************************************************
1425+ 526A ~            ; function to handle CALL ANIMSTOP basic extension
1426+ 526A ~            ; two forms
1427+ 526A ~            ; ANIMSTOP ( BYTE id )
1428+ 526A ~            ; or
1429+ 526A ~            ; ANIMSTOP ( BYTE item_number,
1430+ 526A ~            ;            INT[] sprite_animations )
1431+ 526A ~            ; sets active flag to 0
1432+ 526A ~            ANIMSTOP:
1433+ 526A ~                LD DE,ANIMSTARTSTOP_COMMON.STOP
1434+ 526A ~            ; *******************************************************************************************************
1435+ 526A ~            ANIMSTARTSTOP_COMMON:
1436+ 526A ~                LD (ANIMSTARTSTOP_COMMON.FN+1),DE
1437+ 526A ~                ; opening (
1438+ 526A ~            	CALL CHKCHAR
1439+ 526A ~            	DB '('
1440+ 526A ~            	; get sprite animation id or array size
1441+ 526A ~            	LD IX,GETBYT
1442+ 526A ~            	CALL CALBAS
1443+ 526A ~                PUSH AF
1444+ 526A ~                ; check if comma present
1445+ 526A ~                CALL GETPREVCHAR
1446+ 526A ~                INC HL
1447+ 526A ~                CP ','
1448+ 526A ~                JR Z,.L1
1449+ 526A ~                CP ')'
1450+ 526A ~                JP NZ,SYNTAX_ERROR
1451+ 526A ~                ; ok so single argument variant
1452+ 526A ~                POP AF
1453+ 526A ~                PUSH HL
1454+ 526A ~                DI
1455+ 526A ~                CALL .SETVALUE
1456+ 526A ~                EI
1457+ 526A ~                POP HL
1458+ 526A ~                RET
1459+ 526A ~            .L1:
1460+ 526A ~                ; get array pointer
1461+ 526A ~                POP DE
1462+ 526A ~                PUSH DE
1463+ 526A ~                LD A,2
1464+ 526A ~                LD B,1
1465+ 526A ~                CALL GET_BASIC_ARRAY_DATA_POINTER
1466+ 526A ~                PUSH BC
1467+ 526A ~            	; ending )
1468+ 526A ~            	CALL CHKCHAR
1469+ 526A ~            	DB ')'
1470+ 526A ~                POP DE ; array pointer
1471+ 526A ~                POP BC ; number of items
1472+ 526A ~                LD A,B
1473+ 526A ~                OR A
1474+ 526A ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
1475+ 526A ~                PUSH HL
1476+ 526A ~                DI
1477+ 526A ~            .L2:
1478+ 526A ~                PUSH BC
1479+ 526A ~                LD A,(DE)
1480+ 526A ~                .2 INC DE
1481+ 526A ~                PUSH DE
1482+ 526A ~                CALL .SETVALUE
1483+ 526A ~                POP DE
1484+ 526A ~                POP BC
1485+ 526A ~                DJNZ .L2
1486+ 526A ~                EI
1487+ 526A ~                POP HL
1488+ 526A ~                RET
1489+ 526A ~
1490+ 526A ~            .SETVALUE:
1491+ 526A ~                LD B,A
1492+ 526A ~                INC A
1493+ 526A ~                LD C,A
1494+ 526A ~                LD A,(ANIMSPRNUM)
1495+ 526A ~                CP C
1496+ 526A ~                JP C,SUBSCRIPT_OUT_OF_RANGE
1497+ 526A ~                LD A,B
1498+ 526A ~                CALL GETnthSPRANIM
1499+ 526A ~                PUSH HL
1500+ 526A ~                POP IX
1501+ 526A ~            .FN:
1502+ 526A ~                JP 0
1503+ 526A ~            .START:
1504+ 526A ~                LD (IX+6),1 ; active flag
1505+ 526A ~                LD (IX+3),0 ; current item
1506+ 526A ~                LD B,0 ; setup timer
1507+ 526A ~                JP SETUP_ANIM_STEP
1508+ 526A ~            .STOP:
1509+ 526A ~                LD (IX+6),0 ; active flag
1510+ 526A ~                RET
1511+ 526A ~            .STEP:
1512+ 526A ~                LD B,0
1513+ 526A ~                JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1514+ 526A ~            ; *******************************************************************************************************
1515+ 526A               ENDIF
1516+ 526A
1517+ 526A              ; *******************************************************************************************************
1518+ 526A              ; helper function to locate single animation and execute operation
1519+ 526A              ; needs to have jump set to a correct function
1520+ 526A              ; used by SGAM helper routines so always needed
1521+ 526A              ; input A=animation item
1522+ 526A              ANIM_SETVALUE:
1523+ 526A 47               LD B,A
1524+ 526B 3C               INC A
1525+ 526C 4F               LD C,A
1526+ 526D 3A F5 4E         LD A,(ANIMSPRNUM)
1527+ 5270 B9               CP C
1528+ 5271 D8               RET C ; out of range, so do nothing
1529+ 5272 78               LD A,B
1530+ 5273 CD 19 4F         CALL GETnthSPRANIM
1531+ 5276 E5               PUSH HL
1532+ 5277 DD E1            POP IX
1533+ 5279              .FN:
1534+ 5279 C3 00 00         JP 0
1535+ 527C              ; *******************************************************************************************************
1536+ 527C
1537+ 527C               IF (1 == 1)
1538+ 527C              ; *******************************************************************************************************
1539+ 527C              ; helper function to set values of multiple animations
1540+ 527C              ; needs to have jump set to a correct function
1541+ 527C              ; input B=number of animation item
1542+ 527C              ; input DE=animation item array
1543+ 527C              ANIM_LIST_SETVALUE:
1544+ 527C F3               DI
1545+ 527D C5               PUSH BC
1546+ 527E 1A               LD A,(DE)
1547+ 527F 13          > INC DE
1547+ 5280 13          > INC DE
1548+ 5281 D5               PUSH DE
1549+ 5282 CD 6A 52         CALL ANIM_SETVALUE
1550+ 5285 D1               POP DE
1551+ 5286 C1               POP BC
1552+ 5287 10 F3            DJNZ ANIM_LIST_SETVALUE
1553+ 5289 FB               EI
1554+ 528A C9               RET
1555+ 528B              ; *******************************************************************************************************
1556+ 528B
1557+ 528B              ; *******************************************************************************************************
1558+ 528B              ; function to handle single item ANIMSTEP in DEFUSR mode
1559+ 528B              ; input IX=pointer to input array, real data from +2
1560+ 528B              ; +2 = animation id
1561+ 528B              ANIMSTEP_SINGLE_DEFUSR:
1562+ 528B 21 96 52         LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1563+ 528E              .L1:
1564+ 528E 22 7A 52         LD (ANIM_SETVALUE.FN+1),HL
1565+ 5291 DD 7E 02         LD A,(IX+2)
1566+ 5294 18 D4            JR ANIM_SETVALUE
1567+ 5296              .STEP:
1568+ 5296 06 00            LD B,0
1569+ 5298 C3 F0 52         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1570+ 529B              ; *******************************************************************************************************
1571+ 529B
1572+ 529B              ; *******************************************************************************************************
1573+ 529B              ; function to handle multi item ANIMSTEP in DEFUSR mode
1574+ 529B              ; input IX=pointer to input array, real data from +2
1575+ 529B              ; +2 = list size
1576+ 529B              ; +4 = array pointer holding items
1577+ 529B              ANIMSTEP_MULTI_DEFUSR:
1578+ 529B 21 96 52         LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1579+ 529E              .L1:
1580+ 529E 22 7A 52         LD (ANIM_SETVALUE.FN+1),HL
1581+ 52A1 DD 46 02         LD B,(IX+2)
1582+ 52A4 DD 5E 04         LD E,(IX+4)
1583+ 52A7 DD 56 05         LD D,(IX+5)
1584+ 52AA 18 D0            JR ANIM_LIST_SETVALUE
1585+ 52AC              ; *******************************************************************************************************
1586+ 52AC
1587+ 52AC              ; *******************************************************************************************************
1588+ 52AC              ; function to handle single item ANIMSTART in DEFUSR mode
1589+ 52AC              ; input IX=pointer to input array, real data from +2
1590+ 52AC              ; +2 = animation id
1591+ 52AC              ANIMSTART_SINGLE_DEFUSR:
1592+ 52AC 21 B1 52         LD HL,ANIMSTART_SINGLE_DEFUSR.START
1593+ 52AF 18 DD            JR ANIMSTEP_SINGLE_DEFUSR.L1
1594+ 52B1              .START:
1595+ 52B1 DD 36 06 01      LD (IX+6),1 ; active flag
1596+ 52B5 DD 36 03 00      LD (IX+3),0 ; current item
1597+ 52B9 06 00            LD B,0 ; setup timer
1598+ 52BB C3 4C 53         JP SETUP_ANIM_STEP
1599+ 52BE              ; *******************************************************************************************************
1600+ 52BE
1601+ 52BE              ; *******************************************************************************************************
1602+ 52BE              ; function to handle multi item ANIMSTART in DEFUSR mode
1603+ 52BE              ; input IX=pointer to input array, real data from +2
1604+ 52BE              ; +2 = list size
1605+ 52BE              ; +4 = array pointer holding items
1606+ 52BE              ANIMSTART_MULTI_DEFUSR:
1607+ 52BE 21 B1 52         LD HL,ANIMSTART_SINGLE_DEFUSR.START
1608+ 52C1 18 DB            JR ANIMSTEP_MULTI_DEFUSR.L1
1609+ 52C3              ; *******************************************************************************************************
1610+ 52C3
1611+ 52C3              ; *******************************************************************************************************
1612+ 52C3              ; function to handle single item ANIMSTOP in DEFUSR mode
1613+ 52C3              ; input IX=pointer to input array, real data from +2
1614+ 52C3              ; +2 = animation id
1615+ 52C3              ANIMSTOP_SINGLE_DEFUSR:
1616+ 52C3 21 C8 52         LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1617+ 52C6 18 C6            JR ANIMSTEP_SINGLE_DEFUSR.L1
1618+ 52C8              .STOP:
1619+ 52C8 DD 36 06 00      LD (IX+6),0 ; active flag
1620+ 52CC C9               RET
1621+ 52CD              ; *******************************************************************************************************
1622+ 52CD
1623+ 52CD              ; *******************************************************************************************************
1624+ 52CD              ; function to handle multi item ANIMSTOP in DEFUSR mode
1625+ 52CD              ; input IX=pointer to input array, real data from +2
1626+ 52CD              ; +2 = list size
1627+ 52CD              ; +4 = array pointer holding items
1628+ 52CD              ANIMSTOP_MULTI_DEFUSR:
1629+ 52CD 21 C8 52         LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1630+ 52D0 18 CC            JR ANIMSTEP_MULTI_DEFUSR.L1
1631+ 52D2              ; *******************************************************************************************************
1632+ 52D2               ENDIF
1633+ 52D2
1634+ 52D2              ; *******************************************************************************************************
1635+ 52D2              ; function processes animations during vblank period
1636+ 52D2              PROCESS_ANIMATIONS:
1637+ 52D2 3A F5 4E         LD A,(ANIMSPRNUM)
1638+ 52D5 B7               OR A
1639+ 52D6 C8               RET Z; no animations defined
1640+ 52D7 47               LD B,A
1641+ 52D8 DD 2A F6 4E      LD IX,(ANIMSPRPTR)
1642+ 52DC              .L1:
1643+ 52DC C5               PUSH BC
1644+ 52DD 06 00            LD B,0 ; normal mode, change on timer expiry only
1645+ 52DF CD EB 52         CALL PROCESS_SINGLE_ANIMATION
1646+ 52E2 11 08 00         LD DE,8
1647+ 52E5 DD 19            ADD IX,DE
1648+ 52E7 C1               POP BC
1649+ 52E8 10 F2            DJNZ .L1
1650+ 52EA C9               RET
1651+ 52EB              ; *******************************************************************************************************
1652+ 52EB
1653+ 52EB              ; *******************************************************************************************************
1654+ 52EB              ; processes single sprite animation
1655+ 52EB              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
1656+ 52EB              ; on timer expiry goes to next animation item
1657+ 52EB              ; input IX=sprite animation pointer
1658+ 52EB              ; input B=1 force mode, activate animation action regardless of expired timer
1659+ 52EB              PROCESS_SINGLE_ANIMATION:
1660+ 52EB DD 7E 06         LD A,(IX+6); active
1661+ 52EE B7               OR A
1662+ 52EF C8               RET Z ; inactive animation
1663+ 52F0              .INACTIVE_TOO:
1664+ 52F0 DD 6E 01         LD L,(IX+1)
1665+ 52F3 DD 66 02         LD H,(IX+2) ; HL=end time
1666+ 52F6 2B               DEC HL
1667+ 52F7 DD 75 01         LD (IX+1),L
1668+ 52FA DD 74 02         LD (IX+2),H
1669+ 52FD 7D               LD A,L
1670+ 52FE B4               OR H
1671+ 52FF 28 06            JR Z,.STEP
1672+ 5301 05               DEC B
1673+ 5302 04               INC B
1674+ 5303 C8               RET Z ; not forced mode, return
1675+ 5304 C3 4C 53         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
1676+ 5307              .STEP:
1677+ 5307 06 00            LD B,0; setup timer
1678+ 5309 DD 34 03         INC (IX+3) ; current animation item
1679+ 530C C3 4C 53         JP SETUP_ANIM_STEP
1680+ 530F              ; *******************************************************************************************************
1681+ 530F
1682+ 530F              ; *******************************************************************************************************
1683+ 530F              ; function will setup sprite animation after current item change
1684+ 530F              ; input A=current animation definition
1685+ 530F              ; input IX=pointer to sprite animation
1686+ 530F              ; input B=1 skip timer setup
1687+ 530F              ; output IY=pointer to animation item
1688+ 530F              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
1689+ 530F              ; basically sets new end time for current animation
1690+ 530F              INIT_CURRENT_ANIMATION:
1691+ 530F CD 0D 4F         CALL GETnthANIMDEF
1692+ 5312 DD 7E 03         LD A,(IX+3) ; current animation item
1693+ 5315 BE               CP (HL) ; number of animation items in the animation definition
1694+ 5316 38 0A            JR C,.L3 ; last item not reached
1695+ 5318                  ; last item reached
1696+ 5318 DD 7E 05         LD A,(IX+5) ; cyclic flag
1697+ 531B B7               OR A
1698+ 531C 28 2C            JR Z,.ERROR ; non-cyclic animation
1699+ 531E                  ; cyclic animation, restart
1700+ 531E DD 36 03 00      LD (IX+3),0; current item
1701+ 5322              .L3:
1702+ 5322                  ; HL = animation definition
1703+ 5322 23               INC HL ; skip animation definition size field
1704+ 5323 16 00            LD D,0
1705+ 5325 DD 5E 03         LD E,(IX+3); current item
1706+ 5328 19               ADD HL,DE
1707+ 5329 4E               LD C,(HL) ; current animation item
1708+ 532A 0C               INC C
1709+ 532B 3A EF 4E         LD A,(ANIMITEMNUM)
1710+ 532E B9               CP C
1711+ 532F 38 19            JR C,.ERROR ; invalid animation item, stop animation
1712+ 5331 0D               DEC C
1713+ 5332 79               LD A,C
1714+ 5333 CD 04 4F         CALL GETnthANIMITEM
1715+ 5336 E5               PUSH HL
1716+ 5337 FD E1            POP IY ; IY=animation item
1717+ 5339 05               DEC B
1718+ 533A 28 0C            JR Z,.EXIT
1719+ 533C FD 5E 01         LD E,(IY+1)
1720+ 533F FD 56 02         LD D,(IY+2) ; duration
1721+ 5342 DD 73 01         LD (IX+1),E
1722+ 5345 DD 72 02         LD (IX+2),D
1723+ 5348              .EXIT:
1724+ 5348 AF               XOR A
1725+ 5349 C9               RET
1726+ 534A              .ERROR:
1727+ 534A 37               SCF
1728+ 534B C9               RET
1729+ 534C              ; *******************************************************************************************************
1730+ 534C
1731+ 534C              ; *******************************************************************************************************
1732+ 534C              ; function will display currect item and set up expiry time
1733+ 534C              ; it will also stop the animation if expired
1734+ 534C              ; sets sprite update flag if any changes in sprite data made
1735+ 534C              ; input IX=current sprite animation
1736+ 534C              ; input B=1 skip timer setup
1737+ 534C              SETUP_ANIM_STEP:
1738+ 534C DD 4E 04         LD C,(IX+4) ; animation definition ID
1739+ 534F 0C               INC C
1740+ 5350 3A F2 4E         LD A,(ANIMDEFNUM)
1741+ 5353 B9               CP C
1742+ 5354 30 05            JR NC,.L2
1743+ 5356                  ; given animation item is outside of bounds, deactivate animation
1744+ 5356              .STOPANIM:
1745+ 5356 DD 36 06 00      LD (IX+6),0
1746+ 535A C9               RET
1747+ 535B              .L2:
1748+ 535B 0D               DEC C
1749+ 535C 79               LD A,C
1750+ 535D CD 0F 53         CALL INIT_CURRENT_ANIMATION
1751+ 5360 38 F4            JR C, .STOPANIM
1752+ 5362 FD 7E 00         LD A,(IY) ; type of animation item
1753+ 5365 B7               OR A
1754+ 5366 28 44            JR Z,.L4 ; change pattern and/or color
1755+ 5368              .PAT:
1756+ 5368                  ; change pattern definition
1757+ 5368                  ; check if sprite or character
1758+ 5368 DD 7E 07         LD A,(IX+7)
1759+ 536B B7               OR A
1760+ 536C 20 58            JR NZ,.CHAR
1761+ 536E DD 7E 00         LD A,(IX) ; sprite number
1762+ 5371 CD 89 4D         CALL GETnthSPRATTR
1763+ 5374 23          > INC HL ; skip y and x
1763+ 5375 23          > INC HL
1763+ 5376 23          > INC HL
1763+ 5377 23          > INC HL
1764+ 5378 7E               LD A,(HL); current pattern
1765+ 5379 26 00            LD H,0
1766+ 537B 6F               LD L,A
1767+ 537C 3A E0 F3         LD A,(REG1SAV)
1768+ 537F E6 02            AND 2
1769+ 5381 20 07            JR NZ,.L6
1770+ 5383                  ; 8x8 sprite
1771+ 5383 CD 74 5F         CALL HLx8
1772+ 5386 06 08            LD B,8
1773+ 5388 18 05            JR .L5
1774+ 538A              .L6:
1775+ 538A CD 72 5F         CALL HLx32
1776+ 538D 06 20            LD B,32
1777+ 538F              .L5:
1778+ 538F 3A AF FC         LD A,(SCRMOD)
1779+ 5392 3D               DEC A
1780+ 5393 20 06            JR NZ,.L10
1781+ 5395 ED 5B C5 F3      LD DE,(T32PAT)
1782+ 5399 18 04            JR .L7
1783+ 539B              .L10:
1784+ 539B ED 5B CF F3      LD DE,(GRPPAT)
1785+ 539F              .L7:
1786+ 539F 19               ADD HL,DE
1787+ 53A0 CD 55 5F         CALL SETWRT_LOCAL_WRITE
1788+ 53A3 FD 6E 03         LD L,(IY+3)
1789+ 53A6 FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
1790+ 53A9 C3 6A 5F         JP BBYTECOPY
1791+ 53AC              .L4:
1792+ 53AC                  ; change pattern and color in sprite attributes table
1793+ 53AC DD 7E 00         LD A,(IX) ; sprite number
1794+ 53AF CD 89 4D         CALL GETnthSPRATTR
1795+ 53B2 23          > INC HL ; skip y and x
1795+ 53B3 23          > INC HL
1795+ 53B4 23          > INC HL
1795+ 53B5 23          > INC HL
1796+ 53B6 FD 7E 03         LD A,(IY+3) ; new pattern
1797+ 53B9 77               LD (HL),A
1798+ 53BA 23          > INC HL
1798+ 53BB 23          > INC HL
1799+ 53BC FD 7E 04         LD A,(IY+4) ; new color
1800+ 53BF 77               LD (HL),A
1801+ 53C0 2A 80 4D         LD HL,(SPRATR_UPDATE_FLAG)
1802+ 53C3 36 01            LD (HL),1
1803+ 53C5 C9               RET
1804+ 53C6              .CHAR:
1805+ 53C6 DD 6E 00         LD L,(IX)
1806+ 53C9 3D               DEC A
1807+ 53CA 67               LD H,A
1808+ 53CB CD 74 5F         CALL HLx8
1809+ 53CE 3A AF FC         LD A,(SCRMOD)
1810+ 53D1 3D               DEC A
1811+ 53D2 20 06            JR NZ,.L8
1812+ 53D4 ED 5B C1 F3      LD DE,(T32CGP)
1813+ 53D8 18 04            JR .L9
1814+ 53DA              .L8:
1815+ 53DA ED 5B CB F3      LD DE,(GRPCGP)
1816+ 53DE              .L9:
1817+ 53DE 06 08            LD B,8
1818+ 53E0 18 BD            JR .L7
1819+ 53E2              ; *******************************************************************************************************
1820+ 53E2
# file closed: asm\ANIMATION.asm
 139  53E2               INCLUDE "SGAM.asm"
# file opened: asm\SGAM.asm
   1+ 53E2              ; Sprite Group Animate and Move
   2+ 53E2
   3+ 53E2              ; *******************************************************************************************************
   4+ 53E2              ; shared function to process a list of animations
   5+ 53E2              ; input B=list size
   6+ 53E2              ; input DE=list pointer
   7+ 53E2              SGAM_PROCESS_ANIM_LIST:
   8+ 53E2 21 F5 53         LD HL,.STEP
   9+ 53E5 22 7A 52         LD (ANIM_SETVALUE.FN+1),HL
  10+ 53E8              .L1:
  11+ 53E8 C5               PUSH BC
  12+ 53E9 1A               LD A,(DE)
  13+ 53EA 13          > INC DE
  13+ 53EB 13          > INC DE
  14+ 53EC D5               PUSH DE
  15+ 53ED CD 6A 52         CALL ANIM_SETVALUE
  16+ 53F0 D1               POP DE
  17+ 53F1 C1               POP BC
  18+ 53F2 10 F4            DJNZ .L1
  19+ 53F4 C9           	RET
  20+ 53F5              .STEP:
  21+ 53F5 06 01            LD B,1
  22+ 53F7 C3 F0 52         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
  23+ 53FA              ; *******************************************************************************************************
  24+ 53FA
  25+ 53FA               IF (0 == 1)
  26+ 53FA ~            ; *******************************************************************************************************
  27+ 53FA ~            ; function to handle CALL SGAM basic extension
  28+ 53FA ~            ; sets position of a group of sprites as described in SPRGRPMOV
  29+ 53FA ~            ; and manually animate a list of animations
  30+ 53FA ~            ; _SGAM ( INT x,
  31+ 53FA ~            ;	      INT y,
  32+ 53FA ~            ;		  BYTE count,
  33+ 53FA ~            ;		  INT[2][count] data_ptr,
  34+ 53FA ~            ;         BYTE item_number,
  35+ 53FA ~            ;         INT[] sprite_animations )
  36+ 53FA ~            ; will put ram in page 0 also, page 1 is already there
  37+ 53FA ~            SGAM:
  38+ 53FA ~            	LD A, (SPRATR_INIT_STATUS)
  39+ 53FA ~            	OR A
  40+ 53FA ~            	JP Z,ILLEGAL_FUNCTION
  41+ 53FA ~            	; opening (
  42+ 53FA ~            	CALL CHKCHAR
  43+ 53FA ~            	DB '('
  44+ 53FA ~            	; get x
  45+ 53FA ~            	LD IX, FRMQNT
  46+ 53FA ~            	CALL CALBAS
  47+ 53FA ~            	LD (BLIT_STRUCT),DE
  48+ 53FA ~            	; comma
  49+ 53FA ~            	CALL CHKCHAR
  50+ 53FA ~            	DB ','
  51+ 53FA ~            	; get y
  52+ 53FA ~            	LD IX, FRMQNT
  53+ 53FA ~            	CALL CALBAS
  54+ 53FA ~            	LD (BLIT_STRUCT+2),DE
  55+ 53FA ~            	; comma
  56+ 53FA ~            	CALL CHKCHAR
  57+ 53FA ~            	DB ','
  58+ 53FA ~            	; get count
  59+ 53FA ~            	LD IX, GETBYT
  60+ 53FA ~            	CALL CALBAS
  61+ 53FA ~                OR A
  62+ 53FA ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
  63+ 53FA ~            	LD (BLIT_STRUCT+4),A
  64+ 53FA ~            	; comma
  65+ 53FA ~            	CALL CHKCHAR
  66+ 53FA ~            	DB ','
  67+ 53FA ~            	; get sprite group definition array data pointer
  68+ 53FA ~                LD A,(BLIT_STRUCT+4)
  69+ 53FA ~            	LD E,A
  70+ 53FA ~            	LD D,3
  71+ 53FA ~            	LD A,2
  72+ 53FA ~            	LD B,A
  73+ 53FA ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
  74+ 53FA ~            	LD (BLIT_STRUCT+5),BC
  75+ 53FA ~            	; comma
  76+ 53FA ~            	CALL CHKCHAR
  77+ 53FA ~            	DB ','
  78+ 53FA ~            	; get sprite animation array size
  79+ 53FA ~            	LD IX,GETBYT
  80+ 53FA ~            	CALL CALBAS
  81+ 53FA ~                LD (BLIT_STRUCT+7),A
  82+ 53FA ~                OR A
  83+ 53FA ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
  84+ 53FA ~            	; comma
  85+ 53FA ~            	CALL CHKCHAR
  86+ 53FA ~            	DB ','
  87+ 53FA ~                ; get array pointer
  88+ 53FA ~                LD A,(BLIT_STRUCT+7)
  89+ 53FA ~                LD D,A
  90+ 53FA ~                LD A,2
  91+ 53FA ~                LD B,1
  92+ 53FA ~                CALL GET_BASIC_ARRAY_DATA_POINTER
  93+ 53FA ~                LD (BLIT_STRUCT+8),BC
  94+ 53FA ~            	; ending )
  95+ 53FA ~            	CALL CHKCHAR
  96+ 53FA ~            	DB ')'
  97+ 53FA ~            .ENTRY:
  98+ 53FA ~                PUSH HL
  99+ 53FA ~
 100+ 53FA ~            	; enable page 0
 101+ 53FA ~            	LD IY, .RET
 102+ 53FA ~            	JP ENABLE_PAGE0
 103+ 53FA ~            .RET:
 104+ 53FA ~                EXX
 105+ 53FA ~                LD DE,(BLIT_STRUCT) ; initial x
 106+ 53FA ~                LD BC,(BLIT_STRUCT+2) ; initial y
 107+ 53FA ~                EXX
 108+ 53FA ~                LD HL,(BLIT_STRUCT+5) ; pointer to data
 109+ 53FA ~                LD A,(BLIT_STRUCT+4) ; number of entries
 110+ 53FA ~                LD B,A
 111+ 53FA ~                CALL SPR_UPDATE_LOC
 112+ 53FA ~
 113+ 53FA ~                LD A,(BLIT_STRUCT+7) ; anim number
 114+ 53FA ~                LD B,A
 115+ 53FA ~                LD DE,(BLIT_STRUCT+8) ; anim list
 116+ 53FA ~            	CALL SGAM_PROCESS_ANIM_LIST
 117+ 53FA ~
 118+ 53FA ~                POP DE
 119+ 53FA ~                POP BC
 120+ 53FA ~                CALL RESTORE_PAGE_INFO
 121+ 53FA ~                EI
 122+ 53FA ~                POP HL
 123+ 53FA ~                RET
 124+ 53FA ~            ; *******************************************************************************************************
 125+ 53FA               ENDIF
 126+ 53FA
 127+ 53FA               IF (1 == 1)
 128+ 53FA              ; *******************************************************************************************************
 129+ 53FA              ; same as SGAM but for DEFUSR approach
 130+ 53FA              ; input IX=pointer to input array, real data from +2
 131+ 53FA              ; +02 = X
 132+ 53FA              ; +04 = Y
 133+ 53FA              ; +06 = count
 134+ 53FA              ; +08 = data pointer
 135+ 53FA              ; +10 = anim number
 136+ 53FA              ; +12 = sprite animations
 137+ 53FA              SGAM_DEFUSR:
 138+ 53FA              	; enable page 0
 139+ 53FA FD 21 01 54  	LD IY, .RET
 140+ 53FE C3 38 60     	JP ENABLE_PAGE0
 141+ 5401              .RET:
 142+ 5401 FB           	EI
 143+ 5402 D9               EXX
 144+ 5403 DD 5E 02     	LD E,(IX+2)
 145+ 5406 DD 56 03     	LD D,(IX+3) ; initial x
 146+ 5409 DD 4E 04     	LD C,(IX+4)
 147+ 540C DD 46 05     	LD B,(IX+5) ; initial y
 148+ 540F D9               EXX
 149+ 5410 DD 6E 08     	LD L,(IX+8)
 150+ 5413 DD 66 09     	LD H,(IX+9) ; pointer to data
 151+ 5416 DD 46 06         LD B,(IX+6) ; count
 152+ 5419 DD E5        	PUSH IX
 153+ 541B CD BA 4E         CALL SPR_UPDATE_LOC
 154+ 541E DD E1        	POP IX
 155+ 5420 DD 46 0A         LD B,(IX+10) ; anim number
 156+ 5423 DD 5E 0C     	LD E,(IX+12)
 157+ 5426 DD 56 0D     	LD D,(IX+13)
 158+ 5429 CD E2 53     	CALL SGAM_PROCESS_ANIM_LIST
 159+ 542C
 160+ 542C D1               POP DE
 161+ 542D C1               POP BC
 162+ 542E C3 AF 5F         JP RESTORE_PAGE_INFO
 163+ 5431              ; *******************************************************************************************************
 164+ 5431               ENDIF
 165+ 5431
 166+ 5431              ; *******************************************************************************************************
 167+ 5431              ; handles automatic move and animate sprite groups during interrupt
 168+ 5431              PROCESS_AUTOSGAMS:
 169+ 5431 3A F8 4E     	LD A,(AUTOSGAMNUM)
 170+ 5434 B7           	OR A
 171+ 5435 C8           	RET Z
 172+ 5436 47           	LD B,A
 173+ 5437 DD 2A F9 4E  	LD IX,(AUTOSGAMPTR)
 174+ 543B              .L1:
 175+ 543B C5           	PUSH BC
 176+ 543C DD 7E 13     	LD A,(IX+19) ; active flag
 177+ 543F B7           	OR A
 178+ 5440 28 28        	JR Z,.LOOPEND
 179+ 5442              	; active, check timer
 180+ 5442 DD 6E 16     	LD L,(IX+22)
 181+ 5445 DD 66 17     	LD H,(IX+23) ; timer
 182+ 5448 2B           	DEC HL
 183+ 5449 7C           	LD A,H
 184+ 544A B5           	OR L
 185+ 544B 28 08        	JR Z,.L2
 186+ 544D              	; not expired
 187+ 544D DD 75 16     	LD (IX+22),L
 188+ 5450 DD 74 17     	LD (IX+23),H
 189+ 5453 18 15        	JR .LOOPEND
 190+ 5455              .L2:
 191+ 5455              	; expired, process
 192+ 5455
 193+ 5455                  ; set initial timer
 194+ 5455 DD 7E 14         LD A,(IX+20)
 195+ 5458 DD 77 16         LD (IX+22),A
 196+ 545B DD 7E 15         LD A,(IX+21)
 197+ 545E DD 77 17         LD (IX+23),A
 198+ 5461
 199+ 5461 CD 73 54     	CALL .MOVE
 200+ 5464 CD DE 54     	CALL .UPDATELOC
 201+ 5467 CD 03 55     	CALL .PROCESS_ANIM_LIST
 202+ 546A
 203+ 546A              .LOOPEND:
 204+ 546A 11 18 00     	LD DE,24
 205+ 546D DD 19        	ADD IX,DE
 206+ 546F C1           	POP BC
 207+ 5470 10 C9        	DJNZ .L1
 208+ 5472 C9           	RET
 209+ 5473
 210+ 5473              .MOVE:
 211+ 5473              	; process movement
 212+ 5473 DD 7E 0A     	LD A,(IX+10) ; direction
 213+ 5476 B7           	OR A
 214+ 5477 28 08        	JR Z, .MOVE_L1
 215+ 5479              	; vertical
 216+ 5479 DD 6E 02     	LD L,(IX+2)
 217+ 547C DD 66 03     	LD H,(IX+3) ; vertical variable pointer
 218+ 547F 18 06        	JR .MOVE_L2
 219+ 5481              .MOVE_L1:
 220+ 5481              	; horizontal
 221+ 5481 DD 6E 00     	LD L,(IX+0)
 222+ 5484 DD 66 01     	LD H,(IX+1) ; horizontal variable pointer
 223+ 5487              .MOVE_L2:
 224+ 5487 E5           	PUSH HL
 225+ 5488 FD E1        	POP IY
 226+ 548A FD 6E 00     	LD L,(IY+0)
 227+ 548D FD 66 01     	LD H,(IY+1)
 228+ 5490 DD 5E 08     	LD E,(IX+8)
 229+ 5493 DD 56 09     	LD D,(IX+9) ; delta value
 230+ 5496 19           	ADD HL,DE
 231+ 5497 E5           	PUSH HL
 232+ 5498 DD 5E 04     	LD E,(IX+4)
 233+ 549B DD 56 05     	LD D,(IX+5) ; minimum value
 234+ 549E A7           	AND A
 235+ 549F ED 52        	SBC HL,DE
 236+ 54A1 FA BB 54     	JP M,.MOVE_L3 ; below minimum
 237+ 54A4 E1           	POP HL
 238+ 54A5 E5           	PUSH HL
 239+ 54A6 DD 5E 06     	LD E,(IX+6)
 240+ 54A9 DD 56 07     	LD D,(IX+7) ; maximum value
 241+ 54AC EB           	EX DE,HL
 242+ 54AD A7           	AND A
 243+ 54AE ED 52        	SBC HL,DE
 244+ 54B0 FA C3 54     	JP M,.MOVE_L4 ; above maximum
 245+ 54B3 E1           	POP HL
 246+ 54B4              	; within bounds
 247+ 54B4              .MOVE_L5:
 248+ 54B4 FD 75 00     	LD (IY+0),L
 249+ 54B7 FD 74 01     	LD (IY+1),H
 250+ 54BA C9           	RET
 251+ 54BB              .MOVE_L3:
 252+ 54BB E1           	POP HL
 253+ 54BC CD CF 54     	CALL .INVERSE_DELTA
 254+ 54BF 6B           	LD L,E
 255+ 54C0 62           	LD H,D
 256+ 54C1 18 F1        	JR .MOVE_L5
 257+ 54C3              .MOVE_L4:
 258+ 54C3 E1           	POP HL
 259+ 54C4 CD CF 54     	CALL .INVERSE_DELTA
 260+ 54C7 DD 6E 06     	LD L,(IX+6)
 261+ 54CA DD 66 07     	LD H,(IX+7) ; maximum
 262+ 54CD 18 E5        	JR .MOVE_L5
 263+ 54CF              .INVERSE_DELTA:
 264+ 54CF AF           	XOR A
 265+ 54D0 DD 96 08     	SUB (IX+8)
 266+ 54D3 DD 77 08     	LD (IX+8),A
 267+ 54D6 9F           	SBC A,A
 268+ 54D7 DD 96 09     	SUB (IX+9)
 269+ 54DA DD 77 09     	LD (IX+9),A
 270+ 54DD C9           	RET
 271+ 54DE
 272+ 54DE              .UPDATELOC:
 273+ 54DE DD E5        	PUSH IX
 274+ 54E0 D9           	EXX
 275+ 54E1 DD 6E 00     	LD L,(IX+0)
 276+ 54E4 DD 66 01     	LD H,(IX+1)
 277+ 54E7 5E           	LD E,(HL)
 278+ 54E8 23           	INC HL
 279+ 54E9 56           	LD D,(HL)
 280+ 54EA DD 6E 02     	LD L,(IX+2)
 281+ 54ED DD 66 03     	LD H,(IX+3)
 282+ 54F0 4E           	LD C,(HL)
 283+ 54F1 23           	INC HL
 284+ 54F2 46           	LD B,(HL)
 285+ 54F3 D9           	EXX
 286+ 54F4 DD 6E 0C     	LD L,(IX+12)
 287+ 54F7 DD 66 0D     	LD H,(IX+13) ; pointer to sprite group data
 288+ 54FA DD 46 0B     	LD B,(IX+11) ; sprite group size
 289+ 54FD CD BA 4E     	CALL SPR_UPDATE_LOC
 290+ 5500 DD E1        	POP IX
 291+ 5502 C9           	RET
 292+ 5503
 293+ 5503              .PROCESS_ANIM_LIST:
 294+ 5503 DD E5        	PUSH IX
 295+ 5505 DD 46 0E         LD B,(IX+14) ; anim list size
 296+ 5508 DD CB 09 7E  	BIT 7,(IX+9)
 297+ 550C 28 08        	JR Z,.PROCESS_ANIM_LIST_L1
 298+ 550E              	; negative direction
 299+ 550E DD 5E 0F     	LD E,(IX+15)
 300+ 5511 DD 56 10     	LD D,(IX+16)
 301+ 5514 18 06        	JR .PROCESS_ANIM_LIST_L2
 302+ 5516              .PROCESS_ANIM_LIST_L1:
 303+ 5516              	; positive direction
 304+ 5516 DD 5E 11     	LD E,(IX+17)
 305+ 5519 DD 56 12     	LD D,(IX+18)
 306+ 551C              .PROCESS_ANIM_LIST_L2:
 307+ 551C CD E2 53     	CALL SGAM_PROCESS_ANIM_LIST
 308+ 551F DD E1        	POP IX
 309+ 5521 C9           	RET
 310+ 5522              ; *******************************************************************************************************
 311+ 5522
# file closed: asm\SGAM.asm
 140  5522               ENDIF
 141  5522
 142  5522               IF (RAM_CMDS == 1)
 143  5522               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
   1+ 5522               IF (0 == 1)
   2+ 5522 ~            ; *******************************************************************************************************
   3+ 5522 ~            ; function to handle CALL MEMCPY basic extension
   4+ 5522 ~            ; _MEMCPY ( INT source,
   5+ 5522 ~            ;			INT destination,
   6+ 5522 ~            ;			INT count,
   7+ 5522 ~            ; will put ram in page 0 also, page 1 is already there
   8+ 5522 ~            MEMCPY:
   9+ 5522 ~            	; opening (
  10+ 5522 ~            	CALL CHKCHAR
  11+ 5522 ~            	DB '('
  12+ 5522 ~            	; get source address
  13+ 5522 ~            	LD IX, FRMQNT
  14+ 5522 ~            	CALL CALBAS
  15+ 5522 ~            	PUSH DE
  16+ 5522 ~            	; comma
  17+ 5522 ~            	CALL CHKCHAR
  18+ 5522 ~            	DB ','
  19+ 5522 ~            	; get destination address
  20+ 5522 ~            	LD IX, FRMQNT
  21+ 5522 ~            	CALL CALBAS
  22+ 5522 ~            	PUSH DE
  23+ 5522 ~            	; comma
  24+ 5522 ~            	CALL CHKCHAR
  25+ 5522 ~            	DB ','
  26+ 5522 ~            	; get length
  27+ 5522 ~            	LD IX, FRMQNT
  28+ 5522 ~            	CALL CALBAS
  29+ 5522 ~            	PUSH DE
  30+ 5522 ~            	; ending )
  31+ 5522 ~            	CALL CHKCHAR
  32+ 5522 ~            	DB ')'
  33+ 5522 ~
  34+ 5522 ~            	; save position
  35+ 5522 ~            	PUSH HL
  36+ 5522 ~            	POP IX
  37+ 5522 ~
  38+ 5522 ~            	POP BC ; count
  39+ 5522 ~            	POP DE ; destination
  40+ 5522 ~            	POP HL ; source
  41+ 5522 ~            	EXX
  42+ 5522 ~            	; enable page 0
  43+ 5522 ~            	LD IY, .RET
  44+ 5522 ~            	JP ENABLE_PAGE0
  45+ 5522 ~            .RET:
  46+ 5522 ~            	EI
  47+ 5522 ~            	EXX
  48+ 5522 ~            	LDIR
  49+ 5522 ~                POP DE
  50+ 5522 ~                POP BC
  51+ 5522 ~                CALL RESTORE_PAGE_INFO
  52+ 5522 ~            	PUSH IX
  53+ 5522 ~            	POP HL
  54+ 5522 ~            	RET
  55+ 5522 ~            ; *******************************************************************************************************
  56+ 5522               ENDIF
  57+ 5522
  58+ 5522               IF (1 == 1)
  59+ 5522              ; *******************************************************************************************************
  60+ 5522              ; same as MEMCPY but for DEFUSR approach
  61+ 5522              ; input IX=pointer to input array, real data from +2
  62+ 5522              ; +2 = source address
  63+ 5522              ; +4 = destination address
  64+ 5522              ; +6 = lenght
  65+ 5522              MEMCPY_DEFUSR:
  66+ 5522              	; enable page 0
  67+ 5522 FD 21 29 55  	LD IY, .RET
  68+ 5526 C3 38 60     	JP ENABLE_PAGE0
  69+ 5529              .RET:
  70+ 5529 FB           	EI
  71+ 552A DD 6E 02     	LD L,(IX+2)
  72+ 552D DD 66 03     	LD H,(IX+3)
  73+ 5530 DD 5E 04     	LD E,(IX+4)
  74+ 5533 DD 56 05     	LD D,(IX+5)
  75+ 5536 DD 4E 06     	LD C,(IX+6)
  76+ 5539 DD 46 07     	LD B,(IX+7)
  77+ 553C ED B0        	LDIR
  78+ 553E D1               POP DE
  79+ 553F C1               POP BC
  80+ 5540 C3 AF 5F         JP RESTORE_PAGE_INFO
  81+ 5543              ; *******************************************************************************************************
  82+ 5543               ENDIF
  83+ 5543
  84+ 5543               IF (0 == 1)
  85+ 5543 ~            ; *******************************************************************************************************
  86+ 5543 ~            ; function to handle CALL FILRAM basic extension
  87+ 5543 ~            ; FILRAM ( INT start address,
  88+ 5543 ~            ;		   INT count,
  89+ 5543 ~            ;		   BYTE value )
  90+ 5543 ~            ; will put ram in page 0 also, page 1 is already there
  91+ 5543 ~            FILRAM:
  92+ 5543 ~            	; opening (
  93+ 5543 ~            	CALL CHKCHAR
  94+ 5543 ~            	DB '('
  95+ 5543 ~            	; get start address
  96+ 5543 ~            	LD IX, FRMQNT
  97+ 5543 ~            	CALL CALBAS
  98+ 5543 ~            	PUSH DE
  99+ 5543 ~            	; comma
 100+ 5543 ~            	CALL CHKCHAR
 101+ 5543 ~            	DB ','
 102+ 5543 ~            	; get count
 103+ 5543 ~            	LD IX, FRMQNT
 104+ 5543 ~            	CALL CALBAS
 105+ 5543 ~            	PUSH DE
 106+ 5543 ~            	; comma
 107+ 5543 ~            	CALL CHKCHAR
 108+ 5543 ~            	DB ','
 109+ 5543 ~            	; get value
 110+ 5543 ~            	LD IX, GETBYT
 111+ 5543 ~            	CALL CALBAS
 112+ 5543 ~            	PUSH AF
 113+ 5543 ~            	; ending )
 114+ 5543 ~            	CALL CHKCHAR
 115+ 5543 ~            	DB ')'
 116+ 5543 ~
 117+ 5543 ~            	; save position
 118+ 5543 ~            	PUSH HL
 119+ 5543 ~            	POP IX
 120+ 5543 ~
 121+ 5543 ~            	POP DE ; actually AF
 122+ 5543 ~            	POP BC ; count
 123+ 5543 ~            	POP HL ; start address
 124+ 5543 ~            	LD A, B
 125+ 5543 ~            	OR C
 126+ 5543 ~            	JR Z, .EXIT ; 0 bytes to fill, skip
 127+ 5543 ~            	EXX
 128+ 5543 ~            	; enable page 0
 129+ 5543 ~            	LD IY, .RET
 130+ 5543 ~            	JP ENABLE_PAGE0
 131+ 5543 ~            .RET:
 132+ 5543 ~            	EI
 133+ 5543 ~            	EXX
 134+ 5543 ~            	CALL FILVRM_FILLVALUE
 135+ 5543 ~                POP DE
 136+ 5543 ~                POP BC
 137+ 5543 ~                CALL RESTORE_PAGE_INFO
 138+ 5543 ~            .EXIT:
 139+ 5543 ~            	PUSH IX
 140+ 5543 ~            	POP HL
 141+ 5543 ~            	RET
 142+ 5543 ~            ; *******************************************************************************************************
 143+ 5543               ENDIF
 144+ 5543
 145+ 5543               IF (1 == 1)
 146+ 5543              ; *******************************************************************************************************
 147+ 5543              ; same as FILVRM but for DEFUSR approach
 148+ 5543              ; input IX=pointer to input array, real data from +2
 149+ 5543              ; +2 = start address
 150+ 5543              ; +4 = count
 151+ 5543              ; +6 = value
 152+ 5543              FILRAM_DEFUSR:
 153+ 5543              	; enable page 0
 154+ 5543 FD 21 4A 55  	LD IY, .RET
 155+ 5547 C3 38 60     	JP ENABLE_PAGE0
 156+ 554A              .RET:
 157+ 554A FB           	EI
 158+ 554B DD 6E 02     	LD L,(IX+2)
 159+ 554E DD 66 03     	LD H,(IX+3)
 160+ 5551 DD 4E 04     	LD C,(IX+4)
 161+ 5554 DD 46 05     	LD B,(IX+5)
 162+ 5557 78           	LD A,B
 163+ 5558 B1           	OR C
 164+ 5559 28 06        	JR Z,.EXIT
 165+ 555B DD 56 06     	LD D,(IX+6)
 166+ 555E CD 66 55     	CALL FILVRM_FILLVALUE
 167+ 5561              .EXIT:
 168+ 5561 D1               POP DE
 169+ 5562 C1               POP BC
 170+ 5563 C3 AF 5F         JP RESTORE_PAGE_INFO
 171+ 5566              ; *******************************************************************************************************
 172+ 5566               ENDIF
 173+ 5566
 174+ 5566              ; *******************************************************************************************************
 175+ 5566              ; common function to fill RAM
 176+ 5566              FILVRM_FILLVALUE:
 177+ 5566 72               LD (HL), D
 178+ 5567 54               LD D, H
 179+ 5568 5D               LD E, L
 180+ 5569 13               INC DE
 181+ 556A 0B               DEC BC
 182+ 556B 78           	LD A,B
 183+ 556C B1           	OR C
 184+ 556D C8           	RET Z ; if count was 1
 185+ 556E ED B0            LDIR
 186+ 5570 C9               RET
 187+ 5571              ; *******************************************************************************************************
# file closed: asm\MEMORY.asm
 144  5571               ENDIF
 145  5571
 146  5571               IF (SOUND_CMDS == 1)
 147  5571               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
   1+ 5571              MUSIC_INIT_STATUS:
   2+ 5571 00            DB 0
   3+ 5572              SFX_INIT_STATUS:
   4+ 5572 00            DB 0
   5+ 5573              SOUND_ENABLED:
   6+ 5573 00            DB 0
   7+ 5574
   8+ 5574               IF (0 == 1)
   9+ 5574 ~            ; *******************************************************************************************************
  10+ 5574 ~            ; function to handle CALL SNDPLYINIT basic extension
  11+ 5574 ~            ; initializes sound player
  12+ 5574 ~            ; _SNDPLYINIT ( INT music_offset,
  13+ 5574 ~            ;				INT sfx_offset, can be -1 if no SFX
  14+ 5574 ~            ; will put ram in page 0 also, page 1 is already there
  15+ 5574 ~            ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
  16+ 5574 ~            SNDPLYINIT:
  17+ 5574 ~            	; opening (
  18+ 5574 ~            	CALL CHKCHAR
  19+ 5574 ~            	DB '('
  20+ 5574 ~            	; get music address
  21+ 5574 ~            	LD IX, FRMQNT
  22+ 5574 ~            	CALL CALBAS
  23+ 5574 ~            	PUSH DE
  24+ 5574 ~            	; comma
  25+ 5574 ~            	CALL CHKCHAR
  26+ 5574 ~            	DB ','
  27+ 5574 ~            	; get sfx address
  28+ 5574 ~            	LD IX, FRMQNT
  29+ 5574 ~            	CALL CALBAS
  30+ 5574 ~            	PUSH DE
  31+ 5574 ~            	; ending )
  32+ 5574 ~            	CALL CHKCHAR
  33+ 5574 ~            	DB ')'
  34+ 5574 ~
  35+ 5574 ~                ; save position in BASIC text
  36+ 5574 ~            	LD B, H
  37+ 5574 ~            	LD C, L
  38+ 5574 ~
  39+ 5574 ~            	; pop LDIR parameters and store away for later
  40+ 5574 ~            	POP DE ; sfx address
  41+ 5574 ~            	POP HL ; music address
  42+ 5574 ~            	PUSH BC ; basic text location
  43+ 5574 ~            	EXX
  44+ 5574 ~            	LD IY, .RET
  45+ 5574 ~            	JP ENABLE_PAGE0
  46+ 5574 ~            .RET:
  47+ 5574 ~            	EXX
  48+ 5574 ~
  49+ 5574 ~            	PUSH DE
  50+ 5574 ~            	XOR A
  51+ 5574 ~            	; HL = music location
  52+ 5574 ~            	CALL PLY_AKG_INIT
  53+ 5574 ~            	LD A, 1
  54+ 5574 ~            	LD (MUSIC_INIT_STATUS), A
  55+ 5574 ~
  56+ 5574 ~            	POP HL ; SFX
  57+ 5574 ~            	; check if SFX address -1
  58+ 5574 ~            	INC HL
  59+ 5574 ~            	LD A, L
  60+ 5574 ~            	OR H
  61+ 5574 ~            	JR Z,.L1
  62+ 5574 ~            	DEC HL
  63+ 5574 ~            	CALL PLY_AKG_INITSOUNDEFFECTS
  64+ 5574 ~            	LD A, 1
  65+ 5574 ~            	LD (SFX_INIT_STATUS), A
  66+ 5574 ~            .L1:
  67+ 5574 ~                POP DE
  68+ 5574 ~                POP BC
  69+ 5574 ~                CALL RESTORE_PAGE_INFO
  70+ 5574 ~
  71+ 5574 ~            	POP HL
  72+ 5574 ~            	RET
  73+ 5574 ~            ; *******************************************************************************************************
  74+ 5574               ENDIF
  75+ 5574
  76+ 5574               IF (1 == 1)
  77+ 5574              ; *******************************************************************************************************
  78+ 5574              ; same as SNDPLYINI but for DEFUSR approach
  79+ 5574              ; input IX=pointer to input array, real data from +2
  80+ 5574              ; +2 = music address
  81+ 5574              ; +4 = sfx address
  82+ 5574              SNDPLYINI_DEFUSR:
  83+ 5574 FD 21 7B 55  	LD IY, .RET
  84+ 5578 C3 38 60     	JP ENABLE_PAGE0
  85+ 557B              .RET:
  86+ 557B AF           	XOR A
  87+ 557C DD 6E 02     	LD L,(IX+2)
  88+ 557F DD 66 03     	LD H,(IX+3)
  89+ 5582 DD E5        	PUSH IX
  90+ 5584 CD 65 41     	CALL PLY_AKG_INIT
  91+ 5587 DD E1        	POP IX
  92+ 5589 3E 01        	LD A, 1
  93+ 558B 32 71 55     	LD (MUSIC_INIT_STATUS), A
  94+ 558E
  95+ 558E DD 6E 04     	LD L,(IX+4)
  96+ 5591 DD 66 05     	LD H,(IX+5)
  97+ 5594              	; check if SFX address -1
  98+ 5594 23           	INC HL
  99+ 5595 7D           	LD A, L
 100+ 5596 B4           	OR H
 101+ 5597 28 09        	JR Z,.L1
 102+ 5599 2B           	DEC HL
 103+ 559A CD 20 40     	CALL PLY_AKG_INITSOUNDEFFECTS
 104+ 559D 3E 01        	LD A, 1
 105+ 559F 32 72 55     	LD (SFX_INIT_STATUS), A
 106+ 55A2              .L1:
 107+ 55A2 D1               POP DE
 108+ 55A3 C1               POP BC
 109+ 55A4 C3 AF 5F         JP RESTORE_PAGE_INFO
 110+ 55A7              ; *******************************************************************************************************
 111+ 55A7               ENDIF
 112+ 55A7
 113+ 55A7              ; *******************************************************************************************************
 114+ 55A7              ; function to handle CALL SNDPLYON basic extension
 115+ 55A7              ; enables sound player
 116+ 55A7              ; _SNDPLYON
 117+ 55A7              ; sets SOUND_ENABLED variable to 1 if init call was done
 118+ 55A7              ; if not throws out of data error
 119+ 55A7              SNDPLYON_DEFUSR:
 120+ 55A7              SNDPLYON:
 121+ 55A7 3A 71 55     	LD A, (MUSIC_INIT_STATUS)
 122+ 55AA B7           	OR A
 123+ 55AB               IF (0 == 1)
 124+ 55AB ~            	JP Z, OUT_OF_DATA ; player not initialized, throw error
 125+ 55AB               ENDIF
 126+ 55AB              .L1:
 127+ 55AB 32 73 55     	LD (SOUND_ENABLED), A
 128+ 55AE              	; disable key click
 129+ 55AE AF           	XOR A
 130+ 55AF 32 DB F3     	LD (CLIKSW), A
 131+ 55B2 C9           	RET
 132+ 55B3              ; *******************************************************************************************************
 133+ 55B3
 134+ 55B3              ; *******************************************************************************************************
 135+ 55B3              ; function to handle CALL SNDPLYOFF basic extension
 136+ 55B3              ; disables sound player
 137+ 55B3              ; _SNDPLYOFF
 138+ 55B3              ; sets SOUND_ENABLED variable to 0
 139+ 55B3              ; calls AKG to stop music and SFX on all channels if initialized
 140+ 55B3              SNDPLYOFF_DEFUSR:
 141+ 55B3              SNDPLYOFF:
 142+ 55B3 3A 73 55     	LD A, (SOUND_ENABLED)
 143+ 55B6 B7           	OR A
 144+ 55B7 C8           	RET Z ; already stopped
 145+ 55B8 AF           	XOR A
 146+ 55B9 32 73 55     	LD (SOUND_ENABLED), A
 147+ 55BC E5           	PUSH HL
 148+ 55BD CD 24 42     	CALL PLY_AKG_STOP
 149+ 55C0 3A 72 55     	LD A, (SFX_INIT_STATUS)
 150+ 55C3 B7           	OR A
 151+ 55C4 28 0E        	JR Z, .EXIT ; SFX not in use
 152+ 55C6 AF           	XOR A
 153+ 55C7 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 154+ 55CA 3E 01        	LD A, 1
 155+ 55CC CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 156+ 55CF 3E 02        	LD A, 2
 157+ 55D1 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 158+ 55D4              .EXIT:
 159+ 55D4 E1           	POP HL
 160+ 55D5 C9           	RET
 161+ 55D6              ; *******************************************************************************************************
 162+ 55D6
 163+ 55D6               IF (0 == 1)
 164+ 55D6 ~            ; *******************************************************************************************************
 165+ 55D6 ~            ; function to handle CALL SNDSFX basic extension
 166+ 55D6 ~            ; plays a sound effect
 167+ 55D6 ~            ; _SNDSFX ( BYTE sfx_number, >0
 168+ 55D6 ~            ;			BYTE channel, = 0,1 or 2
 169+ 55D6 ~            ;			BYTE inverted_volume = 0-16, 0 being full volume
 170+ 55D6 ~            ; will put ram in page 0 also, page 1 is already there
 171+ 55D6 ~            ; if sound off throws illegal function call
 172+ 55D6 ~            ; if sfx not initialized, throws out of data
 173+ 55D6 ~            SNDSFX:
 174+ 55D6 ~            	; opening (
 175+ 55D6 ~            	CALL CHKCHAR
 176+ 55D6 ~            	DB '('
 177+ 55D6 ~            	; get sfx_number
 178+ 55D6 ~            	LD IX, GETBYT
 179+ 55D6 ~            	CALL CALBAS
 180+ 55D6 ~            	PUSH DE
 181+ 55D6 ~            	; comma
 182+ 55D6 ~            	CALL CHKCHAR
 183+ 55D6 ~            	DB ','
 184+ 55D6 ~            	; get sfx address
 185+ 55D6 ~            	LD IX, GETBYT
 186+ 55D6 ~            	CALL CALBAS
 187+ 55D6 ~            	PUSH DE
 188+ 55D6 ~            	; comma
 189+ 55D6 ~            	CALL CHKCHAR
 190+ 55D6 ~            	DB ','
 191+ 55D6 ~            	; get inverted volume
 192+ 55D6 ~            	LD IX, GETBYT
 193+ 55D6 ~            	CALL CALBAS
 194+ 55D6 ~            	PUSH DE
 195+ 55D6 ~            	; ending )
 196+ 55D6 ~            	CALL CHKCHAR
 197+ 55D6 ~            	DB ')'
 198+ 55D6 ~
 199+ 55D6 ~            	LD A, (SOUND_ENABLED)
 200+ 55D6 ~            	OR A
 201+ 55D6 ~            	JR NZ, .L1
 202+ 55D6 ~            	; sound disabled, throw illegal function call
 203+ 55D6 ~            	LD E, 5
 204+ 55D6 ~            	JP THROW_ERROR
 205+ 55D6 ~            .L1:
 206+ 55D6 ~            	LD A, (SFX_INIT_STATUS)
 207+ 55D6 ~            	OR A
 208+ 55D6 ~            	JR NZ, .L2
 209+ 55D6 ~            	; sfx data not initialized, throw out of data
 210+ 55D6 ~            	LD E, 4
 211+ 55D6 ~            	JP THROW_ERROR
 212+ 55D6 ~            .L2:
 213+ 55D6 ~            	; pop  parameters and store away for later
 214+ 55D6 ~            	POP DE ; inverted volume
 215+ 55D6 ~            	LD B, E
 216+ 55D6 ~            	POP DE ; channel
 217+ 55D6 ~            	LD C, E
 218+ 55D6 ~            	POP DE
 219+ 55D6 ~            	LD A, E
 220+ 55D6 ~            	EX AF, AF'
 221+ 55D6 ~            	PUSH HL ; basic text location
 222+ 55D6 ~            	EXX
 223+ 55D6 ~            	LD IY, .RET
 224+ 55D6 ~            	JP ENABLE_PAGE0
 225+ 55D6 ~            .RET:
 226+ 55D6 ~            	EXX
 227+ 55D6 ~            	EX AF, AF'
 228+ 55D6 ~            	CALL PLY_AKG_PLAYSOUNDEFFECT
 229+ 55D6 ~
 230+ 55D6 ~                POP DE
 231+ 55D6 ~                POP BC
 232+ 55D6 ~                CALL RESTORE_PAGE_INFO
 233+ 55D6 ~
 234+ 55D6 ~            	POP HL
 235+ 55D6 ~            	RET
 236+ 55D6 ~            ; *******************************************************************************************************
 237+ 55D6               ENDIF
 238+ 55D6
 239+ 55D6               IF (1 == 1)
 240+ 55D6              ; *******************************************************************************************************
 241+ 55D6              ; same as SNDSFX but for DEFUSR approach
 242+ 55D6              ; input IX=pointer to input array, real data from +2
 243+ 55D6              ; +2 = SFX number
 244+ 55D6              ; +4 = channel
 245+ 55D6              ; +6 = volume
 246+ 55D6              SNDSFX_DEFUSR:
 247+ 55D6 3A 73 55     	LD A, (SOUND_ENABLED)
 248+ 55D9 B7           	OR A
 249+ 55DA C8           	RET Z ; sound disabled, just exit
 250+ 55DB 3A 72 55     	LD A, (SFX_INIT_STATUS)
 251+ 55DE B7           	OR A
 252+ 55DF C8           	RET Z ; sfx data not initialized, just exit
 253+ 55E0 FD 21 E7 55  	LD IY, .RET
 254+ 55E4 C3 38 60     	JP ENABLE_PAGE0
 255+ 55E7              .RET:
 256+ 55E7 FB           	EI
 257+ 55E8 DD 7E 02     	LD A,(IX+2) ; SFX number
 258+ 55EB DD 4E 04     	LD C,(IX+4) ; channel
 259+ 55EE DD 46 06     	LD B,(IX+6) ; volume
 260+ 55F1 CD 24 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
 261+ 55F4 D1               POP DE
 262+ 55F5 C1               POP BC
 263+ 55F6 C3 AF 5F         JP RESTORE_PAGE_INFO
 264+ 55F9              ; *******************************************************************************************************
 265+ 55F9               ENDIF
# file closed: asm\SOUND.asm
 148  55F9               ENDIF
 149  55F9
 150  55F9               IF (VRAM_CMDS == 1)
 151  55F9               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
   1+ 55F9               IF (0 == 1)
   2+ 55F9 ~            ; *******************************************************************************************************
   3+ 55F9 ~            ; function to handle CALL FILVRM basic extension
   4+ 55F9 ~            ; FILVRM ( INT offset,
   5+ 55F9 ~            ;		   INT count,
   6+ 55F9 ~            ;		   BYTE value,
   7+ 55F9 ~            ;		   BYTE wait_vsync) >0 = true
   8+ 55F9 ~            ; wait_vsync will issue HALT before copying
   9+ 55F9 ~            FILVRM:
  10+ 55F9 ~            	; opening (
  11+ 55F9 ~            	CALL CHKCHAR
  12+ 55F9 ~            	DB '('
  13+ 55F9 ~            	; get offset address
  14+ 55F9 ~            	LD IX, FRMQNT
  15+ 55F9 ~            	CALL CALBAS
  16+ 55F9 ~            	PUSH DE
  17+ 55F9 ~            	; comma
  18+ 55F9 ~            	CALL CHKCHAR
  19+ 55F9 ~            	DB ','
  20+ 55F9 ~            	; get count
  21+ 55F9 ~            	LD IX, FRMQNT
  22+ 55F9 ~            	CALL CALBAS
  23+ 55F9 ~            	PUSH DE
  24+ 55F9 ~            	; comma
  25+ 55F9 ~            	CALL CHKCHAR
  26+ 55F9 ~            	DB ','
  27+ 55F9 ~            	; get value
  28+ 55F9 ~            	LD IX, GETBYT
  29+ 55F9 ~            	CALL CALBAS
  30+ 55F9 ~            	PUSH AF
  31+ 55F9 ~            	; comma
  32+ 55F9 ~            	CALL CHKCHAR
  33+ 55F9 ~            	DB ','
  34+ 55F9 ~            	; get vsync wait
  35+ 55F9 ~            	LD IX, GETBYT
  36+ 55F9 ~            	CALL CALBAS
  37+ 55F9 ~            	PUSH AF
  38+ 55F9 ~            	; ending )
  39+ 55F9 ~            	CALL CHKCHAR
  40+ 55F9 ~            	DB ')'
  41+ 55F9 ~
  42+ 55F9 ~            	; save position
  43+ 55F9 ~            	PUSH HL
  44+ 55F9 ~            	POP IX
  45+ 55F9 ~
  46+ 55F9 ~            	; syntax ok
  47+ 55F9 ~            	; wait for vsync if needed
  48+ 55F9 ~            	POP AF
  49+ 55F9 ~            	OR A
  50+ 55F9 ~            	JR Z, .L1
  51+ 55F9 ~            	HALT
  52+ 55F9 ~
  53+ 55F9 ~            .L1:
  54+ 55F9 ~            	LD A,1
  55+ 55F9 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  56+ 55F9 ~                POP AF ; value
  57+ 55F9 ~                POP BC ; count
  58+ 55F9 ~                POP HL ; offset
  59+ 55F9 ~                CALL BIOS_FILVRM
  60+ 55F9 ~            	XOR A
  61+ 55F9 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  62+ 55F9 ~
  63+ 55F9 ~            .L3:
  64+ 55F9 ~            	PUSH IX
  65+ 55F9 ~            	POP HL
  66+ 55F9 ~            	RET
  67+ 55F9 ~            ; *******************************************************************************************************
  68+ 55F9               ENDIF
  69+ 55F9
  70+ 55F9               IF (1 == 1)
  71+ 55F9              ; *******************************************************************************************************
  72+ 55F9              ; same as FILVRM but for DEFUSR approach
  73+ 55F9              ; input IX=pointer to input array, real data from +2
  74+ 55F9              ; +2 = offset
  75+ 55F9              ; +4 = count
  76+ 55F9              ; +6 = value
  77+ 55F9              ; +8 = halt flag
  78+ 55F9              FILVRM_DEFUSR:
  79+ 55F9 DD 7E 08     	LD A,(IX+8)
  80+ 55FC B7           	OR A
  81+ 55FD 28 01        	JR Z,.L0
  82+ 55FF 76           	HALT
  83+ 5600              .L0:
  84+ 5600 3E 01        	LD A,1
  85+ 5602 32 15 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
  86+ 5605 DD 6E 02     	LD L,(IX+2)
  87+ 5608 DD 66 03     	LD H,(IX+3)
  88+ 560B DD 4E 04     	LD C,(IX+4)
  89+ 560E DD 46 05     	LD B,(IX+5)
  90+ 5611 DD 7E 06     	LD A,(IX+6)
  91+ 5614 CD 56 00     	CALL BIOS_FILVRM
  92+ 5617 AF           	XOR A
  93+ 5618 32 15 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
  94+ 561B C9           	RET
  95+ 561C              ; *******************************************************************************************************
  96+ 561C               ENDIF
  97+ 561C
  98+ 561C               IF (0 == 1)
  99+ 561C ~            ; *******************************************************************************************************
 100+ 561C ~            ; function to handle CALL MEMVRM basic extension
 101+ 561C ~            ; copies from RAM to VRAM
 102+ 561C ~            ; if flag != 0 it will issue HALT before copying
 103+ 561C ~            ; if bit 1 of flag set and sprite system initialized it will set sprite update flag
 104+ 561C ~            ; _MEMVRM ( INT source,
 105+ 561C ~            ;			INT destination,
 106+ 561C ~            ;			INT count,
 107+ 561C ~            ;			BYTE flag)
 108+ 561C ~            ; will put ram in page 0 also, page 1 is already there
 109+ 561C ~            MEMVRM:
 110+ 561C ~            	; opening (
 111+ 561C ~            	CALL CHKCHAR
 112+ 561C ~            	DB '('
 113+ 561C ~            	; get source address
 114+ 561C ~            	LD IX, FRMQNT
 115+ 561C ~            	CALL CALBAS
 116+ 561C ~            	PUSH DE
 117+ 561C ~            	; comma
 118+ 561C ~            	CALL CHKCHAR
 119+ 561C ~            	DB ','
 120+ 561C ~            	; get destination address
 121+ 561C ~            	LD IX, FRMQNT
 122+ 561C ~            	CALL CALBAS
 123+ 561C ~            	PUSH DE
 124+ 561C ~            	; comma
 125+ 561C ~            	CALL CHKCHAR
 126+ 561C ~            	DB ','
 127+ 561C ~            	; get length
 128+ 561C ~            	LD IX, FRMQNT
 129+ 561C ~            	CALL CALBAS
 130+ 561C ~            	PUSH DE
 131+ 561C ~            	; comma
 132+ 561C ~            	CALL CHKCHAR
 133+ 561C ~            	DB ','
 134+ 561C ~            	; get vsync wait
 135+ 561C ~            	LD IX, GETBYT
 136+ 561C ~            	CALL CALBAS
 137+ 561C ~            	PUSH AF
 138+ 561C ~            	; ending )
 139+ 561C ~            	CALL CHKCHAR
 140+ 561C ~            	DB ')'
 141+ 561C ~
 142+ 561C ~                ; save position in BASIC text
 143+ 561C ~            	PUSH HL
 144+ 561C ~            	POP IX
 145+ 561C ~
 146+ 561C ~            	POP AF ; wait vsync
 147+ 561C ~            	OR A
 148+ 561C ~            	JR Z, .L1
 149+ 561C ~            	; check for special case to set sprite update flag
 150+ 561C ~            	IF (SPRITE_CMDS == 1)
 151+ 561C ~            		AND 2
 152+ 561C ~            		JR Z,.L2
 153+ 561C ~            		LD A, (SPRATR_INIT_STATUS)
 154+ 561C ~            		OR A
 155+ 561C ~            		JR Z,.L2
 156+ 561C ~            		LD HL,(SPRATR_UPDATE_FLAG)
 157+ 561C ~            		LD (HL),A
 158+ 561C ~            	ENDIF
 159+ 561C ~            .L2:
 160+ 561C ~            	HALT
 161+ 561C ~            .L1:
 162+ 561C ~            	; pop LDIR parameters and store away for later
 163+ 561C ~            	POP BC ; count
 164+ 561C ~            	POP DE ; vram destination
 165+ 561C ~            	POP HL ; ram source
 166+ 561C ~            	EXX
 167+ 561C ~             	LD IY, .RET
 168+ 561C ~            	JP ENABLE_PAGE0
 169+ 561C ~            .RET:
 170+ 561C ~            	EI
 171+ 561C ~            	EXX
 172+ 561C ~            	CALL VRAM_LDIRVM
 173+ 561C ~                POP DE
 174+ 561C ~                POP BC
 175+ 561C ~                CALL RESTORE_PAGE_INFO
 176+ 561C ~            	PUSH IX
 177+ 561C ~            	POP HL
 178+ 561C ~            	RET
 179+ 561C ~            ; *******************************************************************************************************
 180+ 561C               ENDIF
 181+ 561C
 182+ 561C               IF (1 == 1)
 183+ 561C              ; *******************************************************************************************************
 184+ 561C              ; same as MEMVRM but for DEFUSR approach
 185+ 561C              ; input IX=pointer to input array, real data from +2
 186+ 561C              ; +2 = source address
 187+ 561C              ; +4 = destination address
 188+ 561C              ; +6 = lenght
 189+ 561C              ; +8 = flag
 190+ 561C              MEMVRM_DEFUSR:
 191+ 561C DD 7E 08     	LD A,(IX+8)
 192+ 561F B7           	OR A
 193+ 5620 28 0F        	JR Z,.L0
 194+ 5622              	IF (SPRITE_CMDS == 1)
 195+ 5622 E6 02        		AND 2
 196+ 5624 28 0A        		JR Z,.L2
 197+ 5626 3A 7F 4D     		LD A, (SPRATR_INIT_STATUS)
 198+ 5629 B7           		OR A
 199+ 562A 28 04        		JR Z,.L2
 200+ 562C 2A 80 4D     		LD HL,(SPRATR_UPDATE_FLAG)
 201+ 562F 77           		LD (HL),A
 202+ 5630              	ENDIF
 203+ 5630              .L2:
 204+ 5630 76           	HALT
 205+ 5631              .L0:
 206+ 5631              	; enable page 0
 207+ 5631 FD 21 38 56  	LD IY, .RET
 208+ 5635 C3 38 60     	JP ENABLE_PAGE0
 209+ 5638              .RET:
 210+ 5638 FB           	EI
 211+ 5639 DD 6E 02     	LD L,(IX+2)
 212+ 563C DD 66 03     	LD H,(IX+3)
 213+ 563F DD 5E 04     	LD E,(IX+4)
 214+ 5642 DD 56 05     	LD D,(IX+5)
 215+ 5645 DD 4E 06     	LD C,(IX+6)
 216+ 5648 DD 46 07     	LD B,(IX+7)
 217+ 564B CD 53 56     	CALL VRAM_LDIRVM
 218+ 564E D1               POP DE
 219+ 564F C1               POP BC
 220+ 5650 C3 AF 5F         JP RESTORE_PAGE_INFO
 221+ 5653              ; *******************************************************************************************************
 222+ 5653               ENDIF
 223+ 5653
 224+ 5653              ; *******************************************************************************************************
 225+ 5653              ; common code to copy from memory to VRAM
 226+ 5653              ; input HL=RAM source
 227+ 5653              ; input DE=VRAM destination
 228+ 5653              ; BC=count
 229+ 5653              VRAM_LDIRVM:
 230+ 5653 3E 01        	LD A,1
 231+ 5655 32 15 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 232+ 5658 EB           	EX DE, HL
 233+ 5659 F3           	DI
 234+ 565A CD 55 5F     	CALL SETWRT_LOCAL_WRITE
 235+ 565D FB           	EI
 236+ 565E EB           	EX DE, HL
 237+ 565F 78           	LD A, B
 238+ 5660 B7           	OR A
 239+ 5661 28 0D        	JR Z, .L3
 240+ 5663 C5           	PUSH BC
 241+ 5664 0E 98        	LD C, #98
 242+ 5666              .L2:
 243+ 5666 50           	LD D, B
 244+ 5667 06 00        	LD B, 0
 245+ 5669 CD 6C 5F     	CALL BBYTECOPY_NO_C
 246+ 566C 42           	LD B, D
 247+ 566D 10 F7        	DJNZ .L2
 248+ 566F C1           	POP BC
 249+ 5670              .L3:
 250+ 5670 79           	LD A, C
 251+ 5671 B7           	OR A
 252+ 5672 28 04        	JR Z,.L4
 253+ 5674 41           	LD B, C
 254+ 5675 CD 6A 5F     	CALL BBYTECOPY
 255+ 5678              .L4:
 256+ 5678 AF           	XOR A
 257+ 5679 32 15 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 258+ 567C C9           	RET
 259+ 567D              ; *******************************************************************************************************
 260+ 567D
 261+ 567D               IF (0 == 1)
 262+ 567D ~            ; *******************************************************************************************************
 263+ 567D ~            ; function to handle CALL VRMMEM basic extension
 264+ 567D ~            ; copies from VRAM to RAM
 265+ 567D ~            ; _VRMMEM ( INT source,
 266+ 567D ~            ;			INT destination,
 267+ 567D ~            ;			INT count
 268+ 567D ~            ; will put ram in page 0 also, page 1 is already there
 269+ 567D ~            VRMMEM:
 270+ 567D ~            	; opening (
 271+ 567D ~            	CALL CHKCHAR
 272+ 567D ~            	DB '('
 273+ 567D ~            	; get source address
 274+ 567D ~            	LD IX, FRMQNT
 275+ 567D ~            	CALL CALBAS
 276+ 567D ~            	PUSH DE
 277+ 567D ~            	; comma
 278+ 567D ~            	CALL CHKCHAR
 279+ 567D ~            	DB ','
 280+ 567D ~            	; get destination address
 281+ 567D ~            	LD IX, FRMQNT
 282+ 567D ~            	CALL CALBAS
 283+ 567D ~            	PUSH DE
 284+ 567D ~            	; comma
 285+ 567D ~            	CALL CHKCHAR
 286+ 567D ~            	DB ','
 287+ 567D ~            	; get length
 288+ 567D ~            	LD IX, FRMQNT
 289+ 567D ~            	CALL CALBAS
 290+ 567D ~            	PUSH DE
 291+ 567D ~            	; ending )
 292+ 567D ~            	CALL CHKCHAR
 293+ 567D ~            	DB ')'
 294+ 567D ~
 295+ 567D ~                ; save position in BASIC text
 296+ 567D ~            	PUSH HL
 297+ 567D ~            	POP IX
 298+ 567D ~
 299+ 567D ~            	POP BC ; count
 300+ 567D ~            	POP DE ; destination
 301+ 567D ~            	POP HL ; source
 302+ 567D ~            	EXX
 303+ 567D ~            	LD IY, .RET
 304+ 567D ~            	JP ENABLE_PAGE0
 305+ 567D ~            .RET:
 306+ 567D ~            	EI
 307+ 567D ~            	EXX
 308+ 567D ~            	CALL VRAM_LDIRMV
 309+ 567D ~                POP DE
 310+ 567D ~                POP BC
 311+ 567D ~                CALL RESTORE_PAGE_INFO
 312+ 567D ~            	PUSH IX
 313+ 567D ~            	POP HL
 314+ 567D ~            	RET
 315+ 567D ~            ; *******************************************************************************************************
 316+ 567D               ENDIF
 317+ 567D
 318+ 567D               IF (1 == 1)
 319+ 567D              ; *******************************************************************************************************
 320+ 567D              ; same as VRMMEM but for DEFUSR approach
 321+ 567D              ; input IX=pointer to input array, real data from +2
 322+ 567D              ; +2 = source address
 323+ 567D              ; +4 = destination address
 324+ 567D              ; +6 = count
 325+ 567D              VRMMEM_DEFUSR:
 326+ 567D              	; enable page 0
 327+ 567D FD 21 84 56  	LD IY, .RET
 328+ 5681 C3 38 60     	JP ENABLE_PAGE0
 329+ 5684              .RET:
 330+ 5684 FB           	EI
 331+ 5685 DD 6E 02     	LD L,(IX+2)
 332+ 5688 DD 66 03     	LD H,(IX+3)
 333+ 568B DD 5E 04     	LD E,(IX+4)
 334+ 568E DD 56 05     	LD D,(IX+5)
 335+ 5691 DD 4E 06     	LD C,(IX+6)
 336+ 5694 DD 46 07     	LD B,(IX+7)
 337+ 5697 CD 9F 56     	CALL VRAM_LDIRMV
 338+ 569A D1               POP DE
 339+ 569B C1               POP BC
 340+ 569C C3 AF 5F         JP RESTORE_PAGE_INFO
 341+ 569F              ; *******************************************************************************************************
 342+ 569F               ENDIF
 343+ 569F
 344+ 569F              ; *******************************************************************************************************
 345+ 569F              ; common code to copy from VRAM to RAM
 346+ 569F              ; input HL=VRAM source
 347+ 569F              ; input DE=RAM destination
 348+ 569F              ; BC=count
 349+ 569F              VRAM_LDIRMV:
 350+ 569F 3E 01        	LD A,1
 351+ 56A1 32 15 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 352+ 56A4 7D           	LD	A, L
 353+ 56A5 F3           	DI
 354+ 56A6 CD 60 5F     	CALL SETWRT_LOCAL_READ
 355+ 56A9 FB           	EI
 356+ 56AA 00           	NOP
 357+ 56AB 00           	NOP
 358+ 56AC 00           	NOP ; too fast VDP access per openMSX
 359+ 56AD              .L4:
 360+ 56AD DB 98            IN A, (#98)
 361+ 56AF 12           	LD (DE), A
 362+ 56B0 13               INC DE
 363+ 56B1 0B               DEC BC
 364+ 56B2 79               LD A, C
 365+ 56B3 B0               OR B
 366+ 56B4 20 F7            JR NZ, .L4
 367+ 56B6 AF           	XOR A
 368+ 56B7 32 15 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 369+ 56BA C9               RET
 370+ 56BB              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
 152  56BB               ENDIF
 153  56BB
 154  56BB               IF (GENCAL_CMD == 1)
 155  56BB               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
   1+ 56BB               IF (1 == 1)
   2+ 56BB              ; *******************************************************************************************************
   3+ 56BB              ; same as GENCAL but for DEFUSR approach
   4+ 56BB              ; input IX=pointer to input array, real data from +2
   5+ 56BB              ; +2 = function address to call
   6+ 56BB              ; +4 = register list array pointer
   7+ 56BB              GENCAL_DEFUSR:
   8+ 56BB DD 6E 02         LD L,(IX+2)
   9+ 56BE DD 66 03         LD H,(IX+3)
  10+ 56C1 E5               PUSH HL
  11+ 56C2 DD 6E 04         LD L,(IX+4)
  12+ 56C5 DD 66 05         LD H,(IX+5)
  13+ 56C8 E5               PUSH HL
  14+ 56C9 18 00            JR GENCAL.COMMON
  15+ 56CB              ; *******************************************************************************************************
  16+ 56CB               ENDIF
  17+ 56CB
  18+ 56CB              ; *******************************************************************************************************
  19+ 56CB              ; function to handle CALL GENCAL basic extension
  20+ 56CB              ; GENCAL ( INT fn_addr, = address of the function to call
  21+ 56CB              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
  22+ 56CB              ; output values of registers will also be stored at reg_list_ptr
  23+ 56CB              GENCAL:
  24+ 56CB               IF (0 == 1)
  25+ 56CB ~            	; opening (
  26+ 56CB ~            	CALL CHKCHAR
  27+ 56CB ~            	DB '('
  28+ 56CB ~            	; get function address
  29+ 56CB ~            	LD IX, FRMQNT
  30+ 56CB ~            	CALL CALBAS
  31+ 56CB ~            	PUSH DE
  32+ 56CB ~            	; comma
  33+ 56CB ~            	CALL CHKCHAR
  34+ 56CB ~            	DB ','
  35+ 56CB ~            	; get pointer to register list
  36+ 56CB ~                LD A,2
  37+ 56CB ~                LD B,1
  38+ 56CB ~                LD DE,#0500
  39+ 56CB ~                CALL GET_BASIC_ARRAY_DATA_POINTER
  40+ 56CB ~            	PUSH BC
  41+ 56CB ~            	; ending )
  42+ 56CB ~            	CALL CHKCHAR
  43+ 56CB ~            	DB ')'
  44+ 56CB               ENDIF
  45+ 56CB              .COMMON:
  46+ 56CB              	; save BASIC token position
  47+ 56CB E5           	PUSH HL
  48+ 56CC D9               EXX
  49+ 56CD E1           	POP HL ; HL'=next basic token
  50+ 56CE D9               EXX
  51+ 56CF
  52+ 56CF E1               POP HL ; get pointer to register values
  53+ 56D0 F3           	DI
  54+ 56D1 ED 73 04 5F      LD (BLIT_STRUCT), SP
  55+ 56D5 F9               LD SP, HL
  56+ 56D6 F1               POP AF
  57+ 56D7 C1               POP BC
  58+ 56D8 D1               POP DE
  59+ 56D9 E1               POP HL
  60+ 56DA DD E1            POP IX
  61+ 56DC FD E1            POP IY
  62+ 56DE D9               EXX
  63+ 56DF ED 73 06 5F      LD (BLIT_STRUCT+2), SP
  64+ 56E3 ED 7B 04 5F      LD SP, (BLIT_STRUCT)
  65+ 56E7 FB               EI
  66+ 56E8 D1               POP DE ; get function to call
  67+ 56E9 E5               PUSH HL
  68+ 56EA CD 05 57         CALL .EXXDECALL
  69+ 56ED F3               DI
  70+ 56EE ED 73 04 5F      LD (BLIT_STRUCT), SP
  71+ 56F2 ED 7B 06 5F      LD SP, (BLIT_STRUCT+2)
  72+ 56F6 FD E5            PUSH IY
  73+ 56F8 DD E5            PUSH IX
  74+ 56FA E5               PUSH HL
  75+ 56FB D5               PUSH DE
  76+ 56FC C5               PUSH BC
  77+ 56FD F5               PUSH AF
  78+ 56FE ED 7B 04 5F      LD SP, (BLIT_STRUCT)
  79+ 5702 FB               EI
  80+ 5703 E1               POP HL
  81+ 5704 C9           	RET
  82+ 5705
  83+ 5705              .EXXDECALL:
  84+ 5705 D5               PUSH DE
  85+ 5706 D9               EXX
  86+ 5707 C9               RET
  87+ 5708              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
 156  5708               ENDIF
 157  5708
 158  5708               IF (BOX_CMDS == 1)
 159  5708               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
   1+ 5708              ; *******************************************************************************************************
   2+ 5708              ; generic function to implement rectangle data copy
   3+ 5708              ; should be modified to call appropriate function for memory or vram
   4+ 5708              ; input IX=pointer to following structure
   5+ 5708              ; +00 source data pointer
   6+ 5708              ; +02 num bytes in a row
   7+ 5708              ; +04 number of rows
   8+ 5708              ; +06 source add-to value till next row
   9+ 5708              ; +08 destination address
  10+ 5708              ; +10 destination add-to value till next row
  11+ 5708              ; modifies AF, BC, DE, HL
  12+ 5708              RECTANGLE_COPY:
  13+ 5708 DD 6E 00     	LD L, (IX+0)
  14+ 570B DD 66 01     	LD H, (IX+1) ; source address
  15+ 570E DD 5E 08     	LD E, (IX+8)
  16+ 5711 DD 56 09     	LD D, (IX+9) ; destination
  17+ 5714 DD 46 04     	LD B, (IX+4) ; row number
  18+ 5717              .L1:
  19+ 5717 C5           	PUSH BC
  20+ 5718 E5           		PUSH HL
  21+ 5719 D5           			PUSH DE
  22+ 571A DD 4E 02     				LD C, (IX+2)
  23+ 571D DD 46 03     				LD B, (IX+3) ; num bytes in a row
  24+ 5720              .CALL1:
  25+ 5720 CD 00 00     				CALL 0 ; set destination address from DE
  26+ 5723              .CALL2:
  27+ 5723 CD 00 00     				CALL 0 ; copy data fn
  28+ 5726 E1           			POP HL
  29+ 5727 DD 4E 0A     			LD C, (IX+10)
  30+ 572A DD 46 0B     			LD B, (IX+11) ; destination add-to
  31+ 572D 09           			ADD HL, BC
  32+ 572E EB           			EX DE, HL
  33+ 572F E1           		POP HL
  34+ 5730 DD 4E 06     		LD C, (IX+6)
  35+ 5733 DD 46 07     		LD B, (IX+7) ; src add-to
  36+ 5736 09           		ADD HL, BC
  37+ 5737 C1           	POP BC
  38+ 5738 10 DD        	DJNZ .L1
  39+ 573A C9           	RET
  40+ 573B              ; *******************************************************************************************************
  41+ 573B
  42+ 573B               IF (0 == 1)
  43+ 573B ~            ; *******************************************************************************************************
  44+ 573B ~            ; function to handle CALL BOXMEMCPY basic extension
  45+ 573B ~            ; copies data with window like boundaries within ram
  46+ 573B ~            ; BOXMEMCPY ( INT source data pointer,
  47+ 573B ~            ;			  INT source number of bytes in a row,
  48+ 573B ~            ;			  INT number of rows,
  49+ 573B ~            ;			  INT source add-to value till next row,
  50+ 573B ~            ; 			  INT destination pointer,
  51+ 573B ~            ;			  INT destination add-to value till next row )
  52+ 573B ~            ; request_data_ptr described in RECTANGLE_COPY
  53+ 573B ~            ; will put ram in page 0 also, page 1 is already there
  54+ 573B ~            BOXMEMCPY:
  55+ 573B ~            	LD DE,BOXMEMCPY_COMMON
  56+ 573B ~            	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
  57+ 573B ~            	JP BOX_EXTENSION_PARAMS_COMMON
  58+ 573B               ENDIF
  59+ 573B
  60+ 573B               IF (1 == 1)
  61+ 573B              ; *******************************************************************************************************
  62+ 573B              ; same as BOXMEMCPY but for DEFUSR approach
  63+ 573B              ; input IX=pointer to input array, real data from +2
  64+ 573B              ; +02 = source data pointer
  65+ 573B              ; +04 = source number of bytes in a row
  66+ 573B              ; +06 = number of rows
  67+ 573B              ; +08 = source add-to value till next row
  68+ 573B              ; +10 = destination pointer
  69+ 573B              ; +12 = destination add-to value till next row
  70+ 573B              BOXMEMCPY_DEFUSR:
  71+ 573B 21 48 57     	LD HL,BOXMEMCPY_COMMON
  72+ 573E 22 5E 57     	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
  73+ 5741 DD 23        	INC IX
  74+ 5743 DD 23        	INC IX
  75+ 5745 C3 5B 57     	JP BOXCOMMON_DEFUSR
  76+ 5748               ENDIF
  77+ 5748
  78+ 5748              BOXMEMCPY_COMMON:
  79+ 5748 FB           	EI
  80+ 5749              	; set RAM functions to call
  81+ 5749 21 00 00     	LD HL, 0
  82+ 574C 22 20 57     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
  83+ 574F 22 22 57     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
  84+ 5752 21 ED B0     	LD HL, #B0ED ; LDIR
  85+ 5755 22 24 57     	LD (RECTANGLE_COPY.CALL1+4), HL
  86+ 5758 C3 63 57     	JP BOXCOMMON_DEFUSR.CALL
  87+ 575B              ; *******************************************************************************************************
  88+ 575B
  89+ 575B               IF (0 == 1)
  90+ 575B ~            ; *******************************************************************************************************
  91+ 575B ~            ; common parts of BOX commands to load parameters
  92+ 575B ~            BOX_EXTENSION_PARAMS_COMMON:
  93+ 575B ~            	; opening (
  94+ 575B ~            	CALL CHKCHAR
  95+ 575B ~            	DB '('
  96+ 575B ~            	; get source data pointer
  97+ 575B ~            	LD IX, FRMQNT
  98+ 575B ~            	CALL CALBAS
  99+ 575B ~            	LD (BLIT_STRUCT+0), DE
 100+ 575B ~            	; comma
 101+ 575B ~            	CALL CHKCHAR
 102+ 575B ~            	DB ','
 103+ 575B ~            	; source number of bytes in a row
 104+ 575B ~            	LD IX, FRMQNT
 105+ 575B ~            	CALL CALBAS
 106+ 575B ~            	LD (BLIT_STRUCT+2), DE
 107+ 575B ~            	; comma
 108+ 575B ~            	CALL CHKCHAR
 109+ 575B ~            	DB ','
 110+ 575B ~            	; number of rows
 111+ 575B ~            	LD IX, FRMQNT
 112+ 575B ~            	CALL CALBAS
 113+ 575B ~            	LD (BLIT_STRUCT+4), DE
 114+ 575B ~            	; comma
 115+ 575B ~            	CALL CHKCHAR
 116+ 575B ~            	DB ','
 117+ 575B ~            	; source add-to value till next row
 118+ 575B ~            	LD IX, FRMQNT
 119+ 575B ~            	CALL CALBAS
 120+ 575B ~            	LD (BLIT_STRUCT+6), DE
 121+ 575B ~            	; comma
 122+ 575B ~            	CALL CHKCHAR
 123+ 575B ~            	DB ','
 124+ 575B ~            	; destination pointer
 125+ 575B ~            	LD IX, FRMQNT
 126+ 575B ~            	CALL CALBAS
 127+ 575B ~            	LD (BLIT_STRUCT+8), DE
 128+ 575B ~            	; comma
 129+ 575B ~            	CALL CHKCHAR
 130+ 575B ~            	DB ','
 131+ 575B ~            	; destination add-to value till next row
 132+ 575B ~            	LD IX, FRMQNT
 133+ 575B ~            	CALL CALBAS
 134+ 575B ~            	LD (BLIT_STRUCT+10), DE
 135+ 575B ~            	; ending )
 136+ 575B ~            	CALL CHKCHAR
 137+ 575B ~            	DB ')'
 138+ 575B ~            	LD IX,BLIT_STRUCT
 139+ 575B               ENDIF
 140+ 575B              BOXCOMMON_DEFUSR:
 141+ 575B E5           	PUSH HL ; save position in BASIC buffer
 142+ 575C              .ADDR:
 143+ 575C FD 21 00 00  	LD IY, 0 ; modified by code
 144+ 5760 C3 38 60     	JP ENABLE_PAGE0
 145+ 5763              .CALL:
 146+ 5763 CD 08 57     	CALL RECTANGLE_COPY
 147+ 5766 AF           	XOR A
 148+ 5767 32 15 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 149+ 576A
 150+ 576A D1               POP DE
 151+ 576B C1               POP BC
 152+ 576C CD AF 5F         CALL RESTORE_PAGE_INFO
 153+ 576F
 154+ 576F E1           	POP HL
 155+ 5770 C9           	RET
 156+ 5771              ; *******************************************************************************************************
 157+ 5771
 158+ 5771               IF (0 == 1)
 159+ 5771 ~            ; *******************************************************************************************************
 160+ 5771 ~            ; function to handle CALL BOXMEMVRM basic extension
 161+ 5771 ~            ; copies data with window like boundaries from ram to Vram
 162+ 5771 ~            ; BOXMEMVRM ( INT source data pointer,
 163+ 5771 ~            ;			  INT source number of bytes in a row,
 164+ 5771 ~            ;			  INT number of rows,
 165+ 5771 ~            ;			  INT source add-to value till next row,
 166+ 5771 ~            ; 			  INT destination pointer,
 167+ 5771 ~            ;			  INT destination add-to value till next row )
 168+ 5771 ~            ; request_data_ptr described in RECTANGLE_COPY
 169+ 5771 ~            ; will put ram in page 0 also, page 1 is already there
 170+ 5771 ~            BOXMEMVRM:
 171+ 5771 ~            	LD DE,BOXMEMVRM_COMMON
 172+ 5771 ~            	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
 173+ 5771 ~            	JP BOX_EXTENSION_PARAMS_COMMON
 174+ 5771               ENDIF
 175+ 5771
 176+ 5771               IF (1 == 1)
 177+ 5771              ; *******************************************************************************************************
 178+ 5771              ; same as BOXMEMVRM but for DEFUSR approach
 179+ 5771              ; input IX=pointer to input array, real data from +2
 180+ 5771              ; +02 = source data pointer
 181+ 5771              ; +04 = source number of bytes in a row
 182+ 5771              ; +06 = number of rows
 183+ 5771              ; +08 = source add-to value till next row
 184+ 5771              ; +10 = destination pointer
 185+ 5771              ; +12 = destination add-to value till next row
 186+ 5771              BOXMEMVRM_DEFUSR:
 187+ 5771 21 7E 57     	LD HL,BOXMEMVRM_COMMON
 188+ 5774 22 5E 57     	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
 189+ 5777 DD 23        	INC IX
 190+ 5779 DD 23        	INC IX
 191+ 577B C3 5B 57     	JP BOXCOMMON_DEFUSR
 192+ 577E               ENDIF
 193+ 577E
 194+ 577E              BOXMEMVRM_COMMON:
 195+ 577E FB           	EI
 196+ 577F              	; set RAM functions to call
 197+ 577F 21 99 57     	LD HL, .SETDEST
 198+ 5782 22 21 57     	LD (RECTANGLE_COPY.CALL1+1), HL
 199+ 5785 21 A1 57     	LD HL, .COPYDATA
 200+ 5788 22 24 57     	LD (RECTANGLE_COPY.CALL2+1), HL
 201+ 578B 3E CD        	LD A, #CD ; CALL
 202+ 578D 32 20 57     	LD (RECTANGLE_COPY.CALL1), A
 203+ 5790 32 23 57     	LD (RECTANGLE_COPY.CALL2), A
 204+ 5793              	;LD A,1
 205+ 5793 32 15 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 206+ 5796 C3 63 57     	JP BOXCOMMON_DEFUSR.CALL
 207+ 5799              .SETDEST:
 208+ 5799 EB           	EX DE, HL
 209+ 579A F3           	DI
 210+ 579B CD 55 5F     	CALL SETWRT_LOCAL_WRITE
 211+ 579E FB           	EI
 212+ 579F EB           	EX DE, HL
 213+ 57A0 C9           	RET
 214+ 57A1              .COPYDATA:
 215+ 57A1 41           	LD B, C
 216+ 57A2 C3 6A 5F     	JP BBYTECOPY
 217+ 57A5              ; *******************************************************************************************************
# file closed: asm\BOX.asm
 160  57A5               ENDIF
 161  57A5
 162  57A5               IF (BLIT_CMDS == 1)
 163  57A5               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
   1+ 57A5              ; *******************************************************************************************************
   2+ 57A5              ; function rotates mask and data of several characters and applies to background data
   3+ 57A5              ; this handles x-shift from 0 to 4
   4+ 57A5              ; contains self-modifying code that is set-up from external function
   5+ 57A5              ; input HL=pointer to mask data
   6+ 57A5              ; input HL'=pointer to character data
   7+ 57A5              ; input DE=output buffer containing background data
   8+ 57A5              ; input BC=DE+8
   9+ 57A5              ; input A=number of characters to process
  10+ 57A5              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  11+ 57A5              SHIFT04:
  12+ 57A5 08           	EX AF, AF'
  13+ 57A6 7E           	LD A, (HL) ; get mask
  14+ 57A7 D9           	EXX
  15+ 57A8 57           	LD D, A
  16+ 57A9 1E FF        	LD E, #FF
  17+ 57AB 37           	SCF
  18+ 57AC              .M1:
  19+ 57AC 18 FE        	JR .M1 ; this is self-modifying part
  20+ 57AE CB 1A        	RR D
  21+ 57B0 CB 1B        	RR E
  22+ 57B2 CB 1A        	RR D
  23+ 57B4 CB 1B        	RR E
  24+ 57B6 CB 1A        	RR D
  25+ 57B8 CB 1B        	RR E
  26+ 57BA CB 1A        	RR D
  27+ 57BC CB 1B        	RR E
  28+ 57BE
  29+ 57BE 46           	LD B, (HL) ; get data
  30+ 57BF 0E 00        	LD C, 0
  31+ 57C1              .M2:
  32+ 57C1 18 FE        	JR .M2 ; also self-modifying part
  33+ 57C3 CB 38        	SRL B
  34+ 57C5 CB 19        	RR C
  35+ 57C7 CB 38        	SRL B
  36+ 57C9 CB 19        	RR C
  37+ 57CB CB 38        	SRL B
  38+ 57CD CB 19        	RR C
  39+ 57CF CB 38        	SRL B
  40+ 57D1 CB 19        	RR C
  41+ 57D3
  42+ 57D3 D9           	EXX
  43+ 57D4 1A           	LD A, (DE) ; background
  44+ 57D5 D9           	EXX
  45+ 57D6 A2           	AND D
  46+ 57D7 B0           	OR B
  47+ 57D8 D9           	EXX
  48+ 57D9 12           	LD (DE), A
  49+ 57DA
  50+ 57DA 0A           	LD A, (BC)
  51+ 57DB D9           	EXX
  52+ 57DC A3           	AND E
  53+ 57DD B1           	OR C
  54+ 57DE 23           	INC HL
  55+ 57DF D9           	EXX
  56+ 57E0 02           	LD (BC), A
  57+ 57E1
  58+ 57E1 23           	INC HL
  59+ 57E2 13           	INC DE
  60+ 57E3 03           	INC BC
  61+ 57E4
  62+ 57E4 08           	EX AF, AF'
  63+ 57E5 3D           	DEC A
  64+ 57E6 C2 A5 57     	JP NZ, SHIFT04
  65+ 57E9 C9           	RET
  66+ 57EA              ; *******************************************************************************************************
  67+ 57EA
  68+ 57EA              ; *******************************************************************************************************
  69+ 57EA              ; function rotates mask and data of several characters and applies to background data
  70+ 57EA              ; this handles x-shift from 5 to 8
  71+ 57EA              ; contains self-modifying code that is set-up from external function
  72+ 57EA              ; input HL=pointer to mask data
  73+ 57EA              ; input HL'=pointer to character data
  74+ 57EA              ; input DE=output buffer containing background data
  75+ 57EA              ; input BC=DE+8
  76+ 57EA              ; input A=number of characters to process
  77+ 57EA              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  78+ 57EA              SHIFT58:
  79+ 57EA 08           	EX AF, AF'
  80+ 57EB 7E           	LD A, (HL) ; get mask
  81+ 57EC D9           	EXX
  82+ 57ED 57           	LD D, A
  83+ 57EE 1E FF        	LD E, #FF
  84+ 57F0 37           	SCF
  85+ 57F1              .M1:
  86+ 57F1 18 FE        	JR .M1 ; this is self-modifying part
  87+ 57F3 CB 12        	RL D
  88+ 57F5 CB 13        	RL E
  89+ 57F7 CB 12        	RL D
  90+ 57F9 CB 13        	RL E
  91+ 57FB CB 12        	RL D
  92+ 57FD CB 13        	RL E
  93+ 57FF
  94+ 57FF 46           	LD B, (HL)
  95+ 5800 0E 00        	LD C, 0
  96+ 5802              .M2:
  97+ 5802 18 FE        	JR .M2 ; also self-modifying part
  98+ 5804 CB 20        	SLA B
  99+ 5806 CB 11        	RL C
 100+ 5808 CB 20        	SLA B
 101+ 580A CB 11        	RL C
 102+ 580C CB 20        	SLA B
 103+ 580E CB 11        	RL C
 104+ 5810
 105+ 5810 D9           	EXX
 106+ 5811 1A           	LD A, (DE) ; background
 107+ 5812 D9           	EXX
 108+ 5813 A3           	AND E
 109+ 5814 B1           	OR C
 110+ 5815 D9           	EXX
 111+ 5816 12           	LD (DE), A
 112+ 5817
 113+ 5817 0A           	LD A, (BC)
 114+ 5818 D9           	EXX
 115+ 5819 A2           	AND D
 116+ 581A B0           	OR B
 117+ 581B 23           	INC HL
 118+ 581C D9           	EXX
 119+ 581D 02           	LD (BC), A
 120+ 581E
 121+ 581E 23           	INC HL
 122+ 581F 13           	INC DE
 123+ 5820 03           	INC BC
 124+ 5821
 125+ 5821 08           	EX AF, AF'
 126+ 5822 3D           	DEC A
 127+ 5823 C2 EA 57     	JP NZ, SHIFT58
 128+ 5826 C9           	RET
 129+ 5827              ; *******************************************************************************************************
 130+ 5827
 131+ 5827              ; *******************************************************************************************************
 132+ 5827              ; routine that shifts one row of characters
 133+ 5827              ; contains self-modifying code that is set-up from external function
 134+ 5827              ; input HL=pointer to mask data
 135+ 5827              ; input HL'=pointer to character data
 136+ 5827              ; input DE=output buffer containing background data
 137+ 5827              ; input A=number of characters to process
 138+ 5827              ; input IX=pointer to structure describing input data
 139+ 5827              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 140+ 5827              SHIFT_ROW:
 141+ 5827 F5           	PUSH AF
 142+ 5828 ED 53 00 5F  		LD (BLIT_TMP1), DE
 143+ 582C E5           		PUSH HL
 144+ 582D CD 70 58     			CALL .ADDYSHIFT
 145+ 5830 E1           		POP HL
 146+ 5831 ED 53 02 5F  		LD (BLIT_TMP2), DE ; DE+vertical shift
 147+ 5835              .L1:
 148+ 5835 3E 08        		LD A, 8
 149+ 5837 DD 96 02     		SUB (IX+2) ; y shift
 150+ 583A              .CALL1:
 151+ 583A CD 00 00     		CALL 0
 152+ 583D DD 7E 02     		LD A, (IX+2); y shift
 153+ 5840 B7           		OR A
 154+ 5841 28 26        		JR Z, .DONE
 155+ 5843 ED 5B 00 5F  		LD DE, (BLIT_TMP1)
 156+ 5847 E5           		PUSH HL
 157+ 5848 CD 7E 58     			CALL .DETONEXTROW
 158+ 584B E1           		POP HL
 159+ 584C              .CALL2:
 160+ 584C CD 00 00     		CALL 0
 161+ 584F ED 5B 00 5F  		LD DE, (BLIT_TMP1)
 162+ 5853 E5           		PUSH HL
 163+ 5854 CD 78 58     			CALL .ADD8
 164+ 5857 E1           		POP HL
 165+ 5858 ED 53 00 5F  		LD (BLIT_TMP1), DE
 166+ 585C ED 5B 02 5F  		LD DE, (BLIT_TMP2)
 167+ 5860 E5           		PUSH HL
 168+ 5861 CD 78 58     			CALL .ADD8
 169+ 5864 E1           		POP HL
 170+ 5865 ED 53 02 5F  		LD (BLIT_TMP2), DE ; DE+vertical shift
 171+ 5869              .DONE:
 172+ 5869 F1           	POP AF
 173+ 586A 3D           	DEC A
 174+ 586B C8           	RET Z
 175+ 586C F5           	PUSH AF
 176+ 586D C3 35 58     	JP .L1
 177+ 5870              .ADDYSHIFT:
 178+ 5870 EB           	EX DE, HL
 179+ 5871 16 00        	LD D, 0
 180+ 5873 DD 5E 02     	LD E, (IX+2); y shift
 181+ 5876 18 0C        	JR .MOVDEBC
 182+ 5878              .ADD8:
 183+ 5878 21 08 00     	LD HL, 8
 184+ 587B C3 84 58     	JP .MOVDEBC
 185+ 587E              .DETONEXTROW:
 186+ 587E DD 6E 06     	LD L, (IX+6)
 187+ 5881 DD 66 07     	LD H, (IX+7) ; bkg add to value
 188+ 5884              .MOVDEBC:
 189+ 5884 19           	ADD HL, DE
 190+ 5885 54           	LD D, H
 191+ 5886 5D           	LD E, L
 192+ 5887 01 08 00     	LD BC, 8
 193+ 588A 09           	ADD HL, BC
 194+ 588B 44           	LD B, H
 195+ 588C 4D           	LD C, L
 196+ 588D C9           	RET
 197+ 588E              ; *******************************************************************************************************
 198+ 588E
 199+ 588E              ; *******************************************************************************************************
 200+ 588E              ; function rotates mask and character data and applies it to background
 201+ 588E              ; input IX=pointer to structure describing input data
 202+ 588E              ; +0  DW horizontal shift count 0-7 (low byte used)
 203+ 588E              ; +2  DW vertical shift count 0-7 (low byte used)
 204+ 588E              ; +4  DW background data start;
 205+ 588E              ; +6  DW background add to value to next row of background data
 206+ 588E              ; +8  DW mask data start;
 207+ 588E              ; +10  DW character data start;
 208+ 588E              ; +12 DW character&mask add to value to next row of data
 209+ 588E              ; +14 DW columns (low byte used)
 210+ 588E              ; +16 DW rows (low byte used)
 211+ 588E              SHIFT_MERGE_CHARACTER:
 212+ 588E DD 7E 00     	LD A, (IX) ; shift
 213+ 5891 FE 05        	CP 5
 214+ 5893 38 25        	JR C, .RIGHT
 215+ 5895              	; shifts 5-7, use rotate towards left 1-3
 216+ 5895 21 EA 57     	LD HL, SHIFT58
 217+ 5898 22 3B 58     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 218+ 589B 22 4D 58     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 219+ 589E D6 05        	SUB 5
 220+ 58A0 28 0D        	JR Z, .L1
 221+ 58A2 87           	ADD A, A
 222+ 58A3 87           	ADD A, A
 223+ 58A4 67           	LD H, A
 224+ 58A5 2E 18        	LD L, #18 ; JR opcode
 225+ 58A7 22 F1 57     	LD (SHIFT58.M1), HL
 226+ 58AA 22 02 58     	LD (SHIFT58.M2), HL
 227+ 58AD 18 32        	JR .DO
 228+ 58AF              .L1:
 229+ 58AF 21 00 00     	LD HL, 0 ; 2xNOP opcode
 230+ 58B2 22 F1 57     	LD (SHIFT58.M1), HL
 231+ 58B5 22 02 58     	LD (SHIFT58.M2), HL
 232+ 58B8 18 27        	JR .DO
 233+ 58BA              .RIGHT:
 234+ 58BA              	; shifts 0-4, rotate towards right
 235+ 58BA 21 A5 57     	LD HL, SHIFT04
 236+ 58BD 22 3B 58     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 237+ 58C0 22 4D 58     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 238+ 58C3 FE 04        	CP 4
 239+ 58C5 28 11        	JR Z, .R1
 240+ 58C7 D6 04        	SUB 4
 241+ 58C9 ED 44        	NEG
 242+ 58CB 87           	ADD A, A
 243+ 58CC 87           	ADD A, A
 244+ 58CD 67           	LD H, A
 245+ 58CE 2E 18        	LD L, #18 ; JR opcode
 246+ 58D0 22 AC 57     	LD (SHIFT04.M1), HL
 247+ 58D3 22 C1 57     	LD (SHIFT04.M2), HL
 248+ 58D6 18 09        	JR .DO
 249+ 58D8              .R1:
 250+ 58D8 21 00 00     	LD HL, 0 ; 2xNOP opcode
 251+ 58DB 22 AC 57     	LD (SHIFT04.M1), HL
 252+ 58DE 22 C1 57     	LD (SHIFT04.M2), HL
 253+ 58E1              .DO:
 254+ 58E1 DD 46 10     	LD B, (IX+16) ; rows
 255+ 58E4 DD 6E 08     	LD L, (IX+8)
 256+ 58E7 DD 66 09     	LD H, (IX+9) ; mask data
 257+ 58EA DD 5E 04     	LD E, (IX+4)
 258+ 58ED DD 56 05     	LD D, (IX+5) ; background data
 259+ 58F0 D9           	EXX
 260+ 58F1 DD 6E 0A     	LD L, (IX+10)
 261+ 58F4 DD 66 0B     	LD H, (IX+11) ; character data
 262+ 58F7 D9           	EXX
 263+ 58F8              .LOOP:
 264+ 58F8 C5           	PUSH BC
 265+ 58F9 E5           		PUSH HL
 266+ 58FA D5           			PUSH DE
 267+ 58FB D9           				EXX
 268+ 58FC E5           				PUSH HL
 269+ 58FD D9           					EXX
 270+ 58FE DD 7E 0E     					LD A, (IX+14) ; columns
 271+ 5901              .CALL:
 272+ 5901 CD 27 58     					CALL SHIFT_ROW
 273+ 5904 E1           				POP HL
 274+ 5905 DD 5E 0C     				LD E, (IX+12)
 275+ 5908 DD 56 0D     				LD D, (IX+13) ; char data to next row
 276+ 590B 19           				ADD HL, DE
 277+ 590C D9           				EXX
 278+ 590D E1           			POP HL
 279+ 590E DD 5E 06     			LD E, (IX+6)
 280+ 5911 DD 56 07     			LD D, (IX+7) ; background to next row
 281+ 5914 19           			ADD HL, DE
 282+ 5915 EB           			EX DE, HL
 283+ 5916 E1           		POP HL
 284+ 5917 DD 4E 0C     		LD C, (IX+12)
 285+ 591A DD 46 0D     		LD B, (IX+13) ; char data to next row
 286+ 591D 09           		ADD HL, BC
 287+ 591E C1           	POP BC
 288+ 591F 10 D7        	DJNZ .LOOP
 289+ 5921 C9           	RET
 290+ 5922              ; *******************************************************************************************************
 291+ 5922
 292+ 5922              ; *******************************************************************************************************
 293+ 5922              ; helper function DE \ 8
 294+ 5922              DEdiv8:
 295+ 5922 7B           	LD A,E
 296+ 5923 CB 2A        	SRA D
 297+ 5925 CB 1F            RR  A
 298+ 5927 CB 2A            SRA D
 299+ 5929 CB 1F            RR  A
 300+ 592B CB 2A            SRA D
 301+ 592D CB 1F            RR  A
 302+ 592F C9           	RET
 303+ 5930              ; *******************************************************************************************************
 304+ 5930
 305+ 5930               IF (1 == 1)
 306+ 5930              ; *******************************************************************************************************
 307+ 5930              ; function to handle BLIT basic extension through DEFUSR call in RAW format
 308+ 5930              ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 309+ 5930              ; +2  DW horizontal shift count 0-7 (low byte used)
 310+ 5930              ; +4  DW vertical shift count 0-7 (low byte used)
 311+ 5930              ; +6  DW background data start;
 312+ 5930              ; +8  DW background add to value to next row of background data
 313+ 5930              ; +10  DW mask data start;
 314+ 5930              ; +12  DW character data start;
 315+ 5930              ; +14 DW character&mask add to value to next row of data
 316+ 5930              ; +16 DW columns (low byte used)
 317+ 5930              ; +18 DW rows (low byte used)
 318+ 5930              ; will put ram in page 0 also, page 1 is already there
 319+ 5930              ;BLIT_DEFUSR:
 320+ 5930              ;	DI
 321+ 5930              ;	LD IY, .RET
 322+ 5930              ;	JP ENABLE_PAGE0
 323+ 5930              ;.RET:
 324+ 5930              ;	EI
 325+ 5930              ;	INC IX
 326+ 5930              ;	INC IX
 327+ 5930              ;	CALL SHIFT_MERGE_CHARACTER
 328+ 5930              ;
 329+ 5930              ;   POP DE
 330+ 5930              ;    POP BC
 331+ 5930              ;    JP RESTORE_PAGE_INFO
 332+ 5930              ; *******************************************************************************************************
 333+ 5930
 334+ 5930              ; *******************************************************************************************************
 335+ 5930              ; function to handle CALL BLIT basic extension in DEFUSR form
 336+ 5930              ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 337+ 5930              ; +02 x
 338+ 5930              ; +04 y
 339+ 5930              ; +06 char_data_pointer
 340+ 5930              ; +08 mask_data_pointer
 341+ 5930              ; +10 width
 342+ 5930              ; +12 height
 343+ 5930              ; +14 background_pointer
 344+ 5930              ; +16 background_width
 345+ 5930              ; BLIT ( INT x,
 346+ 5930              ;		 INT y,
 347+ 5930              ;		 INT char_data_pointer,
 348+ 5930              ;		 INT mask_data_pointer,
 349+ 5930              ;		 INT width (in characters),
 350+ 5930              ;		 INT height (in characters),
 351+ 5930              ;		 INT background_pointer (top left),
 352+ 5930              ;		 INT background_width (in characters),
 353+ 5930              BLIT_DEFUSR:
 354+ 5930 DD 5E 02     	LD E,(IX+2)
 355+ 5933 DD 56 03     	LD D,(IX+3)
 356+ 5936 7B           	LD A,E
 357+ 5937 E6 07        	AND 7
 358+ 5939 32 04 5F     	LD (BLIT_STRUCT+0),A
 359+ 593C CD 22 59     	CALL DEdiv8
 360+ 593F 32 00 5F     	LD (BLIT_TMP+0),A
 361+ 5942 DD 5E 04     	LD E,(IX+4)
 362+ 5945 DD 56 05     	LD D,(IX+5)
 363+ 5948 7B           	LD A,E
 364+ 5949 E6 07        	AND 7
 365+ 594B 32 06 5F     	LD (BLIT_STRUCT+2),A
 366+ 594E CD 22 59     	CALL DEdiv8
 367+ 5951 32 01 5F     	LD (BLIT_TMP+1),A
 368+ 5954 DD 6E 06     	LD L,(IX+6)
 369+ 5957 DD 66 07     	LD H,(IX+7)
 370+ 595A 22 0E 5F     	LD (BLIT_STRUCT+10),HL
 371+ 595D DD 6E 08     	LD L,(IX+8)
 372+ 5960 DD 66 09     	LD H,(IX+9)
 373+ 5963 22 0C 5F     	LD (BLIT_STRUCT+8),HL
 374+ 5966 DD 7E 0A     	LD A,(IX+10)
 375+ 5969 32 12 5F     	LD (BLIT_STRUCT+14),A
 376+ 596C DD 7E 0C     	LD A,(IX+12)
 377+ 596F 32 14 5F     	LD (BLIT_STRUCT+16),A
 378+ 5972 DD 6E 0E     	LD L,(IX+14)
 379+ 5975 DD 66 0F     	LD H,(IX+15)
 380+ 5978 22 08 5F     	LD (BLIT_STRUCT+4),HL
 381+ 597B              	;LD A,(IX+16)
 382+ 597B              	;LD (BLIT_TMP+2),A
 383+ 597B
 384+ 597B              	; calculate char&mask add to value
 385+ 597B 26 00        	LD H,0
 386+ 597D 3A 12 5F     	LD A,(BLIT_STRUCT+14)
 387+ 5980 6F           	LD L,A
 388+ 5981 CD 74 5F     	CALL HLx8
 389+ 5984 22 10 5F     	LD (BLIT_STRUCT+12),HL
 390+ 5987              	; calculate background add to value
 391+ 5987 26 00        	LD H,0
 392+ 5989 DD 6E 10     	LD L,(IX+16)
 393+ 598C CD 74 5F     	CALL HLx8
 394+ 598F 22 0A 5F     	LD (BLIT_STRUCT+6),HL
 395+ 5992              	; calculate pointer to background location
 396+ 5992 21 00 00     	LD HL,0
 397+ 5995 3A 01 5F     	LD A,(BLIT_TMP+1)
 398+ 5998 B7           	OR A
 399+ 5999 28 08        	JR Z, .L1
 400+ 599B 47           	LD B,A
 401+ 599C ED 5B 0A 5F  	LD DE,(BLIT_STRUCT+6)
 402+ 59A0              .L0:
 403+ 59A0 19           	ADD HL, DE
 404+ 59A1 10 FD        	DJNZ .L0
 405+ 59A3              .L1:
 406+ 59A3 EB           	EX DE,HL
 407+ 59A4 26 00        	LD H,0
 408+ 59A6 3A 00 5F     	LD A,(BLIT_TMP+0)
 409+ 59A9 6F           	LD L,A
 410+ 59AA CD 74 5F     	CALL HLx8
 411+ 59AD 19           	ADD HL,DE
 412+ 59AE ED 5B 08 5F  	LD DE,(BLIT_STRUCT+4)
 413+ 59B2 19           	ADD HL,DE
 414+ 59B3 22 08 5F     	LD (BLIT_STRUCT+4),HL
 415+ 59B6
 416+ 59B6 FD 21 BD 59  	LD IY, .RET
 417+ 59BA C3 38 60     	JP ENABLE_PAGE0
 418+ 59BD              .RET:
 419+ 59BD FB           	EI
 420+ 59BE DD 21 04 5F  	LD IX, BLIT_STRUCT
 421+ 59C2 CD 8E 58     	CALL SHIFT_MERGE_CHARACTER
 422+ 59C5
 423+ 59C5 D1               POP DE
 424+ 59C6 C1               POP BC
 425+ 59C7 C3 AF 5F         JP RESTORE_PAGE_INFO
 426+ 59CA              ; *******************************************************************************************************
 427+ 59CA               ENDIF
 428+ 59CA
 429+ 59CA               IF (0 == 1)
 430+ 59CA ~            ; *******************************************************************************************************
 431+ 59CA ~            ; function to handle CALL BLIT basic extension
 432+ 59CA ~            ; rotates 1-bit character drawing horizontally with mask and character data and
 433+ 59CA ~            ; fuses with background data and applies vertical shift too
 434+ 59CA ~            ; in form without pointers
 435+ 59CA ~            ; BLIT ( INT x,
 436+ 59CA ~            ;		 INT y,
 437+ 59CA ~            ;		 INT char_data_pointer,
 438+ 59CA ~            ;		 INT mask_data_pointer,
 439+ 59CA ~            ;		 INT width (in characters),
 440+ 59CA ~            ;		 INT height (in characters),
 441+ 59CA ~            ;		 INT background_pointer (top left),
 442+ 59CA ~            ;		 INT background_width (in characters),
 443+ 59CA ~            ; will put ram in page 0 also, page 1 is already there
 444+ 59CA ~            BLIT:
 445+ 59CA ~            	; opening (
 446+ 59CA ~            	CALL CHKCHAR
 447+ 59CA ~            	DB '('
 448+ 59CA ~            	; get x coordinate
 449+ 59CA ~            	LD IX, FRMQNT
 450+ 59CA ~            	CALL CALBAS
 451+ 59CA ~            	LD A, E
 452+ 59CA ~            	AND 7
 453+ 59CA ~            	LD (BLIT_STRUCT+0), A
 454+ 59CA ~            	CALL DEdiv8
 455+ 59CA ~            	LD (BLIT_TMP+0),A
 456+ 59CA ~            	; comma
 457+ 59CA ~            	CALL CHKCHAR
 458+ 59CA ~            	DB ','
 459+ 59CA ~            	; get y coordinate
 460+ 59CA ~            	LD IX, FRMQNT
 461+ 59CA ~            	CALL CALBAS
 462+ 59CA ~            	LD A, E
 463+ 59CA ~            	AND 7
 464+ 59CA ~            	LD (BLIT_STRUCT+2), A
 465+ 59CA ~            	CALL DEdiv8
 466+ 59CA ~            	LD (BLIT_TMP+1),A
 467+ 59CA ~            	; comma
 468+ 59CA ~            	CALL CHKCHAR
 469+ 59CA ~            	DB ','
 470+ 59CA ~            	; get char data pointer
 471+ 59CA ~            	LD IX, FRMQNT
 472+ 59CA ~            	CALL CALBAS
 473+ 59CA ~            	LD (BLIT_STRUCT+10), DE
 474+ 59CA ~            	; comma
 475+ 59CA ~            	CALL CHKCHAR
 476+ 59CA ~            	DB ','
 477+ 59CA ~            	; get mask data pointer
 478+ 59CA ~            	LD IX, FRMQNT
 479+ 59CA ~            	CALL CALBAS
 480+ 59CA ~            	LD (BLIT_STRUCT+8), DE
 481+ 59CA ~            	; comma
 482+ 59CA ~            	CALL CHKCHAR
 483+ 59CA ~            	DB ','
 484+ 59CA ~            	; get width
 485+ 59CA ~            	LD IX, FRMQNT
 486+ 59CA ~            	CALL CALBAS
 487+ 59CA ~            	LD A, E
 488+ 59CA ~            	LD (BLIT_STRUCT+14), A
 489+ 59CA ~            	; comma
 490+ 59CA ~            	CALL CHKCHAR
 491+ 59CA ~            	DB ','
 492+ 59CA ~            	; get height
 493+ 59CA ~            	LD IX, FRMQNT
 494+ 59CA ~            	CALL CALBAS
 495+ 59CA ~            	LD A, E
 496+ 59CA ~            	LD (BLIT_STRUCT+16), A
 497+ 59CA ~            	; comma
 498+ 59CA ~            	CALL CHKCHAR
 499+ 59CA ~            	DB ','
 500+ 59CA ~            	; get background pointer
 501+ 59CA ~            	LD IX, FRMQNT
 502+ 59CA ~            	CALL CALBAS
 503+ 59CA ~            	LD (BLIT_STRUCT+4), DE
 504+ 59CA ~            	; comma
 505+ 59CA ~            	CALL CHKCHAR
 506+ 59CA ~            	DB ','
 507+ 59CA ~            	; get background width
 508+ 59CA ~            	LD IX, FRMQNT
 509+ 59CA ~            	CALL CALBAS
 510+ 59CA ~            	LD A, E
 511+ 59CA ~            	LD (BLIT_TMP+2), A
 512+ 59CA ~            	; ending )
 513+ 59CA ~            	CALL CHKCHAR
 514+ 59CA ~            	DB ')'
 515+ 59CA ~
 516+ 59CA ~            	PUSH HL ; save position in BASIC buffer
 517+ 59CA ~
 518+ 59CA ~            	; calculate char&mask add to value
 519+ 59CA ~            	LD H, 0
 520+ 59CA ~            	LD A, (BLIT_STRUCT+14)
 521+ 59CA ~            	LD L, A
 522+ 59CA ~            	CALL HLx8
 523+ 59CA ~            	LD (BLIT_STRUCT+12), HL
 524+ 59CA ~            	; calculate background add to value
 525+ 59CA ~            	LD H, 0
 526+ 59CA ~            	LD A, (BLIT_TMP+2)
 527+ 59CA ~            	LD L, A
 528+ 59CA ~            	CALL HLx8
 529+ 59CA ~            	LD (BLIT_STRUCT+6), HL
 530+ 59CA ~            	; calculate pointer to background location
 531+ 59CA ~            	LD HL, 0
 532+ 59CA ~            	LD A,(BLIT_TMP+1)
 533+ 59CA ~            	OR A
 534+ 59CA ~            	JR Z, .L1
 535+ 59CA ~            	LD B,A
 536+ 59CA ~            	LD DE,(BLIT_STRUCT+6)
 537+ 59CA ~            .L0:
 538+ 59CA ~            	ADD HL, DE
 539+ 59CA ~            	DJNZ .L0
 540+ 59CA ~            .L1:
 541+ 59CA ~            	EX DE,HL
 542+ 59CA ~            	LD H,0
 543+ 59CA ~            	LD A,(BLIT_TMP+0)
 544+ 59CA ~            	LD L,A
 545+ 59CA ~            	CALL HLx8
 546+ 59CA ~            	ADD HL,DE
 547+ 59CA ~            	LD DE,(BLIT_STRUCT+4)
 548+ 59CA ~            	ADD HL,DE
 549+ 59CA ~            	LD (BLIT_STRUCT+4),HL
 550+ 59CA ~
 551+ 59CA ~            	LD IY, .RET
 552+ 59CA ~            	JP ENABLE_PAGE0
 553+ 59CA ~            .RET:
 554+ 59CA ~            	EI
 555+ 59CA ~            	LD IX, BLIT_STRUCT
 556+ 59CA ~            	CALL SHIFT_MERGE_CHARACTER
 557+ 59CA ~
 558+ 59CA ~                POP DE
 559+ 59CA ~                POP BC
 560+ 59CA ~                CALL RESTORE_PAGE_INFO
 561+ 59CA ~
 562+ 59CA ~            	POP HL
 563+ 59CA ~            	RET
 564+ 59CA ~            ; *******************************************************************************************************
 565+ 59CA               ENDIF
# file closed: asm\BLIT.asm
 164  59CA               ENDIF
 165  59CA
 166  59CA               IF (TILE_CMDS == 1)
 167  59CA               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
   1+ 59CA              ; *******************************************************************************************************
   2+ 59CA              ; generic function to implement tiling
   3+ 59CA              ; should be modified to call appropriate function for memory or vram
   4+ 59CA              ; input IX=pointer to following structure
   5+ 59CA              ; +00 tile_data_ptr
   6+ 59CA              ; +02 tile_rows
   7+ 59CA              ; +04 tile_columns
   8+ 59CA              ; +06 destination_address
   9+ 59CA              ; +08 dest_to_next_row_add_to_value
  10+ 59CA              ; +10 num_horizontal_tiles
  11+ 59CA              ; +12 num_vertical_tiles
  12+ 59CA              ; modifies AF, BC, DE, HL
  13+ 59CA              TILE:
  14+ 59CA DD 6E 06     	LD L, (IX+6)
  15+ 59CD DD 66 07     	LD H, (IX+7) ; destination address
  16+ 59D0 22 00 5F     	LD (TILETMP1), HL
  17+ 59D3 DD 46 0C     	LD B, (IX+12) ; vertical tile number
  18+ 59D6              .L1:
  19+ 59D6 C5           	PUSH BC
  20+ 59D7 DD 6E 00     		LD L, (IX+0)
  21+ 59DA DD 66 01     		LD H, (IX+1) ; tile address
  22+ 59DD 22 02 5F     		LD (TILETMP2), HL
  23+ 59E0 DD 46 02     		LD B, (IX+2) ; tile rows
  24+ 59E3              .L2:
  25+ 59E3 C5           		PUSH BC
  26+ 59E4 CD 00 00     .CALL1:		CALL 0
  27+ 59E7 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
  28+ 59EA              .L3:
  29+ 59EA C5           			PUSH BC
  30+ 59EB 2A 02 5F     				LD HL, (TILETMP2)
  31+ 59EE DD 46 04     				LD B, (IX+4) ; tile columns
  32+ 59F1              .L4:
  33+ 59F1 C5           				PUSH BC
  34+ 59F2              .CALL2:
  35+ 59F2 CD 00 00     					CALL 0
  36+ 59F5 C1           				POP BC
  37+ 59F6 10 F9        				DJNZ .L4
  38+ 59F8 C1           			POP BC
  39+ 59F9 10 EF        			DJNZ .L3
  40+ 59FB 22 02 5F     			LD (TILETMP2), HL
  41+ 59FE 2A 00 5F     			LD HL, (TILETMP1)
  42+ 5A01 DD 5E 08     			LD E, (IX+8)
  43+ 5A04 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
  44+ 5A07 19           			ADD HL, DE
  45+ 5A08 22 00 5F     			LD (TILETMP1), HL
  46+ 5A0B C1           		POP BC
  47+ 5A0C 10 D5        		DJNZ .L2
  48+ 5A0E C1           	POP BC
  49+ 5A0F 10 C5        	DJNZ .L1
  50+ 5A11 C9           	RET
  51+ 5A12              ; *******************************************************************************************************
  52+ 5A12
  53+ 5A12               IF (1 == 1)
  54+ 5A12              ; *******************************************************************************************************
  55+ 5A12              ; same as TILERAM but for DEFUSR approach
  56+ 5A12              ; input IX=pointer to input array, real data from +2
  57+ 5A12              ; +02 = tile data pointer
  58+ 5A12              ; +04 = tile columns
  59+ 5A12              ; +06 = tile rows
  60+ 5A12              ; +08 = destination pointer
  61+ 5A12              ; +10 = destination columns
  62+ 5A12              ; +12 = destination rows
  63+ 5A12              ; +14 = destination begin column
  64+ 5A12              ; +16 = destination begin row
  65+ 5A12              ; +18 = number of tiles horizontally
  66+ 5A12              ; +20 = number of tiles vertically
  67+ 5A12              ; *******************************************************************************************************
  68+ 5A12              TILERAM_DEFUSR:
  69+ 5A12              	; tile data pointer
  70+ 5A12 DD 6E 02     	LD L,(IX+2)
  71+ 5A15 DD 66 03     	LD H,(IX+3)
  72+ 5A18 22 04 5F     	LD (BLIT_STRUCT+0),HL
  73+ 5A1B              	; tile columns
  74+ 5A1B DD 6E 04     	LD L,(IX+4)
  75+ 5A1E DD 66 05     	LD H,(IX+5)
  76+ 5A21 22 08 5F     	LD (BLIT_STRUCT+4),HL
  77+ 5A24              	; tile rows
  78+ 5A24 DD 6E 06     	LD L,(IX+6)
  79+ 5A27 DD 66 07     	LD H,(IX+7)
  80+ 5A2A 22 06 5F     	LD (BLIT_STRUCT+2),HL
  81+ 5A2D              	; destintion pointer
  82+ 5A2D DD 6E 08     	LD L,(IX+8)
  83+ 5A30 DD 66 09     	LD H,(IX+9)
  84+ 5A33 22 0A 5F     	LD (BLIT_STRUCT+6),HL
  85+ 5A36              	; destination columns
  86+ 5A36 DD 7E 0A     	LD A,(IX+10)
  87+ 5A39 32 00 5F     	LD (BLIT_TMP+0),A
  88+ 5A3C              	; destination rows
  89+ 5A3C DD 7E 0C     	LD A,(IX+12)
  90+ 5A3F 32 01 5F     	LD (BLIT_TMP+1),A
  91+ 5A42              	; destination begin column
  92+ 5A42 DD 7E 0E     	LD A,(IX+14)
  93+ 5A45 32 02 5F     	LD (BLIT_TMP+2),A
  94+ 5A48              	; destination begin row
  95+ 5A48 DD 7E 10     	LD A,(IX+16)
  96+ 5A4B 32 03 5F     	LD (BLIT_TMP+3),A
  97+ 5A4E              	; number of tiles horizontally
  98+ 5A4E DD 6E 12     	LD L,(IX+18)
  99+ 5A51 DD 66 13     	LD H,(IX+19)
 100+ 5A54 22 0E 5F     	LD (BLIT_STRUCT+10),HL
 101+ 5A57              	; number of tiles vertically
 102+ 5A57 DD 6E 14     	LD L,(IX+20)
 103+ 5A5A DD 66 15     	LD H,(IX+21)
 104+ 5A5D 22 10 5F     	LD (BLIT_STRUCT+12),HL
 105+ 5A60               IF (0 == 1) ; otherwise we just continue with code below
 106+ 5A60 ~            	JP TILERAM.COMMON
 107+ 5A60               ENDIF
 108+ 5A60               ENDIF
 109+ 5A60
 110+ 5A60              ; *******************************************************************************************************
 111+ 5A60              ; function to handle CALL TILERAM basic extension
 112+ 5A60              ; fills memory with tiles
 113+ 5A60              ; TILERAM ( INT tile_data_pointer,
 114+ 5A60              ;			INT tile_columns,
 115+ 5A60              ;			INT tile_rows,
 116+ 5A60              ;			INT destination_pointer,
 117+ 5A60              ;			INT destination_columns,
 118+ 5A60              ;			INT destination_rows,
 119+ 5A60              ;			INT destination_begin_column,
 120+ 5A60              ;			INT destination_begin_row,
 121+ 5A60              ;			INT number_of_tiles_horizontally,
 122+ 5A60              ;			INT	number_of_tiles_vertically )
 123+ 5A60              ; will put ram in page 0 also, page 1 is already there
 124+ 5A60              TILERAM:
 125+ 5A60               IF (0 == 1)
 126+ 5A60 ~            	; opening (
 127+ 5A60 ~            	CALL CHKCHAR
 128+ 5A60 ~            	DB '('
 129+ 5A60 ~            	; get tile data pointer coordinate
 130+ 5A60 ~            	LD IX, FRMQNT
 131+ 5A60 ~            	CALL CALBAS
 132+ 5A60 ~            	LD (BLIT_STRUCT+0), DE
 133+ 5A60 ~            	; comma
 134+ 5A60 ~            	CALL CHKCHAR
 135+ 5A60 ~            	DB ','
 136+ 5A60 ~            	; get tile columns
 137+ 5A60 ~            	LD IX, FRMQNT
 138+ 5A60 ~            	CALL CALBAS
 139+ 5A60 ~            	LD (BLIT_STRUCT+4), DE
 140+ 5A60 ~            	; comma
 141+ 5A60 ~            	CALL CHKCHAR
 142+ 5A60 ~            	DB ','
 143+ 5A60 ~            	; get tile columns
 144+ 5A60 ~            	LD IX, FRMQNT
 145+ 5A60 ~            	CALL CALBAS
 146+ 5A60 ~            	LD (BLIT_STRUCT+2), DE
 147+ 5A60 ~            	; comma
 148+ 5A60 ~            	CALL CHKCHAR
 149+ 5A60 ~            	DB ','
 150+ 5A60 ~            	; get destintion pointer
 151+ 5A60 ~            	LD IX, FRMQNT
 152+ 5A60 ~            	CALL CALBAS
 153+ 5A60 ~            	LD (BLIT_STRUCT+6), DE
 154+ 5A60 ~            	; comma
 155+ 5A60 ~            	CALL CHKCHAR
 156+ 5A60 ~            	DB ','
 157+ 5A60 ~            	; get destination columns
 158+ 5A60 ~            	LD IX, FRMQNT
 159+ 5A60 ~            	CALL CALBAS
 160+ 5A60 ~            	LD A, E
 161+ 5A60 ~            	LD (BLIT_TMP+0), A
 162+ 5A60 ~            	; comma
 163+ 5A60 ~            	CALL CHKCHAR
 164+ 5A60 ~            	DB ','
 165+ 5A60 ~            	; get destination rows
 166+ 5A60 ~            	LD IX, FRMQNT
 167+ 5A60 ~            	CALL CALBAS
 168+ 5A60 ~            	LD A, E
 169+ 5A60 ~            	LD (BLIT_TMP+1), A
 170+ 5A60 ~            	; comma
 171+ 5A60 ~            	CALL CHKCHAR
 172+ 5A60 ~            	DB ','
 173+ 5A60 ~            	; get destination begin column
 174+ 5A60 ~            	LD IX, FRMQNT
 175+ 5A60 ~            	CALL CALBAS
 176+ 5A60 ~            	LD A, E
 177+ 5A60 ~            	LD (BLIT_TMP+2), A
 178+ 5A60 ~            	; comma
 179+ 5A60 ~            	CALL CHKCHAR
 180+ 5A60 ~            	DB ','
 181+ 5A60 ~            	; get destination begin row
 182+ 5A60 ~            	LD IX, FRMQNT
 183+ 5A60 ~            	CALL CALBAS
 184+ 5A60 ~            	LD A, E
 185+ 5A60 ~            	LD (BLIT_TMP+3), A
 186+ 5A60 ~            	; comma
 187+ 5A60 ~            	CALL CHKCHAR
 188+ 5A60 ~            	DB ','
 189+ 5A60 ~            	; get number of tiles horizontally
 190+ 5A60 ~            	LD IX, FRMQNT
 191+ 5A60 ~            	CALL CALBAS
 192+ 5A60 ~            	LD (BLIT_STRUCT+10), DE
 193+ 5A60 ~            	; comma
 194+ 5A60 ~            	CALL CHKCHAR
 195+ 5A60 ~            	DB ','
 196+ 5A60 ~            	; get number of tiles vertically
 197+ 5A60 ~            	LD IX, FRMQNT
 198+ 5A60 ~            	CALL CALBAS
 199+ 5A60 ~            	LD (BLIT_STRUCT+12), DE
 200+ 5A60 ~            	; ending )
 201+ 5A60 ~            	CALL CHKCHAR
 202+ 5A60 ~            	DB ')'
 203+ 5A60               ENDIF
 204+ 5A60              .COMMON:
 205+ 5A60 E5           	PUSH HL ; save position in BASIC buffer
 206+ 5A61
 207+ 5A61              	; calculate destination add to value
 208+ 5A61 26 00        	LD H, 0
 209+ 5A63 3A 00 5F     	LD A, (BLIT_TMP+0)
 210+ 5A66 6F           	LD L, A
 211+ 5A67 CD 74 5F     	CALL HLx8
 212+ 5A6A 22 0C 5F     	LD (BLIT_STRUCT+8), HL
 213+ 5A6D              	; calculate pointer to background location
 214+ 5A6D 21 00 00     	LD HL, 0
 215+ 5A70 3A 03 5F     	LD A,(BLIT_TMP+3)
 216+ 5A73 B7           	OR A
 217+ 5A74 28 08        	JR Z, .L1
 218+ 5A76 47           	LD B,A
 219+ 5A77 ED 5B 0C 5F  	LD DE,(BLIT_STRUCT+8)
 220+ 5A7B              .L0:
 221+ 5A7B 19           	ADD HL, DE
 222+ 5A7C 10 FD        	DJNZ .L0
 223+ 5A7E              .L1:
 224+ 5A7E EB           	EX DE,HL
 225+ 5A7F 26 00        	LD H,0
 226+ 5A81 3A 02 5F     	LD A,(BLIT_TMP+2)
 227+ 5A84 6F           	LD L,A
 228+ 5A85 CD 74 5F     	CALL HLx8
 229+ 5A88 19           	ADD HL,DE
 230+ 5A89 ED 5B 0A 5F  	LD DE,(BLIT_STRUCT+6)
 231+ 5A8D 19           	ADD HL,DE
 232+ 5A8E 22 0A 5F     	LD (BLIT_STRUCT+6),HL
 233+ 5A91 FD 21 98 5A  	LD IY, .RET
 234+ 5A95 C3 38 60     	JP ENABLE_PAGE0
 235+ 5A98              .RET:
 236+ 5A98 FB           	EI
 237+ 5A99              	; set RAM functions to call
 238+ 5A99 21 B3 5A     	LD HL, .TILECOPY
 239+ 5A9C 22 F3 59     	LD (TILE.CALL2+1), HL
 240+ 5A9F 21 C4 5A     	LD HL, .SETDESTROW
 241+ 5AA2 22 E5 59     	LD (TILE.CALL1+1), HL
 242+ 5AA5 DD 21 04 5F  	LD IX,BLIT_STRUCT
 243+ 5AA9 CD CA 59     	CALL TILE
 244+ 5AAC
 245+ 5AAC D1               POP DE
 246+ 5AAD C1               POP BC
 247+ 5AAE CD AF 5F         CALL RESTORE_PAGE_INFO
 248+ 5AB1
 249+ 5AB1 E1           	POP HL
 250+ 5AB2 C9           	RET
 251+ 5AB3              .TILECOPY:
 252+ 5AB3 ED A0       > LDI
 252+ 5AB5 ED A0       > LDI
 252+ 5AB7 ED A0       > LDI
 252+ 5AB9 ED A0       > LDI
 252+ 5ABB ED A0       > LDI
 252+ 5ABD ED A0       > LDI
 252+ 5ABF ED A0       > LDI
 252+ 5AC1 ED A0       > LDI
 253+ 5AC3 C9           	RET
 254+ 5AC4              .SETDESTROW:
 255+ 5AC4 ED 5B 00 5F  	LD DE, (TILETMP1)
 256+ 5AC8 C9           	RET
 257+ 5AC9              ; *******************************************************************************************************
 258+ 5AC9
 259+ 5AC9               IF (1 == 1)
 260+ 5AC9              ; *******************************************************************************************************
 261+ 5AC9              ; same as TILEVRM but for DEFUSR approach
 262+ 5AC9              ; input IX=pointer to input array, real data from +2
 263+ 5AC9              ; +02 = tile data pointer
 264+ 5AC9              ; +04 = tile columns
 265+ 5AC9              ; +06 = tile rows
 266+ 5AC9              ; +08 = destination begin column
 267+ 5AC9              ; +10 = destination begin row
 268+ 5AC9              ; +12 = number of tiles horizontally
 269+ 5AC9              ; +14 = number of tiles vertically
 270+ 5AC9              ; *******************************************************************************************************
 271+ 5AC9              TILEVRM_DEFUSR:
 272+ 5AC9              	; tile data pointer
 273+ 5AC9 DD 6E 02     	LD L,(IX+2)
 274+ 5ACC DD 66 03     	LD H,(IX+3)
 275+ 5ACF 22 04 5F     	LD (BLIT_STRUCT+0),HL
 276+ 5AD2              	; tile columns
 277+ 5AD2 DD 6E 04     	LD L,(IX+4)
 278+ 5AD5 DD 66 05     	LD H,(IX+5)
 279+ 5AD8 22 08 5F     	LD (BLIT_STRUCT+4),HL
 280+ 5ADB              	; tile rows
 281+ 5ADB DD 6E 06     	LD L,(IX+6)
 282+ 5ADE DD 66 07     	LD H,(IX+7)
 283+ 5AE1 22 06 5F     	LD (BLIT_STRUCT+2),HL
 284+ 5AE4              	; destination begin column
 285+ 5AE4 DD 7E 08     	LD A,(IX+8)
 286+ 5AE7 32 02 5F     	LD (BLIT_TMP+2),A
 287+ 5AEA              	; destination begin row
 288+ 5AEA DD 7E 0A     	LD A,(IX+10)
 289+ 5AED 32 03 5F     	LD (BLIT_TMP+3),A
 290+ 5AF0              	; number of tiles horizontally
 291+ 5AF0 DD 6E 0C     	LD L,(IX+12)
 292+ 5AF3 DD 66 0D     	LD H,(IX+13)
 293+ 5AF6 22 0E 5F     	LD (BLIT_STRUCT+10),HL
 294+ 5AF9              	; number of tiles vertically
 295+ 5AF9 DD 6E 0E     	LD L,(IX+14)
 296+ 5AFC DD 66 0F     	LD H,(IX+15)
 297+ 5AFF 22 10 5F     	LD (BLIT_STRUCT+12),HL
 298+ 5B02               IF (0 == 1) ; otherwise we just continue with code below
 299+ 5B02 ~            	JP TILEVRM.COMMON
 300+ 5B02               ENDIF
 301+ 5B02               ENDIF
 302+ 5B02
 303+ 5B02              ; *******************************************************************************************************
 304+ 5B02              ; function to handle CALL TILEVRM basic extension
 305+ 5B02              ; fills vram with tiles
 306+ 5B02              ; TILEVRM ( INT tile_data_pointer,
 307+ 5B02              ;			INT tile_columns,
 308+ 5B02              ;			INT tile_rows,
 309+ 5B02              ;			INT destination_begin_column,
 310+ 5B02              ;			INT destination_begin_row,
 311+ 5B02              ;			INT number_of_tiles_horizontally,
 312+ 5B02              ;			INT	number_of_tiles_vertically )
 313+ 5B02              ; will put ram in page 0 also, page 1 is already there
 314+ 5B02              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
 315+ 5B02              TILEVRM:
 316+ 5B02               IF (0 == 1)
 317+ 5B02 ~            	; opening (
 318+ 5B02 ~            	CALL CHKCHAR
 319+ 5B02 ~            	DB '('
 320+ 5B02 ~            	; get tile data pointer coordinate
 321+ 5B02 ~            	LD IX, FRMQNT
 322+ 5B02 ~            	CALL CALBAS
 323+ 5B02 ~            	LD (BLIT_STRUCT+0), DE
 324+ 5B02 ~            	; comma
 325+ 5B02 ~            	CALL CHKCHAR
 326+ 5B02 ~            	DB ','
 327+ 5B02 ~            	; get tile columns
 328+ 5B02 ~            	LD IX, FRMQNT
 329+ 5B02 ~            	CALL CALBAS
 330+ 5B02 ~            	LD (BLIT_STRUCT+4), DE
 331+ 5B02 ~            	; comma
 332+ 5B02 ~            	CALL CHKCHAR
 333+ 5B02 ~            	DB ','
 334+ 5B02 ~            	; get tile columns
 335+ 5B02 ~            	LD IX, FRMQNT
 336+ 5B02 ~            	CALL CALBAS
 337+ 5B02 ~            	LD (BLIT_STRUCT+2), DE
 338+ 5B02 ~            	; comma
 339+ 5B02 ~            	CALL CHKCHAR
 340+ 5B02 ~            	DB ','
 341+ 5B02 ~            	; get destination begin column
 342+ 5B02 ~            	LD IX, FRMQNT
 343+ 5B02 ~            	CALL CALBAS
 344+ 5B02 ~            	LD A, E
 345+ 5B02 ~            	LD (BLIT_TMP+2), A
 346+ 5B02 ~            	; comma
 347+ 5B02 ~            	CALL CHKCHAR
 348+ 5B02 ~            	DB ','
 349+ 5B02 ~            	; get destination begin row
 350+ 5B02 ~            	LD IX, FRMQNT
 351+ 5B02 ~            	CALL CALBAS
 352+ 5B02 ~            	LD A, E
 353+ 5B02 ~            	LD (BLIT_TMP+3), A
 354+ 5B02 ~            	; comma
 355+ 5B02 ~            	CALL CHKCHAR
 356+ 5B02 ~            	DB ','
 357+ 5B02 ~            	; get number of tiles horizontally
 358+ 5B02 ~            	LD IX, FRMQNT
 359+ 5B02 ~            	CALL CALBAS
 360+ 5B02 ~            	LD (BLIT_STRUCT+10), DE
 361+ 5B02 ~            	; comma
 362+ 5B02 ~            	CALL CHKCHAR
 363+ 5B02 ~            	DB ','
 364+ 5B02 ~            	; get number of tiles vertically
 365+ 5B02 ~            	LD IX, FRMQNT
 366+ 5B02 ~            	CALL CALBAS
 367+ 5B02 ~            	LD (BLIT_STRUCT+12), DE
 368+ 5B02 ~            	; ending )
 369+ 5B02 ~            	CALL CHKCHAR
 370+ 5B02 ~            	DB ')'
 371+ 5B02               ENDIF
 372+ 5B02
 373+ 5B02              .COMMON:
 374+ 5B02 E5           	PUSH HL ; save position in BASIC buffer
 375+ 5B03
 376+ 5B03              	; calculate destination add to value
 377+ 5B03 21 00 01     	LD HL, 256
 378+ 5B06 22 0C 5F     	LD (BLIT_STRUCT+8), HL
 379+ 5B09              	; calculate pointer to background location
 380+ 5B09 3A 03 5F     	LD A,(BLIT_TMP+3)
 381+ 5B0C 67           	LD H,A
 382+ 5B0D 2E 00        	LD L,0
 383+ 5B0F EB           	EX DE,HL
 384+ 5B10 26 00        	LD H,0
 385+ 5B12 3A 02 5F     	LD A,(BLIT_TMP+2)
 386+ 5B15 6F           	LD L,A
 387+ 5B16 CD 74 5F     	CALL HLx8
 388+ 5B19 19           	ADD HL,DE
 389+ 5B1A ED 5B CB F3  	LD DE,(GRPCGP)
 390+ 5B1E 19           	ADD HL,DE
 391+ 5B1F 22 0A 5F     	LD (BLIT_STRUCT+6),HL
 392+ 5B22 FD 21 29 5B  	LD IY, .RET
 393+ 5B26 C3 38 60     	JP ENABLE_PAGE0
 394+ 5B29              .RET:
 395+ 5B29 FB           	EI
 396+ 5B2A              	; set RAM functions to call
 397+ 5B2A 21 44 5B     	LD HL, .TILECOPY
 398+ 5B2D 22 F3 59     	LD (TILE.CALL2+1), HL
 399+ 5B30 21 4A 5B     	LD HL, .SETDESTROW
 400+ 5B33 22 E5 59     	LD (TILE.CALL1+1), HL
 401+ 5B36 DD 21 04 5F  	LD IX,BLIT_STRUCT
 402+ 5B3A CD CA 59     	CALL TILE
 403+ 5B3D
 404+ 5B3D D1               POP DE
 405+ 5B3E C1               POP BC
 406+ 5B3F CD AF 5F         CALL RESTORE_PAGE_INFO
 407+ 5B42
 408+ 5B42 E1           	POP HL
 409+ 5B43 C9           	RET
 410+ 5B44              .TILECOPY:
 411+ 5B44 01 98 08     	LD BC, #0898
 412+ 5B47 C3 6C 5F     	JP BBYTECOPY_NO_C
 413+ 5B4A              .SETDESTROW:
 414+ 5B4A 2A 00 5F     	LD HL, (TILETMP1)
 415+ 5B4D F3           	DI
 416+ 5B4E CD 55 5F     	CALL SETWRT_LOCAL_WRITE
 417+ 5B51 FB           	EI
 418+ 5B52 C9           	RET
 419+ 5B53              ; *******************************************************************************************************
 420+ 5B53
# file closed: asm\TILE.asm
 168  5B53               ENDIF
 169  5B53
 170  5B53               IF (COLL_CMD == 1)
 171  5B53               INCLUDE "COLLISION.asm"
# file opened: asm\COLLISION.asm
   1+ 5B53              ; generic collision checking routines
   2+ 5B53              ; in BASIC we use rectangle structure array DIM R%(7,n) of the format
   3+ 5B53              ; R%(0,n) is active flag, <>0 active / 0 skipped in checks
   4+ 5B53              ; R%(1,n) is either upper left x coordinate or sprite id (0-31) depending on R(7,n)
   5+ 5B53              ; R%(2,n) is either upper left y coordinate or unused depending on R(7,n)
   6+ 5B53              ; R%(3,n) x offset where rectangle begins
   7+ 5B53              ; R%(4,n) y offset where rectangle begins
   8+ 5B53              ; R%(5,n) is width
   9+ 5B53              ; R%(6,n) is height
  10+ 5B53              ; R%(7,0) is type, 0=generic where R%(1,0) contains x coordinate
  11+ 5B53              ;                  <>0 sprite where R%(1,0) contains sprite id
  12+ 5B53              ; for type sprite, upper left coordinates are taken from sprite attribute array
  13+ 5B53
  14+ 5B53              ; ************************************************************************************************
  15+ 5B53              ; quick test if HL<=DE<=HL+BC
  16+ 5B53              ; input BC=width, DE=x, HL=min
  17+ 5B53              ; if not true flag C set
  18+ 5B53              ; modifies AF
  19+ 5B53              GENERIC_INNER_CHECK:
  20+ 5B53 E5               PUSH HL
  21+ 5B54 D5               PUSH DE
  22+ 5B55 EB               EX DE,HL
  23+ 5B56 A7               AND A
  24+ 5B57 ED 52            SBC HL, DE
  25+ 5B59 FA 67 5B         JP M, .GENERIC_INNER_CHECK_NOT
  26+ 5B5C A7               AND A
  27+ 5B5D ED 42            SBC HL, BC
  28+ 5B5F 28 03            JR Z, .L2
  29+ 5B61 F2 67 5B         JP P, .GENERIC_INNER_CHECK_NOT
  30+ 5B64              .L2:
  31+ 5B64 A7               AND A
  32+ 5B65 18 01            JR .EXIT
  33+ 5B67              .GENERIC_INNER_CHECK_NOT:
  34+ 5B67 37               SCF
  35+ 5B68              .EXIT:
  36+ 5B68 D1               POP DE
  37+ 5B69 E1               POP HL
  38+ 5B6A C9               RET
  39+ 5B6B              ; ************************************************************************************************
  40+ 5B6B
  41+ 5B6B              ; ************************************************************************************************
  42+ 5B6B              ; function to check if rectangles are overlapping
  43+ 5B6B              ; input IX=IY=pointer to struct
  44+ 5B6B              ;  +00 active flag
  45+ 5B6B              ;  +02 x coordinate
  46+ 5B6B              ;  +04 y coordinate
  47+ 5B6B              ;  +06 x offset where rectangle begins
  48+ 5B6B              ;  +08 y offset where rectangle begins
  49+ 5B6B              ;  +10 width
  50+ 5B6B              ;  +12 height
  51+ 5B6B              ; where IY is used to read +2 and +4, and IX to read +6, +8, +10 and +12
  52+ 5B6B              ; this is a hack to allow location being taken from sprite attributes table
  53+ 5B6B              ; input BLIT_STRUCT data
  54+ 5B6B              ;  +00 x coordinate
  55+ 5B6B              ;  +02 y coordinate
  56+ 5B6B              ;  +04 width
  57+ 5B6B              ;  +06 height
  58+ 5B6B              ; returns CF=1 if not overlapping, CF=0 if overlapping
  59+ 5B6B              RECTANGLE_OVERLAP_CHECK:
  60+ 5B6B                  ; first check which rectangle is higher
  61+ 5B6B DD 6E 0C         LD L,(IX+12)
  62+ 5B6E DD 66 0D         LD H,(IX+13)
  63+ 5B71 ED 5B 0A 5F      LD DE,(BLIT_STRUCT+6)
  64+ 5B75 A7               AND A
  65+ 5B76 ED 52            SBC HL,DE
  66+ 5B78 FD 6E 04         LD L,(IY+4)
  67+ 5B7B FD 66 05         LD H,(IY+5)
  68+ 5B7E DD 5E 08         LD E,(IX+8)
  69+ 5B81 DD 56 09         LD D,(IX+9)
  70+ 5B84 FA A4 5B         JP M,.L1
  71+ 5B87                  ; equally high or IX defined one higher
  72+ 5B87                  ; check upper boundary
  73+ 5B87 19               ADD HL,DE
  74+ 5B88 ED 5B 06 5F      LD DE,(BLIT_STRUCT+2)
  75+ 5B8C DD 4E 0C         LD C,(IX+12)
  76+ 5B8F DD 46 0D         LD B,(IX+13)
  77+ 5B92 CD 53 5B         CALL GENERIC_INNER_CHECK
  78+ 5B95 30 29            JR NC,.INSIDE
  79+ 5B97                  ; check lower boundary
  80+ 5B97 E5               PUSH HL
  81+ 5B98 2A 0A 5F         LD HL,(BLIT_STRUCT+6)
  82+ 5B9B 19               ADD HL,DE
  83+ 5B9C EB               EX DE,HL
  84+ 5B9D E1               POP HL
  85+ 5B9E CD 53 5B         CALL GENERIC_INNER_CHECK
  86+ 5BA1 30 1D            JR NC,.INSIDE
  87+ 5BA3 C9               RET ; not overlapping
  88+ 5BA4              .L1:
  89+ 5BA4                  ; rectangle defined in BLIT_STRUCT is higher
  90+ 5BA4 19               ADD HL,DE
  91+ 5BA5 EB               EX DE,HL
  92+ 5BA6 2A 06 5F         LD HL,(BLIT_STRUCT+2)
  93+ 5BA9 ED 4B 0A 5F      LD BC,(BLIT_STRUCT+6)
  94+ 5BAD CD 53 5B         CALL GENERIC_INNER_CHECK
  95+ 5BB0 30 0E            JR NC,.INSIDE
  96+ 5BB2 E5               PUSH HL
  97+ 5BB3 DD 6E 0C         LD L,(IX+12)
  98+ 5BB6 DD 66 0D         LD H,(IX+13)
  99+ 5BB9 19               ADD HL,DE
 100+ 5BBA EB               EX DE,HL
 101+ 5BBB E1               POP HL
 102+ 5BBC CD 53 5B         CALL GENERIC_INNER_CHECK
 103+ 5BBF D8               RET C
 104+ 5BC0              .INSIDE:
 105+ 5BC0                  ; check x coordinate
 106+ 5BC0                  ; first check which rectangle is wider
 107+ 5BC0 DD 6E 0A         LD L,(IX+10)
 108+ 5BC3 DD 66 0B         LD H,(IX+11)
 109+ 5BC6 ED 5B 08 5F      LD DE,(BLIT_STRUCT+4)
 110+ 5BCA A7               AND A
 111+ 5BCB ED 52            SBC HL,DE
 112+ 5BCD FD 6E 02         LD L,(IY+2)
 113+ 5BD0 FD 66 03         LD H,(IY+3)
 114+ 5BD3 DD 5E 06         LD E,(IX+6)
 115+ 5BD6 DD 56 07         LD D,(IX+7)
 116+ 5BD9 FA F5 5B         JP M,.L2
 117+ 5BDC                  ; equally wide or IX defined one wider
 118+ 5BDC                  ; check left boundary
 119+ 5BDC 19               ADD HL,DE
 120+ 5BDD ED 5B 04 5F      LD DE,(BLIT_STRUCT+0)
 121+ 5BE1 DD 4E 0A         LD C,(IX+10)
 122+ 5BE4 DD 46 0B         LD B,(IX+11)
 123+ 5BE7 CD 53 5B         CALL GENERIC_INNER_CHECK
 124+ 5BEA D0               RET NC ; overlap
 125+ 5BEB                  ; check right boundary
 126+ 5BEB E5               PUSH HL
 127+ 5BEC 2A 08 5F         LD HL,(BLIT_STRUCT+4)
 128+ 5BEF 19               ADD HL,DE
 129+ 5BF0 EB               EX DE,HL
 130+ 5BF1 E1               POP HL
 131+ 5BF2 C3 53 5B         JP GENERIC_INNER_CHECK ; CF and result set by fn call
 132+ 5BF5              .L2:
 133+ 5BF5                  ; rectangle defined in BLIT_STRUCT is higher
 134+ 5BF5 19               ADD HL,DE
 135+ 5BF6 EB               EX DE,HL
 136+ 5BF7 2A 04 5F         LD HL,(BLIT_STRUCT+0)
 137+ 5BFA ED 4B 08 5F      LD BC,(BLIT_STRUCT+4)
 138+ 5BFE CD 53 5B         CALL GENERIC_INNER_CHECK
 139+ 5C01 D0               RET NC ; overlap
 140+ 5C02 E5               PUSH HL
 141+ 5C03 DD 6E 0A         LD L,(IX+10)
 142+ 5C06 DD 66 0B         LD H,(IX+11)
 143+ 5C09 19               ADD HL,DE
 144+ 5C0A EB               EX DE,HL
 145+ 5C0B E1               POP HL
 146+ 5C0C C3 53 5B         JP GENERIC_INNER_CHECK
 147+ 5C0F              ; ************************************************************************************************
 148+ 5C0F
 149+ 5C0F              ; ************************************************************************************************
 150+ 5C0F              ; function tries to find rectangle overlap and returns an index if found
 151+ 5C0F              ; input BLIT_STRUCT data
 152+ 5C0F              ;  +00 x coordinate
 153+ 5C0F              ;  +02 y coordinate
 154+ 5C0F              ;  +04 width
 155+ 5C0F              ;  +06 height
 156+ 5C0F              ;  +08 number of items in a list, described under RECTANGLE_OVERLAP_CHECK
 157+ 5C0F              ;  +09 pointer to first element of R%(7,n)
 158+ 5C0F              ;  +11 pointer to INT result variable
 159+ 5C0F              ; returns CF=1 if not overlapping
 160+ 5C0F              ; returns A=list index and CF=0 if overlapping
 161+ 5C0F              FIND_OVERLAP:
 162+ 5C0F 3A 0C 5F         LD A,(BLIT_STRUCT+8)
 163+ 5C12 47               LD B,A
 164+ 5C13 DD 2A 0D 5F      LD IX,(BLIT_STRUCT+9)
 165+ 5C17              .L1:
 166+ 5C17 C5               PUSH BC
 167+ 5C18                  ; check active flag
 168+ 5C18 DD 7E 00         LD A,(IX)
 169+ 5C1B DD B6 01         OR (IX+1)
 170+ 5C1E 28 18            JR Z,.NEXT
 171+ 5C20                  ; check type
 172+ 5C20 DD 7E 0E         LD A,(IX+14)
 173+ 5C23 DD B6 0F         OR (IX+15)
 174+ 5C26 20 1A            JR NZ,.L2
 175+ 5C28 DD E5            PUSH IX
 176+ 5C2A FD E1            POP IY
 177+ 5C2C              .L3:
 178+ 5C2C CD 6B 5B         CALL RECTANGLE_OVERLAP_CHECK
 179+ 5C2F 38 07            JR C,.NEXT
 180+ 5C31                  ; found
 181+ 5C31 C1               POP BC
 182+ 5C32 3A 0C 5F         LD A,(BLIT_STRUCT+8)
 183+ 5C35 90               SUB B
 184+ 5C36 A7               AND A
 185+ 5C37 C9               RET
 186+ 5C38              .NEXT:
 187+ 5C38 11 10 00         LD DE,16
 188+ 5C3B DD 19            ADD IX,DE
 189+ 5C3D C1               POP BC
 190+ 5C3E 10 D7            DJNZ .L1
 191+ 5C40 37               SCF
 192+ 5C41 C9               RET
 193+ 5C42              .L2:
 194+ 5C42                  ; sprite, need to build a temporary data struct since x and y values are inversed
 195+ 5C42                  ; at BLIT_STRUCT+13
 196+ 5C42 DD 7E 02         LD A,(IX+2) ; sprite ID
 197+ 5C45 CD 89 4D         CALL GETnthSPRATTR
 198+ 5C48 FD 21 0F 5F      LD IY,BLIT_STRUCT+11
 199+ 5C4C 7E               LD A,(HL)
 200+ 5C4D FD 77 04         LD (IY+4),A
 201+ 5C50 23               INC HL
 202+ 5C51 7E               LD A,(HL)
 203+ 5C52 FD 77 05         LD (IY+5),A
 204+ 5C55 23               INC HL
 205+ 5C56 7E               LD A,(HL)
 206+ 5C57 FD 77 02         LD (IY+2),A
 207+ 5C5A 23               INC HL
 208+ 5C5B 7E               LD A,(HL)
 209+ 5C5C FD 77 03         LD (IY+3),A
 210+ 5C5F 18 CB            JR .L3
 211+ 5C61              ; ************************************************************************************************
 212+ 5C61
 213+ 5C61               IF (0 == 1)
 214+ 5C61 ~            ; ************************************************************************************************
 215+ 5C61 ~            ; function to handle CALL COLL basic extension
 216+ 5C61 ~            ; checks for collision between player and other rectangles
 217+ 5C61 ~            ; COLL ( INT result variable,
 218+ 5C61 ~            ;	     INT player x value,
 219+ 5C61 ~            ;	     INT player y value,
 220+ 5C61 ~            ;	     INT player width,
 221+ 5C61 ~            ;	     INT player height,
 222+ 5C61 ~            ;	     INT number of items in a list,
 223+ 5C61 ~            ;		 INT[6][n] rectangle struct )
 224+ 5C61 ~            ; will fill result variable with index or -1 if no collision
 225+ 5C61 ~            ; rectangle struct described under RECTANGLE_OVERLAP_CHECK
 226+ 5C61 ~            COLL:
 227+ 5C61 ~            	; opening (
 228+ 5C61 ~            	CALL CHKCHAR
 229+ 5C61 ~            	DB '('
 230+ 5C61 ~            	; get address of result variable
 231+ 5C61 ~            	LD IX, PTRGET
 232+ 5C61 ~            	CALL CALBAS
 233+ 5C61 ~            	LD (BLIT_STRUCT+11),DE
 234+ 5C61 ~            	; comma
 235+ 5C61 ~            	CALL CHKCHAR
 236+ 5C61 ~            	DB ','
 237+ 5C61 ~            	; get x
 238+ 5C61 ~            	LD IX, FRMQNT
 239+ 5C61 ~            	CALL CALBAS
 240+ 5C61 ~            	LD (BLIT_STRUCT+0),DE
 241+ 5C61 ~            	; comma
 242+ 5C61 ~            	CALL CHKCHAR
 243+ 5C61 ~            	DB ','
 244+ 5C61 ~            	; get y
 245+ 5C61 ~            	LD IX, FRMQNT
 246+ 5C61 ~            	CALL CALBAS
 247+ 5C61 ~            	LD (BLIT_STRUCT+2),DE
 248+ 5C61 ~            	; comma
 249+ 5C61 ~            	CALL CHKCHAR
 250+ 5C61 ~            	DB ','
 251+ 5C61 ~            	; get width
 252+ 5C61 ~            	LD IX, FRMQNT
 253+ 5C61 ~            	CALL CALBAS
 254+ 5C61 ~            	LD (BLIT_STRUCT+4),DE
 255+ 5C61 ~            	; comma
 256+ 5C61 ~            	CALL CHKCHAR
 257+ 5C61 ~            	DB ','
 258+ 5C61 ~            	; get height
 259+ 5C61 ~            	LD IX, FRMQNT
 260+ 5C61 ~            	CALL CALBAS
 261+ 5C61 ~            	LD (BLIT_STRUCT+6),DE
 262+ 5C61 ~            	; comma
 263+ 5C61 ~            	CALL CHKCHAR
 264+ 5C61 ~            	DB ','
 265+ 5C61 ~            	; get number of items in a list
 266+ 5C61 ~            	LD IX, GETBYT
 267+ 5C61 ~            	CALL CALBAS
 268+ 5C61 ~            	LD (BLIT_STRUCT+8),A
 269+ 5C61 ~            	; comma
 270+ 5C61 ~            	CALL CHKCHAR
 271+ 5C61 ~            	DB ','
 272+ 5C61 ~            	; get address of rectangle structure array DIM R%(7,n)
 273+ 5C61 ~            	LD A,(BLIT_STRUCT+8)
 274+ 5C61 ~                LD E,A
 275+ 5C61 ~                LD A,2
 276+ 5C61 ~            	LD B,A
 277+ 5C61 ~            	LD D,7
 278+ 5C61 ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
 279+ 5C61 ~            	LD (BLIT_STRUCT+9),BC
 280+ 5C61 ~            	; ending )
 281+ 5C61 ~            	CALL CHKCHAR
 282+ 5C61 ~            	DB ')'
 283+ 5C61 ~
 284+ 5C61 ~                PUSH HL
 285+ 5C61 ~                CALL FIND_OVERLAP
 286+ 5C61 ~                LD HL,(BLIT_STRUCT+11)
 287+ 5C61 ~                JR C,.NOTFOUND
 288+ 5C61 ~                LD (HL),A
 289+ 5C61 ~                INC HL
 290+ 5C61 ~                LD (HL),0
 291+ 5C61 ~                POP HL
 292+ 5C61 ~                RET
 293+ 5C61 ~            .NOTFOUND:
 294+ 5C61 ~                LD (HL),#FF
 295+ 5C61 ~                INC HL
 296+ 5C61 ~                LD (HL),#FF
 297+ 5C61 ~                POP HL
 298+ 5C61 ~                RET
 299+ 5C61 ~            ; ************************************************************************************************
 300+ 5C61               ENDIF
 301+ 5C61
 302+ 5C61               IF (1 == 1)
 303+ 5C61              ; *******************************************************************************************************
 304+ 5C61              ; same as COLL but for DEFUSR approach
 305+ 5C61              ; input IX=pointer to input array, real data from +2
 306+ 5C61              ; +02 = pointer to result variable
 307+ 5C61              ; +04 = player X
 308+ 5C61              ; +06 = player Y
 309+ 5C61              ; +08 = player width
 310+ 5C61              ; +10 = player height
 311+ 5C61              ; +12 = number of list items
 312+ 5C61              ; +14 = pointer to list of collidable objects
 313+ 5C61              COLL_DEFUSR:
 314+ 5C61 DD E5            PUSH IX
 315+ 5C63 E1               POP HL
 316+ 5C64 23          > INC HL ; skip over to player x
 316+ 5C65 23          > INC HL
 316+ 5C66 23          > INC HL
 316+ 5C67 23          > INC HL
 317+ 5C68 11 04 5F         LD DE,BLIT_STRUCT
 318+ 5C6B 01 09 00         LD BC,9
 319+ 5C6E ED B0            LDIR ; copy over x,y,w,h,list item number
 320+ 5C70 DD 7E 0E         LD A,(IX+14)
 321+ 5C73 32 0D 5F         LD (BLIT_STRUCT+9),A
 322+ 5C76 DD 7E 0F         LD A,(IX+15)
 323+ 5C79 32 0E 5F         LD (BLIT_STRUCT+10),A ; address to collidable objects array
 324+ 5C7C DD 7E 02         LD A,(IX+2)
 325+ 5C7F 32 0F 5F         LD (BLIT_STRUCT+11),A
 326+ 5C82 DD 7E 03         LD A,(IX+3)
 327+ 5C85 32 10 5F         LD (BLIT_STRUCT+12),A ; address to results variable
 328+ 5C88 DD E5            PUSH IX
 329+ 5C8A CD 0F 5C         CALL FIND_OVERLAP
 330+ 5C8D DD E1            POP IX
 331+ 5C8F DD 6E 02         LD L,(IX+2)
 332+ 5C92 DD 66 03         LD H,(IX+3)
 333+ 5C95 38 05            JR C,.NOTFOUND
 334+ 5C97 77               LD (HL),A
 335+ 5C98 23               INC HL
 336+ 5C99 36 00            LD (HL),0
 337+ 5C9B C9               RET
 338+ 5C9C              .NOTFOUND:
 339+ 5C9C 36 FF            LD (HL),#FF
 340+ 5C9E 23               INC HL
 341+ 5C9F 36 FF            LD (HL),#FF
 342+ 5CA1 C9               RET
 343+ 5CA2              ; *******************************************************************************************************
 344+ 5CA2               ENDIF
 345+ 5CA2
# file closed: asm\COLLISION.asm
 172  5CA2               ENDIF
 173  5CA2
 174  5CA2               IF (DECOMP_CMDS == 1)
 175  5CA2               INCLUDE "decomp.asm"
# file opened: asm\decomp.asm
   1+ 5CA2              ; -----------------------------------------------------------------------------
   2+ 5CA2              ; ZX0 decoder by Einar Saukas & Urusergi
   3+ 5CA2              ; "Standard" version (68 bytes only)
   4+ 5CA2              ; -----------------------------------------------------------------------------
   5+ 5CA2              ; Parameters:
   6+ 5CA2              ;   HL: source address (compressed data)
   7+ 5CA2              ;   DE: destination address (decompressing)
   8+ 5CA2              ; -----------------------------------------------------------------------------
   9+ 5CA2
  10+ 5CA2              dzx0_standard:
  11+ 5CA2 01 FF FF             ld      bc, $ffff               ; preserve default offset 1
  12+ 5CA5 C5                   push    bc
  13+ 5CA6 03                   inc     bc
  14+ 5CA7 3E 80                ld      a, $80
  15+ 5CA9              dzx0s_literals:
  16+ 5CA9 CD D9 5C             call    dzx0s_elias             ; obtain length
  17+ 5CAC              dzx0_ldir_1:
  18+ 5CAC ED B0                ldir                            ; copy literals
  19+ 5CAE 00                   nop                             ; placeholder for call
  20+ 5CAF 87                   add     a, a                    ; copy from last offset or new offset?
  21+ 5CB0 38 0E                jr      c, dzx0s_new_offset
  22+ 5CB2 CD D9 5C             call    dzx0s_elias             ; obtain length
  23+ 5CB5              dzx0s_copy:
  24+ 5CB5 E3                   ex      (sp), hl                ; preserve source, restore offset
  25+ 5CB6 E5                   push    hl                      ; preserve offset
  26+ 5CB7 19                   add     hl, de                  ; calculate destination - offset
  27+ 5CB8              dzx0_ldir_2:
  28+ 5CB8 ED B0                ldir                            ; copy from offset
  29+ 5CBA 00                   nop                             ; placeholder for call
  30+ 5CBB E1                   pop     hl                      ; restore offset
  31+ 5CBC E3                   ex      (sp), hl                ; preserve offset, restore source
  32+ 5CBD 87                   add     a, a                    ; copy from literals or new offset?
  33+ 5CBE 30 E9                jr      nc, dzx0s_literals
  34+ 5CC0              dzx0s_new_offset:
  35+ 5CC0 C1                   pop     bc                      ; discard last offset
  36+ 5CC1 0E FE                ld      c, $fe                  ; prepare negative offset
  37+ 5CC3 CD DA 5C             call    dzx0s_elias_loop        ; obtain offset MSB
  38+ 5CC6 0C                   inc     c
  39+ 5CC7 C8                   ret     z                       ; check end marker
  40+ 5CC8 41                   ld      b, c
  41+ 5CC9 4E                   ld      c, (hl)                 ; obtain offset LSB
  42+ 5CCA 23                   inc     hl
  43+ 5CCB CB 18                rr      b                       ; last offset bit becomes first length bit
  44+ 5CCD CB 19                rr      c
  45+ 5CCF C5                   push    bc                      ; preserve new offset
  46+ 5CD0 01 01 00             ld      bc, 1                   ; obtain length
  47+ 5CD3 D4 E1 5C             call    nc, dzx0s_elias_backtrack
  48+ 5CD6 03                   inc     bc
  49+ 5CD7 18 DC                jr      dzx0s_copy
  50+ 5CD9              dzx0s_elias:
  51+ 5CD9 0C                   inc     c                       ; interlaced Elias gamma coding
  52+ 5CDA              dzx0s_elias_loop:
  53+ 5CDA 87                   add     a, a
  54+ 5CDB 20 03                jr      nz, dzx0s_elias_skip
  55+ 5CDD 7E                   ld      a, (hl)                 ; load another group of 8 bits
  56+ 5CDE 23                   inc     hl
  57+ 5CDF 17                   rla
  58+ 5CE0              dzx0s_elias_skip:
  59+ 5CE0 D8                   ret     c
  60+ 5CE1              dzx0s_elias_backtrack:
  61+ 5CE1 87                   add     a, a
  62+ 5CE2 CB 11                rl      c
  63+ 5CE4 CB 10                rl      b
  64+ 5CE6 18 F2                jr      dzx0s_elias_loop
  65+ 5CE8              ; -----------------------------------------------------------------------------
  66+ 5CE8
  67+ 5CE8              ; *******************************************************************************************************
  68+ 5CE8              ; helper function for VRAM unpack to save AF prior to calling copy to VRAM fn
  69+ 5CE8              ; also simulates register states as if LDIR was called
  70+ 5CE8              LDIR_TO_VRAM:
  71+ 5CE8 F5                   PUSH AF ; save AF used by algorithm
  72+ 5CE9 D5                   PUSH DE
  73+ 5CEA C5                   PUSH BC
  74+ 5CEB CD 53 56             CALL VRAM_LDIRVM
  75+ 5CEE C1                   POP BC
  76+ 5CEF EB                   EX DE,HL
  77+ 5CF0 E1                   POP HL
  78+ 5CF1 09                   ADD HL,BC
  79+ 5CF2 EB                   EX DE,HL
  80+ 5CF3 01 00 00             LD BC,0
  81+ 5CF6 F1                   POP AF
  82+ 5CF7 C9                   RET
  83+ 5CF8              ; *******************************************************************************************************
  84+ 5CF8
  85+ 5CF8              ; *******************************************************************************************************
  86+ 5CF8              ; helper function to get a byte from VRAM address at HL and place it at DE also in VRAM
  87+ 5CF8              VPOKE_VPEEK:
  88+ 5CF8 F3                   DI
  89+ 5CF9 CD 60 5F             CALL SETWRT_LOCAL_READ
  90+ 5CFC E3                   EX (SP),HL
  91+ 5CFD E3                   EX (SP),HL
  92+ 5CFE DB 98                IN A,(#98)
  93+ 5D00                      ;IN A,(#98) ; WHY IS THIS NEEDED ?
  94+ 5D00 F5                   PUSH AF
  95+ 5D01 EB                   EX DE,HL
  96+ 5D02 CD 55 5F             CALL SETWRT_LOCAL_WRITE
  97+ 5D05 E3                   EX (SP),HL
  98+ 5D06 E3                   EX (SP),HL
  99+ 5D07 EB                   EX DE,HL
 100+ 5D08 F1                   POP AF
 101+ 5D09 D3 98                OUT (#98),A
 102+ 5D0B FB                   EI
 103+ 5D0C C9                   RET
 104+ 5D0D              ; *******************************************************************************************************
 105+ 5D0D
 106+ 5D0D              ; *******************************************************************************************************
 107+ 5D0D              ; helper fn VRAM variant of LDIR
 108+ 5D0D              ; input HL = source, DE = destination, BC = count
 109+ 5D0D              VRAM_LDIR:
 110+ 5D0D F5                   PUSH AF
 111+ 5D0E              _L0:
 112+ 5D0E CD F8 5C             CALL VPOKE_VPEEK
 113+ 5D11 23                   INC HL
 114+ 5D12 13                   INC DE
 115+ 5D13 0B                   DEC BC
 116+ 5D14 78                   LD A, B
 117+ 5D15 B1                   OR C
 118+ 5D16 20 F6                JR NZ, _L0
 119+ 5D18 F1                   POP AF
 120+ 5D19 C9                   RET
 121+ 5D1A              ; *******************************************************************************************************
 122+ 5D1A
 123+ 5D1A               IF (0 == 1)
 124+ 5D1A ~            ; *******************************************************************************************************
 125+ 5D1A ~            ; function to handle CALL VUNPACK basic extension
 126+ 5D1A ~            ; _VUNPACK ( INT source,
 127+ 5D1A ~            ;			 INT destination )
 128+ 5D1A ~            ; will put ram in page 0 also, page 1 is already there
 129+ 5D1A ~            ; *******************************************************************************************************
 130+ 5D1A ~            VUNPACK:
 131+ 5D1A ~                LD A, #CD ; CALL
 132+ 5D1A ~                LD (dzx0_ldir_1), A
 133+ 5D1A ~                LD (dzx0_ldir_2), A
 134+ 5D1A ~                LD DE, LDIR_TO_VRAM
 135+ 5D1A ~                LD (dzx0_ldir_1 + 1), DE
 136+ 5D1A ~                LD DE, VRAM_LDIR
 137+ 5D1A ~                LD (dzx0_ldir_2 + 1), DE
 138+ 5D1A ~                JR UNPACK_COMMON
 139+ 5D1A ~            ; function to handle CALL UNPACK basic extension
 140+ 5D1A ~            ; _UNPACK ( INT source,
 141+ 5D1A ~            ;			INT destination )
 142+ 5D1A ~            ; will put ram in page 0 also, page 1 is already there
 143+ 5D1A ~            UNPACK:
 144+ 5D1A ~                LD DE, #B0ED ; LDIR
 145+ 5D1A ~                LD (dzx0_ldir_1), DE
 146+ 5D1A ~                LD (dzx0_ldir_2), DE
 147+ 5D1A ~                XOR A ; NOP
 148+ 5D1A ~                LD (dzx0_ldir_1 + 2), A
 149+ 5D1A ~                LD (dzx0_ldir_2 + 2), A
 150+ 5D1A ~            UNPACK_COMMON:
 151+ 5D1A ~            	; opening (
 152+ 5D1A ~            	CALL CHKCHAR
 153+ 5D1A ~            	DB '('
 154+ 5D1A ~            	; get source address
 155+ 5D1A ~            	LD IX, FRMQNT
 156+ 5D1A ~            	CALL CALBAS
 157+ 5D1A ~            	PUSH DE
 158+ 5D1A ~            	; comma
 159+ 5D1A ~            	CALL CHKCHAR
 160+ 5D1A ~            	DB ','
 161+ 5D1A ~            	; get destination address
 162+ 5D1A ~            	LD IX, FRMQNT
 163+ 5D1A ~            	CALL CALBAS
 164+ 5D1A ~            	PUSH DE
 165+ 5D1A ~            	; ending )
 166+ 5D1A ~            	CALL CHKCHAR
 167+ 5D1A ~            	DB ')'
 168+ 5D1A ~
 169+ 5D1A ~            	; save position
 170+ 5D1A ~            	PUSH HL
 171+ 5D1A ~            	POP IX
 172+ 5D1A ~
 173+ 5D1A ~            	POP DE ; destination
 174+ 5D1A ~            	POP HL ; source
 175+ 5D1A ~            	EXX
 176+ 5D1A ~            	; enable page 0
 177+ 5D1A ~            	LD IY, .RET
 178+ 5D1A ~            	JP ENABLE_PAGE0
 179+ 5D1A ~            .RET:
 180+ 5D1A ~            	EI
 181+ 5D1A ~            	EXX
 182+ 5D1A ~            	CALL dzx0_standard
 183+ 5D1A ~                    POP DE
 184+ 5D1A ~                    POP BC
 185+ 5D1A ~                    CALL RESTORE_PAGE_INFO
 186+ 5D1A ~            	PUSH IX
 187+ 5D1A ~            	POP HL
 188+ 5D1A ~            	RET
 189+ 5D1A ~            ; *******************************************************************************************************
 190+ 5D1A               ENDIF
 191+ 5D1A
 192+ 5D1A               IF (1 == 1)
 193+ 5D1A              ; *******************************************************************************************************
 194+ 5D1A              ; same as VUNPACK but for DEFUSR approach
 195+ 5D1A              ; input IX=pointer to input array, real data from +2
 196+ 5D1A              ; +2 = source address
 197+ 5D1A              ; +4 = destination address
 198+ 5D1A              ; *******************************************************************************************************
 199+ 5D1A              VUNPACK_DEFUSR:
 200+ 5D1A 3E CD            LD A, #CD ; CALL
 201+ 5D1C 32 AC 5C         LD (dzx0_ldir_1), A
 202+ 5D1F 32 B8 5C         LD (dzx0_ldir_2), A
 203+ 5D22 21 E8 5C         LD HL, LDIR_TO_VRAM
 204+ 5D25 22 AD 5C         LD (dzx0_ldir_1 + 1), HL
 205+ 5D28 21 0D 5D         LD HL, VRAM_LDIR
 206+ 5D2B 22 B9 5C         LD (dzx0_ldir_2 + 1), HL
 207+ 5D2E 18 10            JR UNPACK_DEFUSR_COMMON
 208+ 5D30              ; same as UNPACK but for DEFUSR approach
 209+ 5D30              ; input IX=pointer to input array, real data from +2
 210+ 5D30              ; +2 = source address
 211+ 5D30              ; +4 = destination address
 212+ 5D30              UNPACK_DEFUSR:
 213+ 5D30 21 ED B0         LD HL, #B0ED ; LDIR
 214+ 5D33 22 AC 5C         LD (dzx0_ldir_1), HL
 215+ 5D36 22 B8 5C         LD (dzx0_ldir_2), HL
 216+ 5D39 AF               XOR A ; NOP
 217+ 5D3A 32 AE 5C         LD (dzx0_ldir_1 + 2), A
 218+ 5D3D 32 BA 5C         LD (dzx0_ldir_2 + 2), A
 219+ 5D40              UNPACK_DEFUSR_COMMON:
 220+ 5D40              	; enable page 0
 221+ 5D40 FD 21 47 5D  	LD IY, .RET
 222+ 5D44 C3 38 60     	JP ENABLE_PAGE0
 223+ 5D47              .RET:
 224+ 5D47 FB           	EI
 225+ 5D48 DD 6E 02     	LD L,(IX+2)
 226+ 5D4B DD 66 03     	LD H,(IX+3)
 227+ 5D4E DD 5E 04     	LD E,(IX+4)
 228+ 5D51 DD 56 05     	LD D,(IX+5)
 229+ 5D54 CD A2 5C     	CALL dzx0_standard
 230+ 5D57 D1               POP DE
 231+ 5D58 C1               POP BC
 232+ 5D59 C3 AF 5F         JP RESTORE_PAGE_INFO
 233+ 5D5C              ; *******************************************************************************************************
 234+ 5D5C               ENDIF
# file closed: asm\decomp.asm
 176  5D5C               ENDIF
 177  5D5C
 178  5D5C               IF (DLOAD_CMD == 1)
 179  5D5C               INCLUDE "DLOAD.asm"
# file opened: asm\DLOAD.asm
   1+ 5D5C              BDOS_SETDTA     EQU #1A
   2+ 5D5C              BDOS_OPEN       EQU #0F
   3+ 5D5C              BDOS_CLOSE      EQU #10
   4+ 5D5C              BDOS_RDBLK      EQU #27
   5+ 5D5C
   6+ 5D5C              ; *******************************************************************************************************
   7+ 5D5C              ; function processes file name
   8+ 5D5C              ; filenames supported are D:FILENAME.EXT, FILENAME.EXT, D:FILENAME, FILENAME
   9+ 5D5C              ; FCB 0 will be zeroed out
  10+ 5D5C              ; FCB 0 will be populated with drive info 0=default or 1-8 for drives A-H
  11+ 5D5C              ; FCB 0 will be populated with file name
  12+ 5D5C              ; input HL=pointer to expression
  13+ 5D5C              ; input B=length
  14+ 5D5C              ; returns CF=1 if bad filename
  15+ 5D5C              DLOAD_PROCESS_FILENAME:
  16+ 5D5C                  ; check for zero size
  17+ 5D5C 78               LD A,B
  18+ 5D5D B7               OR A
  19+ 5D5E 28 6B            JR Z, .BADFILENAME
  20+ 5D60                  ; check for more than 2+8+1+3=14
  21+ 5D60 FE 0F            CP 15
  22+ 5D62 30 67            JR NC, .BADFILENAME
  23+ 5D64                  ; check if more than 2 letters
  24+ 5D64 FE 03            CP 3
  25+ 5D66 38 1C            JR C, .L7 ; no drive
  26+ 5D68                  ; check for : at proper place
  27+ 5D68 5E               LD E, (HL)
  28+ 5D69 23               INC HL
  29+ 5D6A 7E               LD A, (HL)
  30+ 5D6B FE 3A            CP ':'
  31+ 5D6D 20 14            JR NZ, .L1
  32+ 5D6F                  ; so we have : , check for letters A-H
  33+ 5D6F 7B               LD A,E
  34+ 5D70 CD A4 60         CALL UPPER
  35+ 5D73 D6 41            SUB 'A'
  36+ 5D75 FE 09            CP 9
  37+ 5D77 30 52            JR NC, .BADFILENAME
  38+ 5D79 23               INC HL
  39+ 5D7A 05               DEC B ; consume two characters
  40+ 5D7B 05               DEC B
  41+ 5D7C              .L2:
  42+ 5D7C ED 5B 53 F3      LD DE, (FCB0)
  43+ 5D80 12               LD (DE), A
  44+ 5D81 18 04            JR .PROCESS_FILENAME
  45+ 5D83              .L1:
  46+ 5D83                  ; no drive specified
  47+ 5D83 2B               DEC HL
  48+ 5D84              .L7:
  49+ 5D84 AF               XOR A
  50+ 5D85 18 F5            JR .L2
  51+ 5D87              .PROCESS_FILENAME:
  52+ 5D87                  ; HL is pointing to rest of the name
  53+ 5D87 13               INC DE ; 8-character filename location, needs to be padded with blanks
  54+ 5D88 0E 08            LD C,8 ; filename length
  55+ 5D8A              .L4:
  56+ 5D8A CD CD 5D         CALL .GETCHAR
  57+ 5D8D FE 2E            CP '.'
  58+ 5D8F 28 31            JR Z, .L6 ; if dot, fill rest with blanks
  59+ 5D91 12               LD (DE),A
  60+ 5D92 13               INC DE
  61+ 5D93 0D               DEC C
  62+ 5D94 20 F4            JR NZ, .L4
  63+ 5D96                  ; so we cleared filename part
  64+ 5D96 78               LD A,B ; no more letters. just fill extension with blanks
  65+ 5D97 B7               OR A
  66+ 5D98 28 07            JR Z, .L8
  67+ 5D9A CD CD 5D         CALL .GETCHAR ; here we must have . for a valid name
  68+ 5D9D FE 2E            CP '.'
  69+ 5D9F 20 2A            JR NZ, .BADFILENAME
  70+ 5DA1              .L8:
  71+ 5DA1 0E 03            LD C,3
  72+ 5DA3              .L5:
  73+ 5DA3 CD CD 5D         CALL .GETCHAR
  74+ 5DA6 12               LD (DE),A
  75+ 5DA7 13               INC DE
  76+ 5DA8 0D               DEC C
  77+ 5DA9 20 F8            JR NZ, .L5
  78+ 5DAB 78               LD A,B ; nothing must be left in buffer
  79+ 5DAC B7               OR A
  80+ 5DAD 20 1C            JR NZ, .BADFILENAME
  81+ 5DAF                  ; file name correct, now zero out the rest of FCB 0
  82+ 5DAF 2A 53 F3         LD HL,(FCB0)
  83+ 5DB2 11 0C 00         LD DE,12
  84+ 5DB5 19               ADD HL,DE
  85+ 5DB6 36 00            LD (HL),0
  86+ 5DB8 54               LD D,H
  87+ 5DB9 5D               LD E,L
  88+ 5DBA 13               INC DE
  89+ 5DBB 01 18 00         LD BC,37-12-1
  90+ 5DBE ED B0            LDIR
  91+ 5DC0 AF               XOR A ; clear carry flag
  92+ 5DC1 C9               RET
  93+ 5DC2              .L6:
  94+ 5DC2 3E 20            LD A,' '
  95+ 5DC4              .L9:
  96+ 5DC4 12               LD (DE),A
  97+ 5DC5 13               INC DE
  98+ 5DC6 0D               DEC C
  99+ 5DC7 20 FB            JR NZ, .L9
 100+ 5DC9 18 D6            JR .L8
 101+ 5DCB              .BADFILENAME:
 102+ 5DCB 37               SCF
 103+ 5DCC C9               RET
 104+ 5DCD              .GETCHAR: ; gets a character, returns blank if we read past input
 105+ 5DCD 78               LD A,B
 106+ 5DCE B7               OR A
 107+ 5DCF 28 07            JR Z, .BLANK
 108+ 5DD1 7E               LD A,(HL)
 109+ 5DD2 CD A4 60         CALL UPPER
 110+ 5DD5 23               INC HL
 111+ 5DD6 05               DEC B
 112+ 5DD7 C9               RET
 113+ 5DD8              .BLANK:
 114+ 5DD8 3E 20            LD A,' '
 115+ 5DDA C9               RET
 116+ 5DDB              ; *******************************************************************************************************
 117+ 5DDB
 118+ 5DDB              ; *******************************************************************************************************
 119+ 5DDB              ; function sets disk buffer from NULBUF
 120+ 5DDB              ; input none
 121+ 5DDB              ; returns ZF!=1 on error
 122+ 5DDB              DLOAD_SETDTA:
 123+ 5DDB ED 5B 62 F8      LD DE,(NULBUF)
 124+ 5DDF 0E 1A            LD C, BDOS_SETDTA
 125+ 5DE1 18 24            JR BDOS_CALL
 126+ 5DE3              ; *******************************************************************************************************
 127+ 5DE3
 128+ 5DE3              ; *******************************************************************************************************
 129+ 5DE3              ; function opens a file using FCB 0
 130+ 5DE3              ; input none
 131+ 5DE3              ; returns ZF!=1 on error
 132+ 5DE3              DLOAD_OPENFILE:
 133+ 5DE3 ED 5B 53 F3      LD DE,(FCB0)
 134+ 5DE7 0E 0F            LD C, BDOS_OPEN
 135+ 5DE9 18 1C            JR BDOS_CALL
 136+ 5DEB              ; *******************************************************************************************************
 137+ 5DEB
 138+ 5DEB              ; *******************************************************************************************************
 139+ 5DEB              ; function makes a file seek and sets record size to 1 byte
 140+ 5DEB              ; input none
 141+ 5DEB              ; output node
 142+ 5DEB              DLOAD_SEEK:
 143+ 5DEB 2A 04 5F         LD HL,(BLIT_STRUCT)
 144+ 5DEE DD 2A 53 F3      LD IX,(FCB0)
 145+ 5DF2 DD 75 21         LD (IX+33),L
 146+ 5DF5 DD 74 22         LD (IX+34),H
 147+ 5DF8 DD 36 0E 01      LD (IX+14),1
 148+ 5DFC DD 36 0F 00      LD (IX+15),0
 149+ 5E00 C9               RET
 150+ 5E01              ; *******************************************************************************************************
 151+ 5E01
 152+ 5E01              ; *******************************************************************************************************
 153+ 5E01              ; function reads a number of bytes from a file using FCB 0 to (NULBUF) buffer
 154+ 5E01              ; input HL=number of bytes to read
 155+ 5E01              ; returns HL=number of bytes read
 156+ 5E01              ; returns ZF!=1 on error
 157+ 5E01              DLOAD_READ:
 158+ 5E01 ED 5B 53 F3      LD DE,(FCB0)
 159+ 5E05 0E 27            LD C,BDOS_RDBLK
 160+ 5E07              BDOS_CALL:
 161+ 5E07 CD 7D F3         CALL BDOS
 162+ 5E0A B7               OR A
 163+ 5E0B C9               RET
 164+ 5E0C              ; *******************************************************************************************************
 165+ 5E0C
 166+ 5E0C              ; *******************************************************************************************************
 167+ 5E0C              ; function closes a file FCB 0
 168+ 5E0C              ; input none
 169+ 5E0C              ; returns ZF!=1 on error
 170+ 5E0C              DLOAD_CLOSE:
 171+ 5E0C AF               XOR A
 172+ 5E0D ED 5B 53 F3      LD DE,(FCB0)
 173+ 5E11 0E 10            LD C,BDOS_CLOSE
 174+ 5E13 18 F2            JR BDOS_CALL
 175+ 5E15              ; *******************************************************************************************************
 176+ 5E15
 177+ 5E15              ; *******************************************************************************************************
 178+ 5E15              ; function copies data from (NULBUF) to destination, enables RAM in page 0
 179+ 5E15              ; input BC=number of bytes to copy
 180+ 5E15              ; output none
 181+ 5E15              DLOAD_TRANSFERBLOCK:
 182+ 5E15 D9               EXX ; save BC
 183+ 5E16              	; enable page 0
 184+ 5E16 FD 21 1D 5E  	LD IY, .RET
 185+ 5E1A C3 38 60     	JP ENABLE_PAGE0
 186+ 5E1D              .RET:
 187+ 5E1D FB           	EI
 188+ 5E1E D9               EXX
 189+ 5E1F ED 5B 06 5F      LD DE,(BLIT_STRUCT+2)
 190+ 5E23 2A 62 F8         LD HL,(NULBUF)
 191+ 5E26 ED B0        	LDIR
 192+ 5E28 ED 53 06 5F      LD (BLIT_STRUCT+2),DE
 193+ 5E2C D1               POP DE
 194+ 5E2D C1               POP BC
 195+ 5E2E C3 AF 5F         JP RESTORE_PAGE_INFO
 196+ 5E31              ; *******************************************************************************************************
 197+ 5E31
 198+ 5E31              ; *******************************************************************************************************
 199+ 5E31              ; function opens and loads a file in FCB 0
 200+ 5E31              ; file name needs to be already set in FCB 0
 201+ 5E31              ; input none
 202+ 5E31              ; returns ZF!=1 on error
 203+ 5E31              DLOAD_LOADFILE:
 204+ 5E31 CD DB 5D         CALL DLOAD_SETDTA
 205+ 5E34 CD E3 5D         CALL DLOAD_OPENFILE
 206+ 5E37 C0               RET NZ
 207+ 5E38 CD EB 5D         CALL DLOAD_SEEK
 208+ 5E3B ED 4B 08 5F      LD BC,(BLIT_STRUCT+4)
 209+ 5E3F              .L1:
 210+ 5E3F 78               LD A,B
 211+ 5E40 B7               OR A
 212+ 5E41 28 12            JR Z,.REST
 213+ 5E43 05               DEC B
 214+ 5E44 21 00 01         LD HL,256
 215+ 5E47              .L2:
 216+ 5E47 C5               PUSH BC
 217+ 5E48 E5               PUSH HL
 218+ 5E49 CD 01 5E         CALL DLOAD_READ
 219+ 5E4C C1               POP BC
 220+ 5E4D 20 10            JR NZ,.ERRREAD
 221+ 5E4F CD 15 5E         CALL DLOAD_TRANSFERBLOCK
 222+ 5E52 C1               POP BC
 223+ 5E53 18 EA            JR .L1
 224+ 5E55              .REST:
 225+ 5E55 79               LD A,C
 226+ 5E56 B7               OR A
 227+ 5E57 28 07            JR Z,.EXIT
 228+ 5E59 26 00            LD H,0
 229+ 5E5B 69               LD L,C
 230+ 5E5C 4C               LD C,H
 231+ 5E5D 18 E8            JR .L2
 232+ 5E5F              .ERRREAD:
 233+ 5E5F C1               POP BC
 234+ 5E60              .EXIT:
 235+ 5E60 F5               PUSH AF
 236+ 5E61 CD 0C 5E         CALL DLOAD_CLOSE
 237+ 5E64 F1               POP AF
 238+ 5E65 C9               RET
 239+ 5E66              ; *******************************************************************************************************
 240+ 5E66
 241+ 5E66               IF (0 == 1)
 242+ 5E66 ~
 243+ 5E66 ~            ; *******************************************************************************************************
 244+ 5E66 ~            ; function to handle CALL DLOAD basic extension
 245+ 5E66 ~            ; _DLOAD ( STRING filename,
 246+ 5E66 ~            ;		   INT offset,
 247+ 5E66 ~            ;		   INT destination,
 248+ 5E66 ~            ;          INT size )
 249+ 5E66 ~            ; will put ram in page 0 also, page 1 is already there
 250+ 5E66 ~            DLOAD:
 251+ 5E66 ~            	; opening (
 252+ 5E66 ~            	CALL CHKCHAR
 253+ 5E66 ~            	DB '('
 254+ 5E66 ~                CALL EVALTXTPARAM
 255+ 5E66 ~                PUSH HL
 256+ 5E66 ~                CALL GETSTRPNT
 257+ 5E66 ~                CALL DLOAD_PROCESS_FILENAME
 258+ 5E66 ~                JP C, BAD_FILENAME
 259+ 5E66 ~                POP HL
 260+ 5E66 ~            	; comma
 261+ 5E66 ~            	CALL CHKCHAR
 262+ 5E66 ~            	DB ','
 263+ 5E66 ~            	; get offset
 264+ 5E66 ~            	LD IX, FRMQNT
 265+ 5E66 ~            	CALL CALBAS
 266+ 5E66 ~            	LD (BLIT_STRUCT), DE
 267+ 5E66 ~            	; comma
 268+ 5E66 ~            	CALL CHKCHAR
 269+ 5E66 ~            	DB ','
 270+ 5E66 ~            	; get destination
 271+ 5E66 ~            	LD IX, FRMQNT
 272+ 5E66 ~            	CALL CALBAS
 273+ 5E66 ~            	LD (BLIT_STRUCT+2), DE
 274+ 5E66 ~            	; comma
 275+ 5E66 ~            	CALL CHKCHAR
 276+ 5E66 ~            	DB ','
 277+ 5E66 ~            	; get size
 278+ 5E66 ~            	LD IX, FRMQNT
 279+ 5E66 ~            	CALL CALBAS
 280+ 5E66 ~            	LD (BLIT_STRUCT+4), DE
 281+ 5E66 ~            	; ending )
 282+ 5E66 ~            	CALL CHKCHAR
 283+ 5E66 ~            	DB ')'
 284+ 5E66 ~
 285+ 5E66 ~                PUSH HL
 286+ 5E66 ~                CALL DLOAD_LOADFILE
 287+ 5E66 ~                JP NZ, DISKIOERR
 288+ 5E66 ~                POP HL
 289+ 5E66 ~                RET
 290+ 5E66 ~            ; *******************************************************************************************************
 291+ 5E66 ~
 292+ 5E66               ENDIF
 293+ 5E66
 294+ 5E66               IF (1 == 1)
 295+ 5E66              ; *******************************************************************************************************
 296+ 5E66              ; same as DLOAD but for DEFUSR approach
 297+ 5E66              ; input IX=pointer to input array, real data from +2
 298+ 5E66              ; +2 = string pointer
 299+ 5E66              ; +4 = offset
 300+ 5E66              ; +6 = destination
 301+ 5E66              ; +8 = size
 302+ 5E66              ; *******************************************************************************************************
 303+ 5E66              DLOAD_DEFUSR:
 304+ 5E66 DD 6E 02         LD L,(IX+2)
 305+ 5E69 DD 66 03         LD H,(IX+3)
 306+ 5E6C 46               LD B,(HL) ; string length
 307+ 5E6D 23               INC HL
 308+ 5E6E 5E               LD E,(HL)
 309+ 5E6F 23               INC HL
 310+ 5E70 56               LD D,(HL)
 311+ 5E71 EB               EX DE,HL ; pointer to ASCIIZ text
 312+ 5E72 CD 5C 5D         CALL DLOAD_PROCESS_FILENAME
 313+ 5E75 D8               RET C ; exit on error
 314+ 5E76 DD 6E 04         LD L,(IX+4)
 315+ 5E79 DD 66 05         LD H,(IX+5)
 316+ 5E7C 22 04 5F         LD (BLIT_STRUCT),HL ; offset
 317+ 5E7F DD 6E 06         LD L,(IX+6)
 318+ 5E82 DD 66 07         LD H,(IX+7)
 319+ 5E85 22 06 5F         LD (BLIT_STRUCT+2),HL ; destination
 320+ 5E88 DD 6E 08         LD L,(IX+8)
 321+ 5E8B DD 66 09         LD H,(IX+9)
 322+ 5E8E 22 08 5F         LD (BLIT_STRUCT+4),HL ; size
 323+ 5E91 C3 31 5E         JP DLOAD_LOADFILE
 324+ 5E94              ; *******************************************************************************************************
 325+ 5E94
 326+ 5E94               ENDIF
 327+ 5E94
# file closed: asm\DLOAD.asm
 180  5E94               ENDIF
 181  5E94
 182  5E94               IF (1 == 1)
 183  5E94               INCLUDE "DEFUSR.asm"
# file opened: asm\DEFUSR.asm
   1+ 5E94              ; entry function that handles call using CALLF
   2+ 5E94              ; pointer to data structure is expected at DAC+2
   3+ 5E94              ; first entry must be function id followed by function specific parameters
   4+ 5E94
   5+ 5E94              DEFUSR_TABLE_ENTRIES    EQU 41
   6+ 5E94
   7+ 5E94              DEFUSR_JUMP_TABLE:
   8+ 5E94               IF (SPRITE_CMDS == 1)
   9+ 5E94 6E 4E         DW SPRENABLE_DEFUSR        ; 0
  10+ 5E96               ELSE
  11+ 5E96 ~             DW NOACTION_DEFUSR
  12+ 5E96               ENDIF
  13+ 5E96
  14+ 5E96               IF (SPRITE_CMDS == 1)
  15+ 5E96 92 4E         DW SPRDISABLE_DEFUSR        ; 1
  16+ 5E98               ELSE
  17+ 5E98 ~             DW NOACTION_DEFUSR
  18+ 5E98               ENDIF
  19+ 5E98
  20+ 5E98               IF (RAM_CMDS == 1)
  21+ 5E98 22 55         DW MEMCPY_DEFUSR           ; 2
  22+ 5E9A               ELSE
  23+ 5E9A ~             DW NOACTION_DEFUSR
  24+ 5E9A               ENDIF
  25+ 5E9A
  26+ 5E9A               IF (VRAM_CMDS == 1)        ; 3
  27+ 5E9A 1C 56         DW MEMVRM_DEFUSR
  28+ 5E9C               ELSE
  29+ 5E9C ~             DW NOACTION_DEFUSR
  30+ 5E9C               ENDIF
  31+ 5E9C
  32+ 5E9C               IF (BLIT_CMDS == 1)        ; 4
  33+ 5E9C 30 59         DW BLIT_DEFUSR
  34+ 5E9E               ELSE
  35+ 5E9E ~             DW NOACTION_DEFUSR
  36+ 5E9E               ENDIF
  37+ 5E9E
  38+ 5E9E               IF (ANIM_CMDS == 1)        ; 5
  39+ 5E9E FA 53         DW SGAM_DEFUSR
  40+ 5EA0               ELSE
  41+ 5EA0 ~             DW NOACTION_DEFUSR
  42+ 5EA0               ENDIF
  43+ 5EA0
  44+ 5EA0               IF (SPRITE_CMDS == 1)
  45+ 5EA0 D5 4E         DW SPRGRPMOV_DEFUSR        ; 6
  46+ 5EA2               ELSE
  47+ 5EA2 ~             DW NOACTION_DEFUSR
  48+ 5EA2               ENDIF
  49+ 5EA2
  50+ 5EA2               IF (COLL_CMD == 1)
  51+ 5EA2 61 5C         DW COLL_DEFUSR             ; 7
  52+ 5EA4               ELSE
  53+ 5EA4 ~             DW NOACTION_DEFUSR
  54+ 5EA4               ENDIF
  55+ 5EA4
  56+ 5EA4               IF (SOUND_CMDS == 1)
  57+ 5EA4 D6 55         DW SNDSFX_DEFUSR             ; 8
  58+ 5EA6               ELSE
  59+ 5EA6 ~             DW NOACTION_DEFUSR
  60+ 5EA6               ENDIF
  61+ 5EA6
  62+ 5EA6               IF (ANIM_CMDS == 1)
  63+ 5EA6 8B 52         DW ANIMSTEP_SINGLE_DEFUSR      ; 9
  64+ 5EA8 9B 52         DW ANIMSTEP_MULTI_DEFUSR       ; 10
  65+ 5EAA AC 52         DW ANIMSTART_SINGLE_DEFUSR     ; 11
  66+ 5EAC BE 52         DW ANIMSTART_MULTI_DEFUSR      ; 12
  67+ 5EAE C3 52         DW ANIMSTOP_SINGLE_DEFUSR      ; 13
  68+ 5EB0 CD 52         DW ANIMSTOP_MULTI_DEFUSR       ; 14
  69+ 5EB2               ELSE
  70+ 5EB2 ~             DW NOACTION_DEFUSR
  71+ 5EB2 ~             DW NOACTION_DEFUSR
  72+ 5EB2 ~             DW NOACTION_DEFUSR
  73+ 5EB2 ~             DW NOACTION_DEFUSR
  74+ 5EB2 ~             DW NOACTION_DEFUSR
  75+ 5EB2 ~             DW NOACTION_DEFUSR
  76+ 5EB2               ENDIF
  77+ 5EB2
  78+ 5EB2               IF (BOX_CMDS == 1)
  79+ 5EB2 3B 57         DW BOXMEMCPY_DEFUSR            ; 15
  80+ 5EB4 71 57         DW BOXMEMVRM_DEFUSR            ; 16
  81+ 5EB6               ELSE
  82+ 5EB6 ~             DW NOACTION_DEFUSR
  83+ 5EB6 ~             DW NOACTION_DEFUSR
  84+ 5EB6               ENDIF
  85+ 5EB6
  86+ 5EB6               IF (ANIM_CMDS == 1)
  87+ 5EB6 35 4F         DW MAXANIMITEMS_DEFUSR         ; 17
  88+ 5EB8 44 50         DW MAXANIMDEFS_DEFUSR          ; 18
  89+ 5EBA A1 50         DW MAXANIMSPRS_DEFUSR          ; 19
  90+ 5EBC 5F 51         DW MAXAUTOSGAMS_DEFUSR         ; 20
  91+ 5EBE FA 4F         DW ANIMITEMPAT_DEFUSR          ; 21
  92+ 5EC0 1F 50         DW ANIMITEMPTR_DEFUSR          ; 22
  93+ 5EC2 7B 50         DW ANIMDEF_DEFUSR              ; 23
  94+ 5EC4 EE 50         DW ANIMSPRITE_DEFUSR           ; 24
  95+ 5EC6 25 51         DW ANIMCHAR_DEFUSR             ; 25
  96+ 5EC8 B0 51         DW AUTOSGAMDEF_DEFUSR          ; 26
  97+ 5ECA 40 52         DW AUTOSGAMSTART_DEFUSR        ; 27
  98+ 5ECC 67 52         DW AUTOSGAMSTOP_DEFUSR         ; 28
  99+ 5ECE               ELSE
 100+ 5ECE ~             DW NOACTION_DEFUSR
 101+ 5ECE ~             DW NOACTION_DEFUSR
 102+ 5ECE ~             DW NOACTION_DEFUSR
 103+ 5ECE ~             DW NOACTION_DEFUSR
 104+ 5ECE ~             DW NOACTION_DEFUSR
 105+ 5ECE ~             DW NOACTION_DEFUSR
 106+ 5ECE ~             DW NOACTION_DEFUSR
 107+ 5ECE ~             DW NOACTION_DEFUSR
 108+ 5ECE ~             DW NOACTION_DEFUSR
 109+ 5ECE ~             DW NOACTION_DEFUSR
 110+ 5ECE ~             DW NOACTION_DEFUSR
 111+ 5ECE ~             DW NOACTION_DEFUSR
 112+ 5ECE               ENDIF
 113+ 5ECE
 114+ 5ECE               IF (GENCAL_CMD == 1)
 115+ 5ECE BB 56         DW GENCAL_DEFUSR               ; 29
 116+ 5ED0               ELSE
 117+ 5ED0 ~             DW NOACTION_DEFUSR
 118+ 5ED0               ENDIF
 119+ 5ED0
 120+ 5ED0               IF (RAM_CMDS == 1)
 121+ 5ED0 43 55         DW FILRAM_DEFUSR               ; 30
 122+ 5ED2               ELSE
 123+ 5ED2 ~             DW NOACTION_DEFUSR
 124+ 5ED2               ENDIF
 125+ 5ED2
 126+ 5ED2               IF (SOUND_CMDS == 1)
 127+ 5ED2 74 55         DW SNDPLYINI_DEFUSR            ; 31
 128+ 5ED4 A7 55         DW SNDPLYON_DEFUSR             ; 32
 129+ 5ED6 B3 55         DW SNDPLYOFF_DEFUSR            ; 33
 130+ 5ED8               ELSE
 131+ 5ED8 ~             DW NOACTION_DEFUSR
 132+ 5ED8 ~             DW NOACTION_DEFUSR
 133+ 5ED8 ~             DW NOACTION_DEFUSR
 134+ 5ED8               ENDIF
 135+ 5ED8
 136+ 5ED8               IF (TILE_CMDS == 1)
 137+ 5ED8 12 5A         DW TILERAM_DEFUSR              ; 34
 138+ 5EDA C9 5A         DW TILEVRM_DEFUSR              ; 35
 139+ 5EDC               ELSE
 140+ 5EDC ~             DW NOACTION_DEFUSR
 141+ 5EDC ~             DW NOACTION_DEFUSR
 142+ 5EDC               ENDIF
 143+ 5EDC
 144+ 5EDC               IF (VRAM_CMDS == 1)
 145+ 5EDC F9 55         DW FILVRM_DEFUSR               ; 36
 146+ 5EDE 7D 56         DW VRMMEM_DEFUSR               ; 37
 147+ 5EE0               ELSE
 148+ 5EE0 ~             DW NOACTION_DEFUSR
 149+ 5EE0 ~             DW NOACTION_DEFUSR
 150+ 5EE0               ENDIF
 151+ 5EE0
 152+ 5EE0               IF (DECOMP_CMDS == 1)
 153+ 5EE0 30 5D         DW UNPACK_DEFUSR               ; 38
 154+ 5EE2               IF (VRAM_CMDS == 1)
 155+ 5EE2 1A 5D          DW VUNPACK_DEFUSR             ; 39
 156+ 5EE4               ELSE
 157+ 5EE4 ~              DW NOACTION_DEFUSR
 158+ 5EE4               ENDIF
 159+ 5EE4               ELSE
 160+ 5EE4 ~             DW NOACTION_DEFUSR
 161+ 5EE4 ~             DW NOACTION_DEFUSR
 162+ 5EE4               ENDIF
 163+ 5EE4
 164+ 5EE4               IF (DLOAD_CMD == 1)
 165+ 5EE4 66 5E         DW DLOAD_DEFUSR               ; 40
 166+ 5EE6               ELSE
 167+ 5EE6 ~             DW NOACTION_DEFUSR
 168+ 5EE6               ENDIF
 169+ 5EE6
 170+ 5EE6              DEFUSR_ENTRY:
 171+ 5EE6 FB               EI
 172+ 5EE7 DD 2A F8 F7      LD IX,(DAC+2)
 173+ 5EEB DD 7E 00         LD A,(IX)
 174+ 5EEE FE 29            CP DEFUSR_TABLE_ENTRIES
 175+ 5EF0 D0               RET NC ; return if an undefined function requested
 176+ 5EF1 26 00            LD H,0
 177+ 5EF3 6F               LD L,A
 178+ 5EF4 29               ADD HL,HL
 179+ 5EF5 11 94 5E         LD DE,DEFUSR_JUMP_TABLE
 180+ 5EF8 19               ADD HL,DE
 181+ 5EF9 EB               EX DE,HL
 182+ 5EFA 1A               LD A,(DE)
 183+ 5EFB 6F               LD L,A
 184+ 5EFC 13               INC DE
 185+ 5EFD 1A               LD A,(DE)
 186+ 5EFE 67               LD H,A
 187+ 5EFF E9               JP (HL) ; call function with IX=pointer to data array
 188+ 5F00
# file closed: asm\DEFUSR.asm
 184  5F00               ENDIF
 185  5F00
 186  5F00              ; temp variables for BLIT, TILE functions
 187  5F00               IF (BLIT_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS + COLL_CMD + DLOAD_CMD > 0)
 188  5F00              BLIT_TMP:
 189  5F00              TILETMP1:
 190  5F00              BLIT_TMP1:
 191  5F00 00 00         DW 0
 192  5F02              TILETMP2:
 193  5F02              BLIT_TMP2:
 194  5F02 00 00         DW 0
 195  5F04              BLIT_STRUCT:
 196  5F04 00 00 00...   DS 17
 197  5F08               ENDIF
 198  5F15
 199  5F15               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 200  5F15              VRAM_UPDATE_IN_PROGRESS:
 201  5F15 00            DB 0
 202  5F16               ENDIF
 203  5F16
 204  5F16              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 205  5F16              ; per starting letter, if no commands with this letter, NULL value
 206  5F16              CMDS:
 207  5F16 4A 5F        	DW CMDS_A ; always present due to ARTINFO
 208  5F18               IF (BLIT_CMDS + BOX_CMDS > 0) && (0 == 1)
 209  5F18 ~                DW CMDS_B ; B
 210  5F18               ELSE
 211  5F18 00 00        	DW 0
 212  5F1A               ENDIF
 213  5F1A               IF (COLL_CMD == 1) && (0 == 1)
 214  5F1A ~            	DW CMDS_C ;
 215  5F1A               ELSE
 216  5F1A 00 00            DW 0 ; C
 217  5F1C               ENDIF
 218  5F1C               IF (DLOAD_CMD > 0) && (0 == 1)
 219  5F1C ~                DW CMDS_D ; D
 220  5F1C               ELSE
 221  5F1C 00 00        	DW 0
 222  5F1E               ENDIF
 223  5F1E 00 00            DW 0 ; E
 224  5F20               IF (VRAM_CMDS + RAM_CMDS > 0) && (0 == 1)
 225  5F20 ~                DW CMDS_F; F
 226  5F20               ELSE
 227  5F20 00 00        	DW 0
 228  5F22               ENDIF
 229  5F22               IF (GENCAL_CMD > 0) && (0 == 1)
 230  5F22 ~                DW CMDS_G; G
 231  5F22               ELSE
 232  5F22 00 00        	DW 0
 233  5F24               ENDIF
 234  5F24 00 00            DW 0 ; H
 235  5F26 00 00            DW 0 ; I
 236  5F28 00 00            DW 0 ; J
 237  5F2A 00 00            DW 0 ; K
 238  5F2C 00 00            DW 0 ; L
 239  5F2E               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0) && (0 == 1)
 240  5F2E ~                DW CMDS_M ; M
 241  5F2E               ELSE
 242  5F2E 00 00        	DW 0
 243  5F30               ENDIF
 244  5F30 00 00            DW 0 ; N
 245  5F32 00 00            DW 0 ; O
 246  5F34 00 00            DW 0 ; P
 247  5F36 00 00            DW 0 ; Q
 248  5F38 00 00            DW 0 ; R
 249  5F3A               IF (SOUND_CMDS + SPRITE_CMDS > 0) && (0 == 1)
 250  5F3A ~                DW CMDS_S ; S
 251  5F3A               ELSE
 252  5F3A 00 00        	DW 0
 253  5F3C               ENDIF
 254  5F3C               IF (TILE_CMDS > 0) && (0 == 1)
 255  5F3C ~                DW CMDS_T ; T
 256  5F3C               ELSE
 257  5F3C 00 00        	DW 0
 258  5F3E               ENDIF
 259  5F3E               IF (DECOMP_CMDS > 0) && (0 == 1)
 260  5F3E ~                DW CMDS_U ; U
 261  5F3E               ELSE
 262  5F3E 00 00        	DW 0
 263  5F40               ENDIF
 264  5F40               IF ((VRAM_CMDS > 0) || (VRAM_CMDS + DECOMP_CMDS > 1)) && (0 == 1)
 265  5F40 ~                DW CMDS_V ; V
 266  5F40               ELSE
 267  5F40 00 00        	DW 0
 268  5F42               ENDIF
 269  5F42 00 00            DW 0 ; W
 270  5F44 00 00            DW 0 ; X
 271  5F46 00 00            DW 0 ; Y
 272  5F48 00 00            DW 0 ; Z
 273  5F4A
 274  5F4A               IF (0 == 1)
 275  5F4A ~             IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 276  5F4A ~            CMDS_M:
 277  5F4A ~             IF (VRAM_CMDS == 1)
 278  5F4A ~                DB "MEMVRM", 0
 279  5F4A ~                DW MEMVRM
 280  5F4A ~             ENDIF
 281  5F4A ~             IF (RAM_CMDS == 1)
 282  5F4A ~            	DB "MEMCPY", 0
 283  5F4A ~            	DW MEMCPY
 284  5F4A ~             ENDIF
 285  5F4A ~             IF (ANIM_CMDS == 1)
 286  5F4A ~            	DB "MAXANIMITEMS",0
 287  5F4A ~            	DW MAXANIMITEMS
 288  5F4A ~            	DB "MAXANIMDEFS",0
 289  5F4A ~            	DW MAXANIMDEFS
 290  5F4A ~            	DB "MAXANIMSPRS",0
 291  5F4A ~            	DW MAXANIMSPRS
 292  5F4A ~               DB "MAXAUTOSGAMS",0
 293  5F4A ~               DW MAXAUTOSGAMS
 294  5F4A ~             ENDIF
 295  5F4A ~             ENDIF
 296  5F4A ~
 297  5F4A ~             IF (VRAM_CMDS + RAM_CMDS > 0)
 298  5F4A ~            CMDS_F:
 299  5F4A ~             IF (VRAM_CMDS == 1)
 300  5F4A ~                DB "FILVRM", 0
 301  5F4A ~                DW FILVRM
 302  5F4A ~             ENDIF
 303  5F4A ~             IF (RAM_CMDS == 1)
 304  5F4A ~                DB "FILRAM", 0
 305  5F4A ~                DW FILRAM
 306  5F4A ~             ENDIF
 307  5F4A ~             ENDIF
 308  5F4A ~
 309  5F4A ~             IF (GENCAL_CMD > 0)
 310  5F4A ~            CMDS_G:
 311  5F4A ~             IF (GENCAL_CMD == 1)
 312  5F4A ~                DB "GENCAL", 0
 313  5F4A ~                DW GENCAL
 314  5F4A ~             ENDIF
 315  5F4A ~             ENDIF
 316  5F4A ~
 317  5F4A ~             IF (VRAM_CMDS > 0)
 318  5F4A ~            CMDS_V:
 319  5F4A ~             IF (VRAM_CMDS == 1)
 320  5F4A ~            	DB "VRMMEM", 0
 321  5F4A ~            	DW VRMMEM
 322  5F4A ~             ENDIF
 323  5F4A ~             IF (DECOMP_CMDS == 1)
 324  5F4A ~            	DB "VUNPACK", 0
 325  5F4A ~            	DW VUNPACK
 326  5F4A ~             ENDIF
 327  5F4A ~             ENDIF
 328  5F4A ~
 329  5F4A ~             IF (SOUND_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 330  5F4A ~            CMDS_S:
 331  5F4A ~             IF (SPRITE_CMDS + ANIM_CMDS > 0)
 332  5F4A ~                DB "SGAM",0
 333  5F4A ~                DW SGAM
 334  5F4A ~             ENDIF
 335  5F4A ~             IF (SPRITE_CMDS == 1)
 336  5F4A ~            	DB "SPRGRPMOV", 0
 337  5F4A ~            	DW SPRGRPMOV
 338  5F4A ~             ENDIF
 339  5F4A ~             IF (SOUND_CMDS == 1)
 340  5F4A ~            	DB "SNDSFX", 0
 341  5F4A ~            	DW SNDSFX
 342  5F4A ~            	DB "SNDPLYON", 0
 343  5F4A ~            	DW SNDPLYON
 344  5F4A ~            	DB "SNDPLYOFF", 0
 345  5F4A ~            	DW SNDPLYOFF
 346  5F4A ~            	DB "SNDPLYINI", 0
 347  5F4A ~            	DW SNDPLYINIT
 348  5F4A ~             ENDIF
 349  5F4A ~             IF (SPRITE_CMDS == 1)
 350  5F4A ~            	DB "SPRENABLE", 0
 351  5F4A ~            	DW SPRENABLE
 352  5F4A ~            	DB "SPRDISABLE", 0
 353  5F4A ~            	DW SPRDISABLE
 354  5F4A ~             ENDIF
 355  5F4A ~             ENDIF
 356  5F4A ~
 357  5F4A ~             IF (BLIT_CMDS + BOX_CMDS > 0)
 358  5F4A ~            CMDS_B:
 359  5F4A ~             IF (BLIT_CMDS == 1)
 360  5F4A ~            	DB "BLIT", 0
 361  5F4A ~            	DW BLIT
 362  5F4A ~             ENDIF
 363  5F4A ~             IF (BOX_CMDS == 1)
 364  5F4A ~            	DB "BOXMEMCPY", 0
 365  5F4A ~            	DW BOXMEMCPY
 366  5F4A ~            	DB "BOXMEMVRM", 0
 367  5F4A ~            	DW BOXMEMVRM
 368  5F4A ~             ENDIF
 369  5F4A ~             ENDIF
 370  5F4A ~
 371  5F4A ~             IF (TILE_CMDS > 0)
 372  5F4A ~            CMDS_T:
 373  5F4A ~             IF (TILE_CMDS == 1)
 374  5F4A ~            	DB "TILERAM", 0
 375  5F4A ~            	DW TILERAM
 376  5F4A ~            	DB "TILEVRM", 0
 377  5F4A ~            	DW TILEVRM
 378  5F4A ~             ENDIF
 379  5F4A ~             ENDIF
 380  5F4A ~
 381  5F4A ~             IF (COLL_CMD > 0)
 382  5F4A ~            CMDS_C:
 383  5F4A ~             IF (COLL_CMD == 1)
 384  5F4A ~                DB "COLL", 0
 385  5F4A ~                DW COLL
 386  5F4A ~             ENDIF
 387  5F4A ~             ENDIF
 388  5F4A ~
 389  5F4A ~             IF (DECOMP_CMDS > 0)
 390  5F4A ~            CMDS_U:
 391  5F4A ~             IF (DECOMP_CMDS == 1)
 392  5F4A ~                DB "UNPACK", 0
 393  5F4A ~                DW UNPACK
 394  5F4A ~             ENDIF
 395  5F4A ~             ENDIF
 396  5F4A ~
 397  5F4A ~             IF (DLOAD_CMD > 0)
 398  5F4A ~            CMDS_D:
 399  5F4A ~             IF (DLOAD_CMD == 1)
 400  5F4A ~                DB "DLOAD", 0
 401  5F4A ~                DW DLOAD
 402  5F4A ~             ENDIF
 403  5F4A ~             ENDIF
 404  5F4A ~
 405  5F4A ~            CMDS_A:
 406  5F4A ~             IF (ANIM_CMDS == 1)
 407  5F4A ~               DB "ANIMSTEP",0
 408  5F4A ~               DW ANIMSTEP
 409  5F4A ~            	DB "ANIMSTART",0
 410  5F4A ~            	DW ANIMSTART
 411  5F4A ~            	DB "ANIMSTOP",0
 412  5F4A ~            	DW ANIMSTOP
 413  5F4A ~            	DB "ANIMITEMPAT",0
 414  5F4A ~            	DW ANIMITEMPAT
 415  5F4A ~            	DB "ANIMITEMPTR",0
 416  5F4A ~            	DW ANIMITEMPTR_CMD
 417  5F4A ~            	DB "ANIMDEF",0
 418  5F4A ~            	DW ANIMDEF
 419  5F4A ~            	DB "ANIMSPRITE",0
 420  5F4A ~            	DW ANIMSPRITE
 421  5F4A ~               DB "ANIMCHAR",0
 422  5F4A ~               DW ANIMCHAR
 423  5F4A ~               DB "AUTOSGAMDEF",0
 424  5F4A ~               DW AUTOSGAMDEF
 425  5F4A ~               DB "AUTOSGAMSTART",0
 426  5F4A ~               DW AUTOSGAMSTART
 427  5F4A ~               DB "AUTOSGAMSTOP",0
 428  5F4A ~               DW AUTOSGAMSTOP
 429  5F4A ~             ENDIF
 430  5F4A ~               DB "ARTINFO",0
 431  5F4A ~               DW ARTINFO
 432  5F4A ~            	DB 0
 433  5F4A               ELSE // if not BASIC extension
 434  5F4A              CMDS_A:
 435  5F4A 41 52 54 49     DB "ARTINFO",0
 435  5F4E 4E 46 4F 00
 436  5F52 AD 60           DW ARTINFO
 437  5F54 00           	DB 0
 438  5F55               ENDIF
 439  5F55
 440  5F55               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 441  5F55              ; ****************************************************************************************************
 442  5F55              ; function sets VRAM address for writing
 443  5F55              ; input HL=address
 444  5F55              ; modifies AF
 445  5F55              SETWRT_LOCAL_WRITE:
 446  5F55 7D           	LD	A,L
 447  5F56 D3 99        	OUT (#99),A
 448  5F58 7C           	LD	A,H
 449  5F59 E6 3F        	AND #3F
 450  5F5B F6 40        	OR	#40
 451  5F5D D3 99        	OUT (#99),A
 452  5F5F C9           	RET
 453  5F60              ; ****************************************************************************************************
 454  5F60
 455  5F60              ; ****************************************************************************************************
 456  5F60              ; function sets VRAM address for reading
 457  5F60              ; input HL=address
 458  5F60              ; modifies AF
 459  5F60              SETWRT_LOCAL_READ:
 460  5F60 7D           	LD	A,L
 461  5F61 D3 99        	OUT (#99),A
 462  5F63 7C           	LD	A,H
 463  5F64 E6 3F        	AND #3F
 464  5F66 00              NOP
 465  5F67 D3 99        	OUT (#99),A
 466  5F69 C9           	RET
 467  5F6A              ; ****************************************************************************************************
 468  5F6A               ENDIF
 469  5F6A
 470  5F6A               IF (VRAM_CMDS + TILE_CMDS > 0)
 471  5F6A              ; ****************************************************************************************************
 472  5F6A              ; function copies data from RAM to VRAM
 473  5F6A              ; input HL=address in RAM
 474  5F6A              ; input B=count
 475  5F6A              ; modifies AF, BC, HL
 476  5F6A              BBYTECOPY:
 477  5F6A 0E 98        	LD C,#98
 478  5F6C              BBYTECOPY_NO_C:
 479  5F6C ED A3        	OUTI
 480  5F6E C2 6C 5F     	JP	NZ, BBYTECOPY_NO_C
 481  5F71 C9           	RET
 482  5F72              ; ****************************************************************************************************
 483  5F72               ENDIF
 484  5F72
 485  5F72              ; ****************************************************************************************************
 486  5F72              ; function multiplies HL by 32
 487  5F72              HLx32:
 488  5F72 29           	ADD HL,HL
 489  5F73              ; ****************************************************************************************************
 490  5F73              ; function multiplies HL by 16
 491  5F73              HLx16:
 492  5F73 29           	ADD HL,HL
 493  5F74              ; ****************************************************************************************************
 494  5F74              ; function multiplies HL by 8
 495  5F74              HLx8:
 496  5F74 29          > ADD HL, HL
 496  5F75 29          > ADD HL, HL
 496  5F76 29          > ADD HL, HL
 497  5F77 C9           	RET
 498  5F78              ; ****************************************************************************************************
 499  5F78
 500  5F78              ; ****************************************************************************************************
 501  5F78              ; function gets slot and subslot data for specific page
 502  5F78              ; input A=page (0, 1 or 2)
 503  5F78              ; output B = 0A8H register value
 504  5F78              ; output D = 0 is no subslots, 1 if yes
 505  5F78              ; output C = 0A8H value when page 3 slot equals to requested page slot
 506  5F78              ; output E = subslot value if present
 507  5F78              ; modifies AF, BC, DE, HL
 508  5F78              GET_PAGE_INFO:
 509  5F78 6F               LD L, A
 510  5F79 C6 C1            ADD A, low (EXPTBL)
 511  5F7B 32 85 5F         LD (GET_PAGE_INFO_L1+1), A
 512  5F7E DB A8            IN A, (0A8H)
 513  5F80 47               LD B, A
 514  5F81 E6 3F            AND 03FH
 515  5F83 4F               LD C, A
 516  5F84              GET_PAGE_INFO_L1:
 517  5F84 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 518  5F87 E6 80            AND 080H
 519  5F89 28 1B            JR Z, GET_PAGE_INFO_L2
 520  5F8B                  ; expanded
 521  5F8B 2D               DEC L
 522  5F8C FA AB 5F         JP M, GET_PAGE_INFO_L3
 523  5F8F 2D               DEC L
 524  5F90 FA A9 5F         JP M, GET_PAGE_INFO_L4
 525  5F93                  ; page 2
 526  5F93 07               RLCA
 527  5F94 07               RLCA
 528  5F95              GET_PAGE_INFO_L5:
 529  5F95 E6 C0            AND 0C0H
 530  5F97 B1               OR C
 531  5F98 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 532  5F9A 4F               LD C, A
 533  5F9B 3A FF FF         LD A, (0FFFFH)
 534  5F9E 2F               CPL
 535  5F9F 5F               LD E, A
 536  5FA0 16 01            LD D, 1
 537  5FA2 78               LD A, B ; return stack
 538  5FA3 D3 A8            OUT (0A8H), A
 539  5FA5 C9               RET
 540  5FA6              GET_PAGE_INFO_L2:
 541  5FA6                  ; not expanded
 542  5FA6 16 00            LD D, 0
 543  5FA8 C9               RET
 544  5FA9              GET_PAGE_INFO_L4:
 545  5FA9                  ; page 1
 546  5FA9 0F               RRCA
 547  5FAA 0F               RRCA
 548  5FAB              GET_PAGE_INFO_L3:
 549  5FAB                  ; page 0
 550  5FAB 0F               RRCA
 551  5FAC 0F               RRCA
 552  5FAD 18 E6            JR GET_PAGE_INFO_L5
 553  5FAF              ; ****************************************************************************************************
 554  5FAF
 555  5FAF              ; ****************************************************************************************************
 556  5FAF              ; function returns original slot and subslot info
 557  5FAF              ; input B = 0A8H register value
 558  5FAF              ; input D = 0 is no subslots, 1 if yes
 559  5FAF              ; input C = 0A8H value when page 3 slot equals to requested page slot
 560  5FAF              ; input E = subslot value if present
 561  5FAF              ; modifies AF, disables interrupts
 562  5FAF              RESTORE_PAGE_INFO:
 563  5FAF F3              DI
 564  5FB0 7A              LD A, D
 565  5FB1 B7              OR A
 566  5FB2 28 07           JR Z, RESTORE_PAGE_INFO_L1
 567  5FB4 79              LD A, C
 568  5FB5 D3 A8           OUT (0A8H), A
 569  5FB7 7B              LD A, E
 570  5FB8 32 FF FF        LD (0FFFFH), A
 571  5FBB              RESTORE_PAGE_INFO_L1:
 572  5FBB 78              LD A, B
 573  5FBC D3 A8           OUT (0A8H), A
 574  5FBE              NOACTION_DEFUSR: ; just a safe RET for use when DEFUSR table has an empty entry
 575  5FBE C9              RET
 576  5FBF              ; ****************************************************************************************************
 577  5FBF
 578  5FBF              ; *******************************************************************************************************
 579  5FBF              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 580  5FBF              ; INPUT:  A = SLOT ID: EXXXSSPP
 581  5FBF              ; E = EXPANDED FLAG
 582  5FBF              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 583  5FBF              ; PP = PRIMARY SLOT NUMBER
 584  5FBF              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 585  5FBF              ; CHANGES: AF, BC, DE
 586  5FBF
 587  5FBF              LOCAL_ENASLT:
 588  5FBF CD DF 5F         CALL L0353
 589  5FC2 FA CC 5F         JP M, L0340
 590  5FC5 DB A8            IN A, (0A8H)
 591  5FC7 A1               AND C
 592  5FC8 B0               OR B
 593  5FC9 D3 A8            OUT (0A8H), A
 594  5FCB C9               RET
 595  5FCC              L0340:
 596  5FCC E5               PUSH HL
 597  5FCD CD 04 60         CALL L0378
 598  5FD0 4F               LD C, A
 599  5FD1 06 00            LD B, 0
 600  5FD3 7D               LD A, L
 601  5FD4 A4               AND H
 602  5FD5 B2               OR D
 603  5FD6 21 C5 FC         LD HL, 0FCC5H
 604  5FD9 09               ADD HL, BC
 605  5FDA 77               LD (HL), A
 606  5FDB E1               POP HL
 607  5FDC 79               LD A, C
 608  5FDD 18 E0            JR LOCAL_ENASLT
 609  5FDF              L0353:
 610  5FDF F3               DI
 611  5FE0 F5               PUSH AF
 612  5FE1 7C               LD A, H
 613  5FE2 07               RLCA
 614  5FE3 07               RLCA
 615  5FE4 E6 03            AND 3
 616  5FE6 5F               LD E, A
 617  5FE7 3E C0            LD A, 0C0H
 618  5FE9              L035D:
 619  5FE9 07               RLCA
 620  5FEA 07               RLCA
 621  5FEB 1D               DEC E
 622  5FEC F2 E9 5F         JP P, L035D
 623  5FEF 5F               LD E, A
 624  5FF0 2F               CPL
 625  5FF1 4F               LD C, A
 626  5FF2 F1               POP AF
 627  5FF3 F5               PUSH AF
 628  5FF4 E6 03            AND 3
 629  5FF6 3C               INC A
 630  5FF7 47               LD B, A
 631  5FF8 3E AB            LD A, 0ABH
 632  5FFA              L036E:
 633  5FFA C6 55            ADD A, 055H
 634  5FFC 10 FC            DJNZ L036E
 635  5FFE 57               LD D, A
 636  5FFF A3               AND E
 637  6000 47               LD B, A
 638  6001 F1               POP AF
 639  6002 A7               AND A
 640  6003 C9               RET
 641  6004              L0378:
 642  6004 F5               PUSH AF
 643  6005 7A               LD A, D
 644  6006 E6 C0            AND 0C0H
 645  6008 4F               LD C, A
 646  6009 F1               POP AF
 647  600A F5               PUSH AF
 648  600B 57               LD D, A
 649  600C DB A8            IN A, (0A8H)
 650  600E 47               LD B, A
 651  600F E6 3F            AND 03FH
 652  6011 B1               OR C
 653  6012 D3 A8            OUT (0A8H), A
 654  6014 7A               LD A, D
 655  6015 0F               RRCA
 656  6016 0F               RRCA
 657  6017 E6 03            AND 3
 658  6019 57               LD D, A
 659  601A 3E AB            LD A, 0ABH
 660  601C              L0390:
 661  601C C6 55            ADD A, 055H
 662  601E 15               DEC D
 663  601F F2 1C 60         JP P, L0390
 664  6022 A3               AND E
 665  6023 57               LD D, A
 666  6024 7B               LD A, E
 667  6025 2F               CPL
 668  6026 67               LD H, A
 669  6027 3A FF FF         LD A, (0FFFFH)
 670  602A 2F               CPL
 671  602B 6F               LD L, A
 672  602C A4               AND H
 673  602D B2               OR D
 674  602E 32 FF FF         LD (0FFFFH), A
 675  6031 78               LD A, B
 676  6032 D3 A8            OUT (0A8H), A
 677  6034 F1               POP AF
 678  6035 E6 03            AND 3
 679  6037 C9               RET
 680  6038              ; *******************************************************************************************************
 681  6038
 682  6038              ; *******************************************************************************************************
 683  6038              ; some common code to activate page 0 and place values needed to restore original page on stack
 684  6038              ; input IY=return address
 685  6038              ENABLE_PAGE0:
 686  6038 F3              DI
 687  6039 AF              XOR A
 688  603A CD 78 5F        CALL GET_PAGE_INFO
 689  603D C5              PUSH BC
 690  603E D5              PUSH DE
 691  603F 3A 41 F3        LD A, (RAMAD0)
 692  6042 26 00           LD H, 0
 693  6044 CD BF 5F        CALL LOCAL_ENASLT
 694  6047 FD E9        	JP (IY)
 695  6049              ; *******************************************************************************************************
 696  6049
 697  6049              ; General BASIC CALL-instruction handler
 698  6049              CALLHAND:
 699  6049 FB              EI
 700  604A E5           	PUSH HL
 701  604B 21 16 5F     	LD	HL, CMDS ; pointer table based on starting letter
 702  604E 3A 89 FD        LD A, (PROCNM)
 703  6051 D6 41           SUB 'A'
 704  6053 87              ADD A, A
 705  6054 16 00           LD D, 0
 706  6056 5F              LD E, A
 707  6057 19              ADD HL, DE
 708  6058 5E              LD E, (HL)
 709  6059 23              INC HL
 710  605A 56              LD D, (HL)
 711  605B 7A              LD A, D
 712  605C B3              OR E
 713  605D 28 23           JR Z, .CMDNOTRECOGNIZED
 714  605F EB              EX DE, HL
 715  6060              .CHKCMD:
 716  6060 11 89 FD     	LD	DE, PROCNM
 717  6063              .LOOP:
 718  6063 1A              LD	A,(DE)
 719  6064 BE           	CP	(HL)
 720  6065 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 721  6067 13           	INC	DE
 722  6068 23           	INC	HL
 723  6069 A7           	AND	A
 724  606A 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 725  606C 5E           	LD	E,(HL)
 726  606D 23           	INC	HL
 727  606E 56           	LD	D,(HL)
 728  606F E1           	POP	HL		; routine address
 729  6070 CD 91 60     	CALL	GETPREVCHAR
 730  6073 CD 85 60     	CALL	.CALLDE		; Call routine
 731  6076 A7           	AND	A
 732  6077 C9           	RET
 733  6078
 734  6078              .TONEXTCMD:
 735  6078 0E FF        	LD	C,0FFH
 736  607A AF           	XOR	A
 737  607B ED B1        	CPIR			; Skip to end of instruction name
 738  607D 23           	INC	HL
 739  607E 23           	INC	HL		; Skip address
 740  607F BE           	CP	(HL)
 741  6080 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 742  6082              .CMDNOTRECOGNIZED:
 743  6082 E1           	POP	HL
 744  6083 37              SCF
 745  6084 C9           	RET
 746  6085
 747  6085              .CALLDE:
 748  6085 D5           	PUSH	DE
 749  6086 C9           	RET
 750  6087
 751  6087              ;---------------------------
 752  6087
 753  6087              CHKCHAR:
 754  6087 CD 91 60     	CALL	GETPREVCHAR	; Get previous basic char
 755  608A E3           	EX	(SP),HL
 756  608B BE           	CP	(HL) 	        ; Check if good char
 757  608C 20 0D        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 758  608E 23           	INC	HL
 759  608F E3           	EX	(SP),HL
 760  6090 23           	INC	HL		; Get next basic char
 761  6091
 762  6091              GETPREVCHAR:
 763  6091 2B           	DEC HL
 764  6092 DD 21 66 46  	LD	IX,CHRGTR
 765  6096 CD 59 01     	CALL CALBAS
 766  6099 FB              EI
 767  609A C9              RET
 768  609B
 769  609B               IF (0 == 1)
 770  609B ~             IF (DLOAD_CMD == 1)
 771  609B ~            BAD_FILENAME:
 772  609B ~               LD E,56
 773  609B ~               JR THROW_ERROR
 774  609B ~            DISKIOERR:
 775  609B ~               LD E,69
 776  609B ~               JR THROW_ERROR
 777  609B ~             ENDIF
 778  609B ~            OUT_OF_DATA:
 779  609B ~               LD E, 4
 780  609B ~               JR THROW_ERROR
 781  609B ~            TYPE_MISMATCH:
 782  609B ~               LD E, 13 ; Type mismatch
 783  609B ~               JR THROW_ERROR
 784  609B ~            SUBSCRIPT_OUT_OF_RANGE:
 785  609B ~               LD E,9 ; subscript out of range
 786  609B ~            	JR THROW_ERROR
 787  609B ~            OVERFLOW:
 788  609B ~            	LD E,6
 789  609B ~            	JR THROW_ERROR
 790  609B ~            ILLEGAL_FUNCTION:
 791  609B ~               LD E, 5 ; illegal function call
 792  609B ~               JR THROW_ERROR
 793  609B               ENDIF
 794  609B              SYNTAX_ERROR:
 795  609B 1E 02           LD E, 2 ; Syntax error
 796  609D              THROW_ERROR:
 797  609D DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 798  60A1 C3 59 01     	JP	CALBAS
 799  60A4
 800  60A4
 801  60A4              ;---------------------------
 802  60A4
 803  60A4               IF (DLOAD_CMD == 1)
 804  60A4              ; *******************************************************************************************************
 805  60A4              ; helper function to make an uppercase letter
 806  60A4              ; input A=character
 807  60A4              ; output A=uppercase version of input
 808  60A4              UPPER:
 809  60A4 FE 61           CP "a"
 810  60A6 D8              RET C
 811  60A7 FE 7B           CP "z"+1
 812  60A9 D0              RET NC
 813  60AA E6 5F           AND 5FH
 814  60AC C9              RET
 815  60AD              ; *******************************************************************************************************
 816  60AD               ENDIF
 817  60AD
 818  60AD               IF (0 == 1)
 819  60AD ~
 820  60AD ~             IF (DLOAD_CMD == 1)
 821  60AD ~            ; *******************************************************************************************************
 822  60AD ~            ; helper function to return string pointer and length
 823  60AD ~            ; returns HL = String Address
 824  60AD ~            ; returns B  = Lenght
 825  60AD ~            ; modifies BC, DE, HL
 826  60AD ~            GETSTRPNT:
 827  60AD ~               LD      HL,(USR)
 828  60AD ~               LD      B,(HL)
 829  60AD ~               INC     HL
 830  60AD ~               LD      E,(HL)
 831  60AD ~               INC     HL
 832  60AD ~               LD      D,(HL)
 833  60AD ~               EX      DE,HL
 834  60AD ~               RET
 835  60AD ~            ; *******************************************************************************************************
 836  60AD ~
 837  60AD ~            ; *******************************************************************************************************
 838  60AD ~            ; helper function to get string parameter
 839  60AD ~            ; throws error if incorrect type
 840  60AD ~            ; input HL=basic text
 841  60AD ~            EVALTXTPARAM:
 842  60AD ~            	LD	IX,FRMEVL
 843  60AD ~            	CALL CALBAS		; Evaluate expression
 844  60AD ~               LD A,(VALTYP)
 845  60AD ~               CP 3               ; Text type?
 846  60AD ~               JP NZ,TYPE_MISMATCH
 847  60AD ~               PUSH HL
 848  60AD ~               LD	IX,FRESTR         ; Free the temporary string
 849  60AD ~               CALL CALBAS
 850  60AD ~               POP HL
 851  60AD ~               RET
 852  60AD ~            ; *******************************************************************************************************
 853  60AD ~
 854  60AD ~             ENDIF
 855  60AD ~
 856  60AD ~            ; *******************************************************************************************************
 857  60AD ~            ; helper function to get pointer to BASIC array data
 858  60AD ~            ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
 859  60AD ~            ; input B=dimensions (1 or 2)
 860  60AD ~            ; input D=minimal first dimension
 861  60AD ~            ; input E=minimal second dimension, if applicable
 862  60AD ~            ; returns BC=pointer to first data element
 863  60AD ~            ; throws BASIC error if invalid type
 864  60AD ~            GET_BASIC_ARRAY_DATA_POINTER:
 865  60AD ~            	PUSH DE
 866  60AD ~            	PUSH BC
 867  60AD ~            	PUSH AF
 868  60AD ~               LD A,1
 869  60AD ~               LD (SUBFLG),A ; search for arrays only
 870  60AD ~            	LD IX, PTRGET
 871  60AD ~            	CALL CALBAS
 872  60AD ~               XOR A
 873  60AD ~               LD (SUBFLG),A ; if not reset will cause syntax errors
 874  60AD ~            	LD A,(VALTYP)
 875  60AD ~            	POP DE ; required type
 876  60AD ~            	CP D
 877  60AD ~            	JP NZ,TYPE_MISMATCH
 878  60AD ~            	LD A,(BC)
 879  60AD ~            	INC BC
 880  60AD ~            	POP DE ; required number of dimensions
 881  60AD ~            	CP D
 882  60AD ~            	JP NZ,TYPE_MISMATCH
 883  60AD ~            	POP DE ; required minimal array dimensions
 884  60AD ~            	DEC A
 885  60AD ~            	JR Z,.ONE_DIMENSION
 886  60AD ~            	; 2-dimension array
 887  60AD ~            	LD A,(BC)
 888  60AD ~            	.2 INC BC
 889  60AD ~            	CP E
 890  60AD ~            	JP C,SUBSCRIPT_OUT_OF_RANGE
 891  60AD ~            .ONE_DIMENSION:
 892  60AD ~            	LD A,(BC)
 893  60AD ~            	.2 INC BC
 894  60AD ~            	CP D
 895  60AD ~            	JP C,SUBSCRIPT_OUT_OF_RANGE
 896  60AD ~            	RET
 897  60AD ~            ; *******************************************************************************************************
 898  60AD               ENDIF
 899  60AD
 900  60AD              ; *******************************************************************************************************
 901  60AD              ; function to handle CALL ARTINFO basic extension
 902  60AD              ; returns info about the extension
 903  60AD              ; _ARTINFO ( INT variable version,
 904  60AD              ;			    INT variable build_flags,
 905  60AD              ;			    INT variable free_memory_ptr )
 906  60AD              ; this function is always available and can be used to test if the extension is active
 907  60AD              ARTINFO:
 908  60AD              	; opening (
 909  60AD CD 87 60     	CALL CHKCHAR
 910  60B0 28           	DB '('
 911  60B1              	; get address of version variable
 912  60B1 DD 21 A4 5E  	LD IX, PTRGET
 913  60B5 CD 59 01     	CALL CALBAS
 914  60B8 3A 12 40     	LD A,(VERSION)
 915  60BB 12              LD (DE),A
 916  60BC 13              INC DE
 917  60BD 3A 13 40        LD A,(VERSION+1)
 918  60C0 12              LD (DE),A
 919  60C1              	; comma
 920  60C1 CD 87 60     	CALL CHKCHAR
 921  60C4 2C           	DB ','
 922  60C5              	; get address of build flags variable
 923  60C5 DD 21 A4 5E  	LD IX, PTRGET
 924  60C9 CD 59 01     	CALL CALBAS
 925  60CC E5              PUSH HL
 926  60CD 21 FF 1B        LD HL,SOUND_CMDS+2*RAM_CMDS+4*VRAM_CMDS+8*BLIT_CMDS+16*SPRITE_CMDS+32*GENCAL_CMD+64*TILE_CMDS+128*BOX_CMDS+256*ANIM_CMDS+512*COLL_CMD+1024*0+2048*1+4096*DECOMP_CMDS
 927  60D0 EB              EX DE,HL
 928  60D1 73              LD (HL),E
 929  60D2 23              INC HL
 930  60D3 72              LD (HL),D
 931  60D4 E1              POP HL
 932  60D5              	; comma
 933  60D5 CD 87 60     	CALL CHKCHAR
 934  60D8 2C           	DB ','
 935  60D9              	; get address of free memory variable
 936  60D9 DD 21 A4 5E  	LD IX, PTRGET
 937  60DD CD 59 01     	CALL CALBAS
 938  60E0 3A 10 40     	LD A,(FREEMEMPTR)
 939  60E3 12              LD (DE),A
 940  60E4 13              INC DE
 941  60E5 3A 11 40        LD A,(FREEMEMPTR+1)
 942  60E8 12              LD (DE),A
 943  60E9              	; ending )
 944  60E9 CD 87 60     	CALL CHKCHAR
 945  60EC 29           	DB ')'
 946  60ED C9           	RET
 947  60EE              ; *******************************************************************************************************
 948  60EE
 949  60EE              EXT_END:
 950  60EE
# file closed: asm\main.asm
