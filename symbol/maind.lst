# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		   EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000              COLL_CMD       EQU 1
  14  4000              DECOMP_CMDS    EQU 1
  15  4000              DLOAD_CMD      EQU 1
  16  4000
  17  4000              ; what to compile, provided in sjasmplus command line
  18  4000              ;BASIC_EXTENSION   EQU 1
  19  4000              ;DEFUSR_EXTENSION  EQU 0
  20  4000
  21  4000              CHPUT   EQU    #A2
  22  4000              CALBAS  EQU		#159
  23  4000              ERRHAND EQU    #406F
  24  4000              FRMEVL  EQU    #4C64
  25  4000              FRESTR  EQU		#67D0
  26  4000              ; FRMQNT = formula quantificator
  27  4000              ; input HL=pointer to current program expression
  28  4000              ; output HL=next address
  29  4000              ; output DE=integer datum
  30  4000              FRMQNT	EQU		#542F
  31  4000              ; GETBYT = get byte parameter
  32  4000              ; input HL=pointer to current program expression
  33  4000              ; output HL=next address
  34  4000              ; output A=E=byte read
  35  4000              GETBYT		EQU	#521C
  36  4000              CHRGTR  	   EQU   #4666
  37  4000              PTRGET		EQU 	#5EA4
  38  4000              SUBFLG		EQU	#F6A5
  39  4000              SYNCHR		EQU	#558C
  40  4000              VALTYP  	   EQU   #F663
  41  4000              DAC         EQU   #F7F6
  42  4000              USR     	   EQU   #F7F8
  43  4000              PROCNM		EQU	#FD89
  44  4000              BIOS_FILVRM EQU   #0056
  45  4000              CLIKSW		EQU	#F3DB
  46  4000
  47  4000              RAMAD0	   EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  48  4000              RAMAD1	   EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  49  4000              RAMAD2	   EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  50  4000              RAMAD3	   EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  51  4000              EXPTBL	   EQU   #FCC1
  52  4000              SCRMOD	   EQU   #FCAF ; current screen mode
  53  4000              REG1SAV     EQU   #F3E0 ; VDP(1)
  54  4000              JIFFY	      EQU   #FC9E
  55  4000              GRPPAT	   EQU   #F3CF ; SCREEN 2 sprite generator table address
  56  4000              GRPCGP		EQU	#F3CB ; SCREEN 2 pattern generator table address
  57  4000              GRPATR      EQU   #F3CD ; SCREEN 2 sprite attribute table address
  58  4000              T32PAT	   EQU   #F3C5 ; SCREEN 1 sprite generator table address
  59  4000              T32CGP      EQU   #F3C1 ; SCREEN 1 pattern ganarator table address
  60  4000              T32ATR      EQU   #F3C3 ; SCREEN 1 sprite attribute table address
  61  4000
  62  4000              FCB0        EQU   #F353 ; location of FCB 0
  63  4000              BDOS        EQU   #F37D ; disk functions
  64  4000              NULBUF      EQU   #F862 ; disk buffer of 256 bytes address
  65  4000
  66  4000              ; BASIC error codes
  67  4000              ;01 NEXT without FOR
  68  4000              ;02 Syntax error
  69  4000              ;03 RETURN without GOSUB
  70  4000              ;04 Out of DATA
  71  4000              ;05 Illegal function call
  72  4000              ;06 Overflow
  73  4000              ;07 Out of memory
  74  4000              ;08 Undefined line number
  75  4000              ;09 Subscript out of range
  76  4000              ;10 Redimensioned array
  77  4000              ;11 Division by zero
  78  4000              ;12 Illegal direct
  79  4000              ;13 Type mismatch
  80  4000              ;14 Out of string space
  81  4000              ;15 String too long
  82  4000              ;16 String formula too complex
  83  4000              ;17 Can't CONTINUE
  84  4000              ;18 Undefined user function
  85  4000              ;19 Device I/O error
  86  4000              ;20 Verify error
  87  4000              ;21 No RESUME
  88  4000              ;22 RESUME without error
  89  4000              ;23 Unprintable error
  90  4000              ;24 Missing operand
  91  4000              ;25 Line buffer overflow
  92  4000              ;50 FIELD overflow
  93  4000              ;51 Internal error
  94  4000              ;52 Bad file number
  95  4000              ;53 File not found
  96  4000              ;54 File already open
  97  4000              ;55 Input past end
  98  4000              ;56 Bad file name
  99  4000              ;57 Direct statement in file
 100  4000              ;58 Sequential I/O only
 101  4000              ;59 File not OPEN
 102  4000
 103  4000
 104  4000               ; simulate cartridge with BASIC extension
 105  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
 105  4004 94 60 00 00
 105  4008 00 00 00 00
 105  400C 00 00 00 00
 106  4010
 107  4010              ; this location #4010 stores last location used by basic extension
 108  4010              ; free memory after that point
 109  4010              FREEMEMPTR:
 110  4010 39 61         DW EXT_END
 111  4012
 112  4012              ; this location #4012 stores extension version in DAA format
 113  4012              ; first byte is major version and second minor
 114  4012              VERSION:
 115  4012 00 93         DB #00, #93
 116  4014
 117  4014              ; this location #4014 contains a jump to entry point for DEFUSR approach
 118  4014              ; if excluded it contains 3xRET so that sound player can be at aspecific spot
 119  4014               IF (1 == 1)
 120  4014 C3 18 5F        JP DEFUSR_ENTRY
 121  4017               ELSE
 122  4017 ~               .3 RET
 123  4017               ENDIF
 124  4017
 125  4017              ; binary included AKG player compiled at #4017
 126  4017               IF (SOUND_CMDS == 1)
 127  4017              	INCBIN "bin/AKG.bin"
 128  4CF3              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF3              MAIN_PLAYER_START EQU 04017H
   2+ 4CF3              PLY_AKG_START EQU 04017H
   3+ 4CF3              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 04020H
   4+ 4CF3              PLY_AKG_INITSOUNDEFFECTS EQU 04020H
   5+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04024H
   6+ 4CF3              PLY_AKG_PLAYSOUNDEFFECT EQU 04024H
   7+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04025H
   8+ 4CF3              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04025H
   9+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 0404CH
  10+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 0404CH
  11+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 0405AH
  12+ 4CF3              PLY_AKG_PSES_PLAY EQU 04093H
  13+ 4CF3              PLY_AKG_PSES_READFIRSTBYTE EQU 0409CH
  14+ 4CF3              PLY_AKG_PSES_S_ENDORLOOP EQU 040B4H
  15+ 4CF3              PLY_AKG_PSES_S_LOOP EQU 040BFH
  16+ 4CF3              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C5H
  17+ 4CF3              PLY_AKG_PSES_NOTREACHED EQU 040D8H
  18+ 4CF3              PLY_AKG_PSES_HARDWAREONLY EQU 040DCH
  19+ 4CF3              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E3H
  20+ 4CF3              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F5H
  21+ 4CF3              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FFH
  22+ 4CF3              PLY_AKG_PSES_H_AFTERRETRIG EQU 04109H
  23+ 4CF3              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411DH
  24+ 4CF3              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 04122H
  25+ 4CF3              PLY_AKG_PSES_READHARDWAREPERIOD EQU 0412AH
  26+ 4CF3              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04135H
  27+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 04141H
  28+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04143H
  29+ 4CF3              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04149H
  30+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414DH
  31+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414DH
  32+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414FH
  33+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414FH
  34+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414FH
  35+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 04150H
  36+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 04151H
  37+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04155H
  38+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04155H
  39+ 4CF3              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04155H
  40+ 4CF3              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415DH
  41+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04165H
  42+ 4CF3              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04165H
  43+ 4CF3              PLY_AKG_INIT EQU 04165H
  44+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04165H
  45+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04193H
  46+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A7H
  47+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B9H
  48+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D8H
  49+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E5H
  50+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL EQU 041EBH
  51+ 4CF3              PLY_AKG_INITTABLE0 EQU 041EEH
  52+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EEH
  53+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04208H
  54+ 4CF3              PLY_AKG_INITTABLE0_END EQU 04208H
  55+ 4CF3              PLY_AKG_INITTABLE1 EQU 04208H
  56+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04208H
  57+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 0420CH
  58+ 4CF3              PLY_AKG_INITTABLE1_END EQU 0420CH
  59+ 4CF3              PLY_AKG_INITTABLEORA EQU 0420CH
  60+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 0420CH
  61+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04224H
  62+ 4CF3              PLY_AKG_INITTABLEORA_END EQU 04224H
  63+ 4CF3              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04224H
  64+ 4CF3              PLY_AKG_STOP EQU 04224H
  65+ 4CF3              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04236H
  66+ 4CF3              PLY_AKG_PLAY EQU 04236H
  67+ 4CF3              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423EH
  68+ 4CF3              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04244H
  69+ 4CF3              PLY_AKG_READLINKER EQU 04249H
  70+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04249H
  71+ 4CF3              PLY_AKG_READLINKER_PTLINKER EQU 04249H
  72+ 4CF3              PLY_AKG_READLINKER_NOLOOP EQU 04254H
  73+ 4CF3              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428DH
  74+ 4CF3              PLY_AKG_READLINE EQU 04290H
  75+ 4CF3              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 04290H
  76+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04296H
  77+ 4CF3              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04296H
  78+ 4CF3              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A3H
  79+ 4CF3              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A7H
  80+ 4CF3              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042AAH
  81+ 4CF3              PLY_AKG_SPEEDTRACK_END EQU 042ADH
  82+ 4CF3              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042ADH
  83+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B3H
  84+ 4CF3              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B3H
  85+ 4CF3              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042C0H
  86+ 4CF3              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C4H
  87+ 4CF3              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C7H
  88+ 4CF3              PLY_AKG_EVENTTRACK_END EQU 042CAH
  89+ 4CF3              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042CAH
  90+ 4CF3              PLY_AKG_CHANNEL1_READTRACK EQU 042D6H
  91+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D6H
  92+ 4CF3              PLY_AKG_CHANNEL1_PTTRACK EQU 042D6H
  93+ 4CF3              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042F1H
  94+ 4CF3              PLY_AKG_CHANNEL1_WAIT EQU 042FCH
  95+ 4CF3              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04303H
  96+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04303H
  97+ 4CF3              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04303H
  98+ 4CF3              PLY_AKG_CHANNEL1_NOTE EQU 0430CH
  99+ 4CF3              PLY_AKG_BASENOTEINDEX EQU 0430CH
 100+ 4CF3              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430EH
 101+ 4CF3              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430EH
 102+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431EH
 103+ 4CF3              PLY_AKG_INSTRUMENTSTABLE EQU 0431EH
 104+ 4CF3              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 04330H
 105+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 04340H
 106+ 4CF3              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04368H
 107+ 4CF3              PLY_AKG_CHANNEL1_READCELLEND EQU 0436BH
 108+ 4CF3              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 0436BH
 109+ 4CF3              PLY_AKG_CHANNEL2_READTRACK EQU 04377H
 110+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04377H
 111+ 4CF3              PLY_AKG_CHANNEL2_PTTRACK EQU 04377H
 112+ 4CF3              PLY_AKG_CHANNEL2_SMALLWAIT EQU 04392H
 113+ 4CF3              PLY_AKG_CHANNEL2_WAIT EQU 0439DH
 114+ 4CF3              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A4H
 115+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A4H
 116+ 4CF3              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A4H
 117+ 4CF3              PLY_AKG_CHANNEL2_NOTE EQU 043ADH
 118+ 4CF3              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043B2H
 119+ 4CF3              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043B2H
 120+ 4CF3              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D4H
 121+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E4H
 122+ 4CF3              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 0440CH
 123+ 4CF3              PLY_AKG_CHANNEL2_READCELLEND EQU 0440FH
 124+ 4CF3              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440FH
 125+ 4CF3              PLY_AKG_CHANNEL3_READTRACK EQU 0441BH
 126+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 0441BH
 127+ 4CF3              PLY_AKG_CHANNEL3_PTTRACK EQU 0441BH
 128+ 4CF3              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04436H
 129+ 4CF3              PLY_AKG_CHANNEL3_WAIT EQU 04441H
 130+ 4CF3              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04448H
 131+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04448H
 132+ 4CF3              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04448H
 133+ 4CF3              PLY_AKG_CHANNEL3_NOTE EQU 04451H
 134+ 4CF3              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04456H
 135+ 4CF3              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04456H
 136+ 4CF3              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04478H
 137+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04488H
 138+ 4CF3              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044B0H
 139+ 4CF3              PLY_AKG_CHANNEL3_READCELLEND EQU 044B3H
 140+ 4CF3              PLY_AKG_CURRENTSPEED EQU 044B3H
 141+ 4CF3              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B5H
 142+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B8H
 143+ 4CF3              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B8H
 144+ 4CF3              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044BBH
 145+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BEH
 146+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BEH
 147+ 4CF3              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044CAH
 148+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044D1H
 149+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D4H
 150+ 4CF3              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044DAH
 151+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DDH
 152+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DDH
 153+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044EBH
 154+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044F0H
 155+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044FBH
 156+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FEH
 157+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FEH
 158+ 4CF3              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 04501H
 159+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04504H
 160+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04504H
 161+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450DH
 162+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04517H
 163+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 0451AH
 164+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 0451AH
 165+ 4CF3              PLY_AKG_CHANNEL1_PITCH EQU 0451AH
 166+ 4CF3              PLY_AKG_CHANNEL1_ISPITCH EQU 0451DH
 167+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 04522H
 168+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACK EQU 04522H
 169+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04526H
 170+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04528H
 171+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 0452AH
 172+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 04531H
 173+ 4CF3              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 04532H
 174+ 4CF3              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04535H
 175+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04535H
 176+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 04551H
 177+ 4CF3              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 04551H
 178+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455EH
 179+ 4CF3              PLY_AKG_CHANNEL1_GLIDEOVER EQU 04562H
 180+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 04572H
 181+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 04572H
 182+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04573H
 183+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04574H
 184+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04576H
 185+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04576H
 186+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04576H
 187+ 4CF3              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04577H
 188+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04578H
 189+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 0457AH
 190+ 4CF3              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 0457AH
 191+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 0457AH
 192+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 0457AH
 193+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 0457AH
 194+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457DH
 195+ 4CF3              PLY_AKG_CHANNEL1_PITCH_END EQU 0457FH
 196+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04587H
 197+ 4CF3              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04587H
 198+ 4CF3              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 0458AH
 199+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458DH
 200+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458DH
 201+ 4CF3              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04599H
 202+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 045A0H
 203+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A3H
 204+ 4CF3              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A9H
 205+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045ACH
 206+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045ACH
 207+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045BAH
 208+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BFH
 209+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045CAH
 210+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CDH
 211+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CDH
 212+ 4CF3              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045D0H
 213+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D3H
 214+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D3H
 215+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045DCH
 216+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E6H
 217+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E9H
 218+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E9H
 219+ 4CF3              PLY_AKG_CHANNEL2_PITCH EQU 045E9H
 220+ 4CF3              PLY_AKG_CHANNEL2_ISPITCH EQU 045ECH
 221+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045F1H
 222+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045F1H
 223+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F5H
 224+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F7H
 225+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F9H
 226+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 04600H
 227+ 4CF3              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 04601H
 228+ 4CF3              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04604H
 229+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04604H
 230+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 04620H
 231+ 4CF3              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 04620H
 232+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462DH
 233+ 4CF3              PLY_AKG_CHANNEL2_GLIDEOVER EQU 04631H
 234+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 04641H
 235+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 04641H
 236+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 04642H
 237+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04643H
 238+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04645H
 239+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04645H
 240+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04645H
 241+ 4CF3              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04646H
 242+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04647H
 243+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04649H
 244+ 4CF3              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04649H
 245+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04649H
 246+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04649H
 247+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04649H
 248+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_END EQU 0464CH
 249+ 4CF3              PLY_AKG_CHANNEL2_PITCH_END EQU 0464EH
 250+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04656H
 251+ 4CF3              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04656H
 252+ 4CF3              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04659H
 253+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 0465CH
 254+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 0465CH
 255+ 4CF3              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04668H
 256+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466FH
 257+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 04672H
 258+ 4CF3              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04678H
 259+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 0467BH
 260+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 0467BH
 261+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04689H
 262+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468EH
 263+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04699H
 264+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 0469CH
 265+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 0469CH
 266+ 4CF3              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469FH
 267+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 046A2H
 268+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE EQU 046A2H
 269+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046ABH
 270+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B5H
 271+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B8H
 272+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B8H
 273+ 4CF3              PLY_AKG_CHANNEL3_PITCH EQU 046B8H
 274+ 4CF3              PLY_AKG_CHANNEL3_ISPITCH EQU 046BBH
 275+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046C0H
 276+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046C0H
 277+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C4H
 278+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C6H
 279+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C8H
 280+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CFH
 281+ 4CF3              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046D0H
 282+ 4CF3              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D3H
 283+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D3H
 284+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046EFH
 285+ 4CF3              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046EFH
 286+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046FCH
 287+ 4CF3              PLY_AKG_CHANNEL3_GLIDEOVER EQU 04700H
 288+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 04710H
 289+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 04710H
 290+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 04711H
 291+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 04712H
 292+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04714H
 293+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04714H
 294+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04714H
 295+ 4CF3              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04715H
 296+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04716H
 297+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04718H
 298+ 4CF3              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04718H
 299+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04718H
 300+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04718H
 301+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04718H
 302+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_END EQU 0471BH
 303+ 4CF3              PLY_AKG_CHANNEL3_PITCH_END EQU 0471DH
 304+ 4CF3              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04729H
 305+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04729H
 306+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04729H
 307+ 4CF3              PLY_AKG_CHANNEL1_TRACKNOTE EQU 0472CH
 308+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472EH
 309+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04734H
 310+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04737H
 311+ 4CF3              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04737H
 312+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 0473AH
 313+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04743H
 314+ 4CF3              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 0474BH
 315+ 4CF3              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04758H
 316+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04758H
 317+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04758H
 318+ 4CF3              PLY_AKG_CHANNEL2_TRACKNOTE EQU 0475BH
 319+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475DH
 320+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04763H
 321+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04766H
 322+ 4CF3              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04766H
 323+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04769H
 324+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 04772H
 325+ 4CF3              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 0477AH
 326+ 4CF3              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04788H
 327+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04788H
 328+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04788H
 329+ 4CF3              PLY_AKG_CHANNEL3_TRACKNOTE EQU 0478BH
 330+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478DH
 331+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04793H
 332+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04796H
 333+ 4CF3              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04796H
 334+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04799H
 335+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 047A2H
 336+ 4CF3              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047AAH
 337+ 4CF3              PLY_AKG_SENDPSGREGISTERS EQU 047B9H
 338+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047C1H
 339+ 4CF3              PLY_AKG_PSGREG01_INSTR EQU 047C1H
 340+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047D1H
 341+ 4CF3              PLY_AKG_PSGREG23_INSTR EQU 047D1H
 342+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047E2H
 343+ 4CF3              PLY_AKG_PSGREG45_INSTR EQU 047E2H
 344+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F3H
 345+ 4CF3              PLY_AKG_PSGREG6_8_INSTR EQU 047F3H
 346+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04804H
 347+ 4CF3              PLY_AKG_PSGREG9_10_INSTR EQU 04804H
 348+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04815H
 349+ 4CF3              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04815H
 350+ 4CF3              PLY_AKG_PSGREG13_OLDVALUE EQU 0482AH
 351+ 4CF3              PLY_AKG_RETRIG EQU 0482CH
 352+ 4CF3              PLY_AKG_PSGREG13_INSTR EQU 0482EH
 353+ 4CF3              PLY_AKG_PSGREG13_END EQU 0483DH
 354+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483DH
 355+ 4CF3              PLY_AKG_SAVESP EQU 0483DH
 356+ 4CF3              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 04841H
 357+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTS EQU 04849H
 358+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04856H
 359+ 4CF3              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04856H
 360+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485EH
 361+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 0486BH
 362+ 4CF3              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 0486BH
 363+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTS EQU 04873H
 364+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487EH
 365+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS EQU 0487EH
 366+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488DH
 367+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488DH
 368+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04894H
 369+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A4H
 370+ 4CF3              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A4H
 371+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048ABH
 372+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048ABH
 373+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048AEH
 374+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B7H
 375+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B7H
 376+ 4CF3              PLY_AKG_READINSTRUMENTCELL EQU 048BDH
 377+ 4CF3              PLY_AKG_NOSOFTNOHARD EQU 048CAH
 378+ 4CF3              PLY_AKG_NSNH_NONOISE EQU 048DFH
 379+ 4CF3              PLY_AKG_SOFT EQU 048E2H
 380+ 4CF3              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E9H
 381+ 4CF3              PLY_AKG_S_NOTSIMPLE EQU 048F1H
 382+ 4CF3              PLY_AKG_S_AFTERSIMPLETEST EQU 048F4H
 383+ 4CF3              PLY_AKG_HARDTOSOFT EQU 04901H
 384+ 4CF3              PLY_AKG_HS_JUMPRATIO EQU 0490CH
 385+ 4CF3              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04939H
 386+ 4CF3              PLY_AKG_ENDWITHOUTLOOP EQU 0493BH
 387+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 0493BH
 388+ 4CF3              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 0493BH
 389+ 4CF3              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04943H
 390+ 4CF3              PLY_AKG_SH_JUMPRATIO EQU 04950H
 391+ 4CF3              PLY_AKG_SH_JUMPRATIOEND EQU 04971H
 392+ 4CF3              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 04980H
 393+ 4CF3              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04986H
 394+ 4CF3              PLY_AKG_H_OR_ENDWITHLOOP EQU 049A0H
 395+ 4CF3              PLY_AKG_H_RETRIGEND EQU 049B2H
 396+ 4CF3              PLY_AKG_H_AFTERRETRIG EQU 049B3H
 397+ 4CF3              PLY_AKG_ENDWITHLOOP EQU 049C5H
 398+ 4CF3              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049CCH
 399+ 4CF3              PLY_AKG_S_OR_H_NEXTBYTE EQU 049E2H
 400+ 4CF3              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049F0H
 401+ 4CF3              PLY_AKG_S_OR_H_AFTERPITCH EQU 04A00H
 402+ 4CF3              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0EH
 403+ 4CF3              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1DH
 404+ 4CF3              PLY_AKG_SHOHS_RETRIGEND EQU 04A2CH
 405+ 4CF3              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2DH
 406+ 4CF3              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3FH
 407+ 4CF3              PLY_AKG_EFFECTTABLE EQU 04A4DH
 408+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4DH
 409+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A71H
 410+ 4CF3              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A71H
 411+ 4CF3              PLY_AKG_EFFECT_RESET EQU 04A74H
 412+ 4CF3              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A76H
 413+ 4CF3              PLY_AKG_EFFECT_VOLUME EQU 04A91H
 414+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9DH
 415+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA3H
 416+ 4CF3              PLY_AKG_ARPEGGIOSTABLE EQU 04AA3H
 417+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04ACAH
 418+ 4CF3              PLY_AKG_EFFECT_PITCHTABLE EQU 04AD1H
 419+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD7H
 420+ 4CF3              PLY_AKG_PITCHESTABLE EQU 04AD7H
 421+ 4CF3              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFEH
 422+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B05H
 423+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B16H
 424+ 4CF3              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1DH
 425+ 4CF3              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2DH
 426+ 4CF3              PLY_AKG_EFFECT_PITCHUP EQU 04B42H
 427+ 4CF3              PLY_AKG_EFFECT_PITCHSTOP EQU 04B54H
 428+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B5BH
 429+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B85H
 430+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B85H
 431+ 4CF3              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9EH
 432+ 4CF3              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9EH
 433+ 4CF3              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BB0H
 434+ 4CF3              PLY_AKG_EFFECT_LEGATO EQU 04BC6H
 435+ 4CF3              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BDAH
 436+ 4CF3              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BE2H
 437+ 4CF3              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BEAH
 438+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BF2H
 439+ 4CF3              PLY_AKG_EVENT EQU 04BF2H
 440+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF3H
 441+ 4CF3              PLY_AKG_PERIODTABLE EQU 04BF3H
 442+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF3H
 443+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF3H
 444+ 4CF3              PLY_AKG_PERIODTABLE_END EQU 04CF3H
 445+ 4CF3              PLY_AKG_END EQU 04CF3H
 446+ 4CF3              MAIN_PLAYER_END EQU 04CF3H
 447+ 4CF3              TESTEREND EQU 04CF3H
 448+ 4CF3
# file closed: ./symbol/AKG.sym
 129  4CF3               ENDIF
 130  4CF3
 131  4CF3               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
   1+ 4CF3              ORIG.HTIMI:
   2+ 4CF3 00 00 00 00  	DB 0, 0, 0, 0, 0
   2+ 4CF7 00
   3+ 4CF8               EXPORT ORIG.HTIMI
   4+ 4CF8
   5+ 4CF8              ; *******************************************************************************************************
   6+ 4CF8              ; interrupt handler when page 0 enabled
   7+ 4CF8              ; we are here only if one of the extended basic commands have paged in page 0
   8+ 4CF8              ; which means we arrived from BASIC so page 2 is already good
   9+ 4CF8              VBLANK:
  10+ 4CF8              	EXPORT VBLANK
  11+ 4CF8
  12+ 4CF8 F5               PUSH AF
  13+ 4CF9              	; is VDP originator ?
  14+ 4CF9 DB 99        	IN	A, (099H)
  15+ 4CFB A7           	AND	A
  16+ 4CFC F2 2A 4D     	JP P, .EXIT
  17+ 4CFF
  18+ 4CFF               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  19+ 4CFF C5               PUSH BC
  20+ 4D00 D5               PUSH DE
  21+ 4D01 E5               PUSH HL
  22+ 4D02 08               EX AF, AF'
  23+ 4D03 D9               EXX
  24+ 4D04 F5               PUSH AF
  25+ 4D05 C5               PUSH BC
  26+ 4D06 D5               PUSH DE
  27+ 4D07 E5               PUSH HL
  28+ 4D08 DD E5            PUSH IX
  29+ 4D0A FD E5            PUSH IY
  30+ 4D0C
  31+ 4D0C               IF (SPRITE_CMDS == 1)
  32+ 4D0C CD 64 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  33+ 4D0F               ENDIF
  34+ 4D0F
  35+ 4D0F               IF (SOUND_CMDS == 1)
  36+ 4D0F 3A A8 55     	LD A, (SOUND_ENABLED)
  37+ 4D12 B7           	OR A
  38+ 4D13 C4 36 42     	CALL NZ,PLY_AKG_PLAY
  39+ 4D16               ENDIF
  40+ 4D16
  41+ 4D16                  ; increase JIFFY
  42+ 4D16 2A 9E FC         LD HL,(JIFFY)
  43+ 4D19 23               INC HL
  44+ 4D1A 22 9E FC         LD (JIFFY),HL
  45+ 4D1D
  46+ 4D1D FD E1            POP IY
  47+ 4D1F DD E1            POP IX
  48+ 4D21 E1               POP HL
  49+ 4D22 D1               POP DE
  50+ 4D23 C1               POP BC
  51+ 4D24 F1               POP AF
  52+ 4D25 08               EX AF, AF'
  53+ 4D26 D9               EXX
  54+ 4D27 E1               POP HL
  55+ 4D28 D1               POP DE
  56+ 4D29 C1               POP BC
  57+ 4D2A               ENDIF
  58+ 4D2A
  59+ 4D2A              .EXIT:
  60+ 4D2A F1           	POP AF
  61+ 4D2B FB           	EI
  62+ 4D2C ED 4D        	RETI
  63+ 4D2E              ; *******************************************************************************************************
  64+ 4D2E
  65+ 4D2E              ; *******************************************************************************************************
  66+ 4D2E              ; H.TIMI function
  67+ 4D2E              ; we can end up here from anywhere so page in both page 0 and 2
  68+ 4D2E              MBGE_HTIMI:
  69+ 4D2E               EXPORT MBGE_HTIMI
  70+ 4D2E
  71+ 4D2E               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  72+ 4D2E
  73+ 4D2E F5           	PUSH AF
  74+ 4D2F
  75+ 4D2F              	; enable page 2
  76+ 4D2F 3E 02            LD A, 2
  77+ 4D31 CD C3 5F         CALL GET_PAGE_INFO
  78+ 4D34 C5               PUSH BC
  79+ 4D35 D5               PUSH DE
  80+ 4D36 3A 43 F3         LD A, (RAMAD2)
  81+ 4D39 26 80            LD H, 080H
  82+ 4D3B CD 0A 60         CALL LOCAL_ENASLT
  83+ 4D3E              	; enable page 0
  84+ 4D3E AF               XOR A
  85+ 4D3F CD C3 5F         CALL GET_PAGE_INFO
  86+ 4D42 C5               PUSH BC
  87+ 4D43 D5               PUSH DE
  88+ 4D44 3A 41 F3         LD A, (RAMAD0)
  89+ 4D47 26 00            LD H, 0
  90+ 4D49 CD 0A 60         CALL LOCAL_ENASLT
  91+ 4D4C
  92+ 4D4C               IF (SPRITE_CMDS == 1)
  93+ 4D4C CD 64 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  94+ 4D4F               ENDIF
  95+ 4D4F
  96+ 4D4F               IF (SOUND_CMDS == 1)
  97+ 4D4F 3A A8 55     	LD A, (SOUND_ENABLED)
  98+ 4D52 B7           	OR A
  99+ 4D53 C4 36 42     	CALL NZ,PLY_AKG_PLAY
 100+ 4D56               ENDIF
 101+ 4D56
 102+ 4D56              	; restore page 0
 103+ 4D56 D1               POP DE
 104+ 4D57 C1               POP BC
 105+ 4D58 CD FA 5F         CALL RESTORE_PAGE_INFO
 106+ 4D5B              	; restore page 2
 107+ 4D5B D1               POP DE
 108+ 4D5C C1               POP BC
 109+ 4D5D CD FA 5F         CALL RESTORE_PAGE_INFO
 110+ 4D60
 111+ 4D60 F1           	POP AF
 112+ 4D61               ENDIF
 113+ 4D61 C3 F3 4C     	JP ORIG.HTIMI
 114+ 4D64              ; *******************************************************************************************************
 115+ 4D64
 116+ 4D64              ; *******************************************************************************************************
 117+ 4D64              ; function checks if the sprite system is initialized and what screen mode we are running
 118+ 4D64              ; also checks if some VRAM modifying command is running
 119+ 4D64              ; when that checks out calls sprite updates and animation processing
 120+ 4D64              ; if in an unsupported mode disables sprite handling
 121+ 4D64              PROCESS_SPRITES_AND_ANIMATIONS:
 122+ 4D64              	; check if initialized
 123+ 4D64 3A 86 4D     	LD A, (SPRATR_INIT_STATUS)
 124+ 4D67 B7           	OR A
 125+ 4D68 C8           	RET Z
 126+ 4D69              	; check screen mode
 127+ 4D69 3A AF FC     	LD A, (SCRMOD)
 128+ 4D6C 3D           	DEC A
 129+ 4D6D 28 08        	JR Z, .L0 ; screen 1
 130+ 4D6F 3D           	DEC A
 131+ 4D70 28 05            JR Z, .L0 ; screen 2
 132+ 4D72              	; unsupported screen mode, disable
 133+ 4D72 AF               XOR A
 134+ 4D73 32 86 4D         LD (SPRATR_INIT_STATUS),A
 135+ 4D76 C9               RET
 136+ 4D77              .L0:
 137+ 4D77                  ; check if anyone else is working with VRAM
 138+ 4D77 3A 56 5F         LD A,(VRAM_UPDATE_IN_PROGRESS)
 139+ 4D7A B7               OR A
 140+ 4D7B C0               RET NZ
 141+ 4D7C
 142+ 4D7C CD 9C 4D         CALL SPRATR_UPDATE
 143+ 4D7F
 144+ 4D7F               IF (ANIM_CMDS == 1)
 145+ 4D7F CD 0E 53         CALL PROCESS_ANIMATIONS
 146+ 4D82 CD 6B 54         CALL PROCESS_AUTOSGAMS
 147+ 4D85               ENDIF
 148+ 4D85 C9               RET
 149+ 4D86              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
 132  4D86
 133  4D86               IF (SPRITE_CMDS == 1)
 134  4D86               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4D86              ; commands and variables related to sprites
   2+ 4D86
   3+ 4D86              SPRATR_INIT_STATUS:
   4+ 4D86 00            DB 0
   5+ 4D87              SPRATR_UPDATE_FLAG:
   6+ 4D87 00 00         DW 0
   7+ 4D89              SPRATR_DATA:
   8+ 4D89 00 00         DW 0
   9+ 4D8B              SPRFLICKER_ENABLED:
  10+ 4D8B 00            DB 0
  11+ 4D8C              ; to support sprite flicker
  12+ 4D8C              FLICKER:
  13+ 4D8C 00            DB 0
  14+ 4D8D              NUM_SPRITES_HANDLED:
  15+ 4D8D 20            DB 32
  16+ 4D8E
  17+ 4D8E              ; to temporarily store stack pointer
  18+ 4D8E              TMPSP:
  19+ 4D8E 00 00         DW 0
  20+ 4D90
  21+ 4D90              ; *******************************************************************************************************
  22+ 4D90              ; helper function gets pointer to n-th entry in sprite attributes
  23+ 4D90              ; changes HL,DE
  24+ 4D90              GETnthSPRATTR:
  25+ 4D90 26 00            LD H,0
  26+ 4D92 6F               LD L,A
  27+ 4D93 CD BF 5F         CALL HLx8
  28+ 4D96 ED 5B 89 4D      LD DE,(SPRATR_DATA)
  29+ 4D9A 19               ADD HL,DE
  30+ 4D9B C9               RET
  31+ 4D9C              ; *******************************************************************************************************
  32+ 4D9C
  33+ 4D9C              ; *******************************************************************************************************
  34+ 4D9C              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  35+ 4D9C              ; struct {
  36+ 4D9C              ; DW y
  37+ 4D9C              ; DW x
  38+ 4D9C              ; DW pattern (0-63)
  39+ 4D9C              ; DW color
  40+ 4D9C              ; } [32]
  41+ 4D9C              ; will hide sprites whose location is outside of visible area
  42+ 4D9C              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  43+ 4D9C              ; modifies AF, AF', BC, DE, HL, IX
  44+ 4D9C              SPRATR_UPDATE:
  45+ 4D9C              	; check if update requested
  46+ 4D9C 2A 87 4D     	LD HL, (SPRATR_UPDATE_FLAG)
  47+ 4D9F 7E           	LD A, (HL)
  48+ 4DA0 B7           	OR A
  49+ 4DA1 C8           	RET Z
  50+ 4DA2
  51+ 4DA2 DD 21 8D 4D  	LD IX,NUM_SPRITES_HANDLED
  52+ 4DA6 DD 46 00     	LD B, (IX) ; sprite number
  53+ 4DA9 0E 98        	LD C, #98 ; register for vdp data output
  54+ 4DAB              	; set VDP address
  55+ 4DAB 3A AF FC         LD A,(SCRMOD)
  56+ 4DAE 3D               DEC A
  57+ 4DAF 20 05            JR NZ,.L4
  58+ 4DB1 2A C3 F3         LD HL, (T32ATR)
  59+ 4DB4 18 03            JR .L5
  60+ 4DB6              .L4:
  61+ 4DB6 2A CD F3         LD HL, (GRPATR)
  62+ 4DB9              .L5:
  63+ 4DB9 3A 8B 4D     	LD A, (SPRFLICKER_ENABLED)
  64+ 4DBC B7           	OR A
  65+ 4DBD 28 03        	JR Z, .L3
  66+ 4DBF 3A 8C 4D     	LD A, (FLICKER)
  67+ 4DC2              .L3:
  68+ 4DC2 5F           	LD E, A
  69+ 4DC3 08           	EX AF, AF'
  70+ 4DC4 7B           	LD A, E
  71+ 4DC5 87           	ADD A, A
  72+ 4DC6 87           	ADD A, A
  73+ 4DC7 16 00        	LD D, 0
  74+ 4DC9 5F           	LD E, A
  75+ 4DCA 19           	ADD HL, DE
  76+ 4DCB CD A0 5F     	CALL SETWRT_LOCAL_WRITE
  77+ 4DCE ED 73 8E 4D  	LD (TMPSP), SP
  78+ 4DD2 ED 7B 89 4D  	LD SP, (SPRATR_DATA)
  79+ 4DD6
  80+ 4DD6              .LOOP:
  81+ 4DD6 E1           	POP HL
  82+ 4DD7 24           	INC H
  83+ 4DD8 28 0D        	JR Z, .L1 ; negative number between -256 and -1
  84+ 4DDA 25           	DEC H
  85+ 4DDB 20 15        	JR NZ, .OUT3 ; sprite vertically can't be visible
  86+ 4DDD 7D           	LD A, L
  87+ 4DDE FE C0        	CP 192
  88+ 4DE0 30 10        	JR NC, .OUT3
  89+ 4DE2 3D           	DEC A ; due to VDP rule that top of screen is -1
  90+ 4DE3 57           	LD D, A
  91+ 4DE4 C3 0B 4E     	JP .X
  92+ 4DE7              .L1:
  93+ 4DE7 7D           	LD A, L
  94+ 4DE8 C6 10        	ADD 16
  95+ 4DEA FA F2 4D     	JP M, .OUT3 ; below -16
  96+ 4DED 2D           	DEC L ; due to VDP rule that top of screen is -1
  97+ 4DEE 55           	LD D, L
  98+ 4DEF C3 0B 4E     	JP .X
  99+ 4DF2              .OUT3:
 100+ 4DF2 E1           	POP HL ; skip x value
 101+ 4DF3              .OUT2:
 102+ 4DF3 E1           	POP HL ; skip pattern
 103+ 4DF4 E1           	POP HL ; skip color
 104+ 4DF5 3E D1        	LD A, #D1
 105+ 4DF7 ED 79        	OUT (C), A ; sprite hidden
 106+ 4DF9 00          > NOP
 106+ 4DFA 00          > NOP
 106+ 4DFB 00          > NOP
 107+ 4DFC ED 79        	OUT (C), A ; value unimportant
 108+ 4DFE 00          > NOP
 108+ 4DFF 00          > NOP
 108+ 4E00 00          > NOP
 109+ 4E01 ED 79        	OUT (C), A ; value unimportant
 110+ 4E03 00          > NOP
 110+ 4E04 00          > NOP
 110+ 4E05 00          > NOP
 111+ 4E06 ED 79        	OUT (C), A ; value unimportant
 112+ 4E08 C3 36 4E     	JP .NEXT
 113+ 4E0B              .X:
 114+ 4E0B E1           	POP HL
 115+ 4E0C 24           	INC H
 116+ 4E0D 28 08        	JR Z, .L2
 117+ 4E0F 25           	DEC H
 118+ 4E10 20 E1        	JR NZ, .OUT2
 119+ 4E12 1E 00        	LD E, 0 ; EC bit
 120+ 4E14 C3 20 4E     	JP .XY
 121+ 4E17              .L2:
 122+ 4E17 7D           	LD A, L
 123+ 4E18 C6 20        	ADD 32
 124+ 4E1A FA F3 4D     	JP M, .OUT2
 125+ 4E1D 6F           	LD L, A
 126+ 4E1E 1E 80        	LD E, #80
 127+ 4E20              .XY:
 128+ 4E20 ED 51        	OUT (C), D
 129+ 4E22 3A E0 F3     	LD A, (REG1SAV)
 130+ 4E25 E6 02        	AND 2
 131+ 4E27 ED 69        	OUT (C), L
 132+ 4E29 E1           	POP HL ; pattern
 133+ 4E2A 7D           	LD A, L
 134+ 4E2B 28 02        	JR Z, .SMALLSPRITES
 135+ 4E2D 87           	ADD A, A
 136+ 4E2E 87           	ADD A, A ; needs to go at 4x
 137+ 4E2F              .SMALLSPRITES:
 138+ 4E2F D3 98        	OUT (#98), A
 139+ 4E31 E1           	POP HL ; color
 140+ 4E32 7D           	LD A, L
 141+ 4E33 B3           	OR E
 142+ 4E34 D3 98        	OUT (#98), A
 143+ 4E36              .NEXT:
 144+ 4E36 08           	EX AF, AF'
 145+ 4E37 3C           	INC A ; increase current sprite
 146+ 4E38 DD BE 00     	CP (IX) ; compare to maximum handled
 147+ 4E3B C2 5B 4E     	JP NZ, .NEXT2 ; continue if not over
 148+ 4E3E AF           	XOR A ; back to zero
 149+ 4E3F 08           	EX AF, AF'
 150+ 4E40 3A AF FC         LD A,(SCRMOD)
 151+ 4E43 3D               DEC A
 152+ 4E44 20 05            JR NZ,.L6
 153+ 4E46 2A C3 F3         LD HL, (T32ATR)
 154+ 4E49 18 03            JR .L7
 155+ 4E4B              .L6:
 156+ 4E4B 2A CD F3         LD HL, (GRPATR)
 157+ 4E4E              .L7:
 158+ 4E4E              	; CALL SETWRT_LOCAL not allowed as SP modified
 159+ 4E4E 7D           	LD	A, L
 160+ 4E4F D3 99        	OUT	(099H), A
 161+ 4E51 7C           	LD	A, H
 162+ 4E52 E6 3F        	AND	03FH
 163+ 4E54 F6 40        	OR	040H
 164+ 4E56 D3 99        	OUT	(099H), A
 165+ 4E58 C3 5C 4E     	JP .NEXT3
 166+ 4E5B              .NEXT2:
 167+ 4E5B 08           	EX AF, AF'
 168+ 4E5C              .NEXT3:
 169+ 4E5C 05           	DEC B
 170+ 4E5D C2 D6 4D     	JP NZ, .LOOP
 171+ 4E60 08           	EX AF, AF'
 172+ 4E61 3C           	INC A ; increase flicker to start at the next one on next vblank
 173+ 4E62 DD BE 00     	CP (IX)
 174+ 4E65 20 01        	JR NZ,.L8
 175+ 4E67 AF           	XOR A
 176+ 4E68              .L8:
 177+ 4E68 32 8C 4D     	LD (FLICKER), A
 178+ 4E6B
 179+ 4E6B ED 7B 8E 4D  	LD SP, (TMPSP)
 180+ 4E6F 2A 87 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 181+ 4E72 36 00        	LD (HL), 0 ; zero out update flag
 182+ 4E74 C9           	RET
 183+ 4E75              ; *******************************************************************************************************
 184+ 4E75
 185+ 4E75               IF (0 == 1)
 186+ 4E75 ~            ; *******************************************************************************************************
 187+ 4E75 ~            ; function to handle CALL SPRENABLE basic extension
 188+ 4E75 ~            ; initializes sprites handler
 189+ 4E75 ~            ; _SPRENABLE ( INT[3][31] variable sprites_attributes,
 190+ 4E75 ~            ;			   INT variable update_variable,
 191+ 4E75 ~            ;			   BYTE sprite_flicker_enabled,
 192+ 4E75 ~            ;			   BYTE num_sprites_handled )
 193+ 4E75 ~            ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA, SPRFLICKER_ENABLED and NUM_SPRITES_HANDLED
 194+ 4E75 ~            SPRENABLE:
 195+ 4E75 ~            	; opening (
 196+ 4E75 ~            	CALL CHKCHAR
 197+ 4E75 ~            	DB '('
 198+ 4E75 ~            	; get address of sprite attribute table DIM SA%(3,31)
 199+ 4E75 ~            	LD A,2
 200+ 4E75 ~            	LD B,2
 201+ 4E75 ~            	LD DE,#0420
 202+ 4E75 ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
 203+ 4E75 ~            	LD (SPRATR_DATA), BC
 204+ 4E75 ~            	; comma
 205+ 4E75 ~            	CALL CHKCHAR
 206+ 4E75 ~            	DB ','
 207+ 4E75 ~            	; get address of sprite update flag
 208+ 4E75 ~            	LD IX, PTRGET
 209+ 4E75 ~            	CALL CALBAS
 210+ 4E75 ~            	LD (SPRATR_UPDATE_FLAG), DE
 211+ 4E75 ~            	; comma
 212+ 4E75 ~            	CALL CHKCHAR
 213+ 4E75 ~            	DB ','
 214+ 4E75 ~            	; get flicker enabled flag
 215+ 4E75 ~            	LD IX, GETBYT
 216+ 4E75 ~            	CALL CALBAS
 217+ 4E75 ~            	LD (SPRFLICKER_ENABLED), A
 218+ 4E75 ~            	; comma
 219+ 4E75 ~            	CALL CHKCHAR
 220+ 4E75 ~            	DB ','
 221+ 4E75 ~            	; get number of handled sprites
 222+ 4E75 ~            	LD IX, GETBYT
 223+ 4E75 ~            	CALL CALBAS
 224+ 4E75 ~            	LD (NUM_SPRITES_HANDLED),A
 225+ 4E75 ~            	; ending )
 226+ 4E75 ~            	CALL CHKCHAR
 227+ 4E75 ~            	DB ')'
 228+ 4E75 ~            .L0:
 229+ 4E75 ~            	LD A, 1
 230+ 4E75 ~            	LD (SPRATR_INIT_STATUS), A
 231+ 4E75 ~            	RET
 232+ 4E75 ~            ; *******************************************************************************************************
 233+ 4E75               ENDIF
 234+ 4E75
 235+ 4E75               IF (1 == 1)
 236+ 4E75              ; same as SPRENABLE but for DEFUSR approach
 237+ 4E75              ; input IX=pointer to input array, real data from +2
 238+ 4E75              ; +2 = pointer to sprite attributes array data
 239+ 4E75              ; +4 = pointer to sprite update variable
 240+ 4E75              ; +6 = flicker flag
 241+ 4E75              ; +8 = number of sprites to handle
 242+ 4E75              SPRENABLE_DEFUSR:
 243+ 4E75 DD 6E 02     	LD L,(IX+2)
 244+ 4E78 DD 66 03     	LD H,(IX+3)
 245+ 4E7B 22 89 4D     	LD (SPRATR_DATA),HL
 246+ 4E7E DD 6E 04     	LD L,(IX+4)
 247+ 4E81 DD 66 05     	LD H,(IX+5)
 248+ 4E84 22 87 4D     	LD (SPRATR_UPDATE_FLAG),HL
 249+ 4E87 DD 7E 06     	LD A,(IX+6)
 250+ 4E8A 32 8B 4D     	LD (SPRFLICKER_ENABLED),A
 251+ 4E8D DD 7E 08     	LD A,(IX+8)
 252+ 4E90 32 8D 4D     	LD (NUM_SPRITES_HANDLED),A
 253+ 4E93 3E 01        	LD A, 1
 254+ 4E95 32 86 4D     	LD (SPRATR_INIT_STATUS), A
 255+ 4E98 AF           	XOR A ; success
 256+ 4E99 C9           	RET
 257+ 4E9A               ENDIF
 258+ 4E9A
 259+ 4E9A               IF (1 + 0 > 0)
 260+ 4E9A              ; *******************************************************************************************************
 261+ 4E9A              ; function to handle CALL SPRDISABLE basic extension
 262+ 4E9A              ; disables sprites handling
 263+ 4E9A              ; _SPRDISABLE
 264+ 4E9A              ; resets variable SPRATR_INIT_STATUS
 265+ 4E9A              SPRDISABLE:
 266+ 4E9A              SPRDISABLE_DEFUSR:
 267+ 4E9A AF           	XOR A
 268+ 4E9B 32 86 4D     	LD (SPRATR_INIT_STATUS), A
 269+ 4E9E C9           	RET
 270+ 4E9F              ; *******************************************************************************************************
 271+ 4E9F               ENDIF
 272+ 4E9F
 273+ 4E9F              ; *******************************************************************************************************
 274+ 4E9F              ; function to handle CALL SPRSET basic extension
 275+ 4E9F              ; sets position, and optionally pattern and color of sprite
 276+ 4E9F              ; _SPRSET ( BYTE sprite_num , valid 0-31
 277+ 4E9F              ;			INT x,
 278+ 4E9F              ;			INT y,
 279+ 4E9F              ;			INT pattern, valid 0-63, otherwise ignored
 280+ 4E9F              ;			INT color, valid 0-15, otherwise ignored
 281+ 4E9F              ;SPRSET:
 282+ 4E9F              ;	LD A, (SPRATR_INIT_STATUS)
 283+ 4E9F              ;	OR A
 284+ 4E9F              ;	JR NZ, .L1
 285+ 4E9F              ;	LD E, 5 ; illegal function call
 286+ 4E9F              ;	JP THROW_ERROR
 287+ 4E9F              ;.L1:
 288+ 4E9F              ;	; opening (
 289+ 4E9F              ;	CALL CHKCHAR
 290+ 4E9F              ;	DB '('
 291+ 4E9F              ;	; get sprite number
 292+ 4E9F              ;	LD IX, GETBYT
 293+ 4E9F              ;	CALL CALBAS
 294+ 4E9F              ;	PUSH AF
 295+ 4E9F              ;	; comma
 296+ 4E9F              ;	CALL CHKCHAR
 297+ 4E9F              ;	DB ','
 298+ 4E9F              ;	; get x
 299+ 4E9F              ;	LD IX, FRMQNT
 300+ 4E9F              ;	CALL CALBAS
 301+ 4E9F              ;	PUSH DE
 302+ 4E9F              ;	; comma
 303+ 4E9F              ;	CALL CHKCHAR
 304+ 4E9F              ;	DB ','
 305+ 4E9F              ;	; get y
 306+ 4E9F              ;	LD IX, FRMQNT
 307+ 4E9F              ;	CALL CALBAS
 308+ 4E9F              ;	PUSH DE
 309+ 4E9F              ;	; comma
 310+ 4E9F              ;	CALL CHKCHAR
 311+ 4E9F              ;	DB ','
 312+ 4E9F              ;	; get pattern
 313+ 4E9F              ;	LD IX, FRMQNT
 314+ 4E9F              ;	CALL CALBAS
 315+ 4E9F              ;	PUSH DE
 316+ 4E9F              ;	; comma
 317+ 4E9F              ;	CALL CHKCHAR
 318+ 4E9F              ;	DB ','
 319+ 4E9F              ;	; get color
 320+ 4E9F              ;	LD IX, FRMQNT
 321+ 4E9F              ;	CALL CALBAS
 322+ 4E9F              ;	PUSH DE
 323+ 4E9F              ;	; ending )
 324+ 4E9F              ;	CALL CHKCHAR
 325+ 4E9F              ;	DB ')'
 326+ 4E9F              ;
 327+ 4E9F              ;   ; save position in BASIC text
 328+ 4E9F              ;	PUSH HL
 329+ 4E9F              ;	POP IX
 330+ 4E9F              ;
 331+ 4E9F              ;	POP BC ; color
 332+ 4E9F              ;	POP DE ; pattern
 333+ 4E9F              ;	EXX
 334+ 4E9F              ;	POP BC ; y
 335+ 4E9F              ;	POP DE ; x
 336+ 4E9F              ;	POP AF ; sprite number
 337+ 4E9F              ;	CP 32
 338+ 4E9F              ;	JR C, .L2
 339+ 4E9F              ;	LD E, 5 ; illegal function call
 340+ 4E9F              ;	JP THROW_ERROR
 341+ 4E9F              ;.L2:
 342+ 4E9F              ;	; find location in sprite attributes table
 343+ 4E9F              ;	PUSH DE
 344+ 4E9F              ;	CALL GETnthSPRATTR
 345+ 4E9F              ;	POP DE
 346+ 4E9F              ;	DI
 347+ 4E9F              ;	; set y
 348+ 4E9F              ;	LD (HL), C
 349+ 4E9F              ;	INC HL
 350+ 4E9F              ;	LD (HL), B
 351+ 4E9F              ;	INC HL
 352+ 4E9F              ;	; set x
 353+ 4E9F              ;	LD (HL), E
 354+ 4E9F              ;	INC HL
 355+ 4E9F              ;	LD (HL), D
 356+ 4E9F              ;	INC HL
 357+ 4E9F              ;	PUSH HL
 358+ 4E9F              ;	EXX
 359+ 4E9F              ;	POP HL
 360+ 4E9F              ;	; check if 0<=pattern<64
 361+ 4E9F              ;	LD A, D
 362+ 4E9F              ;	OR A
 363+ 4E9F              ;	JR NZ, .L3
 364+ 4E9F              ;	LD A, E
 365+ 4E9F              ;	CP 64
 366+ 4E9F              ;	JR NC, .L3
 367+ 4E9F              ;	; set pattern
 368+ 4E9F              ;	;ADD A, A
 369+ 4E9F              ;	;ADD A, A
 370+ 4E9F              ;	;ADD A, A
 371+ 4E9F              ;	LD (HL), A
 372+ 4E9F              ;	INC HL
 373+ 4E9F              ;	LD (HL), D
 374+ 4E9F              ;	INC HL
 375+ 4E9F              ;	JR .L4
 376+ 4E9F              ;.L3:
 377+ 4E9F              ;	; skip pattern
 378+ 4E9F              ;	.2 INC HL
 379+ 4E9F              ;.L4:
 380+ 4E9F              ;	; check if 0<=color<16
 381+ 4E9F              ;	LD A, B
 382+ 4E9F              ;	OR A
 383+ 4E9F              ;	JR NZ, .L5
 384+ 4E9F              ;	LD A, C
 385+ 4E9F              ;	CP 16
 386+ 4E9F              ;	JR NC, .L5
 387+ 4E9F              ;	; set color
 388+ 4E9F              ;	LD (HL), C
 389+ 4E9F              ;	INC HL
 390+ 4E9F              ;	LD (HL), B
 391+ 4E9F              ;
 392+ 4E9F              ;.L5:
 393+ 4E9F              ;	EI
 394+ 4E9F              ;	PUSH IX
 395+ 4E9F              ;	POP HL
 396+ 4E9F              ;	RET
 397+ 4E9F              ; *******************************************************************************************************
 398+ 4E9F
 399+ 4E9F              ; *******************************************************************************************************
 400+ 4E9F              ; function sets sprite location based on initial coordinates and offset provided
 401+ 4E9F              ; input A=sprite number in SPRATR_DATA , 0-31
 402+ 4E9F              ; input DE=initial x
 403+ 4E9F              ; input BC=initial y
 404+ 4E9F              ; input IY=location where delta y,x are located
 405+ 4E9F              ; modifies AF, HL, IX
 406+ 4E9F              SPRSET_DELTA_POS:
 407+ 4E9F D5           	PUSH DE
 408+ 4EA0 CD 90 4D     	CALL GETnthSPRATTR
 409+ 4EA3 E5           	PUSH HL
 410+ 4EA4 DD E1        	POP IX
 411+ 4EA6 D1           	POP DE
 412+ 4EA7              	; IX=sprite's y location
 413+ 4EA7 FD 6E 00     	LD L, (IY)
 414+ 4EAA FD 66 01     	LD H, (IY+1)
 415+ 4EAD 09           	ADD HL, BC
 416+ 4EAE DD 75 00     	LD (IX), L
 417+ 4EB1 DD 74 01     	LD (IX+1), H
 418+ 4EB4 FD 6E 02     	LD L, (IY+2)
 419+ 4EB7 FD 66 03     	LD H, (IY+3)
 420+ 4EBA 19           	ADD HL, DE
 421+ 4EBB DD 75 02     	LD (IX+2), L
 422+ 4EBE DD 74 03     	LD (IX+3), H
 423+ 4EC1 C9           	RET
 424+ 4EC2              ; *******************************************************************************************************
 425+ 4EC2
 426+ 4EC2              ; *******************************************************************************************************
 427+ 4EC2              ; helper function to set new locations for a set of sprites
 428+ 4EC2              ; input B=number of sprites
 429+ 4EC2              ; HL=pointer to list of sprites and offsets
 430+ 4EC2              SPR_UPDATE_LOC:
 431+ 4EC2 3E 01        	LD A,1
 432+ 4EC4 32 56 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 433+ 4EC7 7E           	LD A, (HL)
 434+ 4EC8 23           	INC HL
 435+ 4EC9 23           	INC HL
 436+ 4ECA E5           	PUSH HL
 437+ 4ECB FD E1        	POP IY
 438+ 4ECD D9           	EXX
 439+ 4ECE CD 9F 4E     	CALL SPRSET_DELTA_POS
 440+ 4ED1 D9           	EXX
 441+ 4ED2 23          > INC HL
 441+ 4ED3 23          > INC HL
 441+ 4ED4 23          > INC HL
 441+ 4ED5 23          > INC HL
 442+ 4ED6 10 EA        	DJNZ SPR_UPDATE_LOC
 443+ 4ED8 AF           	XOR A
 444+ 4ED9 32 56 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 445+ 4EDC C9           	RET
 446+ 4EDD              ; *******************************************************************************************************
 447+ 4EDD
 448+ 4EDD               IF (0 == 1)
 449+ 4EDD ~            ; *******************************************************************************************************
 450+ 4EDD ~            ; function to handle CALL SPRGRPMOV basic extension
 451+ 4EDD ~            ; sets position of a group of sprites described with
 452+ 4EDD ~            ; { int sprite_num, int delta_y, int delta_x } [count]
 453+ 4EDD ~            ; _SPRGRPMOV ( INT x,
 454+ 4EDD ~            ;			   INT y,
 455+ 4EDD ~            ;			   BYTE count,
 456+ 4EDD ~            ;			   INT[2][count] data_ptr
 457+ 4EDD ~            SPRGRPMOV:
 458+ 4EDD ~            	LD A, (SPRATR_INIT_STATUS)
 459+ 4EDD ~            	OR A
 460+ 4EDD ~            	JP Z,ILLEGAL_FUNCTION
 461+ 4EDD ~            	; opening (
 462+ 4EDD ~            	CALL CHKCHAR
 463+ 4EDD ~            	DB '('
 464+ 4EDD ~            	; get x
 465+ 4EDD ~            	LD IX, FRMQNT
 466+ 4EDD ~            	CALL CALBAS
 467+ 4EDD ~            	LD (TMP_STRUCT),DE
 468+ 4EDD ~            	; comma
 469+ 4EDD ~            	CALL CHKCHAR
 470+ 4EDD ~            	DB ','
 471+ 4EDD ~            	; get y
 472+ 4EDD ~            	LD IX, FRMQNT
 473+ 4EDD ~            	CALL CALBAS
 474+ 4EDD ~            	LD (TMP_STRUCT+2),DE
 475+ 4EDD ~            	; comma
 476+ 4EDD ~            	CALL CHKCHAR
 477+ 4EDD ~            	DB ','
 478+ 4EDD ~            	; get count
 479+ 4EDD ~            	LD IX, GETBYT
 480+ 4EDD ~            	CALL CALBAS
 481+ 4EDD ~            	LD (TMP_STRUCT+4),A
 482+ 4EDD ~            	; comma
 483+ 4EDD ~            	CALL CHKCHAR
 484+ 4EDD ~            	DB ','
 485+ 4EDD ~            	; get sprite group definition array data pointer
 486+ 4EDD ~            	LD A,(TMP_STRUCT+4)
 487+ 4EDD ~            	LD E,A
 488+ 4EDD ~            	LD D,3
 489+ 4EDD ~            	LD A,2
 490+ 4EDD ~            	LD B,A
 491+ 4EDD ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
 492+ 4EDD ~            	LD (TMP_STRUCT+5),BC
 493+ 4EDD ~            	; ending )
 494+ 4EDD ~            	CALL CHKCHAR
 495+ 4EDD ~            	DB ')'
 496+ 4EDD ~
 497+ 4EDD ~            	PUSH HL
 498+ 4EDD ~
 499+ 4EDD ~                EXX
 500+ 4EDD ~                LD DE,(TMP_STRUCT) ; initial x
 501+ 4EDD ~                LD BC,(TMP_STRUCT+2) ; initial y
 502+ 4EDD ~                EXX
 503+ 4EDD ~                LD HL,(TMP_STRUCT+5) ; pointer to data
 504+ 4EDD ~                LD A,(TMP_STRUCT+4) ; number of entries
 505+ 4EDD ~                LD B,A
 506+ 4EDD ~            	CALL SPR_UPDATE_LOC
 507+ 4EDD ~
 508+ 4EDD ~            	POP HL
 509+ 4EDD ~            	RET
 510+ 4EDD ~            ; *******************************************************************************************************
 511+ 4EDD               ENDIF
 512+ 4EDD
 513+ 4EDD               IF (1 == 1)
 514+ 4EDD              ; *******************************************************************************************************
 515+ 4EDD              ; same as SPRGRPMOV but for DEFUSR approach
 516+ 4EDD              ; input IX=pointer to input array, real data from +2
 517+ 4EDD              ; +2 = X
 518+ 4EDD              ; +4 = Y
 519+ 4EDD              ; +6 = count
 520+ 4EDD              ; +8 = data pointer
 521+ 4EDD              SPRGRPMOV_DEFUSR:
 522+ 4EDD D9               EXX
 523+ 4EDE DD 5E 02     	LD E,(IX+2)
 524+ 4EE1 DD 56 03     	LD D,(IX+3) ; initial x
 525+ 4EE4 DD 4E 04     	LD C,(IX+4)
 526+ 4EE7 DD 46 05     	LD B,(IX+5) ; initial y
 527+ 4EEA D9               EXX
 528+ 4EEB DD 6E 08     	LD L,(IX+8)
 529+ 4EEE DD 66 09     	LD H,(IX+9) ; pointer to data
 530+ 4EF1 DD 46 06         LD B,(IX+6) ; count
 531+ 4EF4 C3 C2 4E         JP SPR_UPDATE_LOC
 532+ 4EF7              ; *******************************************************************************************************
 533+ 4EF7               ENDIF
# file closed: asm\SPRITES.asm
 135  4EF7               ENDIF
 136  4EF7
 137  4EF7               IF (ANIM_CMDS == 1)
 138  4EF7               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4EF7              ; sprite animation routines
   2+ 4EF7
   3+ 4EF7              ; number of animation items and pointer
   4+ 4EF7              ANIMITEMNUM:
   5+ 4EF7 00            DB 0
   6+ 4EF8              ANIMITEMPTR:
   7+ 4EF8 39 61         DW EXT_END
   8+ 4EFA              ; number of animation definitions and pointer
   9+ 4EFA              ANIMDEFNUM:
  10+ 4EFA 00            DB 0
  11+ 4EFB              ANIMDEFPTR:
  12+ 4EFB 39 61         DW EXT_END
  13+ 4EFD              ; number of links between sprite and animation definitions
  14+ 4EFD              ANIMSPRNUM:
  15+ 4EFD 00            DB 0
  16+ 4EFE              ANIMSPRPTR:
  17+ 4EFE 39 61         DW EXT_END
  18+ 4F00              ; number of automatic sprite group move and animate structures
  19+ 4F00              AUTOSGAMNUM:
  20+ 4F00 00            DB 0
  21+ 4F01              AUTOSGAMPTR:
  22+ 4F01 39 61         DW EXT_END
  23+ 4F03
  24+ 4F03              ; ANIMATION ITEM
  25+ 4F03              ; byte type = [0 - pattern and color change
  26+ 4F03              ;              1 - pattern definition change ]
  27+ 4F03              ; word ticks - number of ticks to hold this state
  28+ 4F03              ; for type = 0
  29+ 4F03              ;   byte pattern;
  30+ 4F03              ;   byte color;
  31+ 4F03              ; for type = 1
  32+ 4F03              ;   work data_pointer;
  33+ 4F03              ; total size = 5b
  34+ 4F03
  35+ 4F03              ; ANIMATION DEFINITION
  36+ 4F03              ; byte number of items 1-15
  37+ 4F03              ; byte[15] anim_item;
  38+ 4F03              ; total size = 16b
  39+ 4F03
  40+ 4F03              ; SPRITE/CHAR ANIMATION
  41+ 4F03              ; +00 byte sprite/char number;
  42+ 4F03              ; +01 word time;
  43+ 4F03              ; +03 byte current item;
  44+ 4F03              ; +04 byte animation definition;
  45+ 4F03              ; +05 byte cyclic;
  46+ 4F03              ; +06 byte active;
  47+ 4F03              ; +07 byte 0=sprite, 1-3 character bank
  48+ 4F03              ; total size = 8b
  49+ 4F03
  50+ 4F03              ; AUTOMATIC SPRITE GROUP MOVE AND ANIMATE structure
  51+ 4F03              ; +00 pointer to X variable
  52+ 4F03              ; +02 pointer to Y variable
  53+ 4F03              ; +04 minimum value
  54+ 4F03              ; +06 maximal value
  55+ 4F03              ; +08 delta value
  56+ 4F03              ; +10 direction 0=horizontal, <>0 = vertical
  57+ 4F03              ; +11 sprite group size
  58+ 4F03              ; +12 sprite group pointer
  59+ 4F03              ; +14 animation list size
  60+ 4F03              ; +15 animation list pointer for negative delta values
  61+ 4F03              ; +17 animation list pointer for positive delta values
  62+ 4F03              ; +19 active flag
  63+ 4F03              ; +20 ticks for movement
  64+ 4F03              ; +22 timer
  65+ 4F03              ; total = 24b
  66+ 4F03
  67+ 4F03              ; *******************************************************************************************************
  68+ 4F03              ; helper function HL=A*5
  69+ 4F03              ; changes HL,DE
  70+ 4F03              Ax5:
  71+ 4F03 26 00            LD H,0
  72+ 4F05 6F               LD L,A
  73+ 4F06 54               LD D,H
  74+ 4F07 5D               LD E,L
  75+ 4F08 29               ADD HL,HL
  76+ 4F09 29               ADD HL,HL
  77+ 4F0A 19               ADD HL,DE
  78+ 4F0B C9               RET
  79+ 4F0C              ; *******************************************************************************************************
  80+ 4F0C
  81+ 4F0C              ; *******************************************************************************************************
  82+ 4F0C              ; helper function gets pointer to n-th animation item
  83+ 4F0C              ; changes HL,DE
  84+ 4F0C              GETnthANIMITEM:
  85+ 4F0C CD 03 4F         CALL Ax5
  86+ 4F0F ED 5B F8 4E      LD DE,(ANIMITEMPTR)
  87+ 4F13 19               ADD HL,DE
  88+ 4F14 C9               RET
  89+ 4F15              ; *******************************************************************************************************
  90+ 4F15
  91+ 4F15              ; *******************************************************************************************************
  92+ 4F15              ; helper function gets pointer to n-th entry in animation definition
  93+ 4F15              ; changes HL,DE
  94+ 4F15              GETnthANIMDEF:
  95+ 4F15 26 00            LD H,0
  96+ 4F17 6F               LD L,A
  97+ 4F18 CD BE 5F         CALL HLx16
  98+ 4F1B ED 5B FB 4E      LD DE,(ANIMDEFPTR)
  99+ 4F1F 19               ADD HL,DE
 100+ 4F20 C9               RET
 101+ 4F21              ; *******************************************************************************************************
 102+ 4F21
 103+ 4F21              ; *******************************************************************************************************
 104+ 4F21              ; helper function gets pointer to n-th entry in sprite animation
 105+ 4F21              ; changes HL,DE
 106+ 4F21              GETnthSPRANIM:
 107+ 4F21 26 00            LD H,0
 108+ 4F23 6F               LD L,A
 109+ 4F24 CD BF 5F         CALL HLx8
 110+ 4F27 ED 5B FE 4E      LD DE,(ANIMSPRPTR)
 111+ 4F2B 19               ADD HL,DE
 112+ 4F2C C9               RET
 113+ 4F2D              ; *******************************************************************************************************
 114+ 4F2D
 115+ 4F2D              ; *******************************************************************************************************
 116+ 4F2D              ; helper function gets pointer to n-th entry in autosgam table
 117+ 4F2D              ; changes HL,DE
 118+ 4F2D              GETnthAUTOSGAM:
 119+ 4F2D 26 00            LD H,0
 120+ 4F2F 6F               LD L,A
 121+ 4F30 CD BF 5F         CALL HLx8
 122+ 4F33 54               LD D,H
 123+ 4F34 5D               LD E,L
 124+ 4F35 29               ADD HL,HL
 125+ 4F36 19               ADD HL,DE
 126+ 4F37 ED 5B 01 4F      LD DE,(AUTOSGAMPTR)
 127+ 4F3B 19               ADD HL,DE
 128+ 4F3C C9               RET
 129+ 4F3D              ; *******************************************************************************************************
 130+ 4F3D
 131+ 4F3D               IF (1 == 1)
 132+ 4F3D              ; *******************************************************************************************************
 133+ 4F3D              ; same as MAXIANIMITEMS but for DEFUSR approach
 134+ 4F3D              ; input IX=pointer to input array, real data from +2
 135+ 4F3D              ; +2 = number
 136+ 4F3D              MAXANIMITEMS_DEFUSR:
 137+ 4F3D DD 7E 02         LD A,(IX+2)
 138+ 4F40 CD 45 4F         CALL MAXANIMITEMS.COMMON
 139+ 4F43 AF               XOR A ; success
 140+ 4F44 C9               RET
 141+ 4F45              ; *******************************************************************************************************
 142+ 4F45               ENDIF
 143+ 4F45
 144+ 4F45              ; *******************************************************************************************************
 145+ 4F45              ; function to handle CALL MAXANIMITEMS basic extension
 146+ 4F45              ; MAXANIMITEMS (BYTE number)
 147+ 4F45              ; sets new number and moves memory buffers as needed
 148+ 4F45              MAXANIMITEMS:
 149+ 4F45               IF (0 == 1)
 150+ 4F45 ~            	; opening (
 151+ 4F45 ~            	CALL CHKCHAR
 152+ 4F45 ~            	DB '('
 153+ 4F45 ~            	; get value
 154+ 4F45 ~            	LD IX, GETBYT
 155+ 4F45 ~            	CALL CALBAS
 156+ 4F45 ~                PUSH AF
 157+ 4F45 ~            	; ending )
 158+ 4F45 ~            	CALL CHKCHAR
 159+ 4F45 ~            	DB ')'
 160+ 4F45 ~                POP AF
 161+ 4F45               ENDIF
 162+ 4F45              .COMMON: ; entry for DEFUSR part, A=number
 163+ 4F45 F3               DI
 164+ 4F46              	; save position
 165+ 4F46 E5           	PUSH HL
 166+ 4F47              .ENTRY:
 167+ 4F47 47               LD B,A
 168+ 4F48 3A F7 4E         LD A,(ANIMITEMNUM)
 169+ 4F4B 90               SUB B
 170+ 4F4C 28 28            JR Z, .EXIT; same value as before
 171+ 4F4E FD 21 FB 4E      LD IY,ANIMDEFPTR
 172+ 4F52 FA 79 4F         JP M, .INCREASE
 173+ 4F55                  ; new value is lower than previous one
 174+ 4F55 CD 98 4F         CALL .SIZEDIFF
 175+ 4F58 CD B3 4F         CALL .DECREASE_COMMON
 176+ 4F5B 2A FE 4E         LD HL,(ANIMSPRPTR)
 177+ 4F5E AF               XOR A
 178+ 4F5F ED 42            SBC HL,BC
 179+ 4F61 22 FE 4E         LD (ANIMSPRPTR),HL
 180+ 4F64              .E1:
 181+ 4F64 2A 01 4F         LD HL,(AUTOSGAMPTR)
 182+ 4F67 AF               XOR A
 183+ 4F68 ED 42            SBC HL,BC
 184+ 4F6A 22 01 4F         LD (AUTOSGAMPTR),HL
 185+ 4F6D              .E3:
 186+ 4F6D 2A 10 40         LD HL,(FREEMEMPTR)
 187+ 4F70 AF               XOR A
 188+ 4F71 ED 42            SBC HL,BC
 189+ 4F73 22 10 40         LD (FREEMEMPTR),HL
 190+ 4F76              .EXIT:
 191+ 4F76 FB               EI
 192+ 4F77 E1           	POP HL
 193+ 4F78 C9           	RET
 194+ 4F79              .INCREASE:
 195+ 4F79 ED 44            NEG
 196+ 4F7B CD 98 4F         CALL .SIZEDIFF
 197+ 4F7E CD DF 4F         CALL .INCREASE_COMMON
 198+ 4F81 2A FE 4E         LD HL,(ANIMSPRPTR)
 199+ 4F84 09               ADD HL,BC
 200+ 4F85 22 FE 4E         LD (ANIMSPRPTR),HL
 201+ 4F88              .E2:
 202+ 4F88 2A 01 4F         LD HL,(AUTOSGAMPTR)
 203+ 4F8B 09               ADD HL,BC
 204+ 4F8C 22 01 4F         LD (AUTOSGAMPTR),HL
 205+ 4F8F              .E4:
 206+ 4F8F 2A 10 40         LD HL,(FREEMEMPTR)
 207+ 4F92 09               ADD HL,BC
 208+ 4F93 22 10 40         LD (FREEMEMPTR),HL
 209+ 4F96 18 DE            JR .EXIT
 210+ 4F98              .SIZEDIFF:
 211+ 4F98 CD 03 4F         CALL Ax5
 212+ 4F9B 78               LD A,B
 213+ 4F9C 32 F7 4E         LD (ANIMITEMNUM),A
 214+ 4F9F 44               LD B,H
 215+ 4FA0 4D               LD C,L
 216+ 4FA1 C9               RET ; BC=size difference in bytes
 217+ 4FA2              .SIZETOMOVE:
 218+ 4FA2 D5               PUSH DE
 219+ 4FA3 2A 10 40         LD HL,(FREEMEMPTR)
 220+ 4FA6 FD 5E 00         LD E,(IY)
 221+ 4FA9 FD 56 01         LD D,(IY+1)
 222+ 4FAC AF               XOR A
 223+ 4FAD ED 52            SBC HL,DE
 224+ 4FAF 44               LD B,H
 225+ 4FB0 4D               LD C,L
 226+ 4FB1 D1               POP DE
 227+ 4FB2 C9               RET
 228+ 4FB3              .DECREASE_COMMON:
 229+ 4FB3 FD 6E 00         LD L,(IY)
 230+ 4FB6 FD 66 01         LD H,(IY+1)
 231+ 4FB9 AF               XOR A
 232+ 4FBA ED 42            SBC HL,BC
 233+ 4FBC EB               EX DE,HL
 234+ 4FBD C5               PUSH BC
 235+ 4FBE CD A2 4F         CALL .SIZETOMOVE
 236+ 4FC1 F3               DI
 237+ 4FC2 78               LD A,B
 238+ 4FC3 B1               OR C
 239+ 4FC4 28 08            JR Z,.L1
 240+ 4FC6 FD 6E 00         LD L,(IY)
 241+ 4FC9 FD 66 01         LD H,(IY+1)
 242+ 4FCC ED B0            LDIR
 243+ 4FCE              .L1:
 244+ 4FCE C1               POP BC
 245+ 4FCF FD 6E 00         LD L,(IY)
 246+ 4FD2 FD 66 01         LD H,(IY+1)
 247+ 4FD5 AF               XOR A
 248+ 4FD6 ED 42            SBC HL,BC
 249+ 4FD8 FD 75 00         LD (IY),L
 250+ 4FDB FD 74 01         LD (IY+1),H
 251+ 4FDE C9               RET
 252+ 4FDF              .INCREASE_COMMON:
 253+ 4FDF 2A 10 40         LD HL,(FREEMEMPTR)
 254+ 4FE2 2B               DEC HL
 255+ 4FE3 AF               XOR A
 256+ 4FE4 ED 42            SBC HL,BC
 257+ 4FE6 EB               EX DE,HL
 258+ 4FE7 C5               PUSH BC
 259+ 4FE8 CD A2 4F         CALL .SIZETOMOVE
 260+ 4FEB F3               DI
 261+ 4FEC 78               LD A,B
 262+ 4FED B1               OR C
 263+ 4FEE 28 06            JR Z,.L2
 264+ 4FF0 2A 10 40         LD HL,(FREEMEMPTR)
 265+ 4FF3 2B               DEC HL
 266+ 4FF4 ED B8            LDDR
 267+ 4FF6              .L2:
 268+ 4FF6 C1               POP BC
 269+ 4FF7 FD 6E 00         LD L,(IY)
 270+ 4FFA FD 66 01         LD H,(IY+1)
 271+ 4FFD 09               ADD HL,BC
 272+ 4FFE FD 75 00         LD (IY),L
 273+ 5001 FD 74 01         LD (IY+1),H
 274+ 5004 C9               RET
 275+ 5005              ; *******************************************************************************************************
 276+ 5005
 277+ 5005               IF (0 == 1)
 278+ 5005 ~            ; *******************************************************************************************************
 279+ 5005 ~            ; function to handle CALL ANIMITEMPAT basic extension
 280+ 5005 ~            ; ANIMITEMPAT ( BYTE id,
 281+ 5005 ~            ;               INT ticks >0,
 282+ 5005 ~            ;               BYTE pattern,
 283+ 5005 ~            ;               BYTE color )
 284+ 5005 ~            ; fills animation item data, returns an error if ID out of bounds
 285+ 5005 ~            ANIMITEMPAT:
 286+ 5005 ~                ; opening (
 287+ 5005 ~            	CALL CHKCHAR
 288+ 5005 ~            	DB '('
 289+ 5005 ~            	; get id
 290+ 5005 ~            	LD IX, GETBYT
 291+ 5005 ~            	CALL CALBAS
 292+ 5005 ~                PUSH AF
 293+ 5005 ~                ; check if out of bounds
 294+ 5005 ~                INC A
 295+ 5005 ~                LD C,A
 296+ 5005 ~                LD A,(ANIMITEMNUM)
 297+ 5005 ~                CP C
 298+ 5005 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 299+ 5005 ~            	; comma
 300+ 5005 ~            	CALL CHKCHAR
 301+ 5005 ~            	DB ','
 302+ 5005 ~            	; get ticks
 303+ 5005 ~            	LD IX, FRMQNT
 304+ 5005 ~            	CALL CALBAS
 305+ 5005 ~                LD A,D
 306+ 5005 ~                OR E
 307+ 5005 ~                JP Z, OVERFLOW
 308+ 5005 ~            	PUSH DE
 309+ 5005 ~            	; comma
 310+ 5005 ~            	CALL CHKCHAR
 311+ 5005 ~            	DB ','
 312+ 5005 ~            	; get pattern
 313+ 5005 ~            	LD IX, GETBYT
 314+ 5005 ~            	CALL CALBAS
 315+ 5005 ~                PUSH AF
 316+ 5005 ~            	; comma
 317+ 5005 ~            	CALL CHKCHAR
 318+ 5005 ~            	DB ','
 319+ 5005 ~            	; get color
 320+ 5005 ~            	LD IX, GETBYT
 321+ 5005 ~            	CALL CALBAS
 322+ 5005 ~                PUSH AF
 323+ 5005 ~            	; ending )
 324+ 5005 ~            	CALL CHKCHAR
 325+ 5005 ~            	DB ')'
 326+ 5005 ~            .ENTRY:
 327+ 5005 ~                PUSH HL
 328+ 5005 ~                POP IX
 329+ 5005 ~                EXX
 330+ 5005 ~                POP BC ; color
 331+ 5005 ~                POP DE ; pattern
 332+ 5005 ~                POP HL ; ticks
 333+ 5005 ~                EXX
 334+ 5005 ~                POP AF
 335+ 5005 ~                CALL GETnthANIMITEM
 336+ 5005 ~                PUSH HL
 337+ 5005 ~                POP IY
 338+ 5005 ~                EXX
 339+ 5005 ~                LD (IY),0 ; type=0
 340+ 5005 ~                LD (IY+1),L
 341+ 5005 ~                LD (IY+2),H
 342+ 5005 ~                LD (IY+3),D
 343+ 5005 ~                LD (IY+4),B
 344+ 5005 ~
 345+ 5005 ~                PUSH IX
 346+ 5005 ~                POP HL
 347+ 5005 ~                RET
 348+ 5005 ~            ; *******************************************************************************************************
 349+ 5005               ENDIF
 350+ 5005
 351+ 5005               IF (1 == 1)
 352+ 5005              ; *******************************************************************************************************
 353+ 5005              ; same as ANIMITEMPAT but for DEFUSR approach
 354+ 5005              ; input IX=pointer to input array, real data from +2
 355+ 5005              ; +02 = ID
 356+ 5005              ; +04 = ticks
 357+ 5005              ; +06 = pattern
 358+ 5005              ; +08 = color
 359+ 5005              ANIMITEMPAT_DEFUSR:
 360+ 5005                  ; check if out of bounds
 361+ 5005 DD 4E 02         LD C,(IX+2)
 362+ 5008 0C               INC C
 363+ 5009 3A F7 4E         LD A,(ANIMITEMNUM)
 364+ 500C B9               CP C
 365+ 500D 38 1D            JR C,.ERR ; out of bounds, prevent memory corruption
 366+ 500F 79               LD A,C
 367+ 5010 3D               DEC A
 368+ 5011 CD 0C 4F         CALL GETnthANIMITEM
 369+ 5014 36 00            LD (HL),0 ; type=0
 370+ 5016 23               INC HL
 371+ 5017 DD 7E 04         LD A,(IX+4) ; ticks low
 372+ 501A 77               LD (HL),A
 373+ 501B 23               INC HL
 374+ 501C DD 7E 05         LD A,(IX+5) ; ticks high
 375+ 501F 77               LD (HL),A
 376+ 5020 23               INC HL
 377+ 5021 DD 7E 06         LD A,(IX+6) ; pattern
 378+ 5024 77               LD (HL),A
 379+ 5025 23               INC HL
 380+ 5026 DD 7E 08         LD A,(IX+8) ; color
 381+ 5029 77               LD (HL),A
 382+ 502A AF               XOR A ; success
 383+ 502B C9               RET
 384+ 502C              .ERR:
 385+ 502C 3E 01            LD A,1
 386+ 502E C9               RET
 387+ 502F              ; *******************************************************************************************************
 388+ 502F               ENDIF
 389+ 502F
 390+ 502F               IF (0 == 1)
 391+ 502F ~            ; *******************************************************************************************************
 392+ 502F ~            ; function to handle CALL ANIMITEMPTR basic extension
 393+ 502F ~            ; ANIMITEMPTR ( BYTE id,
 394+ 502F ~            ;               INT ticks,
 395+ 502F ~            ;               INT pointer,
 396+ 502F ~            ; fills animation item data, returns an error if ID out of bounds
 397+ 502F ~            ANIMITEMPTR_CMD:
 398+ 502F ~                ; opening (
 399+ 502F ~            	CALL CHKCHAR
 400+ 502F ~            	DB '('
 401+ 502F ~            	; get id
 402+ 502F ~            	LD IX, GETBYT
 403+ 502F ~            	CALL CALBAS
 404+ 502F ~                PUSH AF
 405+ 502F ~                ; check if out of bounds
 406+ 502F ~                INC A
 407+ 502F ~                LD C,A
 408+ 502F ~                LD A,(ANIMITEMNUM)
 409+ 502F ~                CP C
 410+ 502F ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 411+ 502F ~            	; comma
 412+ 502F ~            	CALL CHKCHAR
 413+ 502F ~            	DB ','
 414+ 502F ~            	; get ticks
 415+ 502F ~            	LD IX, FRMQNT
 416+ 502F ~            	CALL CALBAS
 417+ 502F ~                LD A,D
 418+ 502F ~                OR E
 419+ 502F ~                JP Z,OVERFLOW
 420+ 502F ~            	PUSH DE
 421+ 502F ~            	; comma
 422+ 502F ~            	CALL CHKCHAR
 423+ 502F ~            	DB ','
 424+ 502F ~            	; get pointer
 425+ 502F ~            	LD IX, FRMQNT
 426+ 502F ~            	CALL CALBAS
 427+ 502F ~            	PUSH DE
 428+ 502F ~            	; ending )
 429+ 502F ~            	CALL CHKCHAR
 430+ 502F ~            	DB ')'
 431+ 502F ~            .ENTRY:
 432+ 502F ~                PUSH HL
 433+ 502F ~                POP IX
 434+ 502F ~                EXX
 435+ 502F ~                POP DE ; pointer
 436+ 502F ~                POP HL ; ticks
 437+ 502F ~                EXX
 438+ 502F ~                POP AF
 439+ 502F ~                CALL GETnthANIMITEM
 440+ 502F ~                PUSH HL
 441+ 502F ~                POP IY
 442+ 502F ~                EXX
 443+ 502F ~                LD (IY),1 ; type=1
 444+ 502F ~                LD (IY+1),L
 445+ 502F ~                LD (IY+2),H
 446+ 502F ~                LD (IY+3),E
 447+ 502F ~                LD (IY+4),D
 448+ 502F ~
 449+ 502F ~                PUSH IX
 450+ 502F ~                POP HL
 451+ 502F ~                RET
 452+ 502F ~            ; *******************************************************************************************************
 453+ 502F               ENDIF
 454+ 502F
 455+ 502F               IF (1 == 1)
 456+ 502F              ; *******************************************************************************************************
 457+ 502F              ; same as ANIMITEMPTR but for DEFUSR approach
 458+ 502F              ; input IX=pointer to input array, real data from +2
 459+ 502F              ; +02 = ID
 460+ 502F              ; +04 = ticks
 461+ 502F              ; +06 = pointer
 462+ 502F              ANIMITEMPTR_DEFUSR:
 463+ 502F                  ; check if out of bounds
 464+ 502F DD 4E 02         LD C,(IX+2)
 465+ 5032 0C               INC C
 466+ 5033 3A F7 4E         LD A,(ANIMITEMNUM)
 467+ 5036 B9               CP C
 468+ 5037 38 1D            JR C,.ERR ; out of bounds, prevent memory corruption
 469+ 5039 79               LD A,C
 470+ 503A 3D               DEC A
 471+ 503B CD 0C 4F         CALL GETnthANIMITEM
 472+ 503E 36 01            LD (HL),1 ; type=1
 473+ 5040 23               INC HL
 474+ 5041 DD 7E 04         LD A,(IX+4) ; ticks low
 475+ 5044 77               LD (HL),A
 476+ 5045 23               INC HL
 477+ 5046 DD 7E 05         LD A,(IX+5) ; ticks high
 478+ 5049 77               LD (HL),A
 479+ 504A 23               INC HL
 480+ 504B DD 7E 06         LD A,(IX+6) ; pointer low
 481+ 504E 77               LD (HL),A
 482+ 504F 23               INC HL
 483+ 5050 DD 7E 07         LD A,(IX+7) ; pointer high
 484+ 5053 77               LD (HL),A
 485+ 5054 AF               XOR A ; success
 486+ 5055 C9               RET
 487+ 5056              .ERR:
 488+ 5056 3E 01            LD A,1
 489+ 5058 C9               RET
 490+ 5059              ; *******************************************************************************************************
 491+ 5059               ENDIF
 492+ 5059
 493+ 5059               IF (1 == 1)
 494+ 5059              ; *******************************************************************************************************
 495+ 5059              ; same as MAXANIMDEFS but for DEFUSR approach
 496+ 5059              ; input IX=pointer to input array, real data from +2
 497+ 5059              ; +2 = number
 498+ 5059              MAXANIMDEFS_DEFUSR:
 499+ 5059 DD 7E 02         LD A,(IX+2)
 500+ 505C CD 61 50         CALL MAXANIMDEFS.COMMON
 501+ 505F AF               XOR A ; success
 502+ 5060 C9               RET
 503+ 5061              ; *******************************************************************************************************
 504+ 5061               ENDIF
 505+ 5061
 506+ 5061              ; *******************************************************************************************************
 507+ 5061              ; function to handle CALL MAXANIMDEFS basic extension
 508+ 5061              ; MAXANIMDEFS (BYTE number)
 509+ 5061              ; sets new number and moves memory buffers as needed
 510+ 5061              MAXANIMDEFS:
 511+ 5061               IF (0 == 1)
 512+ 5061 ~            	; opening (
 513+ 5061 ~            	CALL CHKCHAR
 514+ 5061 ~            	DB '('
 515+ 5061 ~            	; get value
 516+ 5061 ~            	LD IX, GETBYT
 517+ 5061 ~            	CALL CALBAS
 518+ 5061 ~                PUSH AF
 519+ 5061 ~            	; ending )
 520+ 5061 ~            	CALL CHKCHAR
 521+ 5061 ~            	DB ')'
 522+ 5061 ~                POP AF
 523+ 5061               ENDIF
 524+ 5061              .COMMON:
 525+ 5061 F3               DI
 526+ 5062              	; save position
 527+ 5062 E5           	PUSH HL
 528+ 5063              .ENTRY:
 529+ 5063 47               LD B,A
 530+ 5064 3A FA 4E         LD A,(ANIMDEFNUM)
 531+ 5067 90               SUB B
 532+ 5068 CA 76 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 533+ 506B FD 21 FE 4E      LD IY,ANIMSPRPTR
 534+ 506F FA 7B 50         JP M, .INCREASE
 535+ 5072                  ; new value is lower than previous one
 536+ 5072 CD 86 50         CALL .SIZEDIFF
 537+ 5075 CD B3 4F         CALL MAXANIMITEMS.DECREASE_COMMON
 538+ 5078 C3 64 4F         JP MAXANIMITEMS.E1
 539+ 507B              .INCREASE:
 540+ 507B ED 44            NEG
 541+ 507D CD 86 50         CALL .SIZEDIFF
 542+ 5080 CD DF 4F         CALL MAXANIMITEMS.INCREASE_COMMON
 543+ 5083 C3 88 4F         JP MAXANIMITEMS.E2
 544+ 5086              .SIZEDIFF:
 545+ 5086 26 00            LD H,0
 546+ 5088 6F               LD L,A
 547+ 5089 CD BE 5F         CALL HLx16
 548+ 508C 78               LD A,B
 549+ 508D 32 FA 4E         LD (ANIMDEFNUM),A
 550+ 5090 44               LD B,H
 551+ 5091 4D               LD C,L
 552+ 5092 C9               RET ; BC=size difference in bytes
 553+ 5093              ; *******************************************************************************************************
 554+ 5093
 555+ 5093               IF (0 == 1)
 556+ 5093 ~            ; *******************************************************************************************************
 557+ 5093 ~            ; function to handle CALL ANIMDEF basic extension
 558+ 5093 ~            ; ANIMITEMPAT ( BYTE id,
 559+ 5093 ~            ;               BYTE size,
 560+ 5093 ~            ;               INT[] list )
 561+ 5093 ~            ; fills animation definition data, returns an error if out of bounds, or invalid type
 562+ 5093 ~            ANIMDEF:
 563+ 5093 ~                ; opening (
 564+ 5093 ~            	CALL CHKCHAR
 565+ 5093 ~            	DB '('
 566+ 5093 ~            	; get id
 567+ 5093 ~            	LD IX, GETBYT
 568+ 5093 ~            	CALL CALBAS
 569+ 5093 ~                PUSH AF
 570+ 5093 ~                ; check if out of bounds
 571+ 5093 ~                INC A
 572+ 5093 ~                LD C,A
 573+ 5093 ~                LD A,(ANIMDEFNUM)
 574+ 5093 ~                CP C
 575+ 5093 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 576+ 5093 ~            	; comma
 577+ 5093 ~            	CALL CHKCHAR
 578+ 5093 ~            	DB ','
 579+ 5093 ~            	; get size
 580+ 5093 ~            	LD IX, GETBYT
 581+ 5093 ~            	CALL CALBAS
 582+ 5093 ~                CP 16
 583+ 5093 ~                JP NC, OVERFLOW
 584+ 5093 ~                OR A
 585+ 5093 ~                JP Z, OVERFLOW
 586+ 5093 ~            	PUSH AF
 587+ 5093 ~            	; comma
 588+ 5093 ~            	CALL CHKCHAR
 589+ 5093 ~            	DB ','
 590+ 5093 ~            	; get pointer to a list of animation items in integer array format
 591+ 5093 ~                ; get array pointer
 592+ 5093 ~                POP DE
 593+ 5093 ~                PUSH DE
 594+ 5093 ~                LD A,2
 595+ 5093 ~                LD B,1
 596+ 5093 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
 597+ 5093 ~                PUSH BC
 598+ 5093 ~            	; ending )
 599+ 5093 ~            	CALL CHKCHAR
 600+ 5093 ~            	DB ')'
 601+ 5093 ~            .ENTRY:
 602+ 5093 ~                PUSH HL
 603+ 5093 ~                POP IX
 604+ 5093 ~                POP DE ; pointer to INT array
 605+ 5093 ~                POP BC ; B=item number
 606+ 5093 ~                POP AF ; id
 607+ 5093 ~                PUSH DE
 608+ 5093 ~                CALL GETnthANIMDEF
 609+ 5093 ~                POP DE
 610+ 5093 ~                LD (HL),B
 611+ 5093 ~            .L1:
 612+ 5093 ~                INC HL
 613+ 5093 ~                LD A,(DE)
 614+ 5093 ~                .2 INC DE
 615+ 5093 ~                LD (HL),A
 616+ 5093 ~                DJNZ .L1
 617+ 5093 ~                PUSH IX
 618+ 5093 ~                POP HL
 619+ 5093 ~                RET
 620+ 5093 ~            ; *******************************************************************************************************
 621+ 5093               ENDIF
 622+ 5093
 623+ 5093               IF (1 == 1)
 624+ 5093              ; *******************************************************************************************************
 625+ 5093              ; same as ANIMDEF but for DEFUSR approach
 626+ 5093              ; input IX=pointer to input array, real data from +2
 627+ 5093              ; +02 = ID
 628+ 5093              ; +04 = list size
 629+ 5093              ; +06 = list pointer
 630+ 5093              ANIMDEF_DEFUSR:
 631+ 5093                  ; check if out of bounds
 632+ 5093 DD 4E 02         LD C,(IX+2)
 633+ 5096 0C               INC C
 634+ 5097 3A FA 4E         LD A,(ANIMDEFNUM)
 635+ 509A B9               CP C
 636+ 509B 38 1E            JR C,.ERR ; invalid id
 637+ 509D              	; get size
 638+ 509D DD 7E 04         LD A,(IX+4)
 639+ 50A0 FE 10            CP 16
 640+ 50A2 D0               RET NC ; overflow
 641+ 50A3 B7               OR A
 642+ 50A4 C8               RET Z ; ID=0, invalid
 643+ 50A5 47               LD B,A
 644+ 50A6 79               LD A,C
 645+ 50A7 3D               DEC A
 646+ 50A8 CD 15 4F         CALL GETnthANIMDEF
 647+ 50AB 70               LD (HL),B
 648+ 50AC DD 5E 06         LD E,(IX+6)
 649+ 50AF DD 56 07         LD D,(IX+7)
 650+ 50B2              .L1:
 651+ 50B2 23               INC HL
 652+ 50B3 1A               LD A,(DE)
 653+ 50B4 13          > INC DE
 653+ 50B5 13          > INC DE
 654+ 50B6 77               LD (HL),A
 655+ 50B7 10 F9            DJNZ .L1
 656+ 50B9 AF               XOR A ; success
 657+ 50BA C9               RET
 658+ 50BB              .ERR:
 659+ 50BB 3E 01            LD A,1
 660+ 50BD C9               RET
 661+ 50BE              ; *******************************************************************************************************
 662+ 50BE               ENDIF
 663+ 50BE
 664+ 50BE               IF (1 == 1)
 665+ 50BE              ; *******************************************************************************************************
 666+ 50BE              ; same as MAXANIMSPRS but for DEFUSR approach
 667+ 50BE              ; input IX=pointer to input array, real data from +2
 668+ 50BE              ; +2 = number
 669+ 50BE              MAXANIMSPRS_DEFUSR:
 670+ 50BE DD 7E 02         LD A,(IX+2)
 671+ 50C1 CD C6 50         CALL MAXANIMSPRS.COMMON
 672+ 50C4 AF               XOR A ; success
 673+ 50C5 C9               RET
 674+ 50C6              ; *******************************************************************************************************
 675+ 50C6               ENDIF
 676+ 50C6
 677+ 50C6              ; *******************************************************************************************************
 678+ 50C6              ; function to handle CALL MAXANIMSPRS basic extension
 679+ 50C6              ; MAXANIMSPRS (BYTE number)
 680+ 50C6              ; sets new number and moves memory buffers as needed
 681+ 50C6              MAXANIMSPRS:
 682+ 50C6               IF (0 == 1)
 683+ 50C6 ~            	; opening (
 684+ 50C6 ~            	CALL CHKCHAR
 685+ 50C6 ~            	DB '('
 686+ 50C6 ~            	; get value
 687+ 50C6 ~            	LD IX, GETBYT
 688+ 50C6 ~            	CALL CALBAS
 689+ 50C6 ~                PUSH AF
 690+ 50C6 ~            	; ending )
 691+ 50C6 ~            	CALL CHKCHAR
 692+ 50C6 ~            	DB ')'
 693+ 50C6 ~                POP AF
 694+ 50C6               ENDIF
 695+ 50C6              .COMMON:
 696+ 50C6 F3               DI
 697+ 50C7              	; save position
 698+ 50C7 E5           	PUSH HL
 699+ 50C8              .ENTRY:
 700+ 50C8 47               LD B,A
 701+ 50C9 3A FD 4E         LD A,(ANIMSPRNUM)
 702+ 50CC 90               SUB B
 703+ 50CD CA 76 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 704+ 50D0 FD 21 01 4F      LD IY,AUTOSGAMPTR
 705+ 50D4 FA E0 50         JP M, .INCREASE
 706+ 50D7                  ; new value is lower than previous one
 707+ 50D7 CD 01 51         CALL .SIZEDIFF
 708+ 50DA CD B3 4F         CALL MAXANIMITEMS.DECREASE_COMMON
 709+ 50DD C3 6D 4F         JP MAXANIMITEMS.E3
 710+ 50E0              .INCREASE:
 711+ 50E0 ED 44            NEG
 712+ 50E2 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 713+ 50E3 CD 01 51         CALL .SIZEDIFF
 714+ 50E6 CD DF 4F         CALL MAXANIMITEMS.INCREASE_COMMON
 715+ 50E9 AF               XOR A
 716+ 50EA ED 42            SBC HL,BC ; location of new stuff
 717+ 50EC F1               POP AF
 718+ 50ED C5               PUSH BC
 719+ 50EE 47               LD B,A
 720+ 50EF 11 08 00         LD DE,8
 721+ 50F2 E5               PUSH HL
 722+ 50F3 DD E1            POP IX
 723+ 50F5              .L1:
 724+ 50F5 DD 36 06 00      LD (IX+6),0 ; active flag
 725+ 50F9 DD 19            ADD IX,DE
 726+ 50FB 10 F8            DJNZ .L1
 727+ 50FD C1               POP BC
 728+ 50FE C3 8F 4F         JP MAXANIMITEMS.E4
 729+ 5101              .SIZEDIFF:
 730+ 5101 26 00            LD H,0
 731+ 5103 6F               LD L,A
 732+ 5104 CD BF 5F         CALL HLx8
 733+ 5107 78               LD A,B
 734+ 5108 32 FD 4E         LD (ANIMSPRNUM),A
 735+ 510B 44               LD B,H
 736+ 510C 4D               LD C,L
 737+ 510D C9               RET ; BC=size difference in bytes
 738+ 510E              ; *******************************************************************************************************
 739+ 510E
 740+ 510E               IF (0 == 1)
 741+ 510E ~            ; *******************************************************************************************************
 742+ 510E ~            ; function to handle CALL ANIMSPRITE basic extension
 743+ 510E ~            ; ANIMSPRITE ( BYTE id,
 744+ 510E ~            ;              BYTE sprite_number,
 745+ 510E ~            ;              BYTE animation_definition_id,
 746+ 510E ~            ;              BYTE cyclic_flag )
 747+ 510E ~            ; fills sprite animation data, returns an error if out of bounds, or invalid type
 748+ 510E ~            ANIMSPRITE:
 749+ 510E ~                ; opening (
 750+ 510E ~            	CALL CHKCHAR
 751+ 510E ~            	DB '('
 752+ 510E ~            	; get sprite animation id
 753+ 510E ~            	LD IX, GETBYT
 754+ 510E ~            	CALL CALBAS
 755+ 510E ~                PUSH AF
 756+ 510E ~                INC A
 757+ 510E ~                LD C,A
 758+ 510E ~                LD A,(ANIMSPRNUM)
 759+ 510E ~                CP C
 760+ 510E ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 761+ 510E ~            	; comma
 762+ 510E ~            	CALL CHKCHAR
 763+ 510E ~            	DB ','
 764+ 510E ~            	; get sprite number
 765+ 510E ~            	LD IX, GETBYT
 766+ 510E ~            	CALL CALBAS
 767+ 510E ~                PUSH AF
 768+ 510E ~                ; check if out of bounds
 769+ 510E ~                CP 32
 770+ 510E ~                JP NC, SUBSCRIPT_OUT_OF_RANGE
 771+ 510E ~            	; comma
 772+ 510E ~            	CALL CHKCHAR
 773+ 510E ~            	DB ','
 774+ 510E ~            	; get animation definition id
 775+ 510E ~            	LD IX, GETBYT
 776+ 510E ~            	CALL CALBAS
 777+ 510E ~                PUSH AF
 778+ 510E ~                INC A
 779+ 510E ~                LD C,A
 780+ 510E ~                LD A,(ANIMDEFNUM)
 781+ 510E ~                CP C
 782+ 510E ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 783+ 510E ~            	; comma
 784+ 510E ~            	CALL CHKCHAR
 785+ 510E ~            	DB ','
 786+ 510E ~            	; get cyclic flag
 787+ 510E ~            	LD IX, GETBYT
 788+ 510E ~                CALL CALBAS
 789+ 510E ~            	PUSH AF
 790+ 510E ~            	; ending )
 791+ 510E ~            	CALL CHKCHAR
 792+ 510E ~            	DB ')'
 793+ 510E ~            .ENTRY:
 794+ 510E ~                PUSH HL
 795+ 510E ~                POP IX
 796+ 510E ~                EXX
 797+ 510E ~                POP DE ; cyclic
 798+ 510E ~                POP BC ; animation definition id
 799+ 510E ~                POP HL ; sprite number
 800+ 510E ~                EXX
 801+ 510E ~                POP AF ; sprite animation id
 802+ 510E ~                CALL GETnthSPRANIM
 803+ 510E ~                PUSH HL
 804+ 510E ~                POP IY
 805+ 510E ~                EXX
 806+ 510E ~                LD (IY),H
 807+ 510E ~                LD (IY+4),B
 808+ 510E ~                LD (IY+5),D
 809+ 510E ~                ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 810+ 510E ~                ; following will do preparation for ANIMSTEP situation
 811+ 510E ~                ; current item set to above limit and timer to 1
 812+ 510E ~                ; any call to ANIMSTEP will switch and setup to first item for cyclic
 813+ 510E ~                LD (IY+3),255
 814+ 510E ~                LD (IY+1),1
 815+ 510E ~                LD (IY+2),0
 816+ 510E ~                ; mark as sprite animation
 817+ 510E ~                LD (IY+7),0
 818+ 510E ~                PUSH IX
 819+ 510E ~                POP HL
 820+ 510E ~                RET
 821+ 510E ~            ; *******************************************************************************************************
 822+ 510E               ENDIF
 823+ 510E
 824+ 510E               IF (1 == 1)
 825+ 510E              ; *******************************************************************************************************
 826+ 510E              ; same as ANIMSPRITE but for DEFUSR approach
 827+ 510E              ; input IX=pointer to input array, real data from +2
 828+ 510E              ; +02 = ID
 829+ 510E              ; +04 = sprite number
 830+ 510E              ; +06 = animation definition id
 831+ 510E              ; +08 = cyclic flag
 832+ 510E              ANIMSPRITE_DEFUSR:
 833+ 510E DD 4E 02         LD C,(IX+2)
 834+ 5111 0C               INC C
 835+ 5112 3A FD 4E         LD A,(ANIMSPRNUM)
 836+ 5115 B9               CP C
 837+ 5116 38 31            JR C,.ERR ; invalid id
 838+ 5118              	; get sprite number
 839+ 5118 DD 7E 04         LD A,(IX+4)
 840+ 511B FE 20            CP 32
 841+ 511D 30 2A            JR NC,.ERR ; invalid sprite id
 842+ 511F DD 46 06         LD B,(IX+6)
 843+ 5122 04               INC B
 844+ 5123 3A FA 4E         LD A,(ANIMDEFNUM)
 845+ 5126 B8               CP B
 846+ 5127 38 20            JR C,.ERR ; invalid animation definition id
 847+ 5129 79               LD A,C
 848+ 512A 3D               DEC A
 849+ 512B CD 21 4F         CALL GETnthSPRANIM
 850+ 512E DD 7E 04         LD A,(IX+4)
 851+ 5131 77               LD (HL),A ; +0
 852+ 5132 23               INC HL
 853+ 5133 36 01            LD (HL),1 ; +1
 854+ 5135 23               INC HL
 855+ 5136 36 00            LD (HL),0 ; +2
 856+ 5138 23               INC HL
 857+ 5139 36 FF            LD (HL),255 ; +3
 858+ 513B 23               INC HL
 859+ 513C 05               DEC B
 860+ 513D 70               LD (HL),B ; +4
 861+ 513E 23               INC HL
 862+ 513F DD 7E 08         LD A,(IX+8) ; +5
 863+ 5142 77               LD (HL),A
 864+ 5143 23               INC HL
 865+ 5144 23               INC HL
 866+ 5145 36 00            LD (HL),0 ; +7
 867+ 5147 AF               XOR A ; success
 868+ 5148 C9               RET
 869+ 5149              .ERR:
 870+ 5149 3E 01            LD A,1
 871+ 514B C9               RET
 872+ 514C              ; *******************************************************************************************************
 873+ 514C               ENDIF
 874+ 514C
 875+ 514C
 876+ 514C               IF (0 == 1)
 877+ 514C ~            ; *******************************************************************************************************
 878+ 514C ~            ; function to handle CALL ANIMCHAR basic extension
 879+ 514C ~            ; ANIMCHAR ( BYTE id,
 880+ 514C ~            ;            INT character number 0-767,
 881+ 514C ~            ;            BYTE animation_definition_id,
 882+ 514C ~            ;            BYTE cyclic_flag )
 883+ 514C ~            ; fills sprite animation data, returns an error if out of bounds, or invalid type
 884+ 514C ~            ANIMCHAR:
 885+ 514C ~                ; opening (
 886+ 514C ~            	CALL CHKCHAR
 887+ 514C ~            	DB '('
 888+ 514C ~            	; get sprite animation id
 889+ 514C ~            	LD IX, GETBYT
 890+ 514C ~            	CALL CALBAS
 891+ 514C ~                PUSH AF
 892+ 514C ~                INC A
 893+ 514C ~                LD C,A
 894+ 514C ~                LD A,(ANIMSPRNUM)
 895+ 514C ~                CP C
 896+ 514C ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 897+ 514C ~            	; comma
 898+ 514C ~            	CALL CHKCHAR
 899+ 514C ~            	DB ','
 900+ 514C ~            	; get character number
 901+ 514C ~            	LD IX, FRMQNT
 902+ 514C ~            	CALL CALBAS
 903+ 514C ~                PUSH DE
 904+ 514C ~                ; check if out of bounds
 905+ 514C ~                LD A,D
 906+ 514C ~                CP 3
 907+ 514C ~                JP NC, SUBSCRIPT_OUT_OF_RANGE
 908+ 514C ~            	; comma
 909+ 514C ~            	CALL CHKCHAR
 910+ 514C ~            	DB ','
 911+ 514C ~            	; get animation definition id
 912+ 514C ~            	LD IX, GETBYT
 913+ 514C ~            	CALL CALBAS
 914+ 514C ~                PUSH AF
 915+ 514C ~                INC A
 916+ 514C ~                LD C,A
 917+ 514C ~                LD A,(ANIMDEFNUM)
 918+ 514C ~                CP C
 919+ 514C ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 920+ 514C ~            	; comma
 921+ 514C ~            	CALL CHKCHAR
 922+ 514C ~            	DB ','
 923+ 514C ~            	; get cyclic flag
 924+ 514C ~            	LD IX, GETBYT
 925+ 514C ~                CALL CALBAS
 926+ 514C ~            	PUSH AF
 927+ 514C ~            	; ending )
 928+ 514C ~            	CALL CHKCHAR
 929+ 514C ~            	DB ')'
 930+ 514C ~            .ENTRY:
 931+ 514C ~                PUSH HL
 932+ 514C ~                POP IX
 933+ 514C ~                EXX
 934+ 514C ~                POP DE ; cyclic
 935+ 514C ~                POP BC ; animation definition id
 936+ 514C ~                POP HL ; character number
 937+ 514C ~                EXX
 938+ 514C ~                POP AF ; sprite animation id
 939+ 514C ~                CALL GETnthSPRANIM
 940+ 514C ~                PUSH HL
 941+ 514C ~                POP IY
 942+ 514C ~                EXX
 943+ 514C ~                LD (IY),L
 944+ 514C ~                INC H ; save character bank+1
 945+ 514C ~                LD (IY+7),H
 946+ 514C ~                LD (IY+4),B
 947+ 514C ~                LD (IY+5),D
 948+ 514C ~                ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 949+ 514C ~                ; following will do preparation for ANIMSTEP situation
 950+ 514C ~                ; current item set to above limit and timer to 1
 951+ 514C ~                ; any call to ANIMSTEP will switch and setup to first item for cyclic
 952+ 514C ~                LD (IY+3),255
 953+ 514C ~                LD (IY+1),1
 954+ 514C ~                LD (IY+2),0
 955+ 514C ~                PUSH IX
 956+ 514C ~                POP HL
 957+ 514C ~                RET
 958+ 514C ~            ; *******************************************************************************************************
 959+ 514C               ENDIF
 960+ 514C
 961+ 514C               IF (1 == 1)
 962+ 514C              ; *******************************************************************************************************
 963+ 514C              ; same as ANIMCHAR but for DEFUSR approach
 964+ 514C              ; input IX=pointer to input array, real data from +2
 965+ 514C              ; +02 = ID
 966+ 514C              ; +04 = character number
 967+ 514C              ; +06 = animation definition id
 968+ 514C              ; +08 = cyclic flag
 969+ 514C              ANIMCHAR_DEFUSR:
 970+ 514C DD 4E 02         LD C,(IX+2)
 971+ 514F 0C               INC C
 972+ 5150 3A FD 4E         LD A,(ANIMSPRNUM)
 973+ 5153 B9               CP C
 974+ 5154 38 34            JR C,.ERR ; invalid id
 975+ 5156              	; get sprite number
 976+ 5156 DD 7E 05         LD A,(IX+5)
 977+ 5159 FE 03            CP 3
 978+ 515B 30 2D            JR NC,.ERR ; invalid character (>767)
 979+ 515D DD 46 06         LD B,(IX+6)
 980+ 5160 04               INC B
 981+ 5161 3A FA 4E         LD A,(ANIMDEFNUM)
 982+ 5164 B8               CP B
 983+ 5165 38 23            JR C,.ERR ; invalid animation definition id
 984+ 5167 79               LD A,C
 985+ 5168 3D               DEC A
 986+ 5169 CD 21 4F         CALL GETnthSPRANIM
 987+ 516C DD 7E 04         LD A,(IX+4)
 988+ 516F 77               LD (HL),A ; +0
 989+ 5170 23               INC HL
 990+ 5171 36 01            LD (HL),1 ; +1
 991+ 5173 23               INC HL
 992+ 5174 36 00            LD (HL),0 ; +2
 993+ 5176 23               INC HL
 994+ 5177 36 FF            LD (HL),255 ; +3
 995+ 5179 23               INC HL
 996+ 517A 05               DEC B
 997+ 517B 70               LD (HL),B ; +4
 998+ 517C 23               INC HL
 999+ 517D DD 7E 08         LD A,(IX+8) ; +5
1000+ 5180 77               LD (HL),A
1001+ 5181 23               INC HL
1002+ 5182 23               INC HL
1003+ 5183 DD 7E 05         LD A,(IX+5)
1004+ 5186 3C               INC A
1005+ 5187 77               LD (HL),A ; +7
1006+ 5188 AF               XOR A ; success
1007+ 5189 C9               RET
1008+ 518A              .ERR:
1009+ 518A 3E 01            LD A,1
1010+ 518C C9               RET
1011+ 518D              ; *******************************************************************************************************
1012+ 518D               ENDIF
1013+ 518D
1014+ 518D               IF (1 == 1)
1015+ 518D              ; *******************************************************************************************************
1016+ 518D              ; same as MAXAUTOSGAMS but for DEFUSR approach
1017+ 518D              ; input IX=pointer to input array, real data from +2
1018+ 518D              ; +2 = number
1019+ 518D              MAXAUTOSGAMS_DEFUSR:
1020+ 518D DD 7E 02         LD A,(IX+2)
1021+ 5190 CD 95 51         CALL MAXAUTOSGAMS.COMMON
1022+ 5193 AF               XOR A ; success
1023+ 5194 C9               RET
1024+ 5195              ; *******************************************************************************************************
1025+ 5195               ENDIF
1026+ 5195
1027+ 5195              ; *******************************************************************************************************
1028+ 5195              ; function to handle CALL MAXAUTOSGAMS basic extension
1029+ 5195              ; MAXAUTOSGAMS (BYTE number)
1030+ 5195              ; sets new number and moves memory buffers as needed
1031+ 5195              MAXAUTOSGAMS:
1032+ 5195               IF (0 == 1)
1033+ 5195 ~            	; opening (
1034+ 5195 ~            	CALL CHKCHAR
1035+ 5195 ~            	DB '('
1036+ 5195 ~            	; get value
1037+ 5195 ~            	LD IX, GETBYT
1038+ 5195 ~            	CALL CALBAS
1039+ 5195 ~                PUSH AF
1040+ 5195 ~            	; ending )
1041+ 5195 ~            	CALL CHKCHAR
1042+ 5195 ~            	DB ')'
1043+ 5195 ~                POP AF
1044+ 5195               ENDIF
1045+ 5195              .COMMON:
1046+ 5195 F3               DI
1047+ 5196              	; save position
1048+ 5196 E5           	PUSH HL
1049+ 5197              .ENTRY:
1050+ 5197 47               LD B,A
1051+ 5198 3A 00 4F         LD A,(AUTOSGAMNUM)
1052+ 519B 90               SUB B
1053+ 519C CA 76 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
1054+ 519F FD 21 10 40      LD IY,FREEMEMPTR
1055+ 51A3 FA AF 51         JP M, .INCREASE
1056+ 51A6                  ; new value is lower than previous one
1057+ 51A6 CD D0 51         CALL .SIZEDIFF
1058+ 51A9 CD B3 4F         CALL MAXANIMITEMS.DECREASE_COMMON
1059+ 51AC C3 76 4F         JP MAXANIMITEMS.EXIT
1060+ 51AF              .INCREASE:
1061+ 51AF ED 44            NEG
1062+ 51B1 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
1063+ 51B2 CD D0 51         CALL .SIZEDIFF
1064+ 51B5 CD DF 4F         CALL MAXANIMITEMS.INCREASE_COMMON
1065+ 51B8 AF               XOR A
1066+ 51B9 ED 42            SBC HL,BC ; location of new stuff
1067+ 51BB F1               POP AF
1068+ 51BC C5               PUSH BC
1069+ 51BD 47               LD B,A
1070+ 51BE 11 18 00         LD DE,24
1071+ 51C1 E5               PUSH HL
1072+ 51C2 DD E1            POP IX
1073+ 51C4              .L1:
1074+ 51C4 DD 36 13 00      LD (IX+19),0 ; active flag
1075+ 51C8 DD 19            ADD IX,DE
1076+ 51CA 10 F8            DJNZ .L1
1077+ 51CC C1               POP BC
1078+ 51CD C3 76 4F         JP MAXANIMITEMS.EXIT
1079+ 51D0              .SIZEDIFF:
1080+ 51D0 26 00            LD H,0
1081+ 51D2 6F               LD L,A
1082+ 51D3 CD BF 5F         CALL HLx8
1083+ 51D6 54               LD D,H
1084+ 51D7 5D               LD E,L
1085+ 51D8 29               ADD HL,HL
1086+ 51D9 19               ADD HL,DE
1087+ 51DA 78               LD A,B
1088+ 51DB 32 00 4F         LD (AUTOSGAMNUM),A
1089+ 51DE 44               LD B,H
1090+ 51DF 4D               LD C,L
1091+ 51E0 C9               RET ; BC=size difference in bytes
1092+ 51E1              ; *******************************************************************************************************
1093+ 51E1
1094+ 51E1               IF (0 == 1)
1095+ 51E1 ~            ; *******************************************************************************************************
1096+ 51E1 ~            ; function to handle CALL AUTOSGAMDEF basic extension
1097+ 51E1 ~            ; AUTOSGAMDEF ( BYTE id,
1098+ 51E1 ~            ;               INT VARIABLE x, INT VARIABLE y,
1099+ 51E1 ~            ;               INT minimum, INT maximum, INT delta,
1100+ 51E1 ~            ;               INT direction =0 horizontal,
1101+ 51E1 ~            ;               INT ticks,
1102+ 51E1 ~            ;               BYTE sprite_group_count,
1103+ 51E1 ~            ;               INT[2][sprite_group_count] VARIABLE sprite_group,
1104+ 51E1 ~            ;               BYTE item_number,
1105+ 51E1 ~            ;               INT[] VARIABLE sprite_animations_negative_direction,
1106+ 51E1 ~            ;               INT[] VARIABLE sprite_animations_positive_direction
1107+ 51E1 ~            AUTOSGAMDEF:
1108+ 51E1 ~                ; opening (
1109+ 51E1 ~            	CALL CHKCHAR
1110+ 51E1 ~            	DB '('
1111+ 51E1 ~            	; get sprite animation id
1112+ 51E1 ~            	LD IX, GETBYT
1113+ 51E1 ~            	CALL CALBAS
1114+ 51E1 ~                PUSH AF
1115+ 51E1 ~                INC A
1116+ 51E1 ~                LD C,A
1117+ 51E1 ~                LD A,(AUTOSGAMNUM)
1118+ 51E1 ~                CP C
1119+ 51E1 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
1120+ 51E1 ~                POP AF
1121+ 51E1 ~                PUSH HL
1122+ 51E1 ~                CALL GETnthAUTOSGAM
1123+ 51E1 ~                LD (BLIT_TMP),HL ; for later
1124+ 51E1 ~                POP HL
1125+ 51E1 ~            	; comma
1126+ 51E1 ~            	CALL CHKCHAR
1127+ 51E1 ~            	DB ','
1128+ 51E1 ~            	; get address of the X coordinate variable
1129+ 51E1 ~            	LD IX, PTRGET
1130+ 51E1 ~            	CALL CALBAS
1131+ 51E1 ~            	LD IX,(BLIT_TMP)
1132+ 51E1 ~                LD (IX+0),E
1133+ 51E1 ~                LD (IX+1),D
1134+ 51E1 ~            	; comma
1135+ 51E1 ~            	CALL CHKCHAR
1136+ 51E1 ~            	DB ','
1137+ 51E1 ~            	; get address of the Y coordinate variable
1138+ 51E1 ~            	LD IX, PTRGET
1139+ 51E1 ~            	CALL CALBAS
1140+ 51E1 ~            	LD IX,(BLIT_TMP)
1141+ 51E1 ~                LD (IX+2),E
1142+ 51E1 ~                LD (IX+3),D
1143+ 51E1 ~            	; comma
1144+ 51E1 ~            	CALL CHKCHAR
1145+ 51E1 ~            	DB ','
1146+ 51E1 ~            	; get minimum value
1147+ 51E1 ~            	LD IX, FRMQNT
1148+ 51E1 ~            	CALL CALBAS
1149+ 51E1 ~            	LD IX,(BLIT_TMP)
1150+ 51E1 ~                LD (IX+4),E
1151+ 51E1 ~                LD (IX+5),D
1152+ 51E1 ~            	; comma
1153+ 51E1 ~            	CALL CHKCHAR
1154+ 51E1 ~            	DB ','
1155+ 51E1 ~            	; get maximum value
1156+ 51E1 ~            	LD IX, FRMQNT
1157+ 51E1 ~            	CALL CALBAS
1158+ 51E1 ~            	LD IX,(BLIT_TMP)
1159+ 51E1 ~                LD (IX+6),E
1160+ 51E1 ~                LD (IX+7),D
1161+ 51E1 ~            	; comma
1162+ 51E1 ~            	CALL CHKCHAR
1163+ 51E1 ~            	DB ','
1164+ 51E1 ~            	; get delta value
1165+ 51E1 ~            	LD IX, FRMQNT
1166+ 51E1 ~            	CALL CALBAS
1167+ 51E1 ~            	LD IX,(BLIT_TMP)
1168+ 51E1 ~                LD (IX+8),E
1169+ 51E1 ~                LD (IX+9),D
1170+ 51E1 ~            	; comma
1171+ 51E1 ~            	CALL CHKCHAR
1172+ 51E1 ~            	DB ','
1173+ 51E1 ~            	; get direction value
1174+ 51E1 ~            	LD IX, FRMQNT
1175+ 51E1 ~            	CALL CALBAS
1176+ 51E1 ~            	LD IX,(BLIT_TMP)
1177+ 51E1 ~                LD (IX+10),E
1178+ 51E1 ~            	; comma
1179+ 51E1 ~            	CALL CHKCHAR
1180+ 51E1 ~            	DB ','
1181+ 51E1 ~            	; get ticks value
1182+ 51E1 ~            	LD IX, FRMQNT
1183+ 51E1 ~            	CALL CALBAS
1184+ 51E1 ~            	LD IX,(BLIT_TMP)
1185+ 51E1 ~                LD (IX+20),E
1186+ 51E1 ~                LD (IX+21),D
1187+ 51E1 ~            	; comma
1188+ 51E1 ~            	CALL CHKCHAR
1189+ 51E1 ~            	DB ','
1190+ 51E1 ~            	; get sprite group count
1191+ 51E1 ~            	LD IX, GETBYT
1192+ 51E1 ~            	CALL CALBAS
1193+ 51E1 ~                OR A
1194+ 51E1 ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
1195+ 51E1 ~            	LD IX,(BLIT_TMP)
1196+ 51E1 ~                LD (IX+11),A
1197+ 51E1 ~            	; comma
1198+ 51E1 ~            	CALL CHKCHAR
1199+ 51E1 ~            	DB ','
1200+ 51E1 ~            	; get sprite group definition array data pointer
1201+ 51E1 ~            	LD IX,(BLIT_TMP)
1202+ 51E1 ~                LD E,(IX+11)
1203+ 51E1 ~            	LD D,3
1204+ 51E1 ~            	LD A,2
1205+ 51E1 ~            	LD B,A
1206+ 51E1 ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
1207+ 51E1 ~            	LD IX,(BLIT_TMP)
1208+ 51E1 ~            	LD (IX+12),C
1209+ 51E1 ~                LD (IX+13),B
1210+ 51E1 ~            	; comma
1211+ 51E1 ~            	CALL CHKCHAR
1212+ 51E1 ~            	DB ','
1213+ 51E1 ~            	; get sprite animation array size
1214+ 51E1 ~            	LD IX,GETBYT
1215+ 51E1 ~            	CALL CALBAS
1216+ 51E1 ~            	LD IX,(BLIT_TMP)
1217+ 51E1 ~                LD (IX+14),A
1218+ 51E1 ~                OR A
1219+ 51E1 ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
1220+ 51E1 ~            	; comma
1221+ 51E1 ~            	CALL CHKCHAR
1222+ 51E1 ~            	DB ','
1223+ 51E1 ~                ; get array pointer for negative direction
1224+ 51E1 ~            	LD IX,(BLIT_TMP)
1225+ 51E1 ~                LD D,(IX+14)
1226+ 51E1 ~                LD A,2
1227+ 51E1 ~                LD B,1
1228+ 51E1 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
1229+ 51E1 ~            	LD IX,(BLIT_TMP)
1230+ 51E1 ~                LD (IX+15),C
1231+ 51E1 ~                LD (IX+16),B
1232+ 51E1 ~            	; comma
1233+ 51E1 ~            	CALL CHKCHAR
1234+ 51E1 ~            	DB ','
1235+ 51E1 ~                ; get array pointer for positive direction
1236+ 51E1 ~            	LD IX,(BLIT_TMP)
1237+ 51E1 ~                LD D,(IX+14)
1238+ 51E1 ~                LD A,2
1239+ 51E1 ~                LD B,1
1240+ 51E1 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
1241+ 51E1 ~            	LD IX,(BLIT_TMP)
1242+ 51E1 ~                LD (IX+17),C
1243+ 51E1 ~                LD (IX+18),B
1244+ 51E1 ~            	; ending )
1245+ 51E1 ~            	CALL CHKCHAR
1246+ 51E1 ~            	DB ')'
1247+ 51E1 ~                RET
1248+ 51E1 ~            ; *******************************************************************************************************
1249+ 51E1               ENDIF
1250+ 51E1
1251+ 51E1               IF (1 == 1)
1252+ 51E1              ; *******************************************************************************************************
1253+ 51E1              ; same as AUTOSGAMDEF but for DEFUSR approach
1254+ 51E1              ; input IX=pointer to input array, real data from +2
1255+ 51E1              ; +02 = ID
1256+ 51E1              ; +04 = pointer to X variable
1257+ 51E1              ; +06 = pointer to Y variable
1258+ 51E1              ; +08 = minimum
1259+ 51E1              ; +10 = maximum
1260+ 51E1              ; +12 = delta
1261+ 51E1              ; +14 = direction
1262+ 51E1              ; +16 = ticks
1263+ 51E1              ; +18 = sprite group count
1264+ 51E1              ; +20 = sprite group array pointer
1265+ 51E1              ; +22 = item number
1266+ 51E1              ; +24 = sprite animations negative direction array pointer
1267+ 51E1              ; +26 = sprite animations positive direction array pointer
1268+ 51E1              AUTOSGAMDEF_DEFUSR:
1269+ 51E1 DD 4E 02         LD C,(IX+2)
1270+ 51E4 0C               INC C
1271+ 51E5 3A 00 4F         LD A,(AUTOSGAMNUM)
1272+ 51E8 B9               CP C
1273+ 51E9 DA 74 52         JP C,.ERR ; invalid id
1274+ 51EC 79               LD A,C
1275+ 51ED 3D               DEC A
1276+ 51EE CD 2D 4F         CALL GETnthAUTOSGAM
1277+ 51F1 E5               PUSH HL
1278+ 51F2 FD E1            POP IY
1279+ 51F4                  ; X variable
1280+ 51F4 DD 7E 04         LD A,(IX+4)
1281+ 51F7 FD 77 00         LD (IY+0),A
1282+ 51FA DD 7E 05         LD A,(IX+5)
1283+ 51FD FD 77 01         LD (IY+1),A
1284+ 5200              	; Y variable
1285+ 5200 DD 7E 06         LD A,(IX+6)
1286+ 5203 FD 77 02         LD (IY+2),A
1287+ 5206 DD 7E 07         LD A,(IX+7)
1288+ 5209 FD 77 03         LD (IY+3),A
1289+ 520C              	; get minimum value
1290+ 520C DD 7E 08         LD A,(IX+8)
1291+ 520F FD 77 04         LD (IY+4),A
1292+ 5212 DD 7E 09         LD A,(IX+9)
1293+ 5215 FD 77 05         LD (IY+5),A
1294+ 5218              	; get maximum value
1295+ 5218 DD 7E 0A         LD A,(IX+10)
1296+ 521B FD 77 06         LD (IY+6),A
1297+ 521E DD 7E 0B         LD A,(IX+11)
1298+ 5221 FD 77 07         LD (IY+7),A
1299+ 5224              	; get delta value
1300+ 5224 DD 7E 0C         LD A,(IX+12)
1301+ 5227 FD 77 08         LD (IY+8),A
1302+ 522A DD 7E 0D         LD A,(IX+13)
1303+ 522D FD 77 09         LD (IY+9),A
1304+ 5230              	; get direction value
1305+ 5230 DD 7E 0E         LD A,(IX+14)
1306+ 5233 FD 77 0A         LD (IY+10),A
1307+ 5236              	; get ticks value
1308+ 5236 DD 7E 10         LD A,(IX+16)
1309+ 5239 FD 77 14         LD (IY+20),A
1310+ 523C DD 7E 11         LD A,(IX+17)
1311+ 523F FD 77 15         LD (IY+21),A
1312+ 5242              	; get sprite group count
1313+ 5242 DD 7E 12         LD A,(IX+18)
1314+ 5245 FD 77 0B         LD (IY+11),A
1315+ 5248              	; get sprite group definition array data pointer
1316+ 5248 DD 7E 14         LD A,(IX+20)
1317+ 524B FD 77 0C         LD (IY+12),A
1318+ 524E DD 7E 15         LD A,(IX+21)
1319+ 5251 FD 77 0D         LD (IY+13),A
1320+ 5254              	; get sprite animation array size
1321+ 5254 DD 7E 16         LD A,(IX+22)
1322+ 5257 FD 77 0E         LD (IY+14),A
1323+ 525A                  ; get array pointer for negative direction
1324+ 525A DD 7E 18         LD A,(IX+24)
1325+ 525D FD 77 0F         LD (IY+15),A
1326+ 5260 DD 7E 19         LD A,(IX+25)
1327+ 5263 FD 77 10         LD (IY+16),A
1328+ 5266                  ; get array pointer for positive direction
1329+ 5266 DD 7E 1A         LD A,(IX+26)
1330+ 5269 FD 77 11         LD (IY+17),A
1331+ 526C DD 7E 1B         LD A,(IX+27)
1332+ 526F FD 77 12         LD (IY+18),A
1333+ 5272 AF               XOR A ; success
1334+ 5273 C9               RET
1335+ 5274              .ERR:
1336+ 5274 3E 01            LD A,1
1337+ 5276 C9               RET
1338+ 5277              ; *******************************************************************************************************
1339+ 5277               ENDIF
1340+ 5277
1341+ 5277               IF (0 == 1)
1342+ 5277 ~            ; *******************************************************************************************************
1343+ 5277 ~            ; function to handle CALL AUTOSGAMSTART basic extension
1344+ 5277 ~            ; AUTOSGAMSTART ( BYTE id )
1345+ 5277 ~            AUTOSGAMSTART:
1346+ 5277 ~                LD A,1
1347+ 5277 ~            .COMMON:
1348+ 5277 ~                LD (.SETVALUE+3),A
1349+ 5277 ~                ; opening (
1350+ 5277 ~            	CALL CHKCHAR
1351+ 5277 ~            	DB '('
1352+ 5277 ~            	; get sprite animation id
1353+ 5277 ~            	LD IX, GETBYT
1354+ 5277 ~            	CALL CALBAS
1355+ 5277 ~                PUSH AF
1356+ 5277 ~                INC A
1357+ 5277 ~                LD C,A
1358+ 5277 ~                LD A,(AUTOSGAMNUM)
1359+ 5277 ~                CP C
1360+ 5277 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
1361+ 5277 ~                POP AF
1362+ 5277 ~                PUSH HL
1363+ 5277 ~                CALL GETnthAUTOSGAM
1364+ 5277 ~                PUSH HL
1365+ 5277 ~                POP IX
1366+ 5277 ~                POP HL
1367+ 5277 ~                PUSH IX
1368+ 5277 ~            	; ending )
1369+ 5277 ~            	CALL CHKCHAR
1370+ 5277 ~            	DB ')'
1371+ 5277 ~
1372+ 5277 ~                ; so syntax is fine
1373+ 5277 ~                POP IX
1374+ 5277 ~            .SETVALUE:
1375+ 5277 ~                LD (IX+19),1 ; active flag
1376+ 5277 ~                ; set initial timer
1377+ 5277 ~                LD A,(IX+20)
1378+ 5277 ~                LD (IX+22),A
1379+ 5277 ~                LD A,(IX+21)
1380+ 5277 ~                LD (IX+23),A
1381+ 5277 ~                RET
1382+ 5277 ~            ; *******************************************************************************************************
1383+ 5277 ~
1384+ 5277 ~            ; *******************************************************************************************************
1385+ 5277 ~            ; function to handle CALL AUTOSGAMSTOP basic extension
1386+ 5277 ~            ; AUTOSGAMSTOP ( BYTE id )
1387+ 5277 ~            AUTOSGAMSTOP:
1388+ 5277 ~                XOR A
1389+ 5277 ~                JR AUTOSGAMSTART.COMMON
1390+ 5277 ~            ; *******************************************************************************************************
1391+ 5277               ENDIF
1392+ 5277
1393+ 5277               IF (1 == 1)
1394+ 5277              ; *******************************************************************************************************
1395+ 5277              ; function to handle CALL AUTOSGAMSTART basic extension in DEFUSR mode
1396+ 5277              ; input IX=pointer to input array, real data from +2
1397+ 5277              ; +2 = source address
1398+ 5277              AUTOSGAMSTART_DEFUSR:
1399+ 5277 3E 01            LD A,1
1400+ 5279              .COMMON:
1401+ 5279 32 91 52         LD (.SETVALUE+3),A
1402+ 527C DD 4E 02         LD C,(IX+2)
1403+ 527F 0C               INC C
1404+ 5280 3A 00 4F         LD A,(AUTOSGAMNUM)
1405+ 5283 B9               CP C
1406+ 5284 38 1A            JR C,.ERR ; invalid id
1407+ 5286 79               LD A,C
1408+ 5287 3D               DEC A
1409+ 5288 CD 2D 4F         CALL GETnthAUTOSGAM
1410+ 528B E5               PUSH HL
1411+ 528C DD E1            POP IX
1412+ 528E              .SETVALUE:
1413+ 528E DD 36 13 01      LD (IX+19),1 ; active flag
1414+ 5292                  ; set initial timer
1415+ 5292 DD 7E 14         LD A,(IX+20)
1416+ 5295 DD 77 16         LD (IX+22),A
1417+ 5298 DD 7E 15         LD A,(IX+21)
1418+ 529B DD 77 17         LD (IX+23),A
1419+ 529E AF               XOR A ; success
1420+ 529F C9               RET
1421+ 52A0              .ERR:
1422+ 52A0 3E 01            LD A,1
1423+ 52A2 C9               RET
1424+ 52A3              ; *******************************************************************************************************
1425+ 52A3
1426+ 52A3              ; *******************************************************************************************************
1427+ 52A3              ; function to handle CALL AUTOSGAMSTOP basic extension in DEFUSR mode
1428+ 52A3              ; input IX=pointer to input array, real data from +2
1429+ 52A3              ; +2 = source address
1430+ 52A3              AUTOSGAMSTOP_DEFUSR:
1431+ 52A3 AF               XOR A
1432+ 52A4 18 D3            JR AUTOSGAMSTART_DEFUSR.COMMON
1433+ 52A6              ; *******************************************************************************************************
1434+ 52A6               ENDIF
1435+ 52A6
1436+ 52A6               IF (0 == 1)
1437+ 52A6 ~            ; *******************************************************************************************************
1438+ 52A6 ~            ; function to handle CALL ANIMSTEP basic extension
1439+ 52A6 ~            ; two forms
1440+ 52A6 ~            ; ANIMSTEP ( BYTE id )
1441+ 52A6 ~            ; or
1442+ 52A6 ~            ; ANIMSTEP ( BYTE item_number,
1443+ 52A6 ~            ;            INT[] sprite_animations )
1444+ 52A6 ~            ANIMSTEP:
1445+ 52A6 ~                LD DE,ANIMSTARTSTOP_COMMON.STEP
1446+ 52A6 ~                JR ANIMSTARTSTOP_COMMON
1447+ 52A6 ~            ; *******************************************************************************************************
1448+ 52A6 ~            ; *******************************************************************************************************
1449+ 52A6 ~            ; function to handle CALL ANIMSTART basic extension
1450+ 52A6 ~            ; two forms
1451+ 52A6 ~            ; ANIMSTART ( BYTE id )
1452+ 52A6 ~            ; or
1453+ 52A6 ~            ; ANIMSTART ( BYTE item_number,
1454+ 52A6 ~            ;             INT[] sprite_animations )
1455+ 52A6 ~            ; sets active flag to 1
1456+ 52A6 ~            ANIMSTART:
1457+ 52A6 ~                LD DE,ANIMSTARTSTOP_COMMON.START
1458+ 52A6 ~                JR ANIMSTARTSTOP_COMMON
1459+ 52A6 ~            ; *******************************************************************************************************
1460+ 52A6 ~            ; *******************************************************************************************************
1461+ 52A6 ~            ; function to handle CALL ANIMSTOP basic extension
1462+ 52A6 ~            ; two forms
1463+ 52A6 ~            ; ANIMSTOP ( BYTE id )
1464+ 52A6 ~            ; or
1465+ 52A6 ~            ; ANIMSTOP ( BYTE item_number,
1466+ 52A6 ~            ;            INT[] sprite_animations )
1467+ 52A6 ~            ; sets active flag to 0
1468+ 52A6 ~            ANIMSTOP:
1469+ 52A6 ~                LD DE,ANIMSTARTSTOP_COMMON.STOP
1470+ 52A6 ~            ; *******************************************************************************************************
1471+ 52A6 ~            ANIMSTARTSTOP_COMMON:
1472+ 52A6 ~                LD (ANIMSTARTSTOP_COMMON.FN+1),DE
1473+ 52A6 ~                ; opening (
1474+ 52A6 ~            	CALL CHKCHAR
1475+ 52A6 ~            	DB '('
1476+ 52A6 ~            	; get sprite animation id or array size
1477+ 52A6 ~            	LD IX,GETBYT
1478+ 52A6 ~            	CALL CALBAS
1479+ 52A6 ~                PUSH AF
1480+ 52A6 ~                ; check if comma present
1481+ 52A6 ~                CALL GETPREVCHAR
1482+ 52A6 ~                INC HL
1483+ 52A6 ~                CP ','
1484+ 52A6 ~                JR Z,.L1
1485+ 52A6 ~                CP ')'
1486+ 52A6 ~                JP NZ,SYNTAX_ERROR
1487+ 52A6 ~                ; ok so single argument variant
1488+ 52A6 ~                POP AF
1489+ 52A6 ~                PUSH HL
1490+ 52A6 ~                DI
1491+ 52A6 ~                CALL .SETVALUE
1492+ 52A6 ~                EI
1493+ 52A6 ~                POP HL
1494+ 52A6 ~                RET
1495+ 52A6 ~            .L1:
1496+ 52A6 ~                ; get array pointer
1497+ 52A6 ~                POP DE
1498+ 52A6 ~                PUSH DE
1499+ 52A6 ~                LD A,2
1500+ 52A6 ~                LD B,1
1501+ 52A6 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
1502+ 52A6 ~                PUSH BC
1503+ 52A6 ~            	; ending )
1504+ 52A6 ~            	CALL CHKCHAR
1505+ 52A6 ~            	DB ')'
1506+ 52A6 ~                POP DE ; array pointer
1507+ 52A6 ~                POP BC ; number of items
1508+ 52A6 ~                LD A,B
1509+ 52A6 ~                OR A
1510+ 52A6 ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
1511+ 52A6 ~                PUSH HL
1512+ 52A6 ~                DI
1513+ 52A6 ~            .L2:
1514+ 52A6 ~                PUSH BC
1515+ 52A6 ~                LD A,(DE)
1516+ 52A6 ~                .2 INC DE
1517+ 52A6 ~                PUSH DE
1518+ 52A6 ~                CALL .SETVALUE
1519+ 52A6 ~                POP DE
1520+ 52A6 ~                POP BC
1521+ 52A6 ~                DJNZ .L2
1522+ 52A6 ~                EI
1523+ 52A6 ~                POP HL
1524+ 52A6 ~                RET
1525+ 52A6 ~
1526+ 52A6 ~            .SETVALUE:
1527+ 52A6 ~                LD B,A
1528+ 52A6 ~                INC A
1529+ 52A6 ~                LD C,A
1530+ 52A6 ~                LD A,(ANIMSPRNUM)
1531+ 52A6 ~                CP C
1532+ 52A6 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
1533+ 52A6 ~                LD A,B
1534+ 52A6 ~                CALL GETnthSPRANIM
1535+ 52A6 ~                PUSH HL
1536+ 52A6 ~                POP IX
1537+ 52A6 ~            .FN:
1538+ 52A6 ~                JP 0
1539+ 52A6 ~            .START:
1540+ 52A6 ~                LD (IX+6),1 ; active flag
1541+ 52A6 ~                LD (IX+3),0 ; current item
1542+ 52A6 ~                LD B,0 ; setup timer
1543+ 52A6 ~                JP SETUP_ANIM_STEP
1544+ 52A6 ~            .STOP:
1545+ 52A6 ~                LD (IX+6),0 ; active flag
1546+ 52A6 ~                RET
1547+ 52A6 ~            .STEP:
1548+ 52A6 ~                LD B,0
1549+ 52A6 ~                JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1550+ 52A6 ~            ; *******************************************************************************************************
1551+ 52A6               ENDIF
1552+ 52A6
1553+ 52A6              ; *******************************************************************************************************
1554+ 52A6              ; helper function to locate single animation and execute operation
1555+ 52A6              ; needs to have jump set to a correct function
1556+ 52A6              ; used by SGAM helper routines so always needed
1557+ 52A6              ; input A=animation item
1558+ 52A6              ANIM_SETVALUE:
1559+ 52A6 47               LD B,A
1560+ 52A7 3C               INC A
1561+ 52A8 4F               LD C,A
1562+ 52A9 3A FD 4E         LD A,(ANIMSPRNUM)
1563+ 52AC B9               CP C
1564+ 52AD D8               RET C ; out of range, so do nothing
1565+ 52AE 78               LD A,B
1566+ 52AF CD 21 4F         CALL GETnthSPRANIM
1567+ 52B2 E5               PUSH HL
1568+ 52B3 DD E1            POP IX
1569+ 52B5              .FN:
1570+ 52B5 C3 00 00         JP 0
1571+ 52B8              ; *******************************************************************************************************
1572+ 52B8
1573+ 52B8               IF (1 == 1)
1574+ 52B8              ; *******************************************************************************************************
1575+ 52B8              ; helper function to set values of multiple animations
1576+ 52B8              ; needs to have jump set to a correct function
1577+ 52B8              ; input B=number of animation item
1578+ 52B8              ; input DE=animation item array
1579+ 52B8              ANIM_LIST_SETVALUE:
1580+ 52B8 F3               DI
1581+ 52B9 C5               PUSH BC
1582+ 52BA 1A               LD A,(DE)
1583+ 52BB 13          > INC DE
1583+ 52BC 13          > INC DE
1584+ 52BD D5               PUSH DE
1585+ 52BE CD A6 52         CALL ANIM_SETVALUE
1586+ 52C1 D1               POP DE
1587+ 52C2 C1               POP BC
1588+ 52C3 10 F3            DJNZ ANIM_LIST_SETVALUE
1589+ 52C5 FB               EI
1590+ 52C6 C9               RET
1591+ 52C7              ; *******************************************************************************************************
1592+ 52C7
1593+ 52C7              ; *******************************************************************************************************
1594+ 52C7              ; function to handle single item ANIMSTEP in DEFUSR mode
1595+ 52C7              ; input IX=pointer to input array, real data from +2
1596+ 52C7              ; +2 = animation id
1597+ 52C7              ANIMSTEP_SINGLE_DEFUSR:
1598+ 52C7 21 D2 52         LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1599+ 52CA              .L1:
1600+ 52CA 22 B6 52         LD (ANIM_SETVALUE.FN+1),HL
1601+ 52CD DD 7E 02         LD A,(IX+2)
1602+ 52D0 18 D4            JR ANIM_SETVALUE
1603+ 52D2              .STEP:
1604+ 52D2 06 00            LD B,0
1605+ 52D4 C3 2C 53         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1606+ 52D7              ; *******************************************************************************************************
1607+ 52D7
1608+ 52D7              ; *******************************************************************************************************
1609+ 52D7              ; function to handle multi item ANIMSTEP in DEFUSR mode
1610+ 52D7              ; input IX=pointer to input array, real data from +2
1611+ 52D7              ; +2 = list size
1612+ 52D7              ; +4 = array pointer holding items
1613+ 52D7              ANIMSTEP_MULTI_DEFUSR:
1614+ 52D7 21 D2 52         LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1615+ 52DA              .L1:
1616+ 52DA 22 B6 52         LD (ANIM_SETVALUE.FN+1),HL
1617+ 52DD DD 46 02         LD B,(IX+2)
1618+ 52E0 DD 5E 04         LD E,(IX+4)
1619+ 52E3 DD 56 05         LD D,(IX+5)
1620+ 52E6 18 D0            JR ANIM_LIST_SETVALUE
1621+ 52E8              ; *******************************************************************************************************
1622+ 52E8
1623+ 52E8              ; *******************************************************************************************************
1624+ 52E8              ; function to handle single item ANIMSTART in DEFUSR mode
1625+ 52E8              ; input IX=pointer to input array, real data from +2
1626+ 52E8              ; +2 = animation id
1627+ 52E8              ANIMSTART_SINGLE_DEFUSR:
1628+ 52E8 21 ED 52         LD HL,ANIMSTART_SINGLE_DEFUSR.START
1629+ 52EB 18 DD            JR ANIMSTEP_SINGLE_DEFUSR.L1
1630+ 52ED              .START:
1631+ 52ED DD 36 06 01      LD (IX+6),1 ; active flag
1632+ 52F1 DD 36 03 00      LD (IX+3),0 ; current item
1633+ 52F5 06 00            LD B,0 ; setup timer
1634+ 52F7 C3 88 53         JP SETUP_ANIM_STEP
1635+ 52FA              ; *******************************************************************************************************
1636+ 52FA
1637+ 52FA              ; *******************************************************************************************************
1638+ 52FA              ; function to handle multi item ANIMSTART in DEFUSR mode
1639+ 52FA              ; input IX=pointer to input array, real data from +2
1640+ 52FA              ; +2 = list size
1641+ 52FA              ; +4 = array pointer holding items
1642+ 52FA              ANIMSTART_MULTI_DEFUSR:
1643+ 52FA 21 ED 52         LD HL,ANIMSTART_SINGLE_DEFUSR.START
1644+ 52FD 18 DB            JR ANIMSTEP_MULTI_DEFUSR.L1
1645+ 52FF              ; *******************************************************************************************************
1646+ 52FF
1647+ 52FF              ; *******************************************************************************************************
1648+ 52FF              ; function to handle single item ANIMSTOP in DEFUSR mode
1649+ 52FF              ; input IX=pointer to input array, real data from +2
1650+ 52FF              ; +2 = animation id
1651+ 52FF              ANIMSTOP_SINGLE_DEFUSR:
1652+ 52FF 21 04 53         LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1653+ 5302 18 C6            JR ANIMSTEP_SINGLE_DEFUSR.L1
1654+ 5304              .STOP:
1655+ 5304 DD 36 06 00      LD (IX+6),0 ; active flag
1656+ 5308 C9               RET
1657+ 5309              ; *******************************************************************************************************
1658+ 5309
1659+ 5309              ; *******************************************************************************************************
1660+ 5309              ; function to handle multi item ANIMSTOP in DEFUSR mode
1661+ 5309              ; input IX=pointer to input array, real data from +2
1662+ 5309              ; +2 = list size
1663+ 5309              ; +4 = array pointer holding items
1664+ 5309              ANIMSTOP_MULTI_DEFUSR:
1665+ 5309 21 04 53         LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1666+ 530C 18 CC            JR ANIMSTEP_MULTI_DEFUSR.L1
1667+ 530E              ; *******************************************************************************************************
1668+ 530E               ENDIF
1669+ 530E
1670+ 530E              ; *******************************************************************************************************
1671+ 530E              ; function processes animations during vblank period
1672+ 530E              PROCESS_ANIMATIONS:
1673+ 530E 3A FD 4E         LD A,(ANIMSPRNUM)
1674+ 5311 B7               OR A
1675+ 5312 C8               RET Z; no animations defined
1676+ 5313 47               LD B,A
1677+ 5314 DD 2A FE 4E      LD IX,(ANIMSPRPTR)
1678+ 5318              .L1:
1679+ 5318 C5               PUSH BC
1680+ 5319 06 00            LD B,0 ; normal mode, change on timer expiry only
1681+ 531B CD 27 53         CALL PROCESS_SINGLE_ANIMATION
1682+ 531E 11 08 00         LD DE,8
1683+ 5321 DD 19            ADD IX,DE
1684+ 5323 C1               POP BC
1685+ 5324 10 F2            DJNZ .L1
1686+ 5326 C9               RET
1687+ 5327              ; *******************************************************************************************************
1688+ 5327
1689+ 5327              ; *******************************************************************************************************
1690+ 5327              ; processes single sprite animation
1691+ 5327              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
1692+ 5327              ; on timer expiry goes to next animation item
1693+ 5327              ; input IX=sprite animation pointer
1694+ 5327              ; input B=1 force mode, activate animation action regardless of expired timer
1695+ 5327              PROCESS_SINGLE_ANIMATION:
1696+ 5327 DD 7E 06         LD A,(IX+6); active
1697+ 532A B7               OR A
1698+ 532B C8               RET Z ; inactive animation
1699+ 532C              .INACTIVE_TOO:
1700+ 532C DD 6E 01         LD L,(IX+1)
1701+ 532F DD 66 02         LD H,(IX+2) ; HL=end time
1702+ 5332 2B               DEC HL
1703+ 5333 DD 75 01         LD (IX+1),L
1704+ 5336 DD 74 02         LD (IX+2),H
1705+ 5339 7D               LD A,L
1706+ 533A B4               OR H
1707+ 533B 28 06            JR Z,.STEP
1708+ 533D 05               DEC B
1709+ 533E 04               INC B
1710+ 533F C8               RET Z ; not forced mode, return
1711+ 5340 C3 88 53         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
1712+ 5343              .STEP:
1713+ 5343 06 00            LD B,0; setup timer
1714+ 5345 DD 34 03         INC (IX+3) ; current animation item
1715+ 5348 C3 88 53         JP SETUP_ANIM_STEP
1716+ 534B              ; *******************************************************************************************************
1717+ 534B
1718+ 534B              ; *******************************************************************************************************
1719+ 534B              ; function will setup sprite animation after current item change
1720+ 534B              ; input A=current animation definition
1721+ 534B              ; input IX=pointer to sprite animation
1722+ 534B              ; input B=1 skip timer setup
1723+ 534B              ; output IY=pointer to animation item
1724+ 534B              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
1725+ 534B              ; basically sets new end time for current animation
1726+ 534B              INIT_CURRENT_ANIMATION:
1727+ 534B CD 15 4F         CALL GETnthANIMDEF
1728+ 534E DD 7E 03         LD A,(IX+3) ; current animation item
1729+ 5351 BE               CP (HL) ; number of animation items in the animation definition
1730+ 5352 38 0A            JR C,.L3 ; last item not reached
1731+ 5354                  ; last item reached
1732+ 5354 DD 7E 05         LD A,(IX+5) ; cyclic flag
1733+ 5357 B7               OR A
1734+ 5358 28 2C            JR Z,.ERROR ; non-cyclic animation
1735+ 535A                  ; cyclic animation, restart
1736+ 535A DD 36 03 00      LD (IX+3),0; current item
1737+ 535E              .L3:
1738+ 535E                  ; HL = animation definition
1739+ 535E 23               INC HL ; skip animation definition size field
1740+ 535F 16 00            LD D,0
1741+ 5361 DD 5E 03         LD E,(IX+3); current item
1742+ 5364 19               ADD HL,DE
1743+ 5365 4E               LD C,(HL) ; current animation item
1744+ 5366 0C               INC C
1745+ 5367 3A F7 4E         LD A,(ANIMITEMNUM)
1746+ 536A B9               CP C
1747+ 536B 38 19            JR C,.ERROR ; invalid animation item, stop animation
1748+ 536D 0D               DEC C
1749+ 536E 79               LD A,C
1750+ 536F CD 0C 4F         CALL GETnthANIMITEM
1751+ 5372 E5               PUSH HL
1752+ 5373 FD E1            POP IY ; IY=animation item
1753+ 5375 05               DEC B
1754+ 5376 28 0C            JR Z,.EXIT
1755+ 5378 FD 5E 01         LD E,(IY+1)
1756+ 537B FD 56 02         LD D,(IY+2) ; duration
1757+ 537E DD 73 01         LD (IX+1),E
1758+ 5381 DD 72 02         LD (IX+2),D
1759+ 5384              .EXIT:
1760+ 5384 AF               XOR A
1761+ 5385 C9               RET
1762+ 5386              .ERROR:
1763+ 5386 37               SCF
1764+ 5387 C9               RET
1765+ 5388              ; *******************************************************************************************************
1766+ 5388
1767+ 5388              ; *******************************************************************************************************
1768+ 5388              ; function will display currect item and set up expiry time
1769+ 5388              ; it will also stop the animation if expired
1770+ 5388              ; sets sprite update flag if any changes in sprite data made
1771+ 5388              ; input IX=current sprite animation
1772+ 5388              ; input B=1 skip timer setup
1773+ 5388              SETUP_ANIM_STEP:
1774+ 5388 DD 4E 04         LD C,(IX+4) ; animation definition ID
1775+ 538B 0C               INC C
1776+ 538C 3A FA 4E         LD A,(ANIMDEFNUM)
1777+ 538F B9               CP C
1778+ 5390 30 05            JR NC,.L2
1779+ 5392                  ; given animation item is outside of bounds, deactivate animation
1780+ 5392              .STOPANIM:
1781+ 5392 DD 36 06 00      LD (IX+6),0
1782+ 5396 C9               RET
1783+ 5397              .L2:
1784+ 5397 0D               DEC C
1785+ 5398 79               LD A,C
1786+ 5399 CD 4B 53         CALL INIT_CURRENT_ANIMATION
1787+ 539C 38 F4            JR C, .STOPANIM
1788+ 539E FD 7E 00         LD A,(IY) ; type of animation item
1789+ 53A1 B7               OR A
1790+ 53A2 28 44            JR Z,.L4 ; change pattern and/or color
1791+ 53A4              .PAT:
1792+ 53A4                  ; change pattern definition
1793+ 53A4                  ; check if sprite or character
1794+ 53A4 DD 7E 07         LD A,(IX+7)
1795+ 53A7 B7               OR A
1796+ 53A8 20 58            JR NZ,.CHAR
1797+ 53AA DD 7E 00         LD A,(IX) ; sprite number
1798+ 53AD CD 90 4D         CALL GETnthSPRATTR
1799+ 53B0 23          > INC HL ; skip y and x
1799+ 53B1 23          > INC HL
1799+ 53B2 23          > INC HL
1799+ 53B3 23          > INC HL
1800+ 53B4 7E               LD A,(HL); current pattern
1801+ 53B5 26 00            LD H,0
1802+ 53B7 6F               LD L,A
1803+ 53B8 3A E0 F3         LD A,(REG1SAV)
1804+ 53BB E6 02            AND 2
1805+ 53BD 20 07            JR NZ,.L6
1806+ 53BF                  ; 8x8 sprite
1807+ 53BF CD BF 5F         CALL HLx8
1808+ 53C2 06 08            LD B,8
1809+ 53C4 18 05            JR .L5
1810+ 53C6              .L6:
1811+ 53C6 CD BD 5F         CALL HLx32
1812+ 53C9 06 20            LD B,32
1813+ 53CB              .L5:
1814+ 53CB 3A AF FC         LD A,(SCRMOD)
1815+ 53CE 3D               DEC A
1816+ 53CF 20 06            JR NZ,.L10
1817+ 53D1 ED 5B C5 F3      LD DE,(T32PAT)
1818+ 53D5 18 04            JR .L7
1819+ 53D7              .L10:
1820+ 53D7 ED 5B CF F3      LD DE,(GRPPAT)
1821+ 53DB              .L7:
1822+ 53DB 19               ADD HL,DE
1823+ 53DC CD A0 5F         CALL SETWRT_LOCAL_WRITE
1824+ 53DF FD 6E 03         LD L,(IY+3)
1825+ 53E2 FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
1826+ 53E5 C3 B5 5F         JP BBYTECOPY
1827+ 53E8              .L4:
1828+ 53E8                  ; change pattern and color in sprite attributes table
1829+ 53E8 DD 7E 00         LD A,(IX) ; sprite number
1830+ 53EB CD 90 4D         CALL GETnthSPRATTR
1831+ 53EE 23          > INC HL ; skip y and x
1831+ 53EF 23          > INC HL
1831+ 53F0 23          > INC HL
1831+ 53F1 23          > INC HL
1832+ 53F2 FD 7E 03         LD A,(IY+3) ; new pattern
1833+ 53F5 77               LD (HL),A
1834+ 53F6 23          > INC HL
1834+ 53F7 23          > INC HL
1835+ 53F8 FD 7E 04         LD A,(IY+4) ; new color
1836+ 53FB 77               LD (HL),A
1837+ 53FC 2A 87 4D         LD HL,(SPRATR_UPDATE_FLAG)
1838+ 53FF 36 01            LD (HL),1
1839+ 5401 C9               RET
1840+ 5402              .CHAR:
1841+ 5402 DD 6E 00         LD L,(IX)
1842+ 5405 3D               DEC A
1843+ 5406 67               LD H,A
1844+ 5407 CD BF 5F         CALL HLx8
1845+ 540A 3A AF FC         LD A,(SCRMOD)
1846+ 540D 3D               DEC A
1847+ 540E 20 06            JR NZ,.L8
1848+ 5410 ED 5B C1 F3      LD DE,(T32CGP)
1849+ 5414 18 04            JR .L9
1850+ 5416              .L8:
1851+ 5416 ED 5B CB F3      LD DE,(GRPCGP)
1852+ 541A              .L9:
1853+ 541A 06 08            LD B,8
1854+ 541C 18 BD            JR .L7
1855+ 541E              ; *******************************************************************************************************
1856+ 541E
# file closed: asm\ANIMATION.asm
 139  541E               INCLUDE "SGAM.asm"
# file opened: asm\SGAM.asm
   1+ 541E              ; Sprite Group Animate and Move
   2+ 541E
   3+ 541E              ; *******************************************************************************************************
   4+ 541E              ; shared function to process a list of animations
   5+ 541E              ; input B=list size
   6+ 541E              ; input DE=list pointer
   7+ 541E              SGAM_PROCESS_ANIM_LIST:
   8+ 541E 21 31 54         LD HL,.STEP
   9+ 5421 22 B6 52         LD (ANIM_SETVALUE.FN+1),HL
  10+ 5424              .L1:
  11+ 5424 C5               PUSH BC
  12+ 5425 1A               LD A,(DE)
  13+ 5426 13          > INC DE
  13+ 5427 13          > INC DE
  14+ 5428 D5               PUSH DE
  15+ 5429 CD A6 52         CALL ANIM_SETVALUE
  16+ 542C D1               POP DE
  17+ 542D C1               POP BC
  18+ 542E 10 F4            DJNZ .L1
  19+ 5430 C9           	RET
  20+ 5431              .STEP:
  21+ 5431 06 01            LD B,1
  22+ 5433 C3 2C 53         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
  23+ 5436              ; *******************************************************************************************************
  24+ 5436
  25+ 5436               IF (0 == 1)
  26+ 5436 ~            ; *******************************************************************************************************
  27+ 5436 ~            ; function to handle CALL SGAM basic extension
  28+ 5436 ~            ; sets position of a group of sprites as described in SPRGRPMOV
  29+ 5436 ~            ; and manually animate a list of animations
  30+ 5436 ~            ; _SGAM ( INT x,
  31+ 5436 ~            ;	      INT y,
  32+ 5436 ~            ;		  BYTE count,
  33+ 5436 ~            ;		  INT[2][count] data_ptr,
  34+ 5436 ~            ;         BYTE item_number,
  35+ 5436 ~            ;         INT[] sprite_animations )
  36+ 5436 ~            ; will put ram in page 0 also, page 1 is already there
  37+ 5436 ~            SGAM:
  38+ 5436 ~            	LD A, (SPRATR_INIT_STATUS)
  39+ 5436 ~            	OR A
  40+ 5436 ~            	JP Z,ILLEGAL_FUNCTION
  41+ 5436 ~            	; opening (
  42+ 5436 ~            	CALL CHKCHAR
  43+ 5436 ~            	DB '('
  44+ 5436 ~            	; get x
  45+ 5436 ~            	LD IX, FRMQNT
  46+ 5436 ~            	CALL CALBAS
  47+ 5436 ~            	LD (TMP_STRUCT),DE
  48+ 5436 ~            	; comma
  49+ 5436 ~            	CALL CHKCHAR
  50+ 5436 ~            	DB ','
  51+ 5436 ~            	; get y
  52+ 5436 ~            	LD IX, FRMQNT
  53+ 5436 ~            	CALL CALBAS
  54+ 5436 ~            	LD (TMP_STRUCT+2),DE
  55+ 5436 ~            	; comma
  56+ 5436 ~            	CALL CHKCHAR
  57+ 5436 ~            	DB ','
  58+ 5436 ~            	; get count
  59+ 5436 ~            	LD IX, GETBYT
  60+ 5436 ~            	CALL CALBAS
  61+ 5436 ~                OR A
  62+ 5436 ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
  63+ 5436 ~            	LD (TMP_STRUCT+4),A
  64+ 5436 ~            	; comma
  65+ 5436 ~            	CALL CHKCHAR
  66+ 5436 ~            	DB ','
  67+ 5436 ~            	; get sprite group definition array data pointer
  68+ 5436 ~                LD A,(TMP_STRUCT+4)
  69+ 5436 ~            	LD E,A
  70+ 5436 ~            	LD D,3
  71+ 5436 ~            	LD A,2
  72+ 5436 ~            	LD B,A
  73+ 5436 ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
  74+ 5436 ~            	LD (TMP_STRUCT+5),BC
  75+ 5436 ~            	; comma
  76+ 5436 ~            	CALL CHKCHAR
  77+ 5436 ~            	DB ','
  78+ 5436 ~            	; get sprite animation array size
  79+ 5436 ~            	LD IX,GETBYT
  80+ 5436 ~            	CALL CALBAS
  81+ 5436 ~                LD (TMP_STRUCT+7),A
  82+ 5436 ~                OR A
  83+ 5436 ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
  84+ 5436 ~            	; comma
  85+ 5436 ~            	CALL CHKCHAR
  86+ 5436 ~            	DB ','
  87+ 5436 ~                ; get array pointer
  88+ 5436 ~                LD A,(TMP_STRUCT+7)
  89+ 5436 ~                LD D,A
  90+ 5436 ~                LD A,2
  91+ 5436 ~                LD B,1
  92+ 5436 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
  93+ 5436 ~                LD (TMP_STRUCT+8),BC
  94+ 5436 ~            	; ending )
  95+ 5436 ~            	CALL CHKCHAR
  96+ 5436 ~            	DB ')'
  97+ 5436 ~            .ENTRY:
  98+ 5436 ~                PUSH HL
  99+ 5436 ~
 100+ 5436 ~            	; enable page 0
 101+ 5436 ~            	LD IY, .RET
 102+ 5436 ~            	JP ENABLE_PAGE0
 103+ 5436 ~            .RET:
 104+ 5436 ~                EXX
 105+ 5436 ~                LD DE,(TMP_STRUCT) ; initial x
 106+ 5436 ~                LD BC,(TMP_STRUCT+2) ; initial y
 107+ 5436 ~                EXX
 108+ 5436 ~                LD HL,(TMP_STRUCT+5) ; pointer to data
 109+ 5436 ~                LD A,(TMP_STRUCT+4) ; number of entries
 110+ 5436 ~                LD B,A
 111+ 5436 ~                CALL SPR_UPDATE_LOC
 112+ 5436 ~
 113+ 5436 ~                LD A,(TMP_STRUCT+7) ; anim number
 114+ 5436 ~                LD B,A
 115+ 5436 ~                LD DE,(TMP_STRUCT+8) ; anim list
 116+ 5436 ~            	CALL SGAM_PROCESS_ANIM_LIST
 117+ 5436 ~                POP DE
 118+ 5436 ~                POP BC
 119+ 5436 ~                CALL RESTORE_PAGE_INFO
 120+ 5436 ~            	XOR A
 121+ 5436 ~            	POP HL
 122+ 5436 ~            	RET
 123+ 5436 ~            ; *******************************************************************************************************
 124+ 5436               ENDIF
 125+ 5436
 126+ 5436               IF (1 == 1)
 127+ 5436              ; *******************************************************************************************************
 128+ 5436              ; same as SGAM but for DEFUSR approach
 129+ 5436              ; input IX=pointer to input array, real data from +2
 130+ 5436              ; +02 = X
 131+ 5436              ; +04 = Y
 132+ 5436              ; +06 = count
 133+ 5436              ; +08 = data pointer
 134+ 5436              ; +10 = anim number
 135+ 5436              ; +12 = sprite animations
 136+ 5436              SGAM_DEFUSR:
 137+ 5436              	; enable page 0
 138+ 5436 FD 21 3D 54  	LD IY, .RET
 139+ 543A C3 83 60     	JP ENABLE_PAGE0
 140+ 543D              .RET:
 141+ 543D FB           	EI
 142+ 543E D9               EXX
 143+ 543F DD 5E 02     	LD E,(IX+2)
 144+ 5442 DD 56 03     	LD D,(IX+3) ; initial x
 145+ 5445 DD 4E 04     	LD C,(IX+4)
 146+ 5448 DD 46 05     	LD B,(IX+5) ; initial y
 147+ 544B D9               EXX
 148+ 544C DD 6E 08     	LD L,(IX+8)
 149+ 544F DD 66 09     	LD H,(IX+9) ; pointer to data
 150+ 5452 DD 46 06         LD B,(IX+6) ; count
 151+ 5455 DD E5        	PUSH IX
 152+ 5457 CD C2 4E         CALL SPR_UPDATE_LOC
 153+ 545A DD E1        	POP IX
 154+ 545C DD 46 0A         LD B,(IX+10) ; anim number
 155+ 545F DD 5E 0C     	LD E,(IX+12)
 156+ 5462 DD 56 0D     	LD D,(IX+13)
 157+ 5465 CD 1E 54     	CALL SGAM_PROCESS_ANIM_LIST
 158+ 5468 C3 99 5F     	JP COMMON_EXIT_CODE
 159+ 546B              ; *******************************************************************************************************
 160+ 546B               ENDIF
 161+ 546B
 162+ 546B              ; *******************************************************************************************************
 163+ 546B              ; handles automatic move and animate sprite groups during interrupt
 164+ 546B              PROCESS_AUTOSGAMS:
 165+ 546B 3A 00 4F     	LD A,(AUTOSGAMNUM)
 166+ 546E B7           	OR A
 167+ 546F C8           	RET Z
 168+ 5470 47           	LD B,A
 169+ 5471 DD 2A 01 4F  	LD IX,(AUTOSGAMPTR)
 170+ 5475              .L1:
 171+ 5475 C5           	PUSH BC
 172+ 5476 DD 7E 13     	LD A,(IX+19) ; active flag
 173+ 5479 B7           	OR A
 174+ 547A 28 28        	JR Z,.LOOPEND
 175+ 547C              	; active, check timer
 176+ 547C DD 6E 16     	LD L,(IX+22)
 177+ 547F DD 66 17     	LD H,(IX+23) ; timer
 178+ 5482 2B           	DEC HL
 179+ 5483 7C           	LD A,H
 180+ 5484 B5           	OR L
 181+ 5485 28 08        	JR Z,.L2
 182+ 5487              	; not expired
 183+ 5487 DD 75 16     	LD (IX+22),L
 184+ 548A DD 74 17     	LD (IX+23),H
 185+ 548D 18 15        	JR .LOOPEND
 186+ 548F              .L2:
 187+ 548F              	; expired, process
 188+ 548F
 189+ 548F                  ; set initial timer
 190+ 548F DD 7E 14         LD A,(IX+20)
 191+ 5492 DD 77 16         LD (IX+22),A
 192+ 5495 DD 7E 15         LD A,(IX+21)
 193+ 5498 DD 77 17         LD (IX+23),A
 194+ 549B
 195+ 549B CD AD 54     	CALL .MOVE
 196+ 549E CD 18 55     	CALL .UPDATELOC
 197+ 54A1 CD 3D 55     	CALL .PROCESS_ANIM_LIST
 198+ 54A4
 199+ 54A4              .LOOPEND:
 200+ 54A4 11 18 00     	LD DE,24
 201+ 54A7 DD 19        	ADD IX,DE
 202+ 54A9 C1           	POP BC
 203+ 54AA 10 C9        	DJNZ .L1
 204+ 54AC C9           	RET
 205+ 54AD
 206+ 54AD              .MOVE:
 207+ 54AD              	; process movement
 208+ 54AD DD 7E 0A     	LD A,(IX+10) ; direction
 209+ 54B0 B7           	OR A
 210+ 54B1 28 08        	JR Z, .MOVE_L1
 211+ 54B3              	; vertical
 212+ 54B3 DD 6E 02     	LD L,(IX+2)
 213+ 54B6 DD 66 03     	LD H,(IX+3) ; vertical variable pointer
 214+ 54B9 18 06        	JR .MOVE_L2
 215+ 54BB              .MOVE_L1:
 216+ 54BB              	; horizontal
 217+ 54BB DD 6E 00     	LD L,(IX+0)
 218+ 54BE DD 66 01     	LD H,(IX+1) ; horizontal variable pointer
 219+ 54C1              .MOVE_L2:
 220+ 54C1 E5           	PUSH HL
 221+ 54C2 FD E1        	POP IY
 222+ 54C4 FD 6E 00     	LD L,(IY+0)
 223+ 54C7 FD 66 01     	LD H,(IY+1)
 224+ 54CA DD 5E 08     	LD E,(IX+8)
 225+ 54CD DD 56 09     	LD D,(IX+9) ; delta value
 226+ 54D0 19           	ADD HL,DE
 227+ 54D1 E5           	PUSH HL
 228+ 54D2 DD 5E 04     	LD E,(IX+4)
 229+ 54D5 DD 56 05     	LD D,(IX+5) ; minimum value
 230+ 54D8 A7           	AND A
 231+ 54D9 ED 52        	SBC HL,DE
 232+ 54DB FA F5 54     	JP M,.MOVE_L3 ; below minimum
 233+ 54DE E1           	POP HL
 234+ 54DF E5           	PUSH HL
 235+ 54E0 DD 5E 06     	LD E,(IX+6)
 236+ 54E3 DD 56 07     	LD D,(IX+7) ; maximum value
 237+ 54E6 EB           	EX DE,HL
 238+ 54E7 A7           	AND A
 239+ 54E8 ED 52        	SBC HL,DE
 240+ 54EA FA FD 54     	JP M,.MOVE_L4 ; above maximum
 241+ 54ED E1           	POP HL
 242+ 54EE              	; within bounds
 243+ 54EE              .MOVE_L5:
 244+ 54EE FD 75 00     	LD (IY+0),L
 245+ 54F1 FD 74 01     	LD (IY+1),H
 246+ 54F4 C9           	RET
 247+ 54F5              .MOVE_L3:
 248+ 54F5 E1           	POP HL
 249+ 54F6 CD 09 55     	CALL .INVERSE_DELTA
 250+ 54F9 6B           	LD L,E
 251+ 54FA 62           	LD H,D
 252+ 54FB 18 F1        	JR .MOVE_L5
 253+ 54FD              .MOVE_L4:
 254+ 54FD E1           	POP HL
 255+ 54FE CD 09 55     	CALL .INVERSE_DELTA
 256+ 5501 DD 6E 06     	LD L,(IX+6)
 257+ 5504 DD 66 07     	LD H,(IX+7) ; maximum
 258+ 5507 18 E5        	JR .MOVE_L5
 259+ 5509              .INVERSE_DELTA:
 260+ 5509 AF           	XOR A
 261+ 550A DD 96 08     	SUB (IX+8)
 262+ 550D DD 77 08     	LD (IX+8),A
 263+ 5510 9F           	SBC A,A
 264+ 5511 DD 96 09     	SUB (IX+9)
 265+ 5514 DD 77 09     	LD (IX+9),A
 266+ 5517 C9           	RET
 267+ 5518
 268+ 5518              .UPDATELOC:
 269+ 5518 DD E5        	PUSH IX
 270+ 551A D9           	EXX
 271+ 551B DD 6E 00     	LD L,(IX+0)
 272+ 551E DD 66 01     	LD H,(IX+1)
 273+ 5521 5E           	LD E,(HL)
 274+ 5522 23           	INC HL
 275+ 5523 56           	LD D,(HL)
 276+ 5524 DD 6E 02     	LD L,(IX+2)
 277+ 5527 DD 66 03     	LD H,(IX+3)
 278+ 552A 4E           	LD C,(HL)
 279+ 552B 23           	INC HL
 280+ 552C 46           	LD B,(HL)
 281+ 552D D9           	EXX
 282+ 552E DD 6E 0C     	LD L,(IX+12)
 283+ 5531 DD 66 0D     	LD H,(IX+13) ; pointer to sprite group data
 284+ 5534 DD 46 0B     	LD B,(IX+11) ; sprite group size
 285+ 5537 CD C2 4E     	CALL SPR_UPDATE_LOC
 286+ 553A DD E1        	POP IX
 287+ 553C C9           	RET
 288+ 553D
 289+ 553D              .PROCESS_ANIM_LIST:
 290+ 553D DD E5        	PUSH IX
 291+ 553F DD 46 0E         LD B,(IX+14) ; anim list size
 292+ 5542 DD CB 09 7E  	BIT 7,(IX+9)
 293+ 5546 28 08        	JR Z,.PROCESS_ANIM_LIST_L1
 294+ 5548              	; negative direction
 295+ 5548 DD 5E 0F     	LD E,(IX+15)
 296+ 554B DD 56 10     	LD D,(IX+16)
 297+ 554E 18 06        	JR .PROCESS_ANIM_LIST_L2
 298+ 5550              .PROCESS_ANIM_LIST_L1:
 299+ 5550              	; positive direction
 300+ 5550 DD 5E 11     	LD E,(IX+17)
 301+ 5553 DD 56 12     	LD D,(IX+18)
 302+ 5556              .PROCESS_ANIM_LIST_L2:
 303+ 5556 CD 1E 54     	CALL SGAM_PROCESS_ANIM_LIST
 304+ 5559 DD E1        	POP IX
 305+ 555B C9           	RET
 306+ 555C              ; *******************************************************************************************************
 307+ 555C
# file closed: asm\SGAM.asm
 140  555C               ENDIF
 141  555C
 142  555C               IF (RAM_CMDS == 1)
 143  555C               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
   1+ 555C               IF (0 == 1)
   2+ 555C ~            ; *******************************************************************************************************
   3+ 555C ~            ; function to handle CALL MEMCPY basic extension
   4+ 555C ~            ; _MEMCPY ( INT source,
   5+ 555C ~            ;			INT destination,
   6+ 555C ~            ;			INT count,
   7+ 555C ~            ; will put ram in page 0 also, page 1 is already there
   8+ 555C ~            MEMCPY:
   9+ 555C ~            	; opening (
  10+ 555C ~            	CALL CHKCHAR
  11+ 555C ~            	DB '('
  12+ 555C ~            	; get source address
  13+ 555C ~            	LD IX, FRMQNT
  14+ 555C ~            	CALL CALBAS
  15+ 555C ~            	PUSH DE
  16+ 555C ~            	; comma
  17+ 555C ~            	CALL CHKCHAR
  18+ 555C ~            	DB ','
  19+ 555C ~            	; get destination address
  20+ 555C ~            	LD IX, FRMQNT
  21+ 555C ~            	CALL CALBAS
  22+ 555C ~            	PUSH DE
  23+ 555C ~            	; comma
  24+ 555C ~            	CALL CHKCHAR
  25+ 555C ~            	DB ','
  26+ 555C ~            	; get length
  27+ 555C ~            	LD IX, FRMQNT
  28+ 555C ~            	CALL CALBAS
  29+ 555C ~            	PUSH DE
  30+ 555C ~            	; ending )
  31+ 555C ~            	CALL CHKCHAR
  32+ 555C ~            	DB ')'
  33+ 555C ~
  34+ 555C ~            	; save position
  35+ 555C ~            	PUSH HL
  36+ 555C ~            	POP IX
  37+ 555C ~
  38+ 555C ~            	POP BC ; count
  39+ 555C ~            	POP DE ; destination
  40+ 555C ~            	POP HL ; source
  41+ 555C ~            	EXX
  42+ 555C ~            	; enable page 0
  43+ 555C ~            	LD IY, .RET
  44+ 555C ~            	JP ENABLE_PAGE0
  45+ 555C ~            .RET:
  46+ 555C ~            	EI
  47+ 555C ~            	EXX
  48+ 555C ~            	LDIR
  49+ 555C ~            	JP COMMON_EXIT_CODE_IX
  50+ 555C ~            ; *******************************************************************************************************
  51+ 555C               ENDIF
  52+ 555C
  53+ 555C               IF (1 == 1)
  54+ 555C              ; *******************************************************************************************************
  55+ 555C              ; same as MEMCPY but for DEFUSR approach
  56+ 555C              ; input IX=pointer to input array, real data from +2
  57+ 555C              ; +2 = source address
  58+ 555C              ; +4 = destination address
  59+ 555C              ; +6 = lenght
  60+ 555C              MEMCPY_DEFUSR:
  61+ 555C              	; enable page 0
  62+ 555C FD 21 63 55  	LD IY, .RET
  63+ 5560 C3 83 60     	JP ENABLE_PAGE0
  64+ 5563              .RET:
  65+ 5563 FB           	EI
  66+ 5564 DD 6E 02     	LD L,(IX+2)
  67+ 5567 DD 66 03     	LD H,(IX+3)
  68+ 556A DD 5E 04     	LD E,(IX+4)
  69+ 556D DD 56 05     	LD D,(IX+5)
  70+ 5570 DD 4E 06     	LD C,(IX+6)
  71+ 5573 DD 46 07     	LD B,(IX+7)
  72+ 5576 ED B0        	LDIR
  73+ 5578 C3 99 5F         JP COMMON_EXIT_CODE
  74+ 557B              ; *******************************************************************************************************
  75+ 557B               ENDIF
  76+ 557B
  77+ 557B               IF (0 == 1)
  78+ 557B ~            ; *******************************************************************************************************
  79+ 557B ~            ; function to handle CALL FILRAM basic extension
  80+ 557B ~            ; FILRAM ( INT start address,
  81+ 557B ~            ;		   INT count,
  82+ 557B ~            ;		   BYTE value )
  83+ 557B ~            ; will put ram in page 0 also, page 1 is already there
  84+ 557B ~            FILRAM:
  85+ 557B ~            	; opening (
  86+ 557B ~            	CALL CHKCHAR
  87+ 557B ~            	DB '('
  88+ 557B ~            	; get start address
  89+ 557B ~            	LD IX, FRMQNT
  90+ 557B ~            	CALL CALBAS
  91+ 557B ~            	PUSH DE
  92+ 557B ~            	; comma
  93+ 557B ~            	CALL CHKCHAR
  94+ 557B ~            	DB ','
  95+ 557B ~            	; get count
  96+ 557B ~            	LD IX, FRMQNT
  97+ 557B ~            	CALL CALBAS
  98+ 557B ~            	PUSH DE
  99+ 557B ~            	; comma
 100+ 557B ~            	CALL CHKCHAR
 101+ 557B ~            	DB ','
 102+ 557B ~            	; get value
 103+ 557B ~            	LD IX, GETBYT
 104+ 557B ~            	CALL CALBAS
 105+ 557B ~            	PUSH AF
 106+ 557B ~            	; ending )
 107+ 557B ~            	CALL CHKCHAR
 108+ 557B ~            	DB ')'
 109+ 557B ~
 110+ 557B ~            	; save position
 111+ 557B ~            	PUSH HL
 112+ 557B ~            	POP IX
 113+ 557B ~
 114+ 557B ~            	POP DE ; actually AF
 115+ 557B ~            	POP BC ; count
 116+ 557B ~            	POP HL ; start address
 117+ 557B ~            	EXX
 118+ 557B ~            	; enable page 0
 119+ 557B ~            	LD IY, .RET
 120+ 557B ~            	JP ENABLE_PAGE0
 121+ 557B ~            .RET:
 122+ 557B ~            	EI
 123+ 557B ~            	EXX
 124+ 557B ~            	CALL FILVRM_FILLVALUE
 125+ 557B ~            	JP COMMON_EXIT_CODE_IX
 126+ 557B ~            ; *******************************************************************************************************
 127+ 557B               ENDIF
 128+ 557B
 129+ 557B               IF (1 == 1)
 130+ 557B              ; *******************************************************************************************************
 131+ 557B              ; same as FILVRM but for DEFUSR approach
 132+ 557B              ; input IX=pointer to input array, real data from +2
 133+ 557B              ; +2 = start address
 134+ 557B              ; +4 = count
 135+ 557B              ; +6 = value
 136+ 557B              FILRAM_DEFUSR:
 137+ 557B              	; enable page 0
 138+ 557B FD 21 82 55  	LD IY, .RET
 139+ 557F C3 83 60     	JP ENABLE_PAGE0
 140+ 5582              .RET:
 141+ 5582 FB           	EI
 142+ 5583 DD 6E 02     	LD L,(IX+2)
 143+ 5586 DD 66 03     	LD H,(IX+3)
 144+ 5589 DD 4E 04     	LD C,(IX+4)
 145+ 558C DD 46 05     	LD B,(IX+5)
 146+ 558F DD 56 06     	LD D,(IX+6)
 147+ 5592 CD 98 55     	CALL FILVRM_FILLVALUE
 148+ 5595 C3 99 5F         JP COMMON_EXIT_CODE
 149+ 5598              ; *******************************************************************************************************
 150+ 5598               ENDIF
 151+ 5598
 152+ 5598              ; *******************************************************************************************************
 153+ 5598              ; common function to fill RAM
 154+ 5598              FILVRM_FILLVALUE:
 155+ 5598 78           	LD A,B
 156+ 5599 B1           	OR C
 157+ 559A C8           	RET Z ; zero size
 158+ 559B 72               LD (HL), D
 159+ 559C 54               LD D, H
 160+ 559D 5D               LD E, L
 161+ 559E 13               INC DE
 162+ 559F 0B               DEC BC
 163+ 55A0 78           	LD A,B
 164+ 55A1 B1           	OR C
 165+ 55A2 C8           	RET Z ; if count was 1
 166+ 55A3 ED B0            LDIR
 167+ 55A5 C9               RET
 168+ 55A6              ; *******************************************************************************************************
# file closed: asm\MEMORY.asm
 144  55A6               ENDIF
 145  55A6
 146  55A6               IF (SOUND_CMDS == 1)
 147  55A6               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
   1+ 55A6              MUSIC_INIT_STATUS:
   2+ 55A6 00            DB 0
   3+ 55A7              SFX_INIT_STATUS:
   4+ 55A7 00            DB 0
   5+ 55A8              SOUND_ENABLED:
   6+ 55A8 00            DB 0
   7+ 55A9
   8+ 55A9               IF (0 == 1)
   9+ 55A9 ~            ; *******************************************************************************************************
  10+ 55A9 ~            ; function to handle CALL SNDPLYINIT basic extension
  11+ 55A9 ~            ; initializes sound player
  12+ 55A9 ~            ; _SNDPLYINIT ( INT music_offset,
  13+ 55A9 ~            ;				INT sfx_offset, can be -1 if no SFX
  14+ 55A9 ~            ; will put ram in page 0 also, page 1 is already there
  15+ 55A9 ~            ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
  16+ 55A9 ~            SNDPLYINIT:
  17+ 55A9 ~            	; opening (
  18+ 55A9 ~            	CALL CHKCHAR
  19+ 55A9 ~            	DB '('
  20+ 55A9 ~            	; get music address
  21+ 55A9 ~            	LD IX, FRMQNT
  22+ 55A9 ~            	CALL CALBAS
  23+ 55A9 ~            	PUSH DE
  24+ 55A9 ~            	; comma
  25+ 55A9 ~            	CALL CHKCHAR
  26+ 55A9 ~            	DB ','
  27+ 55A9 ~            	; get sfx address
  28+ 55A9 ~            	LD IX, FRMQNT
  29+ 55A9 ~            	CALL CALBAS
  30+ 55A9 ~            	PUSH DE
  31+ 55A9 ~            	; ending )
  32+ 55A9 ~            	CALL CHKCHAR
  33+ 55A9 ~            	DB ')'
  34+ 55A9 ~
  35+ 55A9 ~                ; save position in BASIC text
  36+ 55A9 ~            	LD B, H
  37+ 55A9 ~            	LD C, L
  38+ 55A9 ~
  39+ 55A9 ~            	; pop LDIR parameters and store away for later
  40+ 55A9 ~            	POP DE ; sfx address
  41+ 55A9 ~            	POP HL ; music address
  42+ 55A9 ~            	PUSH BC ; basic text location
  43+ 55A9 ~            	EXX
  44+ 55A9 ~            	LD IY, .RET
  45+ 55A9 ~            	JP ENABLE_PAGE0
  46+ 55A9 ~            .RET:
  47+ 55A9 ~            	EXX
  48+ 55A9 ~
  49+ 55A9 ~            	PUSH DE
  50+ 55A9 ~            	XOR A
  51+ 55A9 ~            	; HL = music location
  52+ 55A9 ~            	CALL PLY_AKG_INIT
  53+ 55A9 ~            	LD A, 1
  54+ 55A9 ~            	LD (MUSIC_INIT_STATUS), A
  55+ 55A9 ~
  56+ 55A9 ~            	POP HL ; SFX
  57+ 55A9 ~            	; check if SFX address -1
  58+ 55A9 ~            	INC HL
  59+ 55A9 ~            	LD A, L
  60+ 55A9 ~            	OR H
  61+ 55A9 ~            	JR Z,.L1
  62+ 55A9 ~            	DEC HL
  63+ 55A9 ~            	CALL PLY_AKG_INITSOUNDEFFECTS
  64+ 55A9 ~            	LD A, 1
  65+ 55A9 ~            	LD (SFX_INIT_STATUS), A
  66+ 55A9 ~            .L1:
  67+ 55A9 ~                POP DE
  68+ 55A9 ~                POP BC
  69+ 55A9 ~                CALL RESTORE_PAGE_INFO
  70+ 55A9 ~            	XOR A
  71+ 55A9 ~            	POP HL
  72+ 55A9 ~            	RET
  73+ 55A9 ~            ; *******************************************************************************************************
  74+ 55A9               ENDIF
  75+ 55A9
  76+ 55A9               IF (1 == 1)
  77+ 55A9              ; *******************************************************************************************************
  78+ 55A9              ; same as SNDPLYINI but for DEFUSR approach
  79+ 55A9              ; input IX=pointer to input array, real data from +2
  80+ 55A9              ; +2 = music address
  81+ 55A9              ; +4 = sfx address
  82+ 55A9              SNDPLYINI_DEFUSR:
  83+ 55A9 FD 21 B0 55  	LD IY, .RET
  84+ 55AD C3 83 60     	JP ENABLE_PAGE0
  85+ 55B0              .RET:
  86+ 55B0 AF           	XOR A
  87+ 55B1 DD 6E 02     	LD L,(IX+2)
  88+ 55B4 DD 66 03     	LD H,(IX+3)
  89+ 55B7 DD E5        	PUSH IX
  90+ 55B9 CD 65 41     	CALL PLY_AKG_INIT
  91+ 55BC DD E1        	POP IX
  92+ 55BE 3E 01        	LD A, 1
  93+ 55C0 32 A6 55     	LD (MUSIC_INIT_STATUS), A
  94+ 55C3
  95+ 55C3 DD 6E 04     	LD L,(IX+4)
  96+ 55C6 DD 66 05     	LD H,(IX+5)
  97+ 55C9              	; check if SFX address -1
  98+ 55C9 23           	INC HL
  99+ 55CA 7D           	LD A, L
 100+ 55CB B4           	OR H
 101+ 55CC 28 09        	JR Z,.L1
 102+ 55CE 2B           	DEC HL
 103+ 55CF CD 20 40     	CALL PLY_AKG_INITSOUNDEFFECTS
 104+ 55D2 3E 01        	LD A, 1
 105+ 55D4 32 A7 55     	LD (SFX_INIT_STATUS), A
 106+ 55D7              .L1:
 107+ 55D7 C3 99 5F     	JP COMMON_EXIT_CODE
 108+ 55DA              ; *******************************************************************************************************
 109+ 55DA               ENDIF
 110+ 55DA
 111+ 55DA              ; *******************************************************************************************************
 112+ 55DA              ; function to handle CALL SNDPLYON basic extension
 113+ 55DA              ; enables sound player
 114+ 55DA              ; _SNDPLYON
 115+ 55DA              ; sets SOUND_ENABLED variable to 1 if init call was done
 116+ 55DA              ; if not throws out of data error
 117+ 55DA              SNDPLYON_DEFUSR:
 118+ 55DA              SNDPLYON:
 119+ 55DA 3A A6 55     	LD A, (MUSIC_INIT_STATUS)
 120+ 55DD B7           	OR A
 121+ 55DE               IF (0 == 1)
 122+ 55DE ~            	JP Z, OUT_OF_DATA ; player not initialized, throw error
 123+ 55DE               ENDIF
 124+ 55DE               IF (1 == 1)
 125+ 55DE 28 08        	JR Z,.ERR
 126+ 55E0               ENDIF
 127+ 55E0              .L1:
 128+ 55E0 32 A8 55     	LD (SOUND_ENABLED), A
 129+ 55E3              	; disable key click
 130+ 55E3 AF           	XOR A
 131+ 55E4 32 DB F3     	LD (CLIKSW), A
 132+ 55E7 C9           	RET
 133+ 55E8              .ERR:
 134+ 55E8 3E 01        	LD A,1
 135+ 55EA C9           	RET
 136+ 55EB              ; *******************************************************************************************************
 137+ 55EB
 138+ 55EB              ; *******************************************************************************************************
 139+ 55EB              ; function to handle CALL SNDPLYOFF basic extension
 140+ 55EB              ; disables sound player
 141+ 55EB              ; _SNDPLYOFF
 142+ 55EB              ; sets SOUND_ENABLED variable to 0
 143+ 55EB              ; calls AKG to stop music and SFX on all channels if initialized
 144+ 55EB              SNDPLYOFF_DEFUSR:
 145+ 55EB              SNDPLYOFF:
 146+ 55EB 3A A8 55     	LD A, (SOUND_ENABLED)
 147+ 55EE B7           	OR A
 148+ 55EF C8           	RET Z ; already stopped
 149+ 55F0 AF           	XOR A
 150+ 55F1 32 A8 55     	LD (SOUND_ENABLED), A
 151+ 55F4 E5           	PUSH HL
 152+ 55F5 CD 24 42     	CALL PLY_AKG_STOP
 153+ 55F8 3A A7 55     	LD A, (SFX_INIT_STATUS)
 154+ 55FB B7           	OR A
 155+ 55FC 28 0E        	JR Z, .EXIT ; SFX not in use
 156+ 55FE AF           	XOR A
 157+ 55FF CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 158+ 5602 3E 01        	LD A, 1
 159+ 5604 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 160+ 5607 3E 02        	LD A, 2
 161+ 5609 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 162+ 560C              .EXIT:
 163+ 560C E1           	POP HL
 164+ 560D AF           	XOR A ; success
 165+ 560E C9           	RET
 166+ 560F              ; *******************************************************************************************************
 167+ 560F
 168+ 560F               IF (0 == 1)
 169+ 560F ~            ; *******************************************************************************************************
 170+ 560F ~            ; function to handle CALL SNDSFX basic extension
 171+ 560F ~            ; plays a sound effect
 172+ 560F ~            ; _SNDSFX ( BYTE sfx_number, >0
 173+ 560F ~            ;			BYTE channel, = 0,1 or 2
 174+ 560F ~            ;			BYTE inverted_volume = 0-16, 0 being full volume
 175+ 560F ~            ; will put ram in page 0 also, page 1 is already there
 176+ 560F ~            ; if sound off throws illegal function call
 177+ 560F ~            ; if sfx not initialized, throws out of data
 178+ 560F ~            SNDSFX:
 179+ 560F ~            	; opening (
 180+ 560F ~            	CALL CHKCHAR
 181+ 560F ~            	DB '('
 182+ 560F ~            	; get sfx_number
 183+ 560F ~            	LD IX, GETBYT
 184+ 560F ~            	CALL CALBAS
 185+ 560F ~            	PUSH DE
 186+ 560F ~            	; comma
 187+ 560F ~            	CALL CHKCHAR
 188+ 560F ~            	DB ','
 189+ 560F ~            	; get sfx address
 190+ 560F ~            	LD IX, GETBYT
 191+ 560F ~            	CALL CALBAS
 192+ 560F ~            	PUSH DE
 193+ 560F ~            	; comma
 194+ 560F ~            	CALL CHKCHAR
 195+ 560F ~            	DB ','
 196+ 560F ~            	; get inverted volume
 197+ 560F ~            	LD IX, GETBYT
 198+ 560F ~            	CALL CALBAS
 199+ 560F ~            	PUSH DE
 200+ 560F ~            	; ending )
 201+ 560F ~            	CALL CHKCHAR
 202+ 560F ~            	DB ')'
 203+ 560F ~
 204+ 560F ~            	LD A, (SOUND_ENABLED)
 205+ 560F ~            	OR A
 206+ 560F ~            	JR NZ, .L1
 207+ 560F ~            	; sound disabled, throw illegal function call
 208+ 560F ~            	LD E, 5
 209+ 560F ~            	JP THROW_ERROR
 210+ 560F ~            .L1:
 211+ 560F ~            	LD A, (SFX_INIT_STATUS)
 212+ 560F ~            	OR A
 213+ 560F ~            	JR NZ, .L2
 214+ 560F ~            	; sfx data not initialized, throw out of data
 215+ 560F ~            	LD E, 4
 216+ 560F ~            	JP THROW_ERROR
 217+ 560F ~            .L2:
 218+ 560F ~            	; pop  parameters and store away for later
 219+ 560F ~            	POP DE ; inverted volume
 220+ 560F ~            	LD B, E
 221+ 560F ~            	POP DE ; channel
 222+ 560F ~            	LD C, E
 223+ 560F ~            	POP DE
 224+ 560F ~            	LD A, E
 225+ 560F ~            	EX AF, AF'
 226+ 560F ~            	PUSH HL ; basic text location
 227+ 560F ~            	EXX
 228+ 560F ~            	LD IY, .RET
 229+ 560F ~            	JP ENABLE_PAGE0
 230+ 560F ~            .RET:
 231+ 560F ~            	EXX
 232+ 560F ~            	EX AF, AF'
 233+ 560F ~            	CALL PLY_AKG_PLAYSOUNDEFFECT
 234+ 560F ~
 235+ 560F ~                POP DE
 236+ 560F ~                POP BC
 237+ 560F ~                CALL RESTORE_PAGE_INFO
 238+ 560F ~            	XOR A
 239+ 560F ~            	POP HL
 240+ 560F ~            	RET
 241+ 560F ~            ; *******************************************************************************************************
 242+ 560F               ENDIF
 243+ 560F
 244+ 560F               IF (1 == 1)
 245+ 560F              ; *******************************************************************************************************
 246+ 560F              ; same as SNDSFX but for DEFUSR approach
 247+ 560F              ; input IX=pointer to input array, real data from +2
 248+ 560F              ; +2 = SFX number
 249+ 560F              ; +4 = channel
 250+ 560F              ; +6 = volume
 251+ 560F              SNDSFX_DEFUSR:
 252+ 560F 3A A8 55     	LD A, (SOUND_ENABLED)
 253+ 5612 B7           	OR A
 254+ 5613 C8           	RET Z ; sound disabled, just exit
 255+ 5614 3A A7 55     	LD A, (SFX_INIT_STATUS)
 256+ 5617 B7           	OR A
 257+ 5618 C8           	RET Z ; sfx data not initialized, just exit
 258+ 5619 FD 21 20 56  	LD IY, .RET
 259+ 561D C3 83 60     	JP ENABLE_PAGE0
 260+ 5620              .RET:
 261+ 5620 FB           	EI
 262+ 5621 DD 7E 02     	LD A,(IX+2) ; SFX number
 263+ 5624 DD 4E 04     	LD C,(IX+4) ; channel
 264+ 5627 DD 46 06     	LD B,(IX+6) ; volume
 265+ 562A CD 24 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
 266+ 562D C3 99 5F     	JP COMMON_EXIT_CODE
 267+ 5630              ; *******************************************************************************************************
 268+ 5630               ENDIF
# file closed: asm\SOUND.asm
 148  5630               ENDIF
 149  5630
 150  5630               IF (VRAM_CMDS == 1)
 151  5630               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
   1+ 5630               IF (0 == 1)
   2+ 5630 ~            ; *******************************************************************************************************
   3+ 5630 ~            ; function to handle CALL FILVRM basic extension
   4+ 5630 ~            ; FILVRM ( INT offset,
   5+ 5630 ~            ;		   INT count,
   6+ 5630 ~            ;		   BYTE value,
   7+ 5630 ~            ;		   BYTE wait_vsync) >0 = true
   8+ 5630 ~            ; wait_vsync will issue HALT before copying
   9+ 5630 ~            FILVRM:
  10+ 5630 ~            	; opening (
  11+ 5630 ~            	CALL CHKCHAR
  12+ 5630 ~            	DB '('
  13+ 5630 ~            	; get offset address
  14+ 5630 ~            	LD IX, FRMQNT
  15+ 5630 ~            	CALL CALBAS
  16+ 5630 ~            	PUSH DE
  17+ 5630 ~            	; comma
  18+ 5630 ~            	CALL CHKCHAR
  19+ 5630 ~            	DB ','
  20+ 5630 ~            	; get count
  21+ 5630 ~            	LD IX, FRMQNT
  22+ 5630 ~            	CALL CALBAS
  23+ 5630 ~            	PUSH DE
  24+ 5630 ~            	; comma
  25+ 5630 ~            	CALL CHKCHAR
  26+ 5630 ~            	DB ','
  27+ 5630 ~            	; get value
  28+ 5630 ~            	LD IX, GETBYT
  29+ 5630 ~            	CALL CALBAS
  30+ 5630 ~            	PUSH AF
  31+ 5630 ~            	; comma
  32+ 5630 ~            	CALL CHKCHAR
  33+ 5630 ~            	DB ','
  34+ 5630 ~            	; get vsync wait
  35+ 5630 ~            	LD IX, GETBYT
  36+ 5630 ~            	CALL CALBAS
  37+ 5630 ~            	PUSH AF
  38+ 5630 ~            	; ending )
  39+ 5630 ~            	CALL CHKCHAR
  40+ 5630 ~            	DB ')'
  41+ 5630 ~
  42+ 5630 ~            	; save position
  43+ 5630 ~            	PUSH HL
  44+ 5630 ~            	POP IX
  45+ 5630 ~
  46+ 5630 ~            	; syntax ok
  47+ 5630 ~            	; wait for vsync if needed
  48+ 5630 ~            	POP AF
  49+ 5630 ~            	OR A
  50+ 5630 ~            	JR Z, .L1
  51+ 5630 ~            	HALT
  52+ 5630 ~
  53+ 5630 ~            .L1:
  54+ 5630 ~            	LD A,1
  55+ 5630 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  56+ 5630 ~                POP AF ; value
  57+ 5630 ~                POP BC ; count
  58+ 5630 ~                POP HL ; offset
  59+ 5630 ~                CALL BIOS_FILVRM
  60+ 5630 ~            	XOR A
  61+ 5630 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  62+ 5630 ~
  63+ 5630 ~            .L3:
  64+ 5630 ~            	PUSH IX
  65+ 5630 ~            	POP HL
  66+ 5630 ~            	RET
  67+ 5630 ~            ; *******************************************************************************************************
  68+ 5630               ENDIF
  69+ 5630
  70+ 5630               IF (1 == 1)
  71+ 5630              ; *******************************************************************************************************
  72+ 5630              ; same as FILVRM but for DEFUSR approach
  73+ 5630              ; input IX=pointer to input array, real data from +2
  74+ 5630              ; +2 = offset
  75+ 5630              ; +4 = count
  76+ 5630              ; +6 = value
  77+ 5630              ; +8 = halt flag
  78+ 5630              FILVRM_DEFUSR:
  79+ 5630 DD 7E 08     	LD A,(IX+8)
  80+ 5633 B7           	OR A
  81+ 5634 28 01        	JR Z,.L0
  82+ 5636 76           	HALT
  83+ 5637              .L0:
  84+ 5637 3E 01        	LD A,1
  85+ 5639 32 56 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
  86+ 563C DD 6E 02     	LD L,(IX+2)
  87+ 563F DD 66 03     	LD H,(IX+3)
  88+ 5642 DD 4E 04     	LD C,(IX+4)
  89+ 5645 DD 46 05     	LD B,(IX+5)
  90+ 5648 DD 7E 06     	LD A,(IX+6)
  91+ 564B CD 56 00     	CALL BIOS_FILVRM
  92+ 564E AF           	XOR A
  93+ 564F 32 56 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
  94+ 5652 C9           	RET
  95+ 5653              ; *******************************************************************************************************
  96+ 5653               ENDIF
  97+ 5653
  98+ 5653               IF (0 == 1)
  99+ 5653 ~            ; *******************************************************************************************************
 100+ 5653 ~            ; function to handle CALL MEMVRM basic extension
 101+ 5653 ~            ; copies from RAM to VRAM
 102+ 5653 ~            ; if flag != 0 it will issue HALT before copying
 103+ 5653 ~            ; if bit 1 of flag set and sprite system initialized it will set sprite update flag
 104+ 5653 ~            ; _MEMVRM ( INT source,
 105+ 5653 ~            ;			INT destination,
 106+ 5653 ~            ;			INT count,
 107+ 5653 ~            ;			BYTE flag)
 108+ 5653 ~            ; will put ram in page 0 also, page 1 is already there
 109+ 5653 ~            MEMVRM:
 110+ 5653 ~            	; opening (
 111+ 5653 ~            	CALL CHKCHAR
 112+ 5653 ~            	DB '('
 113+ 5653 ~            	; get source address
 114+ 5653 ~            	LD IX, FRMQNT
 115+ 5653 ~            	CALL CALBAS
 116+ 5653 ~            	PUSH DE
 117+ 5653 ~            	; comma
 118+ 5653 ~            	CALL CHKCHAR
 119+ 5653 ~            	DB ','
 120+ 5653 ~            	; get destination address
 121+ 5653 ~            	LD IX, FRMQNT
 122+ 5653 ~            	CALL CALBAS
 123+ 5653 ~            	PUSH DE
 124+ 5653 ~            	; comma
 125+ 5653 ~            	CALL CHKCHAR
 126+ 5653 ~            	DB ','
 127+ 5653 ~            	; get length
 128+ 5653 ~            	LD IX, FRMQNT
 129+ 5653 ~            	CALL CALBAS
 130+ 5653 ~            	PUSH DE
 131+ 5653 ~            	; comma
 132+ 5653 ~            	CALL CHKCHAR
 133+ 5653 ~            	DB ','
 134+ 5653 ~            	; get vsync wait
 135+ 5653 ~            	LD IX, GETBYT
 136+ 5653 ~            	CALL CALBAS
 137+ 5653 ~            	PUSH AF
 138+ 5653 ~            	; ending )
 139+ 5653 ~            	CALL CHKCHAR
 140+ 5653 ~            	DB ')'
 141+ 5653 ~
 142+ 5653 ~                ; save position in BASIC text
 143+ 5653 ~            	PUSH HL
 144+ 5653 ~            	POP IX
 145+ 5653 ~
 146+ 5653 ~            	POP AF ; wait vsync
 147+ 5653 ~            	OR A
 148+ 5653 ~            	JR Z, .L1
 149+ 5653 ~            	; check for special case to set sprite update flag
 150+ 5653 ~            	IF (SPRITE_CMDS == 1)
 151+ 5653 ~            		AND 2
 152+ 5653 ~            		JR Z,.L2
 153+ 5653 ~            		LD A, (SPRATR_INIT_STATUS)
 154+ 5653 ~            		OR A
 155+ 5653 ~            		JR Z,.L2
 156+ 5653 ~            		LD HL,(SPRATR_UPDATE_FLAG)
 157+ 5653 ~            		LD (HL),A
 158+ 5653 ~            	ENDIF
 159+ 5653 ~            .L2:
 160+ 5653 ~            	HALT
 161+ 5653 ~            .L1:
 162+ 5653 ~            	; pop LDIR parameters and store away for later
 163+ 5653 ~            	POP BC ; count
 164+ 5653 ~            	POP DE ; vram destination
 165+ 5653 ~            	POP HL ; ram source
 166+ 5653 ~            	EXX
 167+ 5653 ~             	LD IY, .RET
 168+ 5653 ~            	JP ENABLE_PAGE0
 169+ 5653 ~            .RET:
 170+ 5653 ~            	EI
 171+ 5653 ~            	EXX
 172+ 5653 ~            	CALL VRAM_LDIRVM
 173+ 5653 ~            	JP COMMON_EXIT_CODE_IX
 174+ 5653 ~            ; *******************************************************************************************************
 175+ 5653               ENDIF
 176+ 5653
 177+ 5653               IF (1 == 1)
 178+ 5653              ; *******************************************************************************************************
 179+ 5653              ; same as MEMVRM but for DEFUSR approach
 180+ 5653              ; input IX=pointer to input array, real data from +2
 181+ 5653              ; +2 = source address
 182+ 5653              ; +4 = destination address
 183+ 5653              ; +6 = lenght
 184+ 5653              ; +8 = flag
 185+ 5653              MEMVRM_DEFUSR:
 186+ 5653 DD 7E 08     	LD A,(IX+8)
 187+ 5656 B7           	OR A
 188+ 5657 28 0F        	JR Z,.L0
 189+ 5659              	IF (SPRITE_CMDS == 1)
 190+ 5659 E6 02        		AND 2
 191+ 565B 28 0A        		JR Z,.L2
 192+ 565D 3A 86 4D     		LD A, (SPRATR_INIT_STATUS)
 193+ 5660 B7           		OR A
 194+ 5661 28 04        		JR Z,.L2
 195+ 5663 2A 87 4D     		LD HL,(SPRATR_UPDATE_FLAG)
 196+ 5666 77           		LD (HL),A
 197+ 5667              	ENDIF
 198+ 5667              .L2:
 199+ 5667 76           	HALT
 200+ 5668              .L0:
 201+ 5668              	; enable page 0
 202+ 5668 FD 21 6F 56  	LD IY, .RET
 203+ 566C C3 83 60     	JP ENABLE_PAGE0
 204+ 566F              .RET:
 205+ 566F FB           	EI
 206+ 5670 DD 6E 02     	LD L,(IX+2)
 207+ 5673 DD 66 03     	LD H,(IX+3)
 208+ 5676 DD 5E 04     	LD E,(IX+4)
 209+ 5679 DD 56 05     	LD D,(IX+5)
 210+ 567C DD 4E 06     	LD C,(IX+6)
 211+ 567F DD 46 07     	LD B,(IX+7)
 212+ 5682 CD 88 56     	CALL VRAM_LDIRVM
 213+ 5685 C3 99 5F         JP COMMON_EXIT_CODE
 214+ 5688              ; *******************************************************************************************************
 215+ 5688               ENDIF
 216+ 5688
 217+ 5688              ; *******************************************************************************************************
 218+ 5688              ; common code to copy from memory to VRAM
 219+ 5688              ; input HL=RAM source
 220+ 5688              ; input DE=VRAM destination
 221+ 5688              ; BC=count
 222+ 5688              VRAM_LDIRVM:
 223+ 5688 3E 01        	LD A,1
 224+ 568A 32 56 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 225+ 568D EB           	EX DE, HL
 226+ 568E F3           	DI
 227+ 568F CD A0 5F     	CALL SETWRT_LOCAL_WRITE
 228+ 5692 FB           	EI
 229+ 5693 EB           	EX DE, HL
 230+ 5694 78           	LD A, B
 231+ 5695 B7           	OR A
 232+ 5696 28 0D        	JR Z, .L3
 233+ 5698 C5           	PUSH BC
 234+ 5699 0E 98        	LD C, #98
 235+ 569B              .L2:
 236+ 569B 50           	LD D, B
 237+ 569C 06 00        	LD B, 0
 238+ 569E CD B7 5F     	CALL BBYTECOPY_NO_C
 239+ 56A1 42           	LD B, D
 240+ 56A2 10 F7        	DJNZ .L2
 241+ 56A4 C1           	POP BC
 242+ 56A5              .L3:
 243+ 56A5 79           	LD A, C
 244+ 56A6 B7           	OR A
 245+ 56A7 28 04        	JR Z,.L4
 246+ 56A9 41           	LD B, C
 247+ 56AA CD B5 5F     	CALL BBYTECOPY
 248+ 56AD              .L4:
 249+ 56AD AF           	XOR A
 250+ 56AE 32 56 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 251+ 56B1 C9           	RET
 252+ 56B2              ; *******************************************************************************************************
 253+ 56B2
 254+ 56B2               IF (0 == 1)
 255+ 56B2 ~            ; *******************************************************************************************************
 256+ 56B2 ~            ; function to handle CALL VRMMEM basic extension
 257+ 56B2 ~            ; copies from VRAM to RAM
 258+ 56B2 ~            ; _VRMMEM ( INT source,
 259+ 56B2 ~            ;			INT destination,
 260+ 56B2 ~            ;			INT count
 261+ 56B2 ~            ; will put ram in page 0 also, page 1 is already there
 262+ 56B2 ~            VRMMEM:
 263+ 56B2 ~            	; opening (
 264+ 56B2 ~            	CALL CHKCHAR
 265+ 56B2 ~            	DB '('
 266+ 56B2 ~            	; get source address
 267+ 56B2 ~            	LD IX, FRMQNT
 268+ 56B2 ~            	CALL CALBAS
 269+ 56B2 ~            	PUSH DE
 270+ 56B2 ~            	; comma
 271+ 56B2 ~            	CALL CHKCHAR
 272+ 56B2 ~            	DB ','
 273+ 56B2 ~            	; get destination address
 274+ 56B2 ~            	LD IX, FRMQNT
 275+ 56B2 ~            	CALL CALBAS
 276+ 56B2 ~            	PUSH DE
 277+ 56B2 ~            	; comma
 278+ 56B2 ~            	CALL CHKCHAR
 279+ 56B2 ~            	DB ','
 280+ 56B2 ~            	; get length
 281+ 56B2 ~            	LD IX, FRMQNT
 282+ 56B2 ~            	CALL CALBAS
 283+ 56B2 ~            	PUSH DE
 284+ 56B2 ~            	; ending )
 285+ 56B2 ~            	CALL CHKCHAR
 286+ 56B2 ~            	DB ')'
 287+ 56B2 ~
 288+ 56B2 ~                ; save position in BASIC text
 289+ 56B2 ~            	PUSH HL
 290+ 56B2 ~            	POP IX
 291+ 56B2 ~
 292+ 56B2 ~            	POP BC ; count
 293+ 56B2 ~            	POP DE ; destination
 294+ 56B2 ~            	POP HL ; source
 295+ 56B2 ~            	EXX
 296+ 56B2 ~            	LD IY, .RET
 297+ 56B2 ~            	JP ENABLE_PAGE0
 298+ 56B2 ~            .RET:
 299+ 56B2 ~            	EI
 300+ 56B2 ~            	EXX
 301+ 56B2 ~            	CALL VRAM_LDIRMV
 302+ 56B2 ~            	JP COMMON_EXIT_CODE_IX
 303+ 56B2 ~            ; *******************************************************************************************************
 304+ 56B2               ENDIF
 305+ 56B2
 306+ 56B2               IF (1 == 1)
 307+ 56B2              ; *******************************************************************************************************
 308+ 56B2              ; same as VRMMEM but for DEFUSR approach
 309+ 56B2              ; input IX=pointer to input array, real data from +2
 310+ 56B2              ; +2 = source address
 311+ 56B2              ; +4 = destination address
 312+ 56B2              ; +6 = count
 313+ 56B2              VRMMEM_DEFUSR:
 314+ 56B2              	; enable page 0
 315+ 56B2 FD 21 B9 56  	LD IY, .RET
 316+ 56B6 C3 83 60     	JP ENABLE_PAGE0
 317+ 56B9              .RET:
 318+ 56B9 FB           	EI
 319+ 56BA DD 6E 02     	LD L,(IX+2)
 320+ 56BD DD 66 03     	LD H,(IX+3)
 321+ 56C0 DD 5E 04     	LD E,(IX+4)
 322+ 56C3 DD 56 05     	LD D,(IX+5)
 323+ 56C6 DD 4E 06     	LD C,(IX+6)
 324+ 56C9 DD 46 07     	LD B,(IX+7)
 325+ 56CC CD D2 56     	CALL VRAM_LDIRMV
 326+ 56CF C3 99 5F     	JP COMMON_EXIT_CODE
 327+ 56D2              ; *******************************************************************************************************
 328+ 56D2               ENDIF
 329+ 56D2
 330+ 56D2              ; *******************************************************************************************************
 331+ 56D2              ; common code to copy from VRAM to RAM
 332+ 56D2              ; input HL=VRAM source
 333+ 56D2              ; input DE=RAM destination
 334+ 56D2              ; BC=count
 335+ 56D2              VRAM_LDIRMV:
 336+ 56D2 3E 01        	LD A,1
 337+ 56D4 32 56 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 338+ 56D7 7D           	LD	A, L
 339+ 56D8 F3           	DI
 340+ 56D9 CD AB 5F     	CALL SETWRT_LOCAL_READ
 341+ 56DC FB           	EI
 342+ 56DD 00           	NOP
 343+ 56DE 00           	NOP
 344+ 56DF 00           	NOP ; too fast VDP access per openMSX
 345+ 56E0              .L4:
 346+ 56E0 DB 98            IN A, (#98)
 347+ 56E2 12           	LD (DE), A
 348+ 56E3 13               INC DE
 349+ 56E4 0B               DEC BC
 350+ 56E5 79               LD A, C
 351+ 56E6 B0               OR B
 352+ 56E7 20 F7            JR NZ, .L4
 353+ 56E9 AF           	XOR A
 354+ 56EA 32 56 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 355+ 56ED C9               RET
 356+ 56EE              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
 152  56EE               ENDIF
 153  56EE
 154  56EE               IF (GENCAL_CMD == 1)
 155  56EE               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
   1+ 56EE               IF (1 == 1)
   2+ 56EE              ; *******************************************************************************************************
   3+ 56EE              ; same as GENCAL but for DEFUSR approach
   4+ 56EE              ; input IX=pointer to input array, real data from +2
   5+ 56EE              ; +2 = function address to call
   6+ 56EE              ; +4 = register list array pointer
   7+ 56EE              GENCAL_DEFUSR:
   8+ 56EE DD 6E 02         LD L,(IX+2)
   9+ 56F1 DD 66 03         LD H,(IX+3)
  10+ 56F4 E5               PUSH HL
  11+ 56F5 DD 6E 04         LD L,(IX+4)
  12+ 56F8 DD 66 05         LD H,(IX+5)
  13+ 56FB E5               PUSH HL
  14+ 56FC 18 00            JR GENCAL.COMMON
  15+ 56FE              ; *******************************************************************************************************
  16+ 56FE               ENDIF
  17+ 56FE
  18+ 56FE              ; *******************************************************************************************************
  19+ 56FE              ; function to handle CALL GENCAL basic extension
  20+ 56FE              ; GENCAL ( INT fn_addr, = address of the function to call
  21+ 56FE              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
  22+ 56FE              ; output values of registers will also be stored at reg_list_ptr
  23+ 56FE              GENCAL:
  24+ 56FE               IF (0 == 1)
  25+ 56FE ~            	; opening (
  26+ 56FE ~            	CALL CHKCHAR
  27+ 56FE ~            	DB '('
  28+ 56FE ~            	; get function address
  29+ 56FE ~            	LD IX, FRMQNT
  30+ 56FE ~            	CALL CALBAS
  31+ 56FE ~            	PUSH DE
  32+ 56FE ~            	; comma
  33+ 56FE ~            	CALL CHKCHAR
  34+ 56FE ~            	DB ','
  35+ 56FE ~            	; get pointer to register list
  36+ 56FE ~                LD A,2
  37+ 56FE ~                LD B,1
  38+ 56FE ~                LD DE,#0500
  39+ 56FE ~                CALL GET_BASIC_ARRAY_DATA_POINTER
  40+ 56FE ~            	PUSH BC
  41+ 56FE ~            	; ending )
  42+ 56FE ~            	CALL CHKCHAR
  43+ 56FE ~            	DB ')'
  44+ 56FE               ENDIF
  45+ 56FE              .COMMON:
  46+ 56FE              	; save BASIC token position
  47+ 56FE E5           	PUSH HL
  48+ 56FF D9               EXX
  49+ 5700 E1           	POP HL ; HL'=next basic token
  50+ 5701 D9               EXX
  51+ 5702
  52+ 5702 E1               POP HL ; get pointer to register values
  53+ 5703 F3           	DI
  54+ 5704 ED 73 45 5F      LD (TMP_STRUCT), SP
  55+ 5708 F9               LD SP, HL
  56+ 5709 F1               POP AF
  57+ 570A C1               POP BC
  58+ 570B D1               POP DE
  59+ 570C E1               POP HL
  60+ 570D DD E1            POP IX
  61+ 570F FD E1            POP IY
  62+ 5711 D9               EXX
  63+ 5712 ED 73 47 5F      LD (TMP_STRUCT+2), SP
  64+ 5716 ED 7B 45 5F      LD SP, (TMP_STRUCT)
  65+ 571A FB               EI
  66+ 571B D1               POP DE ; get function to call
  67+ 571C E5               PUSH HL
  68+ 571D CD 39 57         CALL .EXXDECALL
  69+ 5720 F3               DI
  70+ 5721 ED 73 45 5F      LD (TMP_STRUCT), SP
  71+ 5725 ED 7B 47 5F      LD SP, (TMP_STRUCT+2)
  72+ 5729 FD E5            PUSH IY
  73+ 572B DD E5            PUSH IX
  74+ 572D E5               PUSH HL
  75+ 572E D5               PUSH DE
  76+ 572F C5               PUSH BC
  77+ 5730 F5               PUSH AF
  78+ 5731 ED 7B 45 5F      LD SP, (TMP_STRUCT)
  79+ 5735 FB               EI
  80+ 5736 E1               POP HL
  81+ 5737 AF               XOR A ; success
  82+ 5738 C9           	RET
  83+ 5739
  84+ 5739              .EXXDECALL:
  85+ 5739 D5               PUSH DE
  86+ 573A D9               EXX
  87+ 573B C9               RET
  88+ 573C              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
 156  573C               ENDIF
 157  573C
 158  573C               IF (BOX_CMDS == 1)
 159  573C               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
   1+ 573C              ; *******************************************************************************************************
   2+ 573C              ; generic function to implement rectangle data copy
   3+ 573C              ; should be modified to call appropriate function for memory or vram
   4+ 573C              ; input IX=pointer to following structure
   5+ 573C              ; +00 source data pointer
   6+ 573C              ; +02 num bytes in a row
   7+ 573C              ; +04 number of rows
   8+ 573C              ; +06 source add-to value till next row
   9+ 573C              ; +08 destination address
  10+ 573C              ; +10 destination add-to value till next row
  11+ 573C              ; modifies AF, BC, DE, HL
  12+ 573C              RECTANGLE_COPY:
  13+ 573C DD 6E 00     	LD L, (IX+0)
  14+ 573F DD 66 01     	LD H, (IX+1) ; source address
  15+ 5742 DD 5E 08     	LD E, (IX+8)
  16+ 5745 DD 56 09     	LD D, (IX+9) ; destination
  17+ 5748 DD 46 04     	LD B, (IX+4) ; row number
  18+ 574B              .L1:
  19+ 574B C5           	PUSH BC
  20+ 574C E5           		PUSH HL
  21+ 574D D5           			PUSH DE
  22+ 574E DD 4E 02     				LD C, (IX+2)
  23+ 5751 DD 46 03     				LD B, (IX+3) ; num bytes in a row
  24+ 5754              .CALL1:
  25+ 5754 CD 00 00     				CALL 0 ; set destination address from DE
  26+ 5757              .CALL2:
  27+ 5757 CD 00 00     				CALL 0 ; copy data fn
  28+ 575A E1           			POP HL
  29+ 575B DD 4E 0A     			LD C, (IX+10)
  30+ 575E DD 46 0B     			LD B, (IX+11) ; destination add-to
  31+ 5761 09           			ADD HL, BC
  32+ 5762 EB           			EX DE, HL
  33+ 5763 E1           		POP HL
  34+ 5764 DD 4E 06     		LD C, (IX+6)
  35+ 5767 DD 46 07     		LD B, (IX+7) ; src add-to
  36+ 576A 09           		ADD HL, BC
  37+ 576B C1           	POP BC
  38+ 576C 10 DD        	DJNZ .L1
  39+ 576E C9           	RET
  40+ 576F              ; *******************************************************************************************************
  41+ 576F
  42+ 576F               IF (0 == 1)
  43+ 576F ~            ; *******************************************************************************************************
  44+ 576F ~            ; function to handle CALL BOXMEMCPY basic extension
  45+ 576F ~            ; copies data with window like boundaries within ram
  46+ 576F ~            ; BOXMEMCPY ( INT source data pointer,
  47+ 576F ~            ;			  INT source number of bytes in a row,
  48+ 576F ~            ;			  INT number of rows,
  49+ 576F ~            ;			  INT source add-to value till next row,
  50+ 576F ~            ; 			  INT destination pointer,
  51+ 576F ~            ;			  INT destination add-to value till next row )
  52+ 576F ~            ; request_data_ptr described in RECTANGLE_COPY
  53+ 576F ~            ; will put ram in page 0 also, page 1 is already there
  54+ 576F ~            BOXMEMCPY:
  55+ 576F ~            	LD DE,BOXMEMCPY_COMMON
  56+ 576F ~            	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
  57+ 576F ~            	JP BOX_EXTENSION_PARAMS_COMMON
  58+ 576F               ENDIF
  59+ 576F
  60+ 576F               IF (1 == 1)
  61+ 576F              ; *******************************************************************************************************
  62+ 576F              ; same as BOXMEMCPY but for DEFUSR approach
  63+ 576F              ; input IX=pointer to input array, real data from +2
  64+ 576F              ; +02 = source data pointer
  65+ 576F              ; +04 = source number of bytes in a row
  66+ 576F              ; +06 = number of rows
  67+ 576F              ; +08 = source add-to value till next row
  68+ 576F              ; +10 = destination pointer
  69+ 576F              ; +12 = destination add-to value till next row
  70+ 576F              BOXMEMCPY_DEFUSR:
  71+ 576F 21 7C 57     	LD HL,BOXMEMCPY_COMMON
  72+ 5772 22 92 57     	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
  73+ 5775 DD 23        	INC IX
  74+ 5777 DD 23        	INC IX
  75+ 5779 C3 8F 57     	JP BOXCOMMON_DEFUSR
  76+ 577C               ENDIF
  77+ 577C
  78+ 577C              BOXMEMCPY_COMMON:
  79+ 577C FB           	EI
  80+ 577D              	; set RAM functions to call
  81+ 577D 21 00 00     	LD HL, 0
  82+ 5780 22 54 57     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
  83+ 5783 22 56 57     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
  84+ 5786 21 ED B0     	LD HL, #B0ED ; LDIR
  85+ 5789 22 58 57     	LD (RECTANGLE_COPY.CALL1+4), HL
  86+ 578C C3 97 57     	JP BOXCOMMON_DEFUSR.CALL
  87+ 578F              ; *******************************************************************************************************
  88+ 578F
  89+ 578F               IF (0 == 1)
  90+ 578F ~            ; *******************************************************************************************************
  91+ 578F ~            ; common parts of BOX commands to load parameters
  92+ 578F ~            BOX_EXTENSION_PARAMS_COMMON:
  93+ 578F ~            	; opening (
  94+ 578F ~            	CALL CHKCHAR
  95+ 578F ~            	DB '('
  96+ 578F ~            	; get source data pointer
  97+ 578F ~            	LD IX, FRMQNT
  98+ 578F ~            	CALL CALBAS
  99+ 578F ~            	LD (TMP_STRUCT+0), DE
 100+ 578F ~            	; comma
 101+ 578F ~            	CALL CHKCHAR
 102+ 578F ~            	DB ','
 103+ 578F ~            	; source number of bytes in a row
 104+ 578F ~            	LD IX, FRMQNT
 105+ 578F ~            	CALL CALBAS
 106+ 578F ~            	LD (TMP_STRUCT+2), DE
 107+ 578F ~            	; comma
 108+ 578F ~            	CALL CHKCHAR
 109+ 578F ~            	DB ','
 110+ 578F ~            	; number of rows
 111+ 578F ~            	LD IX, FRMQNT
 112+ 578F ~            	CALL CALBAS
 113+ 578F ~            	LD (TMP_STRUCT+4), DE
 114+ 578F ~            	; comma
 115+ 578F ~            	CALL CHKCHAR
 116+ 578F ~            	DB ','
 117+ 578F ~            	; source add-to value till next row
 118+ 578F ~            	LD IX, FRMQNT
 119+ 578F ~            	CALL CALBAS
 120+ 578F ~            	LD (TMP_STRUCT+6), DE
 121+ 578F ~            	; comma
 122+ 578F ~            	CALL CHKCHAR
 123+ 578F ~            	DB ','
 124+ 578F ~            	; destination pointer
 125+ 578F ~            	LD IX, FRMQNT
 126+ 578F ~            	CALL CALBAS
 127+ 578F ~            	LD (TMP_STRUCT+8), DE
 128+ 578F ~            	; comma
 129+ 578F ~            	CALL CHKCHAR
 130+ 578F ~            	DB ','
 131+ 578F ~            	; destination add-to value till next row
 132+ 578F ~            	LD IX, FRMQNT
 133+ 578F ~            	CALL CALBAS
 134+ 578F ~            	LD (TMP_STRUCT+10), DE
 135+ 578F ~            	; ending )
 136+ 578F ~            	CALL CHKCHAR
 137+ 578F ~            	DB ')'
 138+ 578F ~            	LD IX,TMP_STRUCT
 139+ 578F               ENDIF
 140+ 578F              BOXCOMMON_DEFUSR:
 141+ 578F E5           	PUSH HL ; save position in BASIC buffer
 142+ 5790              .ADDR:
 143+ 5790 FD 21 00 00  	LD IY, 0 ; modified by code
 144+ 5794 C3 83 60     	JP ENABLE_PAGE0
 145+ 5797              .CALL:
 146+ 5797 CD 3C 57     	CALL RECTANGLE_COPY
 147+ 579A D1           	POP DE
 148+ 579B C1           	POP BC
 149+ 579C CD FA 5F     	CALL RESTORE_PAGE_INFO
 150+ 579F E1           	POP HL
 151+ 57A0 AF           	XOR A ; success
 152+ 57A1 32 56 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 153+ 57A4 C9           	RET
 154+ 57A5              ; *******************************************************************************************************
 155+ 57A5
 156+ 57A5               IF (0 == 1)
 157+ 57A5 ~            ; *******************************************************************************************************
 158+ 57A5 ~            ; function to handle CALL BOXMEMVRM basic extension
 159+ 57A5 ~            ; copies data with window like boundaries from ram to Vram
 160+ 57A5 ~            ; BOXMEMVRM ( INT source data pointer,
 161+ 57A5 ~            ;			  INT source number of bytes in a row,
 162+ 57A5 ~            ;			  INT number of rows,
 163+ 57A5 ~            ;			  INT source add-to value till next row,
 164+ 57A5 ~            ; 			  INT destination pointer,
 165+ 57A5 ~            ;			  INT destination add-to value till next row )
 166+ 57A5 ~            ; request_data_ptr described in RECTANGLE_COPY
 167+ 57A5 ~            ; will put ram in page 0 also, page 1 is already there
 168+ 57A5 ~            BOXMEMVRM:
 169+ 57A5 ~            	LD DE,BOXMEMVRM_COMMON
 170+ 57A5 ~            	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
 171+ 57A5 ~            	JP BOX_EXTENSION_PARAMS_COMMON
 172+ 57A5               ENDIF
 173+ 57A5
 174+ 57A5               IF (1 == 1)
 175+ 57A5              ; *******************************************************************************************************
 176+ 57A5              ; same as BOXMEMVRM but for DEFUSR approach
 177+ 57A5              ; input IX=pointer to input array, real data from +2
 178+ 57A5              ; +02 = source data pointer
 179+ 57A5              ; +04 = source number of bytes in a row
 180+ 57A5              ; +06 = number of rows
 181+ 57A5              ; +08 = source add-to value till next row
 182+ 57A5              ; +10 = destination pointer
 183+ 57A5              ; +12 = destination add-to value till next row
 184+ 57A5              BOXMEMVRM_DEFUSR:
 185+ 57A5 21 B2 57     	LD HL,BOXMEMVRM_COMMON
 186+ 57A8 22 92 57     	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
 187+ 57AB DD 23        	INC IX
 188+ 57AD DD 23        	INC IX
 189+ 57AF C3 8F 57     	JP BOXCOMMON_DEFUSR
 190+ 57B2               ENDIF
 191+ 57B2
 192+ 57B2              BOXMEMVRM_COMMON:
 193+ 57B2 FB           	EI
 194+ 57B3              	; set RAM functions to call
 195+ 57B3 21 CD 57     	LD HL, .SETDEST
 196+ 57B6 22 55 57     	LD (RECTANGLE_COPY.CALL1+1), HL
 197+ 57B9 21 D5 57     	LD HL, .COPYDATA
 198+ 57BC 22 58 57     	LD (RECTANGLE_COPY.CALL2+1), HL
 199+ 57BF 3E CD        	LD A, #CD ; CALL
 200+ 57C1 32 54 57     	LD (RECTANGLE_COPY.CALL1), A
 201+ 57C4 32 57 57     	LD (RECTANGLE_COPY.CALL2), A
 202+ 57C7              	;LD A,1
 203+ 57C7 32 56 5F     	LD (VRAM_UPDATE_IN_PROGRESS),A
 204+ 57CA C3 97 57     	JP BOXCOMMON_DEFUSR.CALL
 205+ 57CD              .SETDEST:
 206+ 57CD EB           	EX DE, HL
 207+ 57CE F3           	DI
 208+ 57CF CD A0 5F     	CALL SETWRT_LOCAL_WRITE
 209+ 57D2 FB           	EI
 210+ 57D3 EB           	EX DE, HL
 211+ 57D4 C9           	RET
 212+ 57D5              .COPYDATA:
 213+ 57D5 41           	LD B, C
 214+ 57D6 C3 B5 5F     	JP BBYTECOPY
 215+ 57D9              ; *******************************************************************************************************
# file closed: asm\BOX.asm
 160  57D9               ENDIF
 161  57D9
 162  57D9               IF (BLIT_CMDS == 1)
 163  57D9               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
   1+ 57D9              ; *******************************************************************************************************
   2+ 57D9              ; function rotates mask and data of several characters and applies to background data
   3+ 57D9              ; this handles x-shift from 0 to 4
   4+ 57D9              ; contains self-modifying code that is set-up from external function
   5+ 57D9              ; input HL=pointer to mask data
   6+ 57D9              ; input HL'=pointer to character data
   7+ 57D9              ; input DE=output buffer containing background data
   8+ 57D9              ; input BC=DE+8
   9+ 57D9              ; input A=number of characters to process
  10+ 57D9              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  11+ 57D9              SHIFT04:
  12+ 57D9 08           	EX AF, AF'
  13+ 57DA 7E           	LD A, (HL) ; get mask
  14+ 57DB D9           	EXX
  15+ 57DC 57           	LD D, A
  16+ 57DD 1E FF        	LD E, #FF
  17+ 57DF 37           	SCF
  18+ 57E0              .M1:
  19+ 57E0 18 FE        	JR .M1 ; this is self-modifying part
  20+ 57E2 CB 1A        	RR D
  21+ 57E4 CB 1B        	RR E
  22+ 57E6 CB 1A        	RR D
  23+ 57E8 CB 1B        	RR E
  24+ 57EA CB 1A        	RR D
  25+ 57EC CB 1B        	RR E
  26+ 57EE CB 1A        	RR D
  27+ 57F0 CB 1B        	RR E
  28+ 57F2
  29+ 57F2 46           	LD B, (HL) ; get data
  30+ 57F3 0E 00        	LD C, 0
  31+ 57F5              .M2:
  32+ 57F5 18 FE        	JR .M2 ; also self-modifying part
  33+ 57F7 CB 38        	SRL B
  34+ 57F9 CB 19        	RR C
  35+ 57FB CB 38        	SRL B
  36+ 57FD CB 19        	RR C
  37+ 57FF CB 38        	SRL B
  38+ 5801 CB 19        	RR C
  39+ 5803 CB 38        	SRL B
  40+ 5805 CB 19        	RR C
  41+ 5807
  42+ 5807 D9           	EXX
  43+ 5808 1A           	LD A, (DE) ; background
  44+ 5809 D9           	EXX
  45+ 580A A2           	AND D
  46+ 580B B0           	OR B
  47+ 580C D9           	EXX
  48+ 580D 12           	LD (DE), A
  49+ 580E
  50+ 580E 0A           	LD A, (BC)
  51+ 580F D9           	EXX
  52+ 5810 A3           	AND E
  53+ 5811 B1           	OR C
  54+ 5812 23           	INC HL
  55+ 5813 D9           	EXX
  56+ 5814 02           	LD (BC), A
  57+ 5815
  58+ 5815 23           	INC HL
  59+ 5816 13           	INC DE
  60+ 5817 03           	INC BC
  61+ 5818
  62+ 5818 08           	EX AF, AF'
  63+ 5819 3D           	DEC A
  64+ 581A C2 D9 57     	JP NZ, SHIFT04
  65+ 581D C9           	RET
  66+ 581E              ; *******************************************************************************************************
  67+ 581E
  68+ 581E              ; *******************************************************************************************************
  69+ 581E              ; function rotates mask and data of several characters and applies to background data
  70+ 581E              ; this handles x-shift from 5 to 8
  71+ 581E              ; contains self-modifying code that is set-up from external function
  72+ 581E              ; input HL=pointer to mask data
  73+ 581E              ; input HL'=pointer to character data
  74+ 581E              ; input DE=output buffer containing background data
  75+ 581E              ; input BC=DE+8
  76+ 581E              ; input A=number of characters to process
  77+ 581E              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  78+ 581E              SHIFT58:
  79+ 581E 08           	EX AF, AF'
  80+ 581F 7E           	LD A, (HL) ; get mask
  81+ 5820 D9           	EXX
  82+ 5821 57           	LD D, A
  83+ 5822 1E FF        	LD E, #FF
  84+ 5824 37           	SCF
  85+ 5825              .M1:
  86+ 5825 18 FE        	JR .M1 ; this is self-modifying part
  87+ 5827 CB 12        	RL D
  88+ 5829 CB 13        	RL E
  89+ 582B CB 12        	RL D
  90+ 582D CB 13        	RL E
  91+ 582F CB 12        	RL D
  92+ 5831 CB 13        	RL E
  93+ 5833
  94+ 5833 46           	LD B, (HL)
  95+ 5834 0E 00        	LD C, 0
  96+ 5836              .M2:
  97+ 5836 18 FE        	JR .M2 ; also self-modifying part
  98+ 5838 CB 20        	SLA B
  99+ 583A CB 11        	RL C
 100+ 583C CB 20        	SLA B
 101+ 583E CB 11        	RL C
 102+ 5840 CB 20        	SLA B
 103+ 5842 CB 11        	RL C
 104+ 5844
 105+ 5844 D9           	EXX
 106+ 5845 1A           	LD A, (DE) ; background
 107+ 5846 D9           	EXX
 108+ 5847 A3           	AND E
 109+ 5848 B1           	OR C
 110+ 5849 D9           	EXX
 111+ 584A 12           	LD (DE), A
 112+ 584B
 113+ 584B 0A           	LD A, (BC)
 114+ 584C D9           	EXX
 115+ 584D A2           	AND D
 116+ 584E B0           	OR B
 117+ 584F 23           	INC HL
 118+ 5850 D9           	EXX
 119+ 5851 02           	LD (BC), A
 120+ 5852
 121+ 5852 23           	INC HL
 122+ 5853 13           	INC DE
 123+ 5854 03           	INC BC
 124+ 5855
 125+ 5855 08           	EX AF, AF'
 126+ 5856 3D           	DEC A
 127+ 5857 C2 1E 58     	JP NZ, SHIFT58
 128+ 585A C9           	RET
 129+ 585B              ; *******************************************************************************************************
 130+ 585B
 131+ 585B              ; *******************************************************************************************************
 132+ 585B              ; routine that shifts one row of characters
 133+ 585B              ; contains self-modifying code that is set-up from external function
 134+ 585B              ; input HL=pointer to mask data
 135+ 585B              ; input HL'=pointer to character data
 136+ 585B              ; input DE=output buffer containing background data
 137+ 585B              ; input A=number of characters to process
 138+ 585B              ; input IX=pointer to structure describing input data
 139+ 585B              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 140+ 585B              SHIFT_ROW:
 141+ 585B F5           	PUSH AF
 142+ 585C ED 53 41 5F  		LD (BLIT_TMP1), DE
 143+ 5860 E5           		PUSH HL
 144+ 5861 CD A4 58     			CALL .ADDYSHIFT
 145+ 5864 E1           		POP HL
 146+ 5865 ED 53 43 5F  		LD (BLIT_TMP2), DE ; DE+vertical shift
 147+ 5869              .L1:
 148+ 5869 3E 08        		LD A, 8
 149+ 586B DD 96 02     		SUB (IX+2) ; y shift
 150+ 586E              .CALL1:
 151+ 586E CD 00 00     		CALL 0
 152+ 5871 DD 7E 02     		LD A, (IX+2); y shift
 153+ 5874 B7           		OR A
 154+ 5875 28 26        		JR Z, .DONE
 155+ 5877 ED 5B 41 5F  		LD DE, (BLIT_TMP1)
 156+ 587B E5           		PUSH HL
 157+ 587C CD B2 58     			CALL .DETONEXTROW
 158+ 587F E1           		POP HL
 159+ 5880              .CALL2:
 160+ 5880 CD 00 00     		CALL 0
 161+ 5883 ED 5B 41 5F  		LD DE, (BLIT_TMP1)
 162+ 5887 E5           		PUSH HL
 163+ 5888 CD AC 58     			CALL .ADD8
 164+ 588B E1           		POP HL
 165+ 588C ED 53 41 5F  		LD (BLIT_TMP1), DE
 166+ 5890 ED 5B 43 5F  		LD DE, (BLIT_TMP2)
 167+ 5894 E5           		PUSH HL
 168+ 5895 CD AC 58     			CALL .ADD8
 169+ 5898 E1           		POP HL
 170+ 5899 ED 53 43 5F  		LD (BLIT_TMP2), DE ; DE+vertical shift
 171+ 589D              .DONE:
 172+ 589D F1           	POP AF
 173+ 589E 3D           	DEC A
 174+ 589F C8           	RET Z
 175+ 58A0 F5           	PUSH AF
 176+ 58A1 C3 69 58     	JP .L1
 177+ 58A4              .ADDYSHIFT:
 178+ 58A4 EB           	EX DE, HL
 179+ 58A5 16 00        	LD D, 0
 180+ 58A7 DD 5E 02     	LD E, (IX+2); y shift
 181+ 58AA 18 0C        	JR .MOVDEBC
 182+ 58AC              .ADD8:
 183+ 58AC 21 08 00     	LD HL, 8
 184+ 58AF C3 B8 58     	JP .MOVDEBC
 185+ 58B2              .DETONEXTROW:
 186+ 58B2 DD 6E 06     	LD L, (IX+6)
 187+ 58B5 DD 66 07     	LD H, (IX+7) ; bkg add to value
 188+ 58B8              .MOVDEBC:
 189+ 58B8 19           	ADD HL, DE
 190+ 58B9 54           	LD D, H
 191+ 58BA 5D           	LD E, L
 192+ 58BB 01 08 00     	LD BC, 8
 193+ 58BE 09           	ADD HL, BC
 194+ 58BF 44           	LD B, H
 195+ 58C0 4D           	LD C, L
 196+ 58C1 C9           	RET
 197+ 58C2              ; *******************************************************************************************************
 198+ 58C2
 199+ 58C2              ; *******************************************************************************************************
 200+ 58C2              ; function rotates mask and character data and applies it to background
 201+ 58C2              ; input IX=pointer to structure describing input data
 202+ 58C2              ; +0  DW horizontal shift count 0-7 (low byte used)
 203+ 58C2              ; +2  DW vertical shift count 0-7 (low byte used)
 204+ 58C2              ; +4  DW background data start;
 205+ 58C2              ; +6  DW background add to value to next row of background data
 206+ 58C2              ; +8  DW mask data start;
 207+ 58C2              ; +10  DW character data start;
 208+ 58C2              ; +12 DW character&mask add to value to next row of data
 209+ 58C2              ; +14 DW columns (low byte used)
 210+ 58C2              ; +16 DW rows (low byte used)
 211+ 58C2              SHIFT_MERGE_CHARACTER:
 212+ 58C2 DD 7E 00     	LD A, (IX) ; shift
 213+ 58C5 FE 05        	CP 5
 214+ 58C7 38 25        	JR C, .RIGHT
 215+ 58C9              	; shifts 5-7, use rotate towards left 1-3
 216+ 58C9 21 1E 58     	LD HL, SHIFT58
 217+ 58CC 22 6F 58     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 218+ 58CF 22 81 58     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 219+ 58D2 D6 05        	SUB 5
 220+ 58D4 28 0D        	JR Z, .L1
 221+ 58D6 87           	ADD A, A
 222+ 58D7 87           	ADD A, A
 223+ 58D8 67           	LD H, A
 224+ 58D9 2E 18        	LD L, #18 ; JR opcode
 225+ 58DB 22 25 58     	LD (SHIFT58.M1), HL
 226+ 58DE 22 36 58     	LD (SHIFT58.M2), HL
 227+ 58E1 18 32        	JR .DO
 228+ 58E3              .L1:
 229+ 58E3 21 00 00     	LD HL, 0 ; 2xNOP opcode
 230+ 58E6 22 25 58     	LD (SHIFT58.M1), HL
 231+ 58E9 22 36 58     	LD (SHIFT58.M2), HL
 232+ 58EC 18 27        	JR .DO
 233+ 58EE              .RIGHT:
 234+ 58EE              	; shifts 0-4, rotate towards right
 235+ 58EE 21 D9 57     	LD HL, SHIFT04
 236+ 58F1 22 6F 58     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 237+ 58F4 22 81 58     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 238+ 58F7 FE 04        	CP 4
 239+ 58F9 28 11        	JR Z, .R1
 240+ 58FB D6 04        	SUB 4
 241+ 58FD ED 44        	NEG
 242+ 58FF 87           	ADD A, A
 243+ 5900 87           	ADD A, A
 244+ 5901 67           	LD H, A
 245+ 5902 2E 18        	LD L, #18 ; JR opcode
 246+ 5904 22 E0 57     	LD (SHIFT04.M1), HL
 247+ 5907 22 F5 57     	LD (SHIFT04.M2), HL
 248+ 590A 18 09        	JR .DO
 249+ 590C              .R1:
 250+ 590C 21 00 00     	LD HL, 0 ; 2xNOP opcode
 251+ 590F 22 E0 57     	LD (SHIFT04.M1), HL
 252+ 5912 22 F5 57     	LD (SHIFT04.M2), HL
 253+ 5915              .DO:
 254+ 5915 DD 46 10     	LD B, (IX+16) ; rows
 255+ 5918 DD 6E 08     	LD L, (IX+8)
 256+ 591B DD 66 09     	LD H, (IX+9) ; mask data
 257+ 591E DD 5E 04     	LD E, (IX+4)
 258+ 5921 DD 56 05     	LD D, (IX+5) ; background data
 259+ 5924 D9           	EXX
 260+ 5925 DD 6E 0A     	LD L, (IX+10)
 261+ 5928 DD 66 0B     	LD H, (IX+11) ; character data
 262+ 592B D9           	EXX
 263+ 592C              .LOOP:
 264+ 592C C5           	PUSH BC
 265+ 592D E5           		PUSH HL
 266+ 592E D5           			PUSH DE
 267+ 592F D9           				EXX
 268+ 5930 E5           				PUSH HL
 269+ 5931 D9           					EXX
 270+ 5932 DD 7E 0E     					LD A, (IX+14) ; columns
 271+ 5935              .CALL:
 272+ 5935 CD 5B 58     					CALL SHIFT_ROW
 273+ 5938 E1           				POP HL
 274+ 5939 DD 5E 0C     				LD E, (IX+12)
 275+ 593C DD 56 0D     				LD D, (IX+13) ; char data to next row
 276+ 593F 19           				ADD HL, DE
 277+ 5940 D9           				EXX
 278+ 5941 E1           			POP HL
 279+ 5942 DD 5E 06     			LD E, (IX+6)
 280+ 5945 DD 56 07     			LD D, (IX+7) ; background to next row
 281+ 5948 19           			ADD HL, DE
 282+ 5949 EB           			EX DE, HL
 283+ 594A E1           		POP HL
 284+ 594B DD 4E 0C     		LD C, (IX+12)
 285+ 594E DD 46 0D     		LD B, (IX+13) ; char data to next row
 286+ 5951 09           		ADD HL, BC
 287+ 5952 C1           	POP BC
 288+ 5953 10 D7        	DJNZ .LOOP
 289+ 5955 C9           	RET
 290+ 5956              ; *******************************************************************************************************
 291+ 5956
 292+ 5956              ; *******************************************************************************************************
 293+ 5956              ; helper function DE \ 8
 294+ 5956              DEdiv8:
 295+ 5956 7B           	LD A,E
 296+ 5957 CB 2A        	SRA D
 297+ 5959 CB 1F            RR  A
 298+ 595B CB 2A            SRA D
 299+ 595D CB 1F            RR  A
 300+ 595F CB 2A            SRA D
 301+ 5961 CB 1F            RR  A
 302+ 5963 C9           	RET
 303+ 5964              ; *******************************************************************************************************
 304+ 5964
 305+ 5964               IF (1 == 1)
 306+ 5964              ; *******************************************************************************************************
 307+ 5964              ; function to handle BLIT basic extension through DEFUSR call in RAW format
 308+ 5964              ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 309+ 5964              ; +2  DW horizontal shift count 0-7 (low byte used)
 310+ 5964              ; +4  DW vertical shift count 0-7 (low byte used)
 311+ 5964              ; +6  DW background data start;
 312+ 5964              ; +8  DW background add to value to next row of background data
 313+ 5964              ; +10  DW mask data start;
 314+ 5964              ; +12  DW character data start;
 315+ 5964              ; +14 DW character&mask add to value to next row of data
 316+ 5964              ; +16 DW columns (low byte used)
 317+ 5964              ; +18 DW rows (low byte used)
 318+ 5964              ; will put ram in page 0 also, page 1 is already there
 319+ 5964              ;BLIT_DEFUSR:
 320+ 5964              ;	DI
 321+ 5964              ;	LD IY, .RET
 322+ 5964              ;	JP ENABLE_PAGE0
 323+ 5964              ;.RET:
 324+ 5964              ;	EI
 325+ 5964              ;	INC IX
 326+ 5964              ;	INC IX
 327+ 5964              ;	CALL SHIFT_MERGE_CHARACTER
 328+ 5964              ;
 329+ 5964              ;   POP DE
 330+ 5964              ;    POP BC
 331+ 5964              ;    JP RESTORE_PAGE_INFO
 332+ 5964              ; *******************************************************************************************************
 333+ 5964
 334+ 5964              ; *******************************************************************************************************
 335+ 5964              ; function to handle CALL BLIT basic extension in DEFUSR form
 336+ 5964              ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 337+ 5964              ; +02 x
 338+ 5964              ; +04 y
 339+ 5964              ; +06 char_data_pointer
 340+ 5964              ; +08 mask_data_pointer
 341+ 5964              ; +10 width
 342+ 5964              ; +12 height
 343+ 5964              ; +14 background_pointer
 344+ 5964              ; +16 background_width
 345+ 5964              ; BLIT ( INT x,
 346+ 5964              ;		 INT y,
 347+ 5964              ;		 INT char_data_pointer,
 348+ 5964              ;		 INT mask_data_pointer,
 349+ 5964              ;		 INT width (in characters),
 350+ 5964              ;		 INT height (in characters),
 351+ 5964              ;		 INT background_pointer (top left),
 352+ 5964              ;		 INT background_width (in characters),
 353+ 5964              BLIT_DEFUSR:
 354+ 5964 DD 5E 02     	LD E,(IX+2)
 355+ 5967 DD 56 03     	LD D,(IX+3)
 356+ 596A 7B           	LD A,E
 357+ 596B E6 07        	AND 7
 358+ 596D 32 45 5F     	LD (TMP_STRUCT+0),A
 359+ 5970 CD 56 59     	CALL DEdiv8
 360+ 5973 32 41 5F     	LD (BLIT_TMP+0),A
 361+ 5976 DD 5E 04     	LD E,(IX+4)
 362+ 5979 DD 56 05     	LD D,(IX+5)
 363+ 597C 7B           	LD A,E
 364+ 597D E6 07        	AND 7
 365+ 597F 32 47 5F     	LD (TMP_STRUCT+2),A
 366+ 5982 CD 56 59     	CALL DEdiv8
 367+ 5985 32 42 5F     	LD (BLIT_TMP+1),A
 368+ 5988 DD 6E 06     	LD L,(IX+6)
 369+ 598B DD 66 07     	LD H,(IX+7)
 370+ 598E 22 4F 5F     	LD (TMP_STRUCT+10),HL
 371+ 5991 DD 6E 08     	LD L,(IX+8)
 372+ 5994 DD 66 09     	LD H,(IX+9)
 373+ 5997 22 4D 5F     	LD (TMP_STRUCT+8),HL
 374+ 599A DD 7E 0A     	LD A,(IX+10)
 375+ 599D 32 53 5F     	LD (TMP_STRUCT+14),A
 376+ 59A0 DD 7E 0C     	LD A,(IX+12)
 377+ 59A3 32 55 5F     	LD (TMP_STRUCT+16),A
 378+ 59A6 DD 6E 0E     	LD L,(IX+14)
 379+ 59A9 DD 66 0F     	LD H,(IX+15)
 380+ 59AC 22 49 5F     	LD (TMP_STRUCT+4),HL
 381+ 59AF              	;LD A,(IX+16)
 382+ 59AF              	;LD (BLIT_TMP+2),A
 383+ 59AF
 384+ 59AF              	; calculate char&mask add to value
 385+ 59AF 26 00        	LD H,0
 386+ 59B1 3A 53 5F     	LD A,(TMP_STRUCT+14)
 387+ 59B4 6F           	LD L,A
 388+ 59B5 CD BF 5F     	CALL HLx8
 389+ 59B8 22 51 5F     	LD (TMP_STRUCT+12),HL
 390+ 59BB              	; calculate background add to value
 391+ 59BB 26 00        	LD H,0
 392+ 59BD DD 6E 10     	LD L,(IX+16)
 393+ 59C0 CD BF 5F     	CALL HLx8
 394+ 59C3 22 4B 5F     	LD (TMP_STRUCT+6),HL
 395+ 59C6              	; calculate pointer to background location
 396+ 59C6 21 00 00     	LD HL,0
 397+ 59C9 3A 42 5F     	LD A,(BLIT_TMP+1)
 398+ 59CC B7           	OR A
 399+ 59CD 28 08        	JR Z, .L1
 400+ 59CF 47           	LD B,A
 401+ 59D0 ED 5B 4B 5F  	LD DE,(TMP_STRUCT+6)
 402+ 59D4              .L0:
 403+ 59D4 19           	ADD HL, DE
 404+ 59D5 10 FD        	DJNZ .L0
 405+ 59D7              .L1:
 406+ 59D7 EB           	EX DE,HL
 407+ 59D8 26 00        	LD H,0
 408+ 59DA 3A 41 5F     	LD A,(BLIT_TMP+0)
 409+ 59DD 6F           	LD L,A
 410+ 59DE CD BF 5F     	CALL HLx8
 411+ 59E1 19           	ADD HL,DE
 412+ 59E2 ED 5B 49 5F  	LD DE,(TMP_STRUCT+4)
 413+ 59E6 19           	ADD HL,DE
 414+ 59E7 22 49 5F     	LD (TMP_STRUCT+4),HL
 415+ 59EA
 416+ 59EA FD 21 F1 59  	LD IY, .RET
 417+ 59EE C3 83 60     	JP ENABLE_PAGE0
 418+ 59F1              .RET:
 419+ 59F1 FB           	EI
 420+ 59F2 DD 21 45 5F  	LD IX, TMP_STRUCT
 421+ 59F6 CD C2 58     	CALL SHIFT_MERGE_CHARACTER
 422+ 59F9 C3 99 5F         JP COMMON_EXIT_CODE
 423+ 59FC              ; *******************************************************************************************************
 424+ 59FC               ENDIF
 425+ 59FC
 426+ 59FC               IF (0 == 1)
 427+ 59FC ~            ; *******************************************************************************************************
 428+ 59FC ~            ; function to handle CALL BLIT basic extension
 429+ 59FC ~            ; rotates 1-bit character drawing horizontally with mask and character data and
 430+ 59FC ~            ; fuses with background data and applies vertical shift too
 431+ 59FC ~            ; in form without pointers
 432+ 59FC ~            ; BLIT ( INT x,
 433+ 59FC ~            ;		 INT y,
 434+ 59FC ~            ;		 INT char_data_pointer,
 435+ 59FC ~            ;		 INT mask_data_pointer,
 436+ 59FC ~            ;		 INT width (in characters),
 437+ 59FC ~            ;		 INT height (in characters),
 438+ 59FC ~            ;		 INT background_pointer (top left),
 439+ 59FC ~            ;		 INT background_width (in characters),
 440+ 59FC ~            ; will put ram in page 0 also, page 1 is already there
 441+ 59FC ~            BLIT:
 442+ 59FC ~            	; opening (
 443+ 59FC ~            	CALL CHKCHAR
 444+ 59FC ~            	DB '('
 445+ 59FC ~            	; get x coordinate
 446+ 59FC ~            	LD IX, FRMQNT
 447+ 59FC ~            	CALL CALBAS
 448+ 59FC ~            	LD A, E
 449+ 59FC ~            	AND 7
 450+ 59FC ~            	LD (TMP_STRUCT+0), A
 451+ 59FC ~            	CALL DEdiv8
 452+ 59FC ~            	LD (BLIT_TMP+0),A
 453+ 59FC ~            	; comma
 454+ 59FC ~            	CALL CHKCHAR
 455+ 59FC ~            	DB ','
 456+ 59FC ~            	; get y coordinate
 457+ 59FC ~            	LD IX, FRMQNT
 458+ 59FC ~            	CALL CALBAS
 459+ 59FC ~            	LD A, E
 460+ 59FC ~            	AND 7
 461+ 59FC ~            	LD (TMP_STRUCT+2), A
 462+ 59FC ~            	CALL DEdiv8
 463+ 59FC ~            	LD (BLIT_TMP+1),A
 464+ 59FC ~            	; comma
 465+ 59FC ~            	CALL CHKCHAR
 466+ 59FC ~            	DB ','
 467+ 59FC ~            	; get char data pointer
 468+ 59FC ~            	LD IX, FRMQNT
 469+ 59FC ~            	CALL CALBAS
 470+ 59FC ~            	LD (TMP_STRUCT+10), DE
 471+ 59FC ~            	; comma
 472+ 59FC ~            	CALL CHKCHAR
 473+ 59FC ~            	DB ','
 474+ 59FC ~            	; get mask data pointer
 475+ 59FC ~            	LD IX, FRMQNT
 476+ 59FC ~            	CALL CALBAS
 477+ 59FC ~            	LD (TMP_STRUCT+8), DE
 478+ 59FC ~            	; comma
 479+ 59FC ~            	CALL CHKCHAR
 480+ 59FC ~            	DB ','
 481+ 59FC ~            	; get width
 482+ 59FC ~            	LD IX, FRMQNT
 483+ 59FC ~            	CALL CALBAS
 484+ 59FC ~            	LD A, E
 485+ 59FC ~            	LD (TMP_STRUCT+14), A
 486+ 59FC ~            	; comma
 487+ 59FC ~            	CALL CHKCHAR
 488+ 59FC ~            	DB ','
 489+ 59FC ~            	; get height
 490+ 59FC ~            	LD IX, FRMQNT
 491+ 59FC ~            	CALL CALBAS
 492+ 59FC ~            	LD A, E
 493+ 59FC ~            	LD (TMP_STRUCT+16), A
 494+ 59FC ~            	; comma
 495+ 59FC ~            	CALL CHKCHAR
 496+ 59FC ~            	DB ','
 497+ 59FC ~            	; get background pointer
 498+ 59FC ~            	LD IX, FRMQNT
 499+ 59FC ~            	CALL CALBAS
 500+ 59FC ~            	LD (TMP_STRUCT+4), DE
 501+ 59FC ~            	; comma
 502+ 59FC ~            	CALL CHKCHAR
 503+ 59FC ~            	DB ','
 504+ 59FC ~            	; get background width
 505+ 59FC ~            	LD IX, FRMQNT
 506+ 59FC ~            	CALL CALBAS
 507+ 59FC ~            	LD A, E
 508+ 59FC ~            	LD (BLIT_TMP+2), A
 509+ 59FC ~            	; ending )
 510+ 59FC ~            	CALL CHKCHAR
 511+ 59FC ~            	DB ')'
 512+ 59FC ~
 513+ 59FC ~            	PUSH HL ; save position in BASIC buffer
 514+ 59FC ~
 515+ 59FC ~            	; calculate char&mask add to value
 516+ 59FC ~            	LD H, 0
 517+ 59FC ~            	LD A, (TMP_STRUCT+14)
 518+ 59FC ~            	LD L, A
 519+ 59FC ~            	CALL HLx8
 520+ 59FC ~            	LD (TMP_STRUCT+12), HL
 521+ 59FC ~            	; calculate background add to value
 522+ 59FC ~            	LD H, 0
 523+ 59FC ~            	LD A, (BLIT_TMP+2)
 524+ 59FC ~            	LD L, A
 525+ 59FC ~            	CALL HLx8
 526+ 59FC ~            	LD (TMP_STRUCT+6), HL
 527+ 59FC ~            	; calculate pointer to background location
 528+ 59FC ~            	LD HL, 0
 529+ 59FC ~            	LD A,(BLIT_TMP+1)
 530+ 59FC ~            	OR A
 531+ 59FC ~            	JR Z, .L1
 532+ 59FC ~            	LD B,A
 533+ 59FC ~            	LD DE,(TMP_STRUCT+6)
 534+ 59FC ~            .L0:
 535+ 59FC ~            	ADD HL, DE
 536+ 59FC ~            	DJNZ .L0
 537+ 59FC ~            .L1:
 538+ 59FC ~            	EX DE,HL
 539+ 59FC ~            	LD H,0
 540+ 59FC ~            	LD A,(BLIT_TMP+0)
 541+ 59FC ~            	LD L,A
 542+ 59FC ~            	CALL HLx8
 543+ 59FC ~            	ADD HL,DE
 544+ 59FC ~            	LD DE,(TMP_STRUCT+4)
 545+ 59FC ~            	ADD HL,DE
 546+ 59FC ~            	LD (TMP_STRUCT+4),HL
 547+ 59FC ~
 548+ 59FC ~            	LD IY, .RET
 549+ 59FC ~            	JP ENABLE_PAGE0
 550+ 59FC ~            .RET:
 551+ 59FC ~            	EI
 552+ 59FC ~            	LD IX, TMP_STRUCT
 553+ 59FC ~            	CALL SHIFT_MERGE_CHARACTER
 554+ 59FC ~
 555+ 59FC ~                POP DE
 556+ 59FC ~                POP BC
 557+ 59FC ~                CALL RESTORE_PAGE_INFO
 558+ 59FC ~            	XOR A
 559+ 59FC ~            	POP HL
 560+ 59FC ~            	RET
 561+ 59FC ~            ; *******************************************************************************************************
 562+ 59FC               ENDIF
# file closed: asm\BLIT.asm
 164  59FC               ENDIF
 165  59FC
 166  59FC               IF (TILE_CMDS == 1)
 167  59FC               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
   1+ 59FC              ; *******************************************************************************************************
   2+ 59FC              ; generic function to implement tiling
   3+ 59FC              ; should be modified to call appropriate function for memory or vram
   4+ 59FC              ; input IX=pointer to following structure
   5+ 59FC              ; +00 tile_data_ptr
   6+ 59FC              ; +02 tile_rows
   7+ 59FC              ; +04 tile_columns
   8+ 59FC              ; +06 destination_address
   9+ 59FC              ; +08 dest_to_next_row_add_to_value
  10+ 59FC              ; +10 num_horizontal_tiles
  11+ 59FC              ; +12 num_vertical_tiles
  12+ 59FC              ; modifies AF, BC, DE, HL
  13+ 59FC              TILE:
  14+ 59FC DD 6E 06     	LD L, (IX+6)
  15+ 59FF DD 66 07     	LD H, (IX+7) ; destination address
  16+ 5A02 22 41 5F     	LD (TILETMP1), HL
  17+ 5A05 DD 46 0C     	LD B, (IX+12) ; vertical tile number
  18+ 5A08              .L1:
  19+ 5A08 C5           	PUSH BC
  20+ 5A09 DD 6E 00     		LD L, (IX+0)
  21+ 5A0C DD 66 01     		LD H, (IX+1) ; tile address
  22+ 5A0F 22 43 5F     		LD (TILETMP2), HL
  23+ 5A12 DD 46 02     		LD B, (IX+2) ; tile rows
  24+ 5A15              .L2:
  25+ 5A15 C5           		PUSH BC
  26+ 5A16 CD 00 00     .CALL1:		CALL 0
  27+ 5A19 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
  28+ 5A1C              .L3:
  29+ 5A1C C5           			PUSH BC
  30+ 5A1D 2A 43 5F     				LD HL, (TILETMP2)
  31+ 5A20 DD 46 04     				LD B, (IX+4) ; tile columns
  32+ 5A23              .L4:
  33+ 5A23 C5           				PUSH BC
  34+ 5A24              .CALL2:
  35+ 5A24 CD 00 00     					CALL 0
  36+ 5A27 C1           				POP BC
  37+ 5A28 10 F9        				DJNZ .L4
  38+ 5A2A C1           			POP BC
  39+ 5A2B 10 EF        			DJNZ .L3
  40+ 5A2D 22 43 5F     			LD (TILETMP2), HL
  41+ 5A30 2A 41 5F     			LD HL, (TILETMP1)
  42+ 5A33 DD 5E 08     			LD E, (IX+8)
  43+ 5A36 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
  44+ 5A39 19           			ADD HL, DE
  45+ 5A3A 22 41 5F     			LD (TILETMP1), HL
  46+ 5A3D C1           		POP BC
  47+ 5A3E 10 D5        		DJNZ .L2
  48+ 5A40 C1           	POP BC
  49+ 5A41 10 C5        	DJNZ .L1
  50+ 5A43 C9           	RET
  51+ 5A44              ; *******************************************************************************************************
  52+ 5A44
  53+ 5A44               IF (1 == 1)
  54+ 5A44              ; *******************************************************************************************************
  55+ 5A44              ; same as TILERAM but for DEFUSR approach
  56+ 5A44              ; input IX=pointer to input array, real data from +2
  57+ 5A44              ; +02 = tile data pointer
  58+ 5A44              ; +04 = tile columns
  59+ 5A44              ; +06 = tile rows
  60+ 5A44              ; +08 = destination pointer
  61+ 5A44              ; +10 = destination columns
  62+ 5A44              ; +12 = destination rows
  63+ 5A44              ; +14 = destination begin column
  64+ 5A44              ; +16 = destination begin row
  65+ 5A44              ; +18 = number of tiles horizontally
  66+ 5A44              ; +20 = number of tiles vertically
  67+ 5A44              ; *******************************************************************************************************
  68+ 5A44              TILERAM_DEFUSR:
  69+ 5A44              	; tile data pointer
  70+ 5A44 DD 6E 02     	LD L,(IX+2)
  71+ 5A47 DD 66 03     	LD H,(IX+3)
  72+ 5A4A 22 45 5F     	LD (TMP_STRUCT+0),HL
  73+ 5A4D              	; tile columns
  74+ 5A4D DD 6E 04     	LD L,(IX+4)
  75+ 5A50 DD 66 05     	LD H,(IX+5)
  76+ 5A53 22 49 5F     	LD (TMP_STRUCT+4),HL
  77+ 5A56              	; tile rows
  78+ 5A56 DD 6E 06     	LD L,(IX+6)
  79+ 5A59 DD 66 07     	LD H,(IX+7)
  80+ 5A5C 22 47 5F     	LD (TMP_STRUCT+2),HL
  81+ 5A5F              	; destintion pointer
  82+ 5A5F DD 6E 08     	LD L,(IX+8)
  83+ 5A62 DD 66 09     	LD H,(IX+9)
  84+ 5A65 22 4B 5F     	LD (TMP_STRUCT+6),HL
  85+ 5A68              	; destination columns
  86+ 5A68 DD 7E 0A     	LD A,(IX+10)
  87+ 5A6B 32 41 5F     	LD (BLIT_TMP+0),A
  88+ 5A6E              	; destination rows
  89+ 5A6E DD 7E 0C     	LD A,(IX+12)
  90+ 5A71 32 42 5F     	LD (BLIT_TMP+1),A
  91+ 5A74              	; destination begin column
  92+ 5A74 DD 7E 0E     	LD A,(IX+14)
  93+ 5A77 32 43 5F     	LD (BLIT_TMP+2),A
  94+ 5A7A              	; destination begin row
  95+ 5A7A DD 7E 10     	LD A,(IX+16)
  96+ 5A7D 32 44 5F     	LD (BLIT_TMP+3),A
  97+ 5A80              	; number of tiles horizontally
  98+ 5A80 DD 6E 12     	LD L,(IX+18)
  99+ 5A83 DD 66 13     	LD H,(IX+19)
 100+ 5A86 22 4F 5F     	LD (TMP_STRUCT+10),HL
 101+ 5A89              	; number of tiles vertically
 102+ 5A89 DD 6E 14     	LD L,(IX+20)
 103+ 5A8C DD 66 15     	LD H,(IX+21)
 104+ 5A8F 22 51 5F     	LD (TMP_STRUCT+12),HL
 105+ 5A92               IF (0 == 1) ; otherwise we just continue with code below
 106+ 5A92 ~            	JP TILERAM.COMMON
 107+ 5A92               ENDIF
 108+ 5A92               ENDIF
 109+ 5A92
 110+ 5A92              ; *******************************************************************************************************
 111+ 5A92              ; function to handle CALL TILERAM basic extension
 112+ 5A92              ; fills memory with tiles
 113+ 5A92              ; TILERAM ( INT tile_data_pointer,
 114+ 5A92              ;			INT tile_columns,
 115+ 5A92              ;			INT tile_rows,
 116+ 5A92              ;			INT destination_pointer,
 117+ 5A92              ;			INT destination_columns,
 118+ 5A92              ;			INT destination_rows,
 119+ 5A92              ;			INT destination_begin_column,
 120+ 5A92              ;			INT destination_begin_row,
 121+ 5A92              ;			INT number_of_tiles_horizontally,
 122+ 5A92              ;			INT	number_of_tiles_vertically )
 123+ 5A92              ; will put ram in page 0 also, page 1 is already there
 124+ 5A92              TILERAM:
 125+ 5A92               IF (0 == 1)
 126+ 5A92 ~            	; opening (
 127+ 5A92 ~            	CALL CHKCHAR
 128+ 5A92 ~            	DB '('
 129+ 5A92 ~            	; get tile data pointer coordinate
 130+ 5A92 ~            	LD IX, FRMQNT
 131+ 5A92 ~            	CALL CALBAS
 132+ 5A92 ~            	LD (TMP_STRUCT+0), DE
 133+ 5A92 ~            	; comma
 134+ 5A92 ~            	CALL CHKCHAR
 135+ 5A92 ~            	DB ','
 136+ 5A92 ~            	; get tile columns
 137+ 5A92 ~            	LD IX, FRMQNT
 138+ 5A92 ~            	CALL CALBAS
 139+ 5A92 ~            	LD (TMP_STRUCT+4), DE
 140+ 5A92 ~            	; comma
 141+ 5A92 ~            	CALL CHKCHAR
 142+ 5A92 ~            	DB ','
 143+ 5A92 ~            	; get tile columns
 144+ 5A92 ~            	LD IX, FRMQNT
 145+ 5A92 ~            	CALL CALBAS
 146+ 5A92 ~            	LD (TMP_STRUCT+2), DE
 147+ 5A92 ~            	; comma
 148+ 5A92 ~            	CALL CHKCHAR
 149+ 5A92 ~            	DB ','
 150+ 5A92 ~            	; get destintion pointer
 151+ 5A92 ~            	LD IX, FRMQNT
 152+ 5A92 ~            	CALL CALBAS
 153+ 5A92 ~            	LD (TMP_STRUCT+6), DE
 154+ 5A92 ~            	; comma
 155+ 5A92 ~            	CALL CHKCHAR
 156+ 5A92 ~            	DB ','
 157+ 5A92 ~            	; get destination columns
 158+ 5A92 ~            	LD IX, FRMQNT
 159+ 5A92 ~            	CALL CALBAS
 160+ 5A92 ~            	LD A, E
 161+ 5A92 ~            	LD (BLIT_TMP+0), A
 162+ 5A92 ~            	; comma
 163+ 5A92 ~            	CALL CHKCHAR
 164+ 5A92 ~            	DB ','
 165+ 5A92 ~            	; get destination rows
 166+ 5A92 ~            	LD IX, FRMQNT
 167+ 5A92 ~            	CALL CALBAS
 168+ 5A92 ~            	LD A, E
 169+ 5A92 ~            	LD (BLIT_TMP+1), A
 170+ 5A92 ~            	; comma
 171+ 5A92 ~            	CALL CHKCHAR
 172+ 5A92 ~            	DB ','
 173+ 5A92 ~            	; get destination begin column
 174+ 5A92 ~            	LD IX, FRMQNT
 175+ 5A92 ~            	CALL CALBAS
 176+ 5A92 ~            	LD A, E
 177+ 5A92 ~            	LD (BLIT_TMP+2), A
 178+ 5A92 ~            	; comma
 179+ 5A92 ~            	CALL CHKCHAR
 180+ 5A92 ~            	DB ','
 181+ 5A92 ~            	; get destination begin row
 182+ 5A92 ~            	LD IX, FRMQNT
 183+ 5A92 ~            	CALL CALBAS
 184+ 5A92 ~            	LD A, E
 185+ 5A92 ~            	LD (BLIT_TMP+3), A
 186+ 5A92 ~            	; comma
 187+ 5A92 ~            	CALL CHKCHAR
 188+ 5A92 ~            	DB ','
 189+ 5A92 ~            	; get number of tiles horizontally
 190+ 5A92 ~            	LD IX, FRMQNT
 191+ 5A92 ~            	CALL CALBAS
 192+ 5A92 ~            	LD (TMP_STRUCT+10), DE
 193+ 5A92 ~            	; comma
 194+ 5A92 ~            	CALL CHKCHAR
 195+ 5A92 ~            	DB ','
 196+ 5A92 ~            	; get number of tiles vertically
 197+ 5A92 ~            	LD IX, FRMQNT
 198+ 5A92 ~            	CALL CALBAS
 199+ 5A92 ~            	LD (TMP_STRUCT+12), DE
 200+ 5A92 ~            	; ending )
 201+ 5A92 ~            	CALL CHKCHAR
 202+ 5A92 ~            	DB ')'
 203+ 5A92               ENDIF
 204+ 5A92              .COMMON:
 205+ 5A92 E5           	PUSH HL ; save position in BASIC buffer
 206+ 5A93
 207+ 5A93              	; calculate destination add to value
 208+ 5A93 26 00        	LD H, 0
 209+ 5A95 3A 41 5F     	LD A, (BLIT_TMP+0)
 210+ 5A98 6F           	LD L, A
 211+ 5A99 CD BF 5F     	CALL HLx8
 212+ 5A9C 22 4D 5F     	LD (TMP_STRUCT+8), HL
 213+ 5A9F              	; calculate pointer to background location
 214+ 5A9F 21 00 00     	LD HL, 0
 215+ 5AA2 3A 44 5F     	LD A,(BLIT_TMP+3)
 216+ 5AA5 B7           	OR A
 217+ 5AA6 28 08        	JR Z, .L1
 218+ 5AA8 47           	LD B,A
 219+ 5AA9 ED 5B 4D 5F  	LD DE,(TMP_STRUCT+8)
 220+ 5AAD              .L0:
 221+ 5AAD 19           	ADD HL, DE
 222+ 5AAE 10 FD        	DJNZ .L0
 223+ 5AB0              .L1:
 224+ 5AB0 EB           	EX DE,HL
 225+ 5AB1 26 00        	LD H,0
 226+ 5AB3 3A 43 5F     	LD A,(BLIT_TMP+2)
 227+ 5AB6 6F           	LD L,A
 228+ 5AB7 CD BF 5F     	CALL HLx8
 229+ 5ABA 19           	ADD HL,DE
 230+ 5ABB ED 5B 4B 5F  	LD DE,(TMP_STRUCT+6)
 231+ 5ABF 19           	ADD HL,DE
 232+ 5AC0 22 4B 5F     	LD (TMP_STRUCT+6),HL
 233+ 5AC3 FD 21 CA 5A  	LD IY, .RET
 234+ 5AC7 C3 83 60     	JP ENABLE_PAGE0
 235+ 5ACA              .RET:
 236+ 5ACA FB           	EI
 237+ 5ACB              	; set RAM functions to call
 238+ 5ACB 21 E1 5A     	LD HL, .TILECOPY
 239+ 5ACE 22 25 5A     	LD (TILE.CALL2+1), HL
 240+ 5AD1 21 F2 5A     	LD HL, .SETDESTROW
 241+ 5AD4 22 17 5A     	LD (TILE.CALL1+1), HL
 242+ 5AD7 DD 21 45 5F  	LD IX,TMP_STRUCT
 243+ 5ADB CD FC 59     	CALL TILE
 244+ 5ADE C3 99 5F     	JP COMMON_EXIT_CODE
 245+ 5AE1              .TILECOPY:
 246+ 5AE1 ED A0       > LDI
 246+ 5AE3 ED A0       > LDI
 246+ 5AE5 ED A0       > LDI
 246+ 5AE7 ED A0       > LDI
 246+ 5AE9 ED A0       > LDI
 246+ 5AEB ED A0       > LDI
 246+ 5AED ED A0       > LDI
 246+ 5AEF ED A0       > LDI
 247+ 5AF1 C9           	RET
 248+ 5AF2              .SETDESTROW:
 249+ 5AF2 ED 5B 41 5F  	LD DE, (TILETMP1)
 250+ 5AF6 C9           	RET
 251+ 5AF7              ; *******************************************************************************************************
 252+ 5AF7
 253+ 5AF7               IF (1 == 1)
 254+ 5AF7              ; *******************************************************************************************************
 255+ 5AF7              ; same as TILEVRM but for DEFUSR approach
 256+ 5AF7              ; input IX=pointer to input array, real data from +2
 257+ 5AF7              ; +02 = tile data pointer
 258+ 5AF7              ; +04 = tile columns
 259+ 5AF7              ; +06 = tile rows
 260+ 5AF7              ; +08 = destination begin column
 261+ 5AF7              ; +10 = destination begin row
 262+ 5AF7              ; +12 = number of tiles horizontally
 263+ 5AF7              ; +14 = number of tiles vertically
 264+ 5AF7              ; *******************************************************************************************************
 265+ 5AF7              TILEVRM_DEFUSR:
 266+ 5AF7              	; tile data pointer
 267+ 5AF7 DD 6E 02     	LD L,(IX+2)
 268+ 5AFA DD 66 03     	LD H,(IX+3)
 269+ 5AFD 22 45 5F     	LD (TMP_STRUCT+0),HL
 270+ 5B00              	; tile columns
 271+ 5B00 DD 6E 04     	LD L,(IX+4)
 272+ 5B03 DD 66 05     	LD H,(IX+5)
 273+ 5B06 22 49 5F     	LD (TMP_STRUCT+4),HL
 274+ 5B09              	; tile rows
 275+ 5B09 DD 6E 06     	LD L,(IX+6)
 276+ 5B0C DD 66 07     	LD H,(IX+7)
 277+ 5B0F 22 47 5F     	LD (TMP_STRUCT+2),HL
 278+ 5B12              	; destination begin column
 279+ 5B12 DD 7E 08     	LD A,(IX+8)
 280+ 5B15 32 43 5F     	LD (BLIT_TMP+2),A
 281+ 5B18              	; destination begin row
 282+ 5B18 DD 7E 0A     	LD A,(IX+10)
 283+ 5B1B 32 44 5F     	LD (BLIT_TMP+3),A
 284+ 5B1E              	; number of tiles horizontally
 285+ 5B1E DD 6E 0C     	LD L,(IX+12)
 286+ 5B21 DD 66 0D     	LD H,(IX+13)
 287+ 5B24 22 4F 5F     	LD (TMP_STRUCT+10),HL
 288+ 5B27              	; number of tiles vertically
 289+ 5B27 DD 6E 0E     	LD L,(IX+14)
 290+ 5B2A DD 66 0F     	LD H,(IX+15)
 291+ 5B2D 22 51 5F     	LD (TMP_STRUCT+12),HL
 292+ 5B30               IF (0 == 1) ; otherwise we just continue with code below
 293+ 5B30 ~            	JP TILEVRM.COMMON
 294+ 5B30               ENDIF
 295+ 5B30               ENDIF
 296+ 5B30
 297+ 5B30              ; *******************************************************************************************************
 298+ 5B30              ; function to handle CALL TILEVRM basic extension
 299+ 5B30              ; fills vram with tiles
 300+ 5B30              ; TILEVRM ( INT tile_data_pointer,
 301+ 5B30              ;			INT tile_columns,
 302+ 5B30              ;			INT tile_rows,
 303+ 5B30              ;			INT destination_begin_column,
 304+ 5B30              ;			INT destination_begin_row,
 305+ 5B30              ;			INT number_of_tiles_horizontally,
 306+ 5B30              ;			INT	number_of_tiles_vertically )
 307+ 5B30              ; will put ram in page 0 also, page 1 is already there
 308+ 5B30              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
 309+ 5B30              TILEVRM:
 310+ 5B30               IF (0 == 1)
 311+ 5B30 ~            	; opening (
 312+ 5B30 ~            	CALL CHKCHAR
 313+ 5B30 ~            	DB '('
 314+ 5B30 ~            	; get tile data pointer coordinate
 315+ 5B30 ~            	LD IX, FRMQNT
 316+ 5B30 ~            	CALL CALBAS
 317+ 5B30 ~            	LD (TMP_STRUCT+0), DE
 318+ 5B30 ~            	; comma
 319+ 5B30 ~            	CALL CHKCHAR
 320+ 5B30 ~            	DB ','
 321+ 5B30 ~            	; get tile columns
 322+ 5B30 ~            	LD IX, FRMQNT
 323+ 5B30 ~            	CALL CALBAS
 324+ 5B30 ~            	LD (TMP_STRUCT+4), DE
 325+ 5B30 ~            	; comma
 326+ 5B30 ~            	CALL CHKCHAR
 327+ 5B30 ~            	DB ','
 328+ 5B30 ~            	; get tile columns
 329+ 5B30 ~            	LD IX, FRMQNT
 330+ 5B30 ~            	CALL CALBAS
 331+ 5B30 ~            	LD (TMP_STRUCT+2), DE
 332+ 5B30 ~            	; comma
 333+ 5B30 ~            	CALL CHKCHAR
 334+ 5B30 ~            	DB ','
 335+ 5B30 ~            	; get destination begin column
 336+ 5B30 ~            	LD IX, FRMQNT
 337+ 5B30 ~            	CALL CALBAS
 338+ 5B30 ~            	LD A, E
 339+ 5B30 ~            	LD (BLIT_TMP+2), A
 340+ 5B30 ~            	; comma
 341+ 5B30 ~            	CALL CHKCHAR
 342+ 5B30 ~            	DB ','
 343+ 5B30 ~            	; get destination begin row
 344+ 5B30 ~            	LD IX, FRMQNT
 345+ 5B30 ~            	CALL CALBAS
 346+ 5B30 ~            	LD A, E
 347+ 5B30 ~            	LD (BLIT_TMP+3), A
 348+ 5B30 ~            	; comma
 349+ 5B30 ~            	CALL CHKCHAR
 350+ 5B30 ~            	DB ','
 351+ 5B30 ~            	; get number of tiles horizontally
 352+ 5B30 ~            	LD IX, FRMQNT
 353+ 5B30 ~            	CALL CALBAS
 354+ 5B30 ~            	LD (TMP_STRUCT+10), DE
 355+ 5B30 ~            	; comma
 356+ 5B30 ~            	CALL CHKCHAR
 357+ 5B30 ~            	DB ','
 358+ 5B30 ~            	; get number of tiles vertically
 359+ 5B30 ~            	LD IX, FRMQNT
 360+ 5B30 ~            	CALL CALBAS
 361+ 5B30 ~            	LD (TMP_STRUCT+12), DE
 362+ 5B30 ~            	; ending )
 363+ 5B30 ~            	CALL CHKCHAR
 364+ 5B30 ~            	DB ')'
 365+ 5B30               ENDIF
 366+ 5B30
 367+ 5B30              .COMMON:
 368+ 5B30 E5           	PUSH HL ; save position in BASIC buffer
 369+ 5B31
 370+ 5B31              	; calculate destination add to value
 371+ 5B31 21 00 01     	LD HL, 256
 372+ 5B34 22 4D 5F     	LD (TMP_STRUCT+8), HL
 373+ 5B37              	; calculate pointer to background location
 374+ 5B37 3A 44 5F     	LD A,(BLIT_TMP+3)
 375+ 5B3A 67           	LD H,A
 376+ 5B3B 2E 00        	LD L,0
 377+ 5B3D EB           	EX DE,HL
 378+ 5B3E 26 00        	LD H,0
 379+ 5B40 3A 43 5F     	LD A,(BLIT_TMP+2)
 380+ 5B43 6F           	LD L,A
 381+ 5B44 CD BF 5F     	CALL HLx8
 382+ 5B47 19           	ADD HL,DE
 383+ 5B48 ED 5B CB F3  	LD DE,(GRPCGP)
 384+ 5B4C 19           	ADD HL,DE
 385+ 5B4D 22 4B 5F     	LD (TMP_STRUCT+6),HL
 386+ 5B50 FD 21 57 5B  	LD IY, .RET
 387+ 5B54 C3 83 60     	JP ENABLE_PAGE0
 388+ 5B57              .RET:
 389+ 5B57 FB           	EI
 390+ 5B58              	; set RAM functions to call
 391+ 5B58 21 6E 5B     	LD HL, .TILECOPY
 392+ 5B5B 22 25 5A     	LD (TILE.CALL2+1), HL
 393+ 5B5E 21 74 5B     	LD HL, .SETDESTROW
 394+ 5B61 22 17 5A     	LD (TILE.CALL1+1), HL
 395+ 5B64 DD 21 45 5F  	LD IX,TMP_STRUCT
 396+ 5B68 CD FC 59     	CALL TILE
 397+ 5B6B C3 99 5F     	JP COMMON_EXIT_CODE
 398+ 5B6E              .TILECOPY:
 399+ 5B6E 01 98 08     	LD BC, #0898
 400+ 5B71 C3 B7 5F     	JP BBYTECOPY_NO_C
 401+ 5B74              .SETDESTROW:
 402+ 5B74 2A 41 5F     	LD HL, (TILETMP1)
 403+ 5B77 F3           	DI
 404+ 5B78 CD A0 5F     	CALL SETWRT_LOCAL_WRITE
 405+ 5B7B FB           	EI
 406+ 5B7C C9           	RET
 407+ 5B7D              ; *******************************************************************************************************
 408+ 5B7D
# file closed: asm\TILE.asm
 168  5B7D               ENDIF
 169  5B7D
 170  5B7D               IF (COLL_CMD == 1)
 171  5B7D               INCLUDE "COLLISION.asm"
# file opened: asm\COLLISION.asm
   1+ 5B7D              ; generic collision checking routines
   2+ 5B7D              ; in BASIC we use rectangle structure array DIM R%(7,n) of the format
   3+ 5B7D              ; R%(0,n) is active flag, <>0 active / 0 skipped in checks
   4+ 5B7D              ; R%(1,n) is either upper left x coordinate or sprite id (0-31) depending on R(7,n)
   5+ 5B7D              ; R%(2,n) is either upper left y coordinate or unused depending on R(7,n)
   6+ 5B7D              ; R%(3,n) x offset where rectangle begins
   7+ 5B7D              ; R%(4,n) y offset where rectangle begins
   8+ 5B7D              ; R%(5,n) is width
   9+ 5B7D              ; R%(6,n) is height
  10+ 5B7D              ; R%(7,0) is type, 0=generic where R%(1,0) contains x coordinate
  11+ 5B7D              ;                  <>0 sprite where R%(1,0) contains sprite id
  12+ 5B7D              ; for type sprite, upper left coordinates are taken from sprite attribute array
  13+ 5B7D
  14+ 5B7D              ; ************************************************************************************************
  15+ 5B7D              ; quick test if HL<=DE<=HL+BC
  16+ 5B7D              ; input BC=width, DE=x, HL=min
  17+ 5B7D              ; if not true flag C set
  18+ 5B7D              ; modifies AF
  19+ 5B7D              GENERIC_INNER_CHECK:
  20+ 5B7D E5               PUSH HL
  21+ 5B7E D5               PUSH DE
  22+ 5B7F EB               EX DE,HL
  23+ 5B80 A7               AND A
  24+ 5B81 ED 52            SBC HL, DE
  25+ 5B83 FA 91 5B         JP M, .GENERIC_INNER_CHECK_NOT
  26+ 5B86 A7               AND A
  27+ 5B87 ED 42            SBC HL, BC
  28+ 5B89 28 03            JR Z, .L2
  29+ 5B8B F2 91 5B         JP P, .GENERIC_INNER_CHECK_NOT
  30+ 5B8E              .L2:
  31+ 5B8E A7               AND A
  32+ 5B8F 18 01            JR .EXIT
  33+ 5B91              .GENERIC_INNER_CHECK_NOT:
  34+ 5B91 37               SCF
  35+ 5B92              .EXIT:
  36+ 5B92 D1               POP DE
  37+ 5B93 E1               POP HL
  38+ 5B94 C9               RET
  39+ 5B95              ; ************************************************************************************************
  40+ 5B95
  41+ 5B95              ; ************************************************************************************************
  42+ 5B95              ; function to check if rectangles are overlapping
  43+ 5B95              ; input IX=IY=pointer to struct
  44+ 5B95              ;  +00 active flag
  45+ 5B95              ;  +02 x coordinate
  46+ 5B95              ;  +04 y coordinate
  47+ 5B95              ;  +06 x offset where rectangle begins
  48+ 5B95              ;  +08 y offset where rectangle begins
  49+ 5B95              ;  +10 width
  50+ 5B95              ;  +12 height
  51+ 5B95              ; where IY is used to read +2 and +4, and IX to read +6, +8, +10 and +12
  52+ 5B95              ; this is a hack to allow location being taken from sprite attributes table
  53+ 5B95              ; input TMP_STRUCT data
  54+ 5B95              ;  +00 x coordinate
  55+ 5B95              ;  +02 y coordinate
  56+ 5B95              ;  +04 width
  57+ 5B95              ;  +06 height
  58+ 5B95              ; returns CF=1 if not overlapping, CF=0 if overlapping
  59+ 5B95              RECTANGLE_OVERLAP_CHECK:
  60+ 5B95                  ; first check which rectangle is higher
  61+ 5B95 DD 6E 0C         LD L,(IX+12)
  62+ 5B98 DD 66 0D         LD H,(IX+13)
  63+ 5B9B ED 5B 4B 5F      LD DE,(TMP_STRUCT+6)
  64+ 5B9F A7               AND A
  65+ 5BA0 ED 52            SBC HL,DE
  66+ 5BA2 FD 6E 04         LD L,(IY+4)
  67+ 5BA5 FD 66 05         LD H,(IY+5)
  68+ 5BA8 DD 5E 08         LD E,(IX+8)
  69+ 5BAB DD 56 09         LD D,(IX+9)
  70+ 5BAE FA CE 5B         JP M,.L1
  71+ 5BB1                  ; equally high or IX defined one higher
  72+ 5BB1                  ; check upper boundary
  73+ 5BB1 19               ADD HL,DE
  74+ 5BB2 ED 5B 47 5F      LD DE,(TMP_STRUCT+2)
  75+ 5BB6 DD 4E 0C         LD C,(IX+12)
  76+ 5BB9 DD 46 0D         LD B,(IX+13)
  77+ 5BBC CD 7D 5B         CALL GENERIC_INNER_CHECK
  78+ 5BBF 30 29            JR NC,.INSIDE
  79+ 5BC1                  ; check lower boundary
  80+ 5BC1 E5               PUSH HL
  81+ 5BC2 2A 4B 5F         LD HL,(TMP_STRUCT+6)
  82+ 5BC5 19               ADD HL,DE
  83+ 5BC6 EB               EX DE,HL
  84+ 5BC7 E1               POP HL
  85+ 5BC8 CD 7D 5B         CALL GENERIC_INNER_CHECK
  86+ 5BCB 30 1D            JR NC,.INSIDE
  87+ 5BCD C9               RET ; not overlapping
  88+ 5BCE              .L1:
  89+ 5BCE                  ; rectangle defined in TMP_STRUCT is higher
  90+ 5BCE 19               ADD HL,DE
  91+ 5BCF EB               EX DE,HL
  92+ 5BD0 2A 47 5F         LD HL,(TMP_STRUCT+2)
  93+ 5BD3 ED 4B 4B 5F      LD BC,(TMP_STRUCT+6)
  94+ 5BD7 CD 7D 5B         CALL GENERIC_INNER_CHECK
  95+ 5BDA 30 0E            JR NC,.INSIDE
  96+ 5BDC E5               PUSH HL
  97+ 5BDD DD 6E 0C         LD L,(IX+12)
  98+ 5BE0 DD 66 0D         LD H,(IX+13)
  99+ 5BE3 19               ADD HL,DE
 100+ 5BE4 EB               EX DE,HL
 101+ 5BE5 E1               POP HL
 102+ 5BE6 CD 7D 5B         CALL GENERIC_INNER_CHECK
 103+ 5BE9 D8               RET C
 104+ 5BEA              .INSIDE:
 105+ 5BEA                  ; check x coordinate
 106+ 5BEA                  ; first check which rectangle is wider
 107+ 5BEA DD 6E 0A         LD L,(IX+10)
 108+ 5BED DD 66 0B         LD H,(IX+11)
 109+ 5BF0 ED 5B 49 5F      LD DE,(TMP_STRUCT+4)
 110+ 5BF4 A7               AND A
 111+ 5BF5 ED 52            SBC HL,DE
 112+ 5BF7 FD 6E 02         LD L,(IY+2)
 113+ 5BFA FD 66 03         LD H,(IY+3)
 114+ 5BFD DD 5E 06         LD E,(IX+6)
 115+ 5C00 DD 56 07         LD D,(IX+7)
 116+ 5C03 FA 1F 5C         JP M,.L2
 117+ 5C06                  ; equally wide or IX defined one wider
 118+ 5C06                  ; check left boundary
 119+ 5C06 19               ADD HL,DE
 120+ 5C07 ED 5B 45 5F      LD DE,(TMP_STRUCT+0)
 121+ 5C0B DD 4E 0A         LD C,(IX+10)
 122+ 5C0E DD 46 0B         LD B,(IX+11)
 123+ 5C11 CD 7D 5B         CALL GENERIC_INNER_CHECK
 124+ 5C14 D0               RET NC ; overlap
 125+ 5C15                  ; check right boundary
 126+ 5C15 E5               PUSH HL
 127+ 5C16 2A 49 5F         LD HL,(TMP_STRUCT+4)
 128+ 5C19 19               ADD HL,DE
 129+ 5C1A EB               EX DE,HL
 130+ 5C1B E1               POP HL
 131+ 5C1C C3 7D 5B         JP GENERIC_INNER_CHECK ; CF and result set by fn call
 132+ 5C1F              .L2:
 133+ 5C1F                  ; rectangle defined in TMP_STRUCT is higher
 134+ 5C1F 19               ADD HL,DE
 135+ 5C20 EB               EX DE,HL
 136+ 5C21 2A 45 5F         LD HL,(TMP_STRUCT+0)
 137+ 5C24 ED 4B 49 5F      LD BC,(TMP_STRUCT+4)
 138+ 5C28 CD 7D 5B         CALL GENERIC_INNER_CHECK
 139+ 5C2B D0               RET NC ; overlap
 140+ 5C2C E5               PUSH HL
 141+ 5C2D DD 6E 0A         LD L,(IX+10)
 142+ 5C30 DD 66 0B         LD H,(IX+11)
 143+ 5C33 19               ADD HL,DE
 144+ 5C34 EB               EX DE,HL
 145+ 5C35 E1               POP HL
 146+ 5C36 C3 7D 5B         JP GENERIC_INNER_CHECK
 147+ 5C39              ; ************************************************************************************************
 148+ 5C39
 149+ 5C39              ; ************************************************************************************************
 150+ 5C39              ; function tries to find rectangle overlap and returns an index if found
 151+ 5C39              ; input TMP_STRUCT data
 152+ 5C39              ;  +00 x coordinate
 153+ 5C39              ;  +02 y coordinate
 154+ 5C39              ;  +04 width
 155+ 5C39              ;  +06 height
 156+ 5C39              ;  +08 number of items in a list, described under RECTANGLE_OVERLAP_CHECK
 157+ 5C39              ;  +09 pointer to first element of R%(7,n)
 158+ 5C39              ;  +11 pointer to INT result variable
 159+ 5C39              ; returns CF=1 if not overlapping
 160+ 5C39              ; returns A=list index and CF=0 if overlapping
 161+ 5C39              FIND_OVERLAP:
 162+ 5C39 3A 4D 5F         LD A,(TMP_STRUCT+8)
 163+ 5C3C 47               LD B,A
 164+ 5C3D DD 2A 4E 5F      LD IX,(TMP_STRUCT+9)
 165+ 5C41              .L1:
 166+ 5C41 C5               PUSH BC
 167+ 5C42                  ; check active flag
 168+ 5C42 DD 7E 00         LD A,(IX)
 169+ 5C45 DD B6 01         OR (IX+1)
 170+ 5C48 28 18            JR Z,.NEXT
 171+ 5C4A                  ; check type
 172+ 5C4A DD 7E 0E         LD A,(IX+14)
 173+ 5C4D DD B6 0F         OR (IX+15)
 174+ 5C50 20 1A            JR NZ,.L2
 175+ 5C52 DD E5            PUSH IX
 176+ 5C54 FD E1            POP IY
 177+ 5C56              .L3:
 178+ 5C56 CD 95 5B         CALL RECTANGLE_OVERLAP_CHECK
 179+ 5C59 38 07            JR C,.NEXT
 180+ 5C5B                  ; found
 181+ 5C5B C1               POP BC
 182+ 5C5C 3A 4D 5F         LD A,(TMP_STRUCT+8)
 183+ 5C5F 90               SUB B
 184+ 5C60 A7               AND A
 185+ 5C61 C9               RET
 186+ 5C62              .NEXT:
 187+ 5C62 11 10 00         LD DE,16
 188+ 5C65 DD 19            ADD IX,DE
 189+ 5C67 C1               POP BC
 190+ 5C68 10 D7            DJNZ .L1
 191+ 5C6A 37               SCF
 192+ 5C6B C9               RET
 193+ 5C6C              .L2:
 194+ 5C6C                  ; sprite, need to build a temporary data struct since x and y values are inversed
 195+ 5C6C                  ; at TMP_STRUCT+13
 196+ 5C6C DD 7E 02         LD A,(IX+2) ; sprite ID
 197+ 5C6F CD 90 4D         CALL GETnthSPRATTR
 198+ 5C72 FD 21 50 5F      LD IY,TMP_STRUCT+11
 199+ 5C76 7E               LD A,(HL)
 200+ 5C77 FD 77 04         LD (IY+4),A
 201+ 5C7A 23               INC HL
 202+ 5C7B 7E               LD A,(HL)
 203+ 5C7C FD 77 05         LD (IY+5),A
 204+ 5C7F 23               INC HL
 205+ 5C80 7E               LD A,(HL)
 206+ 5C81 FD 77 02         LD (IY+2),A
 207+ 5C84 23               INC HL
 208+ 5C85 7E               LD A,(HL)
 209+ 5C86 FD 77 03         LD (IY+3),A
 210+ 5C89 18 CB            JR .L3
 211+ 5C8B              ; ************************************************************************************************
 212+ 5C8B
 213+ 5C8B               IF (0 == 1)
 214+ 5C8B ~            ; ************************************************************************************************
 215+ 5C8B ~            ; function to handle CALL COLL basic extension
 216+ 5C8B ~            ; checks for collision between player and other rectangles
 217+ 5C8B ~            ; COLL ( INT result variable,
 218+ 5C8B ~            ;	     INT player x value,
 219+ 5C8B ~            ;	     INT player y value,
 220+ 5C8B ~            ;	     INT player width,
 221+ 5C8B ~            ;	     INT player height,
 222+ 5C8B ~            ;	     INT number of items in a list,
 223+ 5C8B ~            ;		 INT[6][n] rectangle struct )
 224+ 5C8B ~            ; will fill result variable with index or -1 if no collision
 225+ 5C8B ~            ; rectangle struct described under RECTANGLE_OVERLAP_CHECK
 226+ 5C8B ~            COLL:
 227+ 5C8B ~            	; opening (
 228+ 5C8B ~            	CALL CHKCHAR
 229+ 5C8B ~            	DB '('
 230+ 5C8B ~            	; get address of result variable
 231+ 5C8B ~            	LD IX, PTRGET
 232+ 5C8B ~            	CALL CALBAS
 233+ 5C8B ~            	LD (TMP_STRUCT+11),DE
 234+ 5C8B ~            	; comma
 235+ 5C8B ~            	CALL CHKCHAR
 236+ 5C8B ~            	DB ','
 237+ 5C8B ~            	; get x
 238+ 5C8B ~            	LD IX, FRMQNT
 239+ 5C8B ~            	CALL CALBAS
 240+ 5C8B ~            	LD (TMP_STRUCT+0),DE
 241+ 5C8B ~            	; comma
 242+ 5C8B ~            	CALL CHKCHAR
 243+ 5C8B ~            	DB ','
 244+ 5C8B ~            	; get y
 245+ 5C8B ~            	LD IX, FRMQNT
 246+ 5C8B ~            	CALL CALBAS
 247+ 5C8B ~            	LD (TMP_STRUCT+2),DE
 248+ 5C8B ~            	; comma
 249+ 5C8B ~            	CALL CHKCHAR
 250+ 5C8B ~            	DB ','
 251+ 5C8B ~            	; get width
 252+ 5C8B ~            	LD IX, FRMQNT
 253+ 5C8B ~            	CALL CALBAS
 254+ 5C8B ~            	LD (TMP_STRUCT+4),DE
 255+ 5C8B ~            	; comma
 256+ 5C8B ~            	CALL CHKCHAR
 257+ 5C8B ~            	DB ','
 258+ 5C8B ~            	; get height
 259+ 5C8B ~            	LD IX, FRMQNT
 260+ 5C8B ~            	CALL CALBAS
 261+ 5C8B ~            	LD (TMP_STRUCT+6),DE
 262+ 5C8B ~            	; comma
 263+ 5C8B ~            	CALL CHKCHAR
 264+ 5C8B ~            	DB ','
 265+ 5C8B ~            	; get number of items in a list
 266+ 5C8B ~            	LD IX, GETBYT
 267+ 5C8B ~            	CALL CALBAS
 268+ 5C8B ~            	LD (TMP_STRUCT+8),A
 269+ 5C8B ~            	; comma
 270+ 5C8B ~            	CALL CHKCHAR
 271+ 5C8B ~            	DB ','
 272+ 5C8B ~            	; get address of rectangle structure array DIM R%(7,n)
 273+ 5C8B ~            	LD A,(TMP_STRUCT+8)
 274+ 5C8B ~                LD E,A
 275+ 5C8B ~                LD A,2
 276+ 5C8B ~            	LD B,A
 277+ 5C8B ~            	LD D,7
 278+ 5C8B ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
 279+ 5C8B ~            	LD (TMP_STRUCT+9),BC
 280+ 5C8B ~            	; ending )
 281+ 5C8B ~            	CALL CHKCHAR
 282+ 5C8B ~            	DB ')'
 283+ 5C8B ~
 284+ 5C8B ~                PUSH HL
 285+ 5C8B ~                CALL FIND_OVERLAP
 286+ 5C8B ~                LD HL,(TMP_STRUCT+11)
 287+ 5C8B ~                JR C,.NOTFOUND
 288+ 5C8B ~                LD (HL),A
 289+ 5C8B ~                INC HL
 290+ 5C8B ~                LD (HL),0
 291+ 5C8B ~                POP HL
 292+ 5C8B ~                RET
 293+ 5C8B ~            .NOTFOUND:
 294+ 5C8B ~                LD (HL),#FF
 295+ 5C8B ~                INC HL
 296+ 5C8B ~                LD (HL),#FF
 297+ 5C8B ~                POP HL
 298+ 5C8B ~                RET
 299+ 5C8B ~            ; ************************************************************************************************
 300+ 5C8B               ENDIF
 301+ 5C8B
 302+ 5C8B               IF (1 == 1)
 303+ 5C8B              ; *******************************************************************************************************
 304+ 5C8B              ; same as COLL but for DEFUSR approach
 305+ 5C8B              ; input IX=pointer to input array, real data from +2
 306+ 5C8B              ; +02 = pointer to result variable
 307+ 5C8B              ; +04 = player X
 308+ 5C8B              ; +06 = player Y
 309+ 5C8B              ; +08 = player width
 310+ 5C8B              ; +10 = player height
 311+ 5C8B              ; +12 = number of list items
 312+ 5C8B              ; +14 = pointer to list of collidable objects
 313+ 5C8B              COLL_DEFUSR:
 314+ 5C8B DD E5            PUSH IX
 315+ 5C8D E1               POP HL
 316+ 5C8E 23          > INC HL ; skip over to player x
 316+ 5C8F 23          > INC HL
 316+ 5C90 23          > INC HL
 316+ 5C91 23          > INC HL
 317+ 5C92 11 45 5F         LD DE,TMP_STRUCT
 318+ 5C95 01 09 00         LD BC,9
 319+ 5C98 ED B0            LDIR ; copy over x,y,w,h,list item number
 320+ 5C9A DD 7E 0E         LD A,(IX+14)
 321+ 5C9D 32 4E 5F         LD (TMP_STRUCT+9),A
 322+ 5CA0 DD 7E 0F         LD A,(IX+15)
 323+ 5CA3 32 4F 5F         LD (TMP_STRUCT+10),A ; address to collidable objects array
 324+ 5CA6 DD 7E 02         LD A,(IX+2)
 325+ 5CA9 32 50 5F         LD (TMP_STRUCT+11),A
 326+ 5CAC DD 7E 03         LD A,(IX+3)
 327+ 5CAF 32 51 5F         LD (TMP_STRUCT+12),A ; address to results variable
 328+ 5CB2 DD E5            PUSH IX
 329+ 5CB4 CD 39 5C         CALL FIND_OVERLAP
 330+ 5CB7 DD E1            POP IX
 331+ 5CB9 DD 6E 02         LD L,(IX+2)
 332+ 5CBC DD 66 03         LD H,(IX+3)
 333+ 5CBF 38 06            JR C,.NOTFOUND
 334+ 5CC1 77               LD (HL),A
 335+ 5CC2 23               INC HL
 336+ 5CC3 36 00            LD (HL),0
 337+ 5CC5              .EXIT:
 338+ 5CC5 AF               XOR A ; success
 339+ 5CC6 C9               RET
 340+ 5CC7              .NOTFOUND:
 341+ 5CC7 36 FF            LD (HL),#FF
 342+ 5CC9 23               INC HL
 343+ 5CCA 36 FF            LD (HL),#FF
 344+ 5CCC 18 F7            JR .EXIT
 345+ 5CCE              ; *******************************************************************************************************
 346+ 5CCE               ENDIF
 347+ 5CCE
# file closed: asm\COLLISION.asm
 172  5CCE               ENDIF
 173  5CCE
 174  5CCE               IF (DECOMP_CMDS == 1)
 175  5CCE               INCLUDE "decomp.asm"
# file opened: asm\decomp.asm
   1+ 5CCE              ; -----------------------------------------------------------------------------
   2+ 5CCE              ; ZX0 decoder by Einar Saukas & Urusergi
   3+ 5CCE              ; "Standard" version (68 bytes only)
   4+ 5CCE              ; -----------------------------------------------------------------------------
   5+ 5CCE              ; Parameters:
   6+ 5CCE              ;   HL: source address (compressed data)
   7+ 5CCE              ;   DE: destination address (decompressing)
   8+ 5CCE              ; -----------------------------------------------------------------------------
   9+ 5CCE
  10+ 5CCE              dzx0_standard:
  11+ 5CCE 01 FF FF             ld      bc, $ffff               ; preserve default offset 1
  12+ 5CD1 C5                   push    bc
  13+ 5CD2 03                   inc     bc
  14+ 5CD3 3E 80                ld      a, $80
  15+ 5CD5              dzx0s_literals:
  16+ 5CD5 CD 05 5D             call    dzx0s_elias             ; obtain length
  17+ 5CD8              dzx0_ldir_1:
  18+ 5CD8 ED B0                ldir                            ; copy literals
  19+ 5CDA 00                   nop                             ; placeholder for call
  20+ 5CDB 87                   add     a, a                    ; copy from last offset or new offset?
  21+ 5CDC 38 0E                jr      c, dzx0s_new_offset
  22+ 5CDE CD 05 5D             call    dzx0s_elias             ; obtain length
  23+ 5CE1              dzx0s_copy:
  24+ 5CE1 E3                   ex      (sp), hl                ; preserve source, restore offset
  25+ 5CE2 E5                   push    hl                      ; preserve offset
  26+ 5CE3 19                   add     hl, de                  ; calculate destination - offset
  27+ 5CE4              dzx0_ldir_2:
  28+ 5CE4 ED B0                ldir                            ; copy from offset
  29+ 5CE6 00                   nop                             ; placeholder for call
  30+ 5CE7 E1                   pop     hl                      ; restore offset
  31+ 5CE8 E3                   ex      (sp), hl                ; preserve offset, restore source
  32+ 5CE9 87                   add     a, a                    ; copy from literals or new offset?
  33+ 5CEA 30 E9                jr      nc, dzx0s_literals
  34+ 5CEC              dzx0s_new_offset:
  35+ 5CEC C1                   pop     bc                      ; discard last offset
  36+ 5CED 0E FE                ld      c, $fe                  ; prepare negative offset
  37+ 5CEF CD 06 5D             call    dzx0s_elias_loop        ; obtain offset MSB
  38+ 5CF2 0C                   inc     c
  39+ 5CF3 C8                   ret     z                       ; check end marker
  40+ 5CF4 41                   ld      b, c
  41+ 5CF5 4E                   ld      c, (hl)                 ; obtain offset LSB
  42+ 5CF6 23                   inc     hl
  43+ 5CF7 CB 18                rr      b                       ; last offset bit becomes first length bit
  44+ 5CF9 CB 19                rr      c
  45+ 5CFB C5                   push    bc                      ; preserve new offset
  46+ 5CFC 01 01 00             ld      bc, 1                   ; obtain length
  47+ 5CFF D4 0D 5D             call    nc, dzx0s_elias_backtrack
  48+ 5D02 03                   inc     bc
  49+ 5D03 18 DC                jr      dzx0s_copy
  50+ 5D05              dzx0s_elias:
  51+ 5D05 0C                   inc     c                       ; interlaced Elias gamma coding
  52+ 5D06              dzx0s_elias_loop:
  53+ 5D06 87                   add     a, a
  54+ 5D07 20 03                jr      nz, dzx0s_elias_skip
  55+ 5D09 7E                   ld      a, (hl)                 ; load another group of 8 bits
  56+ 5D0A 23                   inc     hl
  57+ 5D0B 17                   rla
  58+ 5D0C              dzx0s_elias_skip:
  59+ 5D0C D8                   ret     c
  60+ 5D0D              dzx0s_elias_backtrack:
  61+ 5D0D 87                   add     a, a
  62+ 5D0E CB 11                rl      c
  63+ 5D10 CB 10                rl      b
  64+ 5D12 18 F2                jr      dzx0s_elias_loop
  65+ 5D14              ; -----------------------------------------------------------------------------
  66+ 5D14
  67+ 5D14              ; *******************************************************************************************************
  68+ 5D14              ; helper function for VRAM unpack to save AF prior to calling copy to VRAM fn
  69+ 5D14              ; also simulates register states as if LDIR was called
  70+ 5D14              LDIR_TO_VRAM:
  71+ 5D14 F5                   PUSH AF ; save AF used by algorithm
  72+ 5D15 D5                   PUSH DE
  73+ 5D16 C5                   PUSH BC
  74+ 5D17 CD 88 56             CALL VRAM_LDIRVM
  75+ 5D1A C1                   POP BC
  76+ 5D1B EB                   EX DE,HL
  77+ 5D1C E1                   POP HL
  78+ 5D1D 09                   ADD HL,BC
  79+ 5D1E EB                   EX DE,HL
  80+ 5D1F 01 00 00             LD BC,0
  81+ 5D22 F1                   POP AF
  82+ 5D23 C9                   RET
  83+ 5D24              ; *******************************************************************************************************
  84+ 5D24
  85+ 5D24              ; *******************************************************************************************************
  86+ 5D24              ; helper function to get a byte from VRAM address at HL and place it at DE also in VRAM
  87+ 5D24              VPOKE_VPEEK:
  88+ 5D24 F3                   DI
  89+ 5D25 CD AB 5F             CALL SETWRT_LOCAL_READ
  90+ 5D28 E3                   EX (SP),HL
  91+ 5D29 E3                   EX (SP),HL
  92+ 5D2A DB 98                IN A,(#98)
  93+ 5D2C                      ;IN A,(#98) ; WHY IS THIS NEEDED ?
  94+ 5D2C F5                   PUSH AF
  95+ 5D2D EB                   EX DE,HL
  96+ 5D2E CD A0 5F             CALL SETWRT_LOCAL_WRITE
  97+ 5D31 E3                   EX (SP),HL
  98+ 5D32 E3                   EX (SP),HL
  99+ 5D33 EB                   EX DE,HL
 100+ 5D34 F1                   POP AF
 101+ 5D35 D3 98                OUT (#98),A
 102+ 5D37 FB                   EI
 103+ 5D38 C9                   RET
 104+ 5D39              ; *******************************************************************************************************
 105+ 5D39
 106+ 5D39              ; *******************************************************************************************************
 107+ 5D39              ; helper fn VRAM variant of LDIR
 108+ 5D39              ; input HL = source, DE = destination, BC = count
 109+ 5D39              VRAM_LDIR:
 110+ 5D39 F5                   PUSH AF
 111+ 5D3A              _L0:
 112+ 5D3A CD 24 5D             CALL VPOKE_VPEEK
 113+ 5D3D 23                   INC HL
 114+ 5D3E 13                   INC DE
 115+ 5D3F 0B                   DEC BC
 116+ 5D40 78                   LD A, B
 117+ 5D41 B1                   OR C
 118+ 5D42 20 F6                JR NZ, _L0
 119+ 5D44 F1                   POP AF
 120+ 5D45 C9                   RET
 121+ 5D46              ; *******************************************************************************************************
 122+ 5D46
 123+ 5D46               IF (0 == 1)
 124+ 5D46 ~            ; *******************************************************************************************************
 125+ 5D46 ~            ; function to handle CALL VUNPACK basic extension
 126+ 5D46 ~            ; _VUNPACK ( INT source,
 127+ 5D46 ~            ;			 INT destination )
 128+ 5D46 ~            ; will put ram in page 0 also, page 1 is already there
 129+ 5D46 ~            ; *******************************************************************************************************
 130+ 5D46 ~            VUNPACK:
 131+ 5D46 ~                LD A, #CD ; CALL
 132+ 5D46 ~                LD (dzx0_ldir_1), A
 133+ 5D46 ~                LD (dzx0_ldir_2), A
 134+ 5D46 ~                LD DE, LDIR_TO_VRAM
 135+ 5D46 ~                LD (dzx0_ldir_1 + 1), DE
 136+ 5D46 ~                LD DE, VRAM_LDIR
 137+ 5D46 ~                LD (dzx0_ldir_2 + 1), DE
 138+ 5D46 ~                JR UNPACK_COMMON
 139+ 5D46 ~            ; function to handle CALL UNPACK basic extension
 140+ 5D46 ~            ; _UNPACK ( INT source,
 141+ 5D46 ~            ;			INT destination )
 142+ 5D46 ~            ; will put ram in page 0 also, page 1 is already there
 143+ 5D46 ~            UNPACK:
 144+ 5D46 ~                LD DE, #B0ED ; LDIR
 145+ 5D46 ~                LD (dzx0_ldir_1), DE
 146+ 5D46 ~                LD (dzx0_ldir_2), DE
 147+ 5D46 ~                XOR A ; NOP
 148+ 5D46 ~                LD (dzx0_ldir_1 + 2), A
 149+ 5D46 ~                LD (dzx0_ldir_2 + 2), A
 150+ 5D46 ~            UNPACK_COMMON:
 151+ 5D46 ~            	; opening (
 152+ 5D46 ~            	CALL CHKCHAR
 153+ 5D46 ~            	DB '('
 154+ 5D46 ~            	; get source address
 155+ 5D46 ~            	LD IX, FRMQNT
 156+ 5D46 ~            	CALL CALBAS
 157+ 5D46 ~            	PUSH DE
 158+ 5D46 ~            	; comma
 159+ 5D46 ~            	CALL CHKCHAR
 160+ 5D46 ~            	DB ','
 161+ 5D46 ~            	; get destination address
 162+ 5D46 ~            	LD IX, FRMQNT
 163+ 5D46 ~            	CALL CALBAS
 164+ 5D46 ~            	PUSH DE
 165+ 5D46 ~            	; ending )
 166+ 5D46 ~            	CALL CHKCHAR
 167+ 5D46 ~            	DB ')'
 168+ 5D46 ~
 169+ 5D46 ~            	; save position
 170+ 5D46 ~            	PUSH HL
 171+ 5D46 ~            	POP IX
 172+ 5D46 ~
 173+ 5D46 ~            	POP DE ; destination
 174+ 5D46 ~            	POP HL ; source
 175+ 5D46 ~            	EXX
 176+ 5D46 ~            	; enable page 0
 177+ 5D46 ~            	LD IY, .RET
 178+ 5D46 ~            	JP ENABLE_PAGE0
 179+ 5D46 ~            .RET:
 180+ 5D46 ~            	EI
 181+ 5D46 ~            	EXX
 182+ 5D46 ~            	CALL dzx0_standard
 183+ 5D46 ~                    JP COMMON_EXIT_CODE_IX
 184+ 5D46 ~            ; *******************************************************************************************************
 185+ 5D46               ENDIF
 186+ 5D46
 187+ 5D46               IF (1 == 1)
 188+ 5D46              ; *******************************************************************************************************
 189+ 5D46              ; same as VUNPACK but for DEFUSR approach
 190+ 5D46              ; input IX=pointer to input array, real data from +2
 191+ 5D46              ; +2 = source address
 192+ 5D46              ; +4 = destination address
 193+ 5D46              ; *******************************************************************************************************
 194+ 5D46              VUNPACK_DEFUSR:
 195+ 5D46 3E CD            LD A, #CD ; CALL
 196+ 5D48 32 D8 5C         LD (dzx0_ldir_1), A
 197+ 5D4B 32 E4 5C         LD (dzx0_ldir_2), A
 198+ 5D4E 21 14 5D         LD HL, LDIR_TO_VRAM
 199+ 5D51 22 D9 5C         LD (dzx0_ldir_1 + 1), HL
 200+ 5D54 21 39 5D         LD HL, VRAM_LDIR
 201+ 5D57 22 E5 5C         LD (dzx0_ldir_2 + 1), HL
 202+ 5D5A 18 10            JR UNPACK_DEFUSR_COMMON
 203+ 5D5C              ; same as UNPACK but for DEFUSR approach
 204+ 5D5C              ; input IX=pointer to input array, real data from +2
 205+ 5D5C              ; +2 = source address
 206+ 5D5C              ; +4 = destination address
 207+ 5D5C              UNPACK_DEFUSR:
 208+ 5D5C 21 ED B0         LD HL, #B0ED ; LDIR
 209+ 5D5F 22 D8 5C         LD (dzx0_ldir_1), HL
 210+ 5D62 22 E4 5C         LD (dzx0_ldir_2), HL
 211+ 5D65 AF               XOR A ; NOP
 212+ 5D66 32 DA 5C         LD (dzx0_ldir_1 + 2), A
 213+ 5D69 32 E6 5C         LD (dzx0_ldir_2 + 2), A
 214+ 5D6C              UNPACK_DEFUSR_COMMON:
 215+ 5D6C                  ; enable page 0
 216+ 5D6C FD 21 73 5D      LD IY, .RET
 217+ 5D70 C3 83 60         JP ENABLE_PAGE0
 218+ 5D73              .RET:
 219+ 5D73 FB               EI
 220+ 5D74 DD 6E 02         LD L,(IX+2)
 221+ 5D77 DD 66 03         LD H,(IX+3)
 222+ 5D7A DD 5E 04         LD E,(IX+4)
 223+ 5D7D DD 56 05         LD D,(IX+5)
 224+ 5D80 CD CE 5C         CALL dzx0_standard
 225+ 5D83 C3 99 5F         JP COMMON_EXIT_CODE
 226+ 5D86              ; *******************************************************************************************************
 227+ 5D86               ENDIF
# file closed: asm\decomp.asm
 176  5D86               ENDIF
 177  5D86
 178  5D86               IF (DLOAD_CMD == 1)
 179  5D86               INCLUDE "DLOAD.asm"
# file opened: asm\DLOAD.asm
   1+ 5D86              BDOS_SETDTA     EQU #1A
   2+ 5D86              BDOS_OPEN       EQU #0F
   3+ 5D86              BDOS_CLOSE      EQU #10
   4+ 5D86              BDOS_RDBLK      EQU #27
   5+ 5D86
   6+ 5D86              ; *******************************************************************************************************
   7+ 5D86              ; function processes file name
   8+ 5D86              ; filenames supported are D:FILENAME.EXT, FILENAME.EXT, D:FILENAME, FILENAME
   9+ 5D86              ; FCB 0 will be zeroed out
  10+ 5D86              ; FCB 0 will be populated with drive info 0=default or 1-8 for drives A-H
  11+ 5D86              ; FCB 0 will be populated with file name
  12+ 5D86              ; input HL=pointer to expression
  13+ 5D86              ; input B=length
  14+ 5D86              ; returns CF=1 if bad filename
  15+ 5D86              DLOAD_PROCESS_FILENAME:
  16+ 5D86                  ; check for zero size
  17+ 5D86 78               LD A,B
  18+ 5D87 B7               OR A
  19+ 5D88 28 6B            JR Z, .BADFILENAME
  20+ 5D8A                  ; check for more than 2+8+1+3=14
  21+ 5D8A FE 0F            CP 15
  22+ 5D8C 30 67            JR NC, .BADFILENAME
  23+ 5D8E                  ; check if more than 2 letters
  24+ 5D8E FE 03            CP 3
  25+ 5D90 38 1C            JR C, .L7 ; no drive
  26+ 5D92                  ; check for : at proper place
  27+ 5D92 5E               LD E, (HL)
  28+ 5D93 23               INC HL
  29+ 5D94 7E               LD A, (HL)
  30+ 5D95 FE 3A            CP ':'
  31+ 5D97 20 14            JR NZ, .L1
  32+ 5D99                  ; so we have : , check for letters A-H
  33+ 5D99 7B               LD A,E
  34+ 5D9A CD EF 60         CALL UPPER
  35+ 5D9D D6 41            SUB 'A'
  36+ 5D9F FE 09            CP 9
  37+ 5DA1 30 52            JR NC, .BADFILENAME
  38+ 5DA3 23               INC HL
  39+ 5DA4 05               DEC B ; consume two characters
  40+ 5DA5 05               DEC B
  41+ 5DA6              .L2:
  42+ 5DA6 ED 5B 53 F3      LD DE, (FCB0)
  43+ 5DAA 12               LD (DE), A
  44+ 5DAB 18 04            JR .PROCESS_FILENAME
  45+ 5DAD              .L1:
  46+ 5DAD                  ; no drive specified
  47+ 5DAD 2B               DEC HL
  48+ 5DAE              .L7:
  49+ 5DAE AF               XOR A
  50+ 5DAF 18 F5            JR .L2
  51+ 5DB1              .PROCESS_FILENAME:
  52+ 5DB1                  ; HL is pointing to rest of the name
  53+ 5DB1 13               INC DE ; 8-character filename location, needs to be padded with blanks
  54+ 5DB2 0E 08            LD C,8 ; filename length
  55+ 5DB4              .L4:
  56+ 5DB4 CD F7 5D         CALL .GETCHAR
  57+ 5DB7 FE 2E            CP '.'
  58+ 5DB9 28 31            JR Z, .L6 ; if dot, fill rest with blanks
  59+ 5DBB 12               LD (DE),A
  60+ 5DBC 13               INC DE
  61+ 5DBD 0D               DEC C
  62+ 5DBE 20 F4            JR NZ, .L4
  63+ 5DC0                  ; so we cleared filename part
  64+ 5DC0 78               LD A,B ; no more letters. just fill extension with blanks
  65+ 5DC1 B7               OR A
  66+ 5DC2 28 07            JR Z, .L8
  67+ 5DC4 CD F7 5D         CALL .GETCHAR ; here we must have . for a valid name
  68+ 5DC7 FE 2E            CP '.'
  69+ 5DC9 20 2A            JR NZ, .BADFILENAME
  70+ 5DCB              .L8:
  71+ 5DCB 0E 03            LD C,3
  72+ 5DCD              .L5:
  73+ 5DCD CD F7 5D         CALL .GETCHAR
  74+ 5DD0 12               LD (DE),A
  75+ 5DD1 13               INC DE
  76+ 5DD2 0D               DEC C
  77+ 5DD3 20 F8            JR NZ, .L5
  78+ 5DD5 78               LD A,B ; nothing must be left in buffer
  79+ 5DD6 B7               OR A
  80+ 5DD7 20 1C            JR NZ, .BADFILENAME
  81+ 5DD9                  ; file name correct, now zero out the rest of FCB 0
  82+ 5DD9 2A 53 F3         LD HL,(FCB0)
  83+ 5DDC 11 0C 00         LD DE,12
  84+ 5DDF 19               ADD HL,DE
  85+ 5DE0 36 00            LD (HL),0
  86+ 5DE2 54               LD D,H
  87+ 5DE3 5D               LD E,L
  88+ 5DE4 13               INC DE
  89+ 5DE5 01 18 00         LD BC,37-12-1
  90+ 5DE8 ED B0            LDIR
  91+ 5DEA AF               XOR A ; clear carry flag
  92+ 5DEB C9               RET
  93+ 5DEC              .L6:
  94+ 5DEC 3E 20            LD A,' '
  95+ 5DEE              .L9:
  96+ 5DEE 12               LD (DE),A
  97+ 5DEF 13               INC DE
  98+ 5DF0 0D               DEC C
  99+ 5DF1 20 FB            JR NZ, .L9
 100+ 5DF3 18 D6            JR .L8
 101+ 5DF5              .BADFILENAME:
 102+ 5DF5 37               SCF
 103+ 5DF6 C9               RET
 104+ 5DF7              .GETCHAR: ; gets a character, returns blank if we read past input
 105+ 5DF7 78               LD A,B
 106+ 5DF8 B7               OR A
 107+ 5DF9 28 07            JR Z, .BLANK
 108+ 5DFB 7E               LD A,(HL)
 109+ 5DFC CD EF 60         CALL UPPER
 110+ 5DFF 23               INC HL
 111+ 5E00 05               DEC B
 112+ 5E01 C9               RET
 113+ 5E02              .BLANK:
 114+ 5E02 3E 20            LD A,' '
 115+ 5E04 C9               RET
 116+ 5E05              ; *******************************************************************************************************
 117+ 5E05
 118+ 5E05              ; *******************************************************************************************************
 119+ 5E05              ; function sets disk buffer from NULBUF
 120+ 5E05              ; input none
 121+ 5E05              ; returns ZF!=1 on error
 122+ 5E05              DLOAD_SETDTA:
 123+ 5E05 ED 5B 62 F8      LD DE,(NULBUF)
 124+ 5E09 0E 1A            LD C, BDOS_SETDTA
 125+ 5E0B 18 24            JR BDOS_CALL
 126+ 5E0D              ; *******************************************************************************************************
 127+ 5E0D
 128+ 5E0D              ; *******************************************************************************************************
 129+ 5E0D              ; function opens a file using FCB 0
 130+ 5E0D              ; input none
 131+ 5E0D              ; returns ZF!=1 on error
 132+ 5E0D              DLOAD_OPENFILE:
 133+ 5E0D ED 5B 53 F3      LD DE,(FCB0)
 134+ 5E11 0E 0F            LD C, BDOS_OPEN
 135+ 5E13 18 1C            JR BDOS_CALL
 136+ 5E15              ; *******************************************************************************************************
 137+ 5E15
 138+ 5E15              ; *******************************************************************************************************
 139+ 5E15              ; function makes a file seek and sets record size to 1 byte
 140+ 5E15              ; input none
 141+ 5E15              ; output node
 142+ 5E15              DLOAD_SEEK:
 143+ 5E15 2A 45 5F         LD HL,(TMP_STRUCT)
 144+ 5E18 DD 2A 53 F3      LD IX,(FCB0)
 145+ 5E1C DD 75 21         LD (IX+33),L
 146+ 5E1F DD 74 22         LD (IX+34),H
 147+ 5E22 DD 36 0E 01      LD (IX+14),1
 148+ 5E26 DD 36 0F 00      LD (IX+15),0
 149+ 5E2A C9               RET
 150+ 5E2B              ; *******************************************************************************************************
 151+ 5E2B
 152+ 5E2B              ; *******************************************************************************************************
 153+ 5E2B              ; function reads a number of bytes from a file using FCB 0 to (NULBUF) buffer
 154+ 5E2B              ; input HL=number of bytes to read
 155+ 5E2B              ; returns HL=number of bytes read
 156+ 5E2B              ; returns ZF!=1 on error
 157+ 5E2B              DLOAD_READ:
 158+ 5E2B ED 5B 53 F3      LD DE,(FCB0)
 159+ 5E2F 0E 27            LD C,BDOS_RDBLK
 160+ 5E31              BDOS_CALL:
 161+ 5E31 CD 7D F3         CALL BDOS
 162+ 5E34 B7               OR A
 163+ 5E35 C9               RET
 164+ 5E36              ; *******************************************************************************************************
 165+ 5E36
 166+ 5E36              ; *******************************************************************************************************
 167+ 5E36              ; function closes a file FCB 0
 168+ 5E36              ; input none
 169+ 5E36              ; returns ZF!=1 on error
 170+ 5E36              DLOAD_CLOSE:
 171+ 5E36 AF               XOR A
 172+ 5E37 ED 5B 53 F3      LD DE,(FCB0)
 173+ 5E3B 0E 10            LD C,BDOS_CLOSE
 174+ 5E3D 18 F2            JR BDOS_CALL
 175+ 5E3F              ; *******************************************************************************************************
 176+ 5E3F
 177+ 5E3F              ; *******************************************************************************************************
 178+ 5E3F              ; function copies data from (NULBUF) to destination, enables RAM in page 0
 179+ 5E3F              ; input BC=number of bytes to copy
 180+ 5E3F              ; output none
 181+ 5E3F              DLOAD_TRANSFERBLOCK:
 182+ 5E3F D9               EXX ; save BC
 183+ 5E40              	; enable page 0
 184+ 5E40 FD 21 47 5E  	LD IY, .RET
 185+ 5E44 C3 83 60     	JP ENABLE_PAGE0
 186+ 5E47              .RET:
 187+ 5E47 FB           	EI
 188+ 5E48 D9               EXX
 189+ 5E49 ED 5B 47 5F      LD DE,(TMP_STRUCT+2)
 190+ 5E4D 2A 62 F8         LD HL,(NULBUF)
 191+ 5E50 ED B0        	LDIR
 192+ 5E52 ED 53 47 5F      LD (TMP_STRUCT+2),DE
 193+ 5E56 D1               POP DE
 194+ 5E57 C1               POP BC
 195+ 5E58 C3 FA 5F         JP RESTORE_PAGE_INFO
 196+ 5E5B              ; *******************************************************************************************************
 197+ 5E5B
 198+ 5E5B              ; *******************************************************************************************************
 199+ 5E5B              ; function opens and loads a file in FCB 0
 200+ 5E5B              ; file name needs to be already set in FCB 0
 201+ 5E5B              ; input none
 202+ 5E5B              ; returns ZF!=1 on error
 203+ 5E5B              DLOAD_LOADFILE:
 204+ 5E5B CD 05 5E         CALL DLOAD_SETDTA
 205+ 5E5E CD 0D 5E         CALL DLOAD_OPENFILE
 206+ 5E61 C0               RET NZ
 207+ 5E62 CD 15 5E         CALL DLOAD_SEEK
 208+ 5E65 ED 4B 49 5F      LD BC,(TMP_STRUCT+4)
 209+ 5E69              .L1:
 210+ 5E69 78               LD A,B
 211+ 5E6A B7               OR A
 212+ 5E6B 28 12            JR Z,.REST
 213+ 5E6D 05               DEC B
 214+ 5E6E 21 00 01         LD HL,256
 215+ 5E71              .L2:
 216+ 5E71 C5               PUSH BC
 217+ 5E72 E5               PUSH HL
 218+ 5E73 CD 2B 5E         CALL DLOAD_READ
 219+ 5E76 C1               POP BC
 220+ 5E77 20 10            JR NZ,.ERRREAD
 221+ 5E79 CD 3F 5E         CALL DLOAD_TRANSFERBLOCK
 222+ 5E7C C1               POP BC
 223+ 5E7D 18 EA            JR .L1
 224+ 5E7F              .REST:
 225+ 5E7F 79               LD A,C
 226+ 5E80 B7               OR A
 227+ 5E81 28 07            JR Z,.EXIT
 228+ 5E83 26 00            LD H,0
 229+ 5E85 69               LD L,C
 230+ 5E86 4C               LD C,H
 231+ 5E87 18 E8            JR .L2
 232+ 5E89              .ERRREAD:
 233+ 5E89 C1               POP BC
 234+ 5E8A              .EXIT:
 235+ 5E8A F5               PUSH AF
 236+ 5E8B CD 36 5E         CALL DLOAD_CLOSE
 237+ 5E8E F1               POP AF
 238+ 5E8F C9               RET
 239+ 5E90              ; *******************************************************************************************************
 240+ 5E90
 241+ 5E90               IF (0 == 1)
 242+ 5E90 ~
 243+ 5E90 ~            ; *******************************************************************************************************
 244+ 5E90 ~            ; function to handle CALL DLOAD basic extension
 245+ 5E90 ~            ; _DLOAD ( STRING filename,
 246+ 5E90 ~            ;		   INT offset,
 247+ 5E90 ~            ;		   INT destination,
 248+ 5E90 ~            ;          INT size )
 249+ 5E90 ~            ; will put ram in page 0 also, page 1 is already there
 250+ 5E90 ~            DLOAD:
 251+ 5E90 ~            	; opening (
 252+ 5E90 ~            	CALL CHKCHAR
 253+ 5E90 ~            	DB '('
 254+ 5E90 ~                CALL EVALTXTPARAM
 255+ 5E90 ~                PUSH HL
 256+ 5E90 ~                CALL GETSTRPNT
 257+ 5E90 ~                CALL DLOAD_PROCESS_FILENAME
 258+ 5E90 ~                JP C, BAD_FILENAME
 259+ 5E90 ~                POP HL
 260+ 5E90 ~            	; comma
 261+ 5E90 ~            	CALL CHKCHAR
 262+ 5E90 ~            	DB ','
 263+ 5E90 ~            	; get offset
 264+ 5E90 ~            	LD IX, FRMQNT
 265+ 5E90 ~            	CALL CALBAS
 266+ 5E90 ~            	LD (TMP_STRUCT), DE
 267+ 5E90 ~            	; comma
 268+ 5E90 ~            	CALL CHKCHAR
 269+ 5E90 ~            	DB ','
 270+ 5E90 ~            	; get destination
 271+ 5E90 ~            	LD IX, FRMQNT
 272+ 5E90 ~            	CALL CALBAS
 273+ 5E90 ~            	LD (TMP_STRUCT+2), DE
 274+ 5E90 ~            	; comma
 275+ 5E90 ~            	CALL CHKCHAR
 276+ 5E90 ~            	DB ','
 277+ 5E90 ~            	; get size
 278+ 5E90 ~            	LD IX, FRMQNT
 279+ 5E90 ~            	CALL CALBAS
 280+ 5E90 ~            	LD (TMP_STRUCT+4), DE
 281+ 5E90 ~            	; ending )
 282+ 5E90 ~            	CALL CHKCHAR
 283+ 5E90 ~            	DB ')'
 284+ 5E90 ~
 285+ 5E90 ~                PUSH HL
 286+ 5E90 ~                CALL DLOAD_LOADFILE
 287+ 5E90 ~                JP NZ, DISKIOERR
 288+ 5E90 ~                POP HL
 289+ 5E90 ~                RET
 290+ 5E90 ~            ; *******************************************************************************************************
 291+ 5E90 ~
 292+ 5E90               ENDIF
 293+ 5E90
 294+ 5E90               IF (1 == 1)
 295+ 5E90              ; *******************************************************************************************************
 296+ 5E90              ; same as DLOAD but for DEFUSR approach
 297+ 5E90              ; input IX=pointer to input array, real data from +2
 298+ 5E90              ; +2 = string pointer
 299+ 5E90              ; +4 = offset
 300+ 5E90              ; +6 = destination
 301+ 5E90              ; +8 = size
 302+ 5E90              ; output A=0 on success
 303+ 5E90              ; *******************************************************************************************************
 304+ 5E90              DLOAD_DEFUSR:
 305+ 5E90 DD 6E 02         LD L,(IX+2)
 306+ 5E93 DD 66 03         LD H,(IX+3)
 307+ 5E96 46               LD B,(HL) ; string length
 308+ 5E97 23               INC HL
 309+ 5E98 5E               LD E,(HL)
 310+ 5E99 23               INC HL
 311+ 5E9A 56               LD D,(HL)
 312+ 5E9B EB               EX DE,HL ; pointer to ASCIIZ text
 313+ 5E9C CD 86 5D         CALL DLOAD_PROCESS_FILENAME
 314+ 5E9F 38 22            JR C,.ERR ; exit on error
 315+ 5EA1 DD 6E 04         LD L,(IX+4)
 316+ 5EA4 DD 66 05         LD H,(IX+5)
 317+ 5EA7 22 45 5F         LD (TMP_STRUCT),HL ; offset
 318+ 5EAA DD 6E 06         LD L,(IX+6)
 319+ 5EAD DD 66 07         LD H,(IX+7)
 320+ 5EB0 22 47 5F         LD (TMP_STRUCT+2),HL ; destination
 321+ 5EB3 DD 6E 08         LD L,(IX+8)
 322+ 5EB6 DD 66 09         LD H,(IX+9)
 323+ 5EB9 22 49 5F         LD (TMP_STRUCT+4),HL ; size
 324+ 5EBC CD 5B 5E         CALL DLOAD_LOADFILE
 325+ 5EBF 20 02            JR NZ,.ERR
 326+ 5EC1 AF               XOR A
 327+ 5EC2 C9               RET
 328+ 5EC3              .ERR:
 329+ 5EC3 3E 01            LD A,1
 330+ 5EC5 C9               RET
 331+ 5EC6              ; *******************************************************************************************************
 332+ 5EC6
 333+ 5EC6               ENDIF
 334+ 5EC6
# file closed: asm\DLOAD.asm
 180  5EC6               ENDIF
 181  5EC6
 182  5EC6               IF (1 == 1)
 183  5EC6               INCLUDE "DEFUSR.asm"
# file opened: asm\DEFUSR.asm
   1+ 5EC6              ; entry function that handles call using CALLF
   2+ 5EC6              ; pointer to data structure is expected at DAC+2
   3+ 5EC6              ; first entry must be function id followed by function specific parameters
   4+ 5EC6
   5+ 5EC6              DEFUSR_TABLE_ENTRIES    EQU 41
   6+ 5EC6
   7+ 5EC6              DEFUSR_JUMP_TABLE:
   8+ 5EC6               IF (SPRITE_CMDS == 1)
   9+ 5EC6 75 4E         DW SPRENABLE_DEFUSR        ; 0
  10+ 5EC8               ELSE
  11+ 5EC8 ~             DW NOACTION_DEFUSR
  12+ 5EC8               ENDIF
  13+ 5EC8
  14+ 5EC8               IF (SPRITE_CMDS == 1)
  15+ 5EC8 9A 4E         DW SPRDISABLE_DEFUSR        ; 1
  16+ 5ECA               ELSE
  17+ 5ECA ~             DW NOACTION_DEFUSR
  18+ 5ECA               ENDIF
  19+ 5ECA
  20+ 5ECA               IF (RAM_CMDS == 1)
  21+ 5ECA 5C 55         DW MEMCPY_DEFUSR           ; 2
  22+ 5ECC               ELSE
  23+ 5ECC ~             DW NOACTION_DEFUSR
  24+ 5ECC               ENDIF
  25+ 5ECC
  26+ 5ECC               IF (VRAM_CMDS == 1)        ; 3
  27+ 5ECC 53 56         DW MEMVRM_DEFUSR
  28+ 5ECE               ELSE
  29+ 5ECE ~             DW NOACTION_DEFUSR
  30+ 5ECE               ENDIF
  31+ 5ECE
  32+ 5ECE               IF (BLIT_CMDS == 1)        ; 4
  33+ 5ECE 64 59         DW BLIT_DEFUSR
  34+ 5ED0               ELSE
  35+ 5ED0 ~             DW NOACTION_DEFUSR
  36+ 5ED0               ENDIF
  37+ 5ED0
  38+ 5ED0               IF (ANIM_CMDS == 1)        ; 5
  39+ 5ED0 36 54         DW SGAM_DEFUSR
  40+ 5ED2               ELSE
  41+ 5ED2 ~             DW NOACTION_DEFUSR
  42+ 5ED2               ENDIF
  43+ 5ED2
  44+ 5ED2               IF (SPRITE_CMDS == 1)
  45+ 5ED2 DD 4E         DW SPRGRPMOV_DEFUSR        ; 6
  46+ 5ED4               ELSE
  47+ 5ED4 ~             DW NOACTION_DEFUSR
  48+ 5ED4               ENDIF
  49+ 5ED4
  50+ 5ED4               IF (COLL_CMD == 1)
  51+ 5ED4 8B 5C         DW COLL_DEFUSR             ; 7
  52+ 5ED6               ELSE
  53+ 5ED6 ~             DW NOACTION_DEFUSR
  54+ 5ED6               ENDIF
  55+ 5ED6
  56+ 5ED6               IF (SOUND_CMDS == 1)
  57+ 5ED6 0F 56         DW SNDSFX_DEFUSR             ; 8
  58+ 5ED8               ELSE
  59+ 5ED8 ~             DW NOACTION_DEFUSR
  60+ 5ED8               ENDIF
  61+ 5ED8
  62+ 5ED8               IF (ANIM_CMDS == 1)
  63+ 5ED8 C7 52         DW ANIMSTEP_SINGLE_DEFUSR      ; 9
  64+ 5EDA D7 52         DW ANIMSTEP_MULTI_DEFUSR       ; 10
  65+ 5EDC E8 52         DW ANIMSTART_SINGLE_DEFUSR     ; 11
  66+ 5EDE FA 52         DW ANIMSTART_MULTI_DEFUSR      ; 12
  67+ 5EE0 FF 52         DW ANIMSTOP_SINGLE_DEFUSR      ; 13
  68+ 5EE2 09 53         DW ANIMSTOP_MULTI_DEFUSR       ; 14
  69+ 5EE4               ELSE
  70+ 5EE4 ~             DW NOACTION_DEFUSR
  71+ 5EE4 ~             DW NOACTION_DEFUSR
  72+ 5EE4 ~             DW NOACTION_DEFUSR
  73+ 5EE4 ~             DW NOACTION_DEFUSR
  74+ 5EE4 ~             DW NOACTION_DEFUSR
  75+ 5EE4 ~             DW NOACTION_DEFUSR
  76+ 5EE4               ENDIF
  77+ 5EE4
  78+ 5EE4               IF (BOX_CMDS == 1)
  79+ 5EE4 6F 57         DW BOXMEMCPY_DEFUSR            ; 15
  80+ 5EE6 A5 57         DW BOXMEMVRM_DEFUSR            ; 16
  81+ 5EE8               ELSE
  82+ 5EE8 ~             DW NOACTION_DEFUSR
  83+ 5EE8 ~             DW NOACTION_DEFUSR
  84+ 5EE8               ENDIF
  85+ 5EE8
  86+ 5EE8               IF (ANIM_CMDS == 1)
  87+ 5EE8 3D 4F         DW MAXANIMITEMS_DEFUSR         ; 17
  88+ 5EEA 59 50         DW MAXANIMDEFS_DEFUSR          ; 18
  89+ 5EEC BE 50         DW MAXANIMSPRS_DEFUSR          ; 19
  90+ 5EEE 8D 51         DW MAXAUTOSGAMS_DEFUSR         ; 20
  91+ 5EF0 05 50         DW ANIMITEMPAT_DEFUSR          ; 21
  92+ 5EF2 2F 50         DW ANIMITEMPTR_DEFUSR          ; 22
  93+ 5EF4 93 50         DW ANIMDEF_DEFUSR              ; 23
  94+ 5EF6 0E 51         DW ANIMSPRITE_DEFUSR           ; 24
  95+ 5EF8 4C 51         DW ANIMCHAR_DEFUSR             ; 25
  96+ 5EFA E1 51         DW AUTOSGAMDEF_DEFUSR          ; 26
  97+ 5EFC 77 52         DW AUTOSGAMSTART_DEFUSR        ; 27
  98+ 5EFE A3 52         DW AUTOSGAMSTOP_DEFUSR         ; 28
  99+ 5F00               ELSE
 100+ 5F00 ~             DW NOACTION_DEFUSR
 101+ 5F00 ~             DW NOACTION_DEFUSR
 102+ 5F00 ~             DW NOACTION_DEFUSR
 103+ 5F00 ~             DW NOACTION_DEFUSR
 104+ 5F00 ~             DW NOACTION_DEFUSR
 105+ 5F00 ~             DW NOACTION_DEFUSR
 106+ 5F00 ~             DW NOACTION_DEFUSR
 107+ 5F00 ~             DW NOACTION_DEFUSR
 108+ 5F00 ~             DW NOACTION_DEFUSR
 109+ 5F00 ~             DW NOACTION_DEFUSR
 110+ 5F00 ~             DW NOACTION_DEFUSR
 111+ 5F00 ~             DW NOACTION_DEFUSR
 112+ 5F00               ENDIF
 113+ 5F00
 114+ 5F00               IF (GENCAL_CMD == 1)
 115+ 5F00 EE 56         DW GENCAL_DEFUSR               ; 29
 116+ 5F02               ELSE
 117+ 5F02 ~             DW NOACTION_DEFUSR
 118+ 5F02               ENDIF
 119+ 5F02
 120+ 5F02               IF (RAM_CMDS == 1)
 121+ 5F02 7B 55         DW FILRAM_DEFUSR               ; 30
 122+ 5F04               ELSE
 123+ 5F04 ~             DW NOACTION_DEFUSR
 124+ 5F04               ENDIF
 125+ 5F04
 126+ 5F04               IF (SOUND_CMDS == 1)
 127+ 5F04 A9 55         DW SNDPLYINI_DEFUSR            ; 31
 128+ 5F06 DA 55         DW SNDPLYON_DEFUSR             ; 32
 129+ 5F08 EB 55         DW SNDPLYOFF_DEFUSR            ; 33
 130+ 5F0A               ELSE
 131+ 5F0A ~             DW NOACTION_DEFUSR
 132+ 5F0A ~             DW NOACTION_DEFUSR
 133+ 5F0A ~             DW NOACTION_DEFUSR
 134+ 5F0A               ENDIF
 135+ 5F0A
 136+ 5F0A               IF (TILE_CMDS == 1)
 137+ 5F0A 44 5A         DW TILERAM_DEFUSR              ; 34
 138+ 5F0C F7 5A         DW TILEVRM_DEFUSR              ; 35
 139+ 5F0E               ELSE
 140+ 5F0E ~             DW NOACTION_DEFUSR
 141+ 5F0E ~             DW NOACTION_DEFUSR
 142+ 5F0E               ENDIF
 143+ 5F0E
 144+ 5F0E               IF (VRAM_CMDS == 1)
 145+ 5F0E 30 56         DW FILVRM_DEFUSR               ; 36
 146+ 5F10 B2 56         DW VRMMEM_DEFUSR               ; 37
 147+ 5F12               ELSE
 148+ 5F12 ~             DW NOACTION_DEFUSR
 149+ 5F12 ~             DW NOACTION_DEFUSR
 150+ 5F12               ENDIF
 151+ 5F12
 152+ 5F12               IF (DECOMP_CMDS == 1)
 153+ 5F12 5C 5D         DW UNPACK_DEFUSR               ; 38
 154+ 5F14               IF (VRAM_CMDS == 1)
 155+ 5F14 46 5D          DW VUNPACK_DEFUSR             ; 39
 156+ 5F16               ELSE
 157+ 5F16 ~              DW NOACTION_DEFUSR
 158+ 5F16               ENDIF
 159+ 5F16               ELSE
 160+ 5F16 ~             DW NOACTION_DEFUSR
 161+ 5F16 ~             DW NOACTION_DEFUSR
 162+ 5F16               ENDIF
 163+ 5F16
 164+ 5F16               IF (DLOAD_CMD == 1)
 165+ 5F16 90 5E         DW DLOAD_DEFUSR               ; 40
 166+ 5F18               ELSE
 167+ 5F18 ~             DW NOACTION_DEFUSR
 168+ 5F18               ENDIF
 169+ 5F18
 170+ 5F18              ; *******************************************************************************************************
 171+ 5F18              ; function jumps to specified function based on inputs and returns success flag in (DAC+2) of type integer
 172+ 5F18              ; input INT(DAC+2) function ID = 0..DEFUSR_TABLE_ENTRIES-1
 173+ 5F18              ; input function specific parameters after the function ID, these are handled later in a called fn
 174+ 5F18              ; output stores back A to (DAC+2) and set type to INT, A=0 success
 175+ 5F18              DEFUSR_ENTRY:
 176+ 5F18 FB               EI
 177+ 5F19 DD 2A F8 F7      LD IX,(DAC+2)
 178+ 5F1D DD 7E 00         LD A,(IX)
 179+ 5F20 FE 29            CP DEFUSR_TABLE_ENTRIES
 180+ 5F22 30 11            JR NC,.RET ; return if an undefined function requested
 181+ 5F24 26 00            LD H,0
 182+ 5F26 6F               LD L,A
 183+ 5F27 29               ADD HL,HL
 184+ 5F28 11 C6 5E         LD DE,DEFUSR_JUMP_TABLE
 185+ 5F2B 19               ADD HL,DE
 186+ 5F2C 7E               LD A,(HL)
 187+ 5F2D 23               INC HL
 188+ 5F2E 66               LD H,(HL)
 189+ 5F2F 6F               LD L,A
 190+ 5F30 11 35 5F         LD DE,.RET
 191+ 5F33 D5               PUSH DE
 192+ 5F34 E9               JP (HL) ; call function with IX=pointer to data array
 193+ 5F35              .RET:
 194+ 5F35 26 00            LD H,0
 195+ 5F37 6F               LD L,A
 196+ 5F38 22 F8 F7         LD (DAC+2),HL
 197+ 5F3B 3E 02            LD A,2 ; INT
 198+ 5F3D 32 63 F6         LD (VALTYP),A
 199+ 5F40 C9               RET
 200+ 5F41
 201+ 5F41
# file closed: asm\DEFUSR.asm
 184  5F41               ENDIF
 185  5F41
 186  5F41              ; temp variables for various fuctions
 187  5F41              ; name historically from usage by BLIT, but since then
 188  5F41              BLIT_TMP:
 189  5F41              TILETMP1:
 190  5F41              BLIT_TMP1:
 191  5F41 00 00         DW 0
 192  5F43              TILETMP2:
 193  5F43              BLIT_TMP2:
 194  5F43 00 00         DW 0
 195  5F45              TMP_STRUCT:
 196  5F45 00 00 00...   DS 17
 197  5F56
 198  5F56               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 199  5F56              VRAM_UPDATE_IN_PROGRESS:
 200  5F56 00            DB 0
 201  5F57               ENDIF
 202  5F57
 203  5F57              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 204  5F57              ; per starting letter, if no commands with this letter, NULL value
 205  5F57              CMDS:
 206  5F57 8B 5F        	DW CMDS_A ; always present due to ARTINFO
 207  5F59               IF (BLIT_CMDS + BOX_CMDS > 0) && (0 == 1)
 208  5F59 ~                DW CMDS_B ; B
 209  5F59               ELSE
 210  5F59 00 00        	DW 0
 211  5F5B               ENDIF
 212  5F5B               IF (COLL_CMD == 1) && (0 == 1)
 213  5F5B ~            	DW CMDS_C ;
 214  5F5B               ELSE
 215  5F5B 00 00            DW 0 ; C
 216  5F5D               ENDIF
 217  5F5D               IF (DLOAD_CMD > 0) && (0 == 1)
 218  5F5D ~                DW CMDS_D ; D
 219  5F5D               ELSE
 220  5F5D 00 00        	DW 0
 221  5F5F               ENDIF
 222  5F5F 00 00            DW 0 ; E
 223  5F61               IF (VRAM_CMDS + RAM_CMDS > 0) && (0 == 1)
 224  5F61 ~                DW CMDS_F; F
 225  5F61               ELSE
 226  5F61 00 00        	DW 0
 227  5F63               ENDIF
 228  5F63               IF (GENCAL_CMD > 0) && (0 == 1)
 229  5F63 ~                DW CMDS_G; G
 230  5F63               ELSE
 231  5F63 00 00        	DW 0
 232  5F65               ENDIF
 233  5F65 00 00            DW 0 ; H
 234  5F67 00 00            DW 0 ; I
 235  5F69 00 00            DW 0 ; J
 236  5F6B 00 00            DW 0 ; K
 237  5F6D 00 00            DW 0 ; L
 238  5F6F               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0) && (0 == 1)
 239  5F6F ~                DW CMDS_M ; M
 240  5F6F               ELSE
 241  5F6F 00 00        	DW 0
 242  5F71               ENDIF
 243  5F71 00 00            DW 0 ; N
 244  5F73 00 00            DW 0 ; O
 245  5F75 00 00            DW 0 ; P
 246  5F77 00 00            DW 0 ; Q
 247  5F79 00 00            DW 0 ; R
 248  5F7B               IF (SOUND_CMDS + SPRITE_CMDS > 0) && (0 == 1)
 249  5F7B ~                DW CMDS_S ; S
 250  5F7B               ELSE
 251  5F7B 00 00        	DW 0
 252  5F7D               ENDIF
 253  5F7D               IF (TILE_CMDS > 0) && (0 == 1)
 254  5F7D ~                DW CMDS_T ; T
 255  5F7D               ELSE
 256  5F7D 00 00        	DW 0
 257  5F7F               ENDIF
 258  5F7F               IF (DECOMP_CMDS > 0) && (0 == 1)
 259  5F7F ~                DW CMDS_U ; U
 260  5F7F               ELSE
 261  5F7F 00 00        	DW 0
 262  5F81               ENDIF
 263  5F81               IF ((VRAM_CMDS > 0) || (VRAM_CMDS + DECOMP_CMDS > 1)) && (0 == 1)
 264  5F81 ~                DW CMDS_V ; V
 265  5F81               ELSE
 266  5F81 00 00        	DW 0
 267  5F83               ENDIF
 268  5F83 00 00            DW 0 ; W
 269  5F85 00 00            DW 0 ; X
 270  5F87 00 00            DW 0 ; Y
 271  5F89 00 00            DW 0 ; Z
 272  5F8B
 273  5F8B               IF (0 == 1)
 274  5F8B ~             IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 275  5F8B ~            CMDS_M:
 276  5F8B ~             IF (VRAM_CMDS == 1)
 277  5F8B ~                DB "MEMVRM", 0
 278  5F8B ~                DW MEMVRM
 279  5F8B ~             ENDIF
 280  5F8B ~             IF (RAM_CMDS == 1)
 281  5F8B ~            	DB "MEMCPY", 0
 282  5F8B ~            	DW MEMCPY
 283  5F8B ~             ENDIF
 284  5F8B ~             IF (ANIM_CMDS == 1)
 285  5F8B ~            	DB "MAXANIMITEMS",0
 286  5F8B ~            	DW MAXANIMITEMS
 287  5F8B ~            	DB "MAXANIMDEFS",0
 288  5F8B ~            	DW MAXANIMDEFS
 289  5F8B ~            	DB "MAXANIMSPRS",0
 290  5F8B ~            	DW MAXANIMSPRS
 291  5F8B ~               DB "MAXAUTOSGAMS",0
 292  5F8B ~               DW MAXAUTOSGAMS
 293  5F8B ~             ENDIF
 294  5F8B ~             ENDIF
 295  5F8B ~
 296  5F8B ~             IF (VRAM_CMDS + RAM_CMDS > 0)
 297  5F8B ~            CMDS_F:
 298  5F8B ~             IF (VRAM_CMDS == 1)
 299  5F8B ~                DB "FILVRM", 0
 300  5F8B ~                DW FILVRM
 301  5F8B ~             ENDIF
 302  5F8B ~             IF (RAM_CMDS == 1)
 303  5F8B ~                DB "FILRAM", 0
 304  5F8B ~                DW FILRAM
 305  5F8B ~             ENDIF
 306  5F8B ~             ENDIF
 307  5F8B ~
 308  5F8B ~             IF (GENCAL_CMD > 0)
 309  5F8B ~            CMDS_G:
 310  5F8B ~             IF (GENCAL_CMD == 1)
 311  5F8B ~                DB "GENCAL", 0
 312  5F8B ~                DW GENCAL
 313  5F8B ~             ENDIF
 314  5F8B ~             ENDIF
 315  5F8B ~
 316  5F8B ~             IF (VRAM_CMDS > 0)
 317  5F8B ~            CMDS_V:
 318  5F8B ~             IF (VRAM_CMDS == 1)
 319  5F8B ~            	DB "VRMMEM", 0
 320  5F8B ~            	DW VRMMEM
 321  5F8B ~             ENDIF
 322  5F8B ~             IF (DECOMP_CMDS == 1)
 323  5F8B ~            	DB "VUNPACK", 0
 324  5F8B ~            	DW VUNPACK
 325  5F8B ~             ENDIF
 326  5F8B ~             ENDIF
 327  5F8B ~
 328  5F8B ~             IF (SOUND_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 329  5F8B ~            CMDS_S:
 330  5F8B ~             IF (SPRITE_CMDS + ANIM_CMDS > 0)
 331  5F8B ~                DB "SGAM",0
 332  5F8B ~                DW SGAM
 333  5F8B ~             ENDIF
 334  5F8B ~             IF (SPRITE_CMDS == 1)
 335  5F8B ~            	DB "SPRGRPMOV", 0
 336  5F8B ~            	DW SPRGRPMOV
 337  5F8B ~             ENDIF
 338  5F8B ~             IF (SOUND_CMDS == 1)
 339  5F8B ~            	DB "SNDSFX", 0
 340  5F8B ~            	DW SNDSFX
 341  5F8B ~            	DB "SNDPLYON", 0
 342  5F8B ~            	DW SNDPLYON
 343  5F8B ~            	DB "SNDPLYOFF", 0
 344  5F8B ~            	DW SNDPLYOFF
 345  5F8B ~            	DB "SNDPLYINI", 0
 346  5F8B ~            	DW SNDPLYINIT
 347  5F8B ~             ENDIF
 348  5F8B ~             IF (SPRITE_CMDS == 1)
 349  5F8B ~            	DB "SPRENABLE", 0
 350  5F8B ~            	DW SPRENABLE
 351  5F8B ~            	DB "SPRDISABLE", 0
 352  5F8B ~            	DW SPRDISABLE
 353  5F8B ~             ENDIF
 354  5F8B ~             ENDIF
 355  5F8B ~
 356  5F8B ~             IF (BLIT_CMDS + BOX_CMDS > 0)
 357  5F8B ~            CMDS_B:
 358  5F8B ~             IF (BLIT_CMDS == 1)
 359  5F8B ~            	DB "BLIT", 0
 360  5F8B ~            	DW BLIT
 361  5F8B ~             ENDIF
 362  5F8B ~             IF (BOX_CMDS == 1)
 363  5F8B ~            	DB "BOXMEMCPY", 0
 364  5F8B ~            	DW BOXMEMCPY
 365  5F8B ~            	DB "BOXMEMVRM", 0
 366  5F8B ~            	DW BOXMEMVRM
 367  5F8B ~             ENDIF
 368  5F8B ~             ENDIF
 369  5F8B ~
 370  5F8B ~             IF (TILE_CMDS > 0)
 371  5F8B ~            CMDS_T:
 372  5F8B ~             IF (TILE_CMDS == 1)
 373  5F8B ~            	DB "TILERAM", 0
 374  5F8B ~            	DW TILERAM
 375  5F8B ~            	DB "TILEVRM", 0
 376  5F8B ~            	DW TILEVRM
 377  5F8B ~             ENDIF
 378  5F8B ~             ENDIF
 379  5F8B ~
 380  5F8B ~             IF (COLL_CMD > 0)
 381  5F8B ~            CMDS_C:
 382  5F8B ~             IF (COLL_CMD == 1)
 383  5F8B ~                DB "COLL", 0
 384  5F8B ~                DW COLL
 385  5F8B ~             ENDIF
 386  5F8B ~             ENDIF
 387  5F8B ~
 388  5F8B ~             IF (DECOMP_CMDS > 0)
 389  5F8B ~            CMDS_U:
 390  5F8B ~             IF (DECOMP_CMDS == 1)
 391  5F8B ~                DB "UNPACK", 0
 392  5F8B ~                DW UNPACK
 393  5F8B ~             ENDIF
 394  5F8B ~             ENDIF
 395  5F8B ~
 396  5F8B ~             IF (DLOAD_CMD > 0)
 397  5F8B ~            CMDS_D:
 398  5F8B ~             IF (DLOAD_CMD == 1)
 399  5F8B ~                DB "DLOAD", 0
 400  5F8B ~                DW DLOAD
 401  5F8B ~             ENDIF
 402  5F8B ~             ENDIF
 403  5F8B ~
 404  5F8B ~            CMDS_A:
 405  5F8B ~             IF (ANIM_CMDS == 1)
 406  5F8B ~               DB "ANIMSTEP",0
 407  5F8B ~               DW ANIMSTEP
 408  5F8B ~            	DB "ANIMSTART",0
 409  5F8B ~            	DW ANIMSTART
 410  5F8B ~            	DB "ANIMSTOP",0
 411  5F8B ~            	DW ANIMSTOP
 412  5F8B ~            	DB "ANIMITEMPAT",0
 413  5F8B ~            	DW ANIMITEMPAT
 414  5F8B ~            	DB "ANIMITEMPTR",0
 415  5F8B ~            	DW ANIMITEMPTR_CMD
 416  5F8B ~            	DB "ANIMDEF",0
 417  5F8B ~            	DW ANIMDEF
 418  5F8B ~            	DB "ANIMSPRITE",0
 419  5F8B ~            	DW ANIMSPRITE
 420  5F8B ~               DB "ANIMCHAR",0
 421  5F8B ~               DW ANIMCHAR
 422  5F8B ~               DB "AUTOSGAMDEF",0
 423  5F8B ~               DW AUTOSGAMDEF
 424  5F8B ~               DB "AUTOSGAMSTART",0
 425  5F8B ~               DW AUTOSGAMSTART
 426  5F8B ~               DB "AUTOSGAMSTOP",0
 427  5F8B ~               DW AUTOSGAMSTOP
 428  5F8B ~             ENDIF
 429  5F8B ~               DB "ARTINFO",0
 430  5F8B ~               DW ARTINFO
 431  5F8B ~            	DB 0
 432  5F8B               ELSE // if not BASIC extension
 433  5F8B              CMDS_A:
 434  5F8B 41 52 54 49     DB "ARTINFO",0
 434  5F8F 4E 46 4F 00
 435  5F93 F8 60           DW ARTINFO
 436  5F95 00           	DB 0
 437  5F96               ENDIF
 438  5F96
 439  5F96              ; ****************************************************************************************************
 440  5F96              ; some common exit code
 441  5F96              ; returns ROM in page 0
 442  5F96              ; sets exit status to 0 in A
 443  5F96              COMMON_EXIT_CODE_IX:
 444  5F96 DD E5           PUSH IX
 445  5F98 E1              POP HL
 446  5F99              COMMON_EXIT_CODE:
 447  5F99 D1              POP DE
 448  5F9A C1              POP BC
 449  5F9B CD FA 5F        CALL RESTORE_PAGE_INFO
 450  5F9E AF           	XOR A ; success
 451  5F9F C9           	RET
 452  5FA0              ; ****************************************************************************************************
 453  5FA0
 454  5FA0               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 455  5FA0              ; ****************************************************************************************************
 456  5FA0              ; function sets VRAM address for writing
 457  5FA0              ; input HL=address
 458  5FA0              ; modifies AF
 459  5FA0              SETWRT_LOCAL_WRITE:
 460  5FA0 7D           	LD	A,L
 461  5FA1 D3 99        	OUT (#99),A
 462  5FA3 7C           	LD	A,H
 463  5FA4 E6 3F        	AND #3F
 464  5FA6 F6 40        	OR	#40
 465  5FA8 D3 99        	OUT (#99),A
 466  5FAA C9           	RET
 467  5FAB              ; ****************************************************************************************************
 468  5FAB
 469  5FAB              ; ****************************************************************************************************
 470  5FAB              ; function sets VRAM address for reading
 471  5FAB              ; input HL=address
 472  5FAB              ; modifies AF
 473  5FAB              SETWRT_LOCAL_READ:
 474  5FAB 7D           	LD	A,L
 475  5FAC D3 99        	OUT (#99),A
 476  5FAE 7C           	LD	A,H
 477  5FAF E6 3F        	AND #3F
 478  5FB1 00              NOP
 479  5FB2 D3 99        	OUT (#99),A
 480  5FB4 C9           	RET
 481  5FB5              ; ****************************************************************************************************
 482  5FB5               ENDIF
 483  5FB5
 484  5FB5               IF (VRAM_CMDS + TILE_CMDS > 0)
 485  5FB5              ; ****************************************************************************************************
 486  5FB5              ; function copies data from RAM to VRAM
 487  5FB5              ; input HL=address in RAM
 488  5FB5              ; input B=count
 489  5FB5              ; modifies AF, BC, HL
 490  5FB5              BBYTECOPY:
 491  5FB5 0E 98        	LD C,#98
 492  5FB7              BBYTECOPY_NO_C:
 493  5FB7 ED A3        	OUTI
 494  5FB9 C2 B7 5F     	JP	NZ, BBYTECOPY_NO_C
 495  5FBC C9           	RET
 496  5FBD              ; ****************************************************************************************************
 497  5FBD               ENDIF
 498  5FBD
 499  5FBD              ; ****************************************************************************************************
 500  5FBD              ; function multiplies HL by 32
 501  5FBD              HLx32:
 502  5FBD 29           	ADD HL,HL
 503  5FBE              ; ****************************************************************************************************
 504  5FBE              ; function multiplies HL by 16
 505  5FBE              HLx16:
 506  5FBE 29           	ADD HL,HL
 507  5FBF              ; ****************************************************************************************************
 508  5FBF              ; function multiplies HL by 8
 509  5FBF              HLx8:
 510  5FBF 29          > ADD HL, HL
 510  5FC0 29          > ADD HL, HL
 510  5FC1 29          > ADD HL, HL
 511  5FC2 C9           	RET
 512  5FC3              ; ****************************************************************************************************
 513  5FC3
 514  5FC3              ; ****************************************************************************************************
 515  5FC3              ; function gets slot and subslot data for specific page
 516  5FC3              ; input A=page (0, 1 or 2)
 517  5FC3              ; output B = 0A8H register value
 518  5FC3              ; output D = 0 is no subslots, 1 if yes
 519  5FC3              ; output C = 0A8H value when page 3 slot equals to requested page slot
 520  5FC3              ; output E = subslot value if present
 521  5FC3              ; modifies AF, BC, DE, HL
 522  5FC3              GET_PAGE_INFO:
 523  5FC3 6F               LD L, A
 524  5FC4 C6 C1            ADD A, low (EXPTBL)
 525  5FC6 32 D0 5F         LD (GET_PAGE_INFO_L1+1), A
 526  5FC9 DB A8            IN A, (0A8H)
 527  5FCB 47               LD B, A
 528  5FCC E6 3F            AND 03FH
 529  5FCE 4F               LD C, A
 530  5FCF              GET_PAGE_INFO_L1:
 531  5FCF 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 532  5FD2 E6 80            AND 080H
 533  5FD4 28 1B            JR Z, GET_PAGE_INFO_L2
 534  5FD6                  ; expanded
 535  5FD6 2D               DEC L
 536  5FD7 FA F6 5F         JP M, GET_PAGE_INFO_L3
 537  5FDA 2D               DEC L
 538  5FDB FA F4 5F         JP M, GET_PAGE_INFO_L4
 539  5FDE                  ; page 2
 540  5FDE 07               RLCA
 541  5FDF 07               RLCA
 542  5FE0              GET_PAGE_INFO_L5:
 543  5FE0 E6 C0            AND 0C0H
 544  5FE2 B1               OR C
 545  5FE3 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 546  5FE5 4F               LD C, A
 547  5FE6 3A FF FF         LD A, (0FFFFH)
 548  5FE9 2F               CPL
 549  5FEA 5F               LD E, A
 550  5FEB 16 01            LD D, 1
 551  5FED 78               LD A, B ; return stack
 552  5FEE D3 A8            OUT (0A8H), A
 553  5FF0 C9               RET
 554  5FF1              GET_PAGE_INFO_L2:
 555  5FF1                  ; not expanded
 556  5FF1 16 00            LD D, 0
 557  5FF3 C9               RET
 558  5FF4              GET_PAGE_INFO_L4:
 559  5FF4                  ; page 1
 560  5FF4 0F               RRCA
 561  5FF5 0F               RRCA
 562  5FF6              GET_PAGE_INFO_L3:
 563  5FF6                  ; page 0
 564  5FF6 0F               RRCA
 565  5FF7 0F               RRCA
 566  5FF8 18 E6            JR GET_PAGE_INFO_L5
 567  5FFA              ; ****************************************************************************************************
 568  5FFA
 569  5FFA              ; ****************************************************************************************************
 570  5FFA              ; function returns original slot and subslot info
 571  5FFA              ; input B = 0A8H register value
 572  5FFA              ; input D = 0 is no subslots, 1 if yes
 573  5FFA              ; input C = 0A8H value when page 3 slot equals to requested page slot
 574  5FFA              ; input E = subslot value if present
 575  5FFA              ; modifies AF, disables interrupts
 576  5FFA              RESTORE_PAGE_INFO:
 577  5FFA F3              DI
 578  5FFB 7A              LD A, D
 579  5FFC B7              OR A
 580  5FFD 28 07           JR Z, RESTORE_PAGE_INFO_L1
 581  5FFF 79              LD A, C
 582  6000 D3 A8           OUT (0A8H), A
 583  6002 7B              LD A, E
 584  6003 32 FF FF        LD (0FFFFH), A
 585  6006              RESTORE_PAGE_INFO_L1:
 586  6006 78              LD A, B
 587  6007 D3 A8           OUT (0A8H), A
 588  6009              NOACTION_DEFUSR: ; just a safe RET for use when DEFUSR table has an empty entry
 589  6009 C9              RET
 590  600A              ; ****************************************************************************************************
 591  600A
 592  600A              ; *******************************************************************************************************
 593  600A              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 594  600A              ; INPUT:  A = SLOT ID: EXXXSSPP
 595  600A              ; E = EXPANDED FLAG
 596  600A              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 597  600A              ; PP = PRIMARY SLOT NUMBER
 598  600A              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 599  600A              ; CHANGES: AF, BC, DE
 600  600A
 601  600A              LOCAL_ENASLT:
 602  600A CD 2A 60         CALL L0353
 603  600D FA 17 60         JP M, L0340
 604  6010 DB A8            IN A, (0A8H)
 605  6012 A1               AND C
 606  6013 B0               OR B
 607  6014 D3 A8            OUT (0A8H), A
 608  6016 C9               RET
 609  6017              L0340:
 610  6017 E5               PUSH HL
 611  6018 CD 4F 60         CALL L0378
 612  601B 4F               LD C, A
 613  601C 06 00            LD B, 0
 614  601E 7D               LD A, L
 615  601F A4               AND H
 616  6020 B2               OR D
 617  6021 21 C5 FC         LD HL, 0FCC5H
 618  6024 09               ADD HL, BC
 619  6025 77               LD (HL), A
 620  6026 E1               POP HL
 621  6027 79               LD A, C
 622  6028 18 E0            JR LOCAL_ENASLT
 623  602A              L0353:
 624  602A F3               DI
 625  602B F5               PUSH AF
 626  602C 7C               LD A, H
 627  602D 07               RLCA
 628  602E 07               RLCA
 629  602F E6 03            AND 3
 630  6031 5F               LD E, A
 631  6032 3E C0            LD A, 0C0H
 632  6034              L035D:
 633  6034 07               RLCA
 634  6035 07               RLCA
 635  6036 1D               DEC E
 636  6037 F2 34 60         JP P, L035D
 637  603A 5F               LD E, A
 638  603B 2F               CPL
 639  603C 4F               LD C, A
 640  603D F1               POP AF
 641  603E F5               PUSH AF
 642  603F E6 03            AND 3
 643  6041 3C               INC A
 644  6042 47               LD B, A
 645  6043 3E AB            LD A, 0ABH
 646  6045              L036E:
 647  6045 C6 55            ADD A, 055H
 648  6047 10 FC            DJNZ L036E
 649  6049 57               LD D, A
 650  604A A3               AND E
 651  604B 47               LD B, A
 652  604C F1               POP AF
 653  604D A7               AND A
 654  604E C9               RET
 655  604F              L0378:
 656  604F F5               PUSH AF
 657  6050 7A               LD A, D
 658  6051 E6 C0            AND 0C0H
 659  6053 4F               LD C, A
 660  6054 F1               POP AF
 661  6055 F5               PUSH AF
 662  6056 57               LD D, A
 663  6057 DB A8            IN A, (0A8H)
 664  6059 47               LD B, A
 665  605A E6 3F            AND 03FH
 666  605C B1               OR C
 667  605D D3 A8            OUT (0A8H), A
 668  605F 7A               LD A, D
 669  6060 0F               RRCA
 670  6061 0F               RRCA
 671  6062 E6 03            AND 3
 672  6064 57               LD D, A
 673  6065 3E AB            LD A, 0ABH
 674  6067              L0390:
 675  6067 C6 55            ADD A, 055H
 676  6069 15               DEC D
 677  606A F2 67 60         JP P, L0390
 678  606D A3               AND E
 679  606E 57               LD D, A
 680  606F 7B               LD A, E
 681  6070 2F               CPL
 682  6071 67               LD H, A
 683  6072 3A FF FF         LD A, (0FFFFH)
 684  6075 2F               CPL
 685  6076 6F               LD L, A
 686  6077 A4               AND H
 687  6078 B2               OR D
 688  6079 32 FF FF         LD (0FFFFH), A
 689  607C 78               LD A, B
 690  607D D3 A8            OUT (0A8H), A
 691  607F F1               POP AF
 692  6080 E6 03            AND 3
 693  6082 C9               RET
 694  6083              ; *******************************************************************************************************
 695  6083
 696  6083              ; *******************************************************************************************************
 697  6083              ; some common code to activate page 0 and place values needed to restore original page on stack
 698  6083              ; input IY=return address
 699  6083              ENABLE_PAGE0:
 700  6083 F3              DI
 701  6084 AF              XOR A
 702  6085 CD C3 5F        CALL GET_PAGE_INFO
 703  6088 C5              PUSH BC
 704  6089 D5              PUSH DE
 705  608A 3A 41 F3        LD A, (RAMAD0)
 706  608D 26 00           LD H, 0
 707  608F CD 0A 60        CALL LOCAL_ENASLT
 708  6092 FD E9        	JP (IY)
 709  6094              ; *******************************************************************************************************
 710  6094
 711  6094              ; General BASIC CALL-instruction handler
 712  6094              CALLHAND:
 713  6094 FB              EI
 714  6095 E5           	PUSH HL
 715  6096 21 57 5F     	LD	HL, CMDS ; pointer table based on starting letter
 716  6099 3A 89 FD        LD A, (PROCNM)
 717  609C D6 41           SUB 'A'
 718  609E 87              ADD A, A
 719  609F 16 00           LD D, 0
 720  60A1 5F              LD E, A
 721  60A2 19              ADD HL, DE
 722  60A3 5E              LD E, (HL)
 723  60A4 23              INC HL
 724  60A5 56              LD D, (HL)
 725  60A6 7A              LD A, D
 726  60A7 B3              OR E
 727  60A8 28 23           JR Z, .CMDNOTRECOGNIZED
 728  60AA EB              EX DE, HL
 729  60AB              .CHKCMD:
 730  60AB 11 89 FD     	LD	DE, PROCNM
 731  60AE              .LOOP:
 732  60AE 1A              LD	A,(DE)
 733  60AF BE           	CP	(HL)
 734  60B0 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 735  60B2 13           	INC	DE
 736  60B3 23           	INC	HL
 737  60B4 A7           	AND	A
 738  60B5 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 739  60B7 5E           	LD	E,(HL)
 740  60B8 23           	INC	HL
 741  60B9 56           	LD	D,(HL)
 742  60BA E1           	POP	HL		; routine address
 743  60BB CD DC 60     	CALL	GETPREVCHAR
 744  60BE CD D0 60     	CALL	.CALLDE		; Call routine
 745  60C1 A7           	AND	A
 746  60C2 C9           	RET
 747  60C3
 748  60C3              .TONEXTCMD:
 749  60C3 0E FF        	LD	C,0FFH
 750  60C5 AF           	XOR	A
 751  60C6 ED B1        	CPIR			; Skip to end of instruction name
 752  60C8 23           	INC	HL
 753  60C9 23           	INC	HL		; Skip address
 754  60CA BE           	CP	(HL)
 755  60CB 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 756  60CD              .CMDNOTRECOGNIZED:
 757  60CD E1           	POP	HL
 758  60CE 37              SCF
 759  60CF C9           	RET
 760  60D0
 761  60D0              .CALLDE:
 762  60D0 D5           	PUSH	DE
 763  60D1 C9           	RET
 764  60D2
 765  60D2              ;---------------------------
 766  60D2
 767  60D2              CHKCHAR:
 768  60D2 CD DC 60     	CALL	GETPREVCHAR	; Get previous basic char
 769  60D5 E3           	EX	(SP),HL
 770  60D6 BE           	CP	(HL) 	        ; Check if good char
 771  60D7 20 0D        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 772  60D9 23           	INC	HL
 773  60DA E3           	EX	(SP),HL
 774  60DB 23           	INC	HL		; Get next basic char
 775  60DC
 776  60DC              GETPREVCHAR:
 777  60DC 2B           	DEC HL
 778  60DD DD 21 66 46  	LD	IX,CHRGTR
 779  60E1 CD 59 01     	CALL CALBAS
 780  60E4 FB              EI
 781  60E5 C9              RET
 782  60E6
 783  60E6               IF (0 == 1)
 784  60E6 ~             IF (DLOAD_CMD == 1)
 785  60E6 ~            BAD_FILENAME:
 786  60E6 ~               LD E,56
 787  60E6 ~               JR THROW_ERROR
 788  60E6 ~            DISKIOERR:
 789  60E6 ~               LD E,69
 790  60E6 ~               JR THROW_ERROR
 791  60E6 ~             ENDIF
 792  60E6 ~            OUT_OF_DATA:
 793  60E6 ~               LD E, 4
 794  60E6 ~               JR THROW_ERROR
 795  60E6 ~            TYPE_MISMATCH:
 796  60E6 ~               LD E, 13 ; Type mismatch
 797  60E6 ~               JR THROW_ERROR
 798  60E6 ~            SUBSCRIPT_OUT_OF_RANGE:
 799  60E6 ~               LD E,9 ; subscript out of range
 800  60E6 ~            	JR THROW_ERROR
 801  60E6 ~            OVERFLOW:
 802  60E6 ~            	LD E,6
 803  60E6 ~            	JR THROW_ERROR
 804  60E6 ~            ILLEGAL_FUNCTION:
 805  60E6 ~               LD E, 5 ; illegal function call
 806  60E6 ~               JR THROW_ERROR
 807  60E6               ENDIF
 808  60E6              SYNTAX_ERROR:
 809  60E6 1E 02           LD E, 2 ; Syntax error
 810  60E8              THROW_ERROR:
 811  60E8 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 812  60EC C3 59 01     	JP	CALBAS
 813  60EF
 814  60EF
 815  60EF              ;---------------------------
 816  60EF
 817  60EF               IF (DLOAD_CMD == 1)
 818  60EF              ; *******************************************************************************************************
 819  60EF              ; helper function to make an uppercase letter
 820  60EF              ; input A=character
 821  60EF              ; output A=uppercase version of input
 822  60EF              UPPER:
 823  60EF FE 61           CP "a"
 824  60F1 D8              RET C
 825  60F2 FE 7B           CP "z"+1
 826  60F4 D0              RET NC
 827  60F5 E6 5F           AND 5FH
 828  60F7 C9              RET
 829  60F8              ; *******************************************************************************************************
 830  60F8               ENDIF
 831  60F8
 832  60F8               IF (0 == 1)
 833  60F8 ~
 834  60F8 ~             IF (DLOAD_CMD == 1)
 835  60F8 ~            ; *******************************************************************************************************
 836  60F8 ~            ; helper function to return string pointer and length
 837  60F8 ~            ; returns HL = String Address
 838  60F8 ~            ; returns B  = Lenght
 839  60F8 ~            ; modifies BC, DE, HL
 840  60F8 ~            GETSTRPNT:
 841  60F8 ~               LD      HL,(USR)
 842  60F8 ~               LD      B,(HL)
 843  60F8 ~               INC     HL
 844  60F8 ~               LD      E,(HL)
 845  60F8 ~               INC     HL
 846  60F8 ~               LD      D,(HL)
 847  60F8 ~               EX      DE,HL
 848  60F8 ~               RET
 849  60F8 ~            ; *******************************************************************************************************
 850  60F8 ~
 851  60F8 ~            ; *******************************************************************************************************
 852  60F8 ~            ; helper function to get string parameter
 853  60F8 ~            ; throws error if incorrect type
 854  60F8 ~            ; input HL=basic text
 855  60F8 ~            EVALTXTPARAM:
 856  60F8 ~            	LD	IX,FRMEVL
 857  60F8 ~            	CALL CALBAS		; Evaluate expression
 858  60F8 ~               LD A,(VALTYP)
 859  60F8 ~               CP 3               ; Text type?
 860  60F8 ~               JP NZ,TYPE_MISMATCH
 861  60F8 ~               PUSH HL
 862  60F8 ~               LD	IX,FRESTR         ; Free the temporary string
 863  60F8 ~               CALL CALBAS
 864  60F8 ~               POP HL
 865  60F8 ~               RET
 866  60F8 ~            ; *******************************************************************************************************
 867  60F8 ~
 868  60F8 ~             ENDIF
 869  60F8 ~
 870  60F8 ~            ; *******************************************************************************************************
 871  60F8 ~            ; helper function to get pointer to BASIC array data
 872  60F8 ~            ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
 873  60F8 ~            ; input B=dimensions (1 or 2)
 874  60F8 ~            ; input D=minimal first dimension
 875  60F8 ~            ; input E=minimal second dimension, if applicable
 876  60F8 ~            ; returns BC=pointer to first data element
 877  60F8 ~            ; throws BASIC error if invalid type
 878  60F8 ~            GET_BASIC_ARRAY_DATA_POINTER:
 879  60F8 ~            	PUSH DE
 880  60F8 ~            	PUSH BC
 881  60F8 ~            	PUSH AF
 882  60F8 ~               LD A,1
 883  60F8 ~               LD (SUBFLG),A ; search for arrays only
 884  60F8 ~            	LD IX, PTRGET
 885  60F8 ~            	CALL CALBAS
 886  60F8 ~               XOR A
 887  60F8 ~               LD (SUBFLG),A ; if not reset will cause syntax errors
 888  60F8 ~            	LD A,(VALTYP)
 889  60F8 ~            	POP DE ; required type
 890  60F8 ~            	CP D
 891  60F8 ~            	JP NZ,TYPE_MISMATCH
 892  60F8 ~            	LD A,(BC)
 893  60F8 ~            	INC BC
 894  60F8 ~            	POP DE ; required number of dimensions
 895  60F8 ~            	CP D
 896  60F8 ~            	JP NZ,TYPE_MISMATCH
 897  60F8 ~            	POP DE ; required minimal array dimensions
 898  60F8 ~            	DEC A
 899  60F8 ~            	JR Z,.ONE_DIMENSION
 900  60F8 ~            	; 2-dimension array
 901  60F8 ~            	LD A,(BC)
 902  60F8 ~            	.2 INC BC
 903  60F8 ~            	CP E
 904  60F8 ~            	JP C,SUBSCRIPT_OUT_OF_RANGE
 905  60F8 ~            .ONE_DIMENSION:
 906  60F8 ~            	LD A,(BC)
 907  60F8 ~            	.2 INC BC
 908  60F8 ~            	CP D
 909  60F8 ~            	JP C,SUBSCRIPT_OUT_OF_RANGE
 910  60F8 ~            	RET
 911  60F8 ~            ; *******************************************************************************************************
 912  60F8               ENDIF
 913  60F8
 914  60F8              ; *******************************************************************************************************
 915  60F8              ; function to handle CALL ARTINFO basic extension
 916  60F8              ; returns info about the extension
 917  60F8              ; _ARTINFO ( INT variable version,
 918  60F8              ;			    INT variable build_flags,
 919  60F8              ;			    INT variable free_memory_ptr )
 920  60F8              ; this function is always available and can be used to test if the extension is active
 921  60F8              ARTINFO:
 922  60F8              	; opening (
 923  60F8 CD D2 60     	CALL CHKCHAR
 924  60FB 28           	DB '('
 925  60FC              	; get address of version variable
 926  60FC DD 21 A4 5E  	LD IX, PTRGET
 927  6100 CD 59 01     	CALL CALBAS
 928  6103 3A 12 40     	LD A,(VERSION)
 929  6106 12              LD (DE),A
 930  6107 13              INC DE
 931  6108 3A 13 40        LD A,(VERSION+1)
 932  610B 12              LD (DE),A
 933  610C              	; comma
 934  610C CD D2 60     	CALL CHKCHAR
 935  610F 2C           	DB ','
 936  6110              	; get address of build flags variable
 937  6110 DD 21 A4 5E  	LD IX, PTRGET
 938  6114 CD 59 01     	CALL CALBAS
 939  6117 E5              PUSH HL
 940  6118 21 FF 3B        LD HL,SOUND_CMDS+2*RAM_CMDS+4*VRAM_CMDS+8*BLIT_CMDS+16*SPRITE_CMDS+32*GENCAL_CMD+64*TILE_CMDS+128*BOX_CMDS+256*ANIM_CMDS+512*COLL_CMD+1024*0+2048*1+4096*DECOMP_CMDS+8192*DLOAD_CMD
 941  611B EB              EX DE,HL
 942  611C 73              LD (HL),E
 943  611D 23              INC HL
 944  611E 72              LD (HL),D
 945  611F E1              POP HL
 946  6120              	; comma
 947  6120 CD D2 60     	CALL CHKCHAR
 948  6123 2C           	DB ','
 949  6124              	; get address of free memory variable
 950  6124 DD 21 A4 5E  	LD IX, PTRGET
 951  6128 CD 59 01     	CALL CALBAS
 952  612B 3A 10 40     	LD A,(FREEMEMPTR)
 953  612E 12              LD (DE),A
 954  612F 13              INC DE
 955  6130 3A 11 40        LD A,(FREEMEMPTR+1)
 956  6133 12              LD (DE),A
 957  6134              	; ending )
 958  6134 CD D2 60     	CALL CHKCHAR
 959  6137 29           	DB ')'
 960  6138 C9           	RET
 961  6139              ; *******************************************************************************************************
 962  6139
 963  6139              EXT_END:
 964  6139
# file closed: asm\main.asm
