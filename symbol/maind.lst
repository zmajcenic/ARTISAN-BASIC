# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		   EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000              COLL_CMD       EQU 1
  14  4000              DECOMP_CMDS    EQU 1
  15  4000
  16  4000              ; what to compile, provided in sjasmplus command line
  17  4000              ;BASIC_EXTENSION   EQU 1
  18  4000              ;DEFUSR_EXTENSION  EQU 0
  19  4000
  20  4000              CHPUT   EQU    #A2
  21  4000              CALBAS  EQU		#159
  22  4000              ERRHAND EQU    #406F
  23  4000              FRMEVL  EQU    #4C64
  24  4000              FRESTR  EQU		#67D0
  25  4000              ; FRMQNT = formula quantificator
  26  4000              ; input HL=pointer to current program expression
  27  4000              ; output HL=next address
  28  4000              ; output DE=integer datum
  29  4000              FRMQNT	EQU		#542F
  30  4000              ; GETBYT = get byte parameter
  31  4000              ; input HL=pointer to current program expression
  32  4000              ; output HL=next address
  33  4000              ; output A=E=byte read
  34  4000              GETBYT		EQU	#521C
  35  4000              CHRGTR  	   EQU   #4666
  36  4000              PTRGET		EQU 	#5EA4
  37  4000              SUBFLG		EQU	#F6A5
  38  4000              SYNCHR		EQU	#558C
  39  4000              VALTYP  	   EQU   #F663
  40  4000              DAC         EQU   #F7F6
  41  4000              USR     	   EQU   #F7F8
  42  4000              PROCNM		EQU	#FD89
  43  4000              BIOS_FILVRM EQU   #0056
  44  4000              CLIKSW		EQU	#F3DB
  45  4000
  46  4000              RAMAD0	   EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  47  4000              RAMAD1	   EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  48  4000              RAMAD2	   EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  49  4000              RAMAD3	   EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  50  4000              EXPTBL	   EQU   #FCC1
  51  4000              SCRMOD	   EQU   #FCAF ; current screen mode
  52  4000              REG1SAV     EQU   #F3E0 ; VDP(1)
  53  4000              JIFFY	      EQU   #FC9E
  54  4000              GRPPAT	   EQU   #F3CF ; SCREEN 2 sprite generator table address
  55  4000              GRPCGP		EQU	#F3CB ; SCREEN 2 pattern generator table address
  56  4000              GRPATR      EQU   #F3CD ; SCREEN 2 sprite attribute table address
  57  4000              T32PAT	   EQU   #F3C5 ; SCREEN 1 sprite generator table address
  58  4000              T32CGP      EQU   #F3C1 ; SCREEN 1 pattern ganarator table address
  59  4000              T32ATR      EQU   #F3C3 ; SCREEN 1 sprite attribute table address
  60  4000
  61  4000              ; BASIC error codes
  62  4000              ;01 NEXT without FOR
  63  4000              ;02 Syntax error
  64  4000              ;03 RETURN without GOSUB
  65  4000              ;04 Out of DATA
  66  4000              ;05 Illegal function call
  67  4000              ;06 Overflow
  68  4000              ;07 Out of memory
  69  4000              ;08 Undefined line number
  70  4000              ;09 Subscript out of range
  71  4000              ;10 Redimensioned array
  72  4000              ;11 Division by zero
  73  4000              ;12 Illegal direct
  74  4000              ;13 Type mismatch
  75  4000              ;14 Out of string space
  76  4000              ;15 String too long
  77  4000              ;16 String formula too complex
  78  4000              ;17 Can't CONTINUE
  79  4000              ;18 Undefined user function
  80  4000              ;19 Device I/O error
  81  4000              ;20 Verify error
  82  4000              ;21 No RESUME
  83  4000              ;22 RESUME without error
  84  4000              ;23 Unprintable error
  85  4000              ;24 Missing operand
  86  4000              ;25 Line buffer overflow
  87  4000              ;50 FIELD overflow
  88  4000              ;51 Internal error
  89  4000              ;52 Bad file number
  90  4000              ;53 File not found
  91  4000              ;54 File already open
  92  4000              ;55 Input past end
  93  4000              ;56 Bad file name
  94  4000              ;57 Direct statement in file
  95  4000              ;58 Sequential I/O only
  96  4000              ;59 File not OPEN
  97  4000
  98  4000
  99  4000               ; simulate cartridge with BASIC extension
 100  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
 100  4004 DC 5E 00 00
 100  4008 00 00 00 00
 100  400C 00 00 00 00
 101  4010
 102  4010              ; this location #4010 stores last location used by basic extension
 103  4010              ; free memory after that point
 104  4010              FREEMEMPTR:
 105  4010 88 5F         DW EXT_END
 106  4012
 107  4012              ; this location #4012 stores extension version in DAA format
 108  4012              ; first byte is major version and second minor
 109  4012              VERSION:
 110  4012 00 91         DB #00, #91
 111  4014
 112  4014              ; this location #4014 contains a jump to entry point for DEFUSR approach
 113  4014              ; if excluded it contains 3xRET so that sound player can be at aspecific spot
 114  4014               IF (1 == 1)
 115  4014 C3 83 5D        JP DEFUSR_ENTRY
 116  4017               ELSE
 117  4017 ~               .3 RET
 118  4017               ENDIF
 119  4017
 120  4017              ; binary included AKG player compiled at #4017
 121  4017               IF (SOUND_CMDS == 1)
 122  4017              	INCBIN "bin/AKG.bin"
 123  4CF3              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF3              MAIN_PLAYER_START EQU 04017H
   2+ 4CF3              PLY_AKG_START EQU 04017H
   3+ 4CF3              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 04020H
   4+ 4CF3              PLY_AKG_INITSOUNDEFFECTS EQU 04020H
   5+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04024H
   6+ 4CF3              PLY_AKG_PLAYSOUNDEFFECT EQU 04024H
   7+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04025H
   8+ 4CF3              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04025H
   9+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 0404CH
  10+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 0404CH
  11+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 0405AH
  12+ 4CF3              PLY_AKG_PSES_PLAY EQU 04093H
  13+ 4CF3              PLY_AKG_PSES_READFIRSTBYTE EQU 0409CH
  14+ 4CF3              PLY_AKG_PSES_S_ENDORLOOP EQU 040B4H
  15+ 4CF3              PLY_AKG_PSES_S_LOOP EQU 040BFH
  16+ 4CF3              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C5H
  17+ 4CF3              PLY_AKG_PSES_NOTREACHED EQU 040D8H
  18+ 4CF3              PLY_AKG_PSES_HARDWAREONLY EQU 040DCH
  19+ 4CF3              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E3H
  20+ 4CF3              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F5H
  21+ 4CF3              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FFH
  22+ 4CF3              PLY_AKG_PSES_H_AFTERRETRIG EQU 04109H
  23+ 4CF3              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411DH
  24+ 4CF3              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 04122H
  25+ 4CF3              PLY_AKG_PSES_READHARDWAREPERIOD EQU 0412AH
  26+ 4CF3              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04135H
  27+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 04141H
  28+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04143H
  29+ 4CF3              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04149H
  30+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414DH
  31+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414DH
  32+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414FH
  33+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414FH
  34+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414FH
  35+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 04150H
  36+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 04151H
  37+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04155H
  38+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04155H
  39+ 4CF3              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04155H
  40+ 4CF3              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415DH
  41+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04165H
  42+ 4CF3              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04165H
  43+ 4CF3              PLY_AKG_INIT EQU 04165H
  44+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04165H
  45+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04193H
  46+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A7H
  47+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B9H
  48+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D8H
  49+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E5H
  50+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL EQU 041EBH
  51+ 4CF3              PLY_AKG_INITTABLE0 EQU 041EEH
  52+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EEH
  53+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04208H
  54+ 4CF3              PLY_AKG_INITTABLE0_END EQU 04208H
  55+ 4CF3              PLY_AKG_INITTABLE1 EQU 04208H
  56+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04208H
  57+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 0420CH
  58+ 4CF3              PLY_AKG_INITTABLE1_END EQU 0420CH
  59+ 4CF3              PLY_AKG_INITTABLEORA EQU 0420CH
  60+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 0420CH
  61+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04224H
  62+ 4CF3              PLY_AKG_INITTABLEORA_END EQU 04224H
  63+ 4CF3              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04224H
  64+ 4CF3              PLY_AKG_STOP EQU 04224H
  65+ 4CF3              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04236H
  66+ 4CF3              PLY_AKG_PLAY EQU 04236H
  67+ 4CF3              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423EH
  68+ 4CF3              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04244H
  69+ 4CF3              PLY_AKG_READLINKER EQU 04249H
  70+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04249H
  71+ 4CF3              PLY_AKG_READLINKER_PTLINKER EQU 04249H
  72+ 4CF3              PLY_AKG_READLINKER_NOLOOP EQU 04254H
  73+ 4CF3              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428DH
  74+ 4CF3              PLY_AKG_READLINE EQU 04290H
  75+ 4CF3              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 04290H
  76+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04296H
  77+ 4CF3              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04296H
  78+ 4CF3              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A3H
  79+ 4CF3              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A7H
  80+ 4CF3              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042AAH
  81+ 4CF3              PLY_AKG_SPEEDTRACK_END EQU 042ADH
  82+ 4CF3              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042ADH
  83+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B3H
  84+ 4CF3              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B3H
  85+ 4CF3              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042C0H
  86+ 4CF3              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C4H
  87+ 4CF3              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C7H
  88+ 4CF3              PLY_AKG_EVENTTRACK_END EQU 042CAH
  89+ 4CF3              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042CAH
  90+ 4CF3              PLY_AKG_CHANNEL1_READTRACK EQU 042D6H
  91+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D6H
  92+ 4CF3              PLY_AKG_CHANNEL1_PTTRACK EQU 042D6H
  93+ 4CF3              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042F1H
  94+ 4CF3              PLY_AKG_CHANNEL1_WAIT EQU 042FCH
  95+ 4CF3              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04303H
  96+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04303H
  97+ 4CF3              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04303H
  98+ 4CF3              PLY_AKG_CHANNEL1_NOTE EQU 0430CH
  99+ 4CF3              PLY_AKG_BASENOTEINDEX EQU 0430CH
 100+ 4CF3              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430EH
 101+ 4CF3              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430EH
 102+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431EH
 103+ 4CF3              PLY_AKG_INSTRUMENTSTABLE EQU 0431EH
 104+ 4CF3              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 04330H
 105+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 04340H
 106+ 4CF3              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04368H
 107+ 4CF3              PLY_AKG_CHANNEL1_READCELLEND EQU 0436BH
 108+ 4CF3              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 0436BH
 109+ 4CF3              PLY_AKG_CHANNEL2_READTRACK EQU 04377H
 110+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04377H
 111+ 4CF3              PLY_AKG_CHANNEL2_PTTRACK EQU 04377H
 112+ 4CF3              PLY_AKG_CHANNEL2_SMALLWAIT EQU 04392H
 113+ 4CF3              PLY_AKG_CHANNEL2_WAIT EQU 0439DH
 114+ 4CF3              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A4H
 115+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A4H
 116+ 4CF3              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A4H
 117+ 4CF3              PLY_AKG_CHANNEL2_NOTE EQU 043ADH
 118+ 4CF3              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043B2H
 119+ 4CF3              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043B2H
 120+ 4CF3              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D4H
 121+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E4H
 122+ 4CF3              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 0440CH
 123+ 4CF3              PLY_AKG_CHANNEL2_READCELLEND EQU 0440FH
 124+ 4CF3              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440FH
 125+ 4CF3              PLY_AKG_CHANNEL3_READTRACK EQU 0441BH
 126+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 0441BH
 127+ 4CF3              PLY_AKG_CHANNEL3_PTTRACK EQU 0441BH
 128+ 4CF3              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04436H
 129+ 4CF3              PLY_AKG_CHANNEL3_WAIT EQU 04441H
 130+ 4CF3              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04448H
 131+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04448H
 132+ 4CF3              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04448H
 133+ 4CF3              PLY_AKG_CHANNEL3_NOTE EQU 04451H
 134+ 4CF3              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04456H
 135+ 4CF3              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04456H
 136+ 4CF3              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04478H
 137+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04488H
 138+ 4CF3              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044B0H
 139+ 4CF3              PLY_AKG_CHANNEL3_READCELLEND EQU 044B3H
 140+ 4CF3              PLY_AKG_CURRENTSPEED EQU 044B3H
 141+ 4CF3              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B5H
 142+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B8H
 143+ 4CF3              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B8H
 144+ 4CF3              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044BBH
 145+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BEH
 146+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BEH
 147+ 4CF3              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044CAH
 148+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044D1H
 149+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D4H
 150+ 4CF3              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044DAH
 151+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DDH
 152+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DDH
 153+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044EBH
 154+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044F0H
 155+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044FBH
 156+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FEH
 157+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FEH
 158+ 4CF3              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 04501H
 159+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04504H
 160+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04504H
 161+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450DH
 162+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04517H
 163+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 0451AH
 164+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 0451AH
 165+ 4CF3              PLY_AKG_CHANNEL1_PITCH EQU 0451AH
 166+ 4CF3              PLY_AKG_CHANNEL1_ISPITCH EQU 0451DH
 167+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 04522H
 168+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACK EQU 04522H
 169+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04526H
 170+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04528H
 171+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 0452AH
 172+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 04531H
 173+ 4CF3              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 04532H
 174+ 4CF3              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04535H
 175+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04535H
 176+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 04551H
 177+ 4CF3              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 04551H
 178+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455EH
 179+ 4CF3              PLY_AKG_CHANNEL1_GLIDEOVER EQU 04562H
 180+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 04572H
 181+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 04572H
 182+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04573H
 183+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04574H
 184+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04576H
 185+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04576H
 186+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04576H
 187+ 4CF3              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04577H
 188+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04578H
 189+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 0457AH
 190+ 4CF3              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 0457AH
 191+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 0457AH
 192+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 0457AH
 193+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 0457AH
 194+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457DH
 195+ 4CF3              PLY_AKG_CHANNEL1_PITCH_END EQU 0457FH
 196+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04587H
 197+ 4CF3              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04587H
 198+ 4CF3              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 0458AH
 199+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458DH
 200+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458DH
 201+ 4CF3              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04599H
 202+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 045A0H
 203+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A3H
 204+ 4CF3              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A9H
 205+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045ACH
 206+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045ACH
 207+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045BAH
 208+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BFH
 209+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045CAH
 210+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CDH
 211+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CDH
 212+ 4CF3              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045D0H
 213+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D3H
 214+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D3H
 215+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045DCH
 216+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E6H
 217+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E9H
 218+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E9H
 219+ 4CF3              PLY_AKG_CHANNEL2_PITCH EQU 045E9H
 220+ 4CF3              PLY_AKG_CHANNEL2_ISPITCH EQU 045ECH
 221+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045F1H
 222+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045F1H
 223+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F5H
 224+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F7H
 225+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F9H
 226+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 04600H
 227+ 4CF3              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 04601H
 228+ 4CF3              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04604H
 229+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04604H
 230+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 04620H
 231+ 4CF3              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 04620H
 232+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462DH
 233+ 4CF3              PLY_AKG_CHANNEL2_GLIDEOVER EQU 04631H
 234+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 04641H
 235+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 04641H
 236+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 04642H
 237+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04643H
 238+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04645H
 239+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04645H
 240+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04645H
 241+ 4CF3              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04646H
 242+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04647H
 243+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04649H
 244+ 4CF3              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04649H
 245+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04649H
 246+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04649H
 247+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04649H
 248+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_END EQU 0464CH
 249+ 4CF3              PLY_AKG_CHANNEL2_PITCH_END EQU 0464EH
 250+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04656H
 251+ 4CF3              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04656H
 252+ 4CF3              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04659H
 253+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 0465CH
 254+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 0465CH
 255+ 4CF3              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04668H
 256+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466FH
 257+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 04672H
 258+ 4CF3              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04678H
 259+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 0467BH
 260+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 0467BH
 261+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04689H
 262+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468EH
 263+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04699H
 264+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 0469CH
 265+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 0469CH
 266+ 4CF3              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469FH
 267+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 046A2H
 268+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE EQU 046A2H
 269+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046ABH
 270+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B5H
 271+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B8H
 272+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B8H
 273+ 4CF3              PLY_AKG_CHANNEL3_PITCH EQU 046B8H
 274+ 4CF3              PLY_AKG_CHANNEL3_ISPITCH EQU 046BBH
 275+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046C0H
 276+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046C0H
 277+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C4H
 278+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C6H
 279+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C8H
 280+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CFH
 281+ 4CF3              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046D0H
 282+ 4CF3              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D3H
 283+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D3H
 284+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046EFH
 285+ 4CF3              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046EFH
 286+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046FCH
 287+ 4CF3              PLY_AKG_CHANNEL3_GLIDEOVER EQU 04700H
 288+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 04710H
 289+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 04710H
 290+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 04711H
 291+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 04712H
 292+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04714H
 293+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04714H
 294+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04714H
 295+ 4CF3              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04715H
 296+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04716H
 297+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04718H
 298+ 4CF3              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04718H
 299+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04718H
 300+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04718H
 301+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04718H
 302+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_END EQU 0471BH
 303+ 4CF3              PLY_AKG_CHANNEL3_PITCH_END EQU 0471DH
 304+ 4CF3              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04729H
 305+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04729H
 306+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04729H
 307+ 4CF3              PLY_AKG_CHANNEL1_TRACKNOTE EQU 0472CH
 308+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472EH
 309+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04734H
 310+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04737H
 311+ 4CF3              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04737H
 312+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 0473AH
 313+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04743H
 314+ 4CF3              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 0474BH
 315+ 4CF3              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04758H
 316+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04758H
 317+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04758H
 318+ 4CF3              PLY_AKG_CHANNEL2_TRACKNOTE EQU 0475BH
 319+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475DH
 320+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04763H
 321+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04766H
 322+ 4CF3              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04766H
 323+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04769H
 324+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 04772H
 325+ 4CF3              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 0477AH
 326+ 4CF3              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04788H
 327+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04788H
 328+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04788H
 329+ 4CF3              PLY_AKG_CHANNEL3_TRACKNOTE EQU 0478BH
 330+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478DH
 331+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04793H
 332+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04796H
 333+ 4CF3              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04796H
 334+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04799H
 335+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 047A2H
 336+ 4CF3              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047AAH
 337+ 4CF3              PLY_AKG_SENDPSGREGISTERS EQU 047B9H
 338+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047C1H
 339+ 4CF3              PLY_AKG_PSGREG01_INSTR EQU 047C1H
 340+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047D1H
 341+ 4CF3              PLY_AKG_PSGREG23_INSTR EQU 047D1H
 342+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047E2H
 343+ 4CF3              PLY_AKG_PSGREG45_INSTR EQU 047E2H
 344+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F3H
 345+ 4CF3              PLY_AKG_PSGREG6_8_INSTR EQU 047F3H
 346+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04804H
 347+ 4CF3              PLY_AKG_PSGREG9_10_INSTR EQU 04804H
 348+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04815H
 349+ 4CF3              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04815H
 350+ 4CF3              PLY_AKG_PSGREG13_OLDVALUE EQU 0482AH
 351+ 4CF3              PLY_AKG_RETRIG EQU 0482CH
 352+ 4CF3              PLY_AKG_PSGREG13_INSTR EQU 0482EH
 353+ 4CF3              PLY_AKG_PSGREG13_END EQU 0483DH
 354+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483DH
 355+ 4CF3              PLY_AKG_SAVESP EQU 0483DH
 356+ 4CF3              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 04841H
 357+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTS EQU 04849H
 358+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04856H
 359+ 4CF3              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04856H
 360+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485EH
 361+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 0486BH
 362+ 4CF3              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 0486BH
 363+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTS EQU 04873H
 364+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487EH
 365+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS EQU 0487EH
 366+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488DH
 367+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488DH
 368+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04894H
 369+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A4H
 370+ 4CF3              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A4H
 371+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048ABH
 372+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048ABH
 373+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048AEH
 374+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B7H
 375+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B7H
 376+ 4CF3              PLY_AKG_READINSTRUMENTCELL EQU 048BDH
 377+ 4CF3              PLY_AKG_NOSOFTNOHARD EQU 048CAH
 378+ 4CF3              PLY_AKG_NSNH_NONOISE EQU 048DFH
 379+ 4CF3              PLY_AKG_SOFT EQU 048E2H
 380+ 4CF3              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E9H
 381+ 4CF3              PLY_AKG_S_NOTSIMPLE EQU 048F1H
 382+ 4CF3              PLY_AKG_S_AFTERSIMPLETEST EQU 048F4H
 383+ 4CF3              PLY_AKG_HARDTOSOFT EQU 04901H
 384+ 4CF3              PLY_AKG_HS_JUMPRATIO EQU 0490CH
 385+ 4CF3              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04939H
 386+ 4CF3              PLY_AKG_ENDWITHOUTLOOP EQU 0493BH
 387+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 0493BH
 388+ 4CF3              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 0493BH
 389+ 4CF3              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04943H
 390+ 4CF3              PLY_AKG_SH_JUMPRATIO EQU 04950H
 391+ 4CF3              PLY_AKG_SH_JUMPRATIOEND EQU 04971H
 392+ 4CF3              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 04980H
 393+ 4CF3              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04986H
 394+ 4CF3              PLY_AKG_H_OR_ENDWITHLOOP EQU 049A0H
 395+ 4CF3              PLY_AKG_H_RETRIGEND EQU 049B2H
 396+ 4CF3              PLY_AKG_H_AFTERRETRIG EQU 049B3H
 397+ 4CF3              PLY_AKG_ENDWITHLOOP EQU 049C5H
 398+ 4CF3              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049CCH
 399+ 4CF3              PLY_AKG_S_OR_H_NEXTBYTE EQU 049E2H
 400+ 4CF3              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049F0H
 401+ 4CF3              PLY_AKG_S_OR_H_AFTERPITCH EQU 04A00H
 402+ 4CF3              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0EH
 403+ 4CF3              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1DH
 404+ 4CF3              PLY_AKG_SHOHS_RETRIGEND EQU 04A2CH
 405+ 4CF3              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2DH
 406+ 4CF3              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3FH
 407+ 4CF3              PLY_AKG_EFFECTTABLE EQU 04A4DH
 408+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4DH
 409+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A71H
 410+ 4CF3              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A71H
 411+ 4CF3              PLY_AKG_EFFECT_RESET EQU 04A74H
 412+ 4CF3              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A76H
 413+ 4CF3              PLY_AKG_EFFECT_VOLUME EQU 04A91H
 414+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9DH
 415+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA3H
 416+ 4CF3              PLY_AKG_ARPEGGIOSTABLE EQU 04AA3H
 417+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04ACAH
 418+ 4CF3              PLY_AKG_EFFECT_PITCHTABLE EQU 04AD1H
 419+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD7H
 420+ 4CF3              PLY_AKG_PITCHESTABLE EQU 04AD7H
 421+ 4CF3              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFEH
 422+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B05H
 423+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B16H
 424+ 4CF3              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1DH
 425+ 4CF3              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2DH
 426+ 4CF3              PLY_AKG_EFFECT_PITCHUP EQU 04B42H
 427+ 4CF3              PLY_AKG_EFFECT_PITCHSTOP EQU 04B54H
 428+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B5BH
 429+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B85H
 430+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B85H
 431+ 4CF3              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9EH
 432+ 4CF3              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9EH
 433+ 4CF3              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BB0H
 434+ 4CF3              PLY_AKG_EFFECT_LEGATO EQU 04BC6H
 435+ 4CF3              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BDAH
 436+ 4CF3              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BE2H
 437+ 4CF3              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BEAH
 438+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BF2H
 439+ 4CF3              PLY_AKG_EVENT EQU 04BF2H
 440+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF3H
 441+ 4CF3              PLY_AKG_PERIODTABLE EQU 04BF3H
 442+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF3H
 443+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF3H
 444+ 4CF3              PLY_AKG_PERIODTABLE_END EQU 04CF3H
 445+ 4CF3              PLY_AKG_END EQU 04CF3H
 446+ 4CF3              MAIN_PLAYER_END EQU 04CF3H
 447+ 4CF3              TESTEREND EQU 04CF3H
 448+ 4CF3
# file closed: ./symbol/AKG.sym
 124  4CF3               ENDIF
 125  4CF3
 126  4CF3               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
   1+ 4CF3              ORIG.HTIMI:
   2+ 4CF3 00 00 00 00  	DB 0, 0, 0, 0, 0
   2+ 4CF7 00
   3+ 4CF8               EXPORT ORIG.HTIMI
   4+ 4CF8
   5+ 4CF8              ; *******************************************************************************************************
   6+ 4CF8              ; interrupt handler when page 0 enabled
   7+ 4CF8              ; we are here only if one of the extended basic commands have paged in page 0
   8+ 4CF8              ; which means we arrived from BASIC so page 2 is already good
   9+ 4CF8              VBLANK:
  10+ 4CF8              	EXPORT VBLANK
  11+ 4CF8
  12+ 4CF8 F5               PUSH AF
  13+ 4CF9              	; is VDP originator ?
  14+ 4CF9 DB 99        	IN	A, (099H)
  15+ 4CFB A7           	AND	A
  16+ 4CFC F2 23 4D     	JP P, .EXIT
  17+ 4CFF
  18+ 4CFF               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  19+ 4CFF C5               PUSH BC
  20+ 4D00 D5               PUSH DE
  21+ 4D01 E5               PUSH HL
  22+ 4D02 08               EX AF, AF'
  23+ 4D03 D9               EXX
  24+ 4D04 F5               PUSH AF
  25+ 4D05 C5               PUSH BC
  26+ 4D06 D5               PUSH DE
  27+ 4D07 E5               PUSH HL
  28+ 4D08 DD E5            PUSH IX
  29+ 4D0A FD E5            PUSH IY
  30+ 4D0C
  31+ 4D0C               IF (SPRITE_CMDS == 1)
  32+ 4D0C CD 5D 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  33+ 4D0F               ENDIF
  34+ 4D0F
  35+ 4D0F               IF (SOUND_CMDS == 1)
  36+ 4D0F 3A 73 55     	LD A, (SOUND_ENABLED)
  37+ 4D12 B7           	OR A
  38+ 4D13 C4 36 42     	CALL NZ,PLY_AKG_PLAY
  39+ 4D16               ENDIF
  40+ 4D16
  41+ 4D16                  ; increase JIFFY
  42+ 4D16                  ;LD HL,(JIFFY)
  43+ 4D16                  ;INC HL
  44+ 4D16                  ;LD (JIFFY),HL
  45+ 4D16
  46+ 4D16 FD E1            POP IY
  47+ 4D18 DD E1            POP IX
  48+ 4D1A E1               POP HL
  49+ 4D1B D1               POP DE
  50+ 4D1C C1               POP BC
  51+ 4D1D F1               POP AF
  52+ 4D1E 08               EX AF, AF'
  53+ 4D1F D9               EXX
  54+ 4D20 E1               POP HL
  55+ 4D21 D1               POP DE
  56+ 4D22 C1               POP BC
  57+ 4D23               ENDIF
  58+ 4D23
  59+ 4D23              .EXIT:
  60+ 4D23 F1           	POP AF
  61+ 4D24 FB           	EI
  62+ 4D25 ED 4D        	RETI
  63+ 4D27              ; *******************************************************************************************************
  64+ 4D27
  65+ 4D27              ; *******************************************************************************************************
  66+ 4D27              ; H.TIMI function
  67+ 4D27              ; we can end up here from anywhere so page in both page 0 and 2
  68+ 4D27              MBGE_HTIMI:
  69+ 4D27               EXPORT MBGE_HTIMI
  70+ 4D27
  71+ 4D27               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  72+ 4D27
  73+ 4D27 F5           	PUSH AF
  74+ 4D28
  75+ 4D28              	; enable page 2
  76+ 4D28 3E 02            LD A, 2
  77+ 4D2A CD 0B 5E         CALL GET_PAGE_INFO
  78+ 4D2D C5               PUSH BC
  79+ 4D2E D5               PUSH DE
  80+ 4D2F 3A 43 F3         LD A, (RAMAD2)
  81+ 4D32 26 80            LD H, 080H
  82+ 4D34 CD 52 5E         CALL LOCAL_ENASLT
  83+ 4D37              	; enable page 0
  84+ 4D37 AF               XOR A
  85+ 4D38 CD 0B 5E         CALL GET_PAGE_INFO
  86+ 4D3B C5               PUSH BC
  87+ 4D3C D5               PUSH DE
  88+ 4D3D 3A 41 F3         LD A, (RAMAD0)
  89+ 4D40 26 00            LD H, 0
  90+ 4D42 CD 52 5E         CALL LOCAL_ENASLT
  91+ 4D45
  92+ 4D45               IF (SPRITE_CMDS == 1)
  93+ 4D45 CD 5D 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  94+ 4D48               ENDIF
  95+ 4D48
  96+ 4D48               IF (SOUND_CMDS == 1)
  97+ 4D48 3A 73 55     	LD A, (SOUND_ENABLED)
  98+ 4D4B B7           	OR A
  99+ 4D4C C4 36 42     	CALL NZ,PLY_AKG_PLAY
 100+ 4D4F               ENDIF
 101+ 4D4F
 102+ 4D4F              	; restore page 0
 103+ 4D4F D1               POP DE
 104+ 4D50 C1               POP BC
 105+ 4D51 CD 42 5E         CALL RESTORE_PAGE_INFO
 106+ 4D54              	; restore page 2
 107+ 4D54 D1               POP DE
 108+ 4D55 C1               POP BC
 109+ 4D56 CD 42 5E         CALL RESTORE_PAGE_INFO
 110+ 4D59
 111+ 4D59 F1           	POP AF
 112+ 4D5A               ENDIF
 113+ 4D5A C3 F3 4C     	JP ORIG.HTIMI
 114+ 4D5D              ; *******************************************************************************************************
 115+ 4D5D
 116+ 4D5D              ; *******************************************************************************************************
 117+ 4D5D              ; function checks if the sprite system is initialized and what screen mode we are running
 118+ 4D5D              ; also checks if some VRAM modifying command is running
 119+ 4D5D              ; when that checks out calls sprite updates and animation processing
 120+ 4D5D              ; if in an unsupported mode disables sprite handling
 121+ 4D5D              PROCESS_SPRITES_AND_ANIMATIONS:
 122+ 4D5D              	; check if initialized
 123+ 4D5D 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
 124+ 4D60 B7           	OR A
 125+ 4D61 C8           	RET Z
 126+ 4D62              	; check screen mode
 127+ 4D62 3A AF FC     	LD A, (SCRMOD)
 128+ 4D65 3D           	DEC A
 129+ 4D66 28 08        	JR Z, .L0 ; screen 1
 130+ 4D68 3D           	DEC A
 131+ 4D69 28 05            JR Z, .L0 ; screen 2
 132+ 4D6B              	; unsupported screen mode, disable
 133+ 4D6B AF               XOR A
 134+ 4D6C 32 7F 4D         LD (SPRATR_INIT_STATUS),A
 135+ 4D6F C9               RET
 136+ 4D70              .L0:
 137+ 4D70                  ; check if anyone else is working with VRAM
 138+ 4D70 3A B2 5D         LD A,(VRAM_UPDATE_IN_PROGRESS)
 139+ 4D73 B7               OR A
 140+ 4D74 C0               RET NZ
 141+ 4D75
 142+ 4D75 CD 95 4D         CALL SPRATR_UPDATE
 143+ 4D78
 144+ 4D78               IF (ANIM_CMDS == 1)
 145+ 4D78 CD D2 52         CALL PROCESS_ANIMATIONS
 146+ 4D7B CD 31 54         CALL PROCESS_AUTOSGAMS
 147+ 4D7E               ENDIF
 148+ 4D7E C9               RET
 149+ 4D7F              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
 127  4D7F
 128  4D7F               IF (SPRITE_CMDS == 1)
 129  4D7F               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4D7F              ; commands and variables related to sprites
   2+ 4D7F
   3+ 4D7F              SPRATR_INIT_STATUS:
   4+ 4D7F 00            DB 0
   5+ 4D80              SPRATR_UPDATE_FLAG:
   6+ 4D80 00 00         DW 0
   7+ 4D82              SPRATR_DATA:
   8+ 4D82 00 00         DW 0
   9+ 4D84              SPRFLICKER_ENABLED:
  10+ 4D84 00            DB 0
  11+ 4D85              ; to support sprite flicker
  12+ 4D85              FLICKER:
  13+ 4D85 00            DB 0
  14+ 4D86              NUM_SPRITES_HANDLED:
  15+ 4D86 20            DB 32
  16+ 4D87
  17+ 4D87              ; to temporarily store stack pointer
  18+ 4D87              TMPSP:
  19+ 4D87 00 00         DW 0
  20+ 4D89
  21+ 4D89              ; *******************************************************************************************************
  22+ 4D89              ; helper function gets pointer to n-th entry in sprite attributes
  23+ 4D89              ; changes HL,DE
  24+ 4D89              GETnthSPRATTR:
  25+ 4D89 26 00            LD H,0
  26+ 4D8B 6F               LD L,A
  27+ 4D8C CD 07 5E         CALL HLx8
  28+ 4D8F ED 5B 82 4D      LD DE,(SPRATR_DATA)
  29+ 4D93 19               ADD HL,DE
  30+ 4D94 C9               RET
  31+ 4D95              ; *******************************************************************************************************
  32+ 4D95
  33+ 4D95              ; *******************************************************************************************************
  34+ 4D95              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  35+ 4D95              ; struct {
  36+ 4D95              ; DW y
  37+ 4D95              ; DW x
  38+ 4D95              ; DW pattern (0-63)
  39+ 4D95              ; DW color
  40+ 4D95              ; } [32]
  41+ 4D95              ; will hide sprites whose location is outside of visible area
  42+ 4D95              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  43+ 4D95              ; modifies AF, AF', BC, DE, HL, IX
  44+ 4D95              SPRATR_UPDATE:
  45+ 4D95              	; check if update requested
  46+ 4D95 2A 80 4D     	LD HL, (SPRATR_UPDATE_FLAG)
  47+ 4D98 7E           	LD A, (HL)
  48+ 4D99 B7           	OR A
  49+ 4D9A C8           	RET Z
  50+ 4D9B
  51+ 4D9B DD 21 86 4D  	LD IX,NUM_SPRITES_HANDLED
  52+ 4D9F DD 46 00     	LD B, (IX) ; sprite number
  53+ 4DA2 0E 98        	LD C, #98 ; register for vdp data output
  54+ 4DA4              	; set VDP address
  55+ 4DA4 3A AF FC         LD A,(SCRMOD)
  56+ 4DA7 3D               DEC A
  57+ 4DA8 20 05            JR NZ,.L4
  58+ 4DAA 2A C3 F3         LD HL, (T32ATR)
  59+ 4DAD 18 03            JR .L5
  60+ 4DAF              .L4:
  61+ 4DAF 2A CD F3         LD HL, (GRPATR)
  62+ 4DB2              .L5:
  63+ 4DB2 3A 84 4D     	LD A, (SPRFLICKER_ENABLED)
  64+ 4DB5 B7           	OR A
  65+ 4DB6 28 03        	JR Z, .L3
  66+ 4DB8 3A 85 4D     	LD A, (FLICKER)
  67+ 4DBB              .L3:
  68+ 4DBB 5F           	LD E, A
  69+ 4DBC 08           	EX AF, AF'
  70+ 4DBD 7B           	LD A, E
  71+ 4DBE 87           	ADD A, A
  72+ 4DBF 87           	ADD A, A
  73+ 4DC0 16 00        	LD D, 0
  74+ 4DC2 5F           	LD E, A
  75+ 4DC3 19           	ADD HL, DE
  76+ 4DC4 CD F2 5D     	CALL SETWRT_LOCAL
  77+ 4DC7 ED 73 87 4D  	LD (TMPSP), SP
  78+ 4DCB ED 7B 82 4D  	LD SP, (SPRATR_DATA)
  79+ 4DCF
  80+ 4DCF              .LOOP:
  81+ 4DCF E1           	POP HL
  82+ 4DD0 24           	INC H
  83+ 4DD1 28 0D        	JR Z, .L1 ; negative number between -256 and -1
  84+ 4DD3 25           	DEC H
  85+ 4DD4 20 15        	JR NZ, .OUT3 ; sprite vertically can't be visible
  86+ 4DD6 7D           	LD A, L
  87+ 4DD7 FE C0        	CP 192
  88+ 4DD9 30 10        	JR NC, .OUT3
  89+ 4DDB 3D           	DEC A ; due to VDP rule that top of screen is -1
  90+ 4DDC 57           	LD D, A
  91+ 4DDD C3 04 4E     	JP .X
  92+ 4DE0              .L1:
  93+ 4DE0 7D           	LD A, L
  94+ 4DE1 C6 10        	ADD 16
  95+ 4DE3 FA EB 4D     	JP M, .OUT3 ; below -16
  96+ 4DE6 2D           	DEC L ; due to VDP rule that top of screen is -1
  97+ 4DE7 55           	LD D, L
  98+ 4DE8 C3 04 4E     	JP .X
  99+ 4DEB              .OUT3:
 100+ 4DEB E1           	POP HL ; skip x value
 101+ 4DEC              .OUT2:
 102+ 4DEC E1           	POP HL ; skip pattern
 103+ 4DED E1           	POP HL ; skip color
 104+ 4DEE 3E D1        	LD A, #D1
 105+ 4DF0 ED 79        	OUT (C), A ; sprite hidden
 106+ 4DF2 00          > NOP
 106+ 4DF3 00          > NOP
 106+ 4DF4 00          > NOP
 107+ 4DF5 ED 79        	OUT (C), A ; value unimportant
 108+ 4DF7 00          > NOP
 108+ 4DF8 00          > NOP
 108+ 4DF9 00          > NOP
 109+ 4DFA ED 79        	OUT (C), A ; value unimportant
 110+ 4DFC 00          > NOP
 110+ 4DFD 00          > NOP
 110+ 4DFE 00          > NOP
 111+ 4DFF ED 79        	OUT (C), A ; value unimportant
 112+ 4E01 C3 2F 4E     	JP .NEXT
 113+ 4E04              .X:
 114+ 4E04 E1           	POP HL
 115+ 4E05 24           	INC H
 116+ 4E06 28 08        	JR Z, .L2
 117+ 4E08 25           	DEC H
 118+ 4E09 20 E1        	JR NZ, .OUT2
 119+ 4E0B 1E 00        	LD E, 0 ; EC bit
 120+ 4E0D C3 19 4E     	JP .XY
 121+ 4E10              .L2:
 122+ 4E10 7D           	LD A, L
 123+ 4E11 C6 20        	ADD 32
 124+ 4E13 FA EC 4D     	JP M, .OUT2
 125+ 4E16 6F           	LD L, A
 126+ 4E17 1E 80        	LD E, #80
 127+ 4E19              .XY:
 128+ 4E19 ED 51        	OUT (C), D
 129+ 4E1B 3A E0 F3     	LD A, (REG1SAV)
 130+ 4E1E E6 02        	AND 2
 131+ 4E20 ED 69        	OUT (C), L
 132+ 4E22 E1           	POP HL ; pattern
 133+ 4E23 7D           	LD A, L
 134+ 4E24 28 02        	JR Z, .SMALLSPRITES
 135+ 4E26 87           	ADD A, A
 136+ 4E27 87           	ADD A, A ; needs to go at 4x
 137+ 4E28              .SMALLSPRITES:
 138+ 4E28 D3 98        	OUT (#98), A
 139+ 4E2A E1           	POP HL ; color
 140+ 4E2B 7D           	LD A, L
 141+ 4E2C B3           	OR E
 142+ 4E2D D3 98        	OUT (#98), A
 143+ 4E2F              .NEXT:
 144+ 4E2F 08           	EX AF, AF'
 145+ 4E30 3C           	INC A ; increase current sprite
 146+ 4E31 DD BE 00     	CP (IX) ; compare to maximum handled
 147+ 4E34 C2 54 4E     	JP NZ, .NEXT2 ; continue if not over
 148+ 4E37 AF           	XOR A ; back to zero
 149+ 4E38 08           	EX AF, AF'
 150+ 4E39 3A AF FC         LD A,(SCRMOD)
 151+ 4E3C 3D               DEC A
 152+ 4E3D 20 05            JR NZ,.L6
 153+ 4E3F 2A C3 F3         LD HL, (T32ATR)
 154+ 4E42 18 03            JR .L7
 155+ 4E44              .L6:
 156+ 4E44 2A CD F3         LD HL, (GRPATR)
 157+ 4E47              .L7:
 158+ 4E47              	; CALL SETWRT_LOCAL not allowed as SP modified
 159+ 4E47 7D           	LD	A, L
 160+ 4E48 D3 99        	OUT	(099H), A
 161+ 4E4A 7C           	LD	A, H
 162+ 4E4B E6 3F        	AND	03FH
 163+ 4E4D F6 40        	OR	040H
 164+ 4E4F D3 99        	OUT	(099H), A
 165+ 4E51 C3 55 4E     	JP .NEXT3
 166+ 4E54              .NEXT2:
 167+ 4E54 08           	EX AF, AF'
 168+ 4E55              .NEXT3:
 169+ 4E55 05           	DEC B
 170+ 4E56 C2 CF 4D     	JP NZ, .LOOP
 171+ 4E59 08           	EX AF, AF'
 172+ 4E5A 3C           	INC A ; increase flicker to start at the next one on next vblank
 173+ 4E5B DD BE 00     	CP (IX)
 174+ 4E5E 20 01        	JR NZ,.L8
 175+ 4E60 AF           	XOR A
 176+ 4E61              .L8:
 177+ 4E61 32 85 4D     	LD (FLICKER), A
 178+ 4E64
 179+ 4E64 ED 7B 87 4D  	LD SP, (TMPSP)
 180+ 4E68 2A 80 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 181+ 4E6B 36 00        	LD (HL), 0 ; zero out update flag
 182+ 4E6D C9           	RET
 183+ 4E6E              ; *******************************************************************************************************
 184+ 4E6E
 185+ 4E6E               IF (0 == 1)
 186+ 4E6E ~            ; *******************************************************************************************************
 187+ 4E6E ~            ; function to handle CALL SPRENABLE basic extension
 188+ 4E6E ~            ; initializes sprites handler
 189+ 4E6E ~            ; _SPRENABLE ( INT[3][31] variable sprites_attributes,
 190+ 4E6E ~            ;			   INT variable update_variable,
 191+ 4E6E ~            ;			   BYTE sprite_flicker_enabled,
 192+ 4E6E ~            ;			   BYTE num_sprites_handled )
 193+ 4E6E ~            ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA, SPRFLICKER_ENABLED and NUM_SPRITES_HANDLED
 194+ 4E6E ~            SPRENABLE:
 195+ 4E6E ~            	; opening (
 196+ 4E6E ~            	CALL CHKCHAR
 197+ 4E6E ~            	DB '('
 198+ 4E6E ~            	; get address of sprite attribute table DIM SA%(3,31)
 199+ 4E6E ~            	LD A,2
 200+ 4E6E ~            	LD B,2
 201+ 4E6E ~            	LD DE,#0420
 202+ 4E6E ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
 203+ 4E6E ~            	LD (SPRATR_DATA), BC
 204+ 4E6E ~            	; comma
 205+ 4E6E ~            	CALL CHKCHAR
 206+ 4E6E ~            	DB ','
 207+ 4E6E ~            	; get address of sprite update flag
 208+ 4E6E ~            	LD IX, PTRGET
 209+ 4E6E ~            	CALL CALBAS
 210+ 4E6E ~            	LD (SPRATR_UPDATE_FLAG), DE
 211+ 4E6E ~            	; comma
 212+ 4E6E ~            	CALL CHKCHAR
 213+ 4E6E ~            	DB ','
 214+ 4E6E ~            	; get flicker enabled flag
 215+ 4E6E ~            	LD IX, GETBYT
 216+ 4E6E ~            	CALL CALBAS
 217+ 4E6E ~            	LD (SPRFLICKER_ENABLED), A
 218+ 4E6E ~            	; comma
 219+ 4E6E ~            	CALL CHKCHAR
 220+ 4E6E ~            	DB ','
 221+ 4E6E ~            	; get number of handled sprites
 222+ 4E6E ~            	LD IX, GETBYT
 223+ 4E6E ~            	CALL CALBAS
 224+ 4E6E ~            	LD (NUM_SPRITES_HANDLED),A
 225+ 4E6E ~            	; ending )
 226+ 4E6E ~            	CALL CHKCHAR
 227+ 4E6E ~            	DB ')'
 228+ 4E6E ~            .L0:
 229+ 4E6E ~            	LD A, 1
 230+ 4E6E ~            	LD (SPRATR_INIT_STATUS), A
 231+ 4E6E ~            	RET
 232+ 4E6E ~            ; *******************************************************************************************************
 233+ 4E6E               ENDIF
 234+ 4E6E
 235+ 4E6E               IF (1 == 1)
 236+ 4E6E              ; same as SPRENABLE but for DEFUSR approach
 237+ 4E6E              ; input IX=pointer to input array, real data from +2
 238+ 4E6E              ; +2 = pointer to sprite attributes array data
 239+ 4E6E              ; +4 = pointer to sprite update variable
 240+ 4E6E              ; +6 = flicker flag
 241+ 4E6E              ; +8 = number of sprites to handle
 242+ 4E6E              SPRENABLE_DEFUSR:
 243+ 4E6E DD 6E 02     	LD L,(IX+2)
 244+ 4E71 DD 66 03     	LD H,(IX+3)
 245+ 4E74 22 82 4D     	LD (SPRATR_DATA),HL
 246+ 4E77 DD 6E 04     	LD L,(IX+4)
 247+ 4E7A DD 66 05     	LD H,(IX+5)
 248+ 4E7D 22 80 4D     	LD (SPRATR_UPDATE_FLAG),HL
 249+ 4E80 DD 7E 06     	LD A,(IX+6)
 250+ 4E83 32 84 4D     	LD (SPRFLICKER_ENABLED),A
 251+ 4E86 DD 7E 08     	LD A,(IX+8)
 252+ 4E89 32 86 4D     	LD (NUM_SPRITES_HANDLED),A
 253+ 4E8C               IF (0 == 1)
 254+ 4E8C ~            	JR SPRENABLE.L0
 255+ 4E8C               ELSE
 256+ 4E8C 3E 01        	LD A, 1
 257+ 4E8E 32 7F 4D     	LD (SPRATR_INIT_STATUS), A
 258+ 4E91 C9           	RET
 259+ 4E92               ENDIF
 260+ 4E92               ENDIF
 261+ 4E92
 262+ 4E92               IF (1 + 0 > 0)
 263+ 4E92              ; *******************************************************************************************************
 264+ 4E92              ; function to handle CALL SPRDISABLE basic extension
 265+ 4E92              ; disables sprites handling
 266+ 4E92              ; _SPRDISABLE
 267+ 4E92              ; resets variable SPRATR_INIT_STATUS
 268+ 4E92              SPRDISABLE:
 269+ 4E92              SPRDISABLE_DEFUSR:
 270+ 4E92 AF           	XOR A
 271+ 4E93 32 7F 4D     	LD (SPRATR_INIT_STATUS), A
 272+ 4E96 C9           	RET
 273+ 4E97              ; *******************************************************************************************************
 274+ 4E97               ENDIF
 275+ 4E97
 276+ 4E97              ; *******************************************************************************************************
 277+ 4E97              ; function to handle CALL SPRSET basic extension
 278+ 4E97              ; sets position, and optionally pattern and color of sprite
 279+ 4E97              ; _SPRSET ( BYTE sprite_num , valid 0-31
 280+ 4E97              ;			INT x,
 281+ 4E97              ;			INT y,
 282+ 4E97              ;			INT pattern, valid 0-63, otherwise ignored
 283+ 4E97              ;			INT color, valid 0-15, otherwise ignored
 284+ 4E97              ;SPRSET:
 285+ 4E97              ;	LD A, (SPRATR_INIT_STATUS)
 286+ 4E97              ;	OR A
 287+ 4E97              ;	JR NZ, .L1
 288+ 4E97              ;	LD E, 5 ; illegal function call
 289+ 4E97              ;	JP THROW_ERROR
 290+ 4E97              ;.L1:
 291+ 4E97              ;	; opening (
 292+ 4E97              ;	CALL CHKCHAR
 293+ 4E97              ;	DB '('
 294+ 4E97              ;	; get sprite number
 295+ 4E97              ;	LD IX, GETBYT
 296+ 4E97              ;	CALL CALBAS
 297+ 4E97              ;	PUSH AF
 298+ 4E97              ;	; comma
 299+ 4E97              ;	CALL CHKCHAR
 300+ 4E97              ;	DB ','
 301+ 4E97              ;	; get x
 302+ 4E97              ;	LD IX, FRMQNT
 303+ 4E97              ;	CALL CALBAS
 304+ 4E97              ;	PUSH DE
 305+ 4E97              ;	; comma
 306+ 4E97              ;	CALL CHKCHAR
 307+ 4E97              ;	DB ','
 308+ 4E97              ;	; get y
 309+ 4E97              ;	LD IX, FRMQNT
 310+ 4E97              ;	CALL CALBAS
 311+ 4E97              ;	PUSH DE
 312+ 4E97              ;	; comma
 313+ 4E97              ;	CALL CHKCHAR
 314+ 4E97              ;	DB ','
 315+ 4E97              ;	; get pattern
 316+ 4E97              ;	LD IX, FRMQNT
 317+ 4E97              ;	CALL CALBAS
 318+ 4E97              ;	PUSH DE
 319+ 4E97              ;	; comma
 320+ 4E97              ;	CALL CHKCHAR
 321+ 4E97              ;	DB ','
 322+ 4E97              ;	; get color
 323+ 4E97              ;	LD IX, FRMQNT
 324+ 4E97              ;	CALL CALBAS
 325+ 4E97              ;	PUSH DE
 326+ 4E97              ;	; ending )
 327+ 4E97              ;	CALL CHKCHAR
 328+ 4E97              ;	DB ')'
 329+ 4E97              ;
 330+ 4E97              ;   ; save position in BASIC text
 331+ 4E97              ;	PUSH HL
 332+ 4E97              ;	POP IX
 333+ 4E97              ;
 334+ 4E97              ;	POP BC ; color
 335+ 4E97              ;	POP DE ; pattern
 336+ 4E97              ;	EXX
 337+ 4E97              ;	POP BC ; y
 338+ 4E97              ;	POP DE ; x
 339+ 4E97              ;	POP AF ; sprite number
 340+ 4E97              ;	CP 32
 341+ 4E97              ;	JR C, .L2
 342+ 4E97              ;	LD E, 5 ; illegal function call
 343+ 4E97              ;	JP THROW_ERROR
 344+ 4E97              ;.L2:
 345+ 4E97              ;	; find location in sprite attributes table
 346+ 4E97              ;	PUSH DE
 347+ 4E97              ;	CALL GETnthSPRATTR
 348+ 4E97              ;	POP DE
 349+ 4E97              ;	DI
 350+ 4E97              ;	; set y
 351+ 4E97              ;	LD (HL), C
 352+ 4E97              ;	INC HL
 353+ 4E97              ;	LD (HL), B
 354+ 4E97              ;	INC HL
 355+ 4E97              ;	; set x
 356+ 4E97              ;	LD (HL), E
 357+ 4E97              ;	INC HL
 358+ 4E97              ;	LD (HL), D
 359+ 4E97              ;	INC HL
 360+ 4E97              ;	PUSH HL
 361+ 4E97              ;	EXX
 362+ 4E97              ;	POP HL
 363+ 4E97              ;	; check if 0<=pattern<64
 364+ 4E97              ;	LD A, D
 365+ 4E97              ;	OR A
 366+ 4E97              ;	JR NZ, .L3
 367+ 4E97              ;	LD A, E
 368+ 4E97              ;	CP 64
 369+ 4E97              ;	JR NC, .L3
 370+ 4E97              ;	; set pattern
 371+ 4E97              ;	;ADD A, A
 372+ 4E97              ;	;ADD A, A
 373+ 4E97              ;	;ADD A, A
 374+ 4E97              ;	LD (HL), A
 375+ 4E97              ;	INC HL
 376+ 4E97              ;	LD (HL), D
 377+ 4E97              ;	INC HL
 378+ 4E97              ;	JR .L4
 379+ 4E97              ;.L3:
 380+ 4E97              ;	; skip pattern
 381+ 4E97              ;	.2 INC HL
 382+ 4E97              ;.L4:
 383+ 4E97              ;	; check if 0<=color<16
 384+ 4E97              ;	LD A, B
 385+ 4E97              ;	OR A
 386+ 4E97              ;	JR NZ, .L5
 387+ 4E97              ;	LD A, C
 388+ 4E97              ;	CP 16
 389+ 4E97              ;	JR NC, .L5
 390+ 4E97              ;	; set color
 391+ 4E97              ;	LD (HL), C
 392+ 4E97              ;	INC HL
 393+ 4E97              ;	LD (HL), B
 394+ 4E97              ;
 395+ 4E97              ;.L5:
 396+ 4E97              ;	EI
 397+ 4E97              ;	PUSH IX
 398+ 4E97              ;	POP HL
 399+ 4E97              ;	RET
 400+ 4E97              ; *******************************************************************************************************
 401+ 4E97
 402+ 4E97              ; *******************************************************************************************************
 403+ 4E97              ; function sets sprite location based on initial coordinates and offset provided
 404+ 4E97              ; input A=sprite number in SPRATR_DATA , 0-31
 405+ 4E97              ; input DE=initial x
 406+ 4E97              ; input BC=initial y
 407+ 4E97              ; input IY=location where delta y,x are located
 408+ 4E97              ; modifies AF, HL, IX
 409+ 4E97              SPRSET_DELTA_POS:
 410+ 4E97 D5           	PUSH DE
 411+ 4E98 CD 89 4D     	CALL GETnthSPRATTR
 412+ 4E9B E5           	PUSH HL
 413+ 4E9C DD E1        	POP IX
 414+ 4E9E D1           	POP DE
 415+ 4E9F              	; IX=sprite's y location
 416+ 4E9F FD 6E 00     	LD L, (IY)
 417+ 4EA2 FD 66 01     	LD H, (IY+1)
 418+ 4EA5 09           	ADD HL, BC
 419+ 4EA6 DD 75 00     	LD (IX), L
 420+ 4EA9 DD 74 01     	LD (IX+1), H
 421+ 4EAC FD 6E 02     	LD L, (IY+2)
 422+ 4EAF FD 66 03     	LD H, (IY+3)
 423+ 4EB2 19           	ADD HL, DE
 424+ 4EB3 DD 75 02     	LD (IX+2), L
 425+ 4EB6 DD 74 03     	LD (IX+3), H
 426+ 4EB9 C9           	RET
 427+ 4EBA              ; *******************************************************************************************************
 428+ 4EBA
 429+ 4EBA              ; *******************************************************************************************************
 430+ 4EBA              ; helper function to set new locations for a set of sprites
 431+ 4EBA              ; input B=number of sprites
 432+ 4EBA              ; HL=pointer to list of sprites and offsets
 433+ 4EBA              SPR_UPDATE_LOC:
 434+ 4EBA 3E 01        	LD A,1
 435+ 4EBC 32 B2 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 436+ 4EBF 7E           	LD A, (HL)
 437+ 4EC0 23           	INC HL
 438+ 4EC1 23           	INC HL
 439+ 4EC2 E5           	PUSH HL
 440+ 4EC3 FD E1        	POP IY
 441+ 4EC5 D9           	EXX
 442+ 4EC6 CD 97 4E     	CALL SPRSET_DELTA_POS
 443+ 4EC9 D9           	EXX
 444+ 4ECA 23          > INC HL
 444+ 4ECB 23          > INC HL
 444+ 4ECC 23          > INC HL
 444+ 4ECD 23          > INC HL
 445+ 4ECE 10 EA        	DJNZ SPR_UPDATE_LOC
 446+ 4ED0 AF           	XOR A
 447+ 4ED1 32 B2 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 448+ 4ED4 C9           	RET
 449+ 4ED5              ; *******************************************************************************************************
 450+ 4ED5
 451+ 4ED5               IF (0 == 1)
 452+ 4ED5 ~            ; *******************************************************************************************************
 453+ 4ED5 ~            ; function to handle CALL SPRGRPMOV basic extension
 454+ 4ED5 ~            ; sets position of a group of sprites described with
 455+ 4ED5 ~            ; { int sprite_num, int delta_y, int delta_x } [count]
 456+ 4ED5 ~            ; _SPRGRPMOV ( INT x,
 457+ 4ED5 ~            ;			   INT y,
 458+ 4ED5 ~            ;			   BYTE count,
 459+ 4ED5 ~            ;			   INT[2][count] data_ptr
 460+ 4ED5 ~            SPRGRPMOV:
 461+ 4ED5 ~            	LD A, (SPRATR_INIT_STATUS)
 462+ 4ED5 ~            	OR A
 463+ 4ED5 ~            	JP Z,ILLEGAL_FUNCTION
 464+ 4ED5 ~            	; opening (
 465+ 4ED5 ~            	CALL CHKCHAR
 466+ 4ED5 ~            	DB '('
 467+ 4ED5 ~            	; get x
 468+ 4ED5 ~            	LD IX, FRMQNT
 469+ 4ED5 ~            	CALL CALBAS
 470+ 4ED5 ~            	LD (BLIT_STRUCT),DE
 471+ 4ED5 ~            	; comma
 472+ 4ED5 ~            	CALL CHKCHAR
 473+ 4ED5 ~            	DB ','
 474+ 4ED5 ~            	; get y
 475+ 4ED5 ~            	LD IX, FRMQNT
 476+ 4ED5 ~            	CALL CALBAS
 477+ 4ED5 ~            	LD (BLIT_STRUCT+2),DE
 478+ 4ED5 ~            	; comma
 479+ 4ED5 ~            	CALL CHKCHAR
 480+ 4ED5 ~            	DB ','
 481+ 4ED5 ~            	; get count
 482+ 4ED5 ~            	LD IX, GETBYT
 483+ 4ED5 ~            	CALL CALBAS
 484+ 4ED5 ~            	LD (BLIT_STRUCT+4),A
 485+ 4ED5 ~            	; comma
 486+ 4ED5 ~            	CALL CHKCHAR
 487+ 4ED5 ~            	DB ','
 488+ 4ED5 ~            	; get sprite group definition array data pointer
 489+ 4ED5 ~            	LD A,(BLIT_STRUCT+4)
 490+ 4ED5 ~            	LD E,A
 491+ 4ED5 ~            	LD D,3
 492+ 4ED5 ~            	LD A,2
 493+ 4ED5 ~            	LD B,A
 494+ 4ED5 ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
 495+ 4ED5 ~            	LD (BLIT_STRUCT+5),BC
 496+ 4ED5 ~            	; ending )
 497+ 4ED5 ~            	CALL CHKCHAR
 498+ 4ED5 ~            	DB ')'
 499+ 4ED5 ~
 500+ 4ED5 ~            	PUSH HL
 501+ 4ED5 ~
 502+ 4ED5 ~                EXX
 503+ 4ED5 ~                LD DE,(BLIT_STRUCT) ; initial x
 504+ 4ED5 ~                LD BC,(BLIT_STRUCT+2) ; initial y
 505+ 4ED5 ~                EXX
 506+ 4ED5 ~                LD HL,(BLIT_STRUCT+5) ; pointer to data
 507+ 4ED5 ~                LD A,(BLIT_STRUCT+4) ; number of entries
 508+ 4ED5 ~                LD B,A
 509+ 4ED5 ~            	CALL SPR_UPDATE_LOC
 510+ 4ED5 ~
 511+ 4ED5 ~            	POP HL
 512+ 4ED5 ~            	RET
 513+ 4ED5 ~            ; *******************************************************************************************************
 514+ 4ED5               ENDIF
 515+ 4ED5
 516+ 4ED5               IF (1 == 1)
 517+ 4ED5              ; *******************************************************************************************************
 518+ 4ED5              ; same as SPRGRPMOV but for DEFUSR approach
 519+ 4ED5              ; input IX=pointer to input array, real data from +2
 520+ 4ED5              ; +2 = X
 521+ 4ED5              ; +4 = Y
 522+ 4ED5              ; +6 = count
 523+ 4ED5              ; +8 = data pointer
 524+ 4ED5              SPRGRPMOV_DEFUSR:
 525+ 4ED5 D9               EXX
 526+ 4ED6 DD 5E 02     	LD E,(IX+2)
 527+ 4ED9 DD 56 03     	LD D,(IX+3) ; initial x
 528+ 4EDC DD 4E 04     	LD C,(IX+4)
 529+ 4EDF DD 46 05     	LD B,(IX+5) ; initial y
 530+ 4EE2 D9               EXX
 531+ 4EE3 DD 6E 08     	LD L,(IX+8)
 532+ 4EE6 DD 66 09     	LD H,(IX+9) ; pointer to data
 533+ 4EE9 DD 46 06         LD B,(IX+6) ; count
 534+ 4EEC C3 BA 4E         JP SPR_UPDATE_LOC
 535+ 4EEF              ; *******************************************************************************************************
 536+ 4EEF               ENDIF
# file closed: asm\SPRITES.asm
 130  4EEF               ENDIF
 131  4EEF
 132  4EEF               IF (ANIM_CMDS == 1)
 133  4EEF               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4EEF              ; sprite animation routines
   2+ 4EEF
   3+ 4EEF              ; number of animation items and pointer
   4+ 4EEF              ANIMITEMNUM:
   5+ 4EEF 00            DB 0
   6+ 4EF0              ANIMITEMPTR:
   7+ 4EF0 88 5F         DW EXT_END
   8+ 4EF2              ; number of animation definitions and pointer
   9+ 4EF2              ANIMDEFNUM:
  10+ 4EF2 00            DB 0
  11+ 4EF3              ANIMDEFPTR:
  12+ 4EF3 88 5F         DW EXT_END
  13+ 4EF5              ; number of links between sprite and animation definitions
  14+ 4EF5              ANIMSPRNUM:
  15+ 4EF5 00            DB 0
  16+ 4EF6              ANIMSPRPTR:
  17+ 4EF6 88 5F         DW EXT_END
  18+ 4EF8              ; number of automatic sprite group move and animate structures
  19+ 4EF8              AUTOSGAMNUM:
  20+ 4EF8 00            DB 0
  21+ 4EF9              AUTOSGAMPTR:
  22+ 4EF9 88 5F         DW EXT_END
  23+ 4EFB
  24+ 4EFB              ; ANIMATION ITEM
  25+ 4EFB              ; byte type = [0 - pattern and color change
  26+ 4EFB              ;              1 - pattern definition change ]
  27+ 4EFB              ; word ticks - number of ticks to hold this state
  28+ 4EFB              ; for type = 0
  29+ 4EFB              ;   byte pattern;
  30+ 4EFB              ;   byte color;
  31+ 4EFB              ; for type = 1
  32+ 4EFB              ;   work data_pointer;
  33+ 4EFB              ; total size = 5b
  34+ 4EFB
  35+ 4EFB              ; ANIMATION DEFINITION
  36+ 4EFB              ; byte number of items 1-15
  37+ 4EFB              ; byte[15] anim_item;
  38+ 4EFB              ; total size = 16b
  39+ 4EFB
  40+ 4EFB              ; SPRITE/CHAR ANIMATION
  41+ 4EFB              ; +00 byte sprite/char number;
  42+ 4EFB              ; +01 word time;
  43+ 4EFB              ; +03 byte current item;
  44+ 4EFB              ; +04 byte animation definition;
  45+ 4EFB              ; +05 byte cyclic;
  46+ 4EFB              ; +06 byte active;
  47+ 4EFB              ; +07 byte 0=sprite, 1-3 character bank
  48+ 4EFB              ; total size = 8b
  49+ 4EFB
  50+ 4EFB              ; AUTOMATIC SPRITE GROUP MOVE AND ANIMATE structure
  51+ 4EFB              ; +00 pointer to X variable
  52+ 4EFB              ; +02 pointer to Y variable
  53+ 4EFB              ; +04 minimum value
  54+ 4EFB              ; +06 maximal value
  55+ 4EFB              ; +08 delta value
  56+ 4EFB              ; +10 direction 0=horizontal, <>0 = vertical
  57+ 4EFB              ; +11 sprite group size
  58+ 4EFB              ; +12 sprite group pointer
  59+ 4EFB              ; +14 animation list size
  60+ 4EFB              ; +15 animation list pointer for negative delta values
  61+ 4EFB              ; +17 animation list pointer for positive delta values
  62+ 4EFB              ; +19 active flag
  63+ 4EFB              ; +20 ticks for movement
  64+ 4EFB              ; +22 timer
  65+ 4EFB              ; total = 24b
  66+ 4EFB
  67+ 4EFB              ; *******************************************************************************************************
  68+ 4EFB              ; helper function HL=A*5
  69+ 4EFB              ; changes HL,DE
  70+ 4EFB              Ax5:
  71+ 4EFB 26 00            LD H,0
  72+ 4EFD 6F               LD L,A
  73+ 4EFE 54               LD D,H
  74+ 4EFF 5D               LD E,L
  75+ 4F00 29               ADD HL,HL
  76+ 4F01 29               ADD HL,HL
  77+ 4F02 19               ADD HL,DE
  78+ 4F03 C9               RET
  79+ 4F04              ; *******************************************************************************************************
  80+ 4F04
  81+ 4F04              ; *******************************************************************************************************
  82+ 4F04              ; helper function gets pointer to n-th animation item
  83+ 4F04              ; changes HL,DE
  84+ 4F04              GETnthANIMITEM:
  85+ 4F04 CD FB 4E         CALL Ax5
  86+ 4F07 ED 5B F0 4E      LD DE,(ANIMITEMPTR)
  87+ 4F0B 19               ADD HL,DE
  88+ 4F0C C9               RET
  89+ 4F0D              ; *******************************************************************************************************
  90+ 4F0D
  91+ 4F0D              ; *******************************************************************************************************
  92+ 4F0D              ; helper function gets pointer to n-th entry in animation definition
  93+ 4F0D              ; changes HL,DE
  94+ 4F0D              GETnthANIMDEF:
  95+ 4F0D 26 00            LD H,0
  96+ 4F0F 6F               LD L,A
  97+ 4F10 CD 06 5E         CALL HLx16
  98+ 4F13 ED 5B F3 4E      LD DE,(ANIMDEFPTR)
  99+ 4F17 19               ADD HL,DE
 100+ 4F18 C9               RET
 101+ 4F19              ; *******************************************************************************************************
 102+ 4F19
 103+ 4F19              ; *******************************************************************************************************
 104+ 4F19              ; helper function gets pointer to n-th entry in sprite animation
 105+ 4F19              ; changes HL,DE
 106+ 4F19              GETnthSPRANIM:
 107+ 4F19 26 00            LD H,0
 108+ 4F1B 6F               LD L,A
 109+ 4F1C CD 07 5E         CALL HLx8
 110+ 4F1F ED 5B F6 4E      LD DE,(ANIMSPRPTR)
 111+ 4F23 19               ADD HL,DE
 112+ 4F24 C9               RET
 113+ 4F25              ; *******************************************************************************************************
 114+ 4F25
 115+ 4F25              ; *******************************************************************************************************
 116+ 4F25              ; helper function gets pointer to n-th entry in autosgam table
 117+ 4F25              ; changes HL,DE
 118+ 4F25              GETnthAUTOSGAM:
 119+ 4F25 26 00            LD H,0
 120+ 4F27 6F               LD L,A
 121+ 4F28 CD 07 5E         CALL HLx8
 122+ 4F2B 54               LD D,H
 123+ 4F2C 5D               LD E,L
 124+ 4F2D 29               ADD HL,HL
 125+ 4F2E 19               ADD HL,DE
 126+ 4F2F ED 5B F9 4E      LD DE,(AUTOSGAMPTR)
 127+ 4F33 19               ADD HL,DE
 128+ 4F34 C9               RET
 129+ 4F35              ; *******************************************************************************************************
 130+ 4F35
 131+ 4F35               IF (1 == 1)
 132+ 4F35              ; *******************************************************************************************************
 133+ 4F35              ; same as MAXIANIMITEMS but for DEFUSR approach
 134+ 4F35              ; input IX=pointer to input array, real data from +2
 135+ 4F35              ; +2 = number
 136+ 4F35              MAXANIMITEMS_DEFUSR:
 137+ 4F35 DD 7E 02         LD A,(IX+2)
 138+ 4F38 18 00            JR MAXANIMITEMS.COMMON
 139+ 4F3A              ; *******************************************************************************************************
 140+ 4F3A               ENDIF
 141+ 4F3A
 142+ 4F3A              ; *******************************************************************************************************
 143+ 4F3A              ; function to handle CALL MAXANIMITEMS basic extension
 144+ 4F3A              ; MAXANIMITEMS (BYTE number)
 145+ 4F3A              ; sets new number and moves memory buffers as needed
 146+ 4F3A              MAXANIMITEMS:
 147+ 4F3A               IF (0 == 1)
 148+ 4F3A ~            	; opening (
 149+ 4F3A ~            	CALL CHKCHAR
 150+ 4F3A ~            	DB '('
 151+ 4F3A ~            	; get value
 152+ 4F3A ~            	LD IX, GETBYT
 153+ 4F3A ~            	CALL CALBAS
 154+ 4F3A ~                PUSH AF
 155+ 4F3A ~            	; ending )
 156+ 4F3A ~            	CALL CHKCHAR
 157+ 4F3A ~            	DB ')'
 158+ 4F3A ~                POP AF
 159+ 4F3A               ENDIF
 160+ 4F3A              .COMMON: ; entry for DEFUSR part, A=number
 161+ 4F3A F3               DI
 162+ 4F3B              	; save position
 163+ 4F3B E5           	PUSH HL
 164+ 4F3C              .ENTRY:
 165+ 4F3C 47               LD B,A
 166+ 4F3D 3A EF 4E         LD A,(ANIMITEMNUM)
 167+ 4F40 90               SUB B
 168+ 4F41 28 28            JR Z, .EXIT; same value as before
 169+ 4F43 FD 21 F3 4E      LD IY,ANIMDEFPTR
 170+ 4F47 FA 6E 4F         JP M, .INCREASE
 171+ 4F4A                  ; new value is lower than previous one
 172+ 4F4A CD 8D 4F         CALL .SIZEDIFF
 173+ 4F4D CD A8 4F         CALL .DECREASE_COMMON
 174+ 4F50 2A F6 4E         LD HL,(ANIMSPRPTR)
 175+ 4F53 AF               XOR A
 176+ 4F54 ED 42            SBC HL,BC
 177+ 4F56 22 F6 4E         LD (ANIMSPRPTR),HL
 178+ 4F59              .E1:
 179+ 4F59 2A F9 4E         LD HL,(AUTOSGAMPTR)
 180+ 4F5C AF               XOR A
 181+ 4F5D ED 42            SBC HL,BC
 182+ 4F5F 22 F9 4E         LD (AUTOSGAMPTR),HL
 183+ 4F62              .E3:
 184+ 4F62 2A 10 40         LD HL,(FREEMEMPTR)
 185+ 4F65 AF               XOR A
 186+ 4F66 ED 42            SBC HL,BC
 187+ 4F68 22 10 40         LD (FREEMEMPTR),HL
 188+ 4F6B              .EXIT:
 189+ 4F6B FB               EI
 190+ 4F6C E1           	POP HL
 191+ 4F6D C9           	RET
 192+ 4F6E              .INCREASE:
 193+ 4F6E ED 44            NEG
 194+ 4F70 CD 8D 4F         CALL .SIZEDIFF
 195+ 4F73 CD D4 4F         CALL .INCREASE_COMMON
 196+ 4F76 2A F6 4E         LD HL,(ANIMSPRPTR)
 197+ 4F79 09               ADD HL,BC
 198+ 4F7A 22 F6 4E         LD (ANIMSPRPTR),HL
 199+ 4F7D              .E2:
 200+ 4F7D 2A F9 4E         LD HL,(AUTOSGAMPTR)
 201+ 4F80 09               ADD HL,BC
 202+ 4F81 22 F9 4E         LD (AUTOSGAMPTR),HL
 203+ 4F84              .E4:
 204+ 4F84 2A 10 40         LD HL,(FREEMEMPTR)
 205+ 4F87 09               ADD HL,BC
 206+ 4F88 22 10 40         LD (FREEMEMPTR),HL
 207+ 4F8B 18 DE            JR .EXIT
 208+ 4F8D              .SIZEDIFF:
 209+ 4F8D CD FB 4E         CALL Ax5
 210+ 4F90 78               LD A,B
 211+ 4F91 32 EF 4E         LD (ANIMITEMNUM),A
 212+ 4F94 44               LD B,H
 213+ 4F95 4D               LD C,L
 214+ 4F96 C9               RET ; BC=size difference in bytes
 215+ 4F97              .SIZETOMOVE:
 216+ 4F97 D5               PUSH DE
 217+ 4F98 2A 10 40         LD HL,(FREEMEMPTR)
 218+ 4F9B FD 5E 00         LD E,(IY)
 219+ 4F9E FD 56 01         LD D,(IY+1)
 220+ 4FA1 AF               XOR A
 221+ 4FA2 ED 52            SBC HL,DE
 222+ 4FA4 44               LD B,H
 223+ 4FA5 4D               LD C,L
 224+ 4FA6 D1               POP DE
 225+ 4FA7 C9               RET
 226+ 4FA8              .DECREASE_COMMON:
 227+ 4FA8 FD 6E 00         LD L,(IY)
 228+ 4FAB FD 66 01         LD H,(IY+1)
 229+ 4FAE AF               XOR A
 230+ 4FAF ED 42            SBC HL,BC
 231+ 4FB1 EB               EX DE,HL
 232+ 4FB2 C5               PUSH BC
 233+ 4FB3 CD 97 4F         CALL .SIZETOMOVE
 234+ 4FB6 F3               DI
 235+ 4FB7 78               LD A,B
 236+ 4FB8 B1               OR C
 237+ 4FB9 28 08            JR Z,.L1
 238+ 4FBB FD 6E 00         LD L,(IY)
 239+ 4FBE FD 66 01         LD H,(IY+1)
 240+ 4FC1 ED B0            LDIR
 241+ 4FC3              .L1:
 242+ 4FC3 C1               POP BC
 243+ 4FC4 FD 6E 00         LD L,(IY)
 244+ 4FC7 FD 66 01         LD H,(IY+1)
 245+ 4FCA AF               XOR A
 246+ 4FCB ED 42            SBC HL,BC
 247+ 4FCD FD 75 00         LD (IY),L
 248+ 4FD0 FD 74 01         LD (IY+1),H
 249+ 4FD3 C9               RET
 250+ 4FD4              .INCREASE_COMMON:
 251+ 4FD4 2A 10 40         LD HL,(FREEMEMPTR)
 252+ 4FD7 2B               DEC HL
 253+ 4FD8 AF               XOR A
 254+ 4FD9 ED 42            SBC HL,BC
 255+ 4FDB EB               EX DE,HL
 256+ 4FDC C5               PUSH BC
 257+ 4FDD CD 97 4F         CALL .SIZETOMOVE
 258+ 4FE0 F3               DI
 259+ 4FE1 78               LD A,B
 260+ 4FE2 B1               OR C
 261+ 4FE3 28 06            JR Z,.L2
 262+ 4FE5 2A 10 40         LD HL,(FREEMEMPTR)
 263+ 4FE8 2B               DEC HL
 264+ 4FE9 ED B8            LDDR
 265+ 4FEB              .L2:
 266+ 4FEB C1               POP BC
 267+ 4FEC FD 6E 00         LD L,(IY)
 268+ 4FEF FD 66 01         LD H,(IY+1)
 269+ 4FF2 09               ADD HL,BC
 270+ 4FF3 FD 75 00         LD (IY),L
 271+ 4FF6 FD 74 01         LD (IY+1),H
 272+ 4FF9 C9               RET
 273+ 4FFA              ; *******************************************************************************************************
 274+ 4FFA
 275+ 4FFA               IF (0 == 1)
 276+ 4FFA ~            ; *******************************************************************************************************
 277+ 4FFA ~            ; function to handle CALL ANIMITEMPAT basic extension
 278+ 4FFA ~            ; ANIMITEMPAT ( BYTE id,
 279+ 4FFA ~            ;               INT ticks >0,
 280+ 4FFA ~            ;               BYTE pattern,
 281+ 4FFA ~            ;               BYTE color )
 282+ 4FFA ~            ; fills animation item data, returns an error if ID out of bounds
 283+ 4FFA ~            ANIMITEMPAT:
 284+ 4FFA ~                ; opening (
 285+ 4FFA ~            	CALL CHKCHAR
 286+ 4FFA ~            	DB '('
 287+ 4FFA ~            	; get id
 288+ 4FFA ~            	LD IX, GETBYT
 289+ 4FFA ~            	CALL CALBAS
 290+ 4FFA ~                PUSH AF
 291+ 4FFA ~                ; check if out of bounds
 292+ 4FFA ~                INC A
 293+ 4FFA ~                LD C,A
 294+ 4FFA ~                LD A,(ANIMITEMNUM)
 295+ 4FFA ~                CP C
 296+ 4FFA ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 297+ 4FFA ~            	; comma
 298+ 4FFA ~            	CALL CHKCHAR
 299+ 4FFA ~            	DB ','
 300+ 4FFA ~            	; get ticks
 301+ 4FFA ~            	LD IX, FRMQNT
 302+ 4FFA ~            	CALL CALBAS
 303+ 4FFA ~                LD A,D
 304+ 4FFA ~                OR E
 305+ 4FFA ~                JP Z, OVERFLOW
 306+ 4FFA ~            	PUSH DE
 307+ 4FFA ~            	; comma
 308+ 4FFA ~            	CALL CHKCHAR
 309+ 4FFA ~            	DB ','
 310+ 4FFA ~            	; get pattern
 311+ 4FFA ~            	LD IX, GETBYT
 312+ 4FFA ~            	CALL CALBAS
 313+ 4FFA ~                PUSH AF
 314+ 4FFA ~            	; comma
 315+ 4FFA ~            	CALL CHKCHAR
 316+ 4FFA ~            	DB ','
 317+ 4FFA ~            	; get color
 318+ 4FFA ~            	LD IX, GETBYT
 319+ 4FFA ~            	CALL CALBAS
 320+ 4FFA ~                PUSH AF
 321+ 4FFA ~            	; ending )
 322+ 4FFA ~            	CALL CHKCHAR
 323+ 4FFA ~            	DB ')'
 324+ 4FFA ~            .ENTRY:
 325+ 4FFA ~                PUSH HL
 326+ 4FFA ~                POP IX
 327+ 4FFA ~                EXX
 328+ 4FFA ~                POP BC ; color
 329+ 4FFA ~                POP DE ; pattern
 330+ 4FFA ~                POP HL ; ticks
 331+ 4FFA ~                EXX
 332+ 4FFA ~                POP AF
 333+ 4FFA ~                CALL GETnthANIMITEM
 334+ 4FFA ~                PUSH HL
 335+ 4FFA ~                POP IY
 336+ 4FFA ~                EXX
 337+ 4FFA ~                LD (IY),0 ; type=0
 338+ 4FFA ~                LD (IY+1),L
 339+ 4FFA ~                LD (IY+2),H
 340+ 4FFA ~                LD (IY+3),D
 341+ 4FFA ~                LD (IY+4),B
 342+ 4FFA ~
 343+ 4FFA ~                PUSH IX
 344+ 4FFA ~                POP HL
 345+ 4FFA ~                RET
 346+ 4FFA ~            ; *******************************************************************************************************
 347+ 4FFA               ENDIF
 348+ 4FFA
 349+ 4FFA               IF (1 == 1)
 350+ 4FFA              ; *******************************************************************************************************
 351+ 4FFA              ; same as ANIMITEMPAT but for DEFUSR approach
 352+ 4FFA              ; input IX=pointer to input array, real data from +2
 353+ 4FFA              ; +02 = ID
 354+ 4FFA              ; +04 = ticks
 355+ 4FFA              ; +06 = pattern
 356+ 4FFA              ; +08 = color
 357+ 4FFA              ANIMITEMPAT_DEFUSR:
 358+ 4FFA                  ; check if out of bounds
 359+ 4FFA DD 4E 02         LD C,(IX+2)
 360+ 4FFD 0C               INC C
 361+ 4FFE 3A EF 4E         LD A,(ANIMITEMNUM)
 362+ 5001 B9               CP C
 363+ 5002 D8               RET C ; out of bounds, prevent memory corruption
 364+ 5003 79               LD A,C
 365+ 5004 3D               DEC A
 366+ 5005 CD 04 4F         CALL GETnthANIMITEM
 367+ 5008 36 00            LD (HL),0 ; type=0
 368+ 500A 23               INC HL
 369+ 500B DD 7E 04         LD A,(IX+4) ; ticks low
 370+ 500E 77               LD (HL),A
 371+ 500F 23               INC HL
 372+ 5010 DD 7E 05         LD A,(IX+5) ; ticks high
 373+ 5013 77               LD (HL),A
 374+ 5014 23               INC HL
 375+ 5015 DD 7E 06         LD A,(IX+6) ; pattern
 376+ 5018 77               LD (HL),A
 377+ 5019 23               INC HL
 378+ 501A DD 7E 08         LD A,(IX+8) ; color
 379+ 501D 77               LD (HL),A
 380+ 501E C9               RET
 381+ 501F              ; *******************************************************************************************************
 382+ 501F               ENDIF
 383+ 501F
 384+ 501F               IF (0 == 1)
 385+ 501F ~            ; *******************************************************************************************************
 386+ 501F ~            ; function to handle CALL ANIMITEMPTR basic extension
 387+ 501F ~            ; ANIMITEMPTR ( BYTE id,
 388+ 501F ~            ;               INT ticks,
 389+ 501F ~            ;               INT pointer,
 390+ 501F ~            ; fills animation item data, returns an error if ID out of bounds
 391+ 501F ~            ANIMITEMPTR_CMD:
 392+ 501F ~                ; opening (
 393+ 501F ~            	CALL CHKCHAR
 394+ 501F ~            	DB '('
 395+ 501F ~            	; get id
 396+ 501F ~            	LD IX, GETBYT
 397+ 501F ~            	CALL CALBAS
 398+ 501F ~                PUSH AF
 399+ 501F ~                ; check if out of bounds
 400+ 501F ~                INC A
 401+ 501F ~                LD C,A
 402+ 501F ~                LD A,(ANIMITEMNUM)
 403+ 501F ~                CP C
 404+ 501F ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 405+ 501F ~            	; comma
 406+ 501F ~            	CALL CHKCHAR
 407+ 501F ~            	DB ','
 408+ 501F ~            	; get ticks
 409+ 501F ~            	LD IX, FRMQNT
 410+ 501F ~            	CALL CALBAS
 411+ 501F ~                LD A,D
 412+ 501F ~                OR E
 413+ 501F ~                JP Z,OVERFLOW
 414+ 501F ~            	PUSH DE
 415+ 501F ~            	; comma
 416+ 501F ~            	CALL CHKCHAR
 417+ 501F ~            	DB ','
 418+ 501F ~            	; get pointer
 419+ 501F ~            	LD IX, FRMQNT
 420+ 501F ~            	CALL CALBAS
 421+ 501F ~            	PUSH DE
 422+ 501F ~            	; ending )
 423+ 501F ~            	CALL CHKCHAR
 424+ 501F ~            	DB ')'
 425+ 501F ~            .ENTRY:
 426+ 501F ~                PUSH HL
 427+ 501F ~                POP IX
 428+ 501F ~                EXX
 429+ 501F ~                POP DE ; pointer
 430+ 501F ~                POP HL ; ticks
 431+ 501F ~                EXX
 432+ 501F ~                POP AF
 433+ 501F ~                CALL GETnthANIMITEM
 434+ 501F ~                PUSH HL
 435+ 501F ~                POP IY
 436+ 501F ~                EXX
 437+ 501F ~                LD (IY),1 ; type=1
 438+ 501F ~                LD (IY+1),L
 439+ 501F ~                LD (IY+2),H
 440+ 501F ~                LD (IY+3),E
 441+ 501F ~                LD (IY+4),D
 442+ 501F ~
 443+ 501F ~                PUSH IX
 444+ 501F ~                POP HL
 445+ 501F ~                RET
 446+ 501F ~            ; *******************************************************************************************************
 447+ 501F               ENDIF
 448+ 501F
 449+ 501F               IF (1 == 1)
 450+ 501F              ; *******************************************************************************************************
 451+ 501F              ; same as ANIMITEMPTR but for DEFUSR approach
 452+ 501F              ; input IX=pointer to input array, real data from +2
 453+ 501F              ; +02 = ID
 454+ 501F              ; +04 = ticks
 455+ 501F              ; +06 = pointer
 456+ 501F              ANIMITEMPTR_DEFUSR:
 457+ 501F                  ; check if out of bounds
 458+ 501F DD 4E 02         LD C,(IX+2)
 459+ 5022 0C               INC C
 460+ 5023 3A EF 4E         LD A,(ANIMITEMNUM)
 461+ 5026 B9               CP C
 462+ 5027 D8               RET C ; out of bounds, prevent memory corruption
 463+ 5028 79               LD A,C
 464+ 5029 3D               DEC A
 465+ 502A CD 04 4F         CALL GETnthANIMITEM
 466+ 502D 36 01            LD (HL),1 ; type=1
 467+ 502F 23               INC HL
 468+ 5030 DD 7E 04         LD A,(IX+4) ; ticks low
 469+ 5033 77               LD (HL),A
 470+ 5034 23               INC HL
 471+ 5035 DD 7E 05         LD A,(IX+5) ; ticks high
 472+ 5038 77               LD (HL),A
 473+ 5039 23               INC HL
 474+ 503A DD 7E 06         LD A,(IX+6) ; pointer low
 475+ 503D 77               LD (HL),A
 476+ 503E 23               INC HL
 477+ 503F DD 7E 07         LD A,(IX+7) ; pointer high
 478+ 5042 77               LD (HL),A
 479+ 5043 C9               RET
 480+ 5044              ; *******************************************************************************************************
 481+ 5044               ENDIF
 482+ 5044
 483+ 5044               IF (1 == 1)
 484+ 5044              ; *******************************************************************************************************
 485+ 5044              ; same as MAXANIMDEFS but for DEFUSR approach
 486+ 5044              ; input IX=pointer to input array, real data from +2
 487+ 5044              ; +2 = number
 488+ 5044              MAXANIMDEFS_DEFUSR:
 489+ 5044 DD 7E 02         LD A,(IX+2)
 490+ 5047 18 00            JR MAXANIMDEFS.COMMON
 491+ 5049              ; *******************************************************************************************************
 492+ 5049               ENDIF
 493+ 5049
 494+ 5049              ; *******************************************************************************************************
 495+ 5049              ; function to handle CALL MAXANIMDEFS basic extension
 496+ 5049              ; MAXANIMDEFS (BYTE number)
 497+ 5049              ; sets new number and moves memory buffers as needed
 498+ 5049              MAXANIMDEFS:
 499+ 5049               IF (0 == 1)
 500+ 5049 ~            	; opening (
 501+ 5049 ~            	CALL CHKCHAR
 502+ 5049 ~            	DB '('
 503+ 5049 ~            	; get value
 504+ 5049 ~            	LD IX, GETBYT
 505+ 5049 ~            	CALL CALBAS
 506+ 5049 ~                PUSH AF
 507+ 5049 ~            	; ending )
 508+ 5049 ~            	CALL CHKCHAR
 509+ 5049 ~            	DB ')'
 510+ 5049 ~                POP AF
 511+ 5049               ENDIF
 512+ 5049              .COMMON:
 513+ 5049 F3               DI
 514+ 504A              	; save position
 515+ 504A E5           	PUSH HL
 516+ 504B              .ENTRY:
 517+ 504B 47               LD B,A
 518+ 504C 3A F2 4E         LD A,(ANIMDEFNUM)
 519+ 504F 90               SUB B
 520+ 5050 CA 6B 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 521+ 5053 FD 21 F6 4E      LD IY,ANIMSPRPTR
 522+ 5057 FA 63 50         JP M, .INCREASE
 523+ 505A                  ; new value is lower than previous one
 524+ 505A CD 6E 50         CALL .SIZEDIFF
 525+ 505D CD A8 4F         CALL MAXANIMITEMS.DECREASE_COMMON
 526+ 5060 C3 59 4F         JP MAXANIMITEMS.E1
 527+ 5063              .INCREASE:
 528+ 5063 ED 44            NEG
 529+ 5065 CD 6E 50         CALL .SIZEDIFF
 530+ 5068 CD D4 4F         CALL MAXANIMITEMS.INCREASE_COMMON
 531+ 506B C3 7D 4F         JP MAXANIMITEMS.E2
 532+ 506E              .SIZEDIFF:
 533+ 506E 26 00            LD H,0
 534+ 5070 6F               LD L,A
 535+ 5071 CD 06 5E         CALL HLx16
 536+ 5074 78               LD A,B
 537+ 5075 32 F2 4E         LD (ANIMDEFNUM),A
 538+ 5078 44               LD B,H
 539+ 5079 4D               LD C,L
 540+ 507A C9               RET ; BC=size difference in bytes
 541+ 507B              ; *******************************************************************************************************
 542+ 507B
 543+ 507B               IF (0 == 1)
 544+ 507B ~            ; *******************************************************************************************************
 545+ 507B ~            ; function to handle CALL ANIMDEF basic extension
 546+ 507B ~            ; ANIMITEMPAT ( BYTE id,
 547+ 507B ~            ;               BYTE size,
 548+ 507B ~            ;               INT[] list )
 549+ 507B ~            ; fills animation definition data, returns an error if out of bounds, or invalid type
 550+ 507B ~            ANIMDEF:
 551+ 507B ~                ; opening (
 552+ 507B ~            	CALL CHKCHAR
 553+ 507B ~            	DB '('
 554+ 507B ~            	; get id
 555+ 507B ~            	LD IX, GETBYT
 556+ 507B ~            	CALL CALBAS
 557+ 507B ~                PUSH AF
 558+ 507B ~                ; check if out of bounds
 559+ 507B ~                INC A
 560+ 507B ~                LD C,A
 561+ 507B ~                LD A,(ANIMDEFNUM)
 562+ 507B ~                CP C
 563+ 507B ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 564+ 507B ~            	; comma
 565+ 507B ~            	CALL CHKCHAR
 566+ 507B ~            	DB ','
 567+ 507B ~            	; get size
 568+ 507B ~            	LD IX, GETBYT
 569+ 507B ~            	CALL CALBAS
 570+ 507B ~                CP 16
 571+ 507B ~                JP NC, OVERFLOW
 572+ 507B ~                OR A
 573+ 507B ~                JP Z, OVERFLOW
 574+ 507B ~            	PUSH AF
 575+ 507B ~            	; comma
 576+ 507B ~            	CALL CHKCHAR
 577+ 507B ~            	DB ','
 578+ 507B ~            	; get pointer to a list of animation items in integer array format
 579+ 507B ~                ; get array pointer
 580+ 507B ~                POP DE
 581+ 507B ~                PUSH DE
 582+ 507B ~                LD A,2
 583+ 507B ~                LD B,1
 584+ 507B ~                CALL GET_BASIC_ARRAY_DATA_POINTER
 585+ 507B ~                PUSH BC
 586+ 507B ~            	; ending )
 587+ 507B ~            	CALL CHKCHAR
 588+ 507B ~            	DB ')'
 589+ 507B ~            .ENTRY:
 590+ 507B ~                PUSH HL
 591+ 507B ~                POP IX
 592+ 507B ~                POP DE ; pointer to INT array
 593+ 507B ~                POP BC ; B=item number
 594+ 507B ~                POP AF ; id
 595+ 507B ~                PUSH DE
 596+ 507B ~                CALL GETnthANIMDEF
 597+ 507B ~                POP DE
 598+ 507B ~                LD (HL),B
 599+ 507B ~            .L1:
 600+ 507B ~                INC HL
 601+ 507B ~                LD A,(DE)
 602+ 507B ~                .2 INC DE
 603+ 507B ~                LD (HL),A
 604+ 507B ~                DJNZ .L1
 605+ 507B ~                PUSH IX
 606+ 507B ~                POP HL
 607+ 507B ~                RET
 608+ 507B ~            ; *******************************************************************************************************
 609+ 507B               ENDIF
 610+ 507B
 611+ 507B               IF (1 == 1)
 612+ 507B              ; *******************************************************************************************************
 613+ 507B              ; same as ANIMDEF but for DEFUSR approach
 614+ 507B              ; input IX=pointer to input array, real data from +2
 615+ 507B              ; +02 = ID
 616+ 507B              ; +04 = list size
 617+ 507B              ; +06 = list pointer
 618+ 507B              ANIMDEF_DEFUSR:
 619+ 507B                  ; check if out of bounds
 620+ 507B DD 4E 02         LD C,(IX+2)
 621+ 507E 0C               INC C
 622+ 507F 3A F2 4E         LD A,(ANIMDEFNUM)
 623+ 5082 B9               CP C
 624+ 5083 D8               RET C ; invalid id
 625+ 5084              	; get size
 626+ 5084 DD 7E 04         LD A,(IX+4)
 627+ 5087 FE 10            CP 16
 628+ 5089 D0               RET NC ; overflow
 629+ 508A B7               OR A
 630+ 508B C8               RET Z ; ID=0, invalid
 631+ 508C 47               LD B,A
 632+ 508D 79               LD A,C
 633+ 508E 3D               DEC A
 634+ 508F CD 0D 4F         CALL GETnthANIMDEF
 635+ 5092 70               LD (HL),B
 636+ 5093 DD 5E 06         LD E,(IX+6)
 637+ 5096 DD 56 07         LD D,(IX+7)
 638+ 5099              .L1:
 639+ 5099 23               INC HL
 640+ 509A 1A               LD A,(DE)
 641+ 509B 13          > INC DE
 641+ 509C 13          > INC DE
 642+ 509D 77               LD (HL),A
 643+ 509E 10 F9            DJNZ .L1
 644+ 50A0 C9               RET
 645+ 50A1              ; *******************************************************************************************************
 646+ 50A1               ENDIF
 647+ 50A1
 648+ 50A1               IF (1 == 1)
 649+ 50A1              ; *******************************************************************************************************
 650+ 50A1              ; same as MAXANIMSPRS but for DEFUSR approach
 651+ 50A1              ; input IX=pointer to input array, real data from +2
 652+ 50A1              ; +2 = number
 653+ 50A1              MAXANIMSPRS_DEFUSR:
 654+ 50A1 DD 7E 02         LD A,(IX+2)
 655+ 50A4 18 00            JR MAXANIMSPRS.COMMON
 656+ 50A6              ; *******************************************************************************************************
 657+ 50A6               ENDIF
 658+ 50A6
 659+ 50A6              ; *******************************************************************************************************
 660+ 50A6              ; function to handle CALL MAXANIMSPRS basic extension
 661+ 50A6              ; MAXANIMSPRS (BYTE number)
 662+ 50A6              ; sets new number and moves memory buffers as needed
 663+ 50A6              MAXANIMSPRS:
 664+ 50A6               IF (0 == 1)
 665+ 50A6 ~            	; opening (
 666+ 50A6 ~            	CALL CHKCHAR
 667+ 50A6 ~            	DB '('
 668+ 50A6 ~            	; get value
 669+ 50A6 ~            	LD IX, GETBYT
 670+ 50A6 ~            	CALL CALBAS
 671+ 50A6 ~                PUSH AF
 672+ 50A6 ~            	; ending )
 673+ 50A6 ~            	CALL CHKCHAR
 674+ 50A6 ~            	DB ')'
 675+ 50A6 ~                POP AF
 676+ 50A6               ENDIF
 677+ 50A6              .COMMON:
 678+ 50A6 F3               DI
 679+ 50A7              	; save position
 680+ 50A7 E5           	PUSH HL
 681+ 50A8              .ENTRY:
 682+ 50A8 47               LD B,A
 683+ 50A9 3A F5 4E         LD A,(ANIMSPRNUM)
 684+ 50AC 90               SUB B
 685+ 50AD CA 6B 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 686+ 50B0 FD 21 F9 4E      LD IY,AUTOSGAMPTR
 687+ 50B4 FA C0 50         JP M, .INCREASE
 688+ 50B7                  ; new value is lower than previous one
 689+ 50B7 CD E1 50         CALL .SIZEDIFF
 690+ 50BA CD A8 4F         CALL MAXANIMITEMS.DECREASE_COMMON
 691+ 50BD C3 62 4F         JP MAXANIMITEMS.E3
 692+ 50C0              .INCREASE:
 693+ 50C0 ED 44            NEG
 694+ 50C2 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 695+ 50C3 CD E1 50         CALL .SIZEDIFF
 696+ 50C6 CD D4 4F         CALL MAXANIMITEMS.INCREASE_COMMON
 697+ 50C9 AF               XOR A
 698+ 50CA ED 42            SBC HL,BC ; location of new stuff
 699+ 50CC F1               POP AF
 700+ 50CD C5               PUSH BC
 701+ 50CE 47               LD B,A
 702+ 50CF 11 08 00         LD DE,8
 703+ 50D2 E5               PUSH HL
 704+ 50D3 DD E1            POP IX
 705+ 50D5              .L1:
 706+ 50D5 DD 36 06 00      LD (IX+6),0 ; active flag
 707+ 50D9 DD 19            ADD IX,DE
 708+ 50DB 10 F8            DJNZ .L1
 709+ 50DD C1               POP BC
 710+ 50DE C3 84 4F         JP MAXANIMITEMS.E4
 711+ 50E1              .SIZEDIFF:
 712+ 50E1 26 00            LD H,0
 713+ 50E3 6F               LD L,A
 714+ 50E4 CD 07 5E         CALL HLx8
 715+ 50E7 78               LD A,B
 716+ 50E8 32 F5 4E         LD (ANIMSPRNUM),A
 717+ 50EB 44               LD B,H
 718+ 50EC 4D               LD C,L
 719+ 50ED C9               RET ; BC=size difference in bytes
 720+ 50EE              ; *******************************************************************************************************
 721+ 50EE
 722+ 50EE               IF (0 == 1)
 723+ 50EE ~            ; *******************************************************************************************************
 724+ 50EE ~            ; function to handle CALL ANIMSPRITE basic extension
 725+ 50EE ~            ; ANIMSPRITE ( BYTE id,
 726+ 50EE ~            ;              BYTE sprite_number,
 727+ 50EE ~            ;              BYTE animation_definition_id,
 728+ 50EE ~            ;              BYTE cyclic_flag )
 729+ 50EE ~            ; fills sprite animation data, returns an error if out of bounds, or invalid type
 730+ 50EE ~            ANIMSPRITE:
 731+ 50EE ~                ; opening (
 732+ 50EE ~            	CALL CHKCHAR
 733+ 50EE ~            	DB '('
 734+ 50EE ~            	; get sprite animation id
 735+ 50EE ~            	LD IX, GETBYT
 736+ 50EE ~            	CALL CALBAS
 737+ 50EE ~                PUSH AF
 738+ 50EE ~                INC A
 739+ 50EE ~                LD C,A
 740+ 50EE ~                LD A,(ANIMSPRNUM)
 741+ 50EE ~                CP C
 742+ 50EE ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 743+ 50EE ~            	; comma
 744+ 50EE ~            	CALL CHKCHAR
 745+ 50EE ~            	DB ','
 746+ 50EE ~            	; get sprite number
 747+ 50EE ~            	LD IX, GETBYT
 748+ 50EE ~            	CALL CALBAS
 749+ 50EE ~                PUSH AF
 750+ 50EE ~                ; check if out of bounds
 751+ 50EE ~                CP 32
 752+ 50EE ~                JP NC, SUBSCRIPT_OUT_OF_RANGE
 753+ 50EE ~            	; comma
 754+ 50EE ~            	CALL CHKCHAR
 755+ 50EE ~            	DB ','
 756+ 50EE ~            	; get animation definition id
 757+ 50EE ~            	LD IX, GETBYT
 758+ 50EE ~            	CALL CALBAS
 759+ 50EE ~                PUSH AF
 760+ 50EE ~                INC A
 761+ 50EE ~                LD C,A
 762+ 50EE ~                LD A,(ANIMDEFNUM)
 763+ 50EE ~                CP C
 764+ 50EE ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 765+ 50EE ~            	; comma
 766+ 50EE ~            	CALL CHKCHAR
 767+ 50EE ~            	DB ','
 768+ 50EE ~            	; get cyclic flag
 769+ 50EE ~            	LD IX, GETBYT
 770+ 50EE ~                CALL CALBAS
 771+ 50EE ~            	PUSH AF
 772+ 50EE ~            	; ending )
 773+ 50EE ~            	CALL CHKCHAR
 774+ 50EE ~            	DB ')'
 775+ 50EE ~            .ENTRY:
 776+ 50EE ~                PUSH HL
 777+ 50EE ~                POP IX
 778+ 50EE ~                EXX
 779+ 50EE ~                POP DE ; cyclic
 780+ 50EE ~                POP BC ; animation definition id
 781+ 50EE ~                POP HL ; sprite number
 782+ 50EE ~                EXX
 783+ 50EE ~                POP AF ; sprite animation id
 784+ 50EE ~                CALL GETnthSPRANIM
 785+ 50EE ~                PUSH HL
 786+ 50EE ~                POP IY
 787+ 50EE ~                EXX
 788+ 50EE ~                LD (IY),H
 789+ 50EE ~                LD (IY+4),B
 790+ 50EE ~                LD (IY+5),D
 791+ 50EE ~                ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 792+ 50EE ~                ; following will do preparation for ANIMSTEP situation
 793+ 50EE ~                ; current item set to above limit and timer to 1
 794+ 50EE ~                ; any call to ANIMSTEP will switch and setup to first item for cyclic
 795+ 50EE ~                LD (IY+3),255
 796+ 50EE ~                LD (IY+1),1
 797+ 50EE ~                LD (IY+2),0
 798+ 50EE ~                ; mark as sprite animation
 799+ 50EE ~                LD (IY+7),0
 800+ 50EE ~                PUSH IX
 801+ 50EE ~                POP HL
 802+ 50EE ~                RET
 803+ 50EE ~            ; *******************************************************************************************************
 804+ 50EE               ENDIF
 805+ 50EE
 806+ 50EE               IF (1 == 1)
 807+ 50EE              ; *******************************************************************************************************
 808+ 50EE              ; same as ANIMSPRITE but for DEFUSR approach
 809+ 50EE              ; input IX=pointer to input array, real data from +2
 810+ 50EE              ; +02 = ID
 811+ 50EE              ; +04 = sprite number
 812+ 50EE              ; +06 = animation definition id
 813+ 50EE              ; +08 = cyclic flag
 814+ 50EE              ANIMSPRITE_DEFUSR:
 815+ 50EE DD 4E 02         LD C,(IX+2)
 816+ 50F1 0C               INC C
 817+ 50F2 3A F5 4E         LD A,(ANIMSPRNUM)
 818+ 50F5 B9               CP C
 819+ 50F6 D8               RET C ; invalid id
 820+ 50F7              	; get sprite number
 821+ 50F7 DD 7E 04         LD A,(IX+4)
 822+ 50FA FE 20            CP 32
 823+ 50FC D0               RET NC ; invalid sprite id
 824+ 50FD DD 46 06         LD B,(IX+6)
 825+ 5100 04               INC B
 826+ 5101 3A F2 4E         LD A,(ANIMDEFNUM)
 827+ 5104 B8               CP B
 828+ 5105 D8               RET C ; invalid animation definition id
 829+ 5106 79               LD A,C
 830+ 5107 3D               DEC A
 831+ 5108 CD 19 4F         CALL GETnthSPRANIM
 832+ 510B DD 7E 04         LD A,(IX+4)
 833+ 510E 77               LD (HL),A ; +0
 834+ 510F 23               INC HL
 835+ 5110 36 01            LD (HL),1 ; +1
 836+ 5112 23               INC HL
 837+ 5113 36 00            LD (HL),0 ; +2
 838+ 5115 23               INC HL
 839+ 5116 36 FF            LD (HL),255 ; +3
 840+ 5118 23               INC HL
 841+ 5119 05               DEC B
 842+ 511A 70               LD (HL),B ; +4
 843+ 511B 23               INC HL
 844+ 511C DD 7E 08         LD A,(IX+8) ; +5
 845+ 511F 77               LD (HL),A
 846+ 5120 23               INC HL
 847+ 5121 23               INC HL
 848+ 5122 36 00            LD (HL),0 ; +7
 849+ 5124 C9               RET
 850+ 5125              ; *******************************************************************************************************
 851+ 5125               ENDIF
 852+ 5125
 853+ 5125
 854+ 5125               IF (0 == 1)
 855+ 5125 ~            ; *******************************************************************************************************
 856+ 5125 ~            ; function to handle CALL ANIMCHAR basic extension
 857+ 5125 ~            ; ANIMCHAR ( BYTE id,
 858+ 5125 ~            ;            INT character number 0-767,
 859+ 5125 ~            ;            BYTE animation_definition_id,
 860+ 5125 ~            ;            BYTE cyclic_flag )
 861+ 5125 ~            ; fills sprite animation data, returns an error if out of bounds, or invalid type
 862+ 5125 ~            ANIMCHAR:
 863+ 5125 ~                ; opening (
 864+ 5125 ~            	CALL CHKCHAR
 865+ 5125 ~            	DB '('
 866+ 5125 ~            	; get sprite animation id
 867+ 5125 ~            	LD IX, GETBYT
 868+ 5125 ~            	CALL CALBAS
 869+ 5125 ~                PUSH AF
 870+ 5125 ~                INC A
 871+ 5125 ~                LD C,A
 872+ 5125 ~                LD A,(ANIMSPRNUM)
 873+ 5125 ~                CP C
 874+ 5125 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 875+ 5125 ~            	; comma
 876+ 5125 ~            	CALL CHKCHAR
 877+ 5125 ~            	DB ','
 878+ 5125 ~            	; get character number
 879+ 5125 ~            	LD IX, FRMQNT
 880+ 5125 ~            	CALL CALBAS
 881+ 5125 ~                PUSH DE
 882+ 5125 ~                ; check if out of bounds
 883+ 5125 ~                LD A,D
 884+ 5125 ~                CP 3
 885+ 5125 ~                JP NC, SUBSCRIPT_OUT_OF_RANGE
 886+ 5125 ~            	; comma
 887+ 5125 ~            	CALL CHKCHAR
 888+ 5125 ~            	DB ','
 889+ 5125 ~            	; get animation definition id
 890+ 5125 ~            	LD IX, GETBYT
 891+ 5125 ~            	CALL CALBAS
 892+ 5125 ~                PUSH AF
 893+ 5125 ~                INC A
 894+ 5125 ~                LD C,A
 895+ 5125 ~                LD A,(ANIMDEFNUM)
 896+ 5125 ~                CP C
 897+ 5125 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
 898+ 5125 ~            	; comma
 899+ 5125 ~            	CALL CHKCHAR
 900+ 5125 ~            	DB ','
 901+ 5125 ~            	; get cyclic flag
 902+ 5125 ~            	LD IX, GETBYT
 903+ 5125 ~                CALL CALBAS
 904+ 5125 ~            	PUSH AF
 905+ 5125 ~            	; ending )
 906+ 5125 ~            	CALL CHKCHAR
 907+ 5125 ~            	DB ')'
 908+ 5125 ~            .ENTRY:
 909+ 5125 ~                PUSH HL
 910+ 5125 ~                POP IX
 911+ 5125 ~                EXX
 912+ 5125 ~                POP DE ; cyclic
 913+ 5125 ~                POP BC ; animation definition id
 914+ 5125 ~                POP HL ; character number
 915+ 5125 ~                EXX
 916+ 5125 ~                POP AF ; sprite animation id
 917+ 5125 ~                CALL GETnthSPRANIM
 918+ 5125 ~                PUSH HL
 919+ 5125 ~                POP IY
 920+ 5125 ~                EXX
 921+ 5125 ~                LD (IY),L
 922+ 5125 ~                INC H ; save character bank+1
 923+ 5125 ~                LD (IY+7),H
 924+ 5125 ~                LD (IY+4),B
 925+ 5125 ~                LD (IY+5),D
 926+ 5125 ~                ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 927+ 5125 ~                ; following will do preparation for ANIMSTEP situation
 928+ 5125 ~                ; current item set to above limit and timer to 1
 929+ 5125 ~                ; any call to ANIMSTEP will switch and setup to first item for cyclic
 930+ 5125 ~                LD (IY+3),255
 931+ 5125 ~                LD (IY+1),1
 932+ 5125 ~                LD (IY+2),0
 933+ 5125 ~                PUSH IX
 934+ 5125 ~                POP HL
 935+ 5125 ~                RET
 936+ 5125 ~            ; *******************************************************************************************************
 937+ 5125               ENDIF
 938+ 5125
 939+ 5125               IF (1 == 1)
 940+ 5125              ; *******************************************************************************************************
 941+ 5125              ; same as ANIMCHAR but for DEFUSR approach
 942+ 5125              ; input IX=pointer to input array, real data from +2
 943+ 5125              ; +02 = ID
 944+ 5125              ; +04 = character number
 945+ 5125              ; +06 = animation definition id
 946+ 5125              ; +08 = cyclic flag
 947+ 5125              ANIMCHAR_DEFUSR:
 948+ 5125 DD 4E 02         LD C,(IX+2)
 949+ 5128 0C               INC C
 950+ 5129 3A F5 4E         LD A,(ANIMSPRNUM)
 951+ 512C B9               CP C
 952+ 512D D8               RET C ; invalid id
 953+ 512E              	; get sprite number
 954+ 512E DD 7E 05         LD A,(IX+5)
 955+ 5131 FE 03            CP 3
 956+ 5133 D0               RET NC ; invalid character (>767)
 957+ 5134 DD 46 06         LD B,(IX+6)
 958+ 5137 04               INC B
 959+ 5138 3A F2 4E         LD A,(ANIMDEFNUM)
 960+ 513B B8               CP B
 961+ 513C D8               RET C ; invalid animation definition id
 962+ 513D 79               LD A,C
 963+ 513E 3D               DEC A
 964+ 513F CD 19 4F         CALL GETnthSPRANIM
 965+ 5142 DD 7E 04         LD A,(IX+4)
 966+ 5145 77               LD (HL),A ; +0
 967+ 5146 23               INC HL
 968+ 5147 36 01            LD (HL),1 ; +1
 969+ 5149 23               INC HL
 970+ 514A 36 00            LD (HL),0 ; +2
 971+ 514C 23               INC HL
 972+ 514D 36 FF            LD (HL),255 ; +3
 973+ 514F 23               INC HL
 974+ 5150 05               DEC B
 975+ 5151 70               LD (HL),B ; +4
 976+ 5152 23               INC HL
 977+ 5153 DD 7E 08         LD A,(IX+8) ; +5
 978+ 5156 77               LD (HL),A
 979+ 5157 23               INC HL
 980+ 5158 23               INC HL
 981+ 5159 DD 7E 05         LD A,(IX+5)
 982+ 515C 3C               INC A
 983+ 515D 77               LD (HL),A ; +7
 984+ 515E C9               RET
 985+ 515F              ; *******************************************************************************************************
 986+ 515F               ENDIF
 987+ 515F
 988+ 515F               IF (1 == 1)
 989+ 515F              ; *******************************************************************************************************
 990+ 515F              ; same as MAXAUTOSGAMS but for DEFUSR approach
 991+ 515F              ; input IX=pointer to input array, real data from +2
 992+ 515F              ; +2 = number
 993+ 515F              MAXAUTOSGAMS_DEFUSR:
 994+ 515F DD 7E 02         LD A,(IX+2)
 995+ 5162 18 00            JR MAXAUTOSGAMS.COMMON
 996+ 5164              ; *******************************************************************************************************
 997+ 5164               ENDIF
 998+ 5164
 999+ 5164              ; *******************************************************************************************************
1000+ 5164              ; function to handle CALL MAXAUTOSGAMS basic extension
1001+ 5164              ; MAXAUTOSGAMS (BYTE number)
1002+ 5164              ; sets new number and moves memory buffers as needed
1003+ 5164              MAXAUTOSGAMS:
1004+ 5164               IF (0 == 1)
1005+ 5164 ~            	; opening (
1006+ 5164 ~            	CALL CHKCHAR
1007+ 5164 ~            	DB '('
1008+ 5164 ~            	; get value
1009+ 5164 ~            	LD IX, GETBYT
1010+ 5164 ~            	CALL CALBAS
1011+ 5164 ~                PUSH AF
1012+ 5164 ~            	; ending )
1013+ 5164 ~            	CALL CHKCHAR
1014+ 5164 ~            	DB ')'
1015+ 5164 ~                POP AF
1016+ 5164               ENDIF
1017+ 5164              .COMMON:
1018+ 5164 F3               DI
1019+ 5165              	; save position
1020+ 5165 E5           	PUSH HL
1021+ 5166              .ENTRY:
1022+ 5166 47               LD B,A
1023+ 5167 3A F8 4E         LD A,(AUTOSGAMNUM)
1024+ 516A 90               SUB B
1025+ 516B CA 6B 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
1026+ 516E FD 21 10 40      LD IY,FREEMEMPTR
1027+ 5172 FA 7E 51         JP M, .INCREASE
1028+ 5175                  ; new value is lower than previous one
1029+ 5175 CD 9F 51         CALL .SIZEDIFF
1030+ 5178 CD A8 4F         CALL MAXANIMITEMS.DECREASE_COMMON
1031+ 517B C3 6B 4F         JP MAXANIMITEMS.EXIT
1032+ 517E              .INCREASE:
1033+ 517E ED 44            NEG
1034+ 5180 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
1035+ 5181 CD 9F 51         CALL .SIZEDIFF
1036+ 5184 CD D4 4F         CALL MAXANIMITEMS.INCREASE_COMMON
1037+ 5187 AF               XOR A
1038+ 5188 ED 42            SBC HL,BC ; location of new stuff
1039+ 518A F1               POP AF
1040+ 518B C5               PUSH BC
1041+ 518C 47               LD B,A
1042+ 518D 11 18 00         LD DE,24
1043+ 5190 E5               PUSH HL
1044+ 5191 DD E1            POP IX
1045+ 5193              .L1:
1046+ 5193 DD 36 13 00      LD (IX+19),0 ; active flag
1047+ 5197 DD 19            ADD IX,DE
1048+ 5199 10 F8            DJNZ .L1
1049+ 519B C1               POP BC
1050+ 519C C3 6B 4F         JP MAXANIMITEMS.EXIT
1051+ 519F              .SIZEDIFF:
1052+ 519F 26 00            LD H,0
1053+ 51A1 6F               LD L,A
1054+ 51A2 CD 07 5E         CALL HLx8
1055+ 51A5 54               LD D,H
1056+ 51A6 5D               LD E,L
1057+ 51A7 29               ADD HL,HL
1058+ 51A8 19               ADD HL,DE
1059+ 51A9 78               LD A,B
1060+ 51AA 32 F8 4E         LD (AUTOSGAMNUM),A
1061+ 51AD 44               LD B,H
1062+ 51AE 4D               LD C,L
1063+ 51AF C9               RET ; BC=size difference in bytes
1064+ 51B0              ; *******************************************************************************************************
1065+ 51B0
1066+ 51B0               IF (0 == 1)
1067+ 51B0 ~            ; *******************************************************************************************************
1068+ 51B0 ~            ; function to handle CALL AUTOSGAMDEF basic extension
1069+ 51B0 ~            ; AUTOSGAMDEF ( BYTE id,
1070+ 51B0 ~            ;               INT VARIABLE x, INT VARIABLE y,
1071+ 51B0 ~            ;               INT minimum, INT maximum, INT delta,
1072+ 51B0 ~            ;               INT direction =0 horizontal,
1073+ 51B0 ~            ;               INT ticks,
1074+ 51B0 ~            ;               BYTE sprite_group_count,
1075+ 51B0 ~            ;               INT[2][sprite_group_count] VARIABLE sprite_group,
1076+ 51B0 ~            ;               BYTE item_number,
1077+ 51B0 ~            ;               INT[] VARIABLE sprite_animations_negative_direction,
1078+ 51B0 ~            ;               INT[] VARIABLE sprite_animations_positive_direction
1079+ 51B0 ~            AUTOSGAMDEF:
1080+ 51B0 ~                ; opening (
1081+ 51B0 ~            	CALL CHKCHAR
1082+ 51B0 ~            	DB '('
1083+ 51B0 ~            	; get sprite animation id
1084+ 51B0 ~            	LD IX, GETBYT
1085+ 51B0 ~            	CALL CALBAS
1086+ 51B0 ~                PUSH AF
1087+ 51B0 ~                INC A
1088+ 51B0 ~                LD C,A
1089+ 51B0 ~                LD A,(AUTOSGAMNUM)
1090+ 51B0 ~                CP C
1091+ 51B0 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
1092+ 51B0 ~                POP AF
1093+ 51B0 ~                PUSH HL
1094+ 51B0 ~                CALL GETnthAUTOSGAM
1095+ 51B0 ~                LD (BLIT_TMP),HL ; for later
1096+ 51B0 ~                POP HL
1097+ 51B0 ~            	; comma
1098+ 51B0 ~            	CALL CHKCHAR
1099+ 51B0 ~            	DB ','
1100+ 51B0 ~            	; get address of the X coordinate variable
1101+ 51B0 ~            	LD IX, PTRGET
1102+ 51B0 ~            	CALL CALBAS
1103+ 51B0 ~            	LD IX,(BLIT_TMP)
1104+ 51B0 ~                LD (IX+0),E
1105+ 51B0 ~                LD (IX+1),D
1106+ 51B0 ~            	; comma
1107+ 51B0 ~            	CALL CHKCHAR
1108+ 51B0 ~            	DB ','
1109+ 51B0 ~            	; get address of the Y coordinate variable
1110+ 51B0 ~            	LD IX, PTRGET
1111+ 51B0 ~            	CALL CALBAS
1112+ 51B0 ~            	LD IX,(BLIT_TMP)
1113+ 51B0 ~                LD (IX+2),E
1114+ 51B0 ~                LD (IX+3),D
1115+ 51B0 ~            	; comma
1116+ 51B0 ~            	CALL CHKCHAR
1117+ 51B0 ~            	DB ','
1118+ 51B0 ~            	; get minimum value
1119+ 51B0 ~            	LD IX, FRMQNT
1120+ 51B0 ~            	CALL CALBAS
1121+ 51B0 ~            	LD IX,(BLIT_TMP)
1122+ 51B0 ~                LD (IX+4),E
1123+ 51B0 ~                LD (IX+5),D
1124+ 51B0 ~            	; comma
1125+ 51B0 ~            	CALL CHKCHAR
1126+ 51B0 ~            	DB ','
1127+ 51B0 ~            	; get maximum value
1128+ 51B0 ~            	LD IX, FRMQNT
1129+ 51B0 ~            	CALL CALBAS
1130+ 51B0 ~            	LD IX,(BLIT_TMP)
1131+ 51B0 ~                LD (IX+6),E
1132+ 51B0 ~                LD (IX+7),D
1133+ 51B0 ~            	; comma
1134+ 51B0 ~            	CALL CHKCHAR
1135+ 51B0 ~            	DB ','
1136+ 51B0 ~            	; get delta value
1137+ 51B0 ~            	LD IX, FRMQNT
1138+ 51B0 ~            	CALL CALBAS
1139+ 51B0 ~            	LD IX,(BLIT_TMP)
1140+ 51B0 ~                LD (IX+8),E
1141+ 51B0 ~                LD (IX+9),D
1142+ 51B0 ~            	; comma
1143+ 51B0 ~            	CALL CHKCHAR
1144+ 51B0 ~            	DB ','
1145+ 51B0 ~            	; get direction value
1146+ 51B0 ~            	LD IX, FRMQNT
1147+ 51B0 ~            	CALL CALBAS
1148+ 51B0 ~            	LD IX,(BLIT_TMP)
1149+ 51B0 ~                LD (IX+10),E
1150+ 51B0 ~            	; comma
1151+ 51B0 ~            	CALL CHKCHAR
1152+ 51B0 ~            	DB ','
1153+ 51B0 ~            	; get ticks value
1154+ 51B0 ~            	LD IX, FRMQNT
1155+ 51B0 ~            	CALL CALBAS
1156+ 51B0 ~            	LD IX,(BLIT_TMP)
1157+ 51B0 ~                LD (IX+20),E
1158+ 51B0 ~                LD (IX+21),D
1159+ 51B0 ~            	; comma
1160+ 51B0 ~            	CALL CHKCHAR
1161+ 51B0 ~            	DB ','
1162+ 51B0 ~            	; get sprite group count
1163+ 51B0 ~            	LD IX, GETBYT
1164+ 51B0 ~            	CALL CALBAS
1165+ 51B0 ~                OR A
1166+ 51B0 ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
1167+ 51B0 ~            	LD IX,(BLIT_TMP)
1168+ 51B0 ~                LD (IX+11),A
1169+ 51B0 ~            	; comma
1170+ 51B0 ~            	CALL CHKCHAR
1171+ 51B0 ~            	DB ','
1172+ 51B0 ~            	; get sprite group definition array data pointer
1173+ 51B0 ~            	LD IX,(BLIT_TMP)
1174+ 51B0 ~                LD E,(IX+11)
1175+ 51B0 ~            	LD D,3
1176+ 51B0 ~            	LD A,2
1177+ 51B0 ~            	LD B,A
1178+ 51B0 ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
1179+ 51B0 ~            	LD IX,(BLIT_TMP)
1180+ 51B0 ~            	LD (IX+12),C
1181+ 51B0 ~                LD (IX+13),B
1182+ 51B0 ~            	; comma
1183+ 51B0 ~            	CALL CHKCHAR
1184+ 51B0 ~            	DB ','
1185+ 51B0 ~            	; get sprite animation array size
1186+ 51B0 ~            	LD IX,GETBYT
1187+ 51B0 ~            	CALL CALBAS
1188+ 51B0 ~            	LD IX,(BLIT_TMP)
1189+ 51B0 ~                LD (IX+14),A
1190+ 51B0 ~                OR A
1191+ 51B0 ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
1192+ 51B0 ~            	; comma
1193+ 51B0 ~            	CALL CHKCHAR
1194+ 51B0 ~            	DB ','
1195+ 51B0 ~                ; get array pointer for negative direction
1196+ 51B0 ~            	LD IX,(BLIT_TMP)
1197+ 51B0 ~                LD D,(IX+14)
1198+ 51B0 ~                LD A,2
1199+ 51B0 ~                LD B,1
1200+ 51B0 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
1201+ 51B0 ~            	LD IX,(BLIT_TMP)
1202+ 51B0 ~                LD (IX+15),C
1203+ 51B0 ~                LD (IX+16),B
1204+ 51B0 ~            	; comma
1205+ 51B0 ~            	CALL CHKCHAR
1206+ 51B0 ~            	DB ','
1207+ 51B0 ~                ; get array pointer for positive direction
1208+ 51B0 ~            	LD IX,(BLIT_TMP)
1209+ 51B0 ~                LD D,(IX+14)
1210+ 51B0 ~                LD A,2
1211+ 51B0 ~                LD B,1
1212+ 51B0 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
1213+ 51B0 ~            	LD IX,(BLIT_TMP)
1214+ 51B0 ~                LD (IX+17),C
1215+ 51B0 ~                LD (IX+18),B
1216+ 51B0 ~            	; ending )
1217+ 51B0 ~            	CALL CHKCHAR
1218+ 51B0 ~            	DB ')'
1219+ 51B0 ~                RET
1220+ 51B0 ~            ; *******************************************************************************************************
1221+ 51B0               ENDIF
1222+ 51B0
1223+ 51B0               IF (1 == 1)
1224+ 51B0              ; *******************************************************************************************************
1225+ 51B0              ; same as AUTOSGAMDEF but for DEFUSR approach
1226+ 51B0              ; input IX=pointer to input array, real data from +2
1227+ 51B0              ; +02 = ID
1228+ 51B0              ; +04 = pointer to X variable
1229+ 51B0              ; +06 = pointer to Y variable
1230+ 51B0              ; +08 = minimum
1231+ 51B0              ; +10 = maximum
1232+ 51B0              ; +12 = delta
1233+ 51B0              ; +14 = direction
1234+ 51B0              ; +16 = ticks
1235+ 51B0              ; +18 = sprite group count
1236+ 51B0              ; +20 = sprite group array pointer
1237+ 51B0              ; +22 = item number
1238+ 51B0              ; +24 = sprite animations negative direction array pointer
1239+ 51B0              ; +26 = sprite animations positive direction array pointer
1240+ 51B0              AUTOSGAMDEF_DEFUSR:
1241+ 51B0 DD 4E 02         LD C,(IX+2)
1242+ 51B3 0C               INC C
1243+ 51B4 3A F8 4E         LD A,(AUTOSGAMNUM)
1244+ 51B7 B9               CP C
1245+ 51B8 D8               RET C ; invalid id
1246+ 51B9 79               LD A,C
1247+ 51BA 3D               DEC A
1248+ 51BB CD 25 4F         CALL GETnthAUTOSGAM
1249+ 51BE E5               PUSH HL
1250+ 51BF FD E1            POP IY
1251+ 51C1                  ; X variable
1252+ 51C1 DD 7E 04         LD A,(IX+4)
1253+ 51C4 FD 77 00         LD (IY+0),A
1254+ 51C7 DD 7E 05         LD A,(IX+5)
1255+ 51CA FD 77 01         LD (IY+1),A
1256+ 51CD              	; Y variable
1257+ 51CD DD 7E 06         LD A,(IX+6)
1258+ 51D0 FD 77 02         LD (IY+2),A
1259+ 51D3 DD 7E 07         LD A,(IX+7)
1260+ 51D6 FD 77 03         LD (IY+3),A
1261+ 51D9              	; get minimum value
1262+ 51D9 DD 7E 08         LD A,(IX+8)
1263+ 51DC FD 77 04         LD (IY+4),A
1264+ 51DF DD 7E 09         LD A,(IX+9)
1265+ 51E2 FD 77 05         LD (IY+5),A
1266+ 51E5              	; get maximum value
1267+ 51E5 DD 7E 0A         LD A,(IX+10)
1268+ 51E8 FD 77 06         LD (IY+6),A
1269+ 51EB DD 7E 0B         LD A,(IX+11)
1270+ 51EE FD 77 07         LD (IY+7),A
1271+ 51F1              	; get delta value
1272+ 51F1 DD 7E 0C         LD A,(IX+12)
1273+ 51F4 FD 77 08         LD (IY+8),A
1274+ 51F7 DD 7E 0D         LD A,(IX+13)
1275+ 51FA FD 77 09         LD (IY+9),A
1276+ 51FD              	; get direction value
1277+ 51FD DD 7E 0E         LD A,(IX+14)
1278+ 5200 FD 77 0A         LD (IY+10),A
1279+ 5203              	; get ticks value
1280+ 5203 DD 7E 10         LD A,(IX+16)
1281+ 5206 FD 77 14         LD (IY+20),A
1282+ 5209 DD 7E 11         LD A,(IX+17)
1283+ 520C FD 77 15         LD (IY+21),A
1284+ 520F              	; get sprite group count
1285+ 520F DD 7E 12         LD A,(IX+18)
1286+ 5212 FD 77 0B         LD (IY+11),A
1287+ 5215              	; get sprite group definition array data pointer
1288+ 5215 DD 7E 14         LD A,(IX+20)
1289+ 5218 FD 77 0C         LD (IY+12),A
1290+ 521B DD 7E 15         LD A,(IX+21)
1291+ 521E FD 77 0D         LD (IY+13),A
1292+ 5221              	; get sprite animation array size
1293+ 5221 DD 7E 16         LD A,(IX+22)
1294+ 5224 FD 77 0E         LD (IY+14),A
1295+ 5227                  ; get array pointer for negative direction
1296+ 5227 DD 7E 18         LD A,(IX+24)
1297+ 522A FD 77 0F         LD (IY+15),A
1298+ 522D DD 7E 19         LD A,(IX+25)
1299+ 5230 FD 77 10         LD (IY+16),A
1300+ 5233                  ; get array pointer for positive direction
1301+ 5233 DD 7E 1A         LD A,(IX+26)
1302+ 5236 FD 77 11         LD (IY+17),A
1303+ 5239 DD 7E 1B         LD A,(IX+27)
1304+ 523C FD 77 12         LD (IY+18),A
1305+ 523F C9               RET
1306+ 5240              ; *******************************************************************************************************
1307+ 5240               ENDIF
1308+ 5240
1309+ 5240               IF (0 == 1)
1310+ 5240 ~            ; *******************************************************************************************************
1311+ 5240 ~            ; function to handle CALL AUTOSGAMSTART basic extension
1312+ 5240 ~            ; AUTOSGAMSTART ( BYTE id )
1313+ 5240 ~            AUTOSGAMSTART:
1314+ 5240 ~                LD A,1
1315+ 5240 ~            .COMMON:
1316+ 5240 ~                LD (.SETVALUE+3),A
1317+ 5240 ~                ; opening (
1318+ 5240 ~            	CALL CHKCHAR
1319+ 5240 ~            	DB '('
1320+ 5240 ~            	; get sprite animation id
1321+ 5240 ~            	LD IX, GETBYT
1322+ 5240 ~            	CALL CALBAS
1323+ 5240 ~                PUSH AF
1324+ 5240 ~                INC A
1325+ 5240 ~                LD C,A
1326+ 5240 ~                LD A,(AUTOSGAMNUM)
1327+ 5240 ~                CP C
1328+ 5240 ~                JP C,SUBSCRIPT_OUT_OF_RANGE
1329+ 5240 ~                POP AF
1330+ 5240 ~                PUSH HL
1331+ 5240 ~                CALL GETnthAUTOSGAM
1332+ 5240 ~                PUSH HL
1333+ 5240 ~                POP IX
1334+ 5240 ~                POP HL
1335+ 5240 ~                PUSH IX
1336+ 5240 ~            	; ending )
1337+ 5240 ~            	CALL CHKCHAR
1338+ 5240 ~            	DB ')'
1339+ 5240 ~
1340+ 5240 ~                ; so syntax is fine
1341+ 5240 ~                POP IX
1342+ 5240 ~            .SETVALUE:
1343+ 5240 ~                LD (IX+19),1 ; active flag
1344+ 5240 ~                ; set initial timer
1345+ 5240 ~                LD A,(IX+20)
1346+ 5240 ~                LD (IX+22),A
1347+ 5240 ~                LD A,(IX+21)
1348+ 5240 ~                LD (IX+23),A
1349+ 5240 ~                RET
1350+ 5240 ~            ; *******************************************************************************************************
1351+ 5240 ~
1352+ 5240 ~            ; *******************************************************************************************************
1353+ 5240 ~            ; function to handle CALL AUTOSGAMSTOP basic extension
1354+ 5240 ~            ; AUTOSGAMSTOP ( BYTE id )
1355+ 5240 ~            AUTOSGAMSTOP:
1356+ 5240 ~                XOR A
1357+ 5240 ~                JR AUTOSGAMSTART.COMMON
1358+ 5240 ~            ; *******************************************************************************************************
1359+ 5240               ENDIF
1360+ 5240
1361+ 5240               IF (1 == 1)
1362+ 5240              ; *******************************************************************************************************
1363+ 5240              ; function to handle CALL AUTOSGAMSTART basic extension in DEFUSR mode
1364+ 5240              ; input IX=pointer to input array, real data from +2
1365+ 5240              ; +2 = source address
1366+ 5240              AUTOSGAMSTART_DEFUSR:
1367+ 5240 3E 01            LD A,1
1368+ 5242              .COMMON:
1369+ 5242 32 59 52         LD (.SETVALUE+3),A
1370+ 5245 DD 4E 02         LD C,(IX+2)
1371+ 5248 0C               INC C
1372+ 5249 3A F8 4E         LD A,(AUTOSGAMNUM)
1373+ 524C B9               CP C
1374+ 524D D8               RET C ; invalid id
1375+ 524E 79               LD A,C
1376+ 524F 3D               DEC A
1377+ 5250 CD 25 4F         CALL GETnthAUTOSGAM
1378+ 5253 E5               PUSH HL
1379+ 5254 DD E1            POP IX
1380+ 5256              .SETVALUE:
1381+ 5256 DD 36 13 01      LD (IX+19),1 ; active flag
1382+ 525A                  ; set initial timer
1383+ 525A DD 7E 14         LD A,(IX+20)
1384+ 525D DD 77 16         LD (IX+22),A
1385+ 5260 DD 7E 15         LD A,(IX+21)
1386+ 5263 DD 77 17         LD (IX+23),A
1387+ 5266 C9               RET
1388+ 5267              ; *******************************************************************************************************
1389+ 5267
1390+ 5267              ; *******************************************************************************************************
1391+ 5267              ; function to handle CALL AUTOSGAMSTOP basic extension in DEFUSR mode
1392+ 5267              ; input IX=pointer to input array, real data from +2
1393+ 5267              ; +2 = source address
1394+ 5267              AUTOSGAMSTOP_DEFUSR:
1395+ 5267 AF               XOR A
1396+ 5268 18 D8            JR AUTOSGAMSTART_DEFUSR.COMMON
1397+ 526A              ; *******************************************************************************************************
1398+ 526A               ENDIF
1399+ 526A
1400+ 526A               IF (0 == 1)
1401+ 526A ~            ; *******************************************************************************************************
1402+ 526A ~            ; function to handle CALL ANIMSTEP basic extension
1403+ 526A ~            ; two forms
1404+ 526A ~            ; ANIMSTEP ( BYTE id )
1405+ 526A ~            ; or
1406+ 526A ~            ; ANIMSTEP ( BYTE item_number,
1407+ 526A ~            ;            INT[] sprite_animations )
1408+ 526A ~            ANIMSTEP:
1409+ 526A ~                LD DE,ANIMSTARTSTOP_COMMON.STEP
1410+ 526A ~                JR ANIMSTARTSTOP_COMMON
1411+ 526A ~            ; *******************************************************************************************************
1412+ 526A ~            ; *******************************************************************************************************
1413+ 526A ~            ; function to handle CALL ANIMSTART basic extension
1414+ 526A ~            ; two forms
1415+ 526A ~            ; ANIMSTART ( BYTE id )
1416+ 526A ~            ; or
1417+ 526A ~            ; ANIMSTART ( BYTE item_number,
1418+ 526A ~            ;             INT[] sprite_animations )
1419+ 526A ~            ; sets active flag to 1
1420+ 526A ~            ANIMSTART:
1421+ 526A ~                LD DE,ANIMSTARTSTOP_COMMON.START
1422+ 526A ~                JR ANIMSTARTSTOP_COMMON
1423+ 526A ~            ; *******************************************************************************************************
1424+ 526A ~            ; *******************************************************************************************************
1425+ 526A ~            ; function to handle CALL ANIMSTOP basic extension
1426+ 526A ~            ; two forms
1427+ 526A ~            ; ANIMSTOP ( BYTE id )
1428+ 526A ~            ; or
1429+ 526A ~            ; ANIMSTOP ( BYTE item_number,
1430+ 526A ~            ;            INT[] sprite_animations )
1431+ 526A ~            ; sets active flag to 0
1432+ 526A ~            ANIMSTOP:
1433+ 526A ~                LD DE,ANIMSTARTSTOP_COMMON.STOP
1434+ 526A ~            ; *******************************************************************************************************
1435+ 526A ~            ANIMSTARTSTOP_COMMON:
1436+ 526A ~                LD (ANIMSTARTSTOP_COMMON.FN+1),DE
1437+ 526A ~                ; opening (
1438+ 526A ~            	CALL CHKCHAR
1439+ 526A ~            	DB '('
1440+ 526A ~            	; get sprite animation id or array size
1441+ 526A ~            	LD IX,GETBYT
1442+ 526A ~            	CALL CALBAS
1443+ 526A ~                PUSH AF
1444+ 526A ~                ; check if comma present
1445+ 526A ~                CALL GETPREVCHAR
1446+ 526A ~                INC HL
1447+ 526A ~                CP ','
1448+ 526A ~                JR Z,.L1
1449+ 526A ~                CP ')'
1450+ 526A ~                JP NZ,SYNTAX_ERROR
1451+ 526A ~                ; ok so single argument variant
1452+ 526A ~                POP AF
1453+ 526A ~                PUSH HL
1454+ 526A ~                DI
1455+ 526A ~                CALL .SETVALUE
1456+ 526A ~                EI
1457+ 526A ~                POP HL
1458+ 526A ~                RET
1459+ 526A ~            .L1:
1460+ 526A ~                ; get array pointer
1461+ 526A ~                POP DE
1462+ 526A ~                PUSH DE
1463+ 526A ~                LD A,2
1464+ 526A ~                LD B,1
1465+ 526A ~                CALL GET_BASIC_ARRAY_DATA_POINTER
1466+ 526A ~                PUSH BC
1467+ 526A ~            	; ending )
1468+ 526A ~            	CALL CHKCHAR
1469+ 526A ~            	DB ')'
1470+ 526A ~                POP DE ; array pointer
1471+ 526A ~                POP BC ; number of items
1472+ 526A ~                LD A,B
1473+ 526A ~                OR A
1474+ 526A ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
1475+ 526A ~                PUSH HL
1476+ 526A ~                DI
1477+ 526A ~            .L2:
1478+ 526A ~                PUSH BC
1479+ 526A ~                LD A,(DE)
1480+ 526A ~                .2 INC DE
1481+ 526A ~                PUSH DE
1482+ 526A ~                CALL .SETVALUE
1483+ 526A ~                POP DE
1484+ 526A ~                POP BC
1485+ 526A ~                DJNZ .L2
1486+ 526A ~                EI
1487+ 526A ~                POP HL
1488+ 526A ~                RET
1489+ 526A ~
1490+ 526A ~            .SETVALUE:
1491+ 526A ~                LD B,A
1492+ 526A ~                INC A
1493+ 526A ~                LD C,A
1494+ 526A ~                LD A,(ANIMSPRNUM)
1495+ 526A ~                CP C
1496+ 526A ~                JP C,SUBSCRIPT_OUT_OF_RANGE
1497+ 526A ~                LD A,B
1498+ 526A ~                CALL GETnthSPRANIM
1499+ 526A ~                PUSH HL
1500+ 526A ~                POP IX
1501+ 526A ~            .FN:
1502+ 526A ~                JP 0
1503+ 526A ~            .START:
1504+ 526A ~                LD (IX+6),1 ; active flag
1505+ 526A ~                LD (IX+3),0 ; current item
1506+ 526A ~                LD B,0 ; setup timer
1507+ 526A ~                JP SETUP_ANIM_STEP
1508+ 526A ~            .STOP:
1509+ 526A ~                LD (IX+6),0 ; active flag
1510+ 526A ~                RET
1511+ 526A ~            .STEP:
1512+ 526A ~                LD B,0
1513+ 526A ~                JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1514+ 526A ~            ; *******************************************************************************************************
1515+ 526A               ENDIF
1516+ 526A
1517+ 526A              ; *******************************************************************************************************
1518+ 526A              ; helper function to locate single animation and execute operation
1519+ 526A              ; needs to have jump set to a correct function
1520+ 526A              ; used by SGAM helper routines so always needed
1521+ 526A              ; input A=animation item
1522+ 526A              ANIM_SETVALUE:
1523+ 526A 47               LD B,A
1524+ 526B 3C               INC A
1525+ 526C 4F               LD C,A
1526+ 526D 3A F5 4E         LD A,(ANIMSPRNUM)
1527+ 5270 B9               CP C
1528+ 5271 D8               RET C ; out of range, so do nothing
1529+ 5272 78               LD A,B
1530+ 5273 CD 19 4F         CALL GETnthSPRANIM
1531+ 5276 E5               PUSH HL
1532+ 5277 DD E1            POP IX
1533+ 5279              .FN:
1534+ 5279 C3 00 00         JP 0
1535+ 527C              ; *******************************************************************************************************
1536+ 527C
1537+ 527C               IF (1 == 1)
1538+ 527C              ; *******************************************************************************************************
1539+ 527C              ; helper function to set values of multiple animations
1540+ 527C              ; needs to have jump set to a correct function
1541+ 527C              ; input B=number of animation item
1542+ 527C              ; input DE=animation item array
1543+ 527C              ANIM_LIST_SETVALUE:
1544+ 527C F3               DI
1545+ 527D C5               PUSH BC
1546+ 527E 1A               LD A,(DE)
1547+ 527F 13          > INC DE
1547+ 5280 13          > INC DE
1548+ 5281 D5               PUSH DE
1549+ 5282 CD 6A 52         CALL ANIM_SETVALUE
1550+ 5285 D1               POP DE
1551+ 5286 C1               POP BC
1552+ 5287 10 F3            DJNZ ANIM_LIST_SETVALUE
1553+ 5289 FB               EI
1554+ 528A C9               RET
1555+ 528B              ; *******************************************************************************************************
1556+ 528B
1557+ 528B              ; *******************************************************************************************************
1558+ 528B              ; function to handle single item ANIMSTEP in DEFUSR mode
1559+ 528B              ; input IX=pointer to input array, real data from +2
1560+ 528B              ; +2 = animation id
1561+ 528B              ANIMSTEP_SINGLE_DEFUSR:
1562+ 528B 21 96 52         LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1563+ 528E              .L1:
1564+ 528E 22 7A 52         LD (ANIM_SETVALUE.FN+1),HL
1565+ 5291 DD 7E 02         LD A,(IX+2)
1566+ 5294 18 D4            JR ANIM_SETVALUE
1567+ 5296              .STEP:
1568+ 5296 06 00            LD B,0
1569+ 5298 C3 F0 52         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1570+ 529B              ; *******************************************************************************************************
1571+ 529B
1572+ 529B              ; *******************************************************************************************************
1573+ 529B              ; function to handle multi item ANIMSTEP in DEFUSR mode
1574+ 529B              ; input IX=pointer to input array, real data from +2
1575+ 529B              ; +2 = list size
1576+ 529B              ; +4 = array pointer holding items
1577+ 529B              ANIMSTEP_MULTI_DEFUSR:
1578+ 529B 21 96 52         LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1579+ 529E              .L1:
1580+ 529E 22 7A 52         LD (ANIM_SETVALUE.FN+1),HL
1581+ 52A1 DD 46 02         LD B,(IX+2)
1582+ 52A4 DD 5E 04         LD E,(IX+4)
1583+ 52A7 DD 56 05         LD D,(IX+5)
1584+ 52AA 18 D0            JR ANIM_LIST_SETVALUE
1585+ 52AC              ; *******************************************************************************************************
1586+ 52AC
1587+ 52AC              ; *******************************************************************************************************
1588+ 52AC              ; function to handle single item ANIMSTART in DEFUSR mode
1589+ 52AC              ; input IX=pointer to input array, real data from +2
1590+ 52AC              ; +2 = animation id
1591+ 52AC              ANIMSTART_SINGLE_DEFUSR:
1592+ 52AC 21 B1 52         LD HL,ANIMSTART_SINGLE_DEFUSR.START
1593+ 52AF 18 DD            JR ANIMSTEP_SINGLE_DEFUSR.L1
1594+ 52B1              .START:
1595+ 52B1 DD 36 06 01      LD (IX+6),1 ; active flag
1596+ 52B5 DD 36 03 00      LD (IX+3),0 ; current item
1597+ 52B9 06 00            LD B,0 ; setup timer
1598+ 52BB C3 4C 53         JP SETUP_ANIM_STEP
1599+ 52BE              ; *******************************************************************************************************
1600+ 52BE
1601+ 52BE              ; *******************************************************************************************************
1602+ 52BE              ; function to handle multi item ANIMSTART in DEFUSR mode
1603+ 52BE              ; input IX=pointer to input array, real data from +2
1604+ 52BE              ; +2 = list size
1605+ 52BE              ; +4 = array pointer holding items
1606+ 52BE              ANIMSTART_MULTI_DEFUSR:
1607+ 52BE 21 B1 52         LD HL,ANIMSTART_SINGLE_DEFUSR.START
1608+ 52C1 18 DB            JR ANIMSTEP_MULTI_DEFUSR.L1
1609+ 52C3              ; *******************************************************************************************************
1610+ 52C3
1611+ 52C3              ; *******************************************************************************************************
1612+ 52C3              ; function to handle single item ANIMSTOP in DEFUSR mode
1613+ 52C3              ; input IX=pointer to input array, real data from +2
1614+ 52C3              ; +2 = animation id
1615+ 52C3              ANIMSTOP_SINGLE_DEFUSR:
1616+ 52C3 21 C8 52         LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1617+ 52C6 18 C6            JR ANIMSTEP_SINGLE_DEFUSR.L1
1618+ 52C8              .STOP:
1619+ 52C8 DD 36 06 00      LD (IX+6),0 ; active flag
1620+ 52CC C9               RET
1621+ 52CD              ; *******************************************************************************************************
1622+ 52CD
1623+ 52CD              ; *******************************************************************************************************
1624+ 52CD              ; function to handle multi item ANIMSTOP in DEFUSR mode
1625+ 52CD              ; input IX=pointer to input array, real data from +2
1626+ 52CD              ; +2 = list size
1627+ 52CD              ; +4 = array pointer holding items
1628+ 52CD              ANIMSTOP_MULTI_DEFUSR:
1629+ 52CD 21 C8 52         LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1630+ 52D0 18 CC            JR ANIMSTEP_MULTI_DEFUSR.L1
1631+ 52D2              ; *******************************************************************************************************
1632+ 52D2               ENDIF
1633+ 52D2
1634+ 52D2              ; *******************************************************************************************************
1635+ 52D2              ; function processes animations during vblank period
1636+ 52D2              PROCESS_ANIMATIONS:
1637+ 52D2 3A F5 4E         LD A,(ANIMSPRNUM)
1638+ 52D5 B7               OR A
1639+ 52D6 C8               RET Z; no animations defined
1640+ 52D7 47               LD B,A
1641+ 52D8 DD 2A F6 4E      LD IX,(ANIMSPRPTR)
1642+ 52DC              .L1:
1643+ 52DC C5               PUSH BC
1644+ 52DD 06 00            LD B,0 ; normal mode, change on timer expiry only
1645+ 52DF CD EB 52         CALL PROCESS_SINGLE_ANIMATION
1646+ 52E2 11 08 00         LD DE,8
1647+ 52E5 DD 19            ADD IX,DE
1648+ 52E7 C1               POP BC
1649+ 52E8 10 F2            DJNZ .L1
1650+ 52EA C9               RET
1651+ 52EB              ; *******************************************************************************************************
1652+ 52EB
1653+ 52EB              ; *******************************************************************************************************
1654+ 52EB              ; processes single sprite animation
1655+ 52EB              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
1656+ 52EB              ; on timer expiry goes to next animation item
1657+ 52EB              ; input IX=sprite animation pointer
1658+ 52EB              ; input B=1 force mode, activate animation action regardless of expired timer
1659+ 52EB              PROCESS_SINGLE_ANIMATION:
1660+ 52EB DD 7E 06         LD A,(IX+6); active
1661+ 52EE B7               OR A
1662+ 52EF C8               RET Z ; inactive animation
1663+ 52F0              .INACTIVE_TOO:
1664+ 52F0 DD 6E 01         LD L,(IX+1)
1665+ 52F3 DD 66 02         LD H,(IX+2) ; HL=end time
1666+ 52F6 2B               DEC HL
1667+ 52F7 DD 75 01         LD (IX+1),L
1668+ 52FA DD 74 02         LD (IX+2),H
1669+ 52FD 7D               LD A,L
1670+ 52FE B4               OR H
1671+ 52FF 28 06            JR Z,.STEP
1672+ 5301 05               DEC B
1673+ 5302 04               INC B
1674+ 5303 C8               RET Z ; not forced mode, return
1675+ 5304 C3 4C 53         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
1676+ 5307              .STEP:
1677+ 5307 06 00            LD B,0; setup timer
1678+ 5309 DD 34 03         INC (IX+3) ; current animation item
1679+ 530C C3 4C 53         JP SETUP_ANIM_STEP
1680+ 530F              ; *******************************************************************************************************
1681+ 530F
1682+ 530F              ; *******************************************************************************************************
1683+ 530F              ; function will setup sprite animation after current item change
1684+ 530F              ; input A=current animation definition
1685+ 530F              ; input IX=pointer to sprite animation
1686+ 530F              ; input B=1 skip timer setup
1687+ 530F              ; output IY=pointer to animation item
1688+ 530F              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
1689+ 530F              ; basically sets new end time for current animation
1690+ 530F              INIT_CURRENT_ANIMATION:
1691+ 530F CD 0D 4F         CALL GETnthANIMDEF
1692+ 5312 DD 7E 03         LD A,(IX+3) ; current animation item
1693+ 5315 BE               CP (HL) ; number of animation items in the animation definition
1694+ 5316 38 0A            JR C,.L3 ; last item not reached
1695+ 5318                  ; last item reached
1696+ 5318 DD 7E 05         LD A,(IX+5) ; cyclic flag
1697+ 531B B7               OR A
1698+ 531C 28 2C            JR Z,.ERROR ; non-cyclic animation
1699+ 531E                  ; cyclic animation, restart
1700+ 531E DD 36 03 00      LD (IX+3),0; current item
1701+ 5322              .L3:
1702+ 5322                  ; HL = animation definition
1703+ 5322 23               INC HL ; skip animation definition size field
1704+ 5323 16 00            LD D,0
1705+ 5325 DD 5E 03         LD E,(IX+3); current item
1706+ 5328 19               ADD HL,DE
1707+ 5329 4E               LD C,(HL) ; current animation item
1708+ 532A 0C               INC C
1709+ 532B 3A EF 4E         LD A,(ANIMITEMNUM)
1710+ 532E B9               CP C
1711+ 532F 38 19            JR C,.ERROR ; invalid animation item, stop animation
1712+ 5331 0D               DEC C
1713+ 5332 79               LD A,C
1714+ 5333 CD 04 4F         CALL GETnthANIMITEM
1715+ 5336 E5               PUSH HL
1716+ 5337 FD E1            POP IY ; IY=animation item
1717+ 5339 05               DEC B
1718+ 533A 28 0C            JR Z,.EXIT
1719+ 533C FD 5E 01         LD E,(IY+1)
1720+ 533F FD 56 02         LD D,(IY+2) ; duration
1721+ 5342 DD 73 01         LD (IX+1),E
1722+ 5345 DD 72 02         LD (IX+2),D
1723+ 5348              .EXIT:
1724+ 5348 AF               XOR A
1725+ 5349 C9               RET
1726+ 534A              .ERROR:
1727+ 534A 37               SCF
1728+ 534B C9               RET
1729+ 534C              ; *******************************************************************************************************
1730+ 534C
1731+ 534C              ; *******************************************************************************************************
1732+ 534C              ; function will display currect item and set up expiry time
1733+ 534C              ; it will also stop the animation if expired
1734+ 534C              ; sets sprite update flag if any changes in sprite data made
1735+ 534C              ; input IX=current sprite animation
1736+ 534C              ; input B=1 skip timer setup
1737+ 534C              SETUP_ANIM_STEP:
1738+ 534C DD 4E 04         LD C,(IX+4) ; animation definition ID
1739+ 534F 0C               INC C
1740+ 5350 3A F2 4E         LD A,(ANIMDEFNUM)
1741+ 5353 B9               CP C
1742+ 5354 30 05            JR NC,.L2
1743+ 5356                  ; given animation item is outside of bounds, deactivate animation
1744+ 5356              .STOPANIM:
1745+ 5356 DD 36 06 00      LD (IX+6),0
1746+ 535A C9               RET
1747+ 535B              .L2:
1748+ 535B 0D               DEC C
1749+ 535C 79               LD A,C
1750+ 535D CD 0F 53         CALL INIT_CURRENT_ANIMATION
1751+ 5360 38 F4            JR C, .STOPANIM
1752+ 5362 FD 7E 00         LD A,(IY) ; type of animation item
1753+ 5365 B7               OR A
1754+ 5366 28 44            JR Z,.L4 ; change pattern and/or color
1755+ 5368              .PAT:
1756+ 5368                  ; change pattern definition
1757+ 5368                  ; check if sprite or character
1758+ 5368 DD 7E 07         LD A,(IX+7)
1759+ 536B B7               OR A
1760+ 536C 20 58            JR NZ,.CHAR
1761+ 536E DD 7E 00         LD A,(IX) ; sprite number
1762+ 5371 CD 89 4D         CALL GETnthSPRATTR
1763+ 5374 23          > INC HL ; skip y and x
1763+ 5375 23          > INC HL
1763+ 5376 23          > INC HL
1763+ 5377 23          > INC HL
1764+ 5378 7E               LD A,(HL); current pattern
1765+ 5379 26 00            LD H,0
1766+ 537B 6F               LD L,A
1767+ 537C 3A E0 F3         LD A,(REG1SAV)
1768+ 537F E6 02            AND 2
1769+ 5381 20 07            JR NZ,.L6
1770+ 5383                  ; 8x8 sprite
1771+ 5383 CD 07 5E         CALL HLx8
1772+ 5386 06 08            LD B,8
1773+ 5388 18 05            JR .L5
1774+ 538A              .L6:
1775+ 538A CD 05 5E         CALL HLx32
1776+ 538D 06 20            LD B,32
1777+ 538F              .L5:
1778+ 538F 3A AF FC         LD A,(SCRMOD)
1779+ 5392 3D               DEC A
1780+ 5393 20 06            JR NZ,.L10
1781+ 5395 ED 5B C5 F3      LD DE,(T32PAT)
1782+ 5399 18 04            JR .L7
1783+ 539B              .L10:
1784+ 539B ED 5B CF F3      LD DE,(GRPPAT)
1785+ 539F              .L7:
1786+ 539F 19               ADD HL,DE
1787+ 53A0 CD F2 5D         CALL SETWRT_LOCAL
1788+ 53A3 FD 6E 03         LD L,(IY+3)
1789+ 53A6 FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
1790+ 53A9 C3 FD 5D         JP BBYTECOPY
1791+ 53AC              .L4:
1792+ 53AC                  ; change pattern and color in sprite attributes table
1793+ 53AC DD 7E 00         LD A,(IX) ; sprite number
1794+ 53AF CD 89 4D         CALL GETnthSPRATTR
1795+ 53B2 23          > INC HL ; skip y and x
1795+ 53B3 23          > INC HL
1795+ 53B4 23          > INC HL
1795+ 53B5 23          > INC HL
1796+ 53B6 FD 7E 03         LD A,(IY+3) ; new pattern
1797+ 53B9 77               LD (HL),A
1798+ 53BA 23          > INC HL
1798+ 53BB 23          > INC HL
1799+ 53BC FD 7E 04         LD A,(IY+4) ; new color
1800+ 53BF 77               LD (HL),A
1801+ 53C0 2A 80 4D         LD HL,(SPRATR_UPDATE_FLAG)
1802+ 53C3 36 01            LD (HL),1
1803+ 53C5 C9               RET
1804+ 53C6              .CHAR:
1805+ 53C6 DD 6E 00         LD L,(IX)
1806+ 53C9 3D               DEC A
1807+ 53CA 67               LD H,A
1808+ 53CB CD 07 5E         CALL HLx8
1809+ 53CE 3A AF FC         LD A,(SCRMOD)
1810+ 53D1 3D               DEC A
1811+ 53D2 20 06            JR NZ,.L8
1812+ 53D4 ED 5B C1 F3      LD DE,(T32CGP)
1813+ 53D8 18 04            JR .L9
1814+ 53DA              .L8:
1815+ 53DA ED 5B CB F3      LD DE,(GRPCGP)
1816+ 53DE              .L9:
1817+ 53DE 06 08            LD B,8
1818+ 53E0 18 BD            JR .L7
1819+ 53E2              ; *******************************************************************************************************
1820+ 53E2
# file closed: asm\ANIMATION.asm
 134  53E2               INCLUDE "SGAM.asm"
# file opened: asm\SGAM.asm
   1+ 53E2              ; Sprite Group Animate and Move
   2+ 53E2
   3+ 53E2              ; *******************************************************************************************************
   4+ 53E2              ; shared function to process a list of animations
   5+ 53E2              ; input B=list size
   6+ 53E2              ; input DE=list pointer
   7+ 53E2              SGAM_PROCESS_ANIM_LIST:
   8+ 53E2 21 F5 53         LD HL,.STEP
   9+ 53E5 22 7A 52         LD (ANIM_SETVALUE.FN+1),HL
  10+ 53E8              .L1:
  11+ 53E8 C5               PUSH BC
  12+ 53E9 1A               LD A,(DE)
  13+ 53EA 13          > INC DE
  13+ 53EB 13          > INC DE
  14+ 53EC D5               PUSH DE
  15+ 53ED CD 6A 52         CALL ANIM_SETVALUE
  16+ 53F0 D1               POP DE
  17+ 53F1 C1               POP BC
  18+ 53F2 10 F4            DJNZ .L1
  19+ 53F4 C9           	RET
  20+ 53F5              .STEP:
  21+ 53F5 06 01            LD B,1
  22+ 53F7 C3 F0 52         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
  23+ 53FA              ; *******************************************************************************************************
  24+ 53FA
  25+ 53FA               IF (0 == 1)
  26+ 53FA ~            ; *******************************************************************************************************
  27+ 53FA ~            ; function to handle CALL SGAM basic extension
  28+ 53FA ~            ; sets position of a group of sprites as described in SPRGRPMOV
  29+ 53FA ~            ; and manually animate a list of animations
  30+ 53FA ~            ; _SGAM ( INT x,
  31+ 53FA ~            ;	      INT y,
  32+ 53FA ~            ;		  BYTE count,
  33+ 53FA ~            ;		  INT[2][count] data_ptr,
  34+ 53FA ~            ;         BYTE item_number,
  35+ 53FA ~            ;         INT[] sprite_animations )
  36+ 53FA ~            ; will put ram in page 0 also, page 1 is already there
  37+ 53FA ~            SGAM:
  38+ 53FA ~            	LD A, (SPRATR_INIT_STATUS)
  39+ 53FA ~            	OR A
  40+ 53FA ~            	JP Z,ILLEGAL_FUNCTION
  41+ 53FA ~            	; opening (
  42+ 53FA ~            	CALL CHKCHAR
  43+ 53FA ~            	DB '('
  44+ 53FA ~            	; get x
  45+ 53FA ~            	LD IX, FRMQNT
  46+ 53FA ~            	CALL CALBAS
  47+ 53FA ~            	LD (BLIT_STRUCT),DE
  48+ 53FA ~            	; comma
  49+ 53FA ~            	CALL CHKCHAR
  50+ 53FA ~            	DB ','
  51+ 53FA ~            	; get y
  52+ 53FA ~            	LD IX, FRMQNT
  53+ 53FA ~            	CALL CALBAS
  54+ 53FA ~            	LD (BLIT_STRUCT+2),DE
  55+ 53FA ~            	; comma
  56+ 53FA ~            	CALL CHKCHAR
  57+ 53FA ~            	DB ','
  58+ 53FA ~            	; get count
  59+ 53FA ~            	LD IX, GETBYT
  60+ 53FA ~            	CALL CALBAS
  61+ 53FA ~                OR A
  62+ 53FA ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
  63+ 53FA ~            	LD (BLIT_STRUCT+4),A
  64+ 53FA ~            	; comma
  65+ 53FA ~            	CALL CHKCHAR
  66+ 53FA ~            	DB ','
  67+ 53FA ~            	; get sprite group definition array data pointer
  68+ 53FA ~                LD A,(BLIT_STRUCT+4)
  69+ 53FA ~            	LD E,A
  70+ 53FA ~            	LD D,3
  71+ 53FA ~            	LD A,2
  72+ 53FA ~            	LD B,A
  73+ 53FA ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
  74+ 53FA ~            	LD (BLIT_STRUCT+5),BC
  75+ 53FA ~            	; comma
  76+ 53FA ~            	CALL CHKCHAR
  77+ 53FA ~            	DB ','
  78+ 53FA ~            	; get sprite animation array size
  79+ 53FA ~            	LD IX,GETBYT
  80+ 53FA ~            	CALL CALBAS
  81+ 53FA ~                LD (BLIT_STRUCT+7),A
  82+ 53FA ~                OR A
  83+ 53FA ~                JP Z,SUBSCRIPT_OUT_OF_RANGE
  84+ 53FA ~            	; comma
  85+ 53FA ~            	CALL CHKCHAR
  86+ 53FA ~            	DB ','
  87+ 53FA ~                ; get array pointer
  88+ 53FA ~                LD A,(BLIT_STRUCT+7)
  89+ 53FA ~                LD D,A
  90+ 53FA ~                LD A,2
  91+ 53FA ~                LD B,1
  92+ 53FA ~                CALL GET_BASIC_ARRAY_DATA_POINTER
  93+ 53FA ~                LD (BLIT_STRUCT+8),BC
  94+ 53FA ~            	; ending )
  95+ 53FA ~            	CALL CHKCHAR
  96+ 53FA ~            	DB ')'
  97+ 53FA ~            .ENTRY:
  98+ 53FA ~                PUSH HL
  99+ 53FA ~
 100+ 53FA ~            	; enable page 0
 101+ 53FA ~            	LD IY, .RET
 102+ 53FA ~            	JP ENABLE_PAGE0
 103+ 53FA ~            .RET:
 104+ 53FA ~                EXX
 105+ 53FA ~                LD DE,(BLIT_STRUCT) ; initial x
 106+ 53FA ~                LD BC,(BLIT_STRUCT+2) ; initial y
 107+ 53FA ~                EXX
 108+ 53FA ~                LD HL,(BLIT_STRUCT+5) ; pointer to data
 109+ 53FA ~                LD A,(BLIT_STRUCT+4) ; number of entries
 110+ 53FA ~                LD B,A
 111+ 53FA ~                CALL SPR_UPDATE_LOC
 112+ 53FA ~
 113+ 53FA ~                LD A,(BLIT_STRUCT+7) ; anim number
 114+ 53FA ~                LD B,A
 115+ 53FA ~                LD DE,(BLIT_STRUCT+8) ; anim list
 116+ 53FA ~            	CALL SGAM_PROCESS_ANIM_LIST
 117+ 53FA ~
 118+ 53FA ~                POP DE
 119+ 53FA ~                POP BC
 120+ 53FA ~                CALL RESTORE_PAGE_INFO
 121+ 53FA ~                EI
 122+ 53FA ~                POP HL
 123+ 53FA ~                RET
 124+ 53FA ~            ; *******************************************************************************************************
 125+ 53FA               ENDIF
 126+ 53FA
 127+ 53FA               IF (1 == 1)
 128+ 53FA              ; *******************************************************************************************************
 129+ 53FA              ; same as SGAM but for DEFUSR approach
 130+ 53FA              ; input IX=pointer to input array, real data from +2
 131+ 53FA              ; +02 = X
 132+ 53FA              ; +04 = Y
 133+ 53FA              ; +06 = count
 134+ 53FA              ; +08 = data pointer
 135+ 53FA              ; +10 = anim number
 136+ 53FA              ; +12 = sprite animations
 137+ 53FA              SGAM_DEFUSR:
 138+ 53FA              	; enable page 0
 139+ 53FA FD 21 01 54  	LD IY, .RET
 140+ 53FE C3 CB 5E     	JP ENABLE_PAGE0
 141+ 5401              .RET:
 142+ 5401 FB           	EI
 143+ 5402 D9               EXX
 144+ 5403 DD 5E 02     	LD E,(IX+2)
 145+ 5406 DD 56 03     	LD D,(IX+3) ; initial x
 146+ 5409 DD 4E 04     	LD C,(IX+4)
 147+ 540C DD 46 05     	LD B,(IX+5) ; initial y
 148+ 540F D9               EXX
 149+ 5410 DD 6E 08     	LD L,(IX+8)
 150+ 5413 DD 66 09     	LD H,(IX+9) ; pointer to data
 151+ 5416 DD 46 06         LD B,(IX+6) ; count
 152+ 5419 DD E5        	PUSH IX
 153+ 541B CD BA 4E         CALL SPR_UPDATE_LOC
 154+ 541E DD E1        	POP IX
 155+ 5420 DD 46 0A         LD B,(IX+10) ; anim number
 156+ 5423 DD 5E 0C     	LD E,(IX+12)
 157+ 5426 DD 56 0D     	LD D,(IX+13)
 158+ 5429 CD E2 53     	CALL SGAM_PROCESS_ANIM_LIST
 159+ 542C
 160+ 542C D1               POP DE
 161+ 542D C1               POP BC
 162+ 542E C3 42 5E         JP RESTORE_PAGE_INFO
 163+ 5431              ; *******************************************************************************************************
 164+ 5431               ENDIF
 165+ 5431
 166+ 5431              ; *******************************************************************************************************
 167+ 5431              ; handles automatic move and animate sprite groups during interrupt
 168+ 5431              PROCESS_AUTOSGAMS:
 169+ 5431 3A F8 4E     	LD A,(AUTOSGAMNUM)
 170+ 5434 B7           	OR A
 171+ 5435 C8           	RET Z
 172+ 5436 47           	LD B,A
 173+ 5437 DD 2A F9 4E  	LD IX,(AUTOSGAMPTR)
 174+ 543B              .L1:
 175+ 543B C5           	PUSH BC
 176+ 543C DD 7E 13     	LD A,(IX+19) ; active flag
 177+ 543F B7           	OR A
 178+ 5440 28 28        	JR Z,.LOOPEND
 179+ 5442              	; active, check timer
 180+ 5442 DD 6E 16     	LD L,(IX+22)
 181+ 5445 DD 66 17     	LD H,(IX+23) ; timer
 182+ 5448 2B           	DEC HL
 183+ 5449 7C           	LD A,H
 184+ 544A B5           	OR L
 185+ 544B 28 08        	JR Z,.L2
 186+ 544D              	; not expired
 187+ 544D DD 75 16     	LD (IX+22),L
 188+ 5450 DD 74 17     	LD (IX+23),H
 189+ 5453 18 15        	JR .LOOPEND
 190+ 5455              .L2:
 191+ 5455              	; expired, process
 192+ 5455
 193+ 5455                  ; set initial timer
 194+ 5455 DD 7E 14         LD A,(IX+20)
 195+ 5458 DD 77 16         LD (IX+22),A
 196+ 545B DD 7E 15         LD A,(IX+21)
 197+ 545E DD 77 17         LD (IX+23),A
 198+ 5461
 199+ 5461 CD 73 54     	CALL .MOVE
 200+ 5464 CD DE 54     	CALL .UPDATELOC
 201+ 5467 CD 03 55     	CALL .PROCESS_ANIM_LIST
 202+ 546A
 203+ 546A              .LOOPEND:
 204+ 546A 11 18 00     	LD DE,24
 205+ 546D DD 19        	ADD IX,DE
 206+ 546F C1           	POP BC
 207+ 5470 10 C9        	DJNZ .L1
 208+ 5472 C9           	RET
 209+ 5473
 210+ 5473              .MOVE:
 211+ 5473              	; process movement
 212+ 5473 DD 7E 0A     	LD A,(IX+10) ; direction
 213+ 5476 B7           	OR A
 214+ 5477 28 08        	JR Z, .MOVE_L1
 215+ 5479              	; vertical
 216+ 5479 DD 6E 02     	LD L,(IX+2)
 217+ 547C DD 66 03     	LD H,(IX+3) ; vertical variable pointer
 218+ 547F 18 06        	JR .MOVE_L2
 219+ 5481              .MOVE_L1:
 220+ 5481              	; horizontal
 221+ 5481 DD 6E 00     	LD L,(IX+0)
 222+ 5484 DD 66 01     	LD H,(IX+1) ; horizontal variable pointer
 223+ 5487              .MOVE_L2:
 224+ 5487 E5           	PUSH HL
 225+ 5488 FD E1        	POP IY
 226+ 548A FD 6E 00     	LD L,(IY+0)
 227+ 548D FD 66 01     	LD H,(IY+1)
 228+ 5490 DD 5E 08     	LD E,(IX+8)
 229+ 5493 DD 56 09     	LD D,(IX+9) ; delta value
 230+ 5496 19           	ADD HL,DE
 231+ 5497 E5           	PUSH HL
 232+ 5498 DD 5E 04     	LD E,(IX+4)
 233+ 549B DD 56 05     	LD D,(IX+5) ; minimum value
 234+ 549E A7           	AND A
 235+ 549F ED 52        	SBC HL,DE
 236+ 54A1 FA BB 54     	JP M,.MOVE_L3 ; below minimum
 237+ 54A4 E1           	POP HL
 238+ 54A5 E5           	PUSH HL
 239+ 54A6 DD 5E 06     	LD E,(IX+6)
 240+ 54A9 DD 56 07     	LD D,(IX+7) ; maximum value
 241+ 54AC EB           	EX DE,HL
 242+ 54AD A7           	AND A
 243+ 54AE ED 52        	SBC HL,DE
 244+ 54B0 FA C3 54     	JP M,.MOVE_L4 ; above maximum
 245+ 54B3 E1           	POP HL
 246+ 54B4              	; within bounds
 247+ 54B4              .MOVE_L5:
 248+ 54B4 FD 75 00     	LD (IY+0),L
 249+ 54B7 FD 74 01     	LD (IY+1),H
 250+ 54BA C9           	RET
 251+ 54BB              .MOVE_L3:
 252+ 54BB E1           	POP HL
 253+ 54BC CD CF 54     	CALL .INVERSE_DELTA
 254+ 54BF 6B           	LD L,E
 255+ 54C0 62           	LD H,D
 256+ 54C1 18 F1        	JR .MOVE_L5
 257+ 54C3              .MOVE_L4:
 258+ 54C3 E1           	POP HL
 259+ 54C4 CD CF 54     	CALL .INVERSE_DELTA
 260+ 54C7 DD 6E 06     	LD L,(IX+6)
 261+ 54CA DD 66 07     	LD H,(IX+7) ; maximum
 262+ 54CD 18 E5        	JR .MOVE_L5
 263+ 54CF              .INVERSE_DELTA:
 264+ 54CF AF           	XOR A
 265+ 54D0 DD 96 08     	SUB (IX+8)
 266+ 54D3 DD 77 08     	LD (IX+8),A
 267+ 54D6 9F           	SBC A,A
 268+ 54D7 DD 96 09     	SUB (IX+9)
 269+ 54DA DD 77 09     	LD (IX+9),A
 270+ 54DD C9           	RET
 271+ 54DE
 272+ 54DE              .UPDATELOC:
 273+ 54DE DD E5        	PUSH IX
 274+ 54E0 D9           	EXX
 275+ 54E1 DD 6E 00     	LD L,(IX+0)
 276+ 54E4 DD 66 01     	LD H,(IX+1)
 277+ 54E7 5E           	LD E,(HL)
 278+ 54E8 23           	INC HL
 279+ 54E9 56           	LD D,(HL)
 280+ 54EA DD 6E 02     	LD L,(IX+2)
 281+ 54ED DD 66 03     	LD H,(IX+3)
 282+ 54F0 4E           	LD C,(HL)
 283+ 54F1 23           	INC HL
 284+ 54F2 46           	LD B,(HL)
 285+ 54F3 D9           	EXX
 286+ 54F4 DD 6E 0C     	LD L,(IX+12)
 287+ 54F7 DD 66 0D     	LD H,(IX+13) ; pointer to sprite group data
 288+ 54FA DD 46 0B     	LD B,(IX+11) ; sprite group size
 289+ 54FD CD BA 4E     	CALL SPR_UPDATE_LOC
 290+ 5500 DD E1        	POP IX
 291+ 5502 C9           	RET
 292+ 5503
 293+ 5503              .PROCESS_ANIM_LIST:
 294+ 5503 DD E5        	PUSH IX
 295+ 5505 DD 46 0E         LD B,(IX+14) ; anim list size
 296+ 5508 DD CB 09 7E  	BIT 7,(IX+9)
 297+ 550C 28 08        	JR Z,.PROCESS_ANIM_LIST_L1
 298+ 550E              	; negative direction
 299+ 550E DD 5E 0F     	LD E,(IX+15)
 300+ 5511 DD 56 10     	LD D,(IX+16)
 301+ 5514 18 06        	JR .PROCESS_ANIM_LIST_L2
 302+ 5516              .PROCESS_ANIM_LIST_L1:
 303+ 5516              	; positive direction
 304+ 5516 DD 5E 11     	LD E,(IX+17)
 305+ 5519 DD 56 12     	LD D,(IX+18)
 306+ 551C              .PROCESS_ANIM_LIST_L2:
 307+ 551C CD E2 53     	CALL SGAM_PROCESS_ANIM_LIST
 308+ 551F DD E1        	POP IX
 309+ 5521 C9           	RET
 310+ 5522              ; *******************************************************************************************************
 311+ 5522
# file closed: asm\SGAM.asm
 135  5522               ENDIF
 136  5522
 137  5522               IF (RAM_CMDS == 1)
 138  5522               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
   1+ 5522               IF (0 == 1)
   2+ 5522 ~            ; *******************************************************************************************************
   3+ 5522 ~            ; function to handle CALL MEMCPY basic extension
   4+ 5522 ~            ; _MEMCPY ( INT source,
   5+ 5522 ~            ;			INT destination,
   6+ 5522 ~            ;			INT count,
   7+ 5522 ~            ; will put ram in page 0 also, page 1 is already there
   8+ 5522 ~            MEMCPY:
   9+ 5522 ~            	; opening (
  10+ 5522 ~            	CALL CHKCHAR
  11+ 5522 ~            	DB '('
  12+ 5522 ~            	; get source address
  13+ 5522 ~            	LD IX, FRMQNT
  14+ 5522 ~            	CALL CALBAS
  15+ 5522 ~            	PUSH DE
  16+ 5522 ~            	; comma
  17+ 5522 ~            	CALL CHKCHAR
  18+ 5522 ~            	DB ','
  19+ 5522 ~            	; get destination address
  20+ 5522 ~            	LD IX, FRMQNT
  21+ 5522 ~            	CALL CALBAS
  22+ 5522 ~            	PUSH DE
  23+ 5522 ~            	; comma
  24+ 5522 ~            	CALL CHKCHAR
  25+ 5522 ~            	DB ','
  26+ 5522 ~            	; get length
  27+ 5522 ~            	LD IX, FRMQNT
  28+ 5522 ~            	CALL CALBAS
  29+ 5522 ~            	PUSH DE
  30+ 5522 ~            	; ending )
  31+ 5522 ~            	CALL CHKCHAR
  32+ 5522 ~            	DB ')'
  33+ 5522 ~
  34+ 5522 ~            	; save position
  35+ 5522 ~            	PUSH HL
  36+ 5522 ~            	POP IX
  37+ 5522 ~
  38+ 5522 ~            	POP BC ; count
  39+ 5522 ~            	POP DE ; destination
  40+ 5522 ~            	POP HL ; source
  41+ 5522 ~            	EXX
  42+ 5522 ~            	; enable page 0
  43+ 5522 ~            	LD IY, .RET
  44+ 5522 ~            	JP ENABLE_PAGE0
  45+ 5522 ~            .RET:
  46+ 5522 ~            	EI
  47+ 5522 ~            	EXX
  48+ 5522 ~            	LDIR
  49+ 5522 ~                POP DE
  50+ 5522 ~                POP BC
  51+ 5522 ~                CALL RESTORE_PAGE_INFO
  52+ 5522 ~            	PUSH IX
  53+ 5522 ~            	POP HL
  54+ 5522 ~            	RET
  55+ 5522 ~            ; *******************************************************************************************************
  56+ 5522               ENDIF
  57+ 5522
  58+ 5522               IF (1 == 1)
  59+ 5522              ; *******************************************************************************************************
  60+ 5522              ; same as MEMCPY but for DEFUSR approach
  61+ 5522              ; input IX=pointer to input array, real data from +2
  62+ 5522              ; +2 = source address
  63+ 5522              ; +4 = destination address
  64+ 5522              ; +6 = lenght
  65+ 5522              MEMCPY_DEFUSR:
  66+ 5522              	; enable page 0
  67+ 5522 FD 21 29 55  	LD IY, .RET
  68+ 5526 C3 CB 5E     	JP ENABLE_PAGE0
  69+ 5529              .RET:
  70+ 5529 FB           	EI
  71+ 552A DD 6E 02     	LD L,(IX+2)
  72+ 552D DD 66 03     	LD H,(IX+3)
  73+ 5530 DD 5E 04     	LD E,(IX+4)
  74+ 5533 DD 56 05     	LD D,(IX+5)
  75+ 5536 DD 4E 06     	LD C,(IX+6)
  76+ 5539 DD 46 07     	LD B,(IX+7)
  77+ 553C ED B0        	LDIR
  78+ 553E D1               POP DE
  79+ 553F C1               POP BC
  80+ 5540 C3 42 5E         JP RESTORE_PAGE_INFO
  81+ 5543              ; *******************************************************************************************************
  82+ 5543               ENDIF
  83+ 5543
  84+ 5543               IF (0 == 1)
  85+ 5543 ~            ; *******************************************************************************************************
  86+ 5543 ~            ; function to handle CALL FILRAM basic extension
  87+ 5543 ~            ; FILRAM ( INT start address,
  88+ 5543 ~            ;		   INT count,
  89+ 5543 ~            ;		   BYTE value )
  90+ 5543 ~            ; will put ram in page 0 also, page 1 is already there
  91+ 5543 ~            FILRAM:
  92+ 5543 ~            	; opening (
  93+ 5543 ~            	CALL CHKCHAR
  94+ 5543 ~            	DB '('
  95+ 5543 ~            	; get start address
  96+ 5543 ~            	LD IX, FRMQNT
  97+ 5543 ~            	CALL CALBAS
  98+ 5543 ~            	PUSH DE
  99+ 5543 ~            	; comma
 100+ 5543 ~            	CALL CHKCHAR
 101+ 5543 ~            	DB ','
 102+ 5543 ~            	; get count
 103+ 5543 ~            	LD IX, FRMQNT
 104+ 5543 ~            	CALL CALBAS
 105+ 5543 ~            	PUSH DE
 106+ 5543 ~            	; comma
 107+ 5543 ~            	CALL CHKCHAR
 108+ 5543 ~            	DB ','
 109+ 5543 ~            	; get value
 110+ 5543 ~            	LD IX, GETBYT
 111+ 5543 ~            	CALL CALBAS
 112+ 5543 ~            	PUSH AF
 113+ 5543 ~            	; ending )
 114+ 5543 ~            	CALL CHKCHAR
 115+ 5543 ~            	DB ')'
 116+ 5543 ~
 117+ 5543 ~            	; save position
 118+ 5543 ~            	PUSH HL
 119+ 5543 ~            	POP IX
 120+ 5543 ~
 121+ 5543 ~            	POP DE ; actually AF
 122+ 5543 ~            	POP BC ; count
 123+ 5543 ~            	POP HL ; start address
 124+ 5543 ~            	LD A, B
 125+ 5543 ~            	OR C
 126+ 5543 ~            	JR Z, .EXIT ; 0 bytes to fill, skip
 127+ 5543 ~            	EXX
 128+ 5543 ~            	; enable page 0
 129+ 5543 ~            	LD IY, .RET
 130+ 5543 ~            	JP ENABLE_PAGE0
 131+ 5543 ~            .RET:
 132+ 5543 ~            	EI
 133+ 5543 ~            	EXX
 134+ 5543 ~            	CALL FILVRM_FILLVALUE
 135+ 5543 ~                POP DE
 136+ 5543 ~                POP BC
 137+ 5543 ~                CALL RESTORE_PAGE_INFO
 138+ 5543 ~            .EXIT:
 139+ 5543 ~            	PUSH IX
 140+ 5543 ~            	POP HL
 141+ 5543 ~            	RET
 142+ 5543 ~            ; *******************************************************************************************************
 143+ 5543               ENDIF
 144+ 5543
 145+ 5543               IF (1 == 1)
 146+ 5543              ; *******************************************************************************************************
 147+ 5543              ; same as FILVRM but for DEFUSR approach
 148+ 5543              ; input IX=pointer to input array, real data from +2
 149+ 5543              ; +2 = start address
 150+ 5543              ; +4 = count
 151+ 5543              ; +6 = value
 152+ 5543              FILRAM_DEFUSR:
 153+ 5543              	; enable page 0
 154+ 5543 FD 21 4A 55  	LD IY, .RET
 155+ 5547 C3 CB 5E     	JP ENABLE_PAGE0
 156+ 554A              .RET:
 157+ 554A FB           	EI
 158+ 554B DD 6E 02     	LD L,(IX+2)
 159+ 554E DD 66 03     	LD H,(IX+3)
 160+ 5551 DD 4E 04     	LD C,(IX+4)
 161+ 5554 DD 46 05     	LD B,(IX+5)
 162+ 5557 78           	LD A,B
 163+ 5558 B1           	OR C
 164+ 5559 28 06        	JR Z,.EXIT
 165+ 555B DD 56 06     	LD D,(IX+6)
 166+ 555E CD 66 55     	CALL FILVRM_FILLVALUE
 167+ 5561              .EXIT:
 168+ 5561 D1               POP DE
 169+ 5562 C1               POP BC
 170+ 5563 C3 42 5E         JP RESTORE_PAGE_INFO
 171+ 5566              ; *******************************************************************************************************
 172+ 5566               ENDIF
 173+ 5566
 174+ 5566              ; *******************************************************************************************************
 175+ 5566              ; common function to fill RAM
 176+ 5566              FILVRM_FILLVALUE:
 177+ 5566 72               LD (HL), D
 178+ 5567 54               LD D, H
 179+ 5568 5D               LD E, L
 180+ 5569 13               INC DE
 181+ 556A 0B               DEC BC
 182+ 556B 78           	LD A,B
 183+ 556C B1           	OR C
 184+ 556D C8           	RET Z ; if count was 1
 185+ 556E ED B0            LDIR
 186+ 5570 C9               RET
 187+ 5571              ; *******************************************************************************************************
# file closed: asm\MEMORY.asm
 139  5571               ENDIF
 140  5571
 141  5571               IF (SOUND_CMDS == 1)
 142  5571               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
   1+ 5571              MUSIC_INIT_STATUS:
   2+ 5571 00            DB 0
   3+ 5572              SFX_INIT_STATUS:
   4+ 5572 00            DB 0
   5+ 5573              SOUND_ENABLED:
   6+ 5573 00            DB 0
   7+ 5574
   8+ 5574               IF (0 == 1)
   9+ 5574 ~            ; *******************************************************************************************************
  10+ 5574 ~            ; function to handle CALL SNDPLYINIT basic extension
  11+ 5574 ~            ; initializes sound player
  12+ 5574 ~            ; _SNDPLYINIT ( INT music_offset,
  13+ 5574 ~            ;				INT sfx_offset, can be -1 if no SFX
  14+ 5574 ~            ; will put ram in page 0 also, page 1 is already there
  15+ 5574 ~            ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
  16+ 5574 ~            SNDPLYINIT:
  17+ 5574 ~            	; opening (
  18+ 5574 ~            	CALL CHKCHAR
  19+ 5574 ~            	DB '('
  20+ 5574 ~            	; get music address
  21+ 5574 ~            	LD IX, FRMQNT
  22+ 5574 ~            	CALL CALBAS
  23+ 5574 ~            	PUSH DE
  24+ 5574 ~            	; comma
  25+ 5574 ~            	CALL CHKCHAR
  26+ 5574 ~            	DB ','
  27+ 5574 ~            	; get sfx address
  28+ 5574 ~            	LD IX, FRMQNT
  29+ 5574 ~            	CALL CALBAS
  30+ 5574 ~            	PUSH DE
  31+ 5574 ~            	; ending )
  32+ 5574 ~            	CALL CHKCHAR
  33+ 5574 ~            	DB ')'
  34+ 5574 ~
  35+ 5574 ~                ; save position in BASIC text
  36+ 5574 ~            	LD B, H
  37+ 5574 ~            	LD C, L
  38+ 5574 ~
  39+ 5574 ~            	; pop LDIR parameters and store away for later
  40+ 5574 ~            	POP DE ; sfx address
  41+ 5574 ~            	POP HL ; music address
  42+ 5574 ~            	PUSH BC ; basic text location
  43+ 5574 ~            	EXX
  44+ 5574 ~            	LD IY, .RET
  45+ 5574 ~            	JP ENABLE_PAGE0
  46+ 5574 ~            .RET:
  47+ 5574 ~            	EXX
  48+ 5574 ~
  49+ 5574 ~            	PUSH DE
  50+ 5574 ~            	XOR A
  51+ 5574 ~            	; HL = music location
  52+ 5574 ~            	CALL PLY_AKG_INIT
  53+ 5574 ~            	LD A, 1
  54+ 5574 ~            	LD (MUSIC_INIT_STATUS), A
  55+ 5574 ~
  56+ 5574 ~            	POP HL ; SFX
  57+ 5574 ~            	; check if SFX address -1
  58+ 5574 ~            	INC HL
  59+ 5574 ~            	LD A, L
  60+ 5574 ~            	OR H
  61+ 5574 ~            	JR Z,.L1
  62+ 5574 ~            	DEC HL
  63+ 5574 ~            	CALL PLY_AKG_INITSOUNDEFFECTS
  64+ 5574 ~            	LD A, 1
  65+ 5574 ~            	LD (SFX_INIT_STATUS), A
  66+ 5574 ~            .L1:
  67+ 5574 ~                POP DE
  68+ 5574 ~                POP BC
  69+ 5574 ~                CALL RESTORE_PAGE_INFO
  70+ 5574 ~
  71+ 5574 ~            	POP HL
  72+ 5574 ~            	RET
  73+ 5574 ~            ; *******************************************************************************************************
  74+ 5574               ENDIF
  75+ 5574
  76+ 5574               IF (1 == 1)
  77+ 5574              ; *******************************************************************************************************
  78+ 5574              ; same as SNDPLYINI but for DEFUSR approach
  79+ 5574              ; input IX=pointer to input array, real data from +2
  80+ 5574              ; +2 = music address
  81+ 5574              ; +4 = sfx address
  82+ 5574              SNDPLYINI_DEFUSR:
  83+ 5574 FD 21 7B 55  	LD IY, .RET
  84+ 5578 C3 CB 5E     	JP ENABLE_PAGE0
  85+ 557B              .RET:
  86+ 557B AF           	XOR A
  87+ 557C DD 6E 02     	LD L,(IX+2)
  88+ 557F DD 66 03     	LD H,(IX+3)
  89+ 5582 DD E5        	PUSH IX
  90+ 5584 CD 65 41     	CALL PLY_AKG_INIT
  91+ 5587 DD E1        	POP IX
  92+ 5589 3E 01        	LD A, 1
  93+ 558B 32 71 55     	LD (MUSIC_INIT_STATUS), A
  94+ 558E
  95+ 558E DD 6E 04     	LD L,(IX+4)
  96+ 5591 DD 66 05     	LD H,(IX+5)
  97+ 5594              	; check if SFX address -1
  98+ 5594 23           	INC HL
  99+ 5595 7D           	LD A, L
 100+ 5596 B4           	OR H
 101+ 5597 28 09        	JR Z,.L1
 102+ 5599 2B           	DEC HL
 103+ 559A CD 20 40     	CALL PLY_AKG_INITSOUNDEFFECTS
 104+ 559D 3E 01        	LD A, 1
 105+ 559F 32 72 55     	LD (SFX_INIT_STATUS), A
 106+ 55A2              .L1:
 107+ 55A2 D1               POP DE
 108+ 55A3 C1               POP BC
 109+ 55A4 C3 42 5E         JP RESTORE_PAGE_INFO
 110+ 55A7              ; *******************************************************************************************************
 111+ 55A7               ENDIF
 112+ 55A7
 113+ 55A7              ; *******************************************************************************************************
 114+ 55A7              ; function to handle CALL SNDPLYON basic extension
 115+ 55A7              ; enables sound player
 116+ 55A7              ; _SNDPLYON
 117+ 55A7              ; sets SOUND_ENABLED variable to 1 if init call was done
 118+ 55A7              ; if not throws out of data error
 119+ 55A7              SNDPLYON_DEFUSR:
 120+ 55A7              SNDPLYON:
 121+ 55A7 3A 71 55     	LD A, (MUSIC_INIT_STATUS)
 122+ 55AA B7           	OR A
 123+ 55AB 20 05        	JR NZ, .L1
 124+ 55AD              	; player not initialized, throw error
 125+ 55AD 1E 04        	LD E, 04 ; Out of DATA
 126+ 55AF C3 40 5F     	JP THROW_ERROR
 127+ 55B2              .L1:
 128+ 55B2 32 73 55     	LD (SOUND_ENABLED), A
 129+ 55B5              	; disable key click
 130+ 55B5 AF           	XOR A
 131+ 55B6 32 DB F3     	LD (CLIKSW), A
 132+ 55B9 C9           	RET
 133+ 55BA              ; *******************************************************************************************************
 134+ 55BA
 135+ 55BA              ; *******************************************************************************************************
 136+ 55BA              ; function to handle CALL SNDPLYOFF basic extension
 137+ 55BA              ; disables sound player
 138+ 55BA              ; _SNDPLYOFF
 139+ 55BA              ; sets SOUND_ENABLED variable to 0
 140+ 55BA              ; calls AKG to stop music and SFX on all channels if initialized
 141+ 55BA              SNDPLYOFF_DEFUSR:
 142+ 55BA              SNDPLYOFF:
 143+ 55BA 3A 73 55     	LD A, (SOUND_ENABLED)
 144+ 55BD B7           	OR A
 145+ 55BE C8           	RET Z ; already stopped
 146+ 55BF AF           	XOR A
 147+ 55C0 32 73 55     	LD (SOUND_ENABLED), A
 148+ 55C3 E5           	PUSH HL
 149+ 55C4 CD 24 42     	CALL PLY_AKG_STOP
 150+ 55C7 3A 72 55     	LD A, (SFX_INIT_STATUS)
 151+ 55CA B7           	OR A
 152+ 55CB 28 0E        	JR Z, .EXIT ; SFX not in use
 153+ 55CD AF           	XOR A
 154+ 55CE CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 155+ 55D1 3E 01        	LD A, 1
 156+ 55D3 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 157+ 55D6 3E 02        	LD A, 2
 158+ 55D8 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 159+ 55DB              .EXIT:
 160+ 55DB E1           	POP HL
 161+ 55DC C9           	RET
 162+ 55DD              ; *******************************************************************************************************
 163+ 55DD
 164+ 55DD               IF (0 == 1)
 165+ 55DD ~            ; *******************************************************************************************************
 166+ 55DD ~            ; function to handle CALL SNDSFX basic extension
 167+ 55DD ~            ; plays a sound effect
 168+ 55DD ~            ; _SNDSFX ( BYTE sfx_number, >0
 169+ 55DD ~            ;			BYTE channel, = 0,1 or 2
 170+ 55DD ~            ;			BYTE inverted_volume = 0-16, 0 being full volume
 171+ 55DD ~            ; will put ram in page 0 also, page 1 is already there
 172+ 55DD ~            ; if sound off throws illegal function call
 173+ 55DD ~            ; if sfx not initialized, throws out of data
 174+ 55DD ~            SNDSFX:
 175+ 55DD ~            	; opening (
 176+ 55DD ~            	CALL CHKCHAR
 177+ 55DD ~            	DB '('
 178+ 55DD ~            	; get sfx_number
 179+ 55DD ~            	LD IX, GETBYT
 180+ 55DD ~            	CALL CALBAS
 181+ 55DD ~            	PUSH DE
 182+ 55DD ~            	; comma
 183+ 55DD ~            	CALL CHKCHAR
 184+ 55DD ~            	DB ','
 185+ 55DD ~            	; get sfx address
 186+ 55DD ~            	LD IX, GETBYT
 187+ 55DD ~            	CALL CALBAS
 188+ 55DD ~            	PUSH DE
 189+ 55DD ~            	; comma
 190+ 55DD ~            	CALL CHKCHAR
 191+ 55DD ~            	DB ','
 192+ 55DD ~            	; get inverted volume
 193+ 55DD ~            	LD IX, GETBYT
 194+ 55DD ~            	CALL CALBAS
 195+ 55DD ~            	PUSH DE
 196+ 55DD ~            	; ending )
 197+ 55DD ~            	CALL CHKCHAR
 198+ 55DD ~            	DB ')'
 199+ 55DD ~
 200+ 55DD ~            	LD A, (SOUND_ENABLED)
 201+ 55DD ~            	OR A
 202+ 55DD ~            	JR NZ, .L1
 203+ 55DD ~            	; sound disabled, throw illegal function call
 204+ 55DD ~            	LD E, 5
 205+ 55DD ~            	JP THROW_ERROR
 206+ 55DD ~            .L1:
 207+ 55DD ~            	LD A, (SFX_INIT_STATUS)
 208+ 55DD ~            	OR A
 209+ 55DD ~            	JR NZ, .L2
 210+ 55DD ~            	; sfx data not initialized, throw out of data
 211+ 55DD ~            	LD E, 4
 212+ 55DD ~            	JP THROW_ERROR
 213+ 55DD ~            .L2:
 214+ 55DD ~            	; pop  parameters and store away for later
 215+ 55DD ~            	POP DE ; inverted volume
 216+ 55DD ~            	LD B, E
 217+ 55DD ~            	POP DE ; channel
 218+ 55DD ~            	LD C, E
 219+ 55DD ~            	POP DE
 220+ 55DD ~            	LD A, E
 221+ 55DD ~            	EX AF, AF'
 222+ 55DD ~            	PUSH HL ; basic text location
 223+ 55DD ~            	EXX
 224+ 55DD ~            	LD IY, .RET
 225+ 55DD ~            	JP ENABLE_PAGE0
 226+ 55DD ~            .RET:
 227+ 55DD ~            	EXX
 228+ 55DD ~            	EX AF, AF'
 229+ 55DD ~            	CALL PLY_AKG_PLAYSOUNDEFFECT
 230+ 55DD ~
 231+ 55DD ~                POP DE
 232+ 55DD ~                POP BC
 233+ 55DD ~                CALL RESTORE_PAGE_INFO
 234+ 55DD ~
 235+ 55DD ~            	POP HL
 236+ 55DD ~            	RET
 237+ 55DD ~            ; *******************************************************************************************************
 238+ 55DD               ENDIF
 239+ 55DD
 240+ 55DD               IF (1 == 1)
 241+ 55DD              ; *******************************************************************************************************
 242+ 55DD              ; same as SNDSFX but for DEFUSR approach
 243+ 55DD              ; input IX=pointer to input array, real data from +2
 244+ 55DD              ; +2 = SFX number
 245+ 55DD              ; +4 = channel
 246+ 55DD              ; +6 = volume
 247+ 55DD              SNDSFX_DEFUSR:
 248+ 55DD 3A 73 55     	LD A, (SOUND_ENABLED)
 249+ 55E0 B7           	OR A
 250+ 55E1 C8           	RET Z ; sound disabled, just exit
 251+ 55E2 3A 72 55     	LD A, (SFX_INIT_STATUS)
 252+ 55E5 B7           	OR A
 253+ 55E6 C8           	RET Z ; sfx data not initialized, just exit
 254+ 55E7 FD 21 EE 55  	LD IY, .RET
 255+ 55EB C3 CB 5E     	JP ENABLE_PAGE0
 256+ 55EE              .RET:
 257+ 55EE FB           	EI
 258+ 55EF DD 7E 02     	LD A,(IX+2) ; SFX number
 259+ 55F2 DD 4E 04     	LD C,(IX+4) ; channel
 260+ 55F5 DD 46 06     	LD B,(IX+6) ; volume
 261+ 55F8 CD 24 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
 262+ 55FB D1               POP DE
 263+ 55FC C1               POP BC
 264+ 55FD C3 42 5E         JP RESTORE_PAGE_INFO
 265+ 5600              ; *******************************************************************************************************
 266+ 5600               ENDIF
# file closed: asm\SOUND.asm
 143  5600               ENDIF
 144  5600
 145  5600               IF (VRAM_CMDS == 1)
 146  5600               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
   1+ 5600               IF (0 == 1)
   2+ 5600 ~            ; *******************************************************************************************************
   3+ 5600 ~            ; function to handle CALL FILVRM basic extension
   4+ 5600 ~            ; FILVRM ( INT offset,
   5+ 5600 ~            ;		   INT count,
   6+ 5600 ~            ;		   BYTE value,
   7+ 5600 ~            ;		   BYTE wait_vsync) >0 = true
   8+ 5600 ~            ; wait_vsync will issue HALT before copying
   9+ 5600 ~            FILVRM:
  10+ 5600 ~            	; opening (
  11+ 5600 ~            	CALL CHKCHAR
  12+ 5600 ~            	DB '('
  13+ 5600 ~            	; get offset address
  14+ 5600 ~            	LD IX, FRMQNT
  15+ 5600 ~            	CALL CALBAS
  16+ 5600 ~            	PUSH DE
  17+ 5600 ~            	; comma
  18+ 5600 ~            	CALL CHKCHAR
  19+ 5600 ~            	DB ','
  20+ 5600 ~            	; get count
  21+ 5600 ~            	LD IX, FRMQNT
  22+ 5600 ~            	CALL CALBAS
  23+ 5600 ~            	PUSH DE
  24+ 5600 ~            	; comma
  25+ 5600 ~            	CALL CHKCHAR
  26+ 5600 ~            	DB ','
  27+ 5600 ~            	; get value
  28+ 5600 ~            	LD IX, GETBYT
  29+ 5600 ~            	CALL CALBAS
  30+ 5600 ~            	PUSH AF
  31+ 5600 ~            	; comma
  32+ 5600 ~            	CALL CHKCHAR
  33+ 5600 ~            	DB ','
  34+ 5600 ~            	; get vsync wait
  35+ 5600 ~            	LD IX, GETBYT
  36+ 5600 ~            	CALL CALBAS
  37+ 5600 ~            	PUSH AF
  38+ 5600 ~            	; ending )
  39+ 5600 ~            	CALL CHKCHAR
  40+ 5600 ~            	DB ')'
  41+ 5600 ~
  42+ 5600 ~            	; save position
  43+ 5600 ~            	PUSH HL
  44+ 5600 ~            	POP IX
  45+ 5600 ~
  46+ 5600 ~            	; syntax ok
  47+ 5600 ~            	; wait for vsync if needed
  48+ 5600 ~            	POP AF
  49+ 5600 ~            	OR A
  50+ 5600 ~            	JR Z, .L1
  51+ 5600 ~            	HALT
  52+ 5600 ~
  53+ 5600 ~            .L1:
  54+ 5600 ~            	LD A,1
  55+ 5600 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  56+ 5600 ~                POP AF ; value
  57+ 5600 ~                POP BC ; count
  58+ 5600 ~                POP HL ; offset
  59+ 5600 ~                CALL BIOS_FILVRM
  60+ 5600 ~            	XOR A
  61+ 5600 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  62+ 5600 ~
  63+ 5600 ~            .L3:
  64+ 5600 ~            	PUSH IX
  65+ 5600 ~            	POP HL
  66+ 5600 ~            	RET
  67+ 5600 ~            ; *******************************************************************************************************
  68+ 5600               ENDIF
  69+ 5600
  70+ 5600               IF (1 == 1)
  71+ 5600              ; *******************************************************************************************************
  72+ 5600              ; same as FILVRM but for DEFUSR approach
  73+ 5600              ; input IX=pointer to input array, real data from +2
  74+ 5600              ; +2 = offset
  75+ 5600              ; +4 = count
  76+ 5600              ; +6 = value
  77+ 5600              ; +8 = halt flag
  78+ 5600              FILVRM_DEFUSR:
  79+ 5600 DD 7E 08     	LD A,(IX+8)
  80+ 5603 B7           	OR A
  81+ 5604 28 01        	JR Z,.L0
  82+ 5606 76           	HALT
  83+ 5607              .L0:
  84+ 5607 3E 01        	LD A,1
  85+ 5609 32 B2 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
  86+ 560C DD 6E 02     	LD L,(IX+2)
  87+ 560F DD 66 03     	LD H,(IX+3)
  88+ 5612 DD 4E 04     	LD C,(IX+4)
  89+ 5615 DD 46 05     	LD B,(IX+5)
  90+ 5618 DD 7E 06     	LD A,(IX+6)
  91+ 561B CD 56 00     	CALL BIOS_FILVRM
  92+ 561E AF           	XOR A
  93+ 561F 32 B2 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
  94+ 5622 C9           	RET
  95+ 5623              ; *******************************************************************************************************
  96+ 5623               ENDIF
  97+ 5623
  98+ 5623               IF (0 == 1)
  99+ 5623 ~            ; *******************************************************************************************************
 100+ 5623 ~            ; function to handle CALL MEMVRM basic extension
 101+ 5623 ~            ; copies from RAM to VRAM
 102+ 5623 ~            ; if flag != 0 it will issue HALT before copying
 103+ 5623 ~            ; if bit 1 of flag set and sprite system initialized it will set sprite update flag
 104+ 5623 ~            ; _MEMVRM ( INT source,
 105+ 5623 ~            ;			INT destination,
 106+ 5623 ~            ;			INT count,
 107+ 5623 ~            ;			BYTE flag)
 108+ 5623 ~            ; will put ram in page 0 also, page 1 is already there
 109+ 5623 ~            MEMVRM:
 110+ 5623 ~            	; opening (
 111+ 5623 ~            	CALL CHKCHAR
 112+ 5623 ~            	DB '('
 113+ 5623 ~            	; get source address
 114+ 5623 ~            	LD IX, FRMQNT
 115+ 5623 ~            	CALL CALBAS
 116+ 5623 ~            	PUSH DE
 117+ 5623 ~            	; comma
 118+ 5623 ~            	CALL CHKCHAR
 119+ 5623 ~            	DB ','
 120+ 5623 ~            	; get destination address
 121+ 5623 ~            	LD IX, FRMQNT
 122+ 5623 ~            	CALL CALBAS
 123+ 5623 ~            	PUSH DE
 124+ 5623 ~            	; comma
 125+ 5623 ~            	CALL CHKCHAR
 126+ 5623 ~            	DB ','
 127+ 5623 ~            	; get length
 128+ 5623 ~            	LD IX, FRMQNT
 129+ 5623 ~            	CALL CALBAS
 130+ 5623 ~            	PUSH DE
 131+ 5623 ~            	; comma
 132+ 5623 ~            	CALL CHKCHAR
 133+ 5623 ~            	DB ','
 134+ 5623 ~            	; get vsync wait
 135+ 5623 ~            	LD IX, GETBYT
 136+ 5623 ~            	CALL CALBAS
 137+ 5623 ~            	PUSH AF
 138+ 5623 ~            	; ending )
 139+ 5623 ~            	CALL CHKCHAR
 140+ 5623 ~            	DB ')'
 141+ 5623 ~
 142+ 5623 ~                ; save position in BASIC text
 143+ 5623 ~            	PUSH HL
 144+ 5623 ~            	POP IX
 145+ 5623 ~
 146+ 5623 ~            	POP AF ; wait vsync
 147+ 5623 ~            	OR A
 148+ 5623 ~            	JR Z, .L1
 149+ 5623 ~            	; check for special case to set sprite update flag
 150+ 5623 ~            	IF (SPRITE_CMDS == 1)
 151+ 5623 ~            		AND 2
 152+ 5623 ~            		JR Z,.L2
 153+ 5623 ~            		LD A, (SPRATR_INIT_STATUS)
 154+ 5623 ~            		OR A
 155+ 5623 ~            		JR Z,.L2
 156+ 5623 ~            		LD HL,(SPRATR_UPDATE_FLAG)
 157+ 5623 ~            		LD (HL),A
 158+ 5623 ~            	ENDIF
 159+ 5623 ~            .L2:
 160+ 5623 ~            	HALT
 161+ 5623 ~            .L1:
 162+ 5623 ~            	; pop LDIR parameters and store away for later
 163+ 5623 ~            	POP BC ; count
 164+ 5623 ~            	POP DE ; vram destination
 165+ 5623 ~            	POP HL ; ram source
 166+ 5623 ~            	EXX
 167+ 5623 ~             	LD IY, .RET
 168+ 5623 ~            	JP ENABLE_PAGE0
 169+ 5623 ~            .RET:
 170+ 5623 ~            	EI
 171+ 5623 ~            	EXX
 172+ 5623 ~            	CALL VRAM_LDIRVM
 173+ 5623 ~                POP DE
 174+ 5623 ~                POP BC
 175+ 5623 ~                CALL RESTORE_PAGE_INFO
 176+ 5623 ~            	PUSH IX
 177+ 5623 ~            	POP HL
 178+ 5623 ~            	RET
 179+ 5623 ~            ; *******************************************************************************************************
 180+ 5623               ENDIF
 181+ 5623
 182+ 5623               IF (1 == 1)
 183+ 5623              ; *******************************************************************************************************
 184+ 5623              ; same as MEMVRM but for DEFUSR approach
 185+ 5623              ; input IX=pointer to input array, real data from +2
 186+ 5623              ; +2 = source address
 187+ 5623              ; +4 = destination address
 188+ 5623              ; +6 = lenght
 189+ 5623              ; +8 = flag
 190+ 5623              MEMVRM_DEFUSR:
 191+ 5623 DD 7E 08     	LD A,(IX+8)
 192+ 5626 B7           	OR A
 193+ 5627 28 0F        	JR Z,.L0
 194+ 5629              	IF (SPRITE_CMDS == 1)
 195+ 5629 E6 02        		AND 2
 196+ 562B 28 0A        		JR Z,.L2
 197+ 562D 3A 7F 4D     		LD A, (SPRATR_INIT_STATUS)
 198+ 5630 B7           		OR A
 199+ 5631 28 04        		JR Z,.L2
 200+ 5633 2A 80 4D     		LD HL,(SPRATR_UPDATE_FLAG)
 201+ 5636 77           		LD (HL),A
 202+ 5637              	ENDIF
 203+ 5637              .L2:
 204+ 5637 76           	HALT
 205+ 5638              .L0:
 206+ 5638              	; enable page 0
 207+ 5638 FD 21 3F 56  	LD IY, .RET
 208+ 563C C3 CB 5E     	JP ENABLE_PAGE0
 209+ 563F              .RET:
 210+ 563F FB           	EI
 211+ 5640 DD 6E 02     	LD L,(IX+2)
 212+ 5643 DD 66 03     	LD H,(IX+3)
 213+ 5646 DD 5E 04     	LD E,(IX+4)
 214+ 5649 DD 56 05     	LD D,(IX+5)
 215+ 564C DD 4E 06     	LD C,(IX+6)
 216+ 564F DD 46 07     	LD B,(IX+7)
 217+ 5652 CD 5A 56     	CALL VRAM_LDIRVM
 218+ 5655 D1               POP DE
 219+ 5656 C1               POP BC
 220+ 5657 C3 42 5E         JP RESTORE_PAGE_INFO
 221+ 565A              ; *******************************************************************************************************
 222+ 565A               ENDIF
 223+ 565A
 224+ 565A              ; *******************************************************************************************************
 225+ 565A              ; common code to copy from memory to VRAM
 226+ 565A              ; input HL=RAM source
 227+ 565A              ; input DE=VRAM destination
 228+ 565A              ; BC=count
 229+ 565A              VRAM_LDIRVM:
 230+ 565A 3E 01        	LD A,1
 231+ 565C 32 B2 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 232+ 565F EB           	EX DE, HL
 233+ 5660 F3           	DI
 234+ 5661 CD F2 5D     	CALL SETWRT_LOCAL
 235+ 5664 FB           	EI
 236+ 5665 EB           	EX DE, HL
 237+ 5666 78           	LD A, B
 238+ 5667 B7           	OR A
 239+ 5668 28 0D        	JR Z, .L3
 240+ 566A C5           	PUSH BC
 241+ 566B 0E 98        	LD C, #98
 242+ 566D              .L2:
 243+ 566D 50           	LD D, B
 244+ 566E 06 00        	LD B, 0
 245+ 5670 CD FF 5D     	CALL BBYTECOPY_NO_C
 246+ 5673 42           	LD B, D
 247+ 5674 10 F7        	DJNZ .L2
 248+ 5676 C1           	POP BC
 249+ 5677              .L3:
 250+ 5677 79           	LD A, C
 251+ 5678 B7           	OR A
 252+ 5679 28 04        	JR Z,.L4
 253+ 567B 41           	LD B, C
 254+ 567C CD FD 5D     	CALL BBYTECOPY
 255+ 567F              .L4:
 256+ 567F AF           	XOR A
 257+ 5680 32 B2 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 258+ 5683 C9           	RET
 259+ 5684              ; *******************************************************************************************************
 260+ 5684
 261+ 5684               IF (0 == 1)
 262+ 5684 ~            ; *******************************************************************************************************
 263+ 5684 ~            ; function to handle CALL VRMMEM basic extension
 264+ 5684 ~            ; copies from VRAM to RAM
 265+ 5684 ~            ; _VRMMEM ( INT source,
 266+ 5684 ~            ;			INT destination,
 267+ 5684 ~            ;			INT count
 268+ 5684 ~            ; will put ram in page 0 also, page 1 is already there
 269+ 5684 ~            VRMMEM:
 270+ 5684 ~            	; opening (
 271+ 5684 ~            	CALL CHKCHAR
 272+ 5684 ~            	DB '('
 273+ 5684 ~            	; get source address
 274+ 5684 ~            	LD IX, FRMQNT
 275+ 5684 ~            	CALL CALBAS
 276+ 5684 ~            	PUSH DE
 277+ 5684 ~            	; comma
 278+ 5684 ~            	CALL CHKCHAR
 279+ 5684 ~            	DB ','
 280+ 5684 ~            	; get destination address
 281+ 5684 ~            	LD IX, FRMQNT
 282+ 5684 ~            	CALL CALBAS
 283+ 5684 ~            	PUSH DE
 284+ 5684 ~            	; comma
 285+ 5684 ~            	CALL CHKCHAR
 286+ 5684 ~            	DB ','
 287+ 5684 ~            	; get length
 288+ 5684 ~            	LD IX, FRMQNT
 289+ 5684 ~            	CALL CALBAS
 290+ 5684 ~            	PUSH DE
 291+ 5684 ~            	; ending )
 292+ 5684 ~            	CALL CHKCHAR
 293+ 5684 ~            	DB ')'
 294+ 5684 ~
 295+ 5684 ~                ; save position in BASIC text
 296+ 5684 ~            	PUSH HL
 297+ 5684 ~            	POP IX
 298+ 5684 ~
 299+ 5684 ~            	POP BC ; count
 300+ 5684 ~            	POP DE ; destination
 301+ 5684 ~            	POP HL ; source
 302+ 5684 ~            	EXX
 303+ 5684 ~            	LD IY, .RET
 304+ 5684 ~            	JP ENABLE_PAGE0
 305+ 5684 ~            .RET:
 306+ 5684 ~            	EI
 307+ 5684 ~            	EXX
 308+ 5684 ~            	CALL VRAM_LDIRMV
 309+ 5684 ~                POP DE
 310+ 5684 ~                POP BC
 311+ 5684 ~                CALL RESTORE_PAGE_INFO
 312+ 5684 ~            	PUSH IX
 313+ 5684 ~            	POP HL
 314+ 5684 ~            	RET
 315+ 5684 ~            ; *******************************************************************************************************
 316+ 5684               ENDIF
 317+ 5684
 318+ 5684               IF (1 == 1)
 319+ 5684              ; *******************************************************************************************************
 320+ 5684              ; same as VRMMEM but for DEFUSR approach
 321+ 5684              ; input IX=pointer to input array, real data from +2
 322+ 5684              ; +2 = source address
 323+ 5684              ; +4 = destination address
 324+ 5684              ; +6 = count
 325+ 5684              VRMMEM_DEFUSR:
 326+ 5684              	; enable page 0
 327+ 5684 FD 21 8B 56  	LD IY, .RET
 328+ 5688 C3 CB 5E     	JP ENABLE_PAGE0
 329+ 568B              .RET:
 330+ 568B FB           	EI
 331+ 568C DD 6E 02     	LD L,(IX+2)
 332+ 568F DD 66 03     	LD H,(IX+3)
 333+ 5692 DD 5E 04     	LD E,(IX+4)
 334+ 5695 DD 56 05     	LD D,(IX+5)
 335+ 5698 DD 4E 06     	LD C,(IX+6)
 336+ 569B DD 46 07     	LD B,(IX+7)
 337+ 569E CD A6 56     	CALL VRAM_LDIRMV
 338+ 56A1 D1               POP DE
 339+ 56A2 C1               POP BC
 340+ 56A3 C3 42 5E         JP RESTORE_PAGE_INFO
 341+ 56A6              ; *******************************************************************************************************
 342+ 56A6               ENDIF
 343+ 56A6
 344+ 56A6              ; *******************************************************************************************************
 345+ 56A6              ; common code to copy from VRAM to RAM
 346+ 56A6              ; input HL=VRAM source
 347+ 56A6              ; input DE=RAM destination
 348+ 56A6              ; BC=count
 349+ 56A6              VRAM_LDIRMV:
 350+ 56A6 3E 01        	LD A,1
 351+ 56A8 32 B2 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 352+ 56AB 7D           	LD	A, L
 353+ 56AC F3           	DI
 354+ 56AD D3 99        	OUT	(099H), A
 355+ 56AF 7C           	LD	A, H
 356+ 56B0 E6 3F        	AND	03FH
 357+ 56B2 00           	NOP ; too fast VDP access per openMSX
 358+ 56B3 D3 99        	OUT	(099H), A
 359+ 56B5 FB           	EI
 360+ 56B6 00           	NOP
 361+ 56B7 00           	NOP
 362+ 56B8 00           	NOP ; too fast VDP access per openMSX
 363+ 56B9              .L4:
 364+ 56B9 DB 98            IN A, (#98)
 365+ 56BB 12           	LD (DE), A
 366+ 56BC 13               INC DE
 367+ 56BD 0B               DEC BC
 368+ 56BE 79               LD A, C
 369+ 56BF B0               OR B
 370+ 56C0 20 F7            JR NZ, .L4
 371+ 56C2 AF           	XOR A
 372+ 56C3 32 B2 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 373+ 56C6 C9               RET
 374+ 56C7              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
 147  56C7               ENDIF
 148  56C7
 149  56C7               IF (GENCAL_CMD == 1)
 150  56C7               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
   1+ 56C7               IF (1 == 1)
   2+ 56C7              ; *******************************************************************************************************
   3+ 56C7              ; same as GENCAL but for DEFUSR approach
   4+ 56C7              ; input IX=pointer to input array, real data from +2
   5+ 56C7              ; +2 = function address to call
   6+ 56C7              ; +4 = register list array pointer
   7+ 56C7              GENCAL_DEFUSR:
   8+ 56C7 DD 6E 02         LD L,(IX+2)
   9+ 56CA DD 66 03         LD H,(IX+3)
  10+ 56CD E5               PUSH HL
  11+ 56CE DD 6E 04         LD L,(IX+4)
  12+ 56D1 DD 66 05         LD H,(IX+5)
  13+ 56D4 E5               PUSH HL
  14+ 56D5 18 00            JR GENCAL.COMMON
  15+ 56D7              ; *******************************************************************************************************
  16+ 56D7               ENDIF
  17+ 56D7
  18+ 56D7              ; *******************************************************************************************************
  19+ 56D7              ; function to handle CALL GENCAL basic extension
  20+ 56D7              ; GENCAL ( INT fn_addr, = address of the function to call
  21+ 56D7              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
  22+ 56D7              ; output values of registers will also be stored at reg_list_ptr
  23+ 56D7              GENCAL:
  24+ 56D7               IF (0 == 1)
  25+ 56D7 ~            	; opening (
  26+ 56D7 ~            	CALL CHKCHAR
  27+ 56D7 ~            	DB '('
  28+ 56D7 ~            	; get function address
  29+ 56D7 ~            	LD IX, FRMQNT
  30+ 56D7 ~            	CALL CALBAS
  31+ 56D7 ~            	PUSH DE
  32+ 56D7 ~            	; comma
  33+ 56D7 ~            	CALL CHKCHAR
  34+ 56D7 ~            	DB ','
  35+ 56D7 ~            	; get pointer to register list
  36+ 56D7 ~                LD A,2
  37+ 56D7 ~                LD B,1
  38+ 56D7 ~                LD DE,#0500
  39+ 56D7 ~                CALL GET_BASIC_ARRAY_DATA_POINTER
  40+ 56D7 ~            	PUSH BC
  41+ 56D7 ~            	; ending )
  42+ 56D7 ~            	CALL CHKCHAR
  43+ 56D7 ~            	DB ')'
  44+ 56D7               ENDIF
  45+ 56D7              .COMMON:
  46+ 56D7              	; save BASIC token position
  47+ 56D7 E5           	PUSH HL
  48+ 56D8 D9               EXX
  49+ 56D9 E1           	POP HL ; HL'=next basic token
  50+ 56DA D9               EXX
  51+ 56DB
  52+ 56DB E1               POP HL ; get pointer to register values
  53+ 56DC F3           	DI
  54+ 56DD ED 73 A1 5D      LD (BLIT_STRUCT), SP
  55+ 56E1 F9               LD SP, HL
  56+ 56E2 F1               POP AF
  57+ 56E3 C1               POP BC
  58+ 56E4 D1               POP DE
  59+ 56E5 E1               POP HL
  60+ 56E6 DD E1            POP IX
  61+ 56E8 FD E1            POP IY
  62+ 56EA D9               EXX
  63+ 56EB ED 73 A3 5D      LD (BLIT_STRUCT+2), SP
  64+ 56EF ED 7B A1 5D      LD SP, (BLIT_STRUCT)
  65+ 56F3 FB               EI
  66+ 56F4 D1               POP DE ; get function to call
  67+ 56F5 E5               PUSH HL
  68+ 56F6 CD 11 57         CALL .EXXDECALL
  69+ 56F9 F3               DI
  70+ 56FA ED 73 A1 5D      LD (BLIT_STRUCT), SP
  71+ 56FE ED 7B A3 5D      LD SP, (BLIT_STRUCT+2)
  72+ 5702 FD E5            PUSH IY
  73+ 5704 DD E5            PUSH IX
  74+ 5706 E5               PUSH HL
  75+ 5707 D5               PUSH DE
  76+ 5708 C5               PUSH BC
  77+ 5709 F5               PUSH AF
  78+ 570A ED 7B A1 5D      LD SP, (BLIT_STRUCT)
  79+ 570E FB               EI
  80+ 570F E1               POP HL
  81+ 5710 C9           	RET
  82+ 5711
  83+ 5711              .EXXDECALL:
  84+ 5711 D5               PUSH DE
  85+ 5712 D9               EXX
  86+ 5713 C9               RET
  87+ 5714              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
 151  5714               ENDIF
 152  5714
 153  5714               IF (BOX_CMDS == 1)
 154  5714               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
   1+ 5714              ; *******************************************************************************************************
   2+ 5714              ; generic function to implement rectangle data copy
   3+ 5714              ; should be modified to call appropriate function for memory or vram
   4+ 5714              ; input IX=pointer to following structure
   5+ 5714              ; +00 source data pointer
   6+ 5714              ; +02 num bytes in a row
   7+ 5714              ; +04 number of rows
   8+ 5714              ; +06 source add-to value till next row
   9+ 5714              ; +08 destination address
  10+ 5714              ; +10 destination add-to value till next row
  11+ 5714              ; modifies AF, BC, DE, HL
  12+ 5714              RECTANGLE_COPY:
  13+ 5714 DD 6E 00     	LD L, (IX+0)
  14+ 5717 DD 66 01     	LD H, (IX+1) ; source address
  15+ 571A DD 5E 08     	LD E, (IX+8)
  16+ 571D DD 56 09     	LD D, (IX+9) ; destination
  17+ 5720 DD 46 04     	LD B, (IX+4) ; row number
  18+ 5723              .L1:
  19+ 5723 C5           	PUSH BC
  20+ 5724 E5           		PUSH HL
  21+ 5725 D5           			PUSH DE
  22+ 5726 DD 4E 02     				LD C, (IX+2)
  23+ 5729 DD 46 03     				LD B, (IX+3) ; num bytes in a row
  24+ 572C              .CALL1:
  25+ 572C CD 00 00     				CALL 0 ; set destination address from DE
  26+ 572F              .CALL2:
  27+ 572F CD 00 00     				CALL 0 ; copy data fn
  28+ 5732 E1           			POP HL
  29+ 5733 DD 4E 0A     			LD C, (IX+10)
  30+ 5736 DD 46 0B     			LD B, (IX+11) ; destination add-to
  31+ 5739 09           			ADD HL, BC
  32+ 573A EB           			EX DE, HL
  33+ 573B E1           		POP HL
  34+ 573C DD 4E 06     		LD C, (IX+6)
  35+ 573F DD 46 07     		LD B, (IX+7) ; src add-to
  36+ 5742 09           		ADD HL, BC
  37+ 5743 C1           	POP BC
  38+ 5744 10 DD        	DJNZ .L1
  39+ 5746 C9           	RET
  40+ 5747              ; *******************************************************************************************************
  41+ 5747
  42+ 5747               IF (0 == 1)
  43+ 5747 ~            ; *******************************************************************************************************
  44+ 5747 ~            ; function to handle CALL BOXMEMCPY basic extension
  45+ 5747 ~            ; copies data with window like boundaries within ram
  46+ 5747 ~            ; BOXMEMCPY ( INT source data pointer,
  47+ 5747 ~            ;			  INT source number of bytes in a row,
  48+ 5747 ~            ;			  INT number of rows,
  49+ 5747 ~            ;			  INT source add-to value till next row,
  50+ 5747 ~            ; 			  INT destination pointer,
  51+ 5747 ~            ;			  INT destination add-to value till next row )
  52+ 5747 ~            ; request_data_ptr described in RECTANGLE_COPY
  53+ 5747 ~            ; will put ram in page 0 also, page 1 is already there
  54+ 5747 ~            BOXMEMCPY:
  55+ 5747 ~            	LD DE,BOXMEMCPY_COMMON
  56+ 5747 ~            	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
  57+ 5747 ~            	JP BOX_EXTENSION_PARAMS_COMMON
  58+ 5747               ENDIF
  59+ 5747
  60+ 5747               IF (1 == 1)
  61+ 5747              ; *******************************************************************************************************
  62+ 5747              ; same as BOXMEMCPY but for DEFUSR approach
  63+ 5747              ; input IX=pointer to input array, real data from +2
  64+ 5747              ; +02 = source data pointer
  65+ 5747              ; +04 = source number of bytes in a row
  66+ 5747              ; +06 = number of rows
  67+ 5747              ; +08 = source add-to value till next row
  68+ 5747              ; +10 = destination pointer
  69+ 5747              ; +12 = destination add-to value till next row
  70+ 5747              BOXMEMCPY_DEFUSR:
  71+ 5747 21 54 57     	LD HL,BOXMEMCPY_COMMON
  72+ 574A 22 6A 57     	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
  73+ 574D DD 23        	INC IX
  74+ 574F DD 23        	INC IX
  75+ 5751 C3 67 57     	JP BOXCOMMON_DEFUSR
  76+ 5754               ENDIF
  77+ 5754
  78+ 5754              BOXMEMCPY_COMMON:
  79+ 5754 FB           	EI
  80+ 5755              	; set RAM functions to call
  81+ 5755 21 00 00     	LD HL, 0
  82+ 5758 22 2C 57     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
  83+ 575B 22 2E 57     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
  84+ 575E 21 ED B0     	LD HL, #B0ED ; LDIR
  85+ 5761 22 30 57     	LD (RECTANGLE_COPY.CALL1+4), HL
  86+ 5764 C3 6F 57     	JP BOXCOMMON_DEFUSR.CALL
  87+ 5767              ; *******************************************************************************************************
  88+ 5767
  89+ 5767               IF (0 == 1)
  90+ 5767 ~            ; *******************************************************************************************************
  91+ 5767 ~            ; common parts of BOX commands to load parameters
  92+ 5767 ~            BOX_EXTENSION_PARAMS_COMMON:
  93+ 5767 ~            	; opening (
  94+ 5767 ~            	CALL CHKCHAR
  95+ 5767 ~            	DB '('
  96+ 5767 ~            	; get source data pointer
  97+ 5767 ~            	LD IX, FRMQNT
  98+ 5767 ~            	CALL CALBAS
  99+ 5767 ~            	LD (BLIT_STRUCT+0), DE
 100+ 5767 ~            	; comma
 101+ 5767 ~            	CALL CHKCHAR
 102+ 5767 ~            	DB ','
 103+ 5767 ~            	; source number of bytes in a row
 104+ 5767 ~            	LD IX, FRMQNT
 105+ 5767 ~            	CALL CALBAS
 106+ 5767 ~            	LD (BLIT_STRUCT+2), DE
 107+ 5767 ~            	; comma
 108+ 5767 ~            	CALL CHKCHAR
 109+ 5767 ~            	DB ','
 110+ 5767 ~            	; number of rows
 111+ 5767 ~            	LD IX, FRMQNT
 112+ 5767 ~            	CALL CALBAS
 113+ 5767 ~            	LD (BLIT_STRUCT+4), DE
 114+ 5767 ~            	; comma
 115+ 5767 ~            	CALL CHKCHAR
 116+ 5767 ~            	DB ','
 117+ 5767 ~            	; source add-to value till next row
 118+ 5767 ~            	LD IX, FRMQNT
 119+ 5767 ~            	CALL CALBAS
 120+ 5767 ~            	LD (BLIT_STRUCT+6), DE
 121+ 5767 ~            	; comma
 122+ 5767 ~            	CALL CHKCHAR
 123+ 5767 ~            	DB ','
 124+ 5767 ~            	; destination pointer
 125+ 5767 ~            	LD IX, FRMQNT
 126+ 5767 ~            	CALL CALBAS
 127+ 5767 ~            	LD (BLIT_STRUCT+8), DE
 128+ 5767 ~            	; comma
 129+ 5767 ~            	CALL CHKCHAR
 130+ 5767 ~            	DB ','
 131+ 5767 ~            	; destination add-to value till next row
 132+ 5767 ~            	LD IX, FRMQNT
 133+ 5767 ~            	CALL CALBAS
 134+ 5767 ~            	LD (BLIT_STRUCT+10), DE
 135+ 5767 ~            	; ending )
 136+ 5767 ~            	CALL CHKCHAR
 137+ 5767 ~            	DB ')'
 138+ 5767 ~            	LD IX,BLIT_STRUCT
 139+ 5767               ENDIF
 140+ 5767              BOXCOMMON_DEFUSR:
 141+ 5767 E5           	PUSH HL ; save position in BASIC buffer
 142+ 5768              .ADDR:
 143+ 5768 FD 21 00 00  	LD IY, 0 ; modified by code
 144+ 576C C3 CB 5E     	JP ENABLE_PAGE0
 145+ 576F              .CALL:
 146+ 576F CD 14 57     	CALL RECTANGLE_COPY
 147+ 5772 AF           	XOR A
 148+ 5773 32 B2 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 149+ 5776
 150+ 5776 D1               POP DE
 151+ 5777 C1               POP BC
 152+ 5778 CD 42 5E         CALL RESTORE_PAGE_INFO
 153+ 577B
 154+ 577B E1           	POP HL
 155+ 577C C9           	RET
 156+ 577D              ; *******************************************************************************************************
 157+ 577D
 158+ 577D               IF (0 == 1)
 159+ 577D ~            ; *******************************************************************************************************
 160+ 577D ~            ; function to handle CALL BOXMEMVRM basic extension
 161+ 577D ~            ; copies data with window like boundaries from ram to Vram
 162+ 577D ~            ; BOXMEMVRM ( INT source data pointer,
 163+ 577D ~            ;			  INT source number of bytes in a row,
 164+ 577D ~            ;			  INT number of rows,
 165+ 577D ~            ;			  INT source add-to value till next row,
 166+ 577D ~            ; 			  INT destination pointer,
 167+ 577D ~            ;			  INT destination add-to value till next row )
 168+ 577D ~            ; request_data_ptr described in RECTANGLE_COPY
 169+ 577D ~            ; will put ram in page 0 also, page 1 is already there
 170+ 577D ~            BOXMEMVRM:
 171+ 577D ~            	LD DE,BOXMEMVRM_COMMON
 172+ 577D ~            	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
 173+ 577D ~            	JP BOX_EXTENSION_PARAMS_COMMON
 174+ 577D               ENDIF
 175+ 577D
 176+ 577D               IF (1 == 1)
 177+ 577D              ; *******************************************************************************************************
 178+ 577D              ; same as BOXMEMVRM but for DEFUSR approach
 179+ 577D              ; input IX=pointer to input array, real data from +2
 180+ 577D              ; +02 = source data pointer
 181+ 577D              ; +04 = source number of bytes in a row
 182+ 577D              ; +06 = number of rows
 183+ 577D              ; +08 = source add-to value till next row
 184+ 577D              ; +10 = destination pointer
 185+ 577D              ; +12 = destination add-to value till next row
 186+ 577D              BOXMEMVRM_DEFUSR:
 187+ 577D 21 8A 57     	LD HL,BOXMEMVRM_COMMON
 188+ 5780 22 6A 57     	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
 189+ 5783 DD 23        	INC IX
 190+ 5785 DD 23        	INC IX
 191+ 5787 C3 67 57     	JP BOXCOMMON_DEFUSR
 192+ 578A               ENDIF
 193+ 578A
 194+ 578A              BOXMEMVRM_COMMON:
 195+ 578A FB           	EI
 196+ 578B              	; set RAM functions to call
 197+ 578B 21 A5 57     	LD HL, .SETDEST
 198+ 578E 22 2D 57     	LD (RECTANGLE_COPY.CALL1+1), HL
 199+ 5791 21 AD 57     	LD HL, .COPYDATA
 200+ 5794 22 30 57     	LD (RECTANGLE_COPY.CALL2+1), HL
 201+ 5797 3E CD        	LD A, #CD ; CALL
 202+ 5799 32 2C 57     	LD (RECTANGLE_COPY.CALL1), A
 203+ 579C 32 2F 57     	LD (RECTANGLE_COPY.CALL2), A
 204+ 579F              	;LD A,1
 205+ 579F 32 B2 5D     	LD (VRAM_UPDATE_IN_PROGRESS),A
 206+ 57A2 C3 6F 57     	JP BOXCOMMON_DEFUSR.CALL
 207+ 57A5              .SETDEST:
 208+ 57A5 EB           	EX DE, HL
 209+ 57A6 F3           	DI
 210+ 57A7 CD F2 5D     	CALL SETWRT_LOCAL
 211+ 57AA FB           	EI
 212+ 57AB EB           	EX DE, HL
 213+ 57AC C9           	RET
 214+ 57AD              .COPYDATA:
 215+ 57AD 41           	LD B, C
 216+ 57AE C3 FD 5D     	JP BBYTECOPY
 217+ 57B1              ; *******************************************************************************************************
# file closed: asm\BOX.asm
 155  57B1               ENDIF
 156  57B1
 157  57B1               IF (BLIT_CMDS == 1)
 158  57B1               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
   1+ 57B1              ; *******************************************************************************************************
   2+ 57B1              ; function rotates mask and data of several characters and applies to background data
   3+ 57B1              ; this handles x-shift from 0 to 4
   4+ 57B1              ; contains self-modifying code that is set-up from external function
   5+ 57B1              ; input HL=pointer to mask data
   6+ 57B1              ; input HL'=pointer to character data
   7+ 57B1              ; input DE=output buffer containing background data
   8+ 57B1              ; input BC=DE+8
   9+ 57B1              ; input A=number of characters to process
  10+ 57B1              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  11+ 57B1              SHIFT04:
  12+ 57B1 08           	EX AF, AF'
  13+ 57B2 7E           	LD A, (HL) ; get mask
  14+ 57B3 D9           	EXX
  15+ 57B4 57           	LD D, A
  16+ 57B5 1E FF        	LD E, #FF
  17+ 57B7 37           	SCF
  18+ 57B8              .M1:
  19+ 57B8 18 FE        	JR .M1 ; this is self-modifying part
  20+ 57BA CB 1A        	RR D
  21+ 57BC CB 1B        	RR E
  22+ 57BE CB 1A        	RR D
  23+ 57C0 CB 1B        	RR E
  24+ 57C2 CB 1A        	RR D
  25+ 57C4 CB 1B        	RR E
  26+ 57C6 CB 1A        	RR D
  27+ 57C8 CB 1B        	RR E
  28+ 57CA
  29+ 57CA 46           	LD B, (HL) ; get data
  30+ 57CB 0E 00        	LD C, 0
  31+ 57CD              .M2:
  32+ 57CD 18 FE        	JR .M2 ; also self-modifying part
  33+ 57CF CB 38        	SRL B
  34+ 57D1 CB 19        	RR C
  35+ 57D3 CB 38        	SRL B
  36+ 57D5 CB 19        	RR C
  37+ 57D7 CB 38        	SRL B
  38+ 57D9 CB 19        	RR C
  39+ 57DB CB 38        	SRL B
  40+ 57DD CB 19        	RR C
  41+ 57DF
  42+ 57DF D9           	EXX
  43+ 57E0 1A           	LD A, (DE) ; background
  44+ 57E1 D9           	EXX
  45+ 57E2 A2           	AND D
  46+ 57E3 B0           	OR B
  47+ 57E4 D9           	EXX
  48+ 57E5 12           	LD (DE), A
  49+ 57E6
  50+ 57E6 0A           	LD A, (BC)
  51+ 57E7 D9           	EXX
  52+ 57E8 A3           	AND E
  53+ 57E9 B1           	OR C
  54+ 57EA 23           	INC HL
  55+ 57EB D9           	EXX
  56+ 57EC 02           	LD (BC), A
  57+ 57ED
  58+ 57ED 23           	INC HL
  59+ 57EE 13           	INC DE
  60+ 57EF 03           	INC BC
  61+ 57F0
  62+ 57F0 08           	EX AF, AF'
  63+ 57F1 3D           	DEC A
  64+ 57F2 C2 B1 57     	JP NZ, SHIFT04
  65+ 57F5 C9           	RET
  66+ 57F6              ; *******************************************************************************************************
  67+ 57F6
  68+ 57F6              ; *******************************************************************************************************
  69+ 57F6              ; function rotates mask and data of several characters and applies to background data
  70+ 57F6              ; this handles x-shift from 5 to 8
  71+ 57F6              ; contains self-modifying code that is set-up from external function
  72+ 57F6              ; input HL=pointer to mask data
  73+ 57F6              ; input HL'=pointer to character data
  74+ 57F6              ; input DE=output buffer containing background data
  75+ 57F6              ; input BC=DE+8
  76+ 57F6              ; input A=number of characters to process
  77+ 57F6              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  78+ 57F6              SHIFT58:
  79+ 57F6 08           	EX AF, AF'
  80+ 57F7 7E           	LD A, (HL) ; get mask
  81+ 57F8 D9           	EXX
  82+ 57F9 57           	LD D, A
  83+ 57FA 1E FF        	LD E, #FF
  84+ 57FC 37           	SCF
  85+ 57FD              .M1:
  86+ 57FD 18 FE        	JR .M1 ; this is self-modifying part
  87+ 57FF CB 12        	RL D
  88+ 5801 CB 13        	RL E
  89+ 5803 CB 12        	RL D
  90+ 5805 CB 13        	RL E
  91+ 5807 CB 12        	RL D
  92+ 5809 CB 13        	RL E
  93+ 580B
  94+ 580B 46           	LD B, (HL)
  95+ 580C 0E 00        	LD C, 0
  96+ 580E              .M2:
  97+ 580E 18 FE        	JR .M2 ; also self-modifying part
  98+ 5810 CB 20        	SLA B
  99+ 5812 CB 11        	RL C
 100+ 5814 CB 20        	SLA B
 101+ 5816 CB 11        	RL C
 102+ 5818 CB 20        	SLA B
 103+ 581A CB 11        	RL C
 104+ 581C
 105+ 581C D9           	EXX
 106+ 581D 1A           	LD A, (DE) ; background
 107+ 581E D9           	EXX
 108+ 581F A3           	AND E
 109+ 5820 B1           	OR C
 110+ 5821 D9           	EXX
 111+ 5822 12           	LD (DE), A
 112+ 5823
 113+ 5823 0A           	LD A, (BC)
 114+ 5824 D9           	EXX
 115+ 5825 A2           	AND D
 116+ 5826 B0           	OR B
 117+ 5827 23           	INC HL
 118+ 5828 D9           	EXX
 119+ 5829 02           	LD (BC), A
 120+ 582A
 121+ 582A 23           	INC HL
 122+ 582B 13           	INC DE
 123+ 582C 03           	INC BC
 124+ 582D
 125+ 582D 08           	EX AF, AF'
 126+ 582E 3D           	DEC A
 127+ 582F C2 F6 57     	JP NZ, SHIFT58
 128+ 5832 C9           	RET
 129+ 5833              ; *******************************************************************************************************
 130+ 5833
 131+ 5833              ; *******************************************************************************************************
 132+ 5833              ; routine that shifts one row of characters
 133+ 5833              ; contains self-modifying code that is set-up from external function
 134+ 5833              ; input HL=pointer to mask data
 135+ 5833              ; input HL'=pointer to character data
 136+ 5833              ; input DE=output buffer containing background data
 137+ 5833              ; input A=number of characters to process
 138+ 5833              ; input IX=pointer to structure describing input data
 139+ 5833              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 140+ 5833              SHIFT_ROW:
 141+ 5833 F5           	PUSH AF
 142+ 5834 ED 53 9D 5D  		LD (BLIT_TMP1), DE
 143+ 5838 E5           		PUSH HL
 144+ 5839 CD 7C 58     			CALL .ADDYSHIFT
 145+ 583C E1           		POP HL
 146+ 583D ED 53 9F 5D  		LD (BLIT_TMP2), DE ; DE+vertical shift
 147+ 5841              .L1:
 148+ 5841 3E 08        		LD A, 8
 149+ 5843 DD 96 02     		SUB (IX+2) ; y shift
 150+ 5846              .CALL1:
 151+ 5846 CD 00 00     		CALL 0
 152+ 5849 DD 7E 02     		LD A, (IX+2); y shift
 153+ 584C B7           		OR A
 154+ 584D 28 26        		JR Z, .DONE
 155+ 584F ED 5B 9D 5D  		LD DE, (BLIT_TMP1)
 156+ 5853 E5           		PUSH HL
 157+ 5854 CD 8A 58     			CALL .DETONEXTROW
 158+ 5857 E1           		POP HL
 159+ 5858              .CALL2:
 160+ 5858 CD 00 00     		CALL 0
 161+ 585B ED 5B 9D 5D  		LD DE, (BLIT_TMP1)
 162+ 585F E5           		PUSH HL
 163+ 5860 CD 84 58     			CALL .ADD8
 164+ 5863 E1           		POP HL
 165+ 5864 ED 53 9D 5D  		LD (BLIT_TMP1), DE
 166+ 5868 ED 5B 9F 5D  		LD DE, (BLIT_TMP2)
 167+ 586C E5           		PUSH HL
 168+ 586D CD 84 58     			CALL .ADD8
 169+ 5870 E1           		POP HL
 170+ 5871 ED 53 9F 5D  		LD (BLIT_TMP2), DE ; DE+vertical shift
 171+ 5875              .DONE:
 172+ 5875 F1           	POP AF
 173+ 5876 3D           	DEC A
 174+ 5877 C8           	RET Z
 175+ 5878 F5           	PUSH AF
 176+ 5879 C3 41 58     	JP .L1
 177+ 587C              .ADDYSHIFT:
 178+ 587C EB           	EX DE, HL
 179+ 587D 16 00        	LD D, 0
 180+ 587F DD 5E 02     	LD E, (IX+2); y shift
 181+ 5882 18 0C        	JR .MOVDEBC
 182+ 5884              .ADD8:
 183+ 5884 21 08 00     	LD HL, 8
 184+ 5887 C3 90 58     	JP .MOVDEBC
 185+ 588A              .DETONEXTROW:
 186+ 588A DD 6E 06     	LD L, (IX+6)
 187+ 588D DD 66 07     	LD H, (IX+7) ; bkg add to value
 188+ 5890              .MOVDEBC:
 189+ 5890 19           	ADD HL, DE
 190+ 5891 54           	LD D, H
 191+ 5892 5D           	LD E, L
 192+ 5893 01 08 00     	LD BC, 8
 193+ 5896 09           	ADD HL, BC
 194+ 5897 44           	LD B, H
 195+ 5898 4D           	LD C, L
 196+ 5899 C9           	RET
 197+ 589A              ; *******************************************************************************************************
 198+ 589A
 199+ 589A              ; *******************************************************************************************************
 200+ 589A              ; function rotates mask and character data and applies it to background
 201+ 589A              ; input IX=pointer to structure describing input data
 202+ 589A              ; +0  DW horizontal shift count 0-7 (low byte used)
 203+ 589A              ; +2  DW vertical shift count 0-7 (low byte used)
 204+ 589A              ; +4  DW background data start;
 205+ 589A              ; +6  DW background add to value to next row of background data
 206+ 589A              ; +8  DW mask data start;
 207+ 589A              ; +10  DW character data start;
 208+ 589A              ; +12 DW character&mask add to value to next row of data
 209+ 589A              ; +14 DW columns (low byte used)
 210+ 589A              ; +16 DW rows (low byte used)
 211+ 589A              SHIFT_MERGE_CHARACTER:
 212+ 589A DD 7E 00     	LD A, (IX) ; shift
 213+ 589D FE 05        	CP 5
 214+ 589F 38 25        	JR C, .RIGHT
 215+ 58A1              	; shifts 5-7, use rotate towards left 1-3
 216+ 58A1 21 F6 57     	LD HL, SHIFT58
 217+ 58A4 22 47 58     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 218+ 58A7 22 59 58     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 219+ 58AA D6 05        	SUB 5
 220+ 58AC 28 0D        	JR Z, .L1
 221+ 58AE 87           	ADD A, A
 222+ 58AF 87           	ADD A, A
 223+ 58B0 67           	LD H, A
 224+ 58B1 2E 18        	LD L, #18 ; JR opcode
 225+ 58B3 22 FD 57     	LD (SHIFT58.M1), HL
 226+ 58B6 22 0E 58     	LD (SHIFT58.M2), HL
 227+ 58B9 18 32        	JR .DO
 228+ 58BB              .L1:
 229+ 58BB 21 00 00     	LD HL, 0 ; 2xNOP opcode
 230+ 58BE 22 FD 57     	LD (SHIFT58.M1), HL
 231+ 58C1 22 0E 58     	LD (SHIFT58.M2), HL
 232+ 58C4 18 27        	JR .DO
 233+ 58C6              .RIGHT:
 234+ 58C6              	; shifts 0-4, rotate towards right
 235+ 58C6 21 B1 57     	LD HL, SHIFT04
 236+ 58C9 22 47 58     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 237+ 58CC 22 59 58     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 238+ 58CF FE 04        	CP 4
 239+ 58D1 28 11        	JR Z, .R1
 240+ 58D3 D6 04        	SUB 4
 241+ 58D5 ED 44        	NEG
 242+ 58D7 87           	ADD A, A
 243+ 58D8 87           	ADD A, A
 244+ 58D9 67           	LD H, A
 245+ 58DA 2E 18        	LD L, #18 ; JR opcode
 246+ 58DC 22 B8 57     	LD (SHIFT04.M1), HL
 247+ 58DF 22 CD 57     	LD (SHIFT04.M2), HL
 248+ 58E2 18 09        	JR .DO
 249+ 58E4              .R1:
 250+ 58E4 21 00 00     	LD HL, 0 ; 2xNOP opcode
 251+ 58E7 22 B8 57     	LD (SHIFT04.M1), HL
 252+ 58EA 22 CD 57     	LD (SHIFT04.M2), HL
 253+ 58ED              .DO:
 254+ 58ED DD 46 10     	LD B, (IX+16) ; rows
 255+ 58F0 DD 6E 08     	LD L, (IX+8)
 256+ 58F3 DD 66 09     	LD H, (IX+9) ; mask data
 257+ 58F6 DD 5E 04     	LD E, (IX+4)
 258+ 58F9 DD 56 05     	LD D, (IX+5) ; background data
 259+ 58FC D9           	EXX
 260+ 58FD DD 6E 0A     	LD L, (IX+10)
 261+ 5900 DD 66 0B     	LD H, (IX+11) ; character data
 262+ 5903 D9           	EXX
 263+ 5904              .LOOP:
 264+ 5904 C5           	PUSH BC
 265+ 5905 E5           		PUSH HL
 266+ 5906 D5           			PUSH DE
 267+ 5907 D9           				EXX
 268+ 5908 E5           				PUSH HL
 269+ 5909 D9           					EXX
 270+ 590A DD 7E 0E     					LD A, (IX+14) ; columns
 271+ 590D              .CALL:
 272+ 590D CD 33 58     					CALL SHIFT_ROW
 273+ 5910 E1           				POP HL
 274+ 5911 DD 5E 0C     				LD E, (IX+12)
 275+ 5914 DD 56 0D     				LD D, (IX+13) ; char data to next row
 276+ 5917 19           				ADD HL, DE
 277+ 5918 D9           				EXX
 278+ 5919 E1           			POP HL
 279+ 591A DD 5E 06     			LD E, (IX+6)
 280+ 591D DD 56 07     			LD D, (IX+7) ; background to next row
 281+ 5920 19           			ADD HL, DE
 282+ 5921 EB           			EX DE, HL
 283+ 5922 E1           		POP HL
 284+ 5923 DD 4E 0C     		LD C, (IX+12)
 285+ 5926 DD 46 0D     		LD B, (IX+13) ; char data to next row
 286+ 5929 09           		ADD HL, BC
 287+ 592A C1           	POP BC
 288+ 592B 10 D7        	DJNZ .LOOP
 289+ 592D C9           	RET
 290+ 592E              ; *******************************************************************************************************
 291+ 592E
 292+ 592E              ; *******************************************************************************************************
 293+ 592E              ; helper function DE \ 8
 294+ 592E              DEdiv8:
 295+ 592E 7B           	LD A,E
 296+ 592F CB 2A        	SRA D
 297+ 5931 CB 1F            RR  A
 298+ 5933 CB 2A            SRA D
 299+ 5935 CB 1F            RR  A
 300+ 5937 CB 2A            SRA D
 301+ 5939 CB 1F            RR  A
 302+ 593B C9           	RET
 303+ 593C              ; *******************************************************************************************************
 304+ 593C
 305+ 593C               IF (1 == 1)
 306+ 593C              ; *******************************************************************************************************
 307+ 593C              ; function to handle BLIT basic extension through DEFUSR call in RAW format
 308+ 593C              ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 309+ 593C              ; +2  DW horizontal shift count 0-7 (low byte used)
 310+ 593C              ; +4  DW vertical shift count 0-7 (low byte used)
 311+ 593C              ; +6  DW background data start;
 312+ 593C              ; +8  DW background add to value to next row of background data
 313+ 593C              ; +10  DW mask data start;
 314+ 593C              ; +12  DW character data start;
 315+ 593C              ; +14 DW character&mask add to value to next row of data
 316+ 593C              ; +16 DW columns (low byte used)
 317+ 593C              ; +18 DW rows (low byte used)
 318+ 593C              ; will put ram in page 0 also, page 1 is already there
 319+ 593C              ;BLIT_DEFUSR:
 320+ 593C              ;	DI
 321+ 593C              ;	LD IY, .RET
 322+ 593C              ;	JP ENABLE_PAGE0
 323+ 593C              ;.RET:
 324+ 593C              ;	EI
 325+ 593C              ;	INC IX
 326+ 593C              ;	INC IX
 327+ 593C              ;	CALL SHIFT_MERGE_CHARACTER
 328+ 593C              ;
 329+ 593C              ;   POP DE
 330+ 593C              ;    POP BC
 331+ 593C              ;    JP RESTORE_PAGE_INFO
 332+ 593C              ; *******************************************************************************************************
 333+ 593C
 334+ 593C              ; *******************************************************************************************************
 335+ 593C              ; function to handle CALL BLIT basic extension in DEFUSR form
 336+ 593C              ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 337+ 593C              ; +02 x
 338+ 593C              ; +04 y
 339+ 593C              ; +06 char_data_pointer
 340+ 593C              ; +08 mask_data_pointer
 341+ 593C              ; +10 width
 342+ 593C              ; +12 height
 343+ 593C              ; +14 background_pointer
 344+ 593C              ; +16 background_width
 345+ 593C              ; BLIT ( INT x,
 346+ 593C              ;		 INT y,
 347+ 593C              ;		 INT char_data_pointer,
 348+ 593C              ;		 INT mask_data_pointer,
 349+ 593C              ;		 INT width (in characters),
 350+ 593C              ;		 INT height (in characters),
 351+ 593C              ;		 INT background_pointer (top left),
 352+ 593C              ;		 INT background_width (in characters),
 353+ 593C              BLIT_DEFUSR:
 354+ 593C DD 5E 02     	LD E,(IX+2)
 355+ 593F DD 56 03     	LD D,(IX+3)
 356+ 5942 7B           	LD A,E
 357+ 5943 E6 07        	AND 7
 358+ 5945 32 A1 5D     	LD (BLIT_STRUCT+0),A
 359+ 5948 CD 2E 59     	CALL DEdiv8
 360+ 594B 32 9D 5D     	LD (BLIT_TMP+0),A
 361+ 594E DD 5E 04     	LD E,(IX+4)
 362+ 5951 DD 56 05     	LD D,(IX+5)
 363+ 5954 7B           	LD A,E
 364+ 5955 E6 07        	AND 7
 365+ 5957 32 A3 5D     	LD (BLIT_STRUCT+2),A
 366+ 595A CD 2E 59     	CALL DEdiv8
 367+ 595D 32 9E 5D     	LD (BLIT_TMP+1),A
 368+ 5960 DD 6E 06     	LD L,(IX+6)
 369+ 5963 DD 66 07     	LD H,(IX+7)
 370+ 5966 22 AB 5D     	LD (BLIT_STRUCT+10),HL
 371+ 5969 DD 6E 08     	LD L,(IX+8)
 372+ 596C DD 66 09     	LD H,(IX+9)
 373+ 596F 22 A9 5D     	LD (BLIT_STRUCT+8),HL
 374+ 5972 DD 7E 0A     	LD A,(IX+10)
 375+ 5975 32 AF 5D     	LD (BLIT_STRUCT+14),A
 376+ 5978 DD 7E 0C     	LD A,(IX+12)
 377+ 597B 32 B1 5D     	LD (BLIT_STRUCT+16),A
 378+ 597E DD 6E 0E     	LD L,(IX+14)
 379+ 5981 DD 66 0F     	LD H,(IX+15)
 380+ 5984 22 A5 5D     	LD (BLIT_STRUCT+4),HL
 381+ 5987              	;LD A,(IX+16)
 382+ 5987              	;LD (BLIT_TMP+2),A
 383+ 5987
 384+ 5987              	; calculate char&mask add to value
 385+ 5987 26 00        	LD H,0
 386+ 5989 3A AF 5D     	LD A,(BLIT_STRUCT+14)
 387+ 598C 6F           	LD L,A
 388+ 598D CD 07 5E     	CALL HLx8
 389+ 5990 22 AD 5D     	LD (BLIT_STRUCT+12),HL
 390+ 5993              	; calculate background add to value
 391+ 5993 26 00        	LD H,0
 392+ 5995 DD 6E 10     	LD L,(IX+16)
 393+ 5998 CD 07 5E     	CALL HLx8
 394+ 599B 22 A7 5D     	LD (BLIT_STRUCT+6),HL
 395+ 599E              	; calculate pointer to background location
 396+ 599E 21 00 00     	LD HL,0
 397+ 59A1 3A 9E 5D     	LD A,(BLIT_TMP+1)
 398+ 59A4 B7           	OR A
 399+ 59A5 28 08        	JR Z, .L1
 400+ 59A7 47           	LD B,A
 401+ 59A8 ED 5B A7 5D  	LD DE,(BLIT_STRUCT+6)
 402+ 59AC              .L0:
 403+ 59AC 19           	ADD HL, DE
 404+ 59AD 10 FD        	DJNZ .L0
 405+ 59AF              .L1:
 406+ 59AF EB           	EX DE,HL
 407+ 59B0 26 00        	LD H,0
 408+ 59B2 3A 9D 5D     	LD A,(BLIT_TMP+0)
 409+ 59B5 6F           	LD L,A
 410+ 59B6 CD 07 5E     	CALL HLx8
 411+ 59B9 19           	ADD HL,DE
 412+ 59BA ED 5B A5 5D  	LD DE,(BLIT_STRUCT+4)
 413+ 59BE 19           	ADD HL,DE
 414+ 59BF 22 A5 5D     	LD (BLIT_STRUCT+4),HL
 415+ 59C2
 416+ 59C2 FD 21 C9 59  	LD IY, .RET
 417+ 59C6 C3 CB 5E     	JP ENABLE_PAGE0
 418+ 59C9              .RET:
 419+ 59C9 FB           	EI
 420+ 59CA DD 21 A1 5D  	LD IX, BLIT_STRUCT
 421+ 59CE CD 9A 58     	CALL SHIFT_MERGE_CHARACTER
 422+ 59D1
 423+ 59D1 D1               POP DE
 424+ 59D2 C1               POP BC
 425+ 59D3 C3 42 5E         JP RESTORE_PAGE_INFO
 426+ 59D6              ; *******************************************************************************************************
 427+ 59D6               ENDIF
 428+ 59D6
 429+ 59D6               IF (0 == 1)
 430+ 59D6 ~            ; *******************************************************************************************************
 431+ 59D6 ~            ; function to handle CALL BLIT basic extension
 432+ 59D6 ~            ; rotates 1-bit character drawing horizontally with mask and character data and
 433+ 59D6 ~            ; fuses with background data and applies vertical shift too
 434+ 59D6 ~            ; in form without pointers
 435+ 59D6 ~            ; BLIT ( INT x,
 436+ 59D6 ~            ;		 INT y,
 437+ 59D6 ~            ;		 INT char_data_pointer,
 438+ 59D6 ~            ;		 INT mask_data_pointer,
 439+ 59D6 ~            ;		 INT width (in characters),
 440+ 59D6 ~            ;		 INT height (in characters),
 441+ 59D6 ~            ;		 INT background_pointer (top left),
 442+ 59D6 ~            ;		 INT background_width (in characters),
 443+ 59D6 ~            ; will put ram in page 0 also, page 1 is already there
 444+ 59D6 ~            BLIT:
 445+ 59D6 ~            	; opening (
 446+ 59D6 ~            	CALL CHKCHAR
 447+ 59D6 ~            	DB '('
 448+ 59D6 ~            	; get x coordinate
 449+ 59D6 ~            	LD IX, FRMQNT
 450+ 59D6 ~            	CALL CALBAS
 451+ 59D6 ~            	LD A, E
 452+ 59D6 ~            	AND 7
 453+ 59D6 ~            	LD (BLIT_STRUCT+0), A
 454+ 59D6 ~            	CALL DEdiv8
 455+ 59D6 ~            	LD (BLIT_TMP+0),A
 456+ 59D6 ~            	; comma
 457+ 59D6 ~            	CALL CHKCHAR
 458+ 59D6 ~            	DB ','
 459+ 59D6 ~            	; get y coordinate
 460+ 59D6 ~            	LD IX, FRMQNT
 461+ 59D6 ~            	CALL CALBAS
 462+ 59D6 ~            	LD A, E
 463+ 59D6 ~            	AND 7
 464+ 59D6 ~            	LD (BLIT_STRUCT+2), A
 465+ 59D6 ~            	CALL DEdiv8
 466+ 59D6 ~            	LD (BLIT_TMP+1),A
 467+ 59D6 ~            	; comma
 468+ 59D6 ~            	CALL CHKCHAR
 469+ 59D6 ~            	DB ','
 470+ 59D6 ~            	; get char data pointer
 471+ 59D6 ~            	LD IX, FRMQNT
 472+ 59D6 ~            	CALL CALBAS
 473+ 59D6 ~            	LD (BLIT_STRUCT+10), DE
 474+ 59D6 ~            	; comma
 475+ 59D6 ~            	CALL CHKCHAR
 476+ 59D6 ~            	DB ','
 477+ 59D6 ~            	; get mask data pointer
 478+ 59D6 ~            	LD IX, FRMQNT
 479+ 59D6 ~            	CALL CALBAS
 480+ 59D6 ~            	LD (BLIT_STRUCT+8), DE
 481+ 59D6 ~            	; comma
 482+ 59D6 ~            	CALL CHKCHAR
 483+ 59D6 ~            	DB ','
 484+ 59D6 ~            	; get width
 485+ 59D6 ~            	LD IX, FRMQNT
 486+ 59D6 ~            	CALL CALBAS
 487+ 59D6 ~            	LD A, E
 488+ 59D6 ~            	LD (BLIT_STRUCT+14), A
 489+ 59D6 ~            	; comma
 490+ 59D6 ~            	CALL CHKCHAR
 491+ 59D6 ~            	DB ','
 492+ 59D6 ~            	; get height
 493+ 59D6 ~            	LD IX, FRMQNT
 494+ 59D6 ~            	CALL CALBAS
 495+ 59D6 ~            	LD A, E
 496+ 59D6 ~            	LD (BLIT_STRUCT+16), A
 497+ 59D6 ~            	; comma
 498+ 59D6 ~            	CALL CHKCHAR
 499+ 59D6 ~            	DB ','
 500+ 59D6 ~            	; get background pointer
 501+ 59D6 ~            	LD IX, FRMQNT
 502+ 59D6 ~            	CALL CALBAS
 503+ 59D6 ~            	LD (BLIT_STRUCT+4), DE
 504+ 59D6 ~            	; comma
 505+ 59D6 ~            	CALL CHKCHAR
 506+ 59D6 ~            	DB ','
 507+ 59D6 ~            	; get background width
 508+ 59D6 ~            	LD IX, FRMQNT
 509+ 59D6 ~            	CALL CALBAS
 510+ 59D6 ~            	LD A, E
 511+ 59D6 ~            	LD (BLIT_TMP+2), A
 512+ 59D6 ~            	; ending )
 513+ 59D6 ~            	CALL CHKCHAR
 514+ 59D6 ~            	DB ')'
 515+ 59D6 ~
 516+ 59D6 ~            	PUSH HL ; save position in BASIC buffer
 517+ 59D6 ~
 518+ 59D6 ~            	; calculate char&mask add to value
 519+ 59D6 ~            	LD H, 0
 520+ 59D6 ~            	LD A, (BLIT_STRUCT+14)
 521+ 59D6 ~            	LD L, A
 522+ 59D6 ~            	CALL HLx8
 523+ 59D6 ~            	LD (BLIT_STRUCT+12), HL
 524+ 59D6 ~            	; calculate background add to value
 525+ 59D6 ~            	LD H, 0
 526+ 59D6 ~            	LD A, (BLIT_TMP+2)
 527+ 59D6 ~            	LD L, A
 528+ 59D6 ~            	CALL HLx8
 529+ 59D6 ~            	LD (BLIT_STRUCT+6), HL
 530+ 59D6 ~            	; calculate pointer to background location
 531+ 59D6 ~            	LD HL, 0
 532+ 59D6 ~            	LD A,(BLIT_TMP+1)
 533+ 59D6 ~            	OR A
 534+ 59D6 ~            	JR Z, .L1
 535+ 59D6 ~            	LD B,A
 536+ 59D6 ~            	LD DE,(BLIT_STRUCT+6)
 537+ 59D6 ~            .L0:
 538+ 59D6 ~            	ADD HL, DE
 539+ 59D6 ~            	DJNZ .L0
 540+ 59D6 ~            .L1:
 541+ 59D6 ~            	EX DE,HL
 542+ 59D6 ~            	LD H,0
 543+ 59D6 ~            	LD A,(BLIT_TMP+0)
 544+ 59D6 ~            	LD L,A
 545+ 59D6 ~            	CALL HLx8
 546+ 59D6 ~            	ADD HL,DE
 547+ 59D6 ~            	LD DE,(BLIT_STRUCT+4)
 548+ 59D6 ~            	ADD HL,DE
 549+ 59D6 ~            	LD (BLIT_STRUCT+4),HL
 550+ 59D6 ~
 551+ 59D6 ~            	LD IY, .RET
 552+ 59D6 ~            	JP ENABLE_PAGE0
 553+ 59D6 ~            .RET:
 554+ 59D6 ~            	EI
 555+ 59D6 ~            	LD IX, BLIT_STRUCT
 556+ 59D6 ~            	CALL SHIFT_MERGE_CHARACTER
 557+ 59D6 ~
 558+ 59D6 ~                POP DE
 559+ 59D6 ~                POP BC
 560+ 59D6 ~                CALL RESTORE_PAGE_INFO
 561+ 59D6 ~
 562+ 59D6 ~            	POP HL
 563+ 59D6 ~            	RET
 564+ 59D6 ~            ; *******************************************************************************************************
 565+ 59D6               ENDIF
# file closed: asm\BLIT.asm
 159  59D6               ENDIF
 160  59D6
 161  59D6               IF (TILE_CMDS == 1)
 162  59D6               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
   1+ 59D6              ; *******************************************************************************************************
   2+ 59D6              ; generic function to implement tiling
   3+ 59D6              ; should be modified to call appropriate function for memory or vram
   4+ 59D6              ; input IX=pointer to following structure
   5+ 59D6              ; +00 tile_data_ptr
   6+ 59D6              ; +02 tile_rows
   7+ 59D6              ; +04 tile_columns
   8+ 59D6              ; +06 destination_address
   9+ 59D6              ; +08 dest_to_next_row_add_to_value
  10+ 59D6              ; +10 num_horizontal_tiles
  11+ 59D6              ; +12 num_vertical_tiles
  12+ 59D6              ; modifies AF, BC, DE, HL
  13+ 59D6              TILE:
  14+ 59D6 DD 6E 06     	LD L, (IX+6)
  15+ 59D9 DD 66 07     	LD H, (IX+7) ; destination address
  16+ 59DC 22 9D 5D     	LD (TILETMP1), HL
  17+ 59DF DD 46 0C     	LD B, (IX+12) ; vertical tile number
  18+ 59E2              .L1:
  19+ 59E2 C5           	PUSH BC
  20+ 59E3 DD 6E 00     		LD L, (IX+0)
  21+ 59E6 DD 66 01     		LD H, (IX+1) ; tile address
  22+ 59E9 22 9F 5D     		LD (TILETMP2), HL
  23+ 59EC DD 46 02     		LD B, (IX+2) ; tile rows
  24+ 59EF              .L2:
  25+ 59EF C5           		PUSH BC
  26+ 59F0 CD 00 00     .CALL1:		CALL 0
  27+ 59F3 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
  28+ 59F6              .L3:
  29+ 59F6 C5           			PUSH BC
  30+ 59F7 2A 9F 5D     				LD HL, (TILETMP2)
  31+ 59FA DD 46 04     				LD B, (IX+4) ; tile columns
  32+ 59FD              .L4:
  33+ 59FD C5           				PUSH BC
  34+ 59FE              .CALL2:
  35+ 59FE CD 00 00     					CALL 0
  36+ 5A01 C1           				POP BC
  37+ 5A02 10 F9        				DJNZ .L4
  38+ 5A04 C1           			POP BC
  39+ 5A05 10 EF        			DJNZ .L3
  40+ 5A07 22 9F 5D     			LD (TILETMP2), HL
  41+ 5A0A 2A 9D 5D     			LD HL, (TILETMP1)
  42+ 5A0D DD 5E 08     			LD E, (IX+8)
  43+ 5A10 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
  44+ 5A13 19           			ADD HL, DE
  45+ 5A14 22 9D 5D     			LD (TILETMP1), HL
  46+ 5A17 C1           		POP BC
  47+ 5A18 10 D5        		DJNZ .L2
  48+ 5A1A C1           	POP BC
  49+ 5A1B 10 C5        	DJNZ .L1
  50+ 5A1D C9           	RET
  51+ 5A1E              ; *******************************************************************************************************
  52+ 5A1E
  53+ 5A1E               IF (1 == 1)
  54+ 5A1E              ; *******************************************************************************************************
  55+ 5A1E              ; same as TILERAM but for DEFUSR approach
  56+ 5A1E              ; input IX=pointer to input array, real data from +2
  57+ 5A1E              ; +02 = tile data pointer
  58+ 5A1E              ; +04 = tile columns
  59+ 5A1E              ; +06 = tile rows
  60+ 5A1E              ; +08 = destination pointer
  61+ 5A1E              ; +10 = destination columns
  62+ 5A1E              ; +12 = destination rows
  63+ 5A1E              ; +14 = destination begin column
  64+ 5A1E              ; +16 = destination begin row
  65+ 5A1E              ; +18 = number of tiles horizontally
  66+ 5A1E              ; +20 = number of tiles vertically
  67+ 5A1E              ; *******************************************************************************************************
  68+ 5A1E              TILERAM_DEFUSR:
  69+ 5A1E              	; tile data pointer
  70+ 5A1E DD 6E 02     	LD L,(IX+2)
  71+ 5A21 DD 66 03     	LD H,(IX+3)
  72+ 5A24 22 A1 5D     	LD (BLIT_STRUCT+0),HL
  73+ 5A27              	; tile columns
  74+ 5A27 DD 6E 04     	LD L,(IX+4)
  75+ 5A2A DD 66 05     	LD H,(IX+5)
  76+ 5A2D 22 A5 5D     	LD (BLIT_STRUCT+4),HL
  77+ 5A30              	; tile rows
  78+ 5A30 DD 6E 06     	LD L,(IX+6)
  79+ 5A33 DD 66 07     	LD H,(IX+7)
  80+ 5A36 22 A3 5D     	LD (BLIT_STRUCT+2),HL
  81+ 5A39              	; destintion pointer
  82+ 5A39 DD 6E 08     	LD L,(IX+8)
  83+ 5A3C DD 66 09     	LD H,(IX+9)
  84+ 5A3F 22 A7 5D     	LD (BLIT_STRUCT+6),HL
  85+ 5A42              	; destination columns
  86+ 5A42 DD 7E 0A     	LD A,(IX+10)
  87+ 5A45 32 9D 5D     	LD (BLIT_TMP+0),A
  88+ 5A48              	; destination rows
  89+ 5A48 DD 7E 0C     	LD A,(IX+12)
  90+ 5A4B 32 9E 5D     	LD (BLIT_TMP+1),A
  91+ 5A4E              	; destination begin column
  92+ 5A4E DD 7E 0E     	LD A,(IX+14)
  93+ 5A51 32 9F 5D     	LD (BLIT_TMP+2),A
  94+ 5A54              	; destination begin row
  95+ 5A54 DD 7E 10     	LD A,(IX+16)
  96+ 5A57 32 A0 5D     	LD (BLIT_TMP+3),A
  97+ 5A5A              	; number of tiles horizontally
  98+ 5A5A DD 6E 12     	LD L,(IX+18)
  99+ 5A5D DD 66 13     	LD H,(IX+19)
 100+ 5A60 22 AB 5D     	LD (BLIT_STRUCT+10),HL
 101+ 5A63              	; number of tiles vertically
 102+ 5A63 DD 6E 14     	LD L,(IX+20)
 103+ 5A66 DD 66 15     	LD H,(IX+21)
 104+ 5A69 22 AD 5D     	LD (BLIT_STRUCT+12),HL
 105+ 5A6C               IF (0 == 1) ; otherwise we just continue with code below
 106+ 5A6C ~            	JP TILERAM.COMMON
 107+ 5A6C               ENDIF
 108+ 5A6C               ENDIF
 109+ 5A6C
 110+ 5A6C              ; *******************************************************************************************************
 111+ 5A6C              ; function to handle CALL TILERAM basic extension
 112+ 5A6C              ; fills memory with tiles
 113+ 5A6C              ; TILERAM ( INT tile_data_pointer,
 114+ 5A6C              ;			INT tile_columns,
 115+ 5A6C              ;			INT tile_rows,
 116+ 5A6C              ;			INT destination_pointer,
 117+ 5A6C              ;			INT destination_columns,
 118+ 5A6C              ;			INT destination_rows,
 119+ 5A6C              ;			INT destination_begin_column,
 120+ 5A6C              ;			INT destination_begin_row,
 121+ 5A6C              ;			INT number_of_tiles_horizontally,
 122+ 5A6C              ;			INT	number_of_tiles_vertically )
 123+ 5A6C              ; will put ram in page 0 also, page 1 is already there
 124+ 5A6C              TILERAM:
 125+ 5A6C               IF (0 == 1)
 126+ 5A6C ~            	; opening (
 127+ 5A6C ~            	CALL CHKCHAR
 128+ 5A6C ~            	DB '('
 129+ 5A6C ~            	; get tile data pointer coordinate
 130+ 5A6C ~            	LD IX, FRMQNT
 131+ 5A6C ~            	CALL CALBAS
 132+ 5A6C ~            	LD (BLIT_STRUCT+0), DE
 133+ 5A6C ~            	; comma
 134+ 5A6C ~            	CALL CHKCHAR
 135+ 5A6C ~            	DB ','
 136+ 5A6C ~            	; get tile columns
 137+ 5A6C ~            	LD IX, FRMQNT
 138+ 5A6C ~            	CALL CALBAS
 139+ 5A6C ~            	LD (BLIT_STRUCT+4), DE
 140+ 5A6C ~            	; comma
 141+ 5A6C ~            	CALL CHKCHAR
 142+ 5A6C ~            	DB ','
 143+ 5A6C ~            	; get tile columns
 144+ 5A6C ~            	LD IX, FRMQNT
 145+ 5A6C ~            	CALL CALBAS
 146+ 5A6C ~            	LD (BLIT_STRUCT+2), DE
 147+ 5A6C ~            	; comma
 148+ 5A6C ~            	CALL CHKCHAR
 149+ 5A6C ~            	DB ','
 150+ 5A6C ~            	; get destintion pointer
 151+ 5A6C ~            	LD IX, FRMQNT
 152+ 5A6C ~            	CALL CALBAS
 153+ 5A6C ~            	LD (BLIT_STRUCT+6), DE
 154+ 5A6C ~            	; comma
 155+ 5A6C ~            	CALL CHKCHAR
 156+ 5A6C ~            	DB ','
 157+ 5A6C ~            	; get destination columns
 158+ 5A6C ~            	LD IX, FRMQNT
 159+ 5A6C ~            	CALL CALBAS
 160+ 5A6C ~            	LD A, E
 161+ 5A6C ~            	LD (BLIT_TMP+0), A
 162+ 5A6C ~            	; comma
 163+ 5A6C ~            	CALL CHKCHAR
 164+ 5A6C ~            	DB ','
 165+ 5A6C ~            	; get destination rows
 166+ 5A6C ~            	LD IX, FRMQNT
 167+ 5A6C ~            	CALL CALBAS
 168+ 5A6C ~            	LD A, E
 169+ 5A6C ~            	LD (BLIT_TMP+1), A
 170+ 5A6C ~            	; comma
 171+ 5A6C ~            	CALL CHKCHAR
 172+ 5A6C ~            	DB ','
 173+ 5A6C ~            	; get destination begin column
 174+ 5A6C ~            	LD IX, FRMQNT
 175+ 5A6C ~            	CALL CALBAS
 176+ 5A6C ~            	LD A, E
 177+ 5A6C ~            	LD (BLIT_TMP+2), A
 178+ 5A6C ~            	; comma
 179+ 5A6C ~            	CALL CHKCHAR
 180+ 5A6C ~            	DB ','
 181+ 5A6C ~            	; get destination begin row
 182+ 5A6C ~            	LD IX, FRMQNT
 183+ 5A6C ~            	CALL CALBAS
 184+ 5A6C ~            	LD A, E
 185+ 5A6C ~            	LD (BLIT_TMP+3), A
 186+ 5A6C ~            	; comma
 187+ 5A6C ~            	CALL CHKCHAR
 188+ 5A6C ~            	DB ','
 189+ 5A6C ~            	; get number of tiles horizontally
 190+ 5A6C ~            	LD IX, FRMQNT
 191+ 5A6C ~            	CALL CALBAS
 192+ 5A6C ~            	LD (BLIT_STRUCT+10), DE
 193+ 5A6C ~            	; comma
 194+ 5A6C ~            	CALL CHKCHAR
 195+ 5A6C ~            	DB ','
 196+ 5A6C ~            	; get number of tiles vertically
 197+ 5A6C ~            	LD IX, FRMQNT
 198+ 5A6C ~            	CALL CALBAS
 199+ 5A6C ~            	LD (BLIT_STRUCT+12), DE
 200+ 5A6C ~            	; ending )
 201+ 5A6C ~            	CALL CHKCHAR
 202+ 5A6C ~            	DB ')'
 203+ 5A6C               ENDIF
 204+ 5A6C              .COMMON:
 205+ 5A6C E5           	PUSH HL ; save position in BASIC buffer
 206+ 5A6D
 207+ 5A6D              	; calculate destination add to value
 208+ 5A6D 26 00        	LD H, 0
 209+ 5A6F 3A 9D 5D     	LD A, (BLIT_TMP+0)
 210+ 5A72 6F           	LD L, A
 211+ 5A73 CD 07 5E     	CALL HLx8
 212+ 5A76 22 A9 5D     	LD (BLIT_STRUCT+8), HL
 213+ 5A79              	; calculate pointer to background location
 214+ 5A79 21 00 00     	LD HL, 0
 215+ 5A7C 3A A0 5D     	LD A,(BLIT_TMP+3)
 216+ 5A7F B7           	OR A
 217+ 5A80 28 08        	JR Z, .L1
 218+ 5A82 47           	LD B,A
 219+ 5A83 ED 5B A9 5D  	LD DE,(BLIT_STRUCT+8)
 220+ 5A87              .L0:
 221+ 5A87 19           	ADD HL, DE
 222+ 5A88 10 FD        	DJNZ .L0
 223+ 5A8A              .L1:
 224+ 5A8A EB           	EX DE,HL
 225+ 5A8B 26 00        	LD H,0
 226+ 5A8D 3A 9F 5D     	LD A,(BLIT_TMP+2)
 227+ 5A90 6F           	LD L,A
 228+ 5A91 CD 07 5E     	CALL HLx8
 229+ 5A94 19           	ADD HL,DE
 230+ 5A95 ED 5B A7 5D  	LD DE,(BLIT_STRUCT+6)
 231+ 5A99 19           	ADD HL,DE
 232+ 5A9A 22 A7 5D     	LD (BLIT_STRUCT+6),HL
 233+ 5A9D FD 21 A4 5A  	LD IY, .RET
 234+ 5AA1 C3 CB 5E     	JP ENABLE_PAGE0
 235+ 5AA4              .RET:
 236+ 5AA4 FB           	EI
 237+ 5AA5              	; set RAM functions to call
 238+ 5AA5 21 BF 5A     	LD HL, .TILECOPY
 239+ 5AA8 22 FF 59     	LD (TILE.CALL2+1), HL
 240+ 5AAB 21 D0 5A     	LD HL, .SETDESTROW
 241+ 5AAE 22 F1 59     	LD (TILE.CALL1+1), HL
 242+ 5AB1 DD 21 A1 5D  	LD IX,BLIT_STRUCT
 243+ 5AB5 CD D6 59     	CALL TILE
 244+ 5AB8
 245+ 5AB8 D1               POP DE
 246+ 5AB9 C1               POP BC
 247+ 5ABA CD 42 5E         CALL RESTORE_PAGE_INFO
 248+ 5ABD
 249+ 5ABD E1           	POP HL
 250+ 5ABE C9           	RET
 251+ 5ABF              .TILECOPY:
 252+ 5ABF ED A0       > LDI
 252+ 5AC1 ED A0       > LDI
 252+ 5AC3 ED A0       > LDI
 252+ 5AC5 ED A0       > LDI
 252+ 5AC7 ED A0       > LDI
 252+ 5AC9 ED A0       > LDI
 252+ 5ACB ED A0       > LDI
 252+ 5ACD ED A0       > LDI
 253+ 5ACF C9           	RET
 254+ 5AD0              .SETDESTROW:
 255+ 5AD0 ED 5B 9D 5D  	LD DE, (TILETMP1)
 256+ 5AD4 C9           	RET
 257+ 5AD5              ; *******************************************************************************************************
 258+ 5AD5
 259+ 5AD5               IF (1 == 1)
 260+ 5AD5              ; *******************************************************************************************************
 261+ 5AD5              ; same as TILEVRM but for DEFUSR approach
 262+ 5AD5              ; input IX=pointer to input array, real data from +2
 263+ 5AD5              ; +02 = tile data pointer
 264+ 5AD5              ; +04 = tile columns
 265+ 5AD5              ; +06 = tile rows
 266+ 5AD5              ; +08 = destination begin column
 267+ 5AD5              ; +10 = destination begin row
 268+ 5AD5              ; +12 = number of tiles horizontally
 269+ 5AD5              ; +14 = number of tiles vertically
 270+ 5AD5              ; *******************************************************************************************************
 271+ 5AD5              TILEVRM_DEFUSR:
 272+ 5AD5              	; tile data pointer
 273+ 5AD5 DD 6E 02     	LD L,(IX+2)
 274+ 5AD8 DD 66 03     	LD H,(IX+3)
 275+ 5ADB 22 A1 5D     	LD (BLIT_STRUCT+0),HL
 276+ 5ADE              	; tile columns
 277+ 5ADE DD 6E 04     	LD L,(IX+4)
 278+ 5AE1 DD 66 05     	LD H,(IX+5)
 279+ 5AE4 22 A5 5D     	LD (BLIT_STRUCT+4),HL
 280+ 5AE7              	; tile rows
 281+ 5AE7 DD 6E 06     	LD L,(IX+6)
 282+ 5AEA DD 66 07     	LD H,(IX+7)
 283+ 5AED 22 A3 5D     	LD (BLIT_STRUCT+2),HL
 284+ 5AF0              	; destination begin column
 285+ 5AF0 DD 7E 08     	LD A,(IX+8)
 286+ 5AF3 32 9F 5D     	LD (BLIT_TMP+2),A
 287+ 5AF6              	; destination begin row
 288+ 5AF6 DD 7E 0A     	LD A,(IX+10)
 289+ 5AF9 32 A0 5D     	LD (BLIT_TMP+3),A
 290+ 5AFC              	; number of tiles horizontally
 291+ 5AFC DD 6E 0C     	LD L,(IX+12)
 292+ 5AFF DD 66 0D     	LD H,(IX+13)
 293+ 5B02 22 AB 5D     	LD (BLIT_STRUCT+10),HL
 294+ 5B05              	; number of tiles vertically
 295+ 5B05 DD 6E 0E     	LD L,(IX+14)
 296+ 5B08 DD 66 0F     	LD H,(IX+15)
 297+ 5B0B 22 AD 5D     	LD (BLIT_STRUCT+12),HL
 298+ 5B0E               IF (0 == 1) ; otherwise we just continue with code below
 299+ 5B0E ~            	JP TILEVRM.COMMON
 300+ 5B0E               ENDIF
 301+ 5B0E               ENDIF
 302+ 5B0E
 303+ 5B0E              ; *******************************************************************************************************
 304+ 5B0E              ; function to handle CALL TILEVRM basic extension
 305+ 5B0E              ; fills vram with tiles
 306+ 5B0E              ; TILEVRM ( INT tile_data_pointer,
 307+ 5B0E              ;			INT tile_columns,
 308+ 5B0E              ;			INT tile_rows,
 309+ 5B0E              ;			INT destination_begin_column,
 310+ 5B0E              ;			INT destination_begin_row,
 311+ 5B0E              ;			INT number_of_tiles_horizontally,
 312+ 5B0E              ;			INT	number_of_tiles_vertically )
 313+ 5B0E              ; will put ram in page 0 also, page 1 is already there
 314+ 5B0E              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
 315+ 5B0E              TILEVRM:
 316+ 5B0E               IF (0 == 1)
 317+ 5B0E ~            	; opening (
 318+ 5B0E ~            	CALL CHKCHAR
 319+ 5B0E ~            	DB '('
 320+ 5B0E ~            	; get tile data pointer coordinate
 321+ 5B0E ~            	LD IX, FRMQNT
 322+ 5B0E ~            	CALL CALBAS
 323+ 5B0E ~            	LD (BLIT_STRUCT+0), DE
 324+ 5B0E ~            	; comma
 325+ 5B0E ~            	CALL CHKCHAR
 326+ 5B0E ~            	DB ','
 327+ 5B0E ~            	; get tile columns
 328+ 5B0E ~            	LD IX, FRMQNT
 329+ 5B0E ~            	CALL CALBAS
 330+ 5B0E ~            	LD (BLIT_STRUCT+4), DE
 331+ 5B0E ~            	; comma
 332+ 5B0E ~            	CALL CHKCHAR
 333+ 5B0E ~            	DB ','
 334+ 5B0E ~            	; get tile columns
 335+ 5B0E ~            	LD IX, FRMQNT
 336+ 5B0E ~            	CALL CALBAS
 337+ 5B0E ~            	LD (BLIT_STRUCT+2), DE
 338+ 5B0E ~            	; comma
 339+ 5B0E ~            	CALL CHKCHAR
 340+ 5B0E ~            	DB ','
 341+ 5B0E ~            	; get destination begin column
 342+ 5B0E ~            	LD IX, FRMQNT
 343+ 5B0E ~            	CALL CALBAS
 344+ 5B0E ~            	LD A, E
 345+ 5B0E ~            	LD (BLIT_TMP+2), A
 346+ 5B0E ~            	; comma
 347+ 5B0E ~            	CALL CHKCHAR
 348+ 5B0E ~            	DB ','
 349+ 5B0E ~            	; get destination begin row
 350+ 5B0E ~            	LD IX, FRMQNT
 351+ 5B0E ~            	CALL CALBAS
 352+ 5B0E ~            	LD A, E
 353+ 5B0E ~            	LD (BLIT_TMP+3), A
 354+ 5B0E ~            	; comma
 355+ 5B0E ~            	CALL CHKCHAR
 356+ 5B0E ~            	DB ','
 357+ 5B0E ~            	; get number of tiles horizontally
 358+ 5B0E ~            	LD IX, FRMQNT
 359+ 5B0E ~            	CALL CALBAS
 360+ 5B0E ~            	LD (BLIT_STRUCT+10), DE
 361+ 5B0E ~            	; comma
 362+ 5B0E ~            	CALL CHKCHAR
 363+ 5B0E ~            	DB ','
 364+ 5B0E ~            	; get number of tiles vertically
 365+ 5B0E ~            	LD IX, FRMQNT
 366+ 5B0E ~            	CALL CALBAS
 367+ 5B0E ~            	LD (BLIT_STRUCT+12), DE
 368+ 5B0E ~            	; ending )
 369+ 5B0E ~            	CALL CHKCHAR
 370+ 5B0E ~            	DB ')'
 371+ 5B0E               ENDIF
 372+ 5B0E
 373+ 5B0E              .COMMON:
 374+ 5B0E E5           	PUSH HL ; save position in BASIC buffer
 375+ 5B0F
 376+ 5B0F              	; calculate destination add to value
 377+ 5B0F 21 00 01     	LD HL, 256
 378+ 5B12 22 A9 5D     	LD (BLIT_STRUCT+8), HL
 379+ 5B15              	; calculate pointer to background location
 380+ 5B15 3A A0 5D     	LD A,(BLIT_TMP+3)
 381+ 5B18 67           	LD H,A
 382+ 5B19 2E 00        	LD L,0
 383+ 5B1B EB           	EX DE,HL
 384+ 5B1C 26 00        	LD H,0
 385+ 5B1E 3A 9F 5D     	LD A,(BLIT_TMP+2)
 386+ 5B21 6F           	LD L,A
 387+ 5B22 CD 07 5E     	CALL HLx8
 388+ 5B25 19           	ADD HL,DE
 389+ 5B26 ED 5B CB F3  	LD DE,(GRPCGP)
 390+ 5B2A 19           	ADD HL,DE
 391+ 5B2B 22 A7 5D     	LD (BLIT_STRUCT+6),HL
 392+ 5B2E FD 21 35 5B  	LD IY, .RET
 393+ 5B32 C3 CB 5E     	JP ENABLE_PAGE0
 394+ 5B35              .RET:
 395+ 5B35 FB           	EI
 396+ 5B36              	; set RAM functions to call
 397+ 5B36 21 50 5B     	LD HL, .TILECOPY
 398+ 5B39 22 FF 59     	LD (TILE.CALL2+1), HL
 399+ 5B3C 21 56 5B     	LD HL, .SETDESTROW
 400+ 5B3F 22 F1 59     	LD (TILE.CALL1+1), HL
 401+ 5B42 DD 21 A1 5D  	LD IX,BLIT_STRUCT
 402+ 5B46 CD D6 59     	CALL TILE
 403+ 5B49
 404+ 5B49 D1               POP DE
 405+ 5B4A C1               POP BC
 406+ 5B4B CD 42 5E         CALL RESTORE_PAGE_INFO
 407+ 5B4E
 408+ 5B4E E1           	POP HL
 409+ 5B4F C9           	RET
 410+ 5B50              .TILECOPY:
 411+ 5B50 01 98 08     	LD BC, #0898
 412+ 5B53 C3 FF 5D     	JP BBYTECOPY_NO_C
 413+ 5B56              .SETDESTROW:
 414+ 5B56 2A 9D 5D     	LD HL, (TILETMP1)
 415+ 5B59 F3           	DI
 416+ 5B5A CD F2 5D     	CALL SETWRT_LOCAL
 417+ 5B5D FB           	EI
 418+ 5B5E C9           	RET
 419+ 5B5F              ; *******************************************************************************************************
 420+ 5B5F
# file closed: asm\TILE.asm
 163  5B5F               ENDIF
 164  5B5F
 165  5B5F               IF (COLL_CMD == 1)
 166  5B5F               INCLUDE "COLLISION.asm"
# file opened: asm\COLLISION.asm
   1+ 5B5F              ; generic collision checking routines
   2+ 5B5F              ; in BASIC we use rectangle structure array DIM R%(7,n) of the format
   3+ 5B5F              ; R%(0,n) is active flag, <>0 active / 0 skipped in checks
   4+ 5B5F              ; R%(1,n) is either upper left x coordinate or sprite id (0-31) depending on R(7,n)
   5+ 5B5F              ; R%(2,n) is either upper left y coordinate or unused depending on R(7,n)
   6+ 5B5F              ; R%(3,n) x offset where rectangle begins
   7+ 5B5F              ; R%(4,n) y offset where rectangle begins
   8+ 5B5F              ; R%(5,n) is width
   9+ 5B5F              ; R%(6,n) is height
  10+ 5B5F              ; R%(7,0) is type, 0=generic where R%(1,0) contains x coordinate
  11+ 5B5F              ;                  <>0 sprite where R%(1,0) contains sprite id
  12+ 5B5F              ; for type sprite, upper left coordinates are taken from sprite attribute array
  13+ 5B5F
  14+ 5B5F              ; ************************************************************************************************
  15+ 5B5F              ; quick test if HL<=DE<=HL+BC
  16+ 5B5F              ; input BC=width, DE=x, HL=min
  17+ 5B5F              ; if not true flag C set
  18+ 5B5F              ; modifies AF
  19+ 5B5F              GENERIC_INNER_CHECK:
  20+ 5B5F E5               PUSH HL
  21+ 5B60 D5               PUSH DE
  22+ 5B61 EB               EX DE,HL
  23+ 5B62 A7               AND A
  24+ 5B63 ED 52            SBC HL, DE
  25+ 5B65 FA 73 5B         JP M, .GENERIC_INNER_CHECK_NOT
  26+ 5B68 A7               AND A
  27+ 5B69 ED 42            SBC HL, BC
  28+ 5B6B 28 03            JR Z, .L2
  29+ 5B6D F2 73 5B         JP P, .GENERIC_INNER_CHECK_NOT
  30+ 5B70              .L2:
  31+ 5B70 A7               AND A
  32+ 5B71 18 01            JR .EXIT
  33+ 5B73              .GENERIC_INNER_CHECK_NOT:
  34+ 5B73 37               SCF
  35+ 5B74              .EXIT:
  36+ 5B74 D1               POP DE
  37+ 5B75 E1               POP HL
  38+ 5B76 C9               RET
  39+ 5B77              ; ************************************************************************************************
  40+ 5B77
  41+ 5B77              ; ************************************************************************************************
  42+ 5B77              ; function to check if rectangles are overlapping
  43+ 5B77              ; input IX=IY=pointer to struct
  44+ 5B77              ;  +00 active flag
  45+ 5B77              ;  +02 x coordinate
  46+ 5B77              ;  +04 y coordinate
  47+ 5B77              ;  +06 x offset where rectangle begins
  48+ 5B77              ;  +08 y offset where rectangle begins
  49+ 5B77              ;  +10 width
  50+ 5B77              ;  +12 height
  51+ 5B77              ; where IY is used to read +2 and +4, and IX to read +6, +8, +10 and +12
  52+ 5B77              ; this is a hack to allow location being taken from sprite attributes table
  53+ 5B77              ; input BLIT_STRUCT data
  54+ 5B77              ;  +00 x coordinate
  55+ 5B77              ;  +02 y coordinate
  56+ 5B77              ;  +04 width
  57+ 5B77              ;  +06 height
  58+ 5B77              ; returns CF=1 if not overlapping, CF=0 if overlapping
  59+ 5B77              RECTANGLE_OVERLAP_CHECK:
  60+ 5B77                  ; first check which rectangle is higher
  61+ 5B77 DD 6E 0C         LD L,(IX+12)
  62+ 5B7A DD 66 0D         LD H,(IX+13)
  63+ 5B7D ED 5B A7 5D      LD DE,(BLIT_STRUCT+6)
  64+ 5B81 A7               AND A
  65+ 5B82 ED 52            SBC HL,DE
  66+ 5B84 FD 6E 04         LD L,(IY+4)
  67+ 5B87 FD 66 05         LD H,(IY+5)
  68+ 5B8A DD 5E 08         LD E,(IX+8)
  69+ 5B8D DD 56 09         LD D,(IX+9)
  70+ 5B90 FA B0 5B         JP M,.L1
  71+ 5B93                  ; equally high or IX defined one higher
  72+ 5B93                  ; check upper boundary
  73+ 5B93 19               ADD HL,DE
  74+ 5B94 ED 5B A3 5D      LD DE,(BLIT_STRUCT+2)
  75+ 5B98 DD 4E 0C         LD C,(IX+12)
  76+ 5B9B DD 46 0D         LD B,(IX+13)
  77+ 5B9E CD 5F 5B         CALL GENERIC_INNER_CHECK
  78+ 5BA1 30 29            JR NC,.INSIDE
  79+ 5BA3                  ; check lower boundary
  80+ 5BA3 E5               PUSH HL
  81+ 5BA4 2A A7 5D         LD HL,(BLIT_STRUCT+6)
  82+ 5BA7 19               ADD HL,DE
  83+ 5BA8 EB               EX DE,HL
  84+ 5BA9 E1               POP HL
  85+ 5BAA CD 5F 5B         CALL GENERIC_INNER_CHECK
  86+ 5BAD 30 1D            JR NC,.INSIDE
  87+ 5BAF C9               RET ; not overlapping
  88+ 5BB0              .L1:
  89+ 5BB0                  ; rectangle defined in BLIT_STRUCT is higher
  90+ 5BB0 19               ADD HL,DE
  91+ 5BB1 EB               EX DE,HL
  92+ 5BB2 2A A3 5D         LD HL,(BLIT_STRUCT+2)
  93+ 5BB5 ED 4B A7 5D      LD BC,(BLIT_STRUCT+6)
  94+ 5BB9 CD 5F 5B         CALL GENERIC_INNER_CHECK
  95+ 5BBC 30 0E            JR NC,.INSIDE
  96+ 5BBE E5               PUSH HL
  97+ 5BBF DD 6E 0C         LD L,(IX+12)
  98+ 5BC2 DD 66 0D         LD H,(IX+13)
  99+ 5BC5 19               ADD HL,DE
 100+ 5BC6 EB               EX DE,HL
 101+ 5BC7 E1               POP HL
 102+ 5BC8 CD 5F 5B         CALL GENERIC_INNER_CHECK
 103+ 5BCB D8               RET C
 104+ 5BCC              .INSIDE:
 105+ 5BCC                  ; check x coordinate
 106+ 5BCC                  ; first check which rectangle is wider
 107+ 5BCC DD 6E 0A         LD L,(IX+10)
 108+ 5BCF DD 66 0B         LD H,(IX+11)
 109+ 5BD2 ED 5B A5 5D      LD DE,(BLIT_STRUCT+4)
 110+ 5BD6 A7               AND A
 111+ 5BD7 ED 52            SBC HL,DE
 112+ 5BD9 FD 6E 02         LD L,(IY+2)
 113+ 5BDC FD 66 03         LD H,(IY+3)
 114+ 5BDF DD 5E 06         LD E,(IX+6)
 115+ 5BE2 DD 56 07         LD D,(IX+7)
 116+ 5BE5 FA 01 5C         JP M,.L2
 117+ 5BE8                  ; equally wide or IX defined one wider
 118+ 5BE8                  ; check left boundary
 119+ 5BE8 19               ADD HL,DE
 120+ 5BE9 ED 5B A1 5D      LD DE,(BLIT_STRUCT+0)
 121+ 5BED DD 4E 0A         LD C,(IX+10)
 122+ 5BF0 DD 46 0B         LD B,(IX+11)
 123+ 5BF3 CD 5F 5B         CALL GENERIC_INNER_CHECK
 124+ 5BF6 D0               RET NC ; overlap
 125+ 5BF7                  ; check right boundary
 126+ 5BF7 E5               PUSH HL
 127+ 5BF8 2A A5 5D         LD HL,(BLIT_STRUCT+4)
 128+ 5BFB 19               ADD HL,DE
 129+ 5BFC EB               EX DE,HL
 130+ 5BFD E1               POP HL
 131+ 5BFE C3 5F 5B         JP GENERIC_INNER_CHECK ; CF and result set by fn call
 132+ 5C01              .L2:
 133+ 5C01                  ; rectangle defined in BLIT_STRUCT is higher
 134+ 5C01 19               ADD HL,DE
 135+ 5C02 EB               EX DE,HL
 136+ 5C03 2A A1 5D         LD HL,(BLIT_STRUCT+0)
 137+ 5C06 ED 4B A5 5D      LD BC,(BLIT_STRUCT+4)
 138+ 5C0A CD 5F 5B         CALL GENERIC_INNER_CHECK
 139+ 5C0D D0               RET NC ; overlap
 140+ 5C0E E5               PUSH HL
 141+ 5C0F DD 6E 0A         LD L,(IX+10)
 142+ 5C12 DD 66 0B         LD H,(IX+11)
 143+ 5C15 19               ADD HL,DE
 144+ 5C16 EB               EX DE,HL
 145+ 5C17 E1               POP HL
 146+ 5C18 C3 5F 5B         JP GENERIC_INNER_CHECK
 147+ 5C1B              ; ************************************************************************************************
 148+ 5C1B
 149+ 5C1B              ; ************************************************************************************************
 150+ 5C1B              ; function tries to find rectangle overlap and returns an index if found
 151+ 5C1B              ; input BLIT_STRUCT data
 152+ 5C1B              ;  +00 x coordinate
 153+ 5C1B              ;  +02 y coordinate
 154+ 5C1B              ;  +04 width
 155+ 5C1B              ;  +06 height
 156+ 5C1B              ;  +08 number of items in a list, described under RECTANGLE_OVERLAP_CHECK
 157+ 5C1B              ;  +09 pointer to first element of R%(7,n)
 158+ 5C1B              ;  +11 pointer to INT result variable
 159+ 5C1B              ; returns CF=1 if not overlapping
 160+ 5C1B              ; returns A=list index and CF=0 if overlapping
 161+ 5C1B              FIND_OVERLAP:
 162+ 5C1B 3A A9 5D         LD A,(BLIT_STRUCT+8)
 163+ 5C1E 47               LD B,A
 164+ 5C1F DD 2A AA 5D      LD IX,(BLIT_STRUCT+9)
 165+ 5C23              .L1:
 166+ 5C23 C5               PUSH BC
 167+ 5C24                  ; check active flag
 168+ 5C24 DD 7E 00         LD A,(IX)
 169+ 5C27 DD B6 01         OR (IX+1)
 170+ 5C2A 28 18            JR Z,.NEXT
 171+ 5C2C                  ; check type
 172+ 5C2C DD 7E 0E         LD A,(IX+14)
 173+ 5C2F DD B6 0F         OR (IX+15)
 174+ 5C32 20 1A            JR NZ,.L2
 175+ 5C34 DD E5            PUSH IX
 176+ 5C36 FD E1            POP IY
 177+ 5C38              .L3:
 178+ 5C38 CD 77 5B         CALL RECTANGLE_OVERLAP_CHECK
 179+ 5C3B 38 07            JR C,.NEXT
 180+ 5C3D                  ; found
 181+ 5C3D C1               POP BC
 182+ 5C3E 3A A9 5D         LD A,(BLIT_STRUCT+8)
 183+ 5C41 90               SUB B
 184+ 5C42 A7               AND A
 185+ 5C43 C9               RET
 186+ 5C44              .NEXT:
 187+ 5C44 11 10 00         LD DE,16
 188+ 5C47 DD 19            ADD IX,DE
 189+ 5C49 C1               POP BC
 190+ 5C4A 10 D7            DJNZ .L1
 191+ 5C4C 37               SCF
 192+ 5C4D C9               RET
 193+ 5C4E              .L2:
 194+ 5C4E                  ; sprite, need to build a temporary data struct since x and y values are inversed
 195+ 5C4E                  ; at BLIT_STRUCT+13
 196+ 5C4E DD 7E 02         LD A,(IX+2) ; sprite ID
 197+ 5C51 CD 89 4D         CALL GETnthSPRATTR
 198+ 5C54 FD 21 AC 5D      LD IY,BLIT_STRUCT+11
 199+ 5C58 7E               LD A,(HL)
 200+ 5C59 FD 77 04         LD (IY+4),A
 201+ 5C5C 23               INC HL
 202+ 5C5D 7E               LD A,(HL)
 203+ 5C5E FD 77 05         LD (IY+5),A
 204+ 5C61 23               INC HL
 205+ 5C62 7E               LD A,(HL)
 206+ 5C63 FD 77 02         LD (IY+2),A
 207+ 5C66 23               INC HL
 208+ 5C67 7E               LD A,(HL)
 209+ 5C68 FD 77 03         LD (IY+3),A
 210+ 5C6B 18 CB            JR .L3
 211+ 5C6D              ; ************************************************************************************************
 212+ 5C6D
 213+ 5C6D               IF (0 == 1)
 214+ 5C6D ~            ; ************************************************************************************************
 215+ 5C6D ~            ; function to handle CALL COLL basic extension
 216+ 5C6D ~            ; checks for collision between player and other rectangles
 217+ 5C6D ~            ; COLL ( INT result variable,
 218+ 5C6D ~            ;	     INT player x value,
 219+ 5C6D ~            ;	     INT player y value,
 220+ 5C6D ~            ;	     INT player width,
 221+ 5C6D ~            ;	     INT player height,
 222+ 5C6D ~            ;	     INT number of items in a list,
 223+ 5C6D ~            ;		 INT[6][n] rectangle struct )
 224+ 5C6D ~            ; will fill result variable with index or -1 if no collision
 225+ 5C6D ~            ; rectangle struct described under RECTANGLE_OVERLAP_CHECK
 226+ 5C6D ~            COLL:
 227+ 5C6D ~            	; opening (
 228+ 5C6D ~            	CALL CHKCHAR
 229+ 5C6D ~            	DB '('
 230+ 5C6D ~            	; get address of result variable
 231+ 5C6D ~            	LD IX, PTRGET
 232+ 5C6D ~            	CALL CALBAS
 233+ 5C6D ~            	LD (BLIT_STRUCT+11),DE
 234+ 5C6D ~            	; comma
 235+ 5C6D ~            	CALL CHKCHAR
 236+ 5C6D ~            	DB ','
 237+ 5C6D ~            	; get x
 238+ 5C6D ~            	LD IX, FRMQNT
 239+ 5C6D ~            	CALL CALBAS
 240+ 5C6D ~            	LD (BLIT_STRUCT+0),DE
 241+ 5C6D ~            	; comma
 242+ 5C6D ~            	CALL CHKCHAR
 243+ 5C6D ~            	DB ','
 244+ 5C6D ~            	; get y
 245+ 5C6D ~            	LD IX, FRMQNT
 246+ 5C6D ~            	CALL CALBAS
 247+ 5C6D ~            	LD (BLIT_STRUCT+2),DE
 248+ 5C6D ~            	; comma
 249+ 5C6D ~            	CALL CHKCHAR
 250+ 5C6D ~            	DB ','
 251+ 5C6D ~            	; get width
 252+ 5C6D ~            	LD IX, FRMQNT
 253+ 5C6D ~            	CALL CALBAS
 254+ 5C6D ~            	LD (BLIT_STRUCT+4),DE
 255+ 5C6D ~            	; comma
 256+ 5C6D ~            	CALL CHKCHAR
 257+ 5C6D ~            	DB ','
 258+ 5C6D ~            	; get height
 259+ 5C6D ~            	LD IX, FRMQNT
 260+ 5C6D ~            	CALL CALBAS
 261+ 5C6D ~            	LD (BLIT_STRUCT+6),DE
 262+ 5C6D ~            	; comma
 263+ 5C6D ~            	CALL CHKCHAR
 264+ 5C6D ~            	DB ','
 265+ 5C6D ~            	; get number of items in a list
 266+ 5C6D ~            	LD IX, GETBYT
 267+ 5C6D ~            	CALL CALBAS
 268+ 5C6D ~            	LD (BLIT_STRUCT+8),A
 269+ 5C6D ~            	; comma
 270+ 5C6D ~            	CALL CHKCHAR
 271+ 5C6D ~            	DB ','
 272+ 5C6D ~            	; get address of rectangle structure array DIM R%(7,n)
 273+ 5C6D ~            	LD A,(BLIT_STRUCT+8)
 274+ 5C6D ~                LD E,A
 275+ 5C6D ~                LD A,2
 276+ 5C6D ~            	LD B,A
 277+ 5C6D ~            	LD D,7
 278+ 5C6D ~            	CALL GET_BASIC_ARRAY_DATA_POINTER
 279+ 5C6D ~            	LD (BLIT_STRUCT+9),BC
 280+ 5C6D ~            	; ending )
 281+ 5C6D ~            	CALL CHKCHAR
 282+ 5C6D ~            	DB ')'
 283+ 5C6D ~
 284+ 5C6D ~                PUSH HL
 285+ 5C6D ~                CALL FIND_OVERLAP
 286+ 5C6D ~                LD HL,(BLIT_STRUCT+11)
 287+ 5C6D ~                JR C,.NOTFOUND
 288+ 5C6D ~                LD (HL),A
 289+ 5C6D ~                INC HL
 290+ 5C6D ~                LD (HL),0
 291+ 5C6D ~                POP HL
 292+ 5C6D ~                RET
 293+ 5C6D ~            .NOTFOUND:
 294+ 5C6D ~                LD (HL),#FF
 295+ 5C6D ~                INC HL
 296+ 5C6D ~                LD (HL),#FF
 297+ 5C6D ~                POP HL
 298+ 5C6D ~                RET
 299+ 5C6D ~            ; ************************************************************************************************
 300+ 5C6D               ENDIF
 301+ 5C6D
 302+ 5C6D               IF (1 == 1)
 303+ 5C6D              ; *******************************************************************************************************
 304+ 5C6D              ; same as COLL but for DEFUSR approach
 305+ 5C6D              ; input IX=pointer to input array, real data from +2
 306+ 5C6D              ; +02 = pointer to result variable
 307+ 5C6D              ; +04 = player X
 308+ 5C6D              ; +06 = player Y
 309+ 5C6D              ; +08 = player width
 310+ 5C6D              ; +10 = player height
 311+ 5C6D              ; +12 = number of list items
 312+ 5C6D              ; +14 = pointer to list of collidable objects
 313+ 5C6D              COLL_DEFUSR:
 314+ 5C6D DD E5            PUSH IX
 315+ 5C6F E1               POP HL
 316+ 5C70 23          > INC HL ; skip over to player x
 316+ 5C71 23          > INC HL
 316+ 5C72 23          > INC HL
 316+ 5C73 23          > INC HL
 317+ 5C74 11 A1 5D         LD DE,BLIT_STRUCT
 318+ 5C77 01 09 00         LD BC,9
 319+ 5C7A ED B0            LDIR ; copy over x,y,w,h,list item number
 320+ 5C7C DD 7E 0E         LD A,(IX+14)
 321+ 5C7F 32 AA 5D         LD (BLIT_STRUCT+9),A
 322+ 5C82 DD 7E 0F         LD A,(IX+15)
 323+ 5C85 32 AB 5D         LD (BLIT_STRUCT+10),A ; address to collidable objects array
 324+ 5C88 DD 7E 02         LD A,(IX+2)
 325+ 5C8B 32 AC 5D         LD (BLIT_STRUCT+11),A
 326+ 5C8E DD 7E 03         LD A,(IX+3)
 327+ 5C91 32 AD 5D         LD (BLIT_STRUCT+12),A ; address to results variable
 328+ 5C94 DD E5            PUSH IX
 329+ 5C96 CD 1B 5C         CALL FIND_OVERLAP
 330+ 5C99 DD E1            POP IX
 331+ 5C9B DD 6E 02         LD L,(IX+2)
 332+ 5C9E DD 66 03         LD H,(IX+3)
 333+ 5CA1 38 05            JR C,.NOTFOUND
 334+ 5CA3 77               LD (HL),A
 335+ 5CA4 23               INC HL
 336+ 5CA5 36 00            LD (HL),0
 337+ 5CA7 C9               RET
 338+ 5CA8              .NOTFOUND:
 339+ 5CA8 36 FF            LD (HL),#FF
 340+ 5CAA 23               INC HL
 341+ 5CAB 36 FF            LD (HL),#FF
 342+ 5CAD C9               RET
 343+ 5CAE              ; *******************************************************************************************************
 344+ 5CAE               ENDIF
 345+ 5CAE
# file closed: asm\COLLISION.asm
 167  5CAE               ENDIF
 168  5CAE
 169  5CAE               IF (DECOMP_CMDS == 1)
 170  5CAE               INCLUDE "decomp.asm"
# file opened: asm\decomp.asm
   1+ 5CAE              ; -----------------------------------------------------------------------------
   2+ 5CAE              ; ZX0 decoder by Einar Saukas & Urusergi
   3+ 5CAE              ; "Standard" version (68 bytes only)
   4+ 5CAE              ; -----------------------------------------------------------------------------
   5+ 5CAE              ; Parameters:
   6+ 5CAE              ;   HL: source address (compressed data)
   7+ 5CAE              ;   DE: destination address (decompressing)
   8+ 5CAE              ; -----------------------------------------------------------------------------
   9+ 5CAE
  10+ 5CAE              dzx0_standard:
  11+ 5CAE 01 FF FF             ld      bc, $ffff               ; preserve default offset 1
  12+ 5CB1 C5                   push    bc
  13+ 5CB2 03                   inc     bc
  14+ 5CB3 3E 80                ld      a, $80
  15+ 5CB5              dzx0s_literals:
  16+ 5CB5 CD E5 5C             call    dzx0s_elias             ; obtain length
  17+ 5CB8              dzx0_ldir_1:
  18+ 5CB8 ED B0                ldir                            ; copy literals
  19+ 5CBA 00                   nop                             ; placeholder for call
  20+ 5CBB 87                   add     a, a                    ; copy from last offset or new offset?
  21+ 5CBC 38 0E                jr      c, dzx0s_new_offset
  22+ 5CBE CD E5 5C             call    dzx0s_elias             ; obtain length
  23+ 5CC1              dzx0s_copy:
  24+ 5CC1 E3                   ex      (sp), hl                ; preserve source, restore offset
  25+ 5CC2 E5                   push    hl                      ; preserve offset
  26+ 5CC3 19                   add     hl, de                  ; calculate destination - offset
  27+ 5CC4              dzx0_ldir_2:
  28+ 5CC4 ED B0                ldir                            ; copy from offset
  29+ 5CC6 00                   nop                             ; placeholder for call
  30+ 5CC7 E1                   pop     hl                      ; restore offset
  31+ 5CC8 E3                   ex      (sp), hl                ; preserve offset, restore source
  32+ 5CC9 87                   add     a, a                    ; copy from literals or new offset?
  33+ 5CCA 30 E9                jr      nc, dzx0s_literals
  34+ 5CCC              dzx0s_new_offset:
  35+ 5CCC C1                   pop     bc                      ; discard last offset
  36+ 5CCD 0E FE                ld      c, $fe                  ; prepare negative offset
  37+ 5CCF CD E6 5C             call    dzx0s_elias_loop        ; obtain offset MSB
  38+ 5CD2 0C                   inc     c
  39+ 5CD3 C8                   ret     z                       ; check end marker
  40+ 5CD4 41                   ld      b, c
  41+ 5CD5 4E                   ld      c, (hl)                 ; obtain offset LSB
  42+ 5CD6 23                   inc     hl
  43+ 5CD7 CB 18                rr      b                       ; last offset bit becomes first length bit
  44+ 5CD9 CB 19                rr      c
  45+ 5CDB C5                   push    bc                      ; preserve new offset
  46+ 5CDC 01 01 00             ld      bc, 1                   ; obtain length
  47+ 5CDF D4 ED 5C             call    nc, dzx0s_elias_backtrack
  48+ 5CE2 03                   inc     bc
  49+ 5CE3 18 DC                jr      dzx0s_copy
  50+ 5CE5              dzx0s_elias:
  51+ 5CE5 0C                   inc     c                       ; interlaced Elias gamma coding
  52+ 5CE6              dzx0s_elias_loop:
  53+ 5CE6 87                   add     a, a
  54+ 5CE7 20 03                jr      nz, dzx0s_elias_skip
  55+ 5CE9 7E                   ld      a, (hl)                 ; load another group of 8 bits
  56+ 5CEA 23                   inc     hl
  57+ 5CEB 17                   rla
  58+ 5CEC              dzx0s_elias_skip:
  59+ 5CEC D8                   ret     c
  60+ 5CED              dzx0s_elias_backtrack:
  61+ 5CED 87                   add     a, a
  62+ 5CEE CB 11                rl      c
  63+ 5CF0 CB 10                rl      b
  64+ 5CF2 18 F2                jr      dzx0s_elias_loop
  65+ 5CF4              ; -----------------------------------------------------------------------------
  66+ 5CF4
  67+ 5CF4               IF (0 == 1)
  68+ 5CF4 ~            ; *******************************************************************************************************
  69+ 5CF4 ~            ; function to handle CALL VUNPACK basic extension
  70+ 5CF4 ~            ; _VUNPACK ( INT source,
  71+ 5CF4 ~            ;			 INT destination )
  72+ 5CF4 ~            ; will put ram in page 0 also, page 1 is already there
  73+ 5CF4 ~            ; *******************************************************************************************************
  74+ 5CF4 ~            VUNPACK:
  75+ 5CF4 ~                LD A, #CD ; CALL
  76+ 5CF4 ~                LD (dzx0_ldir_1), A
  77+ 5CF4 ~                LD (dzx0_ldir_2), A
  78+ 5CF4 ~                LD DE, VRAM_LDIRVM
  79+ 5CF4 ~                LD (dzx0_ldir_1 + 1), DE
  80+ 5CF4 ~                LD (dzx0_ldir_2 + 1), DE
  81+ 5CF4 ~                JR UNPACK_COMMON
  82+ 5CF4 ~            ; function to handle CALL UNPACK basic extension
  83+ 5CF4 ~            ; _UNPACK ( INT source,
  84+ 5CF4 ~            ;			INT destination )
  85+ 5CF4 ~            ; will put ram in page 0 also, page 1 is already there
  86+ 5CF4 ~            UNPACK:
  87+ 5CF4 ~                LD DE, #B0ED ; LDIR
  88+ 5CF4 ~                LD (dzx0_ldir_1), DE
  89+ 5CF4 ~                LD (dzx0_ldir_2), DE
  90+ 5CF4 ~                XOR A ; NOP
  91+ 5CF4 ~                LD (dzx0_ldir_1 + 2), A
  92+ 5CF4 ~                LD (dzx0_ldir_2 + 2), A
  93+ 5CF4 ~            UNPACK_COMMON:
  94+ 5CF4 ~            	; opening (
  95+ 5CF4 ~            	CALL CHKCHAR
  96+ 5CF4 ~            	DB '('
  97+ 5CF4 ~            	; get source address
  98+ 5CF4 ~            	LD IX, FRMQNT
  99+ 5CF4 ~            	CALL CALBAS
 100+ 5CF4 ~            	PUSH DE
 101+ 5CF4 ~            	; comma
 102+ 5CF4 ~            	CALL CHKCHAR
 103+ 5CF4 ~            	DB ','
 104+ 5CF4 ~            	; get destination address
 105+ 5CF4 ~            	LD IX, FRMQNT
 106+ 5CF4 ~            	CALL CALBAS
 107+ 5CF4 ~            	PUSH DE
 108+ 5CF4 ~            	; ending )
 109+ 5CF4 ~            	CALL CHKCHAR
 110+ 5CF4 ~            	DB ')'
 111+ 5CF4 ~
 112+ 5CF4 ~            	; save position
 113+ 5CF4 ~            	PUSH HL
 114+ 5CF4 ~            	POP IX
 115+ 5CF4 ~
 116+ 5CF4 ~            	POP DE ; destination
 117+ 5CF4 ~            	POP HL ; source
 118+ 5CF4 ~            	EXX
 119+ 5CF4 ~            	; enable page 0
 120+ 5CF4 ~            	LD IY, .RET
 121+ 5CF4 ~            	JP ENABLE_PAGE0
 122+ 5CF4 ~            .RET:
 123+ 5CF4 ~            	EI
 124+ 5CF4 ~            	EXX
 125+ 5CF4 ~            	CALL dzx0_standard
 126+ 5CF4 ~                POP DE
 127+ 5CF4 ~                POP BC
 128+ 5CF4 ~                CALL RESTORE_PAGE_INFO
 129+ 5CF4 ~            	PUSH IX
 130+ 5CF4 ~            	POP HL
 131+ 5CF4 ~            	RET
 132+ 5CF4 ~            ; *******************************************************************************************************
 133+ 5CF4               ENDIF
 134+ 5CF4
 135+ 5CF4               IF (1 == 1)
 136+ 5CF4              ; *******************************************************************************************************
 137+ 5CF4              ; same as VUNPACK but for DEFUSR approach
 138+ 5CF4              ; input IX=pointer to input array, real data from +2
 139+ 5CF4              ; +2 = source address
 140+ 5CF4              ; +4 = destination address
 141+ 5CF4              ; *******************************************************************************************************
 142+ 5CF4              VUNPACK_DEFUSR:
 143+ 5CF4 3E CD            LD A, #CD ; CALL
 144+ 5CF6 32 B8 5C         LD (dzx0_ldir_1), A
 145+ 5CF9 32 C4 5C         LD (dzx0_ldir_2), A
 146+ 5CFC 21 5A 56         LD HL, VRAM_LDIRVM
 147+ 5CFF 22 B9 5C         LD (dzx0_ldir_1 + 1), HL
 148+ 5D02 22 C5 5C         LD (dzx0_ldir_2 + 1), HL
 149+ 5D05 18 10            JR UNPACK_DEFUSR_COMMON
 150+ 5D07              ; same as UNPACK but for DEFUSR approach
 151+ 5D07              ; input IX=pointer to input array, real data from +2
 152+ 5D07              ; +2 = source address
 153+ 5D07              ; +4 = destination address
 154+ 5D07              UNPACK_DEFUSR:
 155+ 5D07 21 ED B0         LD HL, #B0ED ; LDIR
 156+ 5D0A 22 B8 5C         LD (dzx0_ldir_1), HL
 157+ 5D0D 22 C4 5C         LD (dzx0_ldir_2), HL
 158+ 5D10 AF               XOR A ; NOP
 159+ 5D11 32 BA 5C         LD (dzx0_ldir_1 + 2), A
 160+ 5D14 32 C6 5C         LD (dzx0_ldir_2 + 2), A
 161+ 5D17              UNPACK_DEFUSR_COMMON:
 162+ 5D17              	; enable page 0
 163+ 5D17 FD 21 1E 5D  	LD IY, .RET
 164+ 5D1B C3 CB 5E     	JP ENABLE_PAGE0
 165+ 5D1E              .RET:
 166+ 5D1E FB           	EI
 167+ 5D1F DD 6E 02     	LD L,(IX+2)
 168+ 5D22 DD 66 03     	LD H,(IX+3)
 169+ 5D25 DD 5E 04     	LD E,(IX+4)
 170+ 5D28 DD 56 05     	LD D,(IX+5)
 171+ 5D2B CD AE 5C     	CALL dzx0_standard
 172+ 5D2E D1               POP DE
 173+ 5D2F C1               POP BC
 174+ 5D30 C3 42 5E         JP RESTORE_PAGE_INFO
 175+ 5D33              ; *******************************************************************************************************
 176+ 5D33               ENDIF
# file closed: asm\decomp.asm
 171  5D33               ENDIF
 172  5D33
 173  5D33               IF (1 == 1)
 174  5D33               INCLUDE "DEFUSR.asm"
# file opened: asm\DEFUSR.asm
   1+ 5D33              ; entry function that handles call using CALLF
   2+ 5D33              ; pointer to data structure is expected at DAC+2
   3+ 5D33              ; first entry must be function id followed by function specific parameters
   4+ 5D33
   5+ 5D33              DEFUSR_TABLE_ENTRIES    EQU 40
   6+ 5D33
   7+ 5D33              DEFUSR_JUMP_TABLE:
   8+ 5D33               IF (SPRITE_CMDS == 1)
   9+ 5D33 6E 4E         DW SPRENABLE_DEFUSR        ; 0
  10+ 5D35               ELSE
  11+ 5D35 ~             DW NOACTION_DEFUSR
  12+ 5D35               ENDIF
  13+ 5D35
  14+ 5D35               IF (SPRITE_CMDS == 1)
  15+ 5D35 92 4E         DW SPRDISABLE_DEFUSR        ; 1
  16+ 5D37               ELSE
  17+ 5D37 ~             DW NOACTION_DEFUSR
  18+ 5D37               ENDIF
  19+ 5D37
  20+ 5D37               IF (RAM_CMDS == 1)
  21+ 5D37 22 55         DW MEMCPY_DEFUSR           ; 2
  22+ 5D39               ELSE
  23+ 5D39 ~             DW NOACTION_DEFUSR
  24+ 5D39               ENDIF
  25+ 5D39
  26+ 5D39               IF (VRAM_CMDS == 1)        ; 3
  27+ 5D39 23 56         DW MEMVRM_DEFUSR
  28+ 5D3B               ELSE
  29+ 5D3B ~             DW NOACTION_DEFUSR
  30+ 5D3B               ENDIF
  31+ 5D3B
  32+ 5D3B               IF (BLIT_CMDS == 1)        ; 4
  33+ 5D3B 3C 59         DW BLIT_DEFUSR
  34+ 5D3D               ELSE
  35+ 5D3D ~             DW NOACTION_DEFUSR
  36+ 5D3D               ENDIF
  37+ 5D3D
  38+ 5D3D               IF (ANIM_CMDS == 1)        ; 5
  39+ 5D3D FA 53         DW SGAM_DEFUSR
  40+ 5D3F               ELSE
  41+ 5D3F ~             DW NOACTION_DEFUSR
  42+ 5D3F               ENDIF
  43+ 5D3F
  44+ 5D3F               IF (SPRITE_CMDS == 1)
  45+ 5D3F D5 4E         DW SPRGRPMOV_DEFUSR        ; 6
  46+ 5D41               ELSE
  47+ 5D41 ~             DW NOACTION_DEFUSR
  48+ 5D41               ENDIF
  49+ 5D41
  50+ 5D41               IF (COLL_CMD == 1)
  51+ 5D41 6D 5C         DW COLL_DEFUSR             ; 7
  52+ 5D43               ELSE
  53+ 5D43 ~             DW NOACTION_DEFUSR
  54+ 5D43               ENDIF
  55+ 5D43
  56+ 5D43               IF (SOUND_CMDS == 1)
  57+ 5D43 DD 55         DW SNDSFX_DEFUSR             ; 8
  58+ 5D45               ELSE
  59+ 5D45 ~             DW NOACTION_DEFUSR
  60+ 5D45               ENDIF
  61+ 5D45
  62+ 5D45               IF (ANIM_CMDS == 1)
  63+ 5D45 8B 52         DW ANIMSTEP_SINGLE_DEFUSR      ; 9
  64+ 5D47 9B 52         DW ANIMSTEP_MULTI_DEFUSR       ; 10
  65+ 5D49 AC 52         DW ANIMSTART_SINGLE_DEFUSR     ; 11
  66+ 5D4B BE 52         DW ANIMSTART_MULTI_DEFUSR      ; 12
  67+ 5D4D C3 52         DW ANIMSTOP_SINGLE_DEFUSR      ; 13
  68+ 5D4F CD 52         DW ANIMSTOP_MULTI_DEFUSR       ; 14
  69+ 5D51               ELSE
  70+ 5D51 ~             DW NOACTION_DEFUSR
  71+ 5D51 ~             DW NOACTION_DEFUSR
  72+ 5D51 ~             DW NOACTION_DEFUSR
  73+ 5D51 ~             DW NOACTION_DEFUSR
  74+ 5D51 ~             DW NOACTION_DEFUSR
  75+ 5D51 ~             DW NOACTION_DEFUSR
  76+ 5D51               ENDIF
  77+ 5D51
  78+ 5D51               IF (BOX_CMDS == 1)
  79+ 5D51 47 57         DW BOXMEMCPY_DEFUSR            ; 15
  80+ 5D53 7D 57         DW BOXMEMVRM_DEFUSR            ; 16
  81+ 5D55               ELSE
  82+ 5D55 ~             DW NOACTION_DEFUSR
  83+ 5D55 ~             DW NOACTION_DEFUSR
  84+ 5D55               ENDIF
  85+ 5D55
  86+ 5D55               IF (ANIM_CMDS == 1)
  87+ 5D55 35 4F         DW MAXANIMITEMS_DEFUSR         ; 17
  88+ 5D57 44 50         DW MAXANIMDEFS_DEFUSR          ; 18
  89+ 5D59 A1 50         DW MAXANIMSPRS_DEFUSR          ; 19
  90+ 5D5B 5F 51         DW MAXAUTOSGAMS_DEFUSR         ; 20
  91+ 5D5D FA 4F         DW ANIMITEMPAT_DEFUSR          ; 21
  92+ 5D5F 1F 50         DW ANIMITEMPTR_DEFUSR          ; 22
  93+ 5D61 7B 50         DW ANIMDEF_DEFUSR              ; 23
  94+ 5D63 EE 50         DW ANIMSPRITE_DEFUSR           ; 24
  95+ 5D65 25 51         DW ANIMCHAR_DEFUSR             ; 25
  96+ 5D67 B0 51         DW AUTOSGAMDEF_DEFUSR          ; 26
  97+ 5D69 40 52         DW AUTOSGAMSTART_DEFUSR        ; 27
  98+ 5D6B 67 52         DW AUTOSGAMSTOP_DEFUSR         ; 28
  99+ 5D6D               ELSE
 100+ 5D6D ~             DW NOACTION_DEFUSR
 101+ 5D6D ~             DW NOACTION_DEFUSR
 102+ 5D6D ~             DW NOACTION_DEFUSR
 103+ 5D6D ~             DW NOACTION_DEFUSR
 104+ 5D6D ~             DW NOACTION_DEFUSR
 105+ 5D6D ~             DW NOACTION_DEFUSR
 106+ 5D6D ~             DW NOACTION_DEFUSR
 107+ 5D6D ~             DW NOACTION_DEFUSR
 108+ 5D6D ~             DW NOACTION_DEFUSR
 109+ 5D6D ~             DW NOACTION_DEFUSR
 110+ 5D6D ~             DW NOACTION_DEFUSR
 111+ 5D6D ~             DW NOACTION_DEFUSR
 112+ 5D6D               ENDIF
 113+ 5D6D
 114+ 5D6D               IF (GENCAL_CMD == 1)
 115+ 5D6D C7 56         DW GENCAL_DEFUSR               ; 29
 116+ 5D6F               ELSE
 117+ 5D6F ~             DW NOACTION_DEFUSR
 118+ 5D6F               ENDIF
 119+ 5D6F
 120+ 5D6F               IF (RAM_CMDS == 1)
 121+ 5D6F 43 55         DW FILRAM_DEFUSR               ; 30
 122+ 5D71               ELSE
 123+ 5D71 ~             DW NOACTION_DEFUSR
 124+ 5D71               ENDIF
 125+ 5D71
 126+ 5D71               IF (SOUND_CMDS == 1)
 127+ 5D71 74 55         DW SNDPLYINI_DEFUSR            ; 31
 128+ 5D73 A7 55         DW SNDPLYON_DEFUSR             ; 32
 129+ 5D75 BA 55         DW SNDPLYOFF_DEFUSR            ; 33
 130+ 5D77               ELSE
 131+ 5D77 ~             DW NOACTION_DEFUSR
 132+ 5D77 ~             DW NOACTION_DEFUSR
 133+ 5D77 ~             DW NOACTION_DEFUSR
 134+ 5D77               ENDIF
 135+ 5D77
 136+ 5D77               IF (TILE_CMDS == 1)
 137+ 5D77 1E 5A         DW TILERAM_DEFUSR              ; 34
 138+ 5D79 D5 5A         DW TILEVRM_DEFUSR              ; 35
 139+ 5D7B               ELSE
 140+ 5D7B ~             DW NOACTION_DEFUSR
 141+ 5D7B ~             DW NOACTION_DEFUSR
 142+ 5D7B               ENDIF
 143+ 5D7B
 144+ 5D7B               IF (VRAM_CMDS == 1)
 145+ 5D7B 00 56         DW FILVRM_DEFUSR               ; 36
 146+ 5D7D 84 56         DW VRMMEM_DEFUSR               ; 37
 147+ 5D7F               ELSE
 148+ 5D7F ~             DW NOACTION_DEFUSR
 149+ 5D7F ~             DW NOACTION_DEFUSR
 150+ 5D7F               ENDIF
 151+ 5D7F
 152+ 5D7F               IF (DECOMP_CMDS == 1)
 153+ 5D7F 07 5D         DW UNPACK_DEFUSR               ; 38
 154+ 5D81               IF (VRAM_CMDS == 1)
 155+ 5D81 F4 5C          DW VUNPACK_DEFUSR             ; 39
 156+ 5D83               ELSE
 157+ 5D83 ~              DW NOACTION_DEFUSR
 158+ 5D83               ENDIF
 159+ 5D83               ELSE
 160+ 5D83 ~             DW NOACTION_DEFUSR
 161+ 5D83 ~             DW NOACTION_DEFUSR
 162+ 5D83               ENDIF
 163+ 5D83
 164+ 5D83              DEFUSR_ENTRY:
 165+ 5D83 FB               EI
 166+ 5D84 DD 2A F8 F7      LD IX,(DAC+2)
 167+ 5D88 DD 7E 00         LD A,(IX)
 168+ 5D8B FE 28            CP DEFUSR_TABLE_ENTRIES
 169+ 5D8D D0               RET NC ; return if an undefined function requested
 170+ 5D8E 26 00            LD H,0
 171+ 5D90 6F               LD L,A
 172+ 5D91 29               ADD HL,HL
 173+ 5D92 11 33 5D         LD DE,DEFUSR_JUMP_TABLE
 174+ 5D95 19               ADD HL,DE
 175+ 5D96 EB               EX DE,HL
 176+ 5D97 1A               LD A,(DE)
 177+ 5D98 6F               LD L,A
 178+ 5D99 13               INC DE
 179+ 5D9A 1A               LD A,(DE)
 180+ 5D9B 67               LD H,A
 181+ 5D9C E9               JP (HL) ; call function with IX=pointer to data array
 182+ 5D9D
# file closed: asm\DEFUSR.asm
 175  5D9D               ENDIF
 176  5D9D
 177  5D9D              ; temp variables for BLIT, TILE functions
 178  5D9D               IF (BLIT_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS + COLL_CMD > 0)
 179  5D9D              BLIT_TMP:
 180  5D9D              TILETMP1:
 181  5D9D              BLIT_TMP1:
 182  5D9D 00 00         DW 0
 183  5D9F              TILETMP2:
 184  5D9F              BLIT_TMP2:
 185  5D9F 00 00         DW 0
 186  5DA1              BLIT_STRUCT:
 187  5DA1 00 00 00...   DS 17
 188  5DA5               ENDIF
 189  5DB2
 190  5DB2               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 191  5DB2              VRAM_UPDATE_IN_PROGRESS:
 192  5DB2 00            DB 0
 193  5DB3               ENDIF
 194  5DB3
 195  5DB3              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 196  5DB3              ; per starting letter, if no commands with this letter, NULL value
 197  5DB3              CMDS:
 198  5DB3 E7 5D        	DW CMDS_A ; always present due to ARTINFO
 199  5DB5               IF (BLIT_CMDS + BOX_CMDS > 0) && (0 == 1)
 200  5DB5 ~                DW CMDS_B ; B
 201  5DB5               ELSE
 202  5DB5 00 00        	DW 0
 203  5DB7               ENDIF
 204  5DB7               IF (COLL_CMD == 1) && (0 == 1)
 205  5DB7 ~            	DW CMDS_C ;
 206  5DB7               ELSE
 207  5DB7 00 00            DW 0 ; C
 208  5DB9               ENDIF
 209  5DB9 00 00            DW 0 ; D
 210  5DBB 00 00            DW 0 ; E
 211  5DBD               IF (VRAM_CMDS + RAM_CMDS > 0) && (0 == 1)
 212  5DBD ~                DW CMDS_F; F
 213  5DBD               ELSE
 214  5DBD 00 00        	DW 0
 215  5DBF               ENDIF
 216  5DBF               IF (GENCAL_CMD > 0) && (0 == 1)
 217  5DBF ~                DW CMDS_G; G
 218  5DBF               ELSE
 219  5DBF 00 00        	DW 0
 220  5DC1               ENDIF
 221  5DC1 00 00            DW 0 ; H
 222  5DC3 00 00            DW 0 ; I
 223  5DC5 00 00            DW 0 ; J
 224  5DC7 00 00            DW 0 ; K
 225  5DC9 00 00            DW 0 ; L
 226  5DCB               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0) && (0 == 1)
 227  5DCB ~                DW CMDS_M ; M
 228  5DCB               ELSE
 229  5DCB 00 00        	DW 0
 230  5DCD               ENDIF
 231  5DCD 00 00            DW 0 ; N
 232  5DCF 00 00            DW 0 ; O
 233  5DD1 00 00            DW 0 ; P
 234  5DD3 00 00            DW 0 ; Q
 235  5DD5 00 00            DW 0 ; R
 236  5DD7               IF (SOUND_CMDS + SPRITE_CMDS > 0) && (0 == 1)
 237  5DD7 ~                DW CMDS_S ; S
 238  5DD7               ELSE
 239  5DD7 00 00        	DW 0
 240  5DD9               ENDIF
 241  5DD9               IF (TILE_CMDS > 0) && (0 == 1)
 242  5DD9 ~                DW CMDS_T ; T
 243  5DD9               ELSE
 244  5DD9 00 00        	DW 0
 245  5DDB               ENDIF
 246  5DDB               IF (DECOMP_CMDS > 0) && (0 == 1)
 247  5DDB ~                DW CMDS_U ; U
 248  5DDB               ELSE
 249  5DDB 00 00        	DW 0
 250  5DDD               ENDIF
 251  5DDD               IF ((VRAM_CMDS > 0) || (VRAM_CMDS + DECOMP_CMDS > 1)) && (0 == 1)
 252  5DDD ~                DW CMDS_V ; V
 253  5DDD               ELSE
 254  5DDD 00 00        	DW 0
 255  5DDF               ENDIF
 256  5DDF 00 00            DW 0 ; W
 257  5DE1 00 00            DW 0 ; X
 258  5DE3 00 00            DW 0 ; Y
 259  5DE5 00 00            DW 0 ; Z
 260  5DE7
 261  5DE7               IF (0 == 1)
 262  5DE7 ~             IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 263  5DE7 ~            CMDS_M:
 264  5DE7 ~             IF (VRAM_CMDS == 1)
 265  5DE7 ~                DB "MEMVRM", 0
 266  5DE7 ~                DW MEMVRM
 267  5DE7 ~             ENDIF
 268  5DE7 ~             IF (RAM_CMDS == 1)
 269  5DE7 ~            	DB "MEMCPY", 0
 270  5DE7 ~            	DW MEMCPY
 271  5DE7 ~             ENDIF
 272  5DE7 ~             IF (ANIM_CMDS == 1)
 273  5DE7 ~            	DB "MAXANIMITEMS",0
 274  5DE7 ~            	DW MAXANIMITEMS
 275  5DE7 ~            	DB "MAXANIMDEFS",0
 276  5DE7 ~            	DW MAXANIMDEFS
 277  5DE7 ~            	DB "MAXANIMSPRS",0
 278  5DE7 ~            	DW MAXANIMSPRS
 279  5DE7 ~               DB "MAXAUTOSGAMS",0
 280  5DE7 ~               DW MAXAUTOSGAMS
 281  5DE7 ~             ENDIF
 282  5DE7 ~             ENDIF
 283  5DE7 ~
 284  5DE7 ~             IF (VRAM_CMDS + RAM_CMDS > 0)
 285  5DE7 ~            CMDS_F:
 286  5DE7 ~             IF (VRAM_CMDS == 1)
 287  5DE7 ~                DB "FILVRM", 0
 288  5DE7 ~                DW FILVRM
 289  5DE7 ~             ENDIF
 290  5DE7 ~             IF (RAM_CMDS == 1)
 291  5DE7 ~                DB "FILRAM", 0
 292  5DE7 ~                DW FILRAM
 293  5DE7 ~             ENDIF
 294  5DE7 ~             ENDIF
 295  5DE7 ~
 296  5DE7 ~             IF (GENCAL_CMD > 0)
 297  5DE7 ~            CMDS_G:
 298  5DE7 ~             IF (GENCAL_CMD == 1)
 299  5DE7 ~                DB "GENCAL", 0
 300  5DE7 ~                DW GENCAL
 301  5DE7 ~             ENDIF
 302  5DE7 ~             ENDIF
 303  5DE7 ~
 304  5DE7 ~             IF (VRAM_CMDS > 0)
 305  5DE7 ~            CMDS_V:
 306  5DE7 ~             IF (VRAM_CMDS == 1)
 307  5DE7 ~            	DB "VRMMEM", 0
 308  5DE7 ~            	DW VRMMEM
 309  5DE7 ~             ENDIF
 310  5DE7 ~             IF (DECOMP_CMDS == 1)
 311  5DE7 ~            	DB "VUNPACK", 0
 312  5DE7 ~            	DW VUNPACK
 313  5DE7 ~             ENDIF
 314  5DE7 ~             ENDIF
 315  5DE7 ~
 316  5DE7 ~             IF (SOUND_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 317  5DE7 ~            CMDS_S:
 318  5DE7 ~             IF (SPRITE_CMDS + ANIM_CMDS > 0)
 319  5DE7 ~                DB "SGAM",0
 320  5DE7 ~                DW SGAM
 321  5DE7 ~             ENDIF
 322  5DE7 ~             IF (SPRITE_CMDS == 1)
 323  5DE7 ~            	DB "SPRGRPMOV", 0
 324  5DE7 ~            	DW SPRGRPMOV
 325  5DE7 ~             ENDIF
 326  5DE7 ~             IF (SOUND_CMDS == 1)
 327  5DE7 ~            	DB "SNDSFX", 0
 328  5DE7 ~            	DW SNDSFX
 329  5DE7 ~            	DB "SNDPLYON", 0
 330  5DE7 ~            	DW SNDPLYON
 331  5DE7 ~            	DB "SNDPLYOFF", 0
 332  5DE7 ~            	DW SNDPLYOFF
 333  5DE7 ~            	DB "SNDPLYINI", 0
 334  5DE7 ~            	DW SNDPLYINIT
 335  5DE7 ~             ENDIF
 336  5DE7 ~             IF (SPRITE_CMDS == 1)
 337  5DE7 ~            	DB "SPRENABLE", 0
 338  5DE7 ~            	DW SPRENABLE
 339  5DE7 ~            	DB "SPRDISABLE", 0
 340  5DE7 ~            	DW SPRDISABLE
 341  5DE7 ~             ENDIF
 342  5DE7 ~             ENDIF
 343  5DE7 ~
 344  5DE7 ~             IF (BLIT_CMDS + BOX_CMDS > 0)
 345  5DE7 ~            CMDS_B:
 346  5DE7 ~             IF (BLIT_CMDS == 1)
 347  5DE7 ~            	DB "BLIT", 0
 348  5DE7 ~            	DW BLIT
 349  5DE7 ~             ENDIF
 350  5DE7 ~             IF (BOX_CMDS == 1)
 351  5DE7 ~            	DB "BOXMEMCPY", 0
 352  5DE7 ~            	DW BOXMEMCPY
 353  5DE7 ~            	DB "BOXMEMVRM", 0
 354  5DE7 ~            	DW BOXMEMVRM
 355  5DE7 ~             ENDIF
 356  5DE7 ~             ENDIF
 357  5DE7 ~
 358  5DE7 ~             IF (TILE_CMDS > 0)
 359  5DE7 ~            CMDS_T:
 360  5DE7 ~             IF (TILE_CMDS == 1)
 361  5DE7 ~            	DB "TILERAM", 0
 362  5DE7 ~            	DW TILERAM
 363  5DE7 ~            	DB "TILEVRM", 0
 364  5DE7 ~            	DW TILEVRM
 365  5DE7 ~             ENDIF
 366  5DE7 ~             ENDIF
 367  5DE7 ~
 368  5DE7 ~             IF (COLL_CMD > 0)
 369  5DE7 ~            CMDS_C:
 370  5DE7 ~             IF (COLL_CMD == 1)
 371  5DE7 ~                DB "COLL", 0
 372  5DE7 ~                DW COLL
 373  5DE7 ~             ENDIF
 374  5DE7 ~             ENDIF
 375  5DE7 ~
 376  5DE7 ~             IF (DECOMP_CMDS > 0)
 377  5DE7 ~            CMDS_U:
 378  5DE7 ~             IF (DECOMP_CMDS == 1)
 379  5DE7 ~                DB "UNPACK", 0
 380  5DE7 ~                DW UNPACK
 381  5DE7 ~             ENDIF
 382  5DE7 ~             ENDIF
 383  5DE7 ~
 384  5DE7 ~            CMDS_A:
 385  5DE7 ~             IF (ANIM_CMDS == 1)
 386  5DE7 ~               DB "ANIMSTEP",0
 387  5DE7 ~               DW ANIMSTEP
 388  5DE7 ~            	DB "ANIMSTART",0
 389  5DE7 ~            	DW ANIMSTART
 390  5DE7 ~            	DB "ANIMSTOP",0
 391  5DE7 ~            	DW ANIMSTOP
 392  5DE7 ~            	DB "ANIMITEMPAT",0
 393  5DE7 ~            	DW ANIMITEMPAT
 394  5DE7 ~            	DB "ANIMITEMPTR",0
 395  5DE7 ~            	DW ANIMITEMPTR_CMD
 396  5DE7 ~            	DB "ANIMDEF",0
 397  5DE7 ~            	DW ANIMDEF
 398  5DE7 ~            	DB "ANIMSPRITE",0
 399  5DE7 ~            	DW ANIMSPRITE
 400  5DE7 ~               DB "ANIMCHAR",0
 401  5DE7 ~               DW ANIMCHAR
 402  5DE7 ~               DB "AUTOSGAMDEF",0
 403  5DE7 ~               DW AUTOSGAMDEF
 404  5DE7 ~               DB "AUTOSGAMSTART",0
 405  5DE7 ~               DW AUTOSGAMSTART
 406  5DE7 ~               DB "AUTOSGAMSTOP",0
 407  5DE7 ~               DW AUTOSGAMSTOP
 408  5DE7 ~             ENDIF
 409  5DE7 ~               DB "ARTINFO",0
 410  5DE7 ~               DW ARTINFO
 411  5DE7 ~            	DB 0
 412  5DE7               ELSE // if not BASIC extension
 413  5DE7              CMDS_A:
 414  5DE7 41 52 54 49     DB "ARTINFO",0
 414  5DEB 4E 46 4F 00
 415  5DEF 47 5F           DW ARTINFO
 416  5DF1 00           	DB 0
 417  5DF2               ENDIF
 418  5DF2
 419  5DF2               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 420  5DF2              ; ****************************************************************************************************
 421  5DF2              ; function sets VRAM address
 422  5DF2              ; input HL=address
 423  5DF2              ; modifies AF
 424  5DF2              SETWRT_LOCAL:
 425  5DF2 7D           	LD	A,L
 426  5DF3 D3 99        	OUT (099H),A
 427  5DF5 7C           	LD	A,H
 428  5DF6 E6 3F        	AND 03FH
 429  5DF8 F6 40        	OR	040H
 430  5DFA D3 99        	OUT (099H),A
 431  5DFC C9           	RET
 432  5DFD              ; ****************************************************************************************************
 433  5DFD               ENDIF
 434  5DFD
 435  5DFD               IF (VRAM_CMDS + TILE_CMDS > 0)
 436  5DFD              ; ****************************************************************************************************
 437  5DFD              ; function copies data from RAM to VRAM
 438  5DFD              ; input HL=address in RAM
 439  5DFD              ; input B=count
 440  5DFD              ; modifies AF, BC, HL
 441  5DFD              BBYTECOPY:
 442  5DFD 0E 98        	LD C,#98
 443  5DFF              BBYTECOPY_NO_C:
 444  5DFF ED A3        	OUTI
 445  5E01 C2 FF 5D     	JP	NZ, BBYTECOPY_NO_C
 446  5E04 C9           	RET
 447  5E05              ; ****************************************************************************************************
 448  5E05               ENDIF
 449  5E05
 450  5E05              ; ****************************************************************************************************
 451  5E05              ; function multiplies HL by 32
 452  5E05              HLx32:
 453  5E05 29           	ADD HL,HL
 454  5E06              ; ****************************************************************************************************
 455  5E06              ; function multiplies HL by 16
 456  5E06              HLx16:
 457  5E06 29           	ADD HL,HL
 458  5E07              ; ****************************************************************************************************
 459  5E07              ; function multiplies HL by 8
 460  5E07              HLx8:
 461  5E07 29          > ADD HL, HL
 461  5E08 29          > ADD HL, HL
 461  5E09 29          > ADD HL, HL
 462  5E0A C9           	RET
 463  5E0B              ; ****************************************************************************************************
 464  5E0B
 465  5E0B              ; ****************************************************************************************************
 466  5E0B              ; function gets slot and subslot data for specific page
 467  5E0B              ; input A=page (0, 1 or 2)
 468  5E0B              ; output B = 0A8H register value
 469  5E0B              ; output D = 0 is no subslots, 1 if yes
 470  5E0B              ; output C = 0A8H value when page 3 slot equals to requested page slot
 471  5E0B              ; output E = subslot value if present
 472  5E0B              ; modifies AF, BC, DE, HL
 473  5E0B              GET_PAGE_INFO:
 474  5E0B 6F               LD L, A
 475  5E0C C6 C1            ADD A, low (EXPTBL)
 476  5E0E 32 18 5E         LD (GET_PAGE_INFO_L1+1), A
 477  5E11 DB A8            IN A, (0A8H)
 478  5E13 47               LD B, A
 479  5E14 E6 3F            AND 03FH
 480  5E16 4F               LD C, A
 481  5E17              GET_PAGE_INFO_L1:
 482  5E17 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 483  5E1A E6 80            AND 080H
 484  5E1C 28 1B            JR Z, GET_PAGE_INFO_L2
 485  5E1E                  ; expanded
 486  5E1E 2D               DEC L
 487  5E1F FA 3E 5E         JP M, GET_PAGE_INFO_L3
 488  5E22 2D               DEC L
 489  5E23 FA 3C 5E         JP M, GET_PAGE_INFO_L4
 490  5E26                  ; page 2
 491  5E26 07               RLCA
 492  5E27 07               RLCA
 493  5E28              GET_PAGE_INFO_L5:
 494  5E28 E6 C0            AND 0C0H
 495  5E2A B1               OR C
 496  5E2B D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 497  5E2D 4F               LD C, A
 498  5E2E 3A FF FF         LD A, (0FFFFH)
 499  5E31 2F               CPL
 500  5E32 5F               LD E, A
 501  5E33 16 01            LD D, 1
 502  5E35 78               LD A, B ; return stack
 503  5E36 D3 A8            OUT (0A8H), A
 504  5E38 C9               RET
 505  5E39              GET_PAGE_INFO_L2:
 506  5E39                  ; not expanded
 507  5E39 16 00            LD D, 0
 508  5E3B C9               RET
 509  5E3C              GET_PAGE_INFO_L4:
 510  5E3C                  ; page 1
 511  5E3C 0F               RRCA
 512  5E3D 0F               RRCA
 513  5E3E              GET_PAGE_INFO_L3:
 514  5E3E                  ; page 0
 515  5E3E 0F               RRCA
 516  5E3F 0F               RRCA
 517  5E40 18 E6            JR GET_PAGE_INFO_L5
 518  5E42              ; ****************************************************************************************************
 519  5E42
 520  5E42              ; ****************************************************************************************************
 521  5E42              ; function returns original slot and subslot info
 522  5E42              ; input B = 0A8H register value
 523  5E42              ; input D = 0 is no subslots, 1 if yes
 524  5E42              ; input C = 0A8H value when page 3 slot equals to requested page slot
 525  5E42              ; input E = subslot value if present
 526  5E42              ; modifies AF, disables interrupts
 527  5E42              RESTORE_PAGE_INFO:
 528  5E42 F3              DI
 529  5E43 7A              LD A, D
 530  5E44 B7              OR A
 531  5E45 28 07           JR Z, RESTORE_PAGE_INFO_L1
 532  5E47 79              LD A, C
 533  5E48 D3 A8           OUT (0A8H), A
 534  5E4A 7B              LD A, E
 535  5E4B 32 FF FF        LD (0FFFFH), A
 536  5E4E              RESTORE_PAGE_INFO_L1:
 537  5E4E 78              LD A, B
 538  5E4F D3 A8           OUT (0A8H), A
 539  5E51              NOACTION_DEFUSR: ; just a safe RET for use when DEFUSR table has an empty entry
 540  5E51 C9              RET
 541  5E52              ; ****************************************************************************************************
 542  5E52
 543  5E52              ; *******************************************************************************************************
 544  5E52              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 545  5E52              ; INPUT:  A = SLOT ID: EXXXSSPP
 546  5E52              ; E = EXPANDED FLAG
 547  5E52              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 548  5E52              ; PP = PRIMARY SLOT NUMBER
 549  5E52              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 550  5E52              ; CHANGES: AF, BC, DE
 551  5E52
 552  5E52              LOCAL_ENASLT:
 553  5E52 CD 72 5E         CALL L0353
 554  5E55 FA 5F 5E         JP M, L0340
 555  5E58 DB A8            IN A, (0A8H)
 556  5E5A A1               AND C
 557  5E5B B0               OR B
 558  5E5C D3 A8            OUT (0A8H), A
 559  5E5E C9               RET
 560  5E5F              L0340:
 561  5E5F E5               PUSH HL
 562  5E60 CD 97 5E         CALL L0378
 563  5E63 4F               LD C, A
 564  5E64 06 00            LD B, 0
 565  5E66 7D               LD A, L
 566  5E67 A4               AND H
 567  5E68 B2               OR D
 568  5E69 21 C5 FC         LD HL, 0FCC5H
 569  5E6C 09               ADD HL, BC
 570  5E6D 77               LD (HL), A
 571  5E6E E1               POP HL
 572  5E6F 79               LD A, C
 573  5E70 18 E0            JR LOCAL_ENASLT
 574  5E72              L0353:
 575  5E72 F3               DI
 576  5E73 F5               PUSH AF
 577  5E74 7C               LD A, H
 578  5E75 07               RLCA
 579  5E76 07               RLCA
 580  5E77 E6 03            AND 3
 581  5E79 5F               LD E, A
 582  5E7A 3E C0            LD A, 0C0H
 583  5E7C              L035D:
 584  5E7C 07               RLCA
 585  5E7D 07               RLCA
 586  5E7E 1D               DEC E
 587  5E7F F2 7C 5E         JP P, L035D
 588  5E82 5F               LD E, A
 589  5E83 2F               CPL
 590  5E84 4F               LD C, A
 591  5E85 F1               POP AF
 592  5E86 F5               PUSH AF
 593  5E87 E6 03            AND 3
 594  5E89 3C               INC A
 595  5E8A 47               LD B, A
 596  5E8B 3E AB            LD A, 0ABH
 597  5E8D              L036E:
 598  5E8D C6 55            ADD A, 055H
 599  5E8F 10 FC            DJNZ L036E
 600  5E91 57               LD D, A
 601  5E92 A3               AND E
 602  5E93 47               LD B, A
 603  5E94 F1               POP AF
 604  5E95 A7               AND A
 605  5E96 C9               RET
 606  5E97              L0378:
 607  5E97 F5               PUSH AF
 608  5E98 7A               LD A, D
 609  5E99 E6 C0            AND 0C0H
 610  5E9B 4F               LD C, A
 611  5E9C F1               POP AF
 612  5E9D F5               PUSH AF
 613  5E9E 57               LD D, A
 614  5E9F DB A8            IN A, (0A8H)
 615  5EA1 47               LD B, A
 616  5EA2 E6 3F            AND 03FH
 617  5EA4 B1               OR C
 618  5EA5 D3 A8            OUT (0A8H), A
 619  5EA7 7A               LD A, D
 620  5EA8 0F               RRCA
 621  5EA9 0F               RRCA
 622  5EAA E6 03            AND 3
 623  5EAC 57               LD D, A
 624  5EAD 3E AB            LD A, 0ABH
 625  5EAF              L0390:
 626  5EAF C6 55            ADD A, 055H
 627  5EB1 15               DEC D
 628  5EB2 F2 AF 5E         JP P, L0390
 629  5EB5 A3               AND E
 630  5EB6 57               LD D, A
 631  5EB7 7B               LD A, E
 632  5EB8 2F               CPL
 633  5EB9 67               LD H, A
 634  5EBA 3A FF FF         LD A, (0FFFFH)
 635  5EBD 2F               CPL
 636  5EBE 6F               LD L, A
 637  5EBF A4               AND H
 638  5EC0 B2               OR D
 639  5EC1 32 FF FF         LD (0FFFFH), A
 640  5EC4 78               LD A, B
 641  5EC5 D3 A8            OUT (0A8H), A
 642  5EC7 F1               POP AF
 643  5EC8 E6 03            AND 3
 644  5ECA C9               RET
 645  5ECB              ; *******************************************************************************************************
 646  5ECB
 647  5ECB              ; *******************************************************************************************************
 648  5ECB              ; some common code to activate page 0 and place values needed to restore original page on stack
 649  5ECB              ; input IY=return address
 650  5ECB              ENABLE_PAGE0:
 651  5ECB F3              DI
 652  5ECC AF              XOR A
 653  5ECD CD 0B 5E        CALL GET_PAGE_INFO
 654  5ED0 C5              PUSH BC
 655  5ED1 D5              PUSH DE
 656  5ED2 3A 41 F3        LD A, (RAMAD0)
 657  5ED5 26 00           LD H, 0
 658  5ED7 CD 52 5E        CALL LOCAL_ENASLT
 659  5EDA FD E9        	JP (IY)
 660  5EDC              ; *******************************************************************************************************
 661  5EDC
 662  5EDC              ; General BASIC CALL-instruction handler
 663  5EDC              CALLHAND:
 664  5EDC FB              EI
 665  5EDD E5           	PUSH HL
 666  5EDE 21 B3 5D     	LD	HL, CMDS ; pointer table based on starting letter
 667  5EE1 3A 89 FD        LD A, (PROCNM)
 668  5EE4 D6 41           SUB 'A'
 669  5EE6 87              ADD A, A
 670  5EE7 16 00           LD D, 0
 671  5EE9 5F              LD E, A
 672  5EEA 19              ADD HL, DE
 673  5EEB 5E              LD E, (HL)
 674  5EEC 23              INC HL
 675  5EED 56              LD D, (HL)
 676  5EEE 7A              LD A, D
 677  5EEF B3              OR E
 678  5EF0 28 23           JR Z, .CMDNOTRECOGNIZED
 679  5EF2 EB              EX DE, HL
 680  5EF3              .CHKCMD:
 681  5EF3 11 89 FD     	LD	DE, PROCNM
 682  5EF6              .LOOP:
 683  5EF6 1A              LD	A,(DE)
 684  5EF7 BE           	CP	(HL)
 685  5EF8 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 686  5EFA 13           	INC	DE
 687  5EFB 23           	INC	HL
 688  5EFC A7           	AND	A
 689  5EFD 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 690  5EFF 5E           	LD	E,(HL)
 691  5F00 23           	INC	HL
 692  5F01 56           	LD	D,(HL)
 693  5F02 E1           	POP	HL		; routine address
 694  5F03 CD 24 5F     	CALL	GETPREVCHAR
 695  5F06 CD 18 5F     	CALL	.CALLDE		; Call routine
 696  5F09 A7           	AND	A
 697  5F0A C9           	RET
 698  5F0B
 699  5F0B              .TONEXTCMD:
 700  5F0B 0E FF        	LD	C,0FFH
 701  5F0D AF           	XOR	A
 702  5F0E ED B1        	CPIR			; Skip to end of instruction name
 703  5F10 23           	INC	HL
 704  5F11 23           	INC	HL		; Skip address
 705  5F12 BE           	CP	(HL)
 706  5F13 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 707  5F15              .CMDNOTRECOGNIZED:
 708  5F15 E1           	POP	HL
 709  5F16 37              SCF
 710  5F17 C9           	RET
 711  5F18
 712  5F18              .CALLDE:
 713  5F18 D5           	PUSH	DE
 714  5F19 C9           	RET
 715  5F1A
 716  5F1A              ;---------------------------
 717  5F1A
 718  5F1A              ;GETSTRPNT:
 719  5F1A              ; OUT:
 720  5F1A              ; HL = String Address
 721  5F1A              ; B  = Lenght
 722  5F1A              ;        LD      HL,(USR)
 723  5F1A              ;        LD      B,(HL)
 724  5F1A              ;        INC     HL
 725  5F1A              ;        LD      E,(HL)
 726  5F1A              ;        INC     HL
 727  5F1A              ;        LD      D,(HL)
 728  5F1A              ;        EX      DE,HL
 729  5F1A              ;        RET
 730  5F1A
 731  5F1A              ;EVALTXTPARAM:
 732  5F1A              ;	CALL	CHKCHAR
 733  5F1A              ;	DEFB	"("             ; Check for (
 734  5F1A              ;	LD	IX,FRMEVL
 735  5F1A              ;	CALL	CALBAS		; Evaluate expression
 736  5F1A              ;       LD      A,(VALTYP)
 737  5F1A              ;        CP      3               ; Text type?
 738  5F1A              ;        JP      NZ,TYPE_MISMATCH
 739  5F1A              ;        PUSH	HL
 740  5F1A              ;        LD	IX,FRESTR         ; Free the temporary string
 741  5F1A              ;        CALL	CALBAS
 742  5F1A              ;        POP	HL
 743  5F1A              ;	CALL	CHKCHAR
 744  5F1A              ;	DEFB	")"             ; Check for )
 745  5F1A              ;        RET
 746  5F1A
 747  5F1A
 748  5F1A              CHKCHAR:
 749  5F1A CD 24 5F     	CALL	GETPREVCHAR	; Get previous basic char
 750  5F1D E3           	EX	(SP),HL
 751  5F1E BE           	CP	(HL) 	        ; Check if good char
 752  5F1F 20 1D        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 753  5F21 23           	INC	HL
 754  5F22 E3           	EX	(SP),HL
 755  5F23 23           	INC	HL		; Get next basic char
 756  5F24
 757  5F24              GETPREVCHAR:
 758  5F24 2B           	DEC HL
 759  5F25 DD 21 66 46  	LD	IX,CHRGTR
 760  5F29 CD 59 01     	CALL CALBAS
 761  5F2C FB              EI
 762  5F2D C9              RET
 763  5F2E
 764  5F2E
 765  5F2E              TYPE_MISMATCH:
 766  5F2E 1E 0D            LD E, 13 ; Type mismatch
 767  5F30 18 0E            JR THROW_ERROR
 768  5F32              SUBSCRIPT_OUT_OF_RANGE:
 769  5F32 1E 09            LD E,9 ; subscript out of range
 770  5F34 18 0A        	JR THROW_ERROR
 771  5F36              OVERFLOW:
 772  5F36 1E 06        	LD E,6
 773  5F38 18 06        	JR THROW_ERROR
 774  5F3A              ILLEGAL_FUNCTION:
 775  5F3A 1E 05            LD E, 5 ; illegal function call
 776  5F3C 18 02            JR THROW_ERROR
 777  5F3E              SYNTAX_ERROR:
 778  5F3E 1E 02            LD E, 2 ; Syntax error
 779  5F40              THROW_ERROR:
 780  5F40 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 781  5F44 C3 59 01     	JP	CALBAS
 782  5F47
 783  5F47              ;---------------------------
 784  5F47
 785  5F47               IF (0 == 1)
 786  5F47 ~            ; *******************************************************************************************************
 787  5F47 ~            ; helper function to get pointer to BASIC array data
 788  5F47 ~            ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
 789  5F47 ~            ; input B=dimensions (1 or 2)
 790  5F47 ~            ; input D=minimal first dimension
 791  5F47 ~            ; input E=minimal second dimension, if applicable
 792  5F47 ~            ; returns BC=pointer to first data element
 793  5F47 ~            ; throws BASIC error if invalid type
 794  5F47 ~            GET_BASIC_ARRAY_DATA_POINTER:
 795  5F47 ~            	PUSH DE
 796  5F47 ~            	PUSH BC
 797  5F47 ~            	PUSH AF
 798  5F47 ~               LD A,1
 799  5F47 ~               LD (SUBFLG),A ; search for arrays only
 800  5F47 ~            	LD IX, PTRGET
 801  5F47 ~            	CALL CALBAS
 802  5F47 ~               XOR A
 803  5F47 ~               LD (SUBFLG),A ; if not reset will cause syntax errors
 804  5F47 ~            	LD A,(VALTYP)
 805  5F47 ~            	POP DE ; required type
 806  5F47 ~            	CP D
 807  5F47 ~            	JP NZ,TYPE_MISMATCH
 808  5F47 ~            	LD A,(BC)
 809  5F47 ~            	INC BC
 810  5F47 ~            	POP DE ; required number of dimensions
 811  5F47 ~            	CP D
 812  5F47 ~            	JP NZ,TYPE_MISMATCH
 813  5F47 ~            	POP DE ; required minimal array dimensions
 814  5F47 ~            	DEC A
 815  5F47 ~            	JR Z,.ONE_DIMENSION
 816  5F47 ~            	; 2-dimension array
 817  5F47 ~            	LD A,(BC)
 818  5F47 ~            	.2 INC BC
 819  5F47 ~            	CP E
 820  5F47 ~            	JP C,SUBSCRIPT_OUT_OF_RANGE
 821  5F47 ~            .ONE_DIMENSION:
 822  5F47 ~            	LD A,(BC)
 823  5F47 ~            	.2 INC BC
 824  5F47 ~            	CP D
 825  5F47 ~            	JP C,SUBSCRIPT_OUT_OF_RANGE
 826  5F47 ~            	RET
 827  5F47 ~            ; *******************************************************************************************************
 828  5F47               ENDIF
 829  5F47
 830  5F47              ; *******************************************************************************************************
 831  5F47              ; function to handle CALL ARTINFO basic extension
 832  5F47              ; returns info about the extension
 833  5F47              ; _ARTINFO ( INT variable version,
 834  5F47              ;			    INT variable build_flags,
 835  5F47              ;			    INT variable free_memory_ptr )
 836  5F47              ; this function is always available and can be used to test if the extension is active
 837  5F47              ARTINFO:
 838  5F47              	; opening (
 839  5F47 CD 1A 5F     	CALL CHKCHAR
 840  5F4A 28           	DB '('
 841  5F4B              	; get address of version variable
 842  5F4B DD 21 A4 5E  	LD IX, PTRGET
 843  5F4F CD 59 01     	CALL CALBAS
 844  5F52 3A 12 40     	LD A,(VERSION)
 845  5F55 12              LD (DE),A
 846  5F56 13              INC DE
 847  5F57 3A 13 40        LD A,(VERSION+1)
 848  5F5A 12              LD (DE),A
 849  5F5B              	; comma
 850  5F5B CD 1A 5F     	CALL CHKCHAR
 851  5F5E 2C           	DB ','
 852  5F5F              	; get address of build flags variable
 853  5F5F DD 21 A4 5E  	LD IX, PTRGET
 854  5F63 CD 59 01     	CALL CALBAS
 855  5F66 E5              PUSH HL
 856  5F67 21 FF 0B        LD HL,SOUND_CMDS+2*RAM_CMDS+4*VRAM_CMDS+8*BLIT_CMDS+16*SPRITE_CMDS+32*GENCAL_CMD+64*TILE_CMDS+128*BOX_CMDS+256*ANIM_CMDS+512*COLL_CMD+1024*0+2048*1
 857  5F6A EB              EX DE,HL
 858  5F6B 73              LD (HL),E
 859  5F6C 23              INC HL
 860  5F6D 72              LD (HL),D
 861  5F6E E1              POP HL
 862  5F6F              	; comma
 863  5F6F CD 1A 5F     	CALL CHKCHAR
 864  5F72 2C           	DB ','
 865  5F73              	; get address of free memory variable
 866  5F73 DD 21 A4 5E  	LD IX, PTRGET
 867  5F77 CD 59 01     	CALL CALBAS
 868  5F7A 3A 10 40     	LD A,(FREEMEMPTR)
 869  5F7D 12              LD (DE),A
 870  5F7E 13              INC DE
 871  5F7F 3A 11 40        LD A,(FREEMEMPTR+1)
 872  5F82 12              LD (DE),A
 873  5F83              	; ending )
 874  5F83 CD 1A 5F     	CALL CHKCHAR
 875  5F86 29           	DB ')'
 876  5F87 C9           	RET
 877  5F88              ; *******************************************************************************************************
 878  5F88
 879  5F88              EXT_END:
 880  5F88
# file closed: asm\main.asm
