# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		   EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000              COLL_CMD       EQU 1
  14  4000
  15  4000              ;BASIC_EXTENSION   EQU 0
  16  4000              ;DEFUSR_EXTENSION  EQU 1
  17  4000
  18  4000              CHPUT   EQU    #A2
  19  4000              CALBAS  EQU		#159
  20  4000              ERRHAND EQU    #406F
  21  4000              FRMEVL  EQU    #4C64
  22  4000              FRESTR  EQU		#67D0
  23  4000              ; FRMQNT = formula quantificator
  24  4000              ; input HL=pointer to current program expression
  25  4000              ; output HL=next address
  26  4000              ; output DE=integer datum
  27  4000              FRMQNT	EQU		#542F
  28  4000              ; GETBYT = get byte parameter
  29  4000              ; input HL=pointer to current program expression
  30  4000              ; output HL=next address
  31  4000              ; output A=E=byte read
  32  4000              GETBYT		EQU	#521C
  33  4000              CHRGTR  	   EQU   #4666
  34  4000              PTRGET		EQU 	#5EA4
  35  4000              SUBFLG		EQU	#F6A5
  36  4000              SYNCHR		EQU	#558C
  37  4000              VALTYP  	   EQU   #F663
  38  4000              DAC         EQU   #F7F6
  39  4000              USR     	   EQU   #F7F8
  40  4000              PROCNM		EQU	#FD89
  41  4000              BIOS_FILVRM EQU   #0056
  42  4000              CLIKSW		EQU	#F3DB
  43  4000
  44  4000              RAMAD0	   EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  45  4000              RAMAD1	   EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  46  4000              RAMAD2	   EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  47  4000              RAMAD3	   EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  48  4000              EXPTBL	   EQU   #FCC1
  49  4000              SCRMOD	   EQU   #FCAF ; current screen mode
  50  4000              REG1SAV     EQU   #F3E0 ; VDP(1)
  51  4000              JIFFY	      EQU   #FC9E
  52  4000              GRPPAT	   EQU   #F3CF ; SCREEN 2 sprite generator table address
  53  4000              GRPCGP		EQU	#F3CB ; SCREEN 2 pattern generator table address
  54  4000              GRPATR      EQU   #F3CD ; SCREEN 2 sprite attribute table address
  55  4000              T32PAT	   EQU   #F3C5 ; SCREEN 1 sprite generator table address
  56  4000              T32CGP      EQU   #F3C1 ; SCREEN 1 pattern ganarator table address
  57  4000              T32ATR      EQU   #F3C3 ; SCREEN 1 sprite attribute table address
  58  4000
  59  4000              ; BASIC error codes
  60  4000              ;01 NEXT without FOR
  61  4000              ;02 Syntax error
  62  4000              ;03 RETURN without GOSUB
  63  4000              ;04 Out of DATA
  64  4000              ;05 Illegal function call
  65  4000              ;06 Overflow
  66  4000              ;07 Out of memory
  67  4000              ;08 Undefined line number
  68  4000              ;09 Subscript out of range
  69  4000              ;10 Redimensioned array
  70  4000              ;11 Division by zero
  71  4000              ;12 Illegal direct
  72  4000              ;13 Type mismatch
  73  4000              ;14 Out of string space
  74  4000              ;15 String too long
  75  4000              ;16 String formula too complex
  76  4000              ;17 Can't CONTINUE
  77  4000              ;18 Undefined user function
  78  4000              ;19 Device I/O error
  79  4000              ;20 Verify error
  80  4000              ;21 No RESUME
  81  4000              ;22 RESUME without error
  82  4000              ;23 Unprintable error
  83  4000              ;24 Missing operand
  84  4000              ;25 Line buffer overflow
  85  4000              ;50 FIELD overflow
  86  4000              ;51 Internal error
  87  4000              ;52 Bad file number
  88  4000              ;53 File not found
  89  4000              ;54 File already open
  90  4000              ;55 Input past end
  91  4000              ;56 Bad file name
  92  4000              ;57 Direct statement in file
  93  4000              ;58 Sequential I/O only
  94  4000              ;59 File not OPEN
  95  4000
  96  4000
  97  4000               ; simulate cartridge with BASIC extension
  98  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  98  4004 07 65 00 00
  98  4008 00 00 00 00
  98  400C 00 00 00 00
  99  4010
 100  4010              ; this location #4010 stores last location used by basic extension
 101  4010              ; free memory after that point
 102  4010              FREEMEMPTR:
 103  4010 E8 65         DW EXT_END
 104  4012
 105  4012              ; this location #4012 stores extension version in DAA format
 106  4012              ; first byte is major version and second minor
 107  4012              VERSION:
 108  4012 00 90         DB #00, #90
 109  4014
 110  4014              ; this location #4014 contains a jump to entry point for DEFUSR approach
 111  4014              ; if excluded it contains 3xRET so that sound player can be at aspecific spot
 112  4014               IF (0 == 1)
 113  4014 ~               JP DEFUSR_ENTRY
 114  4014               ELSE
 115  4014 C9          > RET
 115  4015 C9          > RET
 115  4016 C9          > RET
 116  4017               ENDIF
 117  4017
 118  4017              ; binary included AKG player compiled at #4017
 119  4017               IF (SOUND_CMDS == 1)
 120  4017              	INCBIN "bin/AKG.bin"
 121  4CF3              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF3              MAIN_PLAYER_START EQU 04017H
   2+ 4CF3              PLY_AKG_START EQU 04017H
   3+ 4CF3              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 04020H
   4+ 4CF3              PLY_AKG_INITSOUNDEFFECTS EQU 04020H
   5+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04024H
   6+ 4CF3              PLY_AKG_PLAYSOUNDEFFECT EQU 04024H
   7+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04025H
   8+ 4CF3              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04025H
   9+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 0404CH
  10+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 0404CH
  11+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 0405AH
  12+ 4CF3              PLY_AKG_PSES_PLAY EQU 04093H
  13+ 4CF3              PLY_AKG_PSES_READFIRSTBYTE EQU 0409CH
  14+ 4CF3              PLY_AKG_PSES_S_ENDORLOOP EQU 040B4H
  15+ 4CF3              PLY_AKG_PSES_S_LOOP EQU 040BFH
  16+ 4CF3              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C5H
  17+ 4CF3              PLY_AKG_PSES_NOTREACHED EQU 040D8H
  18+ 4CF3              PLY_AKG_PSES_HARDWAREONLY EQU 040DCH
  19+ 4CF3              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E3H
  20+ 4CF3              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F5H
  21+ 4CF3              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FFH
  22+ 4CF3              PLY_AKG_PSES_H_AFTERRETRIG EQU 04109H
  23+ 4CF3              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411DH
  24+ 4CF3              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 04122H
  25+ 4CF3              PLY_AKG_PSES_READHARDWAREPERIOD EQU 0412AH
  26+ 4CF3              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04135H
  27+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 04141H
  28+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04143H
  29+ 4CF3              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04149H
  30+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414DH
  31+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414DH
  32+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414FH
  33+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414FH
  34+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414FH
  35+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 04150H
  36+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 04151H
  37+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04155H
  38+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04155H
  39+ 4CF3              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04155H
  40+ 4CF3              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415DH
  41+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04165H
  42+ 4CF3              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04165H
  43+ 4CF3              PLY_AKG_INIT EQU 04165H
  44+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04165H
  45+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04193H
  46+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A7H
  47+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B9H
  48+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D8H
  49+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E5H
  50+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL EQU 041EBH
  51+ 4CF3              PLY_AKG_INITTABLE0 EQU 041EEH
  52+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EEH
  53+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04208H
  54+ 4CF3              PLY_AKG_INITTABLE0_END EQU 04208H
  55+ 4CF3              PLY_AKG_INITTABLE1 EQU 04208H
  56+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04208H
  57+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 0420CH
  58+ 4CF3              PLY_AKG_INITTABLE1_END EQU 0420CH
  59+ 4CF3              PLY_AKG_INITTABLEORA EQU 0420CH
  60+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 0420CH
  61+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04224H
  62+ 4CF3              PLY_AKG_INITTABLEORA_END EQU 04224H
  63+ 4CF3              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04224H
  64+ 4CF3              PLY_AKG_STOP EQU 04224H
  65+ 4CF3              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04236H
  66+ 4CF3              PLY_AKG_PLAY EQU 04236H
  67+ 4CF3              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423EH
  68+ 4CF3              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04244H
  69+ 4CF3              PLY_AKG_READLINKER EQU 04249H
  70+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04249H
  71+ 4CF3              PLY_AKG_READLINKER_PTLINKER EQU 04249H
  72+ 4CF3              PLY_AKG_READLINKER_NOLOOP EQU 04254H
  73+ 4CF3              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428DH
  74+ 4CF3              PLY_AKG_READLINE EQU 04290H
  75+ 4CF3              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 04290H
  76+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04296H
  77+ 4CF3              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04296H
  78+ 4CF3              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A3H
  79+ 4CF3              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A7H
  80+ 4CF3              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042AAH
  81+ 4CF3              PLY_AKG_SPEEDTRACK_END EQU 042ADH
  82+ 4CF3              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042ADH
  83+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B3H
  84+ 4CF3              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B3H
  85+ 4CF3              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042C0H
  86+ 4CF3              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C4H
  87+ 4CF3              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C7H
  88+ 4CF3              PLY_AKG_EVENTTRACK_END EQU 042CAH
  89+ 4CF3              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042CAH
  90+ 4CF3              PLY_AKG_CHANNEL1_READTRACK EQU 042D6H
  91+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D6H
  92+ 4CF3              PLY_AKG_CHANNEL1_PTTRACK EQU 042D6H
  93+ 4CF3              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042F1H
  94+ 4CF3              PLY_AKG_CHANNEL1_WAIT EQU 042FCH
  95+ 4CF3              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04303H
  96+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04303H
  97+ 4CF3              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04303H
  98+ 4CF3              PLY_AKG_CHANNEL1_NOTE EQU 0430CH
  99+ 4CF3              PLY_AKG_BASENOTEINDEX EQU 0430CH
 100+ 4CF3              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430EH
 101+ 4CF3              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430EH
 102+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431EH
 103+ 4CF3              PLY_AKG_INSTRUMENTSTABLE EQU 0431EH
 104+ 4CF3              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 04330H
 105+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 04340H
 106+ 4CF3              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04368H
 107+ 4CF3              PLY_AKG_CHANNEL1_READCELLEND EQU 0436BH
 108+ 4CF3              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 0436BH
 109+ 4CF3              PLY_AKG_CHANNEL2_READTRACK EQU 04377H
 110+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04377H
 111+ 4CF3              PLY_AKG_CHANNEL2_PTTRACK EQU 04377H
 112+ 4CF3              PLY_AKG_CHANNEL2_SMALLWAIT EQU 04392H
 113+ 4CF3              PLY_AKG_CHANNEL2_WAIT EQU 0439DH
 114+ 4CF3              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A4H
 115+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A4H
 116+ 4CF3              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A4H
 117+ 4CF3              PLY_AKG_CHANNEL2_NOTE EQU 043ADH
 118+ 4CF3              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043B2H
 119+ 4CF3              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043B2H
 120+ 4CF3              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D4H
 121+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E4H
 122+ 4CF3              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 0440CH
 123+ 4CF3              PLY_AKG_CHANNEL2_READCELLEND EQU 0440FH
 124+ 4CF3              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440FH
 125+ 4CF3              PLY_AKG_CHANNEL3_READTRACK EQU 0441BH
 126+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 0441BH
 127+ 4CF3              PLY_AKG_CHANNEL3_PTTRACK EQU 0441BH
 128+ 4CF3              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04436H
 129+ 4CF3              PLY_AKG_CHANNEL3_WAIT EQU 04441H
 130+ 4CF3              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04448H
 131+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04448H
 132+ 4CF3              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04448H
 133+ 4CF3              PLY_AKG_CHANNEL3_NOTE EQU 04451H
 134+ 4CF3              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04456H
 135+ 4CF3              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04456H
 136+ 4CF3              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04478H
 137+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04488H
 138+ 4CF3              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044B0H
 139+ 4CF3              PLY_AKG_CHANNEL3_READCELLEND EQU 044B3H
 140+ 4CF3              PLY_AKG_CURRENTSPEED EQU 044B3H
 141+ 4CF3              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B5H
 142+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B8H
 143+ 4CF3              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B8H
 144+ 4CF3              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044BBH
 145+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BEH
 146+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BEH
 147+ 4CF3              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044CAH
 148+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044D1H
 149+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D4H
 150+ 4CF3              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044DAH
 151+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DDH
 152+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DDH
 153+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044EBH
 154+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044F0H
 155+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044FBH
 156+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FEH
 157+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FEH
 158+ 4CF3              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 04501H
 159+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04504H
 160+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04504H
 161+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450DH
 162+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04517H
 163+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 0451AH
 164+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 0451AH
 165+ 4CF3              PLY_AKG_CHANNEL1_PITCH EQU 0451AH
 166+ 4CF3              PLY_AKG_CHANNEL1_ISPITCH EQU 0451DH
 167+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 04522H
 168+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACK EQU 04522H
 169+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04526H
 170+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04528H
 171+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 0452AH
 172+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 04531H
 173+ 4CF3              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 04532H
 174+ 4CF3              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04535H
 175+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04535H
 176+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 04551H
 177+ 4CF3              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 04551H
 178+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455EH
 179+ 4CF3              PLY_AKG_CHANNEL1_GLIDEOVER EQU 04562H
 180+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 04572H
 181+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 04572H
 182+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04573H
 183+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04574H
 184+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04576H
 185+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04576H
 186+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04576H
 187+ 4CF3              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04577H
 188+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04578H
 189+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 0457AH
 190+ 4CF3              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 0457AH
 191+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 0457AH
 192+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 0457AH
 193+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 0457AH
 194+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457DH
 195+ 4CF3              PLY_AKG_CHANNEL1_PITCH_END EQU 0457FH
 196+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04587H
 197+ 4CF3              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04587H
 198+ 4CF3              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 0458AH
 199+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458DH
 200+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458DH
 201+ 4CF3              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04599H
 202+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 045A0H
 203+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A3H
 204+ 4CF3              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A9H
 205+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045ACH
 206+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045ACH
 207+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045BAH
 208+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BFH
 209+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045CAH
 210+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CDH
 211+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CDH
 212+ 4CF3              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045D0H
 213+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D3H
 214+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D3H
 215+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045DCH
 216+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E6H
 217+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E9H
 218+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E9H
 219+ 4CF3              PLY_AKG_CHANNEL2_PITCH EQU 045E9H
 220+ 4CF3              PLY_AKG_CHANNEL2_ISPITCH EQU 045ECH
 221+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045F1H
 222+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045F1H
 223+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F5H
 224+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F7H
 225+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F9H
 226+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 04600H
 227+ 4CF3              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 04601H
 228+ 4CF3              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04604H
 229+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04604H
 230+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 04620H
 231+ 4CF3              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 04620H
 232+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462DH
 233+ 4CF3              PLY_AKG_CHANNEL2_GLIDEOVER EQU 04631H
 234+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 04641H
 235+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 04641H
 236+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 04642H
 237+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04643H
 238+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04645H
 239+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04645H
 240+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04645H
 241+ 4CF3              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04646H
 242+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04647H
 243+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04649H
 244+ 4CF3              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04649H
 245+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04649H
 246+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04649H
 247+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04649H
 248+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_END EQU 0464CH
 249+ 4CF3              PLY_AKG_CHANNEL2_PITCH_END EQU 0464EH
 250+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04656H
 251+ 4CF3              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04656H
 252+ 4CF3              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04659H
 253+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 0465CH
 254+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 0465CH
 255+ 4CF3              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04668H
 256+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466FH
 257+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 04672H
 258+ 4CF3              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04678H
 259+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 0467BH
 260+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 0467BH
 261+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04689H
 262+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468EH
 263+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04699H
 264+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 0469CH
 265+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 0469CH
 266+ 4CF3              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469FH
 267+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 046A2H
 268+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE EQU 046A2H
 269+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046ABH
 270+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B5H
 271+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B8H
 272+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B8H
 273+ 4CF3              PLY_AKG_CHANNEL3_PITCH EQU 046B8H
 274+ 4CF3              PLY_AKG_CHANNEL3_ISPITCH EQU 046BBH
 275+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046C0H
 276+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046C0H
 277+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C4H
 278+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C6H
 279+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C8H
 280+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CFH
 281+ 4CF3              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046D0H
 282+ 4CF3              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D3H
 283+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D3H
 284+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046EFH
 285+ 4CF3              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046EFH
 286+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046FCH
 287+ 4CF3              PLY_AKG_CHANNEL3_GLIDEOVER EQU 04700H
 288+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 04710H
 289+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 04710H
 290+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 04711H
 291+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 04712H
 292+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04714H
 293+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04714H
 294+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04714H
 295+ 4CF3              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04715H
 296+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04716H
 297+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04718H
 298+ 4CF3              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04718H
 299+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04718H
 300+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04718H
 301+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04718H
 302+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_END EQU 0471BH
 303+ 4CF3              PLY_AKG_CHANNEL3_PITCH_END EQU 0471DH
 304+ 4CF3              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04729H
 305+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04729H
 306+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04729H
 307+ 4CF3              PLY_AKG_CHANNEL1_TRACKNOTE EQU 0472CH
 308+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472EH
 309+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04734H
 310+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04737H
 311+ 4CF3              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04737H
 312+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 0473AH
 313+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04743H
 314+ 4CF3              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 0474BH
 315+ 4CF3              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04758H
 316+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04758H
 317+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04758H
 318+ 4CF3              PLY_AKG_CHANNEL2_TRACKNOTE EQU 0475BH
 319+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475DH
 320+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04763H
 321+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04766H
 322+ 4CF3              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04766H
 323+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04769H
 324+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 04772H
 325+ 4CF3              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 0477AH
 326+ 4CF3              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04788H
 327+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04788H
 328+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04788H
 329+ 4CF3              PLY_AKG_CHANNEL3_TRACKNOTE EQU 0478BH
 330+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478DH
 331+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04793H
 332+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04796H
 333+ 4CF3              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04796H
 334+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04799H
 335+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 047A2H
 336+ 4CF3              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047AAH
 337+ 4CF3              PLY_AKG_SENDPSGREGISTERS EQU 047B9H
 338+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047C1H
 339+ 4CF3              PLY_AKG_PSGREG01_INSTR EQU 047C1H
 340+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047D1H
 341+ 4CF3              PLY_AKG_PSGREG23_INSTR EQU 047D1H
 342+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047E2H
 343+ 4CF3              PLY_AKG_PSGREG45_INSTR EQU 047E2H
 344+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F3H
 345+ 4CF3              PLY_AKG_PSGREG6_8_INSTR EQU 047F3H
 346+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04804H
 347+ 4CF3              PLY_AKG_PSGREG9_10_INSTR EQU 04804H
 348+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04815H
 349+ 4CF3              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04815H
 350+ 4CF3              PLY_AKG_PSGREG13_OLDVALUE EQU 0482AH
 351+ 4CF3              PLY_AKG_RETRIG EQU 0482CH
 352+ 4CF3              PLY_AKG_PSGREG13_INSTR EQU 0482EH
 353+ 4CF3              PLY_AKG_PSGREG13_END EQU 0483DH
 354+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483DH
 355+ 4CF3              PLY_AKG_SAVESP EQU 0483DH
 356+ 4CF3              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 04841H
 357+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTS EQU 04849H
 358+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04856H
 359+ 4CF3              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04856H
 360+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485EH
 361+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 0486BH
 362+ 4CF3              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 0486BH
 363+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTS EQU 04873H
 364+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487EH
 365+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS EQU 0487EH
 366+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488DH
 367+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488DH
 368+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04894H
 369+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A4H
 370+ 4CF3              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A4H
 371+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048ABH
 372+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048ABH
 373+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048AEH
 374+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B7H
 375+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B7H
 376+ 4CF3              PLY_AKG_READINSTRUMENTCELL EQU 048BDH
 377+ 4CF3              PLY_AKG_NOSOFTNOHARD EQU 048CAH
 378+ 4CF3              PLY_AKG_NSNH_NONOISE EQU 048DFH
 379+ 4CF3              PLY_AKG_SOFT EQU 048E2H
 380+ 4CF3              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E9H
 381+ 4CF3              PLY_AKG_S_NOTSIMPLE EQU 048F1H
 382+ 4CF3              PLY_AKG_S_AFTERSIMPLETEST EQU 048F4H
 383+ 4CF3              PLY_AKG_HARDTOSOFT EQU 04901H
 384+ 4CF3              PLY_AKG_HS_JUMPRATIO EQU 0490CH
 385+ 4CF3              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04939H
 386+ 4CF3              PLY_AKG_ENDWITHOUTLOOP EQU 0493BH
 387+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 0493BH
 388+ 4CF3              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 0493BH
 389+ 4CF3              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04943H
 390+ 4CF3              PLY_AKG_SH_JUMPRATIO EQU 04950H
 391+ 4CF3              PLY_AKG_SH_JUMPRATIOEND EQU 04971H
 392+ 4CF3              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 04980H
 393+ 4CF3              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04986H
 394+ 4CF3              PLY_AKG_H_OR_ENDWITHLOOP EQU 049A0H
 395+ 4CF3              PLY_AKG_H_RETRIGEND EQU 049B2H
 396+ 4CF3              PLY_AKG_H_AFTERRETRIG EQU 049B3H
 397+ 4CF3              PLY_AKG_ENDWITHLOOP EQU 049C5H
 398+ 4CF3              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049CCH
 399+ 4CF3              PLY_AKG_S_OR_H_NEXTBYTE EQU 049E2H
 400+ 4CF3              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049F0H
 401+ 4CF3              PLY_AKG_S_OR_H_AFTERPITCH EQU 04A00H
 402+ 4CF3              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0EH
 403+ 4CF3              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1DH
 404+ 4CF3              PLY_AKG_SHOHS_RETRIGEND EQU 04A2CH
 405+ 4CF3              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2DH
 406+ 4CF3              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3FH
 407+ 4CF3              PLY_AKG_EFFECTTABLE EQU 04A4DH
 408+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4DH
 409+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A71H
 410+ 4CF3              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A71H
 411+ 4CF3              PLY_AKG_EFFECT_RESET EQU 04A74H
 412+ 4CF3              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A76H
 413+ 4CF3              PLY_AKG_EFFECT_VOLUME EQU 04A91H
 414+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9DH
 415+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA3H
 416+ 4CF3              PLY_AKG_ARPEGGIOSTABLE EQU 04AA3H
 417+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04ACAH
 418+ 4CF3              PLY_AKG_EFFECT_PITCHTABLE EQU 04AD1H
 419+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD7H
 420+ 4CF3              PLY_AKG_PITCHESTABLE EQU 04AD7H
 421+ 4CF3              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFEH
 422+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B05H
 423+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B16H
 424+ 4CF3              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1DH
 425+ 4CF3              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2DH
 426+ 4CF3              PLY_AKG_EFFECT_PITCHUP EQU 04B42H
 427+ 4CF3              PLY_AKG_EFFECT_PITCHSTOP EQU 04B54H
 428+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B5BH
 429+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B85H
 430+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B85H
 431+ 4CF3              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9EH
 432+ 4CF3              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9EH
 433+ 4CF3              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BB0H
 434+ 4CF3              PLY_AKG_EFFECT_LEGATO EQU 04BC6H
 435+ 4CF3              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BDAH
 436+ 4CF3              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BE2H
 437+ 4CF3              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BEAH
 438+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BF2H
 439+ 4CF3              PLY_AKG_EVENT EQU 04BF2H
 440+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF3H
 441+ 4CF3              PLY_AKG_PERIODTABLE EQU 04BF3H
 442+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF3H
 443+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF3H
 444+ 4CF3              PLY_AKG_PERIODTABLE_END EQU 04CF3H
 445+ 4CF3              PLY_AKG_END EQU 04CF3H
 446+ 4CF3              MAIN_PLAYER_END EQU 04CF3H
 447+ 4CF3              TESTEREND EQU 04CF3H
 448+ 4CF3
# file closed: ./symbol/AKG.sym
 122  4CF3               ENDIF
 123  4CF3
 124  4CF3               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
   1+ 4CF3              ORIG.HTIMI:
   2+ 4CF3 00 00 00 00  	DB 0, 0, 0, 0, 0
   2+ 4CF7 00
   3+ 4CF8               EXPORT ORIG.HTIMI
   4+ 4CF8
   5+ 4CF8              ; *******************************************************************************************************
   6+ 4CF8              ; interrupt handler when page 0 enabled
   7+ 4CF8              ; we are here only if one of the extended basic commands have paged in page 0
   8+ 4CF8              ; which means we arrived from BASIC so page 2 is already good
   9+ 4CF8              VBLANK:
  10+ 4CF8              	EXPORT VBLANK
  11+ 4CF8
  12+ 4CF8 F5               PUSH AF
  13+ 4CF9              	; is VDP originator ?
  14+ 4CF9 DB 99        	IN	A, (099H)
  15+ 4CFB A7           	AND	A
  16+ 4CFC F2 23 4D     	JP P, .EXIT
  17+ 4CFF
  18+ 4CFF               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  19+ 4CFF C5               PUSH BC
  20+ 4D00 D5               PUSH DE
  21+ 4D01 E5               PUSH HL
  22+ 4D02 08               EX AF, AF'
  23+ 4D03 D9               EXX
  24+ 4D04 F5               PUSH AF
  25+ 4D05 C5               PUSH BC
  26+ 4D06 D5               PUSH DE
  27+ 4D07 E5               PUSH HL
  28+ 4D08 DD E5            PUSH IX
  29+ 4D0A FD E5            PUSH IY
  30+ 4D0C
  31+ 4D0C               IF (SPRITE_CMDS == 1)
  32+ 4D0C CD 5D 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  33+ 4D0F               ENDIF
  34+ 4D0F
  35+ 4D0F               IF (SOUND_CMDS == 1)
  36+ 4D0F 3A CA 58     	LD A, (SOUND_ENABLED)
  37+ 4D12 B7           	OR A
  38+ 4D13 C4 36 42     	CALL NZ,PLY_AKG_PLAY
  39+ 4D16               ENDIF
  40+ 4D16
  41+ 4D16                  ; increase JIFFY
  42+ 4D16                  ;LD HL,(JIFFY)
  43+ 4D16                  ;INC HL
  44+ 4D16                  ;LD (JIFFY),HL
  45+ 4D16
  46+ 4D16 FD E1            POP IY
  47+ 4D18 DD E1            POP IX
  48+ 4D1A E1               POP HL
  49+ 4D1B D1               POP DE
  50+ 4D1C C1               POP BC
  51+ 4D1D F1               POP AF
  52+ 4D1E 08               EX AF, AF'
  53+ 4D1F D9               EXX
  54+ 4D20 E1               POP HL
  55+ 4D21 D1               POP DE
  56+ 4D22 C1               POP BC
  57+ 4D23               ENDIF
  58+ 4D23
  59+ 4D23              .EXIT:
  60+ 4D23 F1           	POP AF
  61+ 4D24 FB           	EI
  62+ 4D25 ED 4D        	RETI
  63+ 4D27              ; *******************************************************************************************************
  64+ 4D27
  65+ 4D27              ; *******************************************************************************************************
  66+ 4D27              ; H.TIMI function
  67+ 4D27              ; we can end up here from anywhere so page in both page 0 and 2
  68+ 4D27              MBGE_HTIMI:
  69+ 4D27               EXPORT MBGE_HTIMI
  70+ 4D27
  71+ 4D27               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  72+ 4D27
  73+ 4D27 F5           	PUSH AF
  74+ 4D28
  75+ 4D28              	; enable page 2
  76+ 4D28 3E 02            LD A, 2
  77+ 4D2A CD 36 64         CALL GET_PAGE_INFO
  78+ 4D2D C5               PUSH BC
  79+ 4D2E D5               PUSH DE
  80+ 4D2F 3A 43 F3         LD A, (RAMAD2)
  81+ 4D32 26 80            LD H, 080H
  82+ 4D34 CD 7D 64         CALL LOCAL_ENASLT
  83+ 4D37              	; enable page 0
  84+ 4D37 AF               XOR A
  85+ 4D38 CD 36 64         CALL GET_PAGE_INFO
  86+ 4D3B C5               PUSH BC
  87+ 4D3C D5               PUSH DE
  88+ 4D3D 3A 41 F3         LD A, (RAMAD0)
  89+ 4D40 26 00            LD H, 0
  90+ 4D42 CD 7D 64         CALL LOCAL_ENASLT
  91+ 4D45
  92+ 4D45               IF (SPRITE_CMDS == 1)
  93+ 4D45 CD 5D 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  94+ 4D48               ENDIF
  95+ 4D48
  96+ 4D48               IF (SOUND_CMDS == 1)
  97+ 4D48 3A CA 58     	LD A, (SOUND_ENABLED)
  98+ 4D4B B7           	OR A
  99+ 4D4C C4 36 42     	CALL NZ,PLY_AKG_PLAY
 100+ 4D4F               ENDIF
 101+ 4D4F
 102+ 4D4F              	; restore page 0
 103+ 4D4F D1               POP DE
 104+ 4D50 C1               POP BC
 105+ 4D51 CD 6D 64         CALL RESTORE_PAGE_INFO
 106+ 4D54              	; restore page 2
 107+ 4D54 D1               POP DE
 108+ 4D55 C1               POP BC
 109+ 4D56 CD 6D 64         CALL RESTORE_PAGE_INFO
 110+ 4D59
 111+ 4D59 F1           	POP AF
 112+ 4D5A               ENDIF
 113+ 4D5A C3 F3 4C     	JP ORIG.HTIMI
 114+ 4D5D              ; *******************************************************************************************************
 115+ 4D5D
 116+ 4D5D              ; *******************************************************************************************************
 117+ 4D5D              ; function checks if the sprite system is initialized and what screen mode we are running
 118+ 4D5D              ; also checks if some VRAM modifying command is running
 119+ 4D5D              ; when that checks out calls sprite updates and animation processing
 120+ 4D5D              ; if in an unsupported mode disables sprite handling
 121+ 4D5D              PROCESS_SPRITES_AND_ANIMATIONS:
 122+ 4D5D              	; check if initialized
 123+ 4D5D 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
 124+ 4D60 B7           	OR A
 125+ 4D61 C8           	RET Z
 126+ 4D62              	; check screen mode
 127+ 4D62 3A AF FC     	LD A, (SCRMOD)
 128+ 4D65 3D           	DEC A
 129+ 4D66 28 08        	JR Z, .L0 ; screen 1
 130+ 4D68 3D           	DEC A
 131+ 4D69 28 05            JR Z, .L0 ; screen 2
 132+ 4D6B              	; unsupported screen mode, disable
 133+ 4D6B AF               XOR A
 134+ 4D6C 32 7F 4D         LD (SPRATR_INIT_STATUS),A
 135+ 4D6F C9               RET
 136+ 4D70              .L0:
 137+ 4D70                  ; check if anyone else is working with VRAM
 138+ 4D70 3A 46 62         LD A,(VRAM_UPDATE_IN_PROGRESS)
 139+ 4D73 B7               OR A
 140+ 4D74 C0               RET NZ
 141+ 4D75
 142+ 4D75 CD 95 4D         CALL SPRATR_UPDATE
 143+ 4D78
 144+ 4D78               IF (ANIM_CMDS == 1)
 145+ 4D78 CD 76 55         CALL PROCESS_ANIMATIONS
 146+ 4D7B CD 41 57         CALL PROCESS_AUTOSGAMS
 147+ 4D7E               ENDIF
 148+ 4D7E C9               RET
 149+ 4D7F              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
 125  4D7F
 126  4D7F               IF (SPRITE_CMDS == 1)
 127  4D7F               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4D7F              ; commands and variables related to sprites
   2+ 4D7F
   3+ 4D7F              SPRATR_INIT_STATUS:
   4+ 4D7F 00            DB 0
   5+ 4D80              SPRATR_UPDATE_FLAG:
   6+ 4D80 00 00         DW 0
   7+ 4D82              SPRATR_DATA:
   8+ 4D82 00 00         DW 0
   9+ 4D84              SPRFLICKER_ENABLED:
  10+ 4D84 00            DB 0
  11+ 4D85              ; to support sprite flicker
  12+ 4D85              FLICKER:
  13+ 4D85 00            DB 0
  14+ 4D86              NUM_SPRITES_HANDLED:
  15+ 4D86 20            DB 32
  16+ 4D87
  17+ 4D87              ; to temporarily store stack pointer
  18+ 4D87              TMPSP:
  19+ 4D87 00 00         DW 0
  20+ 4D89
  21+ 4D89              ; *******************************************************************************************************
  22+ 4D89              ; helper function gets pointer to n-th entry in sprite attributes
  23+ 4D89              ; changes HL,DE
  24+ 4D89              GETnthSPRATTR:
  25+ 4D89 26 00            LD H,0
  26+ 4D8B 6F               LD L,A
  27+ 4D8C CD 32 64         CALL HLx8
  28+ 4D8F ED 5B 82 4D      LD DE,(SPRATR_DATA)
  29+ 4D93 19               ADD HL,DE
  30+ 4D94 C9               RET
  31+ 4D95              ; *******************************************************************************************************
  32+ 4D95
  33+ 4D95              ; *******************************************************************************************************
  34+ 4D95              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  35+ 4D95              ; struct {
  36+ 4D95              ; DW y
  37+ 4D95              ; DW x
  38+ 4D95              ; DW pattern (0-63)
  39+ 4D95              ; DW color
  40+ 4D95              ; } [32]
  41+ 4D95              ; will hide sprites whose location is outside of visible area
  42+ 4D95              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  43+ 4D95              ; modifies AF, AF', BC, DE, HL, IX
  44+ 4D95              SPRATR_UPDATE:
  45+ 4D95              	; check if update requested
  46+ 4D95 2A 80 4D     	LD HL, (SPRATR_UPDATE_FLAG)
  47+ 4D98 7E           	LD A, (HL)
  48+ 4D99 B7           	OR A
  49+ 4D9A C8           	RET Z
  50+ 4D9B
  51+ 4D9B DD 21 86 4D  	LD IX,NUM_SPRITES_HANDLED
  52+ 4D9F DD 46 00     	LD B, (IX) ; sprite number
  53+ 4DA2 0E 98        	LD C, #98 ; register for vdp data output
  54+ 4DA4              	; set VDP address
  55+ 4DA4 3A AF FC         LD A,(SCRMOD)
  56+ 4DA7 3D               DEC A
  57+ 4DA8 20 05            JR NZ,.L4
  58+ 4DAA 2A C3 F3         LD HL, (T32ATR)
  59+ 4DAD 18 03            JR .L5
  60+ 4DAF              .L4:
  61+ 4DAF 2A CD F3         LD HL, (GRPATR)
  62+ 4DB2              .L5:
  63+ 4DB2 3A 84 4D     	LD A, (SPRFLICKER_ENABLED)
  64+ 4DB5 B7           	OR A
  65+ 4DB6 28 03        	JR Z, .L3
  66+ 4DB8 3A 85 4D     	LD A, (FLICKER)
  67+ 4DBB              .L3:
  68+ 4DBB 5F           	LD E, A
  69+ 4DBC 08           	EX AF, AF'
  70+ 4DBD 7B           	LD A, E
  71+ 4DBE 87           	ADD A, A
  72+ 4DBF 87           	ADD A, A
  73+ 4DC0 16 00        	LD D, 0
  74+ 4DC2 5F           	LD E, A
  75+ 4DC3 19           	ADD HL, DE
  76+ 4DC4 CD 1D 64     	CALL SETWRT_LOCAL
  77+ 4DC7 ED 73 87 4D  	LD (TMPSP), SP
  78+ 4DCB ED 7B 82 4D  	LD SP, (SPRATR_DATA)
  79+ 4DCF
  80+ 4DCF              .LOOP:
  81+ 4DCF E1           	POP HL
  82+ 4DD0 24           	INC H
  83+ 4DD1 28 0D        	JR Z, .L1 ; negative number between -256 and -1
  84+ 4DD3 25           	DEC H
  85+ 4DD4 20 15        	JR NZ, .OUT3 ; sprite vertically can't be visible
  86+ 4DD6 7D           	LD A, L
  87+ 4DD7 FE C0        	CP 192
  88+ 4DD9 30 10        	JR NC, .OUT3
  89+ 4DDB 3D           	DEC A ; due to VDP rule that top of screen is -1
  90+ 4DDC 57           	LD D, A
  91+ 4DDD C3 04 4E     	JP .X
  92+ 4DE0              .L1:
  93+ 4DE0 7D           	LD A, L
  94+ 4DE1 C6 10        	ADD 16
  95+ 4DE3 FA EB 4D     	JP M, .OUT3 ; below -16
  96+ 4DE6 2D           	DEC L ; due to VDP rule that top of screen is -1
  97+ 4DE7 55           	LD D, L
  98+ 4DE8 C3 04 4E     	JP .X
  99+ 4DEB              .OUT3:
 100+ 4DEB E1           	POP HL ; skip x value
 101+ 4DEC              .OUT2:
 102+ 4DEC E1           	POP HL ; skip pattern
 103+ 4DED E1           	POP HL ; skip color
 104+ 4DEE 3E D1        	LD A, #D1
 105+ 4DF0 ED 79        	OUT (C), A ; sprite hidden
 106+ 4DF2 00          > NOP
 106+ 4DF3 00          > NOP
 106+ 4DF4 00          > NOP
 107+ 4DF5 ED 79        	OUT (C), A ; value unimportant
 108+ 4DF7 00          > NOP
 108+ 4DF8 00          > NOP
 108+ 4DF9 00          > NOP
 109+ 4DFA ED 79        	OUT (C), A ; value unimportant
 110+ 4DFC 00          > NOP
 110+ 4DFD 00          > NOP
 110+ 4DFE 00          > NOP
 111+ 4DFF ED 79        	OUT (C), A ; value unimportant
 112+ 4E01 C3 2F 4E     	JP .NEXT
 113+ 4E04              .X:
 114+ 4E04 E1           	POP HL
 115+ 4E05 24           	INC H
 116+ 4E06 28 08        	JR Z, .L2
 117+ 4E08 25           	DEC H
 118+ 4E09 20 E1        	JR NZ, .OUT2
 119+ 4E0B 1E 00        	LD E, 0 ; EC bit
 120+ 4E0D C3 19 4E     	JP .XY
 121+ 4E10              .L2:
 122+ 4E10 7D           	LD A, L
 123+ 4E11 C6 20        	ADD 32
 124+ 4E13 FA EC 4D     	JP M, .OUT2
 125+ 4E16 6F           	LD L, A
 126+ 4E17 1E 80        	LD E, #80
 127+ 4E19              .XY:
 128+ 4E19 ED 51        	OUT (C), D
 129+ 4E1B 3A E0 F3     	LD A, (REG1SAV)
 130+ 4E1E E6 02        	AND 2
 131+ 4E20 ED 69        	OUT (C), L
 132+ 4E22 E1           	POP HL ; pattern
 133+ 4E23 7D           	LD A, L
 134+ 4E24 28 02        	JR Z, .SMALLSPRITES
 135+ 4E26 87           	ADD A, A
 136+ 4E27 87           	ADD A, A ; needs to go at 4x
 137+ 4E28              .SMALLSPRITES:
 138+ 4E28 D3 98        	OUT (#98), A
 139+ 4E2A E1           	POP HL ; color
 140+ 4E2B 7D           	LD A, L
 141+ 4E2C B3           	OR E
 142+ 4E2D D3 98        	OUT (#98), A
 143+ 4E2F              .NEXT:
 144+ 4E2F 08           	EX AF, AF'
 145+ 4E30 3C           	INC A ; increase current sprite
 146+ 4E31 DD BE 00     	CP (IX) ; compare to maximum handled
 147+ 4E34 C2 54 4E     	JP NZ, .NEXT2 ; continue if not over
 148+ 4E37 AF           	XOR A ; back to zero
 149+ 4E38 08           	EX AF, AF'
 150+ 4E39 3A AF FC         LD A,(SCRMOD)
 151+ 4E3C 3D               DEC A
 152+ 4E3D 20 05            JR NZ,.L6
 153+ 4E3F 2A C3 F3         LD HL, (T32ATR)
 154+ 4E42 18 03            JR .L7
 155+ 4E44              .L6:
 156+ 4E44 2A CD F3         LD HL, (GRPATR)
 157+ 4E47              .L7:
 158+ 4E47              	; CALL SETWRT_LOCAL not allowed as SP modified
 159+ 4E47 7D           	LD	A, L
 160+ 4E48 D3 99        	OUT	(099H), A
 161+ 4E4A 7C           	LD	A, H
 162+ 4E4B E6 3F        	AND	03FH
 163+ 4E4D F6 40        	OR	040H
 164+ 4E4F D3 99        	OUT	(099H), A
 165+ 4E51 C3 55 4E     	JP .NEXT3
 166+ 4E54              .NEXT2:
 167+ 4E54 08           	EX AF, AF'
 168+ 4E55              .NEXT3:
 169+ 4E55 05           	DEC B
 170+ 4E56 C2 CF 4D     	JP NZ, .LOOP
 171+ 4E59 08           	EX AF, AF'
 172+ 4E5A 3C           	INC A ; increase flicker to start at the next one on next vblank
 173+ 4E5B DD BE 00     	CP (IX)
 174+ 4E5E 20 01        	JR NZ,.L8
 175+ 4E60 AF           	XOR A
 176+ 4E61              .L8:
 177+ 4E61 32 85 4D     	LD (FLICKER), A
 178+ 4E64
 179+ 4E64 ED 7B 87 4D  	LD SP, (TMPSP)
 180+ 4E68 2A 80 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 181+ 4E6B 36 00        	LD (HL), 0 ; zero out update flag
 182+ 4E6D C9           	RET
 183+ 4E6E              ; *******************************************************************************************************
 184+ 4E6E
 185+ 4E6E               IF (1 == 1)
 186+ 4E6E              ; *******************************************************************************************************
 187+ 4E6E              ; function to handle CALL SPRENABLE basic extension
 188+ 4E6E              ; initializes sprites handler
 189+ 4E6E              ; _SPRENABLE ( INT[3][31] variable sprites_attributes,
 190+ 4E6E              ;			   INT variable update_variable,
 191+ 4E6E              ;			   BYTE sprite_flicker_enabled,
 192+ 4E6E              ;			   BYTE num_sprites_handled )
 193+ 4E6E              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA, SPRFLICKER_ENABLED and NUM_SPRITES_HANDLED
 194+ 4E6E              SPRENABLE:
 195+ 4E6E              	; opening (
 196+ 4E6E CD 45 65     	CALL CHKCHAR
 197+ 4E71 28           	DB '('
 198+ 4E72              	; get address of sprite attribute table DIM SA%(3,31)
 199+ 4E72 3E 02        	LD A,2
 200+ 4E74 06 02        	LD B,2
 201+ 4E76 11 20 04     	LD DE,#0420
 202+ 4E79 CD 72 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
 203+ 4E7C ED 43 82 4D  	LD (SPRATR_DATA), BC
 204+ 4E80              	; comma
 205+ 4E80 CD 45 65     	CALL CHKCHAR
 206+ 4E83 2C           	DB ','
 207+ 4E84              	; get address of sprite update flag
 208+ 4E84 DD 21 A4 5E  	LD IX, PTRGET
 209+ 4E88 CD 59 01     	CALL CALBAS
 210+ 4E8B ED 53 80 4D  	LD (SPRATR_UPDATE_FLAG), DE
 211+ 4E8F              	; comma
 212+ 4E8F CD 45 65     	CALL CHKCHAR
 213+ 4E92 2C           	DB ','
 214+ 4E93              	; get flicker enabled flag
 215+ 4E93 DD 21 1C 52  	LD IX, GETBYT
 216+ 4E97 CD 59 01     	CALL CALBAS
 217+ 4E9A 32 84 4D     	LD (SPRFLICKER_ENABLED), A
 218+ 4E9D              	; comma
 219+ 4E9D CD 45 65     	CALL CHKCHAR
 220+ 4EA0 2C           	DB ','
 221+ 4EA1              	; get number of handled sprites
 222+ 4EA1 DD 21 1C 52  	LD IX, GETBYT
 223+ 4EA5 CD 59 01     	CALL CALBAS
 224+ 4EA8 32 86 4D     	LD (NUM_SPRITES_HANDLED),A
 225+ 4EAB              	; ending )
 226+ 4EAB CD 45 65     	CALL CHKCHAR
 227+ 4EAE 29           	DB ')'
 228+ 4EAF              .L0:
 229+ 4EAF 3E 01        	LD A, 1
 230+ 4EB1 32 7F 4D     	LD (SPRATR_INIT_STATUS), A
 231+ 4EB4 C9           	RET
 232+ 4EB5              ; *******************************************************************************************************
 233+ 4EB5               ENDIF
 234+ 4EB5
 235+ 4EB5               IF (0 == 1)
 236+ 4EB5 ~            ; same as SPRENABLE but for DEFUSR approach
 237+ 4EB5 ~            ; input IX=pointer to input array, real data from +2
 238+ 4EB5 ~            ; +2 = pointer to sprite attributes array data
 239+ 4EB5 ~            ; +4 = pointer to sprite update variable
 240+ 4EB5 ~            ; +6 = flicker flag
 241+ 4EB5 ~            ; +8 = number of sprites to handle
 242+ 4EB5 ~            SPRENABLE_DEFUSR:
 243+ 4EB5 ~            	LD L,(IX+2)
 244+ 4EB5 ~            	LD H,(IX+3)
 245+ 4EB5 ~            	LD (SPRATR_DATA),HL
 246+ 4EB5 ~            	LD L,(IX+4)
 247+ 4EB5 ~            	LD H,(IX+5)
 248+ 4EB5 ~            	LD (SPRATR_UPDATE_FLAG),HL
 249+ 4EB5 ~            	LD A,(IX+6)
 250+ 4EB5 ~            	LD (SPRFLICKER_ENABLED),A
 251+ 4EB5 ~            	LD A,(IX+8)
 252+ 4EB5 ~            	LD (NUM_SPRITES_HANDLED),A
 253+ 4EB5 ~             IF (BASIC_EXTENSION == 1)
 254+ 4EB5 ~            	JR SPRENABLE.L0
 255+ 4EB5 ~             ELSE
 256+ 4EB5 ~            	LD A, 1
 257+ 4EB5 ~            	LD (SPRATR_INIT_STATUS), A
 258+ 4EB5 ~            	RET
 259+ 4EB5 ~             ENDIF
 260+ 4EB5               ENDIF
 261+ 4EB5
 262+ 4EB5               IF (0 + 1 > 0)
 263+ 4EB5              ; *******************************************************************************************************
 264+ 4EB5              ; function to handle CALL SPRDISABLE basic extension
 265+ 4EB5              ; disables sprites handling
 266+ 4EB5              ; _SPRDISABLE
 267+ 4EB5              ; resets variable SPRATR_INIT_STATUS
 268+ 4EB5              SPRDISABLE:
 269+ 4EB5              SPRDISABLE_DEFUSR:
 270+ 4EB5 AF           	XOR A
 271+ 4EB6 32 7F 4D     	LD (SPRATR_INIT_STATUS), A
 272+ 4EB9 C9           	RET
 273+ 4EBA              ; *******************************************************************************************************
 274+ 4EBA               ENDIF
 275+ 4EBA
 276+ 4EBA              ; *******************************************************************************************************
 277+ 4EBA              ; function to handle CALL SPRSET basic extension
 278+ 4EBA              ; sets position, and optionally pattern and color of sprite
 279+ 4EBA              ; _SPRSET ( BYTE sprite_num , valid 0-31
 280+ 4EBA              ;			INT x,
 281+ 4EBA              ;			INT y,
 282+ 4EBA              ;			INT pattern, valid 0-63, otherwise ignored
 283+ 4EBA              ;			INT color, valid 0-15, otherwise ignored
 284+ 4EBA              ;SPRSET:
 285+ 4EBA              ;	LD A, (SPRATR_INIT_STATUS)
 286+ 4EBA              ;	OR A
 287+ 4EBA              ;	JR NZ, .L1
 288+ 4EBA              ;	LD E, 5 ; illegal function call
 289+ 4EBA              ;	JP THROW_ERROR
 290+ 4EBA              ;.L1:
 291+ 4EBA              ;	; opening (
 292+ 4EBA              ;	CALL CHKCHAR
 293+ 4EBA              ;	DB '('
 294+ 4EBA              ;	; get sprite number
 295+ 4EBA              ;	LD IX, GETBYT
 296+ 4EBA              ;	CALL CALBAS
 297+ 4EBA              ;	PUSH AF
 298+ 4EBA              ;	; comma
 299+ 4EBA              ;	CALL CHKCHAR
 300+ 4EBA              ;	DB ','
 301+ 4EBA              ;	; get x
 302+ 4EBA              ;	LD IX, FRMQNT
 303+ 4EBA              ;	CALL CALBAS
 304+ 4EBA              ;	PUSH DE
 305+ 4EBA              ;	; comma
 306+ 4EBA              ;	CALL CHKCHAR
 307+ 4EBA              ;	DB ','
 308+ 4EBA              ;	; get y
 309+ 4EBA              ;	LD IX, FRMQNT
 310+ 4EBA              ;	CALL CALBAS
 311+ 4EBA              ;	PUSH DE
 312+ 4EBA              ;	; comma
 313+ 4EBA              ;	CALL CHKCHAR
 314+ 4EBA              ;	DB ','
 315+ 4EBA              ;	; get pattern
 316+ 4EBA              ;	LD IX, FRMQNT
 317+ 4EBA              ;	CALL CALBAS
 318+ 4EBA              ;	PUSH DE
 319+ 4EBA              ;	; comma
 320+ 4EBA              ;	CALL CHKCHAR
 321+ 4EBA              ;	DB ','
 322+ 4EBA              ;	; get color
 323+ 4EBA              ;	LD IX, FRMQNT
 324+ 4EBA              ;	CALL CALBAS
 325+ 4EBA              ;	PUSH DE
 326+ 4EBA              ;	; ending )
 327+ 4EBA              ;	CALL CHKCHAR
 328+ 4EBA              ;	DB ')'
 329+ 4EBA              ;
 330+ 4EBA              ;   ; save position in BASIC text
 331+ 4EBA              ;	PUSH HL
 332+ 4EBA              ;	POP IX
 333+ 4EBA              ;
 334+ 4EBA              ;	POP BC ; color
 335+ 4EBA              ;	POP DE ; pattern
 336+ 4EBA              ;	EXX
 337+ 4EBA              ;	POP BC ; y
 338+ 4EBA              ;	POP DE ; x
 339+ 4EBA              ;	POP AF ; sprite number
 340+ 4EBA              ;	CP 32
 341+ 4EBA              ;	JR C, .L2
 342+ 4EBA              ;	LD E, 5 ; illegal function call
 343+ 4EBA              ;	JP THROW_ERROR
 344+ 4EBA              ;.L2:
 345+ 4EBA              ;	; find location in sprite attributes table
 346+ 4EBA              ;	PUSH DE
 347+ 4EBA              ;	CALL GETnthSPRATTR
 348+ 4EBA              ;	POP DE
 349+ 4EBA              ;	DI
 350+ 4EBA              ;	; set y
 351+ 4EBA              ;	LD (HL), C
 352+ 4EBA              ;	INC HL
 353+ 4EBA              ;	LD (HL), B
 354+ 4EBA              ;	INC HL
 355+ 4EBA              ;	; set x
 356+ 4EBA              ;	LD (HL), E
 357+ 4EBA              ;	INC HL
 358+ 4EBA              ;	LD (HL), D
 359+ 4EBA              ;	INC HL
 360+ 4EBA              ;	PUSH HL
 361+ 4EBA              ;	EXX
 362+ 4EBA              ;	POP HL
 363+ 4EBA              ;	; check if 0<=pattern<64
 364+ 4EBA              ;	LD A, D
 365+ 4EBA              ;	OR A
 366+ 4EBA              ;	JR NZ, .L3
 367+ 4EBA              ;	LD A, E
 368+ 4EBA              ;	CP 64
 369+ 4EBA              ;	JR NC, .L3
 370+ 4EBA              ;	; set pattern
 371+ 4EBA              ;	;ADD A, A
 372+ 4EBA              ;	;ADD A, A
 373+ 4EBA              ;	;ADD A, A
 374+ 4EBA              ;	LD (HL), A
 375+ 4EBA              ;	INC HL
 376+ 4EBA              ;	LD (HL), D
 377+ 4EBA              ;	INC HL
 378+ 4EBA              ;	JR .L4
 379+ 4EBA              ;.L3:
 380+ 4EBA              ;	; skip pattern
 381+ 4EBA              ;	.2 INC HL
 382+ 4EBA              ;.L4:
 383+ 4EBA              ;	; check if 0<=color<16
 384+ 4EBA              ;	LD A, B
 385+ 4EBA              ;	OR A
 386+ 4EBA              ;	JR NZ, .L5
 387+ 4EBA              ;	LD A, C
 388+ 4EBA              ;	CP 16
 389+ 4EBA              ;	JR NC, .L5
 390+ 4EBA              ;	; set color
 391+ 4EBA              ;	LD (HL), C
 392+ 4EBA              ;	INC HL
 393+ 4EBA              ;	LD (HL), B
 394+ 4EBA              ;
 395+ 4EBA              ;.L5:
 396+ 4EBA              ;	EI
 397+ 4EBA              ;	PUSH IX
 398+ 4EBA              ;	POP HL
 399+ 4EBA              ;	RET
 400+ 4EBA              ; *******************************************************************************************************
 401+ 4EBA
 402+ 4EBA              ; *******************************************************************************************************
 403+ 4EBA              ; function sets sprite location based on initial coordinates and offset provided
 404+ 4EBA              ; input A=sprite number in SPRATR_DATA , 0-31
 405+ 4EBA              ; input DE=initial x
 406+ 4EBA              ; input BC=initial y
 407+ 4EBA              ; input IY=location where delta y,x are located
 408+ 4EBA              ; modifies AF, HL, IX
 409+ 4EBA              SPRSET_DELTA_POS:
 410+ 4EBA D5           	PUSH DE
 411+ 4EBB CD 89 4D     	CALL GETnthSPRATTR
 412+ 4EBE E5           	PUSH HL
 413+ 4EBF DD E1        	POP IX
 414+ 4EC1 D1           	POP DE
 415+ 4EC2              	; IX=sprite's y location
 416+ 4EC2 FD 6E 00     	LD L, (IY)
 417+ 4EC5 FD 66 01     	LD H, (IY+1)
 418+ 4EC8 09           	ADD HL, BC
 419+ 4EC9 DD 75 00     	LD (IX), L
 420+ 4ECC DD 74 01     	LD (IX+1), H
 421+ 4ECF FD 6E 02     	LD L, (IY+2)
 422+ 4ED2 FD 66 03     	LD H, (IY+3)
 423+ 4ED5 19           	ADD HL, DE
 424+ 4ED6 DD 75 02     	LD (IX+2), L
 425+ 4ED9 DD 74 03     	LD (IX+3), H
 426+ 4EDC C9           	RET
 427+ 4EDD              ; *******************************************************************************************************
 428+ 4EDD
 429+ 4EDD              ; *******************************************************************************************************
 430+ 4EDD              ; helper function to set new locations for a set of sprites
 431+ 4EDD              ; input B=number of sprites
 432+ 4EDD              ; HL=pointer to list of sprites and offsets
 433+ 4EDD              SPR_UPDATE_LOC:
 434+ 4EDD 3E 01        	LD A,1
 435+ 4EDF 32 46 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 436+ 4EE2 7E           	LD A, (HL)
 437+ 4EE3 23           	INC HL
 438+ 4EE4 23           	INC HL
 439+ 4EE5 E5           	PUSH HL
 440+ 4EE6 FD E1        	POP IY
 441+ 4EE8 D9           	EXX
 442+ 4EE9 CD BA 4E     	CALL SPRSET_DELTA_POS
 443+ 4EEC D9           	EXX
 444+ 4EED 23          > INC HL
 444+ 4EEE 23          > INC HL
 444+ 4EEF 23          > INC HL
 444+ 4EF0 23          > INC HL
 445+ 4EF1 10 EA        	DJNZ SPR_UPDATE_LOC
 446+ 4EF3 AF           	XOR A
 447+ 4EF4 32 46 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 448+ 4EF7 C9           	RET
 449+ 4EF8              ; *******************************************************************************************************
 450+ 4EF8
 451+ 4EF8               IF (1 == 1)
 452+ 4EF8              ; *******************************************************************************************************
 453+ 4EF8              ; function to handle CALL SPRGRPMOV basic extension
 454+ 4EF8              ; sets position of a group of sprites described with
 455+ 4EF8              ; { int sprite_num, int delta_y, int delta_x } [count]
 456+ 4EF8              ; _SPRGRPMOV ( INT x,
 457+ 4EF8              ;			   INT y,
 458+ 4EF8              ;			   BYTE count,
 459+ 4EF8              ;			   INT[2][count] data_ptr
 460+ 4EF8              SPRGRPMOV:
 461+ 4EF8 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
 462+ 4EFB B7           	OR A
 463+ 4EFC CA 65 65     	JP Z,ILLEGAL_FUNCTION
 464+ 4EFF              	; opening (
 465+ 4EFF CD 45 65     	CALL CHKCHAR
 466+ 4F02 28           	DB '('
 467+ 4F03              	; get x
 468+ 4F03 DD 21 2F 54  	LD IX, FRMQNT
 469+ 4F07 CD 59 01     	CALL CALBAS
 470+ 4F0A ED 53 35 62  	LD (BLIT_STRUCT),DE
 471+ 4F0E              	; comma
 472+ 4F0E CD 45 65     	CALL CHKCHAR
 473+ 4F11 2C           	DB ','
 474+ 4F12              	; get y
 475+ 4F12 DD 21 2F 54  	LD IX, FRMQNT
 476+ 4F16 CD 59 01     	CALL CALBAS
 477+ 4F19 ED 53 37 62  	LD (BLIT_STRUCT+2),DE
 478+ 4F1D              	; comma
 479+ 4F1D CD 45 65     	CALL CHKCHAR
 480+ 4F20 2C           	DB ','
 481+ 4F21              	; get count
 482+ 4F21 DD 21 1C 52  	LD IX, GETBYT
 483+ 4F25 CD 59 01     	CALL CALBAS
 484+ 4F28 32 39 62     	LD (BLIT_STRUCT+4),A
 485+ 4F2B              	; comma
 486+ 4F2B CD 45 65     	CALL CHKCHAR
 487+ 4F2E 2C           	DB ','
 488+ 4F2F              	; get sprite group definition array data pointer
 489+ 4F2F 3A 39 62     	LD A,(BLIT_STRUCT+4)
 490+ 4F32 5F           	LD E,A
 491+ 4F33 16 03        	LD D,3
 492+ 4F35 3E 02        	LD A,2
 493+ 4F37 47           	LD B,A
 494+ 4F38 CD 72 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
 495+ 4F3B ED 43 3A 62  	LD (BLIT_STRUCT+5),BC
 496+ 4F3F              	; ending )
 497+ 4F3F CD 45 65     	CALL CHKCHAR
 498+ 4F42 29           	DB ')'
 499+ 4F43
 500+ 4F43 E5           	PUSH HL
 501+ 4F44
 502+ 4F44 D9               EXX
 503+ 4F45 ED 5B 35 62      LD DE,(BLIT_STRUCT) ; initial x
 504+ 4F49 ED 4B 37 62      LD BC,(BLIT_STRUCT+2) ; initial y
 505+ 4F4D D9               EXX
 506+ 4F4E 2A 3A 62         LD HL,(BLIT_STRUCT+5) ; pointer to data
 507+ 4F51 3A 39 62         LD A,(BLIT_STRUCT+4) ; number of entries
 508+ 4F54 47               LD B,A
 509+ 4F55 CD DD 4E     	CALL SPR_UPDATE_LOC
 510+ 4F58
 511+ 4F58 E1           	POP HL
 512+ 4F59 C9           	RET
 513+ 4F5A              ; *******************************************************************************************************
 514+ 4F5A               ENDIF
 515+ 4F5A
 516+ 4F5A               IF (0 == 1)
 517+ 4F5A ~            ; *******************************************************************************************************
 518+ 4F5A ~            ; same as SPRGRPMOV but for DEFUSR approach
 519+ 4F5A ~            ; input IX=pointer to input array, real data from +2
 520+ 4F5A ~            ; +2 = X
 521+ 4F5A ~            ; +4 = Y
 522+ 4F5A ~            ; +6 = count
 523+ 4F5A ~            ; +8 = data pointer
 524+ 4F5A ~            SPRGRPMOV_DEFUSR:
 525+ 4F5A ~                EXX
 526+ 4F5A ~            	LD E,(IX+2)
 527+ 4F5A ~            	LD D,(IX+3) ; initial x
 528+ 4F5A ~            	LD C,(IX+4)
 529+ 4F5A ~            	LD B,(IX+5) ; initial y
 530+ 4F5A ~                EXX
 531+ 4F5A ~            	LD L,(IX+8)
 532+ 4F5A ~            	LD H,(IX+9) ; pointer to data
 533+ 4F5A ~                LD B,(IX+6) ; count
 534+ 4F5A ~                JP SPR_UPDATE_LOC
 535+ 4F5A ~            ; *******************************************************************************************************
 536+ 4F5A               ENDIF
# file closed: asm\SPRITES.asm
 128  4F5A               ENDIF
 129  4F5A
 130  4F5A               IF (ANIM_CMDS == 1)
 131  4F5A               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4F5A              ; sprite animation routines
   2+ 4F5A
   3+ 4F5A              ; number of animation items and pointer
   4+ 4F5A              ANIMITEMNUM:
   5+ 4F5A 00            DB 0
   6+ 4F5B              ANIMITEMPTR:
   7+ 4F5B E8 65         DW EXT_END
   8+ 4F5D              ; number of animation definitions and pointer
   9+ 4F5D              ANIMDEFNUM:
  10+ 4F5D 00            DB 0
  11+ 4F5E              ANIMDEFPTR:
  12+ 4F5E E8 65         DW EXT_END
  13+ 4F60              ; number of links between sprite and animation definitions
  14+ 4F60              ANIMSPRNUM:
  15+ 4F60 00            DB 0
  16+ 4F61              ANIMSPRPTR:
  17+ 4F61 E8 65         DW EXT_END
  18+ 4F63              ; number of automatic sprite group move and animate structures
  19+ 4F63              AUTOSGAMNUM:
  20+ 4F63 00            DB 0
  21+ 4F64              AUTOSGAMPTR:
  22+ 4F64 E8 65         DW EXT_END
  23+ 4F66
  24+ 4F66              ; ANIMATION ITEM
  25+ 4F66              ; byte type = [0 - pattern and color change
  26+ 4F66              ;              1 - pattern definition change ]
  27+ 4F66              ; word ticks - number of ticks to hold this state
  28+ 4F66              ; for type = 0
  29+ 4F66              ;   byte pattern;
  30+ 4F66              ;   byte color;
  31+ 4F66              ; for type = 1
  32+ 4F66              ;   work data_pointer;
  33+ 4F66              ; total size = 5b
  34+ 4F66
  35+ 4F66              ; ANIMATION DEFINITION
  36+ 4F66              ; byte number of items 1-15
  37+ 4F66              ; byte[15] anim_item;
  38+ 4F66              ; total size = 16b
  39+ 4F66
  40+ 4F66              ; SPRITE/CHAR ANIMATION
  41+ 4F66              ; +00 byte sprite/char number;
  42+ 4F66              ; +01 word time;
  43+ 4F66              ; +03 byte current item;
  44+ 4F66              ; +04 byte animation definition;
  45+ 4F66              ; +05 byte cyclic;
  46+ 4F66              ; +06 byte active;
  47+ 4F66              ; +07 byte 0=sprite, 1-3 character bank
  48+ 4F66              ; total size = 8b
  49+ 4F66
  50+ 4F66              ; AUTOMATIC SPRITE GROUP MOVE AND ANIMATE structure
  51+ 4F66              ; +00 pointer to X variable
  52+ 4F66              ; +02 pointer to Y variable
  53+ 4F66              ; +04 minimum value
  54+ 4F66              ; +06 maximal value
  55+ 4F66              ; +08 delta value
  56+ 4F66              ; +10 direction 0=horizontal, <>0 = vertical
  57+ 4F66              ; +11 sprite group size
  58+ 4F66              ; +12 sprite group pointer
  59+ 4F66              ; +14 animation list size
  60+ 4F66              ; +15 animation list pointer for negative delta values
  61+ 4F66              ; +17 animation list pointer for positive delta values
  62+ 4F66              ; +19 active flag
  63+ 4F66              ; +20 ticks for movement
  64+ 4F66              ; +22 timer
  65+ 4F66              ; total = 24b
  66+ 4F66
  67+ 4F66              ; *******************************************************************************************************
  68+ 4F66              ; helper function HL=A*5
  69+ 4F66              ; changes HL,DE
  70+ 4F66              Ax5:
  71+ 4F66 26 00            LD H,0
  72+ 4F68 6F               LD L,A
  73+ 4F69 54               LD D,H
  74+ 4F6A 5D               LD E,L
  75+ 4F6B 29               ADD HL,HL
  76+ 4F6C 29               ADD HL,HL
  77+ 4F6D 19               ADD HL,DE
  78+ 4F6E C9               RET
  79+ 4F6F              ; *******************************************************************************************************
  80+ 4F6F
  81+ 4F6F              ; *******************************************************************************************************
  82+ 4F6F              ; helper function gets pointer to n-th animation item
  83+ 4F6F              ; changes HL,DE
  84+ 4F6F              GETnthANIMITEM:
  85+ 4F6F CD 66 4F         CALL Ax5
  86+ 4F72 ED 5B 5B 4F      LD DE,(ANIMITEMPTR)
  87+ 4F76 19               ADD HL,DE
  88+ 4F77 C9               RET
  89+ 4F78              ; *******************************************************************************************************
  90+ 4F78
  91+ 4F78              ; *******************************************************************************************************
  92+ 4F78              ; helper function gets pointer to n-th entry in animation definition
  93+ 4F78              ; changes HL,DE
  94+ 4F78              GETnthANIMDEF:
  95+ 4F78 26 00            LD H,0
  96+ 4F7A 6F               LD L,A
  97+ 4F7B CD 31 64         CALL HLx16
  98+ 4F7E ED 5B 5E 4F      LD DE,(ANIMDEFPTR)
  99+ 4F82 19               ADD HL,DE
 100+ 4F83 C9               RET
 101+ 4F84              ; *******************************************************************************************************
 102+ 4F84
 103+ 4F84              ; *******************************************************************************************************
 104+ 4F84              ; helper function gets pointer to n-th entry in sprite animation
 105+ 4F84              ; changes HL,DE
 106+ 4F84              GETnthSPRANIM:
 107+ 4F84 26 00            LD H,0
 108+ 4F86 6F               LD L,A
 109+ 4F87 CD 32 64         CALL HLx8
 110+ 4F8A ED 5B 61 4F      LD DE,(ANIMSPRPTR)
 111+ 4F8E 19               ADD HL,DE
 112+ 4F8F C9               RET
 113+ 4F90              ; *******************************************************************************************************
 114+ 4F90
 115+ 4F90              ; *******************************************************************************************************
 116+ 4F90              ; helper function gets pointer to n-th entry in autosgam table
 117+ 4F90              ; changes HL,DE
 118+ 4F90              GETnthAUTOSGAM:
 119+ 4F90 26 00            LD H,0
 120+ 4F92 6F               LD L,A
 121+ 4F93 CD 32 64         CALL HLx8
 122+ 4F96 54               LD D,H
 123+ 4F97 5D               LD E,L
 124+ 4F98 29               ADD HL,HL
 125+ 4F99 19               ADD HL,DE
 126+ 4F9A ED 5B 64 4F      LD DE,(AUTOSGAMPTR)
 127+ 4F9E 19               ADD HL,DE
 128+ 4F9F C9               RET
 129+ 4FA0              ; *******************************************************************************************************
 130+ 4FA0
 131+ 4FA0               IF (0 == 1)
 132+ 4FA0 ~            ; *******************************************************************************************************
 133+ 4FA0 ~            ; same as MAXIANIMITEMS but for DEFUSR approach
 134+ 4FA0 ~            ; input IX=pointer to input array, real data from +2
 135+ 4FA0 ~            ; +2 = number
 136+ 4FA0 ~            MAXANIMITEMS_DEFUSR:
 137+ 4FA0 ~                LD A,(IX+2)
 138+ 4FA0 ~                JR MAXANIMITEMS.COMMON
 139+ 4FA0 ~            ; *******************************************************************************************************
 140+ 4FA0               ENDIF
 141+ 4FA0
 142+ 4FA0              ; *******************************************************************************************************
 143+ 4FA0              ; function to handle CALL MAXANIMITEMS basic extension
 144+ 4FA0              ; MAXANIMITEMS (BYTE number)
 145+ 4FA0              ; sets new number and moves memory buffers as needed
 146+ 4FA0              MAXANIMITEMS:
 147+ 4FA0               IF (1 == 1)
 148+ 4FA0              	; opening (
 149+ 4FA0 CD 45 65     	CALL CHKCHAR
 150+ 4FA3 28           	DB '('
 151+ 4FA4              	; get value
 152+ 4FA4 DD 21 1C 52  	LD IX, GETBYT
 153+ 4FA8 CD 59 01     	CALL CALBAS
 154+ 4FAB F5               PUSH AF
 155+ 4FAC              	; ending )
 156+ 4FAC CD 45 65     	CALL CHKCHAR
 157+ 4FAF 29           	DB ')'
 158+ 4FB0 F1               POP AF
 159+ 4FB1               ENDIF
 160+ 4FB1              .COMMON: ; entry for DEFUSR part, A=number
 161+ 4FB1 F3               DI
 162+ 4FB2              	; save position
 163+ 4FB2 E5           	PUSH HL
 164+ 4FB3              .ENTRY:
 165+ 4FB3 47               LD B,A
 166+ 4FB4 3A 5A 4F         LD A,(ANIMITEMNUM)
 167+ 4FB7 90               SUB B
 168+ 4FB8 28 28            JR Z, .EXIT; same value as before
 169+ 4FBA FD 21 5E 4F      LD IY,ANIMDEFPTR
 170+ 4FBE FA E5 4F         JP M, .INCREASE
 171+ 4FC1                  ; new value is lower than previous one
 172+ 4FC1 CD 04 50         CALL .SIZEDIFF
 173+ 4FC4 CD 1F 50         CALL .DECREASE_COMMON
 174+ 4FC7 2A 61 4F         LD HL,(ANIMSPRPTR)
 175+ 4FCA AF               XOR A
 176+ 4FCB ED 42            SBC HL,BC
 177+ 4FCD 22 61 4F         LD (ANIMSPRPTR),HL
 178+ 4FD0              .E1:
 179+ 4FD0 2A 64 4F         LD HL,(AUTOSGAMPTR)
 180+ 4FD3 AF               XOR A
 181+ 4FD4 ED 42            SBC HL,BC
 182+ 4FD6 22 64 4F         LD (AUTOSGAMPTR),HL
 183+ 4FD9              .E3:
 184+ 4FD9 2A 10 40         LD HL,(FREEMEMPTR)
 185+ 4FDC AF               XOR A
 186+ 4FDD ED 42            SBC HL,BC
 187+ 4FDF 22 10 40         LD (FREEMEMPTR),HL
 188+ 4FE2              .EXIT:
 189+ 4FE2 FB               EI
 190+ 4FE3 E1           	POP HL
 191+ 4FE4 C9           	RET
 192+ 4FE5              .INCREASE:
 193+ 4FE5 ED 44            NEG
 194+ 4FE7 CD 04 50         CALL .SIZEDIFF
 195+ 4FEA CD 4B 50         CALL .INCREASE_COMMON
 196+ 4FED 2A 61 4F         LD HL,(ANIMSPRPTR)
 197+ 4FF0 09               ADD HL,BC
 198+ 4FF1 22 61 4F         LD (ANIMSPRPTR),HL
 199+ 4FF4              .E2:
 200+ 4FF4 2A 64 4F         LD HL,(AUTOSGAMPTR)
 201+ 4FF7 09               ADD HL,BC
 202+ 4FF8 22 64 4F         LD (AUTOSGAMPTR),HL
 203+ 4FFB              .E4:
 204+ 4FFB 2A 10 40         LD HL,(FREEMEMPTR)
 205+ 4FFE 09               ADD HL,BC
 206+ 4FFF 22 10 40         LD (FREEMEMPTR),HL
 207+ 5002 18 DE            JR .EXIT
 208+ 5004              .SIZEDIFF:
 209+ 5004 CD 66 4F         CALL Ax5
 210+ 5007 78               LD A,B
 211+ 5008 32 5A 4F         LD (ANIMITEMNUM),A
 212+ 500B 44               LD B,H
 213+ 500C 4D               LD C,L
 214+ 500D C9               RET ; BC=size difference in bytes
 215+ 500E              .SIZETOMOVE:
 216+ 500E D5               PUSH DE
 217+ 500F 2A 10 40         LD HL,(FREEMEMPTR)
 218+ 5012 FD 5E 00         LD E,(IY)
 219+ 5015 FD 56 01         LD D,(IY+1)
 220+ 5018 AF               XOR A
 221+ 5019 ED 52            SBC HL,DE
 222+ 501B 44               LD B,H
 223+ 501C 4D               LD C,L
 224+ 501D D1               POP DE
 225+ 501E C9               RET
 226+ 501F              .DECREASE_COMMON:
 227+ 501F FD 6E 00         LD L,(IY)
 228+ 5022 FD 66 01         LD H,(IY+1)
 229+ 5025 AF               XOR A
 230+ 5026 ED 42            SBC HL,BC
 231+ 5028 EB               EX DE,HL
 232+ 5029 C5               PUSH BC
 233+ 502A CD 0E 50         CALL .SIZETOMOVE
 234+ 502D F3               DI
 235+ 502E 78               LD A,B
 236+ 502F B1               OR C
 237+ 5030 28 08            JR Z,.L1
 238+ 5032 FD 6E 00         LD L,(IY)
 239+ 5035 FD 66 01         LD H,(IY+1)
 240+ 5038 ED B0            LDIR
 241+ 503A              .L1:
 242+ 503A C1               POP BC
 243+ 503B FD 6E 00         LD L,(IY)
 244+ 503E FD 66 01         LD H,(IY+1)
 245+ 5041 AF               XOR A
 246+ 5042 ED 42            SBC HL,BC
 247+ 5044 FD 75 00         LD (IY),L
 248+ 5047 FD 74 01         LD (IY+1),H
 249+ 504A C9               RET
 250+ 504B              .INCREASE_COMMON:
 251+ 504B 2A 10 40         LD HL,(FREEMEMPTR)
 252+ 504E 2B               DEC HL
 253+ 504F AF               XOR A
 254+ 5050 ED 42            SBC HL,BC
 255+ 5052 EB               EX DE,HL
 256+ 5053 C5               PUSH BC
 257+ 5054 CD 0E 50         CALL .SIZETOMOVE
 258+ 5057 F3               DI
 259+ 5058 78               LD A,B
 260+ 5059 B1               OR C
 261+ 505A 28 06            JR Z,.L2
 262+ 505C 2A 10 40         LD HL,(FREEMEMPTR)
 263+ 505F 2B               DEC HL
 264+ 5060 ED B8            LDDR
 265+ 5062              .L2:
 266+ 5062 C1               POP BC
 267+ 5063 FD 6E 00         LD L,(IY)
 268+ 5066 FD 66 01         LD H,(IY+1)
 269+ 5069 09               ADD HL,BC
 270+ 506A FD 75 00         LD (IY),L
 271+ 506D FD 74 01         LD (IY+1),H
 272+ 5070 C9               RET
 273+ 5071              ; *******************************************************************************************************
 274+ 5071
 275+ 5071               IF (1 == 1)
 276+ 5071              ; *******************************************************************************************************
 277+ 5071              ; function to handle CALL ANIMITEMPAT basic extension
 278+ 5071              ; ANIMITEMPAT ( BYTE id,
 279+ 5071              ;               INT ticks >0,
 280+ 5071              ;               BYTE pattern,
 281+ 5071              ;               BYTE color )
 282+ 5071              ; fills animation item data, returns an error if ID out of bounds
 283+ 5071              ANIMITEMPAT:
 284+ 5071                  ; opening (
 285+ 5071 CD 45 65     	CALL CHKCHAR
 286+ 5074 28           	DB '('
 287+ 5075              	; get id
 288+ 5075 DD 21 1C 52  	LD IX, GETBYT
 289+ 5079 CD 59 01     	CALL CALBAS
 290+ 507C F5               PUSH AF
 291+ 507D                  ; check if out of bounds
 292+ 507D 3C               INC A
 293+ 507E 4F               LD C,A
 294+ 507F 3A 5A 4F         LD A,(ANIMITEMNUM)
 295+ 5082 B9               CP C
 296+ 5083 DA 5D 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 297+ 5086              	; comma
 298+ 5086 CD 45 65     	CALL CHKCHAR
 299+ 5089 2C           	DB ','
 300+ 508A              	; get ticks
 301+ 508A DD 21 2F 54  	LD IX, FRMQNT
 302+ 508E CD 59 01     	CALL CALBAS
 303+ 5091 7A               LD A,D
 304+ 5092 B3               OR E
 305+ 5093 CA 61 65         JP Z, OVERFLOW
 306+ 5096 D5           	PUSH DE
 307+ 5097              	; comma
 308+ 5097 CD 45 65     	CALL CHKCHAR
 309+ 509A 2C           	DB ','
 310+ 509B              	; get pattern
 311+ 509B DD 21 1C 52  	LD IX, GETBYT
 312+ 509F CD 59 01     	CALL CALBAS
 313+ 50A2 F5               PUSH AF
 314+ 50A3              	; comma
 315+ 50A3 CD 45 65     	CALL CHKCHAR
 316+ 50A6 2C           	DB ','
 317+ 50A7              	; get color
 318+ 50A7 DD 21 1C 52  	LD IX, GETBYT
 319+ 50AB CD 59 01     	CALL CALBAS
 320+ 50AE F5               PUSH AF
 321+ 50AF              	; ending )
 322+ 50AF CD 45 65     	CALL CHKCHAR
 323+ 50B2 29           	DB ')'
 324+ 50B3              .ENTRY:
 325+ 50B3 E5               PUSH HL
 326+ 50B4 DD E1            POP IX
 327+ 50B6 D9               EXX
 328+ 50B7 C1               POP BC ; color
 329+ 50B8 D1               POP DE ; pattern
 330+ 50B9 E1               POP HL ; ticks
 331+ 50BA D9               EXX
 332+ 50BB F1               POP AF
 333+ 50BC CD 6F 4F         CALL GETnthANIMITEM
 334+ 50BF E5               PUSH HL
 335+ 50C0 FD E1            POP IY
 336+ 50C2 D9               EXX
 337+ 50C3 FD 36 00 00      LD (IY),0 ; type=0
 338+ 50C7 FD 75 01         LD (IY+1),L
 339+ 50CA FD 74 02         LD (IY+2),H
 340+ 50CD FD 72 03         LD (IY+3),D
 341+ 50D0 FD 70 04         LD (IY+4),B
 342+ 50D3
 343+ 50D3 DD E5            PUSH IX
 344+ 50D5 E1               POP HL
 345+ 50D6 C9               RET
 346+ 50D7              ; *******************************************************************************************************
 347+ 50D7               ENDIF
 348+ 50D7
 349+ 50D7               IF (0 == 1)
 350+ 50D7 ~            ; *******************************************************************************************************
 351+ 50D7 ~            ; same as ANIMITEMPAT but for DEFUSR approach
 352+ 50D7 ~            ; input IX=pointer to input array, real data from +2
 353+ 50D7 ~            ; +02 = ID
 354+ 50D7 ~            ; +04 = ticks
 355+ 50D7 ~            ; +06 = pattern
 356+ 50D7 ~            ; +08 = color
 357+ 50D7 ~            ANIMITEMPAT_DEFUSR:
 358+ 50D7 ~                ; check if out of bounds
 359+ 50D7 ~                LD C,(IX+2)
 360+ 50D7 ~                INC C
 361+ 50D7 ~                LD A,(ANIMITEMNUM)
 362+ 50D7 ~                CP C
 363+ 50D7 ~                RET C ; out of bounds, prevent memory corruption
 364+ 50D7 ~                LD A,C
 365+ 50D7 ~                DEC A
 366+ 50D7 ~                CALL GETnthANIMITEM
 367+ 50D7 ~                LD (HL),0 ; type=0
 368+ 50D7 ~                INC HL
 369+ 50D7 ~                LD A,(IX+4) ; ticks low
 370+ 50D7 ~                LD (HL),A
 371+ 50D7 ~                INC HL
 372+ 50D7 ~                LD A,(IX+5) ; ticks high
 373+ 50D7 ~                LD (HL),A
 374+ 50D7 ~                INC HL
 375+ 50D7 ~                LD A,(IX+6) ; pattern
 376+ 50D7 ~                LD (HL),A
 377+ 50D7 ~                INC HL
 378+ 50D7 ~                LD A,(IX+8) ; color
 379+ 50D7 ~                LD (HL),A
 380+ 50D7 ~                RET
 381+ 50D7 ~            ; *******************************************************************************************************
 382+ 50D7               ENDIF
 383+ 50D7
 384+ 50D7               IF (1 == 1)
 385+ 50D7              ; *******************************************************************************************************
 386+ 50D7              ; function to handle CALL ANIMITEMPTR basic extension
 387+ 50D7              ; ANIMITEMPTR ( BYTE id,
 388+ 50D7              ;               INT ticks,
 389+ 50D7              ;               INT pointer,
 390+ 50D7              ; fills animation item data, returns an error if ID out of bounds
 391+ 50D7              ANIMITEMPTR_CMD:
 392+ 50D7                  ; opening (
 393+ 50D7 CD 45 65     	CALL CHKCHAR
 394+ 50DA 28           	DB '('
 395+ 50DB              	; get id
 396+ 50DB DD 21 1C 52  	LD IX, GETBYT
 397+ 50DF CD 59 01     	CALL CALBAS
 398+ 50E2 F5               PUSH AF
 399+ 50E3                  ; check if out of bounds
 400+ 50E3 3C               INC A
 401+ 50E4 4F               LD C,A
 402+ 50E5 3A 5A 4F         LD A,(ANIMITEMNUM)
 403+ 50E8 B9               CP C
 404+ 50E9 DA 5D 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 405+ 50EC              	; comma
 406+ 50EC CD 45 65     	CALL CHKCHAR
 407+ 50EF 2C           	DB ','
 408+ 50F0              	; get ticks
 409+ 50F0 DD 21 2F 54  	LD IX, FRMQNT
 410+ 50F4 CD 59 01     	CALL CALBAS
 411+ 50F7 7A               LD A,D
 412+ 50F8 B3               OR E
 413+ 50F9 CA 61 65         JP Z,OVERFLOW
 414+ 50FC D5           	PUSH DE
 415+ 50FD              	; comma
 416+ 50FD CD 45 65     	CALL CHKCHAR
 417+ 5100 2C           	DB ','
 418+ 5101              	; get pointer
 419+ 5101 DD 21 2F 54  	LD IX, FRMQNT
 420+ 5105 CD 59 01     	CALL CALBAS
 421+ 5108 D5           	PUSH DE
 422+ 5109              	; ending )
 423+ 5109 CD 45 65     	CALL CHKCHAR
 424+ 510C 29           	DB ')'
 425+ 510D              .ENTRY:
 426+ 510D E5               PUSH HL
 427+ 510E DD E1            POP IX
 428+ 5110 D9               EXX
 429+ 5111 D1               POP DE ; pointer
 430+ 5112 E1               POP HL ; ticks
 431+ 5113 D9               EXX
 432+ 5114 F1               POP AF
 433+ 5115 CD 6F 4F         CALL GETnthANIMITEM
 434+ 5118 E5               PUSH HL
 435+ 5119 FD E1            POP IY
 436+ 511B D9               EXX
 437+ 511C FD 36 00 01      LD (IY),1 ; type=1
 438+ 5120 FD 75 01         LD (IY+1),L
 439+ 5123 FD 74 02         LD (IY+2),H
 440+ 5126 FD 73 03         LD (IY+3),E
 441+ 5129 FD 72 04         LD (IY+4),D
 442+ 512C
 443+ 512C DD E5            PUSH IX
 444+ 512E E1               POP HL
 445+ 512F C9               RET
 446+ 5130              ; *******************************************************************************************************
 447+ 5130               ENDIF
 448+ 5130
 449+ 5130               IF (0 == 1)
 450+ 5130 ~            ; *******************************************************************************************************
 451+ 5130 ~            ; same as ANIMITEMPTR but for DEFUSR approach
 452+ 5130 ~            ; input IX=pointer to input array, real data from +2
 453+ 5130 ~            ; +02 = ID
 454+ 5130 ~            ; +04 = ticks
 455+ 5130 ~            ; +06 = pointer
 456+ 5130 ~            ANIMITEMPTR_DEFUSR:
 457+ 5130 ~                ; check if out of bounds
 458+ 5130 ~                LD C,(IX+2)
 459+ 5130 ~                INC C
 460+ 5130 ~                LD A,(ANIMITEMNUM)
 461+ 5130 ~                CP C
 462+ 5130 ~                RET C ; out of bounds, prevent memory corruption
 463+ 5130 ~                LD A,C
 464+ 5130 ~                DEC A
 465+ 5130 ~                CALL GETnthANIMITEM
 466+ 5130 ~                LD (HL),1 ; type=1
 467+ 5130 ~                INC HL
 468+ 5130 ~                LD A,(IX+4) ; ticks low
 469+ 5130 ~                LD (HL),A
 470+ 5130 ~                INC HL
 471+ 5130 ~                LD A,(IX+5) ; ticks high
 472+ 5130 ~                LD (HL),A
 473+ 5130 ~                INC HL
 474+ 5130 ~                LD A,(IX+6) ; pointer low
 475+ 5130 ~                LD (HL),A
 476+ 5130 ~                INC HL
 477+ 5130 ~                LD A,(IX+7) ; pointer high
 478+ 5130 ~                LD (HL),A
 479+ 5130 ~                RET
 480+ 5130 ~            ; *******************************************************************************************************
 481+ 5130               ENDIF
 482+ 5130
 483+ 5130               IF (0 == 1)
 484+ 5130 ~            ; *******************************************************************************************************
 485+ 5130 ~            ; same as MAXANIMDEFS but for DEFUSR approach
 486+ 5130 ~            ; input IX=pointer to input array, real data from +2
 487+ 5130 ~            ; +2 = number
 488+ 5130 ~            MAXANIMDEFS_DEFUSR:
 489+ 5130 ~                LD A,(IX+2)
 490+ 5130 ~                JR MAXANIMDEFS.COMMON
 491+ 5130 ~            ; *******************************************************************************************************
 492+ 5130               ENDIF
 493+ 5130
 494+ 5130              ; *******************************************************************************************************
 495+ 5130              ; function to handle CALL MAXANIMDEFS basic extension
 496+ 5130              ; MAXANIMDEFS (BYTE number)
 497+ 5130              ; sets new number and moves memory buffers as needed
 498+ 5130              MAXANIMDEFS:
 499+ 5130               IF (1 == 1)
 500+ 5130              	; opening (
 501+ 5130 CD 45 65     	CALL CHKCHAR
 502+ 5133 28           	DB '('
 503+ 5134              	; get value
 504+ 5134 DD 21 1C 52  	LD IX, GETBYT
 505+ 5138 CD 59 01     	CALL CALBAS
 506+ 513B F5               PUSH AF
 507+ 513C              	; ending )
 508+ 513C CD 45 65     	CALL CHKCHAR
 509+ 513F 29           	DB ')'
 510+ 5140 F1               POP AF
 511+ 5141               ENDIF
 512+ 5141              .COMMON:
 513+ 5141 F3               DI
 514+ 5142              	; save position
 515+ 5142 E5           	PUSH HL
 516+ 5143              .ENTRY:
 517+ 5143 47               LD B,A
 518+ 5144 3A 5D 4F         LD A,(ANIMDEFNUM)
 519+ 5147 90               SUB B
 520+ 5148 CA E2 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 521+ 514B FD 21 61 4F      LD IY,ANIMSPRPTR
 522+ 514F FA 5B 51         JP M, .INCREASE
 523+ 5152                  ; new value is lower than previous one
 524+ 5152 CD 66 51         CALL .SIZEDIFF
 525+ 5155 CD 1F 50         CALL MAXANIMITEMS.DECREASE_COMMON
 526+ 5158 C3 D0 4F         JP MAXANIMITEMS.E1
 527+ 515B              .INCREASE:
 528+ 515B ED 44            NEG
 529+ 515D CD 66 51         CALL .SIZEDIFF
 530+ 5160 CD 4B 50         CALL MAXANIMITEMS.INCREASE_COMMON
 531+ 5163 C3 F4 4F         JP MAXANIMITEMS.E2
 532+ 5166              .SIZEDIFF:
 533+ 5166 26 00            LD H,0
 534+ 5168 6F               LD L,A
 535+ 5169 CD 31 64         CALL HLx16
 536+ 516C 78               LD A,B
 537+ 516D 32 5D 4F         LD (ANIMDEFNUM),A
 538+ 5170 44               LD B,H
 539+ 5171 4D               LD C,L
 540+ 5172 C9               RET ; BC=size difference in bytes
 541+ 5173              ; *******************************************************************************************************
 542+ 5173
 543+ 5173               IF (1 == 1)
 544+ 5173              ; *******************************************************************************************************
 545+ 5173              ; function to handle CALL ANIMDEF basic extension
 546+ 5173              ; ANIMITEMPAT ( BYTE id,
 547+ 5173              ;               BYTE size,
 548+ 5173              ;               INT[] list )
 549+ 5173              ; fills animation definition data, returns an error if out of bounds, or invalid type
 550+ 5173              ANIMDEF:
 551+ 5173                  ; opening (
 552+ 5173 CD 45 65     	CALL CHKCHAR
 553+ 5176 28           	DB '('
 554+ 5177              	; get id
 555+ 5177 DD 21 1C 52  	LD IX, GETBYT
 556+ 517B CD 59 01     	CALL CALBAS
 557+ 517E F5               PUSH AF
 558+ 517F                  ; check if out of bounds
 559+ 517F 3C               INC A
 560+ 5180 4F               LD C,A
 561+ 5181 3A 5D 4F         LD A,(ANIMDEFNUM)
 562+ 5184 B9               CP C
 563+ 5185 DA 5D 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 564+ 5188              	; comma
 565+ 5188 CD 45 65     	CALL CHKCHAR
 566+ 518B 2C           	DB ','
 567+ 518C              	; get size
 568+ 518C DD 21 1C 52  	LD IX, GETBYT
 569+ 5190 CD 59 01     	CALL CALBAS
 570+ 5193 FE 10            CP 16
 571+ 5195 D2 61 65         JP NC, OVERFLOW
 572+ 5198 B7               OR A
 573+ 5199 CA 61 65         JP Z, OVERFLOW
 574+ 519C F5           	PUSH AF
 575+ 519D              	; comma
 576+ 519D CD 45 65     	CALL CHKCHAR
 577+ 51A0 2C           	DB ','
 578+ 51A1              	; get pointer to a list of animation items in integer array format
 579+ 51A1                  ; get array pointer
 580+ 51A1 D1               POP DE
 581+ 51A2 D5               PUSH DE
 582+ 51A3 3E 02            LD A,2
 583+ 51A5 06 01            LD B,1
 584+ 51A7 CD 72 65         CALL GET_BASIC_ARRAY_DATA_POINTER
 585+ 51AA C5               PUSH BC
 586+ 51AB              	; ending )
 587+ 51AB CD 45 65     	CALL CHKCHAR
 588+ 51AE 29           	DB ')'
 589+ 51AF              .ENTRY:
 590+ 51AF E5               PUSH HL
 591+ 51B0 DD E1            POP IX
 592+ 51B2 D1               POP DE ; pointer to INT array
 593+ 51B3 C1               POP BC ; B=item number
 594+ 51B4 F1               POP AF ; id
 595+ 51B5 D5               PUSH DE
 596+ 51B6 CD 78 4F         CALL GETnthANIMDEF
 597+ 51B9 D1               POP DE
 598+ 51BA 70               LD (HL),B
 599+ 51BB              .L1:
 600+ 51BB 23               INC HL
 601+ 51BC 1A               LD A,(DE)
 602+ 51BD 13          > INC DE
 602+ 51BE 13          > INC DE
 603+ 51BF 77               LD (HL),A
 604+ 51C0 10 F9            DJNZ .L1
 605+ 51C2 DD E5            PUSH IX
 606+ 51C4 E1               POP HL
 607+ 51C5 C9               RET
 608+ 51C6              ; *******************************************************************************************************
 609+ 51C6               ENDIF
 610+ 51C6
 611+ 51C6               IF (0 == 1)
 612+ 51C6 ~            ; *******************************************************************************************************
 613+ 51C6 ~            ; same as ANIMDEF but for DEFUSR approach
 614+ 51C6 ~            ; input IX=pointer to input array, real data from +2
 615+ 51C6 ~            ; +02 = ID
 616+ 51C6 ~            ; +04 = list size
 617+ 51C6 ~            ; +06 = list pointer
 618+ 51C6 ~            ANIMDEF_DEFUSR:
 619+ 51C6 ~                ; check if out of bounds
 620+ 51C6 ~                LD C,(IX+2)
 621+ 51C6 ~                INC C
 622+ 51C6 ~                LD A,(ANIMDEFNUM)
 623+ 51C6 ~                CP C
 624+ 51C6 ~                RET C ; invalid id
 625+ 51C6 ~            	; get size
 626+ 51C6 ~                LD A,(IX+4)
 627+ 51C6 ~                CP 16
 628+ 51C6 ~                RET NC ; overflow
 629+ 51C6 ~                OR A
 630+ 51C6 ~                RET Z ; ID=0, invalid
 631+ 51C6 ~                LD B,A
 632+ 51C6 ~                LD A,C
 633+ 51C6 ~                DEC A
 634+ 51C6 ~                CALL GETnthANIMDEF
 635+ 51C6 ~                LD (HL),B
 636+ 51C6 ~                LD E,(IX+6)
 637+ 51C6 ~                LD D,(IX+7)
 638+ 51C6 ~            .L1:
 639+ 51C6 ~                INC HL
 640+ 51C6 ~                LD A,(DE)
 641+ 51C6 ~                .2 INC DE
 642+ 51C6 ~                LD (HL),A
 643+ 51C6 ~                DJNZ .L1
 644+ 51C6 ~                RET
 645+ 51C6 ~            ; *******************************************************************************************************
 646+ 51C6               ENDIF
 647+ 51C6
 648+ 51C6               IF (0 == 1)
 649+ 51C6 ~            ; *******************************************************************************************************
 650+ 51C6 ~            ; same as MAXANIMSPRS but for DEFUSR approach
 651+ 51C6 ~            ; input IX=pointer to input array, real data from +2
 652+ 51C6 ~            ; +2 = number
 653+ 51C6 ~            MAXANIMSPRS_DEFUSR:
 654+ 51C6 ~                LD A,(IX+2)
 655+ 51C6 ~                JR MAXANIMSPRS.COMMON
 656+ 51C6 ~            ; *******************************************************************************************************
 657+ 51C6               ENDIF
 658+ 51C6
 659+ 51C6              ; *******************************************************************************************************
 660+ 51C6              ; function to handle CALL MAXANIMSPRS basic extension
 661+ 51C6              ; MAXANIMSPRS (BYTE number)
 662+ 51C6              ; sets new number and moves memory buffers as needed
 663+ 51C6              MAXANIMSPRS:
 664+ 51C6               IF (1 == 1)
 665+ 51C6              	; opening (
 666+ 51C6 CD 45 65     	CALL CHKCHAR
 667+ 51C9 28           	DB '('
 668+ 51CA              	; get value
 669+ 51CA DD 21 1C 52  	LD IX, GETBYT
 670+ 51CE CD 59 01     	CALL CALBAS
 671+ 51D1 F5               PUSH AF
 672+ 51D2              	; ending )
 673+ 51D2 CD 45 65     	CALL CHKCHAR
 674+ 51D5 29           	DB ')'
 675+ 51D6 F1               POP AF
 676+ 51D7               ENDIF
 677+ 51D7              .COMMON:
 678+ 51D7 F3               DI
 679+ 51D8              	; save position
 680+ 51D8 E5           	PUSH HL
 681+ 51D9              .ENTRY:
 682+ 51D9 47               LD B,A
 683+ 51DA 3A 60 4F         LD A,(ANIMSPRNUM)
 684+ 51DD 90               SUB B
 685+ 51DE CA E2 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 686+ 51E1 FD 21 64 4F      LD IY,AUTOSGAMPTR
 687+ 51E5 FA F1 51         JP M, .INCREASE
 688+ 51E8                  ; new value is lower than previous one
 689+ 51E8 CD 12 52         CALL .SIZEDIFF
 690+ 51EB CD 1F 50         CALL MAXANIMITEMS.DECREASE_COMMON
 691+ 51EE C3 D9 4F         JP MAXANIMITEMS.E3
 692+ 51F1              .INCREASE:
 693+ 51F1 ED 44            NEG
 694+ 51F3 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 695+ 51F4 CD 12 52         CALL .SIZEDIFF
 696+ 51F7 CD 4B 50         CALL MAXANIMITEMS.INCREASE_COMMON
 697+ 51FA AF               XOR A
 698+ 51FB ED 42            SBC HL,BC ; location of new stuff
 699+ 51FD F1               POP AF
 700+ 51FE C5               PUSH BC
 701+ 51FF 47               LD B,A
 702+ 5200 11 08 00         LD DE,8
 703+ 5203 E5               PUSH HL
 704+ 5204 DD E1            POP IX
 705+ 5206              .L1:
 706+ 5206 DD 36 06 00      LD (IX+6),0 ; active flag
 707+ 520A DD 19            ADD IX,DE
 708+ 520C 10 F8            DJNZ .L1
 709+ 520E C1               POP BC
 710+ 520F C3 FB 4F         JP MAXANIMITEMS.E4
 711+ 5212              .SIZEDIFF:
 712+ 5212 26 00            LD H,0
 713+ 5214 6F               LD L,A
 714+ 5215 CD 32 64         CALL HLx8
 715+ 5218 78               LD A,B
 716+ 5219 32 60 4F         LD (ANIMSPRNUM),A
 717+ 521C 44               LD B,H
 718+ 521D 4D               LD C,L
 719+ 521E C9               RET ; BC=size difference in bytes
 720+ 521F              ; *******************************************************************************************************
 721+ 521F
 722+ 521F               IF (1 == 1)
 723+ 521F              ; *******************************************************************************************************
 724+ 521F              ; function to handle CALL ANIMSPRITE basic extension
 725+ 521F              ; ANIMSPRITE ( BYTE id,
 726+ 521F              ;              BYTE sprite_number,
 727+ 521F              ;              BYTE animation_definition_id,
 728+ 521F              ;              BYTE cyclic_flag )
 729+ 521F              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 730+ 521F              ANIMSPRITE:
 731+ 521F                  ; opening (
 732+ 521F CD 45 65     	CALL CHKCHAR
 733+ 5222 28           	DB '('
 734+ 5223              	; get sprite animation id
 735+ 5223 DD 21 1C 52  	LD IX, GETBYT
 736+ 5227 CD 59 01     	CALL CALBAS
 737+ 522A F5               PUSH AF
 738+ 522B 3C               INC A
 739+ 522C 4F               LD C,A
 740+ 522D 3A 60 4F         LD A,(ANIMSPRNUM)
 741+ 5230 B9               CP C
 742+ 5231 DA 5D 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 743+ 5234              	; comma
 744+ 5234 CD 45 65     	CALL CHKCHAR
 745+ 5237 2C           	DB ','
 746+ 5238              	; get sprite number
 747+ 5238 DD 21 1C 52  	LD IX, GETBYT
 748+ 523C CD 59 01     	CALL CALBAS
 749+ 523F F5               PUSH AF
 750+ 5240                  ; check if out of bounds
 751+ 5240 FE 20            CP 32
 752+ 5242 D2 5D 65         JP NC, SUBSCRIPT_OUT_OF_RANGE
 753+ 5245              	; comma
 754+ 5245 CD 45 65     	CALL CHKCHAR
 755+ 5248 2C           	DB ','
 756+ 5249              	; get animation definition id
 757+ 5249 DD 21 1C 52  	LD IX, GETBYT
 758+ 524D CD 59 01     	CALL CALBAS
 759+ 5250 F5               PUSH AF
 760+ 5251 3C               INC A
 761+ 5252 4F               LD C,A
 762+ 5253 3A 5D 4F         LD A,(ANIMDEFNUM)
 763+ 5256 B9               CP C
 764+ 5257 DA 5D 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 765+ 525A              	; comma
 766+ 525A CD 45 65     	CALL CHKCHAR
 767+ 525D 2C           	DB ','
 768+ 525E              	; get cyclic flag
 769+ 525E DD 21 1C 52  	LD IX, GETBYT
 770+ 5262 CD 59 01         CALL CALBAS
 771+ 5265 F5           	PUSH AF
 772+ 5266              	; ending )
 773+ 5266 CD 45 65     	CALL CHKCHAR
 774+ 5269 29           	DB ')'
 775+ 526A              .ENTRY:
 776+ 526A E5               PUSH HL
 777+ 526B DD E1            POP IX
 778+ 526D D9               EXX
 779+ 526E D1               POP DE ; cyclic
 780+ 526F C1               POP BC ; animation definition id
 781+ 5270 E1               POP HL ; sprite number
 782+ 5271 D9               EXX
 783+ 5272 F1               POP AF ; sprite animation id
 784+ 5273 CD 84 4F         CALL GETnthSPRANIM
 785+ 5276 E5               PUSH HL
 786+ 5277 FD E1            POP IY
 787+ 5279 D9               EXX
 788+ 527A FD 74 00         LD (IY),H
 789+ 527D FD 70 04         LD (IY+4),B
 790+ 5280 FD 72 05         LD (IY+5),D
 791+ 5283                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 792+ 5283                  ; following will do preparation for ANIMSTEP situation
 793+ 5283                  ; current item set to above limit and timer to 1
 794+ 5283                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 795+ 5283 FD 36 03 FF      LD (IY+3),255
 796+ 5287 FD 36 01 01      LD (IY+1),1
 797+ 528B FD 36 02 00      LD (IY+2),0
 798+ 528F                  ; mark as sprite animation
 799+ 528F FD 36 07 00      LD (IY+7),0
 800+ 5293 DD E5            PUSH IX
 801+ 5295 E1               POP HL
 802+ 5296 C9               RET
 803+ 5297              ; *******************************************************************************************************
 804+ 5297               ENDIF
 805+ 5297
 806+ 5297               IF (0 == 1)
 807+ 5297 ~            ; *******************************************************************************************************
 808+ 5297 ~            ; same as ANIMSPRITE but for DEFUSR approach
 809+ 5297 ~            ; input IX=pointer to input array, real data from +2
 810+ 5297 ~            ; +02 = ID
 811+ 5297 ~            ; +04 = sprite number
 812+ 5297 ~            ; +06 = animation definition id
 813+ 5297 ~            ; +08 = cyclic flag
 814+ 5297 ~            ANIMSPRITE_DEFUSR:
 815+ 5297 ~                LD C,(IX+2)
 816+ 5297 ~                INC C
 817+ 5297 ~                LD A,(ANIMSPRNUM)
 818+ 5297 ~                CP C
 819+ 5297 ~                RET C ; invalid id
 820+ 5297 ~            	; get sprite number
 821+ 5297 ~                LD A,(IX+4)
 822+ 5297 ~                CP 32
 823+ 5297 ~                RET NC ; invalid sprite id
 824+ 5297 ~                LD B,(IX+6)
 825+ 5297 ~                INC B
 826+ 5297 ~                LD A,(ANIMDEFNUM)
 827+ 5297 ~                CP B
 828+ 5297 ~                RET C ; invalid animation definition id
 829+ 5297 ~                LD A,C
 830+ 5297 ~                DEC A
 831+ 5297 ~                CALL GETnthSPRANIM
 832+ 5297 ~                LD A,(IX+4)
 833+ 5297 ~                LD (HL),A ; +0
 834+ 5297 ~                INC HL
 835+ 5297 ~                LD (HL),1 ; +1
 836+ 5297 ~                INC HL
 837+ 5297 ~                LD (HL),0 ; +2
 838+ 5297 ~                INC HL
 839+ 5297 ~                LD (HL),255 ; +3
 840+ 5297 ~                INC HL
 841+ 5297 ~                DEC B
 842+ 5297 ~                LD (HL),B ; +4
 843+ 5297 ~                INC HL
 844+ 5297 ~                LD A,(IX+8) ; +5
 845+ 5297 ~                LD (HL),A
 846+ 5297 ~                INC HL
 847+ 5297 ~                INC HL
 848+ 5297 ~                LD (HL),0 ; +7
 849+ 5297 ~                RET
 850+ 5297 ~            ; *******************************************************************************************************
 851+ 5297               ENDIF
 852+ 5297
 853+ 5297
 854+ 5297               IF (1 == 1)
 855+ 5297              ; *******************************************************************************************************
 856+ 5297              ; function to handle CALL ANIMCHAR basic extension
 857+ 5297              ; ANIMCHAR ( BYTE id,
 858+ 5297              ;            INT character number 0-767,
 859+ 5297              ;            BYTE animation_definition_id,
 860+ 5297              ;            BYTE cyclic_flag )
 861+ 5297              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 862+ 5297              ANIMCHAR:
 863+ 5297                  ; opening (
 864+ 5297 CD 45 65     	CALL CHKCHAR
 865+ 529A 28           	DB '('
 866+ 529B              	; get sprite animation id
 867+ 529B DD 21 1C 52  	LD IX, GETBYT
 868+ 529F CD 59 01     	CALL CALBAS
 869+ 52A2 F5               PUSH AF
 870+ 52A3 3C               INC A
 871+ 52A4 4F               LD C,A
 872+ 52A5 3A 60 4F         LD A,(ANIMSPRNUM)
 873+ 52A8 B9               CP C
 874+ 52A9 DA 5D 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 875+ 52AC              	; comma
 876+ 52AC CD 45 65     	CALL CHKCHAR
 877+ 52AF 2C           	DB ','
 878+ 52B0              	; get character number
 879+ 52B0 DD 21 2F 54  	LD IX, FRMQNT
 880+ 52B4 CD 59 01     	CALL CALBAS
 881+ 52B7 D5               PUSH DE
 882+ 52B8                  ; check if out of bounds
 883+ 52B8 7A               LD A,D
 884+ 52B9 FE 03            CP 3
 885+ 52BB D2 5D 65         JP NC, SUBSCRIPT_OUT_OF_RANGE
 886+ 52BE              	; comma
 887+ 52BE CD 45 65     	CALL CHKCHAR
 888+ 52C1 2C           	DB ','
 889+ 52C2              	; get animation definition id
 890+ 52C2 DD 21 1C 52  	LD IX, GETBYT
 891+ 52C6 CD 59 01     	CALL CALBAS
 892+ 52C9 F5               PUSH AF
 893+ 52CA 3C               INC A
 894+ 52CB 4F               LD C,A
 895+ 52CC 3A 5D 4F         LD A,(ANIMDEFNUM)
 896+ 52CF B9               CP C
 897+ 52D0 DA 5D 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 898+ 52D3              	; comma
 899+ 52D3 CD 45 65     	CALL CHKCHAR
 900+ 52D6 2C           	DB ','
 901+ 52D7              	; get cyclic flag
 902+ 52D7 DD 21 1C 52  	LD IX, GETBYT
 903+ 52DB CD 59 01         CALL CALBAS
 904+ 52DE F5           	PUSH AF
 905+ 52DF              	; ending )
 906+ 52DF CD 45 65     	CALL CHKCHAR
 907+ 52E2 29           	DB ')'
 908+ 52E3              .ENTRY:
 909+ 52E3 E5               PUSH HL
 910+ 52E4 DD E1            POP IX
 911+ 52E6 D9               EXX
 912+ 52E7 D1               POP DE ; cyclic
 913+ 52E8 C1               POP BC ; animation definition id
 914+ 52E9 E1               POP HL ; character number
 915+ 52EA D9               EXX
 916+ 52EB F1               POP AF ; sprite animation id
 917+ 52EC CD 84 4F         CALL GETnthSPRANIM
 918+ 52EF E5               PUSH HL
 919+ 52F0 FD E1            POP IY
 920+ 52F2 D9               EXX
 921+ 52F3 FD 75 00         LD (IY),L
 922+ 52F6 24               INC H ; save character bank+1
 923+ 52F7 FD 74 07         LD (IY+7),H
 924+ 52FA FD 70 04         LD (IY+4),B
 925+ 52FD FD 72 05         LD (IY+5),D
 926+ 5300                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 927+ 5300                  ; following will do preparation for ANIMSTEP situation
 928+ 5300                  ; current item set to above limit and timer to 1
 929+ 5300                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 930+ 5300 FD 36 03 FF      LD (IY+3),255
 931+ 5304 FD 36 01 01      LD (IY+1),1
 932+ 5308 FD 36 02 00      LD (IY+2),0
 933+ 530C DD E5            PUSH IX
 934+ 530E E1               POP HL
 935+ 530F C9               RET
 936+ 5310              ; *******************************************************************************************************
 937+ 5310               ENDIF
 938+ 5310
 939+ 5310               IF (0 == 1)
 940+ 5310 ~            ; *******************************************************************************************************
 941+ 5310 ~            ; same as ANIMCHAR but for DEFUSR approach
 942+ 5310 ~            ; input IX=pointer to input array, real data from +2
 943+ 5310 ~            ; +02 = ID
 944+ 5310 ~            ; +04 = character number
 945+ 5310 ~            ; +06 = animation definition id
 946+ 5310 ~            ; +08 = cyclic flag
 947+ 5310 ~            ANIMCHAR_DEFUSR:
 948+ 5310 ~                LD C,(IX+2)
 949+ 5310 ~                INC C
 950+ 5310 ~                LD A,(ANIMSPRNUM)
 951+ 5310 ~                CP C
 952+ 5310 ~                RET C ; invalid id
 953+ 5310 ~            	; get sprite number
 954+ 5310 ~                LD A,(IX+5)
 955+ 5310 ~                CP 3
 956+ 5310 ~                RET NC ; invalid character (>767)
 957+ 5310 ~                LD B,(IX+6)
 958+ 5310 ~                INC B
 959+ 5310 ~                LD A,(ANIMDEFNUM)
 960+ 5310 ~                CP B
 961+ 5310 ~                RET C ; invalid animation definition id
 962+ 5310 ~                LD A,C
 963+ 5310 ~                DEC A
 964+ 5310 ~                CALL GETnthSPRANIM
 965+ 5310 ~                LD A,(IX+4)
 966+ 5310 ~                LD (HL),A ; +0
 967+ 5310 ~                INC HL
 968+ 5310 ~                LD (HL),1 ; +1
 969+ 5310 ~                INC HL
 970+ 5310 ~                LD (HL),0 ; +2
 971+ 5310 ~                INC HL
 972+ 5310 ~                LD (HL),255 ; +3
 973+ 5310 ~                INC HL
 974+ 5310 ~                DEC B
 975+ 5310 ~                LD (HL),B ; +4
 976+ 5310 ~                INC HL
 977+ 5310 ~                LD A,(IX+8) ; +5
 978+ 5310 ~                LD (HL),A
 979+ 5310 ~                INC HL
 980+ 5310 ~                INC HL
 981+ 5310 ~                LD A,(IX+5)
 982+ 5310 ~                INC A
 983+ 5310 ~                LD (HL),A ; +7
 984+ 5310 ~                RET
 985+ 5310 ~            ; *******************************************************************************************************
 986+ 5310               ENDIF
 987+ 5310
 988+ 5310               IF (0 == 1)
 989+ 5310 ~            ; *******************************************************************************************************
 990+ 5310 ~            ; same as MAXAUTOSGAMS but for DEFUSR approach
 991+ 5310 ~            ; input IX=pointer to input array, real data from +2
 992+ 5310 ~            ; +2 = number
 993+ 5310 ~            MAXAUTOSGAMS_DEFUSR:
 994+ 5310 ~                LD A,(IX+2)
 995+ 5310 ~                JR MAXAUTOSGAMS.COMMON
 996+ 5310 ~            ; *******************************************************************************************************
 997+ 5310               ENDIF
 998+ 5310
 999+ 5310              ; *******************************************************************************************************
1000+ 5310              ; function to handle CALL MAXAUTOSGAMS basic extension
1001+ 5310              ; MAXAUTOSGAMS (BYTE number)
1002+ 5310              ; sets new number and moves memory buffers as needed
1003+ 5310              MAXAUTOSGAMS:
1004+ 5310               IF (1 == 1)
1005+ 5310              	; opening (
1006+ 5310 CD 45 65     	CALL CHKCHAR
1007+ 5313 28           	DB '('
1008+ 5314              	; get value
1009+ 5314 DD 21 1C 52  	LD IX, GETBYT
1010+ 5318 CD 59 01     	CALL CALBAS
1011+ 531B F5               PUSH AF
1012+ 531C              	; ending )
1013+ 531C CD 45 65     	CALL CHKCHAR
1014+ 531F 29           	DB ')'
1015+ 5320 F1               POP AF
1016+ 5321               ENDIF
1017+ 5321              .COMMON:
1018+ 5321 F3               DI
1019+ 5322              	; save position
1020+ 5322 E5           	PUSH HL
1021+ 5323              .ENTRY:
1022+ 5323 47               LD B,A
1023+ 5324 3A 63 4F         LD A,(AUTOSGAMNUM)
1024+ 5327 90               SUB B
1025+ 5328 CA E2 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
1026+ 532B FD 21 10 40      LD IY,FREEMEMPTR
1027+ 532F FA 3B 53         JP M, .INCREASE
1028+ 5332                  ; new value is lower than previous one
1029+ 5332 CD 5C 53         CALL .SIZEDIFF
1030+ 5335 CD 1F 50         CALL MAXANIMITEMS.DECREASE_COMMON
1031+ 5338 C3 E2 4F         JP MAXANIMITEMS.EXIT
1032+ 533B              .INCREASE:
1033+ 533B ED 44            NEG
1034+ 533D F5               PUSH AF; save difference for later to set active flag to 0 of new entires
1035+ 533E CD 5C 53         CALL .SIZEDIFF
1036+ 5341 CD 4B 50         CALL MAXANIMITEMS.INCREASE_COMMON
1037+ 5344 AF               XOR A
1038+ 5345 ED 42            SBC HL,BC ; location of new stuff
1039+ 5347 F1               POP AF
1040+ 5348 C5               PUSH BC
1041+ 5349 47               LD B,A
1042+ 534A 11 18 00         LD DE,24
1043+ 534D E5               PUSH HL
1044+ 534E DD E1            POP IX
1045+ 5350              .L1:
1046+ 5350 DD 36 13 00      LD (IX+19),0 ; active flag
1047+ 5354 DD 19            ADD IX,DE
1048+ 5356 10 F8            DJNZ .L1
1049+ 5358 C1               POP BC
1050+ 5359 C3 E2 4F         JP MAXANIMITEMS.EXIT
1051+ 535C              .SIZEDIFF:
1052+ 535C 26 00            LD H,0
1053+ 535E 6F               LD L,A
1054+ 535F CD 32 64         CALL HLx8
1055+ 5362 54               LD D,H
1056+ 5363 5D               LD E,L
1057+ 5364 29               ADD HL,HL
1058+ 5365 19               ADD HL,DE
1059+ 5366 78               LD A,B
1060+ 5367 32 63 4F         LD (AUTOSGAMNUM),A
1061+ 536A 44               LD B,H
1062+ 536B 4D               LD C,L
1063+ 536C C9               RET ; BC=size difference in bytes
1064+ 536D              ; *******************************************************************************************************
1065+ 536D
1066+ 536D               IF (1 == 1)
1067+ 536D              ; *******************************************************************************************************
1068+ 536D              ; function to handle CALL AUTOSGAMDEF basic extension
1069+ 536D              ; AUTOSGAMDEF ( BYTE id,
1070+ 536D              ;               INT VARIABLE x, INT VARIABLE y,
1071+ 536D              ;               INT minimum, INT maximum, INT delta,
1072+ 536D              ;               INT direction =0 horizontal,
1073+ 536D              ;               INT ticks,
1074+ 536D              ;               BYTE sprite_group_count,
1075+ 536D              ;               INT[2][sprite_group_count] VARIABLE sprite_group,
1076+ 536D              ;               BYTE item_number,
1077+ 536D              ;               INT[] VARIABLE sprite_animations_negative_direction,
1078+ 536D              ;               INT[] VARIABLE sprite_animations_positive_direction
1079+ 536D              AUTOSGAMDEF:
1080+ 536D                  ; opening (
1081+ 536D CD 45 65     	CALL CHKCHAR
1082+ 5370 28           	DB '('
1083+ 5371              	; get sprite animation id
1084+ 5371 DD 21 1C 52  	LD IX, GETBYT
1085+ 5375 CD 59 01     	CALL CALBAS
1086+ 5378 F5               PUSH AF
1087+ 5379 3C               INC A
1088+ 537A 4F               LD C,A
1089+ 537B 3A 63 4F         LD A,(AUTOSGAMNUM)
1090+ 537E B9               CP C
1091+ 537F DA 5D 65         JP C,SUBSCRIPT_OUT_OF_RANGE
1092+ 5382 F1               POP AF
1093+ 5383 E5               PUSH HL
1094+ 5384 CD 90 4F         CALL GETnthAUTOSGAM
1095+ 5387 22 31 62         LD (BLIT_TMP),HL ; for later
1096+ 538A E1               POP HL
1097+ 538B              	; comma
1098+ 538B CD 45 65     	CALL CHKCHAR
1099+ 538E 2C           	DB ','
1100+ 538F              	; get address of the X coordinate variable
1101+ 538F DD 21 A4 5E  	LD IX, PTRGET
1102+ 5393 CD 59 01     	CALL CALBAS
1103+ 5396 DD 2A 31 62  	LD IX,(BLIT_TMP)
1104+ 539A DD 73 00         LD (IX+0),E
1105+ 539D DD 72 01         LD (IX+1),D
1106+ 53A0              	; comma
1107+ 53A0 CD 45 65     	CALL CHKCHAR
1108+ 53A3 2C           	DB ','
1109+ 53A4              	; get address of the Y coordinate variable
1110+ 53A4 DD 21 A4 5E  	LD IX, PTRGET
1111+ 53A8 CD 59 01     	CALL CALBAS
1112+ 53AB DD 2A 31 62  	LD IX,(BLIT_TMP)
1113+ 53AF DD 73 02         LD (IX+2),E
1114+ 53B2 DD 72 03         LD (IX+3),D
1115+ 53B5              	; comma
1116+ 53B5 CD 45 65     	CALL CHKCHAR
1117+ 53B8 2C           	DB ','
1118+ 53B9              	; get minimum value
1119+ 53B9 DD 21 2F 54  	LD IX, FRMQNT
1120+ 53BD CD 59 01     	CALL CALBAS
1121+ 53C0 DD 2A 31 62  	LD IX,(BLIT_TMP)
1122+ 53C4 DD 73 04         LD (IX+4),E
1123+ 53C7 DD 72 05         LD (IX+5),D
1124+ 53CA              	; comma
1125+ 53CA CD 45 65     	CALL CHKCHAR
1126+ 53CD 2C           	DB ','
1127+ 53CE              	; get maximum value
1128+ 53CE DD 21 2F 54  	LD IX, FRMQNT
1129+ 53D2 CD 59 01     	CALL CALBAS
1130+ 53D5 DD 2A 31 62  	LD IX,(BLIT_TMP)
1131+ 53D9 DD 73 06         LD (IX+6),E
1132+ 53DC DD 72 07         LD (IX+7),D
1133+ 53DF              	; comma
1134+ 53DF CD 45 65     	CALL CHKCHAR
1135+ 53E2 2C           	DB ','
1136+ 53E3              	; get delta value
1137+ 53E3 DD 21 2F 54  	LD IX, FRMQNT
1138+ 53E7 CD 59 01     	CALL CALBAS
1139+ 53EA DD 2A 31 62  	LD IX,(BLIT_TMP)
1140+ 53EE DD 73 08         LD (IX+8),E
1141+ 53F1 DD 72 09         LD (IX+9),D
1142+ 53F4              	; comma
1143+ 53F4 CD 45 65     	CALL CHKCHAR
1144+ 53F7 2C           	DB ','
1145+ 53F8              	; get direction value
1146+ 53F8 DD 21 2F 54  	LD IX, FRMQNT
1147+ 53FC CD 59 01     	CALL CALBAS
1148+ 53FF DD 2A 31 62  	LD IX,(BLIT_TMP)
1149+ 5403 DD 73 0A         LD (IX+10),E
1150+ 5406              	; comma
1151+ 5406 CD 45 65     	CALL CHKCHAR
1152+ 5409 2C           	DB ','
1153+ 540A              	; get ticks value
1154+ 540A DD 21 2F 54  	LD IX, FRMQNT
1155+ 540E CD 59 01     	CALL CALBAS
1156+ 5411 DD 2A 31 62  	LD IX,(BLIT_TMP)
1157+ 5415 DD 73 14         LD (IX+20),E
1158+ 5418 DD 72 15         LD (IX+21),D
1159+ 541B              	; comma
1160+ 541B CD 45 65     	CALL CHKCHAR
1161+ 541E 2C           	DB ','
1162+ 541F              	; get sprite group count
1163+ 541F DD 21 1C 52  	LD IX, GETBYT
1164+ 5423 CD 59 01     	CALL CALBAS
1165+ 5426 B7               OR A
1166+ 5427 CA 5D 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
1167+ 542A DD 2A 31 62  	LD IX,(BLIT_TMP)
1168+ 542E DD 77 0B         LD (IX+11),A
1169+ 5431              	; comma
1170+ 5431 CD 45 65     	CALL CHKCHAR
1171+ 5434 2C           	DB ','
1172+ 5435              	; get sprite group definition array data pointer
1173+ 5435 DD 2A 31 62  	LD IX,(BLIT_TMP)
1174+ 5439 DD 5E 0B         LD E,(IX+11)
1175+ 543C 16 03        	LD D,3
1176+ 543E 3E 02        	LD A,2
1177+ 5440 47           	LD B,A
1178+ 5441 CD 72 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
1179+ 5444 DD 2A 31 62  	LD IX,(BLIT_TMP)
1180+ 5448 DD 71 0C     	LD (IX+12),C
1181+ 544B DD 70 0D         LD (IX+13),B
1182+ 544E              	; comma
1183+ 544E CD 45 65     	CALL CHKCHAR
1184+ 5451 2C           	DB ','
1185+ 5452              	; get sprite animation array size
1186+ 5452 DD 21 1C 52  	LD IX,GETBYT
1187+ 5456 CD 59 01     	CALL CALBAS
1188+ 5459 DD 2A 31 62  	LD IX,(BLIT_TMP)
1189+ 545D DD 77 0E         LD (IX+14),A
1190+ 5460 B7               OR A
1191+ 5461 CA 5D 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
1192+ 5464              	; comma
1193+ 5464 CD 45 65     	CALL CHKCHAR
1194+ 5467 2C           	DB ','
1195+ 5468                  ; get array pointer for negative direction
1196+ 5468 DD 2A 31 62  	LD IX,(BLIT_TMP)
1197+ 546C DD 56 0E         LD D,(IX+14)
1198+ 546F 3E 02            LD A,2
1199+ 5471 06 01            LD B,1
1200+ 5473 CD 72 65         CALL GET_BASIC_ARRAY_DATA_POINTER
1201+ 5476 DD 2A 31 62  	LD IX,(BLIT_TMP)
1202+ 547A DD 71 0F         LD (IX+15),C
1203+ 547D DD 70 10         LD (IX+16),B
1204+ 5480              	; comma
1205+ 5480 CD 45 65     	CALL CHKCHAR
1206+ 5483 2C           	DB ','
1207+ 5484                  ; get array pointer for positive direction
1208+ 5484 DD 2A 31 62  	LD IX,(BLIT_TMP)
1209+ 5488 DD 56 0E         LD D,(IX+14)
1210+ 548B 3E 02            LD A,2
1211+ 548D 06 01            LD B,1
1212+ 548F CD 72 65         CALL GET_BASIC_ARRAY_DATA_POINTER
1213+ 5492 DD 2A 31 62  	LD IX,(BLIT_TMP)
1214+ 5496 DD 71 11         LD (IX+17),C
1215+ 5499 DD 70 12         LD (IX+18),B
1216+ 549C              	; ending )
1217+ 549C CD 45 65     	CALL CHKCHAR
1218+ 549F 29           	DB ')'
1219+ 54A0 C9               RET
1220+ 54A1              ; *******************************************************************************************************
1221+ 54A1               ENDIF
1222+ 54A1
1223+ 54A1               IF (0 == 1)
1224+ 54A1 ~            ; *******************************************************************************************************
1225+ 54A1 ~            ; same as AUTOSGAMDEF but for DEFUSR approach
1226+ 54A1 ~            ; input IX=pointer to input array, real data from +2
1227+ 54A1 ~            ; +02 = ID
1228+ 54A1 ~            ; +04 = pointer to X variable
1229+ 54A1 ~            ; +06 = pointer to Y variable
1230+ 54A1 ~            ; +08 = minimum
1231+ 54A1 ~            ; +10 = maximum
1232+ 54A1 ~            ; +12 = delta
1233+ 54A1 ~            ; +14 = direction
1234+ 54A1 ~            ; +16 = ticks
1235+ 54A1 ~            ; +18 = sprite group count
1236+ 54A1 ~            ; +20 = sprite group array pointer
1237+ 54A1 ~            ; +22 = item number
1238+ 54A1 ~            ; +24 = sprite animations negative direction array pointer
1239+ 54A1 ~            ; +26 = sprite animations positive direction array pointer
1240+ 54A1 ~            AUTOSGAMDEF_DEFUSR:
1241+ 54A1 ~                LD C,(IX+2)
1242+ 54A1 ~                INC C
1243+ 54A1 ~                LD A,(AUTOSGAMNUM)
1244+ 54A1 ~                CP C
1245+ 54A1 ~                RET C ; invalid id
1246+ 54A1 ~                LD A,C
1247+ 54A1 ~                DEC A
1248+ 54A1 ~                CALL GETnthAUTOSGAM
1249+ 54A1 ~                PUSH HL
1250+ 54A1 ~                POP IY
1251+ 54A1 ~                ; X variable
1252+ 54A1 ~                LD A,(IX+4)
1253+ 54A1 ~                LD (IY+0),A
1254+ 54A1 ~                LD A,(IX+5)
1255+ 54A1 ~                LD (IY+1),A
1256+ 54A1 ~            	; Y variable
1257+ 54A1 ~                LD A,(IX+6)
1258+ 54A1 ~                LD (IY+2),A
1259+ 54A1 ~                LD A,(IX+7)
1260+ 54A1 ~                LD (IY+3),A
1261+ 54A1 ~            	; get minimum value
1262+ 54A1 ~                LD A,(IX+8)
1263+ 54A1 ~                LD (IY+4),A
1264+ 54A1 ~                LD A,(IX+9)
1265+ 54A1 ~                LD (IY+5),A
1266+ 54A1 ~            	; get maximum value
1267+ 54A1 ~                LD A,(IX+10)
1268+ 54A1 ~                LD (IY+6),A
1269+ 54A1 ~                LD A,(IX+11)
1270+ 54A1 ~                LD (IY+7),A
1271+ 54A1 ~            	; get delta value
1272+ 54A1 ~                LD A,(IX+12)
1273+ 54A1 ~                LD (IY+8),A
1274+ 54A1 ~                LD A,(IX+13)
1275+ 54A1 ~                LD (IY+9),A
1276+ 54A1 ~            	; get direction value
1277+ 54A1 ~                LD A,(IX+14)
1278+ 54A1 ~                LD (IY+10),A
1279+ 54A1 ~            	; get ticks value
1280+ 54A1 ~                LD A,(IX+16)
1281+ 54A1 ~                LD (IY+20),A
1282+ 54A1 ~                LD A,(IX+17)
1283+ 54A1 ~                LD (IY+21),A
1284+ 54A1 ~            	; get sprite group count
1285+ 54A1 ~                LD A,(IX+18)
1286+ 54A1 ~                LD (IY+11),A
1287+ 54A1 ~            	; get sprite group definition array data pointer
1288+ 54A1 ~                LD A,(IX+20)
1289+ 54A1 ~                LD (IY+12),A
1290+ 54A1 ~                LD A,(IX+21)
1291+ 54A1 ~                LD (IY+13),A
1292+ 54A1 ~            	; get sprite animation array size
1293+ 54A1 ~                LD A,(IX+22)
1294+ 54A1 ~                LD (IY+14),A
1295+ 54A1 ~                ; get array pointer for negative direction
1296+ 54A1 ~                LD A,(IX+24)
1297+ 54A1 ~                LD (IY+15),A
1298+ 54A1 ~                LD A,(IX+25)
1299+ 54A1 ~                LD (IY+16),A
1300+ 54A1 ~                ; get array pointer for positive direction
1301+ 54A1 ~                LD A,(IX+26)
1302+ 54A1 ~                LD (IY+17),A
1303+ 54A1 ~                LD A,(IX+27)
1304+ 54A1 ~                LD (IY+18),A
1305+ 54A1 ~                RET
1306+ 54A1 ~            ; *******************************************************************************************************
1307+ 54A1               ENDIF
1308+ 54A1
1309+ 54A1               IF (1 == 1)
1310+ 54A1              ; *******************************************************************************************************
1311+ 54A1              ; function to handle CALL AUTOSGAMSTART basic extension
1312+ 54A1              ; AUTOSGAMSTART ( BYTE id )
1313+ 54A1              AUTOSGAMSTART:
1314+ 54A1 3E 01            LD A,1
1315+ 54A3              .COMMON:
1316+ 54A3 32 CF 54         LD (.SETVALUE+3),A
1317+ 54A6                  ; opening (
1318+ 54A6 CD 45 65     	CALL CHKCHAR
1319+ 54A9 28           	DB '('
1320+ 54AA              	; get sprite animation id
1321+ 54AA DD 21 1C 52  	LD IX, GETBYT
1322+ 54AE CD 59 01     	CALL CALBAS
1323+ 54B1 F5               PUSH AF
1324+ 54B2 3C               INC A
1325+ 54B3 4F               LD C,A
1326+ 54B4 3A 63 4F         LD A,(AUTOSGAMNUM)
1327+ 54B7 B9               CP C
1328+ 54B8 DA 5D 65         JP C,SUBSCRIPT_OUT_OF_RANGE
1329+ 54BB F1               POP AF
1330+ 54BC E5               PUSH HL
1331+ 54BD CD 90 4F         CALL GETnthAUTOSGAM
1332+ 54C0 E5               PUSH HL
1333+ 54C1 DD E1            POP IX
1334+ 54C3 E1               POP HL
1335+ 54C4 DD E5            PUSH IX
1336+ 54C6              	; ending )
1337+ 54C6 CD 45 65     	CALL CHKCHAR
1338+ 54C9 29           	DB ')'
1339+ 54CA
1340+ 54CA                  ; so syntax is fine
1341+ 54CA DD E1            POP IX
1342+ 54CC              .SETVALUE:
1343+ 54CC DD 36 13 01      LD (IX+19),1 ; active flag
1344+ 54D0                  ; set initial timer
1345+ 54D0 DD 7E 14         LD A,(IX+20)
1346+ 54D3 DD 77 16         LD (IX+22),A
1347+ 54D6 DD 7E 15         LD A,(IX+21)
1348+ 54D9 DD 77 17         LD (IX+23),A
1349+ 54DC C9               RET
1350+ 54DD              ; *******************************************************************************************************
1351+ 54DD
1352+ 54DD              ; *******************************************************************************************************
1353+ 54DD              ; function to handle CALL AUTOSGAMSTOP basic extension
1354+ 54DD              ; AUTOSGAMSTOP ( BYTE id )
1355+ 54DD              AUTOSGAMSTOP:
1356+ 54DD AF               XOR A
1357+ 54DE 18 C3            JR AUTOSGAMSTART.COMMON
1358+ 54E0              ; *******************************************************************************************************
1359+ 54E0               ENDIF
1360+ 54E0
1361+ 54E0               IF (0 == 1)
1362+ 54E0 ~            ; *******************************************************************************************************
1363+ 54E0 ~            ; function to handle CALL AUTOSGAMSTART basic extension in DEFUSR mode
1364+ 54E0 ~            ; input IX=pointer to input array, real data from +2
1365+ 54E0 ~            ; +2 = source address
1366+ 54E0 ~            AUTOSGAMSTART_DEFUSR:
1367+ 54E0 ~                LD A,1
1368+ 54E0 ~            .COMMON:
1369+ 54E0 ~                LD (.SETVALUE+3),A
1370+ 54E0 ~                LD C,(IX+2)
1371+ 54E0 ~                INC C
1372+ 54E0 ~                LD A,(AUTOSGAMNUM)
1373+ 54E0 ~                CP C
1374+ 54E0 ~                RET C ; invalid id
1375+ 54E0 ~                LD A,C
1376+ 54E0 ~                DEC A
1377+ 54E0 ~                CALL GETnthAUTOSGAM
1378+ 54E0 ~                PUSH HL
1379+ 54E0 ~                POP IX
1380+ 54E0 ~            .SETVALUE:
1381+ 54E0 ~                LD (IX+19),1 ; active flag
1382+ 54E0 ~                ; set initial timer
1383+ 54E0 ~                LD A,(IX+20)
1384+ 54E0 ~                LD (IX+22),A
1385+ 54E0 ~                LD A,(IX+21)
1386+ 54E0 ~                LD (IX+23),A
1387+ 54E0 ~                RET
1388+ 54E0 ~            ; *******************************************************************************************************
1389+ 54E0 ~
1390+ 54E0 ~            ; *******************************************************************************************************
1391+ 54E0 ~            ; function to handle CALL AUTOSGAMSTOP basic extension in DEFUSR mode
1392+ 54E0 ~            ; input IX=pointer to input array, real data from +2
1393+ 54E0 ~            ; +2 = source address
1394+ 54E0 ~            AUTOSGAMSTOP_DEFUSR:
1395+ 54E0 ~                XOR A
1396+ 54E0 ~                JR AUTOSGAMSTART_DEFUSR.COMMON
1397+ 54E0 ~            ; *******************************************************************************************************
1398+ 54E0               ENDIF
1399+ 54E0
1400+ 54E0               IF (1 == 1)
1401+ 54E0              ; *******************************************************************************************************
1402+ 54E0              ; function to handle CALL ANIMSTEP basic extension
1403+ 54E0              ; two forms
1404+ 54E0              ; ANIMSTEP ( BYTE id )
1405+ 54E0              ; or
1406+ 54E0              ; ANIMSTEP ( BYTE item_number,
1407+ 54E0              ;            INT[] sprite_animations )
1408+ 54E0              ANIMSTEP:
1409+ 54E0 11 5F 55         LD DE,ANIMSTARTSTOP_COMMON.STEP
1410+ 54E3 18 08            JR ANIMSTARTSTOP_COMMON
1411+ 54E5              ; *******************************************************************************************************
1412+ 54E5              ; *******************************************************************************************************
1413+ 54E5              ; function to handle CALL ANIMSTART basic extension
1414+ 54E5              ; two forms
1415+ 54E5              ; ANIMSTART ( BYTE id )
1416+ 54E5              ; or
1417+ 54E5              ; ANIMSTART ( BYTE item_number,
1418+ 54E5              ;             INT[] sprite_animations )
1419+ 54E5              ; sets active flag to 1
1420+ 54E5              ANIMSTART:
1421+ 54E5 11 4D 55         LD DE,ANIMSTARTSTOP_COMMON.START
1422+ 54E8 18 03            JR ANIMSTARTSTOP_COMMON
1423+ 54EA              ; *******************************************************************************************************
1424+ 54EA              ; *******************************************************************************************************
1425+ 54EA              ; function to handle CALL ANIMSTOP basic extension
1426+ 54EA              ; two forms
1427+ 54EA              ; ANIMSTOP ( BYTE id )
1428+ 54EA              ; or
1429+ 54EA              ; ANIMSTOP ( BYTE item_number,
1430+ 54EA              ;            INT[] sprite_animations )
1431+ 54EA              ; sets active flag to 0
1432+ 54EA              ANIMSTOP:
1433+ 54EA 11 5A 55         LD DE,ANIMSTARTSTOP_COMMON.STOP
1434+ 54ED              ; *******************************************************************************************************
1435+ 54ED              ANIMSTARTSTOP_COMMON:
1436+ 54ED ED 53 4B 55      LD (ANIMSTARTSTOP_COMMON.FN+1),DE
1437+ 54F1                  ; opening (
1438+ 54F1 CD 45 65     	CALL CHKCHAR
1439+ 54F4 28           	DB '('
1440+ 54F5              	; get sprite animation id or array size
1441+ 54F5 DD 21 1C 52  	LD IX,GETBYT
1442+ 54F9 CD 59 01     	CALL CALBAS
1443+ 54FC F5               PUSH AF
1444+ 54FD                  ; check if comma present
1445+ 54FD CD 4F 65         CALL GETPREVCHAR
1446+ 5500 23               INC HL
1447+ 5501 FE 2C            CP ','
1448+ 5503 28 0E            JR Z,.L1
1449+ 5505 FE 29            CP ')'
1450+ 5507 C2 69 65         JP NZ,SYNTAX_ERROR
1451+ 550A                  ; ok so single argument variant
1452+ 550A F1               POP AF
1453+ 550B E5               PUSH HL
1454+ 550C F3               DI
1455+ 550D CD 39 55         CALL .SETVALUE
1456+ 5510 FB               EI
1457+ 5511 E1               POP HL
1458+ 5512 C9               RET
1459+ 5513              .L1:
1460+ 5513                  ; get array pointer
1461+ 5513 D1               POP DE
1462+ 5514 D5               PUSH DE
1463+ 5515 3E 02            LD A,2
1464+ 5517 06 01            LD B,1
1465+ 5519 CD 72 65         CALL GET_BASIC_ARRAY_DATA_POINTER
1466+ 551C C5               PUSH BC
1467+ 551D              	; ending )
1468+ 551D CD 45 65     	CALL CHKCHAR
1469+ 5520 29           	DB ')'
1470+ 5521 D1               POP DE ; array pointer
1471+ 5522 C1               POP BC ; number of items
1472+ 5523 78               LD A,B
1473+ 5524 B7               OR A
1474+ 5525 CA 5D 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
1475+ 5528 E5               PUSH HL
1476+ 5529 F3               DI
1477+ 552A              .L2:
1478+ 552A C5               PUSH BC
1479+ 552B 1A               LD A,(DE)
1480+ 552C 13          > INC DE
1480+ 552D 13          > INC DE
1481+ 552E D5               PUSH DE
1482+ 552F CD 39 55         CALL .SETVALUE
1483+ 5532 D1               POP DE
1484+ 5533 C1               POP BC
1485+ 5534 10 F4            DJNZ .L2
1486+ 5536 FB               EI
1487+ 5537 E1               POP HL
1488+ 5538 C9               RET
1489+ 5539
1490+ 5539              .SETVALUE:
1491+ 5539 47               LD B,A
1492+ 553A 3C               INC A
1493+ 553B 4F               LD C,A
1494+ 553C 3A 60 4F         LD A,(ANIMSPRNUM)
1495+ 553F B9               CP C
1496+ 5540 DA 5D 65         JP C,SUBSCRIPT_OUT_OF_RANGE
1497+ 5543 78               LD A,B
1498+ 5544 CD 84 4F         CALL GETnthSPRANIM
1499+ 5547 E5               PUSH HL
1500+ 5548 DD E1            POP IX
1501+ 554A              .FN:
1502+ 554A C3 00 00         JP 0
1503+ 554D              .START:
1504+ 554D DD 36 06 01      LD (IX+6),1 ; active flag
1505+ 5551 DD 36 03 00      LD (IX+3),0 ; current item
1506+ 5555 06 00            LD B,0 ; setup timer
1507+ 5557 C3 F0 55         JP SETUP_ANIM_STEP
1508+ 555A              .STOP:
1509+ 555A DD 36 06 00      LD (IX+6),0 ; active flag
1510+ 555E C9               RET
1511+ 555F              .STEP:
1512+ 555F 06 00            LD B,0
1513+ 5561 C3 94 55         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1514+ 5564              ; *******************************************************************************************************
1515+ 5564               ENDIF
1516+ 5564
1517+ 5564              ; *******************************************************************************************************
1518+ 5564              ; helper function to locate single animation and execute operation
1519+ 5564              ; needs to have jump set to a correct function
1520+ 5564              ; used by SGAM helper routines so always needed
1521+ 5564              ; input A=animation item
1522+ 5564              ANIM_SETVALUE:
1523+ 5564 47               LD B,A
1524+ 5565 3C               INC A
1525+ 5566 4F               LD C,A
1526+ 5567 3A 60 4F         LD A,(ANIMSPRNUM)
1527+ 556A B9               CP C
1528+ 556B D8               RET C ; out of range, so do nothing
1529+ 556C 78               LD A,B
1530+ 556D CD 84 4F         CALL GETnthSPRANIM
1531+ 5570 E5               PUSH HL
1532+ 5571 DD E1            POP IX
1533+ 5573              .FN:
1534+ 5573 C3 00 00         JP 0
1535+ 5576              ; *******************************************************************************************************
1536+ 5576
1537+ 5576               IF (0 == 1)
1538+ 5576 ~            ; *******************************************************************************************************
1539+ 5576 ~            ; helper function to set values of multiple animations
1540+ 5576 ~            ; needs to have jump set to a correct function
1541+ 5576 ~            ; input B=number of animation item
1542+ 5576 ~            ; input DE=animation item array
1543+ 5576 ~            ANIM_LIST_SETVALUE:
1544+ 5576 ~                DI
1545+ 5576 ~                PUSH BC
1546+ 5576 ~                LD A,(DE)
1547+ 5576 ~                .2 INC DE
1548+ 5576 ~                PUSH DE
1549+ 5576 ~                CALL ANIM_SETVALUE
1550+ 5576 ~                POP DE
1551+ 5576 ~                POP BC
1552+ 5576 ~                DJNZ ANIM_LIST_SETVALUE
1553+ 5576 ~                EI
1554+ 5576 ~                RET
1555+ 5576 ~            ; *******************************************************************************************************
1556+ 5576 ~
1557+ 5576 ~            ; *******************************************************************************************************
1558+ 5576 ~            ; function to handle single item ANIMSTEP in DEFUSR mode
1559+ 5576 ~            ; input IX=pointer to input array, real data from +2
1560+ 5576 ~            ; +2 = animation id
1561+ 5576 ~            ANIMSTEP_SINGLE_DEFUSR:
1562+ 5576 ~                LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1563+ 5576 ~            .L1:
1564+ 5576 ~                LD (ANIM_SETVALUE.FN+1),HL
1565+ 5576 ~                LD A,(IX+2)
1566+ 5576 ~                JR ANIM_SETVALUE
1567+ 5576 ~            .STEP:
1568+ 5576 ~                LD B,0
1569+ 5576 ~                JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1570+ 5576 ~            ; *******************************************************************************************************
1571+ 5576 ~
1572+ 5576 ~            ; *******************************************************************************************************
1573+ 5576 ~            ; function to handle multi item ANIMSTEP in DEFUSR mode
1574+ 5576 ~            ; input IX=pointer to input array, real data from +2
1575+ 5576 ~            ; +2 = list size
1576+ 5576 ~            ; +4 = array pointer holding items
1577+ 5576 ~            ANIMSTEP_MULTI_DEFUSR:
1578+ 5576 ~                LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1579+ 5576 ~            .L1:
1580+ 5576 ~                LD (ANIM_SETVALUE.FN+1),HL
1581+ 5576 ~                LD B,(IX+2)
1582+ 5576 ~                LD E,(IX+4)
1583+ 5576 ~                LD D,(IX+5)
1584+ 5576 ~                JR ANIM_LIST_SETVALUE
1585+ 5576 ~            ; *******************************************************************************************************
1586+ 5576 ~
1587+ 5576 ~            ; *******************************************************************************************************
1588+ 5576 ~            ; function to handle single item ANIMSTART in DEFUSR mode
1589+ 5576 ~            ; input IX=pointer to input array, real data from +2
1590+ 5576 ~            ; +2 = animation id
1591+ 5576 ~            ANIMSTART_SINGLE_DEFUSR:
1592+ 5576 ~                LD HL,ANIMSTART_SINGLE_DEFUSR.START
1593+ 5576 ~                JR ANIMSTEP_SINGLE_DEFUSR.L1
1594+ 5576 ~            .START:
1595+ 5576 ~                LD (IX+6),1 ; active flag
1596+ 5576 ~                LD (IX+3),0 ; current item
1597+ 5576 ~                LD B,0 ; setup timer
1598+ 5576 ~                JP SETUP_ANIM_STEP
1599+ 5576 ~            ; *******************************************************************************************************
1600+ 5576 ~
1601+ 5576 ~            ; *******************************************************************************************************
1602+ 5576 ~            ; function to handle multi item ANIMSTART in DEFUSR mode
1603+ 5576 ~            ; input IX=pointer to input array, real data from +2
1604+ 5576 ~            ; +2 = list size
1605+ 5576 ~            ; +4 = array pointer holding items
1606+ 5576 ~            ANIMSTART_MULTI_DEFUSR:
1607+ 5576 ~                LD HL,ANIMSTART_SINGLE_DEFUSR.START
1608+ 5576 ~                JR ANIMSTEP_MULTI_DEFUSR.L1
1609+ 5576 ~            ; *******************************************************************************************************
1610+ 5576 ~
1611+ 5576 ~            ; *******************************************************************************************************
1612+ 5576 ~            ; function to handle single item ANIMSTOP in DEFUSR mode
1613+ 5576 ~            ; input IX=pointer to input array, real data from +2
1614+ 5576 ~            ; +2 = animation id
1615+ 5576 ~            ANIMSTOP_SINGLE_DEFUSR:
1616+ 5576 ~                LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1617+ 5576 ~                JR ANIMSTEP_SINGLE_DEFUSR.L1
1618+ 5576 ~            .STOP:
1619+ 5576 ~                LD (IX+6),0 ; active flag
1620+ 5576 ~                RET
1621+ 5576 ~            ; *******************************************************************************************************
1622+ 5576 ~
1623+ 5576 ~            ; *******************************************************************************************************
1624+ 5576 ~            ; function to handle multi item ANIMSTOP in DEFUSR mode
1625+ 5576 ~            ; input IX=pointer to input array, real data from +2
1626+ 5576 ~            ; +2 = list size
1627+ 5576 ~            ; +4 = array pointer holding items
1628+ 5576 ~            ANIMSTOP_MULTI_DEFUSR:
1629+ 5576 ~                LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1630+ 5576 ~                JR ANIMSTEP_MULTI_DEFUSR.L1
1631+ 5576 ~            ; *******************************************************************************************************
1632+ 5576               ENDIF
1633+ 5576
1634+ 5576              ; *******************************************************************************************************
1635+ 5576              ; function processes animations during vblank period
1636+ 5576              PROCESS_ANIMATIONS:
1637+ 5576 3A 60 4F         LD A,(ANIMSPRNUM)
1638+ 5579 B7               OR A
1639+ 557A C8               RET Z; no animations defined
1640+ 557B 47               LD B,A
1641+ 557C DD 2A 61 4F      LD IX,(ANIMSPRPTR)
1642+ 5580              .L1:
1643+ 5580 C5               PUSH BC
1644+ 5581 06 00            LD B,0 ; normal mode, change on timer expiry only
1645+ 5583 CD 8F 55         CALL PROCESS_SINGLE_ANIMATION
1646+ 5586 11 08 00         LD DE,8
1647+ 5589 DD 19            ADD IX,DE
1648+ 558B C1               POP BC
1649+ 558C 10 F2            DJNZ .L1
1650+ 558E C9               RET
1651+ 558F              ; *******************************************************************************************************
1652+ 558F
1653+ 558F              ; *******************************************************************************************************
1654+ 558F              ; processes single sprite animation
1655+ 558F              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
1656+ 558F              ; on timer expiry goes to next animation item
1657+ 558F              ; input IX=sprite animation pointer
1658+ 558F              ; input B=1 force mode, activate animation action regardless of expired timer
1659+ 558F              PROCESS_SINGLE_ANIMATION:
1660+ 558F DD 7E 06         LD A,(IX+6); active
1661+ 5592 B7               OR A
1662+ 5593 C8               RET Z ; inactive animation
1663+ 5594              .INACTIVE_TOO:
1664+ 5594 DD 6E 01         LD L,(IX+1)
1665+ 5597 DD 66 02         LD H,(IX+2) ; HL=end time
1666+ 559A 2B               DEC HL
1667+ 559B DD 75 01         LD (IX+1),L
1668+ 559E DD 74 02         LD (IX+2),H
1669+ 55A1 7D               LD A,L
1670+ 55A2 B4               OR H
1671+ 55A3 28 06            JR Z,.STEP
1672+ 55A5 05               DEC B
1673+ 55A6 04               INC B
1674+ 55A7 C8               RET Z ; not forced mode, return
1675+ 55A8 C3 F0 55         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
1676+ 55AB              .STEP:
1677+ 55AB 06 00            LD B,0; setup timer
1678+ 55AD DD 34 03         INC (IX+3) ; current animation item
1679+ 55B0 C3 F0 55         JP SETUP_ANIM_STEP
1680+ 55B3              ; *******************************************************************************************************
1681+ 55B3
1682+ 55B3              ; *******************************************************************************************************
1683+ 55B3              ; function will setup sprite animation after current item change
1684+ 55B3              ; input A=current animation definition
1685+ 55B3              ; input IX=pointer to sprite animation
1686+ 55B3              ; input B=1 skip timer setup
1687+ 55B3              ; output IY=pointer to animation item
1688+ 55B3              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
1689+ 55B3              ; basically sets new end time for current animation
1690+ 55B3              INIT_CURRENT_ANIMATION:
1691+ 55B3 CD 78 4F         CALL GETnthANIMDEF
1692+ 55B6 DD 7E 03         LD A,(IX+3) ; current animation item
1693+ 55B9 BE               CP (HL) ; number of animation items in the animation definition
1694+ 55BA 38 0A            JR C,.L3 ; last item not reached
1695+ 55BC                  ; last item reached
1696+ 55BC DD 7E 05         LD A,(IX+5) ; cyclic flag
1697+ 55BF B7               OR A
1698+ 55C0 28 2C            JR Z,.ERROR ; non-cyclic animation
1699+ 55C2                  ; cyclic animation, restart
1700+ 55C2 DD 36 03 00      LD (IX+3),0; current item
1701+ 55C6              .L3:
1702+ 55C6                  ; HL = animation definition
1703+ 55C6 23               INC HL ; skip animation definition size field
1704+ 55C7 16 00            LD D,0
1705+ 55C9 DD 5E 03         LD E,(IX+3); current item
1706+ 55CC 19               ADD HL,DE
1707+ 55CD 4E               LD C,(HL) ; current animation item
1708+ 55CE 0C               INC C
1709+ 55CF 3A 5A 4F         LD A,(ANIMITEMNUM)
1710+ 55D2 B9               CP C
1711+ 55D3 38 19            JR C,.ERROR ; invalid animation item, stop animation
1712+ 55D5 0D               DEC C
1713+ 55D6 79               LD A,C
1714+ 55D7 CD 6F 4F         CALL GETnthANIMITEM
1715+ 55DA E5               PUSH HL
1716+ 55DB FD E1            POP IY ; IY=animation item
1717+ 55DD 05               DEC B
1718+ 55DE 28 0C            JR Z,.EXIT
1719+ 55E0 FD 5E 01         LD E,(IY+1)
1720+ 55E3 FD 56 02         LD D,(IY+2) ; duration
1721+ 55E6 DD 73 01         LD (IX+1),E
1722+ 55E9 DD 72 02         LD (IX+2),D
1723+ 55EC              .EXIT:
1724+ 55EC AF               XOR A
1725+ 55ED C9               RET
1726+ 55EE              .ERROR:
1727+ 55EE 37               SCF
1728+ 55EF C9               RET
1729+ 55F0              ; *******************************************************************************************************
1730+ 55F0
1731+ 55F0              ; *******************************************************************************************************
1732+ 55F0              ; function will display currect item and set up expiry time
1733+ 55F0              ; it will also stop the animation if expired
1734+ 55F0              ; sets sprite update flag if any changes in sprite data made
1735+ 55F0              ; input IX=current sprite animation
1736+ 55F0              ; input B=1 skip timer setup
1737+ 55F0              SETUP_ANIM_STEP:
1738+ 55F0 DD 4E 04         LD C,(IX+4) ; animation definition ID
1739+ 55F3 0C               INC C
1740+ 55F4 3A 5D 4F         LD A,(ANIMDEFNUM)
1741+ 55F7 B9               CP C
1742+ 55F8 30 05            JR NC,.L2
1743+ 55FA                  ; given animation item is outside of bounds, deactivate animation
1744+ 55FA              .STOPANIM:
1745+ 55FA DD 36 06 00      LD (IX+6),0
1746+ 55FE C9               RET
1747+ 55FF              .L2:
1748+ 55FF 0D               DEC C
1749+ 5600 79               LD A,C
1750+ 5601 CD B3 55         CALL INIT_CURRENT_ANIMATION
1751+ 5604 38 F4            JR C, .STOPANIM
1752+ 5606 FD 7E 00         LD A,(IY) ; type of animation item
1753+ 5609 B7               OR A
1754+ 560A 28 44            JR Z,.L4 ; change pattern and/or color
1755+ 560C              .PAT:
1756+ 560C                  ; change pattern definition
1757+ 560C                  ; check if sprite or character
1758+ 560C DD 7E 07         LD A,(IX+7)
1759+ 560F B7               OR A
1760+ 5610 20 58            JR NZ,.CHAR
1761+ 5612 DD 7E 00         LD A,(IX) ; sprite number
1762+ 5615 CD 89 4D         CALL GETnthSPRATTR
1763+ 5618 23          > INC HL ; skip y and x
1763+ 5619 23          > INC HL
1763+ 561A 23          > INC HL
1763+ 561B 23          > INC HL
1764+ 561C 7E               LD A,(HL); current pattern
1765+ 561D 26 00            LD H,0
1766+ 561F 6F               LD L,A
1767+ 5620 3A E0 F3         LD A,(REG1SAV)
1768+ 5623 E6 02            AND 2
1769+ 5625 20 07            JR NZ,.L6
1770+ 5627                  ; 8x8 sprite
1771+ 5627 CD 32 64         CALL HLx8
1772+ 562A 06 08            LD B,8
1773+ 562C 18 05            JR .L5
1774+ 562E              .L6:
1775+ 562E CD 30 64         CALL HLx32
1776+ 5631 06 20            LD B,32
1777+ 5633              .L5:
1778+ 5633 3A AF FC         LD A,(SCRMOD)
1779+ 5636 3D               DEC A
1780+ 5637 20 06            JR NZ,.L10
1781+ 5639 ED 5B C5 F3      LD DE,(T32PAT)
1782+ 563D 18 04            JR .L7
1783+ 563F              .L10:
1784+ 563F ED 5B CF F3      LD DE,(GRPPAT)
1785+ 5643              .L7:
1786+ 5643 19               ADD HL,DE
1787+ 5644 CD 1D 64         CALL SETWRT_LOCAL
1788+ 5647 FD 6E 03         LD L,(IY+3)
1789+ 564A FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
1790+ 564D C3 28 64         JP BBYTECOPY
1791+ 5650              .L4:
1792+ 5650                  ; change pattern and color in sprite attributes table
1793+ 5650 DD 7E 00         LD A,(IX) ; sprite number
1794+ 5653 CD 89 4D         CALL GETnthSPRATTR
1795+ 5656 23          > INC HL ; skip y and x
1795+ 5657 23          > INC HL
1795+ 5658 23          > INC HL
1795+ 5659 23          > INC HL
1796+ 565A FD 7E 03         LD A,(IY+3) ; new pattern
1797+ 565D 77               LD (HL),A
1798+ 565E 23          > INC HL
1798+ 565F 23          > INC HL
1799+ 5660 FD 7E 04         LD A,(IY+4) ; new color
1800+ 5663 77               LD (HL),A
1801+ 5664 2A 80 4D         LD HL,(SPRATR_UPDATE_FLAG)
1802+ 5667 36 01            LD (HL),1
1803+ 5669 C9               RET
1804+ 566A              .CHAR:
1805+ 566A DD 6E 00         LD L,(IX)
1806+ 566D 3D               DEC A
1807+ 566E 67               LD H,A
1808+ 566F CD 32 64         CALL HLx8
1809+ 5672 3A AF FC         LD A,(SCRMOD)
1810+ 5675 3D               DEC A
1811+ 5676 20 06            JR NZ,.L8
1812+ 5678 ED 5B C1 F3      LD DE,(T32CGP)
1813+ 567C 18 04            JR .L9
1814+ 567E              .L8:
1815+ 567E ED 5B CB F3      LD DE,(GRPCGP)
1816+ 5682              .L9:
1817+ 5682 06 08            LD B,8
1818+ 5684 18 BD            JR .L7
1819+ 5686              ; *******************************************************************************************************
1820+ 5686
# file closed: asm\ANIMATION.asm
 132  5686               INCLUDE "SGAM.asm"
# file opened: asm\SGAM.asm
   1+ 5686              ; Sprite Group Animate and Move
   2+ 5686
   3+ 5686              ; *******************************************************************************************************
   4+ 5686              ; shared function to process a list of animations
   5+ 5686              ; input B=list size
   6+ 5686              ; input DE=list pointer
   7+ 5686              SGAM_PROCESS_ANIM_LIST:
   8+ 5686 21 99 56         LD HL,.STEP
   9+ 5689 22 74 55         LD (ANIM_SETVALUE.FN+1),HL
  10+ 568C              .L1:
  11+ 568C C5               PUSH BC
  12+ 568D 1A               LD A,(DE)
  13+ 568E 13          > INC DE
  13+ 568F 13          > INC DE
  14+ 5690 D5               PUSH DE
  15+ 5691 CD 64 55         CALL ANIM_SETVALUE
  16+ 5694 D1               POP DE
  17+ 5695 C1               POP BC
  18+ 5696 10 F4            DJNZ .L1
  19+ 5698 C9           	RET
  20+ 5699              .STEP:
  21+ 5699 06 01            LD B,1
  22+ 569B C3 94 55         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
  23+ 569E              ; *******************************************************************************************************
  24+ 569E
  25+ 569E               IF (1 == 1)
  26+ 569E              ; *******************************************************************************************************
  27+ 569E              ; function to handle CALL SGAM basic extension
  28+ 569E              ; sets position of a group of sprites as described in SPRGRPMOV
  29+ 569E              ; and manually animate a list of animations
  30+ 569E              ; _SGAM ( INT x,
  31+ 569E              ;	      INT y,
  32+ 569E              ;		  BYTE count,
  33+ 569E              ;		  INT[2][count] data_ptr,
  34+ 569E              ;         BYTE item_number,
  35+ 569E              ;         INT[] sprite_animations )
  36+ 569E              ; will put ram in page 0 also, page 1 is already there
  37+ 569E              SGAM:
  38+ 569E 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
  39+ 56A1 B7           	OR A
  40+ 56A2 CA 65 65     	JP Z,ILLEGAL_FUNCTION
  41+ 56A5              	; opening (
  42+ 56A5 CD 45 65     	CALL CHKCHAR
  43+ 56A8 28           	DB '('
  44+ 56A9              	; get x
  45+ 56A9 DD 21 2F 54  	LD IX, FRMQNT
  46+ 56AD CD 59 01     	CALL CALBAS
  47+ 56B0 ED 53 35 62  	LD (BLIT_STRUCT),DE
  48+ 56B4              	; comma
  49+ 56B4 CD 45 65     	CALL CHKCHAR
  50+ 56B7 2C           	DB ','
  51+ 56B8              	; get y
  52+ 56B8 DD 21 2F 54  	LD IX, FRMQNT
  53+ 56BC CD 59 01     	CALL CALBAS
  54+ 56BF ED 53 37 62  	LD (BLIT_STRUCT+2),DE
  55+ 56C3              	; comma
  56+ 56C3 CD 45 65     	CALL CHKCHAR
  57+ 56C6 2C           	DB ','
  58+ 56C7              	; get count
  59+ 56C7 DD 21 1C 52  	LD IX, GETBYT
  60+ 56CB CD 59 01     	CALL CALBAS
  61+ 56CE B7               OR A
  62+ 56CF CA 5D 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
  63+ 56D2 32 39 62     	LD (BLIT_STRUCT+4),A
  64+ 56D5              	; comma
  65+ 56D5 CD 45 65     	CALL CHKCHAR
  66+ 56D8 2C           	DB ','
  67+ 56D9              	; get sprite group definition array data pointer
  68+ 56D9 3A 39 62         LD A,(BLIT_STRUCT+4)
  69+ 56DC 5F           	LD E,A
  70+ 56DD 16 03        	LD D,3
  71+ 56DF 3E 02        	LD A,2
  72+ 56E1 47           	LD B,A
  73+ 56E2 CD 72 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
  74+ 56E5 ED 43 3A 62  	LD (BLIT_STRUCT+5),BC
  75+ 56E9              	; comma
  76+ 56E9 CD 45 65     	CALL CHKCHAR
  77+ 56EC 2C           	DB ','
  78+ 56ED              	; get sprite animation array size
  79+ 56ED DD 21 1C 52  	LD IX,GETBYT
  80+ 56F1 CD 59 01     	CALL CALBAS
  81+ 56F4 32 3C 62         LD (BLIT_STRUCT+7),A
  82+ 56F7 B7               OR A
  83+ 56F8 CA 5D 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
  84+ 56FB              	; comma
  85+ 56FB CD 45 65     	CALL CHKCHAR
  86+ 56FE 2C           	DB ','
  87+ 56FF                  ; get array pointer
  88+ 56FF 3A 3C 62         LD A,(BLIT_STRUCT+7)
  89+ 5702 57               LD D,A
  90+ 5703 3E 02            LD A,2
  91+ 5705 06 01            LD B,1
  92+ 5707 CD 72 65         CALL GET_BASIC_ARRAY_DATA_POINTER
  93+ 570A ED 43 3D 62      LD (BLIT_STRUCT+8),BC
  94+ 570E              	; ending )
  95+ 570E CD 45 65     	CALL CHKCHAR
  96+ 5711 29           	DB ')'
  97+ 5712              .ENTRY:
  98+ 5712 E5               PUSH HL
  99+ 5713
 100+ 5713              	; enable page 0
 101+ 5713 FD 21 1A 57  	LD IY, .RET
 102+ 5717 C3 F6 64     	JP ENABLE_PAGE0
 103+ 571A              .RET:
 104+ 571A D9               EXX
 105+ 571B ED 5B 35 62      LD DE,(BLIT_STRUCT) ; initial x
 106+ 571F ED 4B 37 62      LD BC,(BLIT_STRUCT+2) ; initial y
 107+ 5723 D9               EXX
 108+ 5724 2A 3A 62         LD HL,(BLIT_STRUCT+5) ; pointer to data
 109+ 5727 3A 39 62         LD A,(BLIT_STRUCT+4) ; number of entries
 110+ 572A 47               LD B,A
 111+ 572B CD DD 4E         CALL SPR_UPDATE_LOC
 112+ 572E
 113+ 572E 3A 3C 62         LD A,(BLIT_STRUCT+7) ; anim number
 114+ 5731 47               LD B,A
 115+ 5732 ED 5B 3D 62      LD DE,(BLIT_STRUCT+8) ; anim list
 116+ 5736 CD 86 56     	CALL SGAM_PROCESS_ANIM_LIST
 117+ 5739
 118+ 5739 D1               POP DE
 119+ 573A C1               POP BC
 120+ 573B CD 6D 64         CALL RESTORE_PAGE_INFO
 121+ 573E FB               EI
 122+ 573F E1               POP HL
 123+ 5740 C9               RET
 124+ 5741              ; *******************************************************************************************************
 125+ 5741               ENDIF
 126+ 5741
 127+ 5741               IF (0 == 1)
 128+ 5741 ~            ; *******************************************************************************************************
 129+ 5741 ~            ; same as SGAM but for DEFUSR approach
 130+ 5741 ~            ; input IX=pointer to input array, real data from +2
 131+ 5741 ~            ; +02 = X
 132+ 5741 ~            ; +04 = Y
 133+ 5741 ~            ; +06 = count
 134+ 5741 ~            ; +08 = data pointer
 135+ 5741 ~            ; +10 = anim number
 136+ 5741 ~            ; +12 = sprite animations
 137+ 5741 ~            SGAM_DEFUSR:
 138+ 5741 ~            	; enable page 0
 139+ 5741 ~            	LD IY, .RET
 140+ 5741 ~            	JP ENABLE_PAGE0
 141+ 5741 ~            .RET:
 142+ 5741 ~            	EI
 143+ 5741 ~                EXX
 144+ 5741 ~            	LD E,(IX+2)
 145+ 5741 ~            	LD D,(IX+3) ; initial x
 146+ 5741 ~            	LD C,(IX+4)
 147+ 5741 ~            	LD B,(IX+5) ; initial y
 148+ 5741 ~                EXX
 149+ 5741 ~            	LD L,(IX+8)
 150+ 5741 ~            	LD H,(IX+9) ; pointer to data
 151+ 5741 ~                LD B,(IX+6) ; count
 152+ 5741 ~            	PUSH IX
 153+ 5741 ~                CALL SPR_UPDATE_LOC
 154+ 5741 ~            	POP IX
 155+ 5741 ~                LD B,(IX+10) ; anim number
 156+ 5741 ~            	LD E,(IX+12)
 157+ 5741 ~            	LD D,(IX+13)
 158+ 5741 ~            	CALL SGAM_PROCESS_ANIM_LIST
 159+ 5741 ~
 160+ 5741 ~                POP DE
 161+ 5741 ~                POP BC
 162+ 5741 ~                JP RESTORE_PAGE_INFO
 163+ 5741 ~            ; *******************************************************************************************************
 164+ 5741               ENDIF
 165+ 5741
 166+ 5741              ; *******************************************************************************************************
 167+ 5741              ; handles automatic move and animate sprite groups during interrupt
 168+ 5741              PROCESS_AUTOSGAMS:
 169+ 5741 3A 63 4F     	LD A,(AUTOSGAMNUM)
 170+ 5744 B7           	OR A
 171+ 5745 C8           	RET Z
 172+ 5746 47           	LD B,A
 173+ 5747 DD 2A 64 4F  	LD IX,(AUTOSGAMPTR)
 174+ 574B              .L1:
 175+ 574B C5           	PUSH BC
 176+ 574C DD 7E 13     	LD A,(IX+19) ; active flag
 177+ 574F B7           	OR A
 178+ 5750 28 28        	JR Z,.LOOPEND
 179+ 5752              	; active, check timer
 180+ 5752 DD 6E 16     	LD L,(IX+22)
 181+ 5755 DD 66 17     	LD H,(IX+23) ; timer
 182+ 5758 2B           	DEC HL
 183+ 5759 7C           	LD A,H
 184+ 575A B5           	OR L
 185+ 575B 28 08        	JR Z,.L2
 186+ 575D              	; not expired
 187+ 575D DD 75 16     	LD (IX+22),L
 188+ 5760 DD 74 17     	LD (IX+23),H
 189+ 5763 18 15        	JR .LOOPEND
 190+ 5765              .L2:
 191+ 5765              	; expired, process
 192+ 5765
 193+ 5765                  ; set initial timer
 194+ 5765 DD 7E 14         LD A,(IX+20)
 195+ 5768 DD 77 16         LD (IX+22),A
 196+ 576B DD 7E 15         LD A,(IX+21)
 197+ 576E DD 77 17         LD (IX+23),A
 198+ 5771
 199+ 5771 CD 83 57     	CALL .MOVE
 200+ 5774 CD EE 57     	CALL .UPDATELOC
 201+ 5777 CD 13 58     	CALL .PROCESS_ANIM_LIST
 202+ 577A
 203+ 577A              .LOOPEND:
 204+ 577A 11 18 00     	LD DE,24
 205+ 577D DD 19        	ADD IX,DE
 206+ 577F C1           	POP BC
 207+ 5780 10 C9        	DJNZ .L1
 208+ 5782 C9           	RET
 209+ 5783
 210+ 5783              .MOVE:
 211+ 5783              	; process movement
 212+ 5783 DD 7E 0A     	LD A,(IX+10) ; direction
 213+ 5786 B7           	OR A
 214+ 5787 28 08        	JR Z, .MOVE_L1
 215+ 5789              	; vertical
 216+ 5789 DD 6E 02     	LD L,(IX+2)
 217+ 578C DD 66 03     	LD H,(IX+3) ; vertical variable pointer
 218+ 578F 18 06        	JR .MOVE_L2
 219+ 5791              .MOVE_L1:
 220+ 5791              	; horizontal
 221+ 5791 DD 6E 00     	LD L,(IX+0)
 222+ 5794 DD 66 01     	LD H,(IX+1) ; horizontal variable pointer
 223+ 5797              .MOVE_L2:
 224+ 5797 E5           	PUSH HL
 225+ 5798 FD E1        	POP IY
 226+ 579A FD 6E 00     	LD L,(IY+0)
 227+ 579D FD 66 01     	LD H,(IY+1)
 228+ 57A0 DD 5E 08     	LD E,(IX+8)
 229+ 57A3 DD 56 09     	LD D,(IX+9) ; delta value
 230+ 57A6 19           	ADD HL,DE
 231+ 57A7 E5           	PUSH HL
 232+ 57A8 DD 5E 04     	LD E,(IX+4)
 233+ 57AB DD 56 05     	LD D,(IX+5) ; minimum value
 234+ 57AE A7           	AND A
 235+ 57AF ED 52        	SBC HL,DE
 236+ 57B1 FA CB 57     	JP M,.MOVE_L3 ; below minimum
 237+ 57B4 E1           	POP HL
 238+ 57B5 E5           	PUSH HL
 239+ 57B6 DD 5E 06     	LD E,(IX+6)
 240+ 57B9 DD 56 07     	LD D,(IX+7) ; maximum value
 241+ 57BC EB           	EX DE,HL
 242+ 57BD A7           	AND A
 243+ 57BE ED 52        	SBC HL,DE
 244+ 57C0 FA D3 57     	JP M,.MOVE_L4 ; above maximum
 245+ 57C3 E1           	POP HL
 246+ 57C4              	; within bounds
 247+ 57C4              .MOVE_L5:
 248+ 57C4 FD 75 00     	LD (IY+0),L
 249+ 57C7 FD 74 01     	LD (IY+1),H
 250+ 57CA C9           	RET
 251+ 57CB              .MOVE_L3:
 252+ 57CB E1           	POP HL
 253+ 57CC CD DF 57     	CALL .INVERSE_DELTA
 254+ 57CF 6B           	LD L,E
 255+ 57D0 62           	LD H,D
 256+ 57D1 18 F1        	JR .MOVE_L5
 257+ 57D3              .MOVE_L4:
 258+ 57D3 E1           	POP HL
 259+ 57D4 CD DF 57     	CALL .INVERSE_DELTA
 260+ 57D7 DD 6E 06     	LD L,(IX+6)
 261+ 57DA DD 66 07     	LD H,(IX+7) ; maximum
 262+ 57DD 18 E5        	JR .MOVE_L5
 263+ 57DF              .INVERSE_DELTA:
 264+ 57DF AF           	XOR A
 265+ 57E0 DD 96 08     	SUB (IX+8)
 266+ 57E3 DD 77 08     	LD (IX+8),A
 267+ 57E6 9F           	SBC A,A
 268+ 57E7 DD 96 09     	SUB (IX+9)
 269+ 57EA DD 77 09     	LD (IX+9),A
 270+ 57ED C9           	RET
 271+ 57EE
 272+ 57EE              .UPDATELOC:
 273+ 57EE DD E5        	PUSH IX
 274+ 57F0 D9           	EXX
 275+ 57F1 DD 6E 00     	LD L,(IX+0)
 276+ 57F4 DD 66 01     	LD H,(IX+1)
 277+ 57F7 5E           	LD E,(HL)
 278+ 57F8 23           	INC HL
 279+ 57F9 56           	LD D,(HL)
 280+ 57FA DD 6E 02     	LD L,(IX+2)
 281+ 57FD DD 66 03     	LD H,(IX+3)
 282+ 5800 4E           	LD C,(HL)
 283+ 5801 23           	INC HL
 284+ 5802 46           	LD B,(HL)
 285+ 5803 D9           	EXX
 286+ 5804 DD 6E 0C     	LD L,(IX+12)
 287+ 5807 DD 66 0D     	LD H,(IX+13) ; pointer to sprite group data
 288+ 580A DD 46 0B     	LD B,(IX+11) ; sprite group size
 289+ 580D CD DD 4E     	CALL SPR_UPDATE_LOC
 290+ 5810 DD E1        	POP IX
 291+ 5812 C9           	RET
 292+ 5813
 293+ 5813              .PROCESS_ANIM_LIST:
 294+ 5813 DD E5        	PUSH IX
 295+ 5815 DD 46 0E         LD B,(IX+14) ; anim list size
 296+ 5818 DD CB 09 7E  	BIT 7,(IX+9)
 297+ 581C 28 08        	JR Z,.PROCESS_ANIM_LIST_L1
 298+ 581E              	; negative direction
 299+ 581E DD 5E 0F     	LD E,(IX+15)
 300+ 5821 DD 56 10     	LD D,(IX+16)
 301+ 5824 18 06        	JR .PROCESS_ANIM_LIST_L2
 302+ 5826              .PROCESS_ANIM_LIST_L1:
 303+ 5826              	; positive direction
 304+ 5826 DD 5E 11     	LD E,(IX+17)
 305+ 5829 DD 56 12     	LD D,(IX+18)
 306+ 582C              .PROCESS_ANIM_LIST_L2:
 307+ 582C CD 86 56     	CALL SGAM_PROCESS_ANIM_LIST
 308+ 582F DD E1        	POP IX
 309+ 5831 C9           	RET
 310+ 5832              ; *******************************************************************************************************
 311+ 5832
# file closed: asm\SGAM.asm
 133  5832               ENDIF
 134  5832
 135  5832               IF (RAM_CMDS == 1)
 136  5832               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
   1+ 5832               IF (1 == 1)
   2+ 5832              ; *******************************************************************************************************
   3+ 5832              ; function to handle CALL MEMCPY basic extension
   4+ 5832              ; _MEMCPY ( INT source,
   5+ 5832              ;			INT destination,
   6+ 5832              ;			INT count,
   7+ 5832              ; will put ram in page 0 also, page 1 is already there
   8+ 5832              MEMCPY:
   9+ 5832              	; opening (
  10+ 5832 CD 45 65     	CALL CHKCHAR
  11+ 5835 28           	DB '('
  12+ 5836              	; get source address
  13+ 5836 DD 21 2F 54  	LD IX, FRMQNT
  14+ 583A CD 59 01     	CALL CALBAS
  15+ 583D D5           	PUSH DE
  16+ 583E              	; comma
  17+ 583E CD 45 65     	CALL CHKCHAR
  18+ 5841 2C           	DB ','
  19+ 5842              	; get destination address
  20+ 5842 DD 21 2F 54  	LD IX, FRMQNT
  21+ 5846 CD 59 01     	CALL CALBAS
  22+ 5849 D5           	PUSH DE
  23+ 584A              	; comma
  24+ 584A CD 45 65     	CALL CHKCHAR
  25+ 584D 2C           	DB ','
  26+ 584E              	; get length
  27+ 584E DD 21 2F 54  	LD IX, FRMQNT
  28+ 5852 CD 59 01     	CALL CALBAS
  29+ 5855 D5           	PUSH DE
  30+ 5856              	; ending )
  31+ 5856 CD 45 65     	CALL CHKCHAR
  32+ 5859 29           	DB ')'
  33+ 585A
  34+ 585A              	; save position
  35+ 585A E5           	PUSH HL
  36+ 585B DD E1        	POP IX
  37+ 585D
  38+ 585D C1           	POP BC ; count
  39+ 585E D1           	POP DE ; destination
  40+ 585F E1           	POP HL ; source
  41+ 5860 D9           	EXX
  42+ 5861              	; enable page 0
  43+ 5861 FD 21 68 58  	LD IY, .RET
  44+ 5865 C3 F6 64     	JP ENABLE_PAGE0
  45+ 5868              .RET:
  46+ 5868 FB           	EI
  47+ 5869 D9           	EXX
  48+ 586A ED B0        	LDIR
  49+ 586C D1               POP DE
  50+ 586D C1               POP BC
  51+ 586E CD 6D 64         CALL RESTORE_PAGE_INFO
  52+ 5871 DD E5        	PUSH IX
  53+ 5873 E1           	POP HL
  54+ 5874 C9           	RET
  55+ 5875              ; *******************************************************************************************************
  56+ 5875               ENDIF
  57+ 5875
  58+ 5875               IF (0 == 1)
  59+ 5875 ~            ; *******************************************************************************************************
  60+ 5875 ~            ; same as MEMCPY but for DEFUSR approach
  61+ 5875 ~            ; input IX=pointer to input array, real data from +2
  62+ 5875 ~            ; +2 = source address
  63+ 5875 ~            ; +4 = destination address
  64+ 5875 ~            ; +6 = lenght
  65+ 5875 ~            MEMCPY_DEFUSR:
  66+ 5875 ~            	; enable page 0
  67+ 5875 ~            	LD IY, .RET
  68+ 5875 ~            	JP ENABLE_PAGE0
  69+ 5875 ~            .RET:
  70+ 5875 ~            	EI
  71+ 5875 ~            	LD L,(IX+2)
  72+ 5875 ~            	LD H,(IX+3)
  73+ 5875 ~            	LD E,(IX+4)
  74+ 5875 ~            	LD D,(IX+5)
  75+ 5875 ~            	LD C,(IX+6)
  76+ 5875 ~            	LD B,(IX+7)
  77+ 5875 ~            	LDIR
  78+ 5875 ~                POP DE
  79+ 5875 ~                POP BC
  80+ 5875 ~                JP RESTORE_PAGE_INFO
  81+ 5875 ~            ; *******************************************************************************************************
  82+ 5875               ENDIF
  83+ 5875
  84+ 5875               IF (1 == 1)
  85+ 5875              ; *******************************************************************************************************
  86+ 5875              ; function to handle CALL FILRAM basic extension
  87+ 5875              ; FILRAM ( INT start address,
  88+ 5875              ;		   INT count,
  89+ 5875              ;		   BYTE value )
  90+ 5875              ; will put ram in page 0 also, page 1 is already there
  91+ 5875              FILRAM:
  92+ 5875              	; opening (
  93+ 5875 CD 45 65     	CALL CHKCHAR
  94+ 5878 28           	DB '('
  95+ 5879              	; get start address
  96+ 5879 DD 21 2F 54  	LD IX, FRMQNT
  97+ 587D CD 59 01     	CALL CALBAS
  98+ 5880 D5           	PUSH DE
  99+ 5881              	; comma
 100+ 5881 CD 45 65     	CALL CHKCHAR
 101+ 5884 2C           	DB ','
 102+ 5885              	; get count
 103+ 5885 DD 21 2F 54  	LD IX, FRMQNT
 104+ 5889 CD 59 01     	CALL CALBAS
 105+ 588C D5           	PUSH DE
 106+ 588D              	; comma
 107+ 588D CD 45 65     	CALL CHKCHAR
 108+ 5890 2C           	DB ','
 109+ 5891              	; get value
 110+ 5891 DD 21 1C 52  	LD IX, GETBYT
 111+ 5895 CD 59 01     	CALL CALBAS
 112+ 5898 F5           	PUSH AF
 113+ 5899              	; ending )
 114+ 5899 CD 45 65     	CALL CHKCHAR
 115+ 589C 29           	DB ')'
 116+ 589D
 117+ 589D              	; save position
 118+ 589D E5           	PUSH HL
 119+ 589E DD E1        	POP IX
 120+ 58A0
 121+ 58A0 D1           	POP DE ; actually AF
 122+ 58A1 C1           	POP BC ; count
 123+ 58A2 E1           	POP HL ; start address
 124+ 58A3 78           	LD A, B
 125+ 58A4 B1           	OR C
 126+ 58A5 28 12        	JR Z, .EXIT ; 0 bytes to fill, skip
 127+ 58A7 D9           	EXX
 128+ 58A8              	; enable page 0
 129+ 58A8 FD 21 AF 58  	LD IY, .RET
 130+ 58AC C3 F6 64     	JP ENABLE_PAGE0
 131+ 58AF              .RET:
 132+ 58AF FB           	EI
 133+ 58B0 D9           	EXX
 134+ 58B1 CD BD 58     	CALL FILVRM_FILLVALUE
 135+ 58B4 D1               POP DE
 136+ 58B5 C1               POP BC
 137+ 58B6 CD 6D 64         CALL RESTORE_PAGE_INFO
 138+ 58B9              .EXIT:
 139+ 58B9 DD E5        	PUSH IX
 140+ 58BB E1           	POP HL
 141+ 58BC C9           	RET
 142+ 58BD              ; *******************************************************************************************************
 143+ 58BD               ENDIF
 144+ 58BD
 145+ 58BD               IF (0 == 1)
 146+ 58BD ~            ; *******************************************************************************************************
 147+ 58BD ~            ; same as FILVRM but for DEFUSR approach
 148+ 58BD ~            ; input IX=pointer to input array, real data from +2
 149+ 58BD ~            ; +2 = start address
 150+ 58BD ~            ; +4 = count
 151+ 58BD ~            ; +6 = value
 152+ 58BD ~            FILRAM_DEFUSR:
 153+ 58BD ~            	; enable page 0
 154+ 58BD ~            	LD IY, .RET
 155+ 58BD ~            	JP ENABLE_PAGE0
 156+ 58BD ~            .RET:
 157+ 58BD ~            	EI
 158+ 58BD ~            	LD L,(IX+2)
 159+ 58BD ~            	LD H,(IX+3)
 160+ 58BD ~            	LD C,(IX+4)
 161+ 58BD ~            	LD B,(IX+5)
 162+ 58BD ~            	LD A,B
 163+ 58BD ~            	OR C
 164+ 58BD ~            	JR Z,.EXIT
 165+ 58BD ~            	LD D,(IX+6)
 166+ 58BD ~            	CALL FILVRM_FILLVALUE
 167+ 58BD ~            .EXIT:
 168+ 58BD ~                POP DE
 169+ 58BD ~                POP BC
 170+ 58BD ~                JP RESTORE_PAGE_INFO
 171+ 58BD ~            ; *******************************************************************************************************
 172+ 58BD               ENDIF
 173+ 58BD
 174+ 58BD              ; *******************************************************************************************************
 175+ 58BD              ; common function to fill RAM
 176+ 58BD              FILVRM_FILLVALUE:
 177+ 58BD 72               LD (HL), D
 178+ 58BE 54               LD D, H
 179+ 58BF 5D               LD E, L
 180+ 58C0 13               INC DE
 181+ 58C1 0B               DEC BC
 182+ 58C2 78           	LD A,B
 183+ 58C3 B1           	OR C
 184+ 58C4 C8           	RET Z ; if count was 1
 185+ 58C5 ED B0            LDIR
 186+ 58C7 C9               RET
 187+ 58C8              ; *******************************************************************************************************
# file closed: asm\MEMORY.asm
 137  58C8               ENDIF
 138  58C8
 139  58C8               IF (SOUND_CMDS == 1)
 140  58C8               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
   1+ 58C8              MUSIC_INIT_STATUS:
   2+ 58C8 00            DB 0
   3+ 58C9              SFX_INIT_STATUS:
   4+ 58C9 00            DB 0
   5+ 58CA              SOUND_ENABLED:
   6+ 58CA 00            DB 0
   7+ 58CB
   8+ 58CB               IF (1 == 1)
   9+ 58CB              ; *******************************************************************************************************
  10+ 58CB              ; function to handle CALL SNDPLYINIT basic extension
  11+ 58CB              ; initializes sound player
  12+ 58CB              ; _SNDPLYINIT ( INT music_offset,
  13+ 58CB              ;				INT sfx_offset, can be -1 if no SFX
  14+ 58CB              ; will put ram in page 0 also, page 1 is already there
  15+ 58CB              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
  16+ 58CB              SNDPLYINIT:
  17+ 58CB              	; opening (
  18+ 58CB CD 45 65     	CALL CHKCHAR
  19+ 58CE 28           	DB '('
  20+ 58CF              	; get music address
  21+ 58CF DD 21 2F 54  	LD IX, FRMQNT
  22+ 58D3 CD 59 01     	CALL CALBAS
  23+ 58D6 D5           	PUSH DE
  24+ 58D7              	; comma
  25+ 58D7 CD 45 65     	CALL CHKCHAR
  26+ 58DA 2C           	DB ','
  27+ 58DB              	; get sfx address
  28+ 58DB DD 21 2F 54  	LD IX, FRMQNT
  29+ 58DF CD 59 01     	CALL CALBAS
  30+ 58E2 D5           	PUSH DE
  31+ 58E3              	; ending )
  32+ 58E3 CD 45 65     	CALL CHKCHAR
  33+ 58E6 29           	DB ')'
  34+ 58E7
  35+ 58E7                  ; save position in BASIC text
  36+ 58E7 44           	LD B, H
  37+ 58E8 4D           	LD C, L
  38+ 58E9
  39+ 58E9              	; pop LDIR parameters and store away for later
  40+ 58E9 D1           	POP DE ; sfx address
  41+ 58EA E1           	POP HL ; music address
  42+ 58EB C5           	PUSH BC ; basic text location
  43+ 58EC D9           	EXX
  44+ 58ED FD 21 F4 58  	LD IY, .RET
  45+ 58F1 C3 F6 64     	JP ENABLE_PAGE0
  46+ 58F4              .RET:
  47+ 58F4 D9           	EXX
  48+ 58F5
  49+ 58F5 D5           	PUSH DE
  50+ 58F6 AF           	XOR A
  51+ 58F7              	; HL = music location
  52+ 58F7 CD 65 41     	CALL PLY_AKG_INIT
  53+ 58FA 3E 01        	LD A, 1
  54+ 58FC 32 C8 58     	LD (MUSIC_INIT_STATUS), A
  55+ 58FF
  56+ 58FF E1           	POP HL ; SFX
  57+ 5900              	; check if SFX address -1
  58+ 5900 23           	INC HL
  59+ 5901 7D           	LD A, L
  60+ 5902 B4           	OR H
  61+ 5903 28 09        	JR Z,.L1
  62+ 5905 2B           	DEC HL
  63+ 5906 CD 20 40     	CALL PLY_AKG_INITSOUNDEFFECTS
  64+ 5909 3E 01        	LD A, 1
  65+ 590B 32 C9 58     	LD (SFX_INIT_STATUS), A
  66+ 590E              .L1:
  67+ 590E D1               POP DE
  68+ 590F C1               POP BC
  69+ 5910 CD 6D 64         CALL RESTORE_PAGE_INFO
  70+ 5913
  71+ 5913 E1           	POP HL
  72+ 5914 C9           	RET
  73+ 5915              ; *******************************************************************************************************
  74+ 5915               ENDIF
  75+ 5915
  76+ 5915               IF (0 == 1)
  77+ 5915 ~            ; *******************************************************************************************************
  78+ 5915 ~            ; same as SNDPLYINI but for DEFUSR approach
  79+ 5915 ~            ; input IX=pointer to input array, real data from +2
  80+ 5915 ~            ; +2 = music address
  81+ 5915 ~            ; +4 = sfx address
  82+ 5915 ~            SNDPLYINI_DEFUSR:
  83+ 5915 ~            	LD IY, .RET
  84+ 5915 ~            	JP ENABLE_PAGE0
  85+ 5915 ~            .RET:
  86+ 5915 ~            	XOR A
  87+ 5915 ~            	LD L,(IX+2)
  88+ 5915 ~            	LD H,(IX+3)
  89+ 5915 ~            	PUSH IX
  90+ 5915 ~            	CALL PLY_AKG_INIT
  91+ 5915 ~            	POP IX
  92+ 5915 ~            	LD A, 1
  93+ 5915 ~            	LD (MUSIC_INIT_STATUS), A
  94+ 5915 ~
  95+ 5915 ~            	LD L,(IX+4)
  96+ 5915 ~            	LD H,(IX+5)
  97+ 5915 ~            	; check if SFX address -1
  98+ 5915 ~            	INC HL
  99+ 5915 ~            	LD A, L
 100+ 5915 ~            	OR H
 101+ 5915 ~            	JR Z,.L1
 102+ 5915 ~            	DEC HL
 103+ 5915 ~            	CALL PLY_AKG_INITSOUNDEFFECTS
 104+ 5915 ~            	LD A, 1
 105+ 5915 ~            	LD (SFX_INIT_STATUS), A
 106+ 5915 ~            .L1:
 107+ 5915 ~                POP DE
 108+ 5915 ~                POP BC
 109+ 5915 ~                JP RESTORE_PAGE_INFO
 110+ 5915 ~            ; *******************************************************************************************************
 111+ 5915               ENDIF
 112+ 5915
 113+ 5915              ; *******************************************************************************************************
 114+ 5915              ; function to handle CALL SNDPLYON basic extension
 115+ 5915              ; enables sound player
 116+ 5915              ; _SNDPLYON
 117+ 5915              ; sets SOUND_ENABLED variable to 1 if init call was done
 118+ 5915              ; if not throws out of data error
 119+ 5915              SNDPLYON_DEFUSR:
 120+ 5915              SNDPLYON:
 121+ 5915 3A C8 58     	LD A, (MUSIC_INIT_STATUS)
 122+ 5918 B7           	OR A
 123+ 5919 20 05        	JR NZ, .L1
 124+ 591B              	; player not initialized, throw error
 125+ 591B 1E 04        	LD E, 04 ; Out of DATA
 126+ 591D C3 6B 65     	JP THROW_ERROR
 127+ 5920              .L1:
 128+ 5920 32 CA 58     	LD (SOUND_ENABLED), A
 129+ 5923              	; disable key click
 130+ 5923 AF           	XOR A
 131+ 5924 32 DB F3     	LD (CLIKSW), A
 132+ 5927 C9           	RET
 133+ 5928              ; *******************************************************************************************************
 134+ 5928
 135+ 5928              ; *******************************************************************************************************
 136+ 5928              ; function to handle CALL SNDPLYOFF basic extension
 137+ 5928              ; disables sound player
 138+ 5928              ; _SNDPLYOFF
 139+ 5928              ; sets SOUND_ENABLED variable to 0
 140+ 5928              ; calls AKG to stop music and SFX on all channels if initialized
 141+ 5928              SNDPLYOFF_DEFUSR:
 142+ 5928              SNDPLYOFF:
 143+ 5928 3A CA 58     	LD A, (SOUND_ENABLED)
 144+ 592B B7           	OR A
 145+ 592C C8           	RET Z ; already stopped
 146+ 592D AF           	XOR A
 147+ 592E 32 CA 58     	LD (SOUND_ENABLED), A
 148+ 5931 E5           	PUSH HL
 149+ 5932 CD 24 42     	CALL PLY_AKG_STOP
 150+ 5935 3A C9 58     	LD A, (SFX_INIT_STATUS)
 151+ 5938 B7           	OR A
 152+ 5939 28 0E        	JR Z, .EXIT ; SFX not in use
 153+ 593B AF           	XOR A
 154+ 593C CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 155+ 593F 3E 01        	LD A, 1
 156+ 5941 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 157+ 5944 3E 02        	LD A, 2
 158+ 5946 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 159+ 5949              .EXIT:
 160+ 5949 E1           	POP HL
 161+ 594A C9           	RET
 162+ 594B              ; *******************************************************************************************************
 163+ 594B
 164+ 594B               IF (1 == 1)
 165+ 594B              ; *******************************************************************************************************
 166+ 594B              ; function to handle CALL SNDSFX basic extension
 167+ 594B              ; plays a sound effect
 168+ 594B              ; _SNDSFX ( BYTE sfx_number, >0
 169+ 594B              ;			BYTE channel, = 0,1 or 2
 170+ 594B              ;			BYTE inverted_volume = 0-16, 0 being full volume
 171+ 594B              ; will put ram in page 0 also, page 1 is already there
 172+ 594B              ; if sound off throws illegal function call
 173+ 594B              ; if sfx not initialized, throws out of data
 174+ 594B              SNDSFX:
 175+ 594B              	; opening (
 176+ 594B CD 45 65     	CALL CHKCHAR
 177+ 594E 28           	DB '('
 178+ 594F              	; get sfx_number
 179+ 594F DD 21 1C 52  	LD IX, GETBYT
 180+ 5953 CD 59 01     	CALL CALBAS
 181+ 5956 D5           	PUSH DE
 182+ 5957              	; comma
 183+ 5957 CD 45 65     	CALL CHKCHAR
 184+ 595A 2C           	DB ','
 185+ 595B              	; get sfx address
 186+ 595B DD 21 1C 52  	LD IX, GETBYT
 187+ 595F CD 59 01     	CALL CALBAS
 188+ 5962 D5           	PUSH DE
 189+ 5963              	; comma
 190+ 5963 CD 45 65     	CALL CHKCHAR
 191+ 5966 2C           	DB ','
 192+ 5967              	; get inverted volume
 193+ 5967 DD 21 1C 52  	LD IX, GETBYT
 194+ 596B CD 59 01     	CALL CALBAS
 195+ 596E D5           	PUSH DE
 196+ 596F              	; ending )
 197+ 596F CD 45 65     	CALL CHKCHAR
 198+ 5972 29           	DB ')'
 199+ 5973
 200+ 5973 3A CA 58     	LD A, (SOUND_ENABLED)
 201+ 5976 B7           	OR A
 202+ 5977 20 05        	JR NZ, .L1
 203+ 5979              	; sound disabled, throw illegal function call
 204+ 5979 1E 05        	LD E, 5
 205+ 597B C3 6B 65     	JP THROW_ERROR
 206+ 597E              .L1:
 207+ 597E 3A C9 58     	LD A, (SFX_INIT_STATUS)
 208+ 5981 B7           	OR A
 209+ 5982 20 05        	JR NZ, .L2
 210+ 5984              	; sfx data not initialized, throw out of data
 211+ 5984 1E 04        	LD E, 4
 212+ 5986 C3 6B 65     	JP THROW_ERROR
 213+ 5989              .L2:
 214+ 5989              	; pop  parameters and store away for later
 215+ 5989 D1           	POP DE ; inverted volume
 216+ 598A 43           	LD B, E
 217+ 598B D1           	POP DE ; channel
 218+ 598C 4B           	LD C, E
 219+ 598D D1           	POP DE
 220+ 598E 7B           	LD A, E
 221+ 598F 08           	EX AF, AF'
 222+ 5990 E5           	PUSH HL ; basic text location
 223+ 5991 D9           	EXX
 224+ 5992 FD 21 99 59  	LD IY, .RET
 225+ 5996 C3 F6 64     	JP ENABLE_PAGE0
 226+ 5999              .RET:
 227+ 5999 D9           	EXX
 228+ 599A 08           	EX AF, AF'
 229+ 599B CD 24 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
 230+ 599E
 231+ 599E D1               POP DE
 232+ 599F C1               POP BC
 233+ 59A0 CD 6D 64         CALL RESTORE_PAGE_INFO
 234+ 59A3
 235+ 59A3 E1           	POP HL
 236+ 59A4 C9           	RET
 237+ 59A5              ; *******************************************************************************************************
 238+ 59A5               ENDIF
 239+ 59A5
 240+ 59A5               IF (0 == 1)
 241+ 59A5 ~            ; *******************************************************************************************************
 242+ 59A5 ~            ; same as SNDSFX but for DEFUSR approach
 243+ 59A5 ~            ; input IX=pointer to input array, real data from +2
 244+ 59A5 ~            ; +2 = SFX number
 245+ 59A5 ~            ; +4 = channel
 246+ 59A5 ~            ; +6 = volume
 247+ 59A5 ~            SNDSFX_DEFUSR:
 248+ 59A5 ~            	LD A, (SOUND_ENABLED)
 249+ 59A5 ~            	OR A
 250+ 59A5 ~            	RET Z ; sound disabled, just exit
 251+ 59A5 ~            	LD A, (SFX_INIT_STATUS)
 252+ 59A5 ~            	OR A
 253+ 59A5 ~            	RET Z ; sfx data not initialized, just exit
 254+ 59A5 ~            	LD IY, .RET
 255+ 59A5 ~            	JP ENABLE_PAGE0
 256+ 59A5 ~            .RET:
 257+ 59A5 ~            	EI
 258+ 59A5 ~            	LD A,(IX+2) ; SFX number
 259+ 59A5 ~            	LD C,(IX+4) ; channel
 260+ 59A5 ~            	LD B,(IX+6) ; volume
 261+ 59A5 ~            	CALL PLY_AKG_PLAYSOUNDEFFECT
 262+ 59A5 ~                POP DE
 263+ 59A5 ~                POP BC
 264+ 59A5 ~                JP RESTORE_PAGE_INFO
 265+ 59A5 ~            ; *******************************************************************************************************
 266+ 59A5               ENDIF
# file closed: asm\SOUND.asm
 141  59A5               ENDIF
 142  59A5
 143  59A5               IF (VRAM_CMDS == 1)
 144  59A5               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
   1+ 59A5               IF (1 == 1)
   2+ 59A5              ; *******************************************************************************************************
   3+ 59A5              ; function to handle CALL FILVRM basic extension
   4+ 59A5              ; FILVRM ( INT offset,
   5+ 59A5              ;		   INT count,
   6+ 59A5              ;		   BYTE value,
   7+ 59A5              ;		   BYTE wait_vsync) >0 = true
   8+ 59A5              ; wait_vsync will issue HALT before copying
   9+ 59A5              FILVRM:
  10+ 59A5              	; opening (
  11+ 59A5 CD 45 65     	CALL CHKCHAR
  12+ 59A8 28           	DB '('
  13+ 59A9              	; get offset address
  14+ 59A9 DD 21 2F 54  	LD IX, FRMQNT
  15+ 59AD CD 59 01     	CALL CALBAS
  16+ 59B0 D5           	PUSH DE
  17+ 59B1              	; comma
  18+ 59B1 CD 45 65     	CALL CHKCHAR
  19+ 59B4 2C           	DB ','
  20+ 59B5              	; get count
  21+ 59B5 DD 21 2F 54  	LD IX, FRMQNT
  22+ 59B9 CD 59 01     	CALL CALBAS
  23+ 59BC D5           	PUSH DE
  24+ 59BD              	; comma
  25+ 59BD CD 45 65     	CALL CHKCHAR
  26+ 59C0 2C           	DB ','
  27+ 59C1              	; get value
  28+ 59C1 DD 21 1C 52  	LD IX, GETBYT
  29+ 59C5 CD 59 01     	CALL CALBAS
  30+ 59C8 F5           	PUSH AF
  31+ 59C9              	; comma
  32+ 59C9 CD 45 65     	CALL CHKCHAR
  33+ 59CC 2C           	DB ','
  34+ 59CD              	; get vsync wait
  35+ 59CD DD 21 1C 52  	LD IX, GETBYT
  36+ 59D1 CD 59 01     	CALL CALBAS
  37+ 59D4 F5           	PUSH AF
  38+ 59D5              	; ending )
  39+ 59D5 CD 45 65     	CALL CHKCHAR
  40+ 59D8 29           	DB ')'
  41+ 59D9
  42+ 59D9              	; save position
  43+ 59D9 E5           	PUSH HL
  44+ 59DA DD E1        	POP IX
  45+ 59DC
  46+ 59DC              	; syntax ok
  47+ 59DC              	; wait for vsync if needed
  48+ 59DC F1           	POP AF
  49+ 59DD B7           	OR A
  50+ 59DE 28 01        	JR Z, .L1
  51+ 59E0 76           	HALT
  52+ 59E1
  53+ 59E1              .L1:
  54+ 59E1 3E 01        	LD A,1
  55+ 59E3 32 46 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
  56+ 59E6 F1               POP AF ; value
  57+ 59E7 C1               POP BC ; count
  58+ 59E8 E1               POP HL ; offset
  59+ 59E9 CD 56 00         CALL BIOS_FILVRM
  60+ 59EC AF           	XOR A
  61+ 59ED 32 46 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
  62+ 59F0
  63+ 59F0              .L3:
  64+ 59F0 DD E5        	PUSH IX
  65+ 59F2 E1           	POP HL
  66+ 59F3 C9           	RET
  67+ 59F4              ; *******************************************************************************************************
  68+ 59F4               ENDIF
  69+ 59F4
  70+ 59F4               IF (0 == 1)
  71+ 59F4 ~            ; *******************************************************************************************************
  72+ 59F4 ~            ; same as FILVRM but for DEFUSR approach
  73+ 59F4 ~            ; input IX=pointer to input array, real data from +2
  74+ 59F4 ~            ; +2 = offset
  75+ 59F4 ~            ; +4 = count
  76+ 59F4 ~            ; +6 = value
  77+ 59F4 ~            ; +8 = halt flag
  78+ 59F4 ~            FILVRM_DEFUSR:
  79+ 59F4 ~            	LD A,(IX+8)
  80+ 59F4 ~            	OR A
  81+ 59F4 ~            	JR Z,.L0
  82+ 59F4 ~            	HALT
  83+ 59F4 ~            .L0:
  84+ 59F4 ~            	LD A,1
  85+ 59F4 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  86+ 59F4 ~            	LD L,(IX+2)
  87+ 59F4 ~            	LD H,(IX+3)
  88+ 59F4 ~            	LD C,(IX+4)
  89+ 59F4 ~            	LD B,(IX+5)
  90+ 59F4 ~            	LD A,(IX+6)
  91+ 59F4 ~            	CALL BIOS_FILVRM
  92+ 59F4 ~            	XOR A
  93+ 59F4 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  94+ 59F4 ~            	RET
  95+ 59F4 ~            ; *******************************************************************************************************
  96+ 59F4               ENDIF
  97+ 59F4
  98+ 59F4               IF (1 == 1)
  99+ 59F4              ; *******************************************************************************************************
 100+ 59F4              ; function to handle CALL MEMVRM basic extension
 101+ 59F4              ; copies from RAM to VRAM
 102+ 59F4              ; _MEMVRM ( INT source,
 103+ 59F4              ;			INT destination,
 104+ 59F4              ;			INT count,
 105+ 59F4              ;			BYTE wait_vsync) >0 = true
 106+ 59F4              ; will put ram in page 0 also, page 1 is already there
 107+ 59F4              ; wait_vsync will issue HALT before copying
 108+ 59F4              MEMVRM:
 109+ 59F4              	; opening (
 110+ 59F4 CD 45 65     	CALL CHKCHAR
 111+ 59F7 28           	DB '('
 112+ 59F8              	; get source address
 113+ 59F8 DD 21 2F 54  	LD IX, FRMQNT
 114+ 59FC CD 59 01     	CALL CALBAS
 115+ 59FF D5           	PUSH DE
 116+ 5A00              	; comma
 117+ 5A00 CD 45 65     	CALL CHKCHAR
 118+ 5A03 2C           	DB ','
 119+ 5A04              	; get destination address
 120+ 5A04 DD 21 2F 54  	LD IX, FRMQNT
 121+ 5A08 CD 59 01     	CALL CALBAS
 122+ 5A0B D5           	PUSH DE
 123+ 5A0C              	; comma
 124+ 5A0C CD 45 65     	CALL CHKCHAR
 125+ 5A0F 2C           	DB ','
 126+ 5A10              	; get length
 127+ 5A10 DD 21 2F 54  	LD IX, FRMQNT
 128+ 5A14 CD 59 01     	CALL CALBAS
 129+ 5A17 D5           	PUSH DE
 130+ 5A18              	; comma
 131+ 5A18 CD 45 65     	CALL CHKCHAR
 132+ 5A1B 2C           	DB ','
 133+ 5A1C              	; get vsync wait
 134+ 5A1C DD 21 1C 52  	LD IX, GETBYT
 135+ 5A20 CD 59 01     	CALL CALBAS
 136+ 5A23 F5           	PUSH AF
 137+ 5A24              	; ending )
 138+ 5A24 CD 45 65     	CALL CHKCHAR
 139+ 5A27 29           	DB ')'
 140+ 5A28
 141+ 5A28                  ; save position in BASIC text
 142+ 5A28 E5           	PUSH HL
 143+ 5A29 DD E1        	POP IX
 144+ 5A2B
 145+ 5A2B F1           	POP AF ; wait vsync
 146+ 5A2C B7           	OR A
 147+ 5A2D 28 01        	JR Z, .L1
 148+ 5A2F 76           	HALT
 149+ 5A30              .L1:
 150+ 5A30              	; pop LDIR parameters and store away for later
 151+ 5A30 C1           	POP BC ; count
 152+ 5A31 D1           	POP DE ; vram destination
 153+ 5A32 E1           	POP HL ; ram source
 154+ 5A33 D9           	EXX
 155+ 5A34 FD 21 3B 5A   	LD IY, .RET
 156+ 5A38 C3 F6 64     	JP ENABLE_PAGE0
 157+ 5A3B              .RET:
 158+ 5A3B FB           	EI
 159+ 5A3C D9           	EXX
 160+ 5A3D CD 49 5A     	CALL VRAM_LDIRVM
 161+ 5A40 D1               POP DE
 162+ 5A41 C1               POP BC
 163+ 5A42 CD 6D 64         CALL RESTORE_PAGE_INFO
 164+ 5A45 DD E5        	PUSH IX
 165+ 5A47 E1           	POP HL
 166+ 5A48 C9           	RET
 167+ 5A49              ; *******************************************************************************************************
 168+ 5A49               ENDIF
 169+ 5A49
 170+ 5A49               IF (0 == 1)
 171+ 5A49 ~            ; *******************************************************************************************************
 172+ 5A49 ~            ; same as MEMVRM but for DEFUSR approach
 173+ 5A49 ~            ; input IX=pointer to input array, real data from +2
 174+ 5A49 ~            ; +2 = source address
 175+ 5A49 ~            ; +4 = destination address
 176+ 5A49 ~            ; +6 = lenght
 177+ 5A49 ~            ; +8 = vsync wait flag
 178+ 5A49 ~            MEMVRM_DEFUSR:
 179+ 5A49 ~            	LD A,(IX+8)
 180+ 5A49 ~            	OR A
 181+ 5A49 ~            	JR Z,.L0
 182+ 5A49 ~            	HALT
 183+ 5A49 ~            .L0:
 184+ 5A49 ~            	; enable page 0
 185+ 5A49 ~            	LD IY, .RET
 186+ 5A49 ~            	JP ENABLE_PAGE0
 187+ 5A49 ~            .RET:
 188+ 5A49 ~            	EI
 189+ 5A49 ~            	LD L,(IX+2)
 190+ 5A49 ~            	LD H,(IX+3)
 191+ 5A49 ~            	LD E,(IX+4)
 192+ 5A49 ~            	LD D,(IX+5)
 193+ 5A49 ~            	LD C,(IX+6)
 194+ 5A49 ~            	LD B,(IX+7)
 195+ 5A49 ~            	CALL VRAM_LDIRVM
 196+ 5A49 ~                POP DE
 197+ 5A49 ~                POP BC
 198+ 5A49 ~                JP RESTORE_PAGE_INFO
 199+ 5A49 ~            ; *******************************************************************************************************
 200+ 5A49               ENDIF
 201+ 5A49
 202+ 5A49              ; *******************************************************************************************************
 203+ 5A49              ; common code to copy from memory to VRAM
 204+ 5A49              ; input HL=RAM source
 205+ 5A49              ; input DE=VRAM destination
 206+ 5A49              ; BC=count
 207+ 5A49              VRAM_LDIRVM:
 208+ 5A49 3E 01        	LD A,1
 209+ 5A4B 32 46 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 210+ 5A4E EB           	EX DE, HL
 211+ 5A4F F3           	DI
 212+ 5A50 CD 1D 64     	CALL SETWRT_LOCAL
 213+ 5A53 FB           	EI
 214+ 5A54 EB           	EX DE, HL
 215+ 5A55 78           	LD A, B
 216+ 5A56 B7           	OR A
 217+ 5A57 28 0D        	JR Z, .L3
 218+ 5A59 C5           	PUSH BC
 219+ 5A5A 0E 98        	LD C, #98
 220+ 5A5C              .L2:
 221+ 5A5C 50           	LD D, B
 222+ 5A5D 06 00        	LD B, 0
 223+ 5A5F CD 2A 64     	CALL BBYTECOPY_NO_C
 224+ 5A62 42           	LD B, D
 225+ 5A63 10 F7        	DJNZ .L2
 226+ 5A65 C1           	POP BC
 227+ 5A66              .L3:
 228+ 5A66 79           	LD A, C
 229+ 5A67 B7           	OR A
 230+ 5A68 28 04        	JR Z,.L4
 231+ 5A6A 41           	LD B, C
 232+ 5A6B CD 28 64     	CALL BBYTECOPY
 233+ 5A6E              .L4:
 234+ 5A6E AF           	XOR A
 235+ 5A6F 32 46 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 236+ 5A72 C9           	RET
 237+ 5A73              ; *******************************************************************************************************
 238+ 5A73
 239+ 5A73               IF (1 == 1)
 240+ 5A73              ; *******************************************************************************************************
 241+ 5A73              ; function to handle CALL VRMMEM basic extension
 242+ 5A73              ; copies from RAM to VRAM
 243+ 5A73              ; _VRMMEM ( INT source,
 244+ 5A73              ;			INT destination,
 245+ 5A73              ;			INT count
 246+ 5A73              ; will put ram in page 0 also, page 1 is already there
 247+ 5A73              VRMMEM:
 248+ 5A73              	; opening (
 249+ 5A73 CD 45 65     	CALL CHKCHAR
 250+ 5A76 28           	DB '('
 251+ 5A77              	; get source address
 252+ 5A77 DD 21 2F 54  	LD IX, FRMQNT
 253+ 5A7B CD 59 01     	CALL CALBAS
 254+ 5A7E D5           	PUSH DE
 255+ 5A7F              	; comma
 256+ 5A7F CD 45 65     	CALL CHKCHAR
 257+ 5A82 2C           	DB ','
 258+ 5A83              	; get destination address
 259+ 5A83 DD 21 2F 54  	LD IX, FRMQNT
 260+ 5A87 CD 59 01     	CALL CALBAS
 261+ 5A8A D5           	PUSH DE
 262+ 5A8B              	; comma
 263+ 5A8B CD 45 65     	CALL CHKCHAR
 264+ 5A8E 2C           	DB ','
 265+ 5A8F              	; get length
 266+ 5A8F DD 21 2F 54  	LD IX, FRMQNT
 267+ 5A93 CD 59 01     	CALL CALBAS
 268+ 5A96 D5           	PUSH DE
 269+ 5A97              	; ending )
 270+ 5A97 CD 45 65     	CALL CHKCHAR
 271+ 5A9A 29           	DB ')'
 272+ 5A9B
 273+ 5A9B                  ; save position in BASIC text
 274+ 5A9B E5           	PUSH HL
 275+ 5A9C DD E1        	POP IX
 276+ 5A9E
 277+ 5A9E C1           	POP BC ; count
 278+ 5A9F D1           	POP DE ; destination
 279+ 5AA0 E1           	POP HL ; source
 280+ 5AA1 D9           	EXX
 281+ 5AA2 FD 21 A9 5A  	LD IY, .RET
 282+ 5AA6 C3 F6 64     	JP ENABLE_PAGE0
 283+ 5AA9              .RET:
 284+ 5AA9 FB           	EI
 285+ 5AAA D9           	EXX
 286+ 5AAB CD B7 5A     	CALL VRAM_LDIRMV
 287+ 5AAE D1               POP DE
 288+ 5AAF C1               POP BC
 289+ 5AB0 CD 6D 64         CALL RESTORE_PAGE_INFO
 290+ 5AB3 DD E5        	PUSH IX
 291+ 5AB5 E1           	POP HL
 292+ 5AB6 C9           	RET
 293+ 5AB7              ; *******************************************************************************************************
 294+ 5AB7               ENDIF
 295+ 5AB7
 296+ 5AB7               IF (0 == 1)
 297+ 5AB7 ~            ; *******************************************************************************************************
 298+ 5AB7 ~            ; same as VRMMEM but for DEFUSR approach
 299+ 5AB7 ~            ; input IX=pointer to input array, real data from +2
 300+ 5AB7 ~            ; +2 = source address
 301+ 5AB7 ~            ; +4 = destination address
 302+ 5AB7 ~            ; +6 = count
 303+ 5AB7 ~            VRMMEM_DEFUSR:
 304+ 5AB7 ~            	; enable page 0
 305+ 5AB7 ~            	LD IY, .RET
 306+ 5AB7 ~            	JP ENABLE_PAGE0
 307+ 5AB7 ~            .RET:
 308+ 5AB7 ~            	EI
 309+ 5AB7 ~            	LD L,(IX+2)
 310+ 5AB7 ~            	LD H,(IX+3)
 311+ 5AB7 ~            	LD E,(IX+4)
 312+ 5AB7 ~            	LD D,(IX+5)
 313+ 5AB7 ~            	LD C,(IX+6)
 314+ 5AB7 ~            	LD B,(IX+7)
 315+ 5AB7 ~            	CALL VRAM_LDIRMV
 316+ 5AB7 ~                POP DE
 317+ 5AB7 ~                POP BC
 318+ 5AB7 ~                JP RESTORE_PAGE_INFO
 319+ 5AB7 ~            ; *******************************************************************************************************
 320+ 5AB7               ENDIF
 321+ 5AB7
 322+ 5AB7              ; *******************************************************************************************************
 323+ 5AB7              ; common code to copy from VRAM to RAM
 324+ 5AB7              ; input HL=VRAM source
 325+ 5AB7              ; input DE=RAM destination
 326+ 5AB7              ; BC=count
 327+ 5AB7              VRAM_LDIRMV:
 328+ 5AB7 3E 01        	LD A,1
 329+ 5AB9 32 46 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 330+ 5ABC 7D           	LD	A, L
 331+ 5ABD F3           	DI
 332+ 5ABE D3 99        	OUT	(099H), A
 333+ 5AC0 7C           	LD	A, H
 334+ 5AC1 E6 3F        	AND	03FH
 335+ 5AC3 D3 99        	OUT	(099H), A
 336+ 5AC5 FB           	EI
 337+ 5AC6              .L4:
 338+ 5AC6 DB 98            IN A, (#98)
 339+ 5AC8 12           	LD (DE), A
 340+ 5AC9 13               INC DE
 341+ 5ACA 0B               DEC BC
 342+ 5ACB 79               LD A, C
 343+ 5ACC B0               OR B
 344+ 5ACD 20 F7            JR NZ, .L4
 345+ 5ACF AF           	XOR A
 346+ 5AD0 32 46 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 347+ 5AD3 C9               RET
 348+ 5AD4              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
 145  5AD4               ENDIF
 146  5AD4
 147  5AD4               IF (GENCAL_CMD == 1)
 148  5AD4               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
   1+ 5AD4               IF (0 == 1)
   2+ 5AD4 ~            ; *******************************************************************************************************
   3+ 5AD4 ~            ; same as GENCAL but for DEFUSR approach
   4+ 5AD4 ~            ; input IX=pointer to input array, real data from +2
   5+ 5AD4 ~            ; +2 = function address to call
   6+ 5AD4 ~            ; +4 = register list array pointer
   7+ 5AD4 ~            GENCAL_DEFUSR:
   8+ 5AD4 ~                LD L,(IX+2)
   9+ 5AD4 ~                LD H,(IX+3)
  10+ 5AD4 ~                PUSH HL
  11+ 5AD4 ~                LD L,(IX+4)
  12+ 5AD4 ~                LD H,(IX+5)
  13+ 5AD4 ~                PUSH HL
  14+ 5AD4 ~                JR GENCAL.COMMON
  15+ 5AD4 ~            ; *******************************************************************************************************
  16+ 5AD4               ENDIF
  17+ 5AD4
  18+ 5AD4              ; *******************************************************************************************************
  19+ 5AD4              ; function to handle CALL GENCAL basic extension
  20+ 5AD4              ; GENCAL ( INT fn_addr, = address of the function to call
  21+ 5AD4              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
  22+ 5AD4              ; output values of registers will also be stored at reg_list_ptr
  23+ 5AD4              GENCAL:
  24+ 5AD4               IF (1 == 1)
  25+ 5AD4              	; opening (
  26+ 5AD4 CD 45 65     	CALL CHKCHAR
  27+ 5AD7 28           	DB '('
  28+ 5AD8              	; get function address
  29+ 5AD8 DD 21 2F 54  	LD IX, FRMQNT
  30+ 5ADC CD 59 01     	CALL CALBAS
  31+ 5ADF D5           	PUSH DE
  32+ 5AE0              	; comma
  33+ 5AE0 CD 45 65     	CALL CHKCHAR
  34+ 5AE3 2C           	DB ','
  35+ 5AE4              	; get pointer to register list
  36+ 5AE4 3E 02            LD A,2
  37+ 5AE6 06 01            LD B,1
  38+ 5AE8 11 00 05         LD DE,#0500
  39+ 5AEB CD 72 65         CALL GET_BASIC_ARRAY_DATA_POINTER
  40+ 5AEE C5           	PUSH BC
  41+ 5AEF              	; ending )
  42+ 5AEF CD 45 65     	CALL CHKCHAR
  43+ 5AF2 29           	DB ')'
  44+ 5AF3               ENDIF
  45+ 5AF3              .COMMON:
  46+ 5AF3              	; save BASIC token position
  47+ 5AF3 E5           	PUSH HL
  48+ 5AF4 D9               EXX
  49+ 5AF5 E1           	POP HL ; HL'=next basic token
  50+ 5AF6 D9               EXX
  51+ 5AF7
  52+ 5AF7 E1               POP HL ; get pointer to register values
  53+ 5AF8 F3           	DI
  54+ 5AF9 ED 73 35 62      LD (BLIT_STRUCT), SP
  55+ 5AFD F9               LD SP, HL
  56+ 5AFE F1               POP AF
  57+ 5AFF C1               POP BC
  58+ 5B00 D1               POP DE
  59+ 5B01 E1               POP HL
  60+ 5B02 DD E1            POP IX
  61+ 5B04 FD E1            POP IY
  62+ 5B06 D9               EXX
  63+ 5B07 ED 73 37 62      LD (BLIT_STRUCT+2), SP
  64+ 5B0B ED 7B 35 62      LD SP, (BLIT_STRUCT)
  65+ 5B0F FB               EI
  66+ 5B10 D1               POP DE ; get function to call
  67+ 5B11 E5               PUSH HL
  68+ 5B12 CD 2D 5B         CALL .EXXDECALL
  69+ 5B15 F3               DI
  70+ 5B16 ED 73 35 62      LD (BLIT_STRUCT), SP
  71+ 5B1A ED 7B 37 62      LD SP, (BLIT_STRUCT+2)
  72+ 5B1E FD E5            PUSH IY
  73+ 5B20 DD E5            PUSH IX
  74+ 5B22 E5               PUSH HL
  75+ 5B23 D5               PUSH DE
  76+ 5B24 C5               PUSH BC
  77+ 5B25 F5               PUSH AF
  78+ 5B26 ED 7B 35 62      LD SP, (BLIT_STRUCT)
  79+ 5B2A FB               EI
  80+ 5B2B E1               POP HL
  81+ 5B2C C9           	RET
  82+ 5B2D
  83+ 5B2D              .EXXDECALL:
  84+ 5B2D D5               PUSH DE
  85+ 5B2E D9               EXX
  86+ 5B2F C9               RET
  87+ 5B30              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
 149  5B30               ENDIF
 150  5B30
 151  5B30               IF (BOX_CMDS == 1)
 152  5B30               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
   1+ 5B30              ; *******************************************************************************************************
   2+ 5B30              ; generic function to implement rectangle data copy
   3+ 5B30              ; should be modified to call appropriate function for memory or vram
   4+ 5B30              ; input IX=pointer to following structure
   5+ 5B30              ; +00 source data pointer
   6+ 5B30              ; +02 num bytes in a row
   7+ 5B30              ; +04 number of rows
   8+ 5B30              ; +06 source add-to value till next row
   9+ 5B30              ; +08 destination address
  10+ 5B30              ; +10 destination add-to value till next row
  11+ 5B30              ; modifies AF, BC, DE, HL
  12+ 5B30              RECTANGLE_COPY:
  13+ 5B30 DD 6E 00     	LD L, (IX+0)
  14+ 5B33 DD 66 01     	LD H, (IX+1) ; source address
  15+ 5B36 DD 5E 08     	LD E, (IX+8)
  16+ 5B39 DD 56 09     	LD D, (IX+9) ; destination
  17+ 5B3C DD 46 04     	LD B, (IX+4) ; row number
  18+ 5B3F              .L1:
  19+ 5B3F C5           	PUSH BC
  20+ 5B40 E5           		PUSH HL
  21+ 5B41 D5           			PUSH DE
  22+ 5B42 DD 4E 02     				LD C, (IX+2)
  23+ 5B45 DD 46 03     				LD B, (IX+3) ; num bytes in a row
  24+ 5B48              .CALL1:
  25+ 5B48 CD 00 00     				CALL 0 ; set destination address from DE
  26+ 5B4B              .CALL2:
  27+ 5B4B CD 00 00     				CALL 0 ; copy data fn
  28+ 5B4E E1           			POP HL
  29+ 5B4F DD 4E 0A     			LD C, (IX+10)
  30+ 5B52 DD 46 0B     			LD B, (IX+11) ; destination add-to
  31+ 5B55 09           			ADD HL, BC
  32+ 5B56 EB           			EX DE, HL
  33+ 5B57 E1           		POP HL
  34+ 5B58 DD 4E 06     		LD C, (IX+6)
  35+ 5B5B DD 46 07     		LD B, (IX+7) ; src add-to
  36+ 5B5E 09           		ADD HL, BC
  37+ 5B5F C1           	POP BC
  38+ 5B60 10 DD        	DJNZ .L1
  39+ 5B62 C9           	RET
  40+ 5B63              ; *******************************************************************************************************
  41+ 5B63
  42+ 5B63               IF (1 == 1)
  43+ 5B63              ; *******************************************************************************************************
  44+ 5B63              ; function to handle CALL BOXMEMCPY basic extension
  45+ 5B63              ; copies data with window like boundaries within ram
  46+ 5B63              ; BOXMEMCPY ( INT source data pointer,
  47+ 5B63              ;			  INT source number of bytes in a row,
  48+ 5B63              ;			  INT number of rows,
  49+ 5B63              ;			  INT source add-to value till next row,
  50+ 5B63              ; 			  INT destination pointer,
  51+ 5B63              ;			  INT destination add-to value till next row )
  52+ 5B63              ; request_data_ptr described in RECTANGLE_COPY
  53+ 5B63              ; will put ram in page 0 also, page 1 is already there
  54+ 5B63              BOXMEMCPY:
  55+ 5B63 11 6D 5B     	LD DE,BOXMEMCPY_COMMON
  56+ 5B66 ED 53 E5 5B  	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
  57+ 5B6A C3 80 5B     	JP BOX_EXTENSION_PARAMS_COMMON
  58+ 5B6D               ENDIF
  59+ 5B6D
  60+ 5B6D               IF (0 == 1)
  61+ 5B6D ~            ; *******************************************************************************************************
  62+ 5B6D ~            ; same as BOXMEMCPY but for DEFUSR approach
  63+ 5B6D ~            ; input IX=pointer to input array, real data from +2
  64+ 5B6D ~            ; +02 = source data pointer
  65+ 5B6D ~            ; +04 = source number of bytes in a row
  66+ 5B6D ~            ; +06 = number of rows
  67+ 5B6D ~            ; +08 = source add-to value till next row
  68+ 5B6D ~            ; +10 = destination pointer
  69+ 5B6D ~            ; +12 = destination add-to value till next row
  70+ 5B6D ~            BOXMEMCPY_DEFUSR:
  71+ 5B6D ~            	LD HL,BOXMEMCPY_COMMON
  72+ 5B6D ~            	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
  73+ 5B6D ~            	INC IX
  74+ 5B6D ~            	INC IX
  75+ 5B6D ~            	JP BOXCOMMON_DEFUSR
  76+ 5B6D               ENDIF
  77+ 5B6D
  78+ 5B6D              BOXMEMCPY_COMMON:
  79+ 5B6D FB           	EI
  80+ 5B6E              	; set RAM functions to call
  81+ 5B6E 21 00 00     	LD HL, 0
  82+ 5B71 22 48 5B     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
  83+ 5B74 22 4A 5B     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
  84+ 5B77 21 ED B0     	LD HL, #B0ED ; LDIR
  85+ 5B7A 22 4C 5B     	LD (RECTANGLE_COPY.CALL1+4), HL
  86+ 5B7D C3 EA 5B     	JP BOXCOMMON_DEFUSR.CALL
  87+ 5B80              ; *******************************************************************************************************
  88+ 5B80
  89+ 5B80               IF (1 == 1)
  90+ 5B80              ; *******************************************************************************************************
  91+ 5B80              ; common parts of BOX commands to load parameters
  92+ 5B80              BOX_EXTENSION_PARAMS_COMMON:
  93+ 5B80              	; opening (
  94+ 5B80 CD 45 65     	CALL CHKCHAR
  95+ 5B83 28           	DB '('
  96+ 5B84              	; get source data pointer
  97+ 5B84 DD 21 2F 54  	LD IX, FRMQNT
  98+ 5B88 CD 59 01     	CALL CALBAS
  99+ 5B8B ED 53 35 62  	LD (BLIT_STRUCT+0), DE
 100+ 5B8F              	; comma
 101+ 5B8F CD 45 65     	CALL CHKCHAR
 102+ 5B92 2C           	DB ','
 103+ 5B93              	; source number of bytes in a row
 104+ 5B93 DD 21 2F 54  	LD IX, FRMQNT
 105+ 5B97 CD 59 01     	CALL CALBAS
 106+ 5B9A ED 53 37 62  	LD (BLIT_STRUCT+2), DE
 107+ 5B9E              	; comma
 108+ 5B9E CD 45 65     	CALL CHKCHAR
 109+ 5BA1 2C           	DB ','
 110+ 5BA2              	; number of rows
 111+ 5BA2 DD 21 2F 54  	LD IX, FRMQNT
 112+ 5BA6 CD 59 01     	CALL CALBAS
 113+ 5BA9 ED 53 39 62  	LD (BLIT_STRUCT+4), DE
 114+ 5BAD              	; comma
 115+ 5BAD CD 45 65     	CALL CHKCHAR
 116+ 5BB0 2C           	DB ','
 117+ 5BB1              	; source add-to value till next row
 118+ 5BB1 DD 21 2F 54  	LD IX, FRMQNT
 119+ 5BB5 CD 59 01     	CALL CALBAS
 120+ 5BB8 ED 53 3B 62  	LD (BLIT_STRUCT+6), DE
 121+ 5BBC              	; comma
 122+ 5BBC CD 45 65     	CALL CHKCHAR
 123+ 5BBF 2C           	DB ','
 124+ 5BC0              	; destination pointer
 125+ 5BC0 DD 21 2F 54  	LD IX, FRMQNT
 126+ 5BC4 CD 59 01     	CALL CALBAS
 127+ 5BC7 ED 53 3D 62  	LD (BLIT_STRUCT+8), DE
 128+ 5BCB              	; comma
 129+ 5BCB CD 45 65     	CALL CHKCHAR
 130+ 5BCE 2C           	DB ','
 131+ 5BCF              	; destination add-to value till next row
 132+ 5BCF DD 21 2F 54  	LD IX, FRMQNT
 133+ 5BD3 CD 59 01     	CALL CALBAS
 134+ 5BD6 ED 53 3F 62  	LD (BLIT_STRUCT+10), DE
 135+ 5BDA              	; ending )
 136+ 5BDA CD 45 65     	CALL CHKCHAR
 137+ 5BDD 29           	DB ')'
 138+ 5BDE DD 21 35 62  	LD IX,BLIT_STRUCT
 139+ 5BE2               ENDIF
 140+ 5BE2              BOXCOMMON_DEFUSR:
 141+ 5BE2 E5           	PUSH HL ; save position in BASIC buffer
 142+ 5BE3              .ADDR:
 143+ 5BE3 FD 21 00 00  	LD IY, 0 ; modified by code
 144+ 5BE7 C3 F6 64     	JP ENABLE_PAGE0
 145+ 5BEA              .CALL:
 146+ 5BEA CD 30 5B     	CALL RECTANGLE_COPY
 147+ 5BED AF           	XOR A
 148+ 5BEE 32 46 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 149+ 5BF1
 150+ 5BF1 D1               POP DE
 151+ 5BF2 C1               POP BC
 152+ 5BF3 CD 6D 64         CALL RESTORE_PAGE_INFO
 153+ 5BF6
 154+ 5BF6 E1           	POP HL
 155+ 5BF7 C9           	RET
 156+ 5BF8              ; *******************************************************************************************************
 157+ 5BF8
 158+ 5BF8               IF (1 == 1)
 159+ 5BF8              ; *******************************************************************************************************
 160+ 5BF8              ; function to handle CALL BOXMEMVRM basic extension
 161+ 5BF8              ; copies data with window like boundaries from ram to Vram
 162+ 5BF8              ; BOXMEMVRM ( INT source data pointer,
 163+ 5BF8              ;			  INT source number of bytes in a row,
 164+ 5BF8              ;			  INT number of rows,
 165+ 5BF8              ;			  INT source add-to value till next row,
 166+ 5BF8              ; 			  INT destination pointer,
 167+ 5BF8              ;			  INT destination add-to value till next row )
 168+ 5BF8              ; request_data_ptr described in RECTANGLE_COPY
 169+ 5BF8              ; will put ram in page 0 also, page 1 is already there
 170+ 5BF8              BOXMEMVRM:
 171+ 5BF8 11 02 5C     	LD DE,BOXMEMVRM_COMMON
 172+ 5BFB ED 53 E5 5B  	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
 173+ 5BFF C3 80 5B     	JP BOX_EXTENSION_PARAMS_COMMON
 174+ 5C02               ENDIF
 175+ 5C02
 176+ 5C02               IF (0 == 1)
 177+ 5C02 ~            ; *******************************************************************************************************
 178+ 5C02 ~            ; same as BOXMEMVRM but for DEFUSR approach
 179+ 5C02 ~            ; input IX=pointer to input array, real data from +2
 180+ 5C02 ~            ; +02 = source data pointer
 181+ 5C02 ~            ; +04 = source number of bytes in a row
 182+ 5C02 ~            ; +06 = number of rows
 183+ 5C02 ~            ; +08 = source add-to value till next row
 184+ 5C02 ~            ; +10 = destination pointer
 185+ 5C02 ~            ; +12 = destination add-to value till next row
 186+ 5C02 ~            BOXMEMVRM_DEFUSR:
 187+ 5C02 ~            	LD HL,BOXMEMVRM_COMMON
 188+ 5C02 ~            	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
 189+ 5C02 ~            	INC IX
 190+ 5C02 ~            	INC IX
 191+ 5C02 ~            	JP BOXCOMMON_DEFUSR
 192+ 5C02               ENDIF
 193+ 5C02
 194+ 5C02              BOXMEMVRM_COMMON:
 195+ 5C02 FB           	EI
 196+ 5C03              	; set RAM functions to call
 197+ 5C03 21 1D 5C     	LD HL, .SETDEST
 198+ 5C06 22 49 5B     	LD (RECTANGLE_COPY.CALL1+1), HL
 199+ 5C09 21 25 5C     	LD HL, .COPYDATA
 200+ 5C0C 22 4C 5B     	LD (RECTANGLE_COPY.CALL2+1), HL
 201+ 5C0F 3E CD        	LD A, #CD ; CALL
 202+ 5C11 32 48 5B     	LD (RECTANGLE_COPY.CALL1), A
 203+ 5C14 32 4B 5B     	LD (RECTANGLE_COPY.CALL2), A
 204+ 5C17              	;LD A,1
 205+ 5C17 32 46 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 206+ 5C1A C3 EA 5B     	JP BOXCOMMON_DEFUSR.CALL
 207+ 5C1D              .SETDEST:
 208+ 5C1D EB           	EX DE, HL
 209+ 5C1E F3           	DI
 210+ 5C1F CD 1D 64     	CALL SETWRT_LOCAL
 211+ 5C22 FB           	EI
 212+ 5C23 EB           	EX DE, HL
 213+ 5C24 C9           	RET
 214+ 5C25              .COPYDATA:
 215+ 5C25 41           	LD B, C
 216+ 5C26 C3 28 64     	JP BBYTECOPY
 217+ 5C29              ; *******************************************************************************************************
# file closed: asm\BOX.asm
 153  5C29               ENDIF
 154  5C29
 155  5C29               IF (BLIT_CMDS == 1)
 156  5C29               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
   1+ 5C29              ; *******************************************************************************************************
   2+ 5C29              ; function rotates mask and data of several characters and applies to background data
   3+ 5C29              ; this handles x-shift from 0 to 4
   4+ 5C29              ; contains self-modifying code that is set-up from external function
   5+ 5C29              ; input HL=pointer to mask data
   6+ 5C29              ; input HL'=pointer to character data
   7+ 5C29              ; input DE=output buffer containing background data
   8+ 5C29              ; input BC=DE+8
   9+ 5C29              ; input A=number of characters to process
  10+ 5C29              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  11+ 5C29              SHIFT04:
  12+ 5C29 08           	EX AF, AF'
  13+ 5C2A 7E           	LD A, (HL) ; get mask
  14+ 5C2B D9           	EXX
  15+ 5C2C 57           	LD D, A
  16+ 5C2D 1E FF        	LD E, #FF
  17+ 5C2F 37           	SCF
  18+ 5C30              .M1:
  19+ 5C30 18 FE        	JR .M1 ; this is self-modifying part
  20+ 5C32 CB 1A        	RR D
  21+ 5C34 CB 1B        	RR E
  22+ 5C36 CB 1A        	RR D
  23+ 5C38 CB 1B        	RR E
  24+ 5C3A CB 1A        	RR D
  25+ 5C3C CB 1B        	RR E
  26+ 5C3E CB 1A        	RR D
  27+ 5C40 CB 1B        	RR E
  28+ 5C42
  29+ 5C42 46           	LD B, (HL) ; get data
  30+ 5C43 0E 00        	LD C, 0
  31+ 5C45              .M2:
  32+ 5C45 18 FE        	JR .M2 ; also self-modifying part
  33+ 5C47 CB 38        	SRL B
  34+ 5C49 CB 19        	RR C
  35+ 5C4B CB 38        	SRL B
  36+ 5C4D CB 19        	RR C
  37+ 5C4F CB 38        	SRL B
  38+ 5C51 CB 19        	RR C
  39+ 5C53 CB 38        	SRL B
  40+ 5C55 CB 19        	RR C
  41+ 5C57
  42+ 5C57 D9           	EXX
  43+ 5C58 1A           	LD A, (DE) ; background
  44+ 5C59 D9           	EXX
  45+ 5C5A A2           	AND D
  46+ 5C5B B0           	OR B
  47+ 5C5C D9           	EXX
  48+ 5C5D 12           	LD (DE), A
  49+ 5C5E
  50+ 5C5E 0A           	LD A, (BC)
  51+ 5C5F D9           	EXX
  52+ 5C60 A3           	AND E
  53+ 5C61 B1           	OR C
  54+ 5C62 23           	INC HL
  55+ 5C63 D9           	EXX
  56+ 5C64 02           	LD (BC), A
  57+ 5C65
  58+ 5C65 23           	INC HL
  59+ 5C66 13           	INC DE
  60+ 5C67 03           	INC BC
  61+ 5C68
  62+ 5C68 08           	EX AF, AF'
  63+ 5C69 3D           	DEC A
  64+ 5C6A C2 29 5C     	JP NZ, SHIFT04
  65+ 5C6D C9           	RET
  66+ 5C6E              ; *******************************************************************************************************
  67+ 5C6E
  68+ 5C6E              ; *******************************************************************************************************
  69+ 5C6E              ; function rotates mask and data of several characters and applies to background data
  70+ 5C6E              ; this handles x-shift from 5 to 8
  71+ 5C6E              ; contains self-modifying code that is set-up from external function
  72+ 5C6E              ; input HL=pointer to mask data
  73+ 5C6E              ; input HL'=pointer to character data
  74+ 5C6E              ; input DE=output buffer containing background data
  75+ 5C6E              ; input BC=DE+8
  76+ 5C6E              ; input A=number of characters to process
  77+ 5C6E              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  78+ 5C6E              SHIFT58:
  79+ 5C6E 08           	EX AF, AF'
  80+ 5C6F 7E           	LD A, (HL) ; get mask
  81+ 5C70 D9           	EXX
  82+ 5C71 57           	LD D, A
  83+ 5C72 1E FF        	LD E, #FF
  84+ 5C74 37           	SCF
  85+ 5C75              .M1:
  86+ 5C75 18 FE        	JR .M1 ; this is self-modifying part
  87+ 5C77 CB 12        	RL D
  88+ 5C79 CB 13        	RL E
  89+ 5C7B CB 12        	RL D
  90+ 5C7D CB 13        	RL E
  91+ 5C7F CB 12        	RL D
  92+ 5C81 CB 13        	RL E
  93+ 5C83
  94+ 5C83 46           	LD B, (HL)
  95+ 5C84 0E 00        	LD C, 0
  96+ 5C86              .M2:
  97+ 5C86 18 FE        	JR .M2 ; also self-modifying part
  98+ 5C88 CB 20        	SLA B
  99+ 5C8A CB 11        	RL C
 100+ 5C8C CB 20        	SLA B
 101+ 5C8E CB 11        	RL C
 102+ 5C90 CB 20        	SLA B
 103+ 5C92 CB 11        	RL C
 104+ 5C94
 105+ 5C94 D9           	EXX
 106+ 5C95 1A           	LD A, (DE) ; background
 107+ 5C96 D9           	EXX
 108+ 5C97 A3           	AND E
 109+ 5C98 B1           	OR C
 110+ 5C99 D9           	EXX
 111+ 5C9A 12           	LD (DE), A
 112+ 5C9B
 113+ 5C9B 0A           	LD A, (BC)
 114+ 5C9C D9           	EXX
 115+ 5C9D A2           	AND D
 116+ 5C9E B0           	OR B
 117+ 5C9F 23           	INC HL
 118+ 5CA0 D9           	EXX
 119+ 5CA1 02           	LD (BC), A
 120+ 5CA2
 121+ 5CA2 23           	INC HL
 122+ 5CA3 13           	INC DE
 123+ 5CA4 03           	INC BC
 124+ 5CA5
 125+ 5CA5 08           	EX AF, AF'
 126+ 5CA6 3D           	DEC A
 127+ 5CA7 C2 6E 5C     	JP NZ, SHIFT58
 128+ 5CAA C9           	RET
 129+ 5CAB              ; *******************************************************************************************************
 130+ 5CAB
 131+ 5CAB              ; *******************************************************************************************************
 132+ 5CAB              ; routine that shifts one row of characters
 133+ 5CAB              ; contains self-modifying code that is set-up from external function
 134+ 5CAB              ; input HL=pointer to mask data
 135+ 5CAB              ; input HL'=pointer to character data
 136+ 5CAB              ; input DE=output buffer containing background data
 137+ 5CAB              ; input A=number of characters to process
 138+ 5CAB              ; input IX=pointer to structure describing input data
 139+ 5CAB              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 140+ 5CAB              SHIFT_ROW:
 141+ 5CAB F5           	PUSH AF
 142+ 5CAC ED 53 31 62  		LD (BLIT_TMP1), DE
 143+ 5CB0 E5           		PUSH HL
 144+ 5CB1 CD F4 5C     			CALL .ADDYSHIFT
 145+ 5CB4 E1           		POP HL
 146+ 5CB5 ED 53 33 62  		LD (BLIT_TMP2), DE ; DE+vertical shift
 147+ 5CB9              .L1:
 148+ 5CB9 3E 08        		LD A, 8
 149+ 5CBB DD 96 02     		SUB (IX+2) ; y shift
 150+ 5CBE              .CALL1:
 151+ 5CBE CD 00 00     		CALL 0
 152+ 5CC1 DD 7E 02     		LD A, (IX+2); y shift
 153+ 5CC4 B7           		OR A
 154+ 5CC5 28 26        		JR Z, .DONE
 155+ 5CC7 ED 5B 31 62  		LD DE, (BLIT_TMP1)
 156+ 5CCB E5           		PUSH HL
 157+ 5CCC CD 02 5D     			CALL .DETONEXTROW
 158+ 5CCF E1           		POP HL
 159+ 5CD0              .CALL2:
 160+ 5CD0 CD 00 00     		CALL 0
 161+ 5CD3 ED 5B 31 62  		LD DE, (BLIT_TMP1)
 162+ 5CD7 E5           		PUSH HL
 163+ 5CD8 CD FC 5C     			CALL .ADD8
 164+ 5CDB E1           		POP HL
 165+ 5CDC ED 53 31 62  		LD (BLIT_TMP1), DE
 166+ 5CE0 ED 5B 33 62  		LD DE, (BLIT_TMP2)
 167+ 5CE4 E5           		PUSH HL
 168+ 5CE5 CD FC 5C     			CALL .ADD8
 169+ 5CE8 E1           		POP HL
 170+ 5CE9 ED 53 33 62  		LD (BLIT_TMP2), DE ; DE+vertical shift
 171+ 5CED              .DONE:
 172+ 5CED F1           	POP AF
 173+ 5CEE 3D           	DEC A
 174+ 5CEF C8           	RET Z
 175+ 5CF0 F5           	PUSH AF
 176+ 5CF1 C3 B9 5C     	JP .L1
 177+ 5CF4              .ADDYSHIFT:
 178+ 5CF4 EB           	EX DE, HL
 179+ 5CF5 16 00        	LD D, 0
 180+ 5CF7 DD 5E 02     	LD E, (IX+2); y shift
 181+ 5CFA 18 0C        	JR .MOVDEBC
 182+ 5CFC              .ADD8:
 183+ 5CFC 21 08 00     	LD HL, 8
 184+ 5CFF C3 08 5D     	JP .MOVDEBC
 185+ 5D02              .DETONEXTROW:
 186+ 5D02 DD 6E 06     	LD L, (IX+6)
 187+ 5D05 DD 66 07     	LD H, (IX+7) ; bkg add to value
 188+ 5D08              .MOVDEBC:
 189+ 5D08 19           	ADD HL, DE
 190+ 5D09 54           	LD D, H
 191+ 5D0A 5D           	LD E, L
 192+ 5D0B 01 08 00     	LD BC, 8
 193+ 5D0E 09           	ADD HL, BC
 194+ 5D0F 44           	LD B, H
 195+ 5D10 4D           	LD C, L
 196+ 5D11 C9           	RET
 197+ 5D12              ; *******************************************************************************************************
 198+ 5D12
 199+ 5D12              ; *******************************************************************************************************
 200+ 5D12              ; function rotates mask and character data and applies it to background
 201+ 5D12              ; input IX=pointer to structure describing input data
 202+ 5D12              ; +0  DW horizontal shift count 0-7 (low byte used)
 203+ 5D12              ; +2  DW vertical shift count 0-7 (low byte used)
 204+ 5D12              ; +4  DW background data start;
 205+ 5D12              ; +6  DW background add to value to next row of background data
 206+ 5D12              ; +8  DW mask data start;
 207+ 5D12              ; +10  DW character data start;
 208+ 5D12              ; +12 DW character&mask add to value to next row of data
 209+ 5D12              ; +14 DW columns (low byte used)
 210+ 5D12              ; +16 DW rows (low byte used)
 211+ 5D12              SHIFT_MERGE_CHARACTER:
 212+ 5D12 DD 7E 00     	LD A, (IX) ; shift
 213+ 5D15 FE 05        	CP 5
 214+ 5D17 38 25        	JR C, .RIGHT
 215+ 5D19              	; shifts 5-7, use rotate towards left 1-3
 216+ 5D19 21 6E 5C     	LD HL, SHIFT58
 217+ 5D1C 22 BF 5C     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 218+ 5D1F 22 D1 5C     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 219+ 5D22 D6 05        	SUB 5
 220+ 5D24 28 0D        	JR Z, .L1
 221+ 5D26 87           	ADD A, A
 222+ 5D27 87           	ADD A, A
 223+ 5D28 67           	LD H, A
 224+ 5D29 2E 18        	LD L, #18 ; JR opcode
 225+ 5D2B 22 75 5C     	LD (SHIFT58.M1), HL
 226+ 5D2E 22 86 5C     	LD (SHIFT58.M2), HL
 227+ 5D31 18 32        	JR .DO
 228+ 5D33              .L1:
 229+ 5D33 21 00 00     	LD HL, 0 ; 2xNOP opcode
 230+ 5D36 22 75 5C     	LD (SHIFT58.M1), HL
 231+ 5D39 22 86 5C     	LD (SHIFT58.M2), HL
 232+ 5D3C 18 27        	JR .DO
 233+ 5D3E              .RIGHT:
 234+ 5D3E              	; shifts 0-4, rotate towards right
 235+ 5D3E 21 29 5C     	LD HL, SHIFT04
 236+ 5D41 22 BF 5C     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 237+ 5D44 22 D1 5C     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 238+ 5D47 FE 04        	CP 4
 239+ 5D49 28 11        	JR Z, .R1
 240+ 5D4B D6 04        	SUB 4
 241+ 5D4D ED 44        	NEG
 242+ 5D4F 87           	ADD A, A
 243+ 5D50 87           	ADD A, A
 244+ 5D51 67           	LD H, A
 245+ 5D52 2E 18        	LD L, #18 ; JR opcode
 246+ 5D54 22 30 5C     	LD (SHIFT04.M1), HL
 247+ 5D57 22 45 5C     	LD (SHIFT04.M2), HL
 248+ 5D5A 18 09        	JR .DO
 249+ 5D5C              .R1:
 250+ 5D5C 21 00 00     	LD HL, 0 ; 2xNOP opcode
 251+ 5D5F 22 30 5C     	LD (SHIFT04.M1), HL
 252+ 5D62 22 45 5C     	LD (SHIFT04.M2), HL
 253+ 5D65              .DO:
 254+ 5D65 DD 46 10     	LD B, (IX+16) ; rows
 255+ 5D68 DD 6E 08     	LD L, (IX+8)
 256+ 5D6B DD 66 09     	LD H, (IX+9) ; mask data
 257+ 5D6E DD 5E 04     	LD E, (IX+4)
 258+ 5D71 DD 56 05     	LD D, (IX+5) ; background data
 259+ 5D74 D9           	EXX
 260+ 5D75 DD 6E 0A     	LD L, (IX+10)
 261+ 5D78 DD 66 0B     	LD H, (IX+11) ; character data
 262+ 5D7B D9           	EXX
 263+ 5D7C              .LOOP:
 264+ 5D7C C5           	PUSH BC
 265+ 5D7D E5           		PUSH HL
 266+ 5D7E D5           			PUSH DE
 267+ 5D7F D9           				EXX
 268+ 5D80 E5           				PUSH HL
 269+ 5D81 D9           					EXX
 270+ 5D82 DD 7E 0E     					LD A, (IX+14) ; columns
 271+ 5D85              .CALL:
 272+ 5D85 CD AB 5C     					CALL SHIFT_ROW
 273+ 5D88 E1           				POP HL
 274+ 5D89 DD 5E 0C     				LD E, (IX+12)
 275+ 5D8C DD 56 0D     				LD D, (IX+13) ; char data to next row
 276+ 5D8F 19           				ADD HL, DE
 277+ 5D90 D9           				EXX
 278+ 5D91 E1           			POP HL
 279+ 5D92 DD 5E 06     			LD E, (IX+6)
 280+ 5D95 DD 56 07     			LD D, (IX+7) ; background to next row
 281+ 5D98 19           			ADD HL, DE
 282+ 5D99 EB           			EX DE, HL
 283+ 5D9A E1           		POP HL
 284+ 5D9B DD 4E 0C     		LD C, (IX+12)
 285+ 5D9E DD 46 0D     		LD B, (IX+13) ; char data to next row
 286+ 5DA1 09           		ADD HL, BC
 287+ 5DA2 C1           	POP BC
 288+ 5DA3 10 D7        	DJNZ .LOOP
 289+ 5DA5 C9           	RET
 290+ 5DA6              ; *******************************************************************************************************
 291+ 5DA6
 292+ 5DA6              ; *******************************************************************************************************
 293+ 5DA6              ; helper function DE \ 8
 294+ 5DA6              DEdiv8:
 295+ 5DA6 7B           	LD A,E
 296+ 5DA7 CB 2A        	SRA D
 297+ 5DA9 CB 1F            RR  A
 298+ 5DAB CB 2A            SRA D
 299+ 5DAD CB 1F            RR  A
 300+ 5DAF CB 2A            SRA D
 301+ 5DB1 CB 1F            RR  A
 302+ 5DB3 C9           	RET
 303+ 5DB4              ; *******************************************************************************************************
 304+ 5DB4
 305+ 5DB4               IF (0 == 1)
 306+ 5DB4 ~            ; *******************************************************************************************************
 307+ 5DB4 ~            ; function to handle BLIT basic extension through DEFUSR call in RAW format
 308+ 5DB4 ~            ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 309+ 5DB4 ~            ; +2  DW horizontal shift count 0-7 (low byte used)
 310+ 5DB4 ~            ; +4  DW vertical shift count 0-7 (low byte used)
 311+ 5DB4 ~            ; +6  DW background data start;
 312+ 5DB4 ~            ; +8  DW background add to value to next row of background data
 313+ 5DB4 ~            ; +10  DW mask data start;
 314+ 5DB4 ~            ; +12  DW character data start;
 315+ 5DB4 ~            ; +14 DW character&mask add to value to next row of data
 316+ 5DB4 ~            ; +16 DW columns (low byte used)
 317+ 5DB4 ~            ; +18 DW rows (low byte used)
 318+ 5DB4 ~            ; will put ram in page 0 also, page 1 is already there
 319+ 5DB4 ~            ;BLIT_DEFUSR:
 320+ 5DB4 ~            ;	DI
 321+ 5DB4 ~            ;	LD IY, .RET
 322+ 5DB4 ~            ;	JP ENABLE_PAGE0
 323+ 5DB4 ~            ;.RET:
 324+ 5DB4 ~            ;	EI
 325+ 5DB4 ~            ;	INC IX
 326+ 5DB4 ~            ;	INC IX
 327+ 5DB4 ~            ;	CALL SHIFT_MERGE_CHARACTER
 328+ 5DB4 ~            ;
 329+ 5DB4 ~            ;   POP DE
 330+ 5DB4 ~            ;    POP BC
 331+ 5DB4 ~            ;    JP RESTORE_PAGE_INFO
 332+ 5DB4 ~            ; *******************************************************************************************************
 333+ 5DB4 ~
 334+ 5DB4 ~            ; *******************************************************************************************************
 335+ 5DB4 ~            ; function to handle CALL BLIT basic extension in DEFUSR form
 336+ 5DB4 ~            ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 337+ 5DB4 ~            ; +02 x
 338+ 5DB4 ~            ; +04 y
 339+ 5DB4 ~            ; +06 char_data_pointer
 340+ 5DB4 ~            ; +08 mask_data_pointer
 341+ 5DB4 ~            ; +10 width
 342+ 5DB4 ~            ; +12 height
 343+ 5DB4 ~            ; +14 background_pointer
 344+ 5DB4 ~            ; +16 background_width
 345+ 5DB4 ~            ; BLIT ( INT x,
 346+ 5DB4 ~            ;		 INT y,
 347+ 5DB4 ~            ;		 INT char_data_pointer,
 348+ 5DB4 ~            ;		 INT mask_data_pointer,
 349+ 5DB4 ~            ;		 INT width (in characters),
 350+ 5DB4 ~            ;		 INT height (in characters),
 351+ 5DB4 ~            ;		 INT background_pointer (top left),
 352+ 5DB4 ~            ;		 INT background_width (in characters),
 353+ 5DB4 ~            BLIT_DEFUSR:
 354+ 5DB4 ~            	LD E,(IX+2)
 355+ 5DB4 ~            	LD D,(IX+3)
 356+ 5DB4 ~            	LD A,E
 357+ 5DB4 ~            	AND 7
 358+ 5DB4 ~            	LD (BLIT_STRUCT+0),A
 359+ 5DB4 ~            	CALL DEdiv8
 360+ 5DB4 ~            	LD (BLIT_TMP+0),A
 361+ 5DB4 ~            	LD E,(IX+4)
 362+ 5DB4 ~            	LD D,(IX+5)
 363+ 5DB4 ~            	LD A,E
 364+ 5DB4 ~            	AND 7
 365+ 5DB4 ~            	LD (BLIT_STRUCT+2),A
 366+ 5DB4 ~            	CALL DEdiv8
 367+ 5DB4 ~            	LD (BLIT_TMP+1),A
 368+ 5DB4 ~            	LD L,(IX+6)
 369+ 5DB4 ~            	LD H,(IX+7)
 370+ 5DB4 ~            	LD (BLIT_STRUCT+10),HL
 371+ 5DB4 ~            	LD L,(IX+8)
 372+ 5DB4 ~            	LD H,(IX+9)
 373+ 5DB4 ~            	LD (BLIT_STRUCT+8),HL
 374+ 5DB4 ~            	LD A,(IX+10)
 375+ 5DB4 ~            	LD (BLIT_STRUCT+14),A
 376+ 5DB4 ~            	LD A,(IX+12)
 377+ 5DB4 ~            	LD (BLIT_STRUCT+16),A
 378+ 5DB4 ~            	LD L,(IX+14)
 379+ 5DB4 ~            	LD H,(IX+15)
 380+ 5DB4 ~            	LD (BLIT_STRUCT+4),HL
 381+ 5DB4 ~            	;LD A,(IX+16)
 382+ 5DB4 ~            	;LD (BLIT_TMP+2),A
 383+ 5DB4 ~
 384+ 5DB4 ~            	; calculate char&mask add to value
 385+ 5DB4 ~            	LD H,0
 386+ 5DB4 ~            	LD A,(BLIT_STRUCT+14)
 387+ 5DB4 ~            	LD L,A
 388+ 5DB4 ~            	CALL HLx8
 389+ 5DB4 ~            	LD (BLIT_STRUCT+12),HL
 390+ 5DB4 ~            	; calculate background add to value
 391+ 5DB4 ~            	LD H,0
 392+ 5DB4 ~            	LD L,(IX+16)
 393+ 5DB4 ~            	CALL HLx8
 394+ 5DB4 ~            	LD (BLIT_STRUCT+6),HL
 395+ 5DB4 ~            	; calculate pointer to background location
 396+ 5DB4 ~            	LD HL,0
 397+ 5DB4 ~            	LD A,(BLIT_TMP+1)
 398+ 5DB4 ~            	OR A
 399+ 5DB4 ~            	JR Z, .L1
 400+ 5DB4 ~            	LD B,A
 401+ 5DB4 ~            	LD DE,(BLIT_STRUCT+6)
 402+ 5DB4 ~            .L0:
 403+ 5DB4 ~            	ADD HL, DE
 404+ 5DB4 ~            	DJNZ .L0
 405+ 5DB4 ~            .L1:
 406+ 5DB4 ~            	EX DE,HL
 407+ 5DB4 ~            	LD H,0
 408+ 5DB4 ~            	LD A,(BLIT_TMP+0)
 409+ 5DB4 ~            	LD L,A
 410+ 5DB4 ~            	CALL HLx8
 411+ 5DB4 ~            	ADD HL,DE
 412+ 5DB4 ~            	LD DE,(BLIT_STRUCT+4)
 413+ 5DB4 ~            	ADD HL,DE
 414+ 5DB4 ~            	LD (BLIT_STRUCT+4),HL
 415+ 5DB4 ~
 416+ 5DB4 ~            	LD IY, .RET
 417+ 5DB4 ~            	JP ENABLE_PAGE0
 418+ 5DB4 ~            .RET:
 419+ 5DB4 ~            	EI
 420+ 5DB4 ~            	LD IX, BLIT_STRUCT
 421+ 5DB4 ~            	CALL SHIFT_MERGE_CHARACTER
 422+ 5DB4 ~
 423+ 5DB4 ~                POP DE
 424+ 5DB4 ~                POP BC
 425+ 5DB4 ~                JP RESTORE_PAGE_INFO
 426+ 5DB4 ~            ; *******************************************************************************************************
 427+ 5DB4               ENDIF
 428+ 5DB4
 429+ 5DB4               IF (1 == 1)
 430+ 5DB4              ; *******************************************************************************************************
 431+ 5DB4              ; function to handle CALL BLIT basic extension
 432+ 5DB4              ; rotates 1-bit character drawing horizontally with mask and character data and
 433+ 5DB4              ; fuses with background data and applies vertical shift too
 434+ 5DB4              ; in form without pointers
 435+ 5DB4              ; BLIT ( INT x,
 436+ 5DB4              ;		 INT y,
 437+ 5DB4              ;		 INT char_data_pointer,
 438+ 5DB4              ;		 INT mask_data_pointer,
 439+ 5DB4              ;		 INT width (in characters),
 440+ 5DB4              ;		 INT height (in characters),
 441+ 5DB4              ;		 INT background_pointer (top left),
 442+ 5DB4              ;		 INT background_width (in characters),
 443+ 5DB4              ; will put ram in page 0 also, page 1 is already there
 444+ 5DB4              BLIT:
 445+ 5DB4              	; opening (
 446+ 5DB4 CD 45 65     	CALL CHKCHAR
 447+ 5DB7 28           	DB '('
 448+ 5DB8              	; get x coordinate
 449+ 5DB8 DD 21 2F 54  	LD IX, FRMQNT
 450+ 5DBC CD 59 01     	CALL CALBAS
 451+ 5DBF 7B           	LD A, E
 452+ 5DC0 E6 07        	AND 7
 453+ 5DC2 32 35 62     	LD (BLIT_STRUCT+0), A
 454+ 5DC5 CD A6 5D     	CALL DEdiv8
 455+ 5DC8 32 31 62     	LD (BLIT_TMP+0),A
 456+ 5DCB              	; comma
 457+ 5DCB CD 45 65     	CALL CHKCHAR
 458+ 5DCE 2C           	DB ','
 459+ 5DCF              	; get y coordinate
 460+ 5DCF DD 21 2F 54  	LD IX, FRMQNT
 461+ 5DD3 CD 59 01     	CALL CALBAS
 462+ 5DD6 7B           	LD A, E
 463+ 5DD7 E6 07        	AND 7
 464+ 5DD9 32 37 62     	LD (BLIT_STRUCT+2), A
 465+ 5DDC CD A6 5D     	CALL DEdiv8
 466+ 5DDF 32 32 62     	LD (BLIT_TMP+1),A
 467+ 5DE2              	; comma
 468+ 5DE2 CD 45 65     	CALL CHKCHAR
 469+ 5DE5 2C           	DB ','
 470+ 5DE6              	; get char data pointer
 471+ 5DE6 DD 21 2F 54  	LD IX, FRMQNT
 472+ 5DEA CD 59 01     	CALL CALBAS
 473+ 5DED ED 53 3F 62  	LD (BLIT_STRUCT+10), DE
 474+ 5DF1              	; comma
 475+ 5DF1 CD 45 65     	CALL CHKCHAR
 476+ 5DF4 2C           	DB ','
 477+ 5DF5              	; get mask data pointer
 478+ 5DF5 DD 21 2F 54  	LD IX, FRMQNT
 479+ 5DF9 CD 59 01     	CALL CALBAS
 480+ 5DFC ED 53 3D 62  	LD (BLIT_STRUCT+8), DE
 481+ 5E00              	; comma
 482+ 5E00 CD 45 65     	CALL CHKCHAR
 483+ 5E03 2C           	DB ','
 484+ 5E04              	; get width
 485+ 5E04 DD 21 2F 54  	LD IX, FRMQNT
 486+ 5E08 CD 59 01     	CALL CALBAS
 487+ 5E0B 7B           	LD A, E
 488+ 5E0C 32 43 62     	LD (BLIT_STRUCT+14), A
 489+ 5E0F              	; comma
 490+ 5E0F CD 45 65     	CALL CHKCHAR
 491+ 5E12 2C           	DB ','
 492+ 5E13              	; get height
 493+ 5E13 DD 21 2F 54  	LD IX, FRMQNT
 494+ 5E17 CD 59 01     	CALL CALBAS
 495+ 5E1A 7B           	LD A, E
 496+ 5E1B 32 45 62     	LD (BLIT_STRUCT+16), A
 497+ 5E1E              	; comma
 498+ 5E1E CD 45 65     	CALL CHKCHAR
 499+ 5E21 2C           	DB ','
 500+ 5E22              	; get background pointer
 501+ 5E22 DD 21 2F 54  	LD IX, FRMQNT
 502+ 5E26 CD 59 01     	CALL CALBAS
 503+ 5E29 ED 53 39 62  	LD (BLIT_STRUCT+4), DE
 504+ 5E2D              	; comma
 505+ 5E2D CD 45 65     	CALL CHKCHAR
 506+ 5E30 2C           	DB ','
 507+ 5E31              	; get background width
 508+ 5E31 DD 21 2F 54  	LD IX, FRMQNT
 509+ 5E35 CD 59 01     	CALL CALBAS
 510+ 5E38 7B           	LD A, E
 511+ 5E39 32 33 62     	LD (BLIT_TMP+2), A
 512+ 5E3C              	; ending )
 513+ 5E3C CD 45 65     	CALL CHKCHAR
 514+ 5E3F 29           	DB ')'
 515+ 5E40
 516+ 5E40 E5           	PUSH HL ; save position in BASIC buffer
 517+ 5E41
 518+ 5E41              	; calculate char&mask add to value
 519+ 5E41 26 00        	LD H, 0
 520+ 5E43 3A 43 62     	LD A, (BLIT_STRUCT+14)
 521+ 5E46 6F           	LD L, A
 522+ 5E47 CD 32 64     	CALL HLx8
 523+ 5E4A 22 41 62     	LD (BLIT_STRUCT+12), HL
 524+ 5E4D              	; calculate background add to value
 525+ 5E4D 26 00        	LD H, 0
 526+ 5E4F 3A 33 62     	LD A, (BLIT_TMP+2)
 527+ 5E52 6F           	LD L, A
 528+ 5E53 CD 32 64     	CALL HLx8
 529+ 5E56 22 3B 62     	LD (BLIT_STRUCT+6), HL
 530+ 5E59              	; calculate pointer to background location
 531+ 5E59 21 00 00     	LD HL, 0
 532+ 5E5C 3A 32 62     	LD A,(BLIT_TMP+1)
 533+ 5E5F B7           	OR A
 534+ 5E60 28 08        	JR Z, .L1
 535+ 5E62 47           	LD B,A
 536+ 5E63 ED 5B 3B 62  	LD DE,(BLIT_STRUCT+6)
 537+ 5E67              .L0:
 538+ 5E67 19           	ADD HL, DE
 539+ 5E68 10 FD        	DJNZ .L0
 540+ 5E6A              .L1:
 541+ 5E6A EB           	EX DE,HL
 542+ 5E6B 26 00        	LD H,0
 543+ 5E6D 3A 31 62     	LD A,(BLIT_TMP+0)
 544+ 5E70 6F           	LD L,A
 545+ 5E71 CD 32 64     	CALL HLx8
 546+ 5E74 19           	ADD HL,DE
 547+ 5E75 ED 5B 39 62  	LD DE,(BLIT_STRUCT+4)
 548+ 5E79 19           	ADD HL,DE
 549+ 5E7A 22 39 62     	LD (BLIT_STRUCT+4),HL
 550+ 5E7D
 551+ 5E7D FD 21 84 5E  	LD IY, .RET
 552+ 5E81 C3 F6 64     	JP ENABLE_PAGE0
 553+ 5E84              .RET:
 554+ 5E84 FB           	EI
 555+ 5E85 DD 21 35 62  	LD IX, BLIT_STRUCT
 556+ 5E89 CD 12 5D     	CALL SHIFT_MERGE_CHARACTER
 557+ 5E8C
 558+ 5E8C D1               POP DE
 559+ 5E8D C1               POP BC
 560+ 5E8E CD 6D 64         CALL RESTORE_PAGE_INFO
 561+ 5E91
 562+ 5E91 E1           	POP HL
 563+ 5E92 C9           	RET
 564+ 5E93              ; *******************************************************************************************************
 565+ 5E93               ENDIF
# file closed: asm\BLIT.asm
 157  5E93               ENDIF
 158  5E93
 159  5E93               IF (TILE_CMDS == 1)
 160  5E93               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
   1+ 5E93              ; *******************************************************************************************************
   2+ 5E93              ; generic function to implement tiling
   3+ 5E93              ; should be modified to call appropriate function for memory or vram
   4+ 5E93              ; input IX=pointer to following structure
   5+ 5E93              ; +00 tile_data_ptr
   6+ 5E93              ; +02 tile_rows
   7+ 5E93              ; +04 tile_columns
   8+ 5E93              ; +06 destination_address
   9+ 5E93              ; +08 dest_to_next_row_add_to_value
  10+ 5E93              ; +10 num_horizontal_tiles
  11+ 5E93              ; +12 num_vertical_tiles
  12+ 5E93              ; modifies AF, BC, DE, HL
  13+ 5E93              TILE:
  14+ 5E93 DD 6E 06     	LD L, (IX+6)
  15+ 5E96 DD 66 07     	LD H, (IX+7) ; destination address
  16+ 5E99 22 31 62     	LD (TILETMP1), HL
  17+ 5E9C DD 46 0C     	LD B, (IX+12) ; vertical tile number
  18+ 5E9F              .L1:
  19+ 5E9F C5           	PUSH BC
  20+ 5EA0 DD 6E 00     		LD L, (IX+0)
  21+ 5EA3 DD 66 01     		LD H, (IX+1) ; tile address
  22+ 5EA6 22 33 62     		LD (TILETMP2), HL
  23+ 5EA9 DD 46 02     		LD B, (IX+2) ; tile rows
  24+ 5EAC              .L2:
  25+ 5EAC C5           		PUSH BC
  26+ 5EAD CD 00 00     .CALL1:		CALL 0
  27+ 5EB0 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
  28+ 5EB3              .L3:
  29+ 5EB3 C5           			PUSH BC
  30+ 5EB4 2A 33 62     				LD HL, (TILETMP2)
  31+ 5EB7 DD 46 04     				LD B, (IX+4) ; tile columns
  32+ 5EBA              .L4:
  33+ 5EBA C5           				PUSH BC
  34+ 5EBB              .CALL2:
  35+ 5EBB CD 00 00     					CALL 0
  36+ 5EBE C1           				POP BC
  37+ 5EBF 10 F9        				DJNZ .L4
  38+ 5EC1 C1           			POP BC
  39+ 5EC2 10 EF        			DJNZ .L3
  40+ 5EC4 22 33 62     			LD (TILETMP2), HL
  41+ 5EC7 2A 31 62     			LD HL, (TILETMP1)
  42+ 5ECA DD 5E 08     			LD E, (IX+8)
  43+ 5ECD DD 56 09     			LD D, (IX+9) ; add to value for dest next row
  44+ 5ED0 19           			ADD HL, DE
  45+ 5ED1 22 31 62     			LD (TILETMP1), HL
  46+ 5ED4 C1           		POP BC
  47+ 5ED5 10 D5        		DJNZ .L2
  48+ 5ED7 C1           	POP BC
  49+ 5ED8 10 C5        	DJNZ .L1
  50+ 5EDA C9           	RET
  51+ 5EDB              ; *******************************************************************************************************
  52+ 5EDB
  53+ 5EDB               IF (0 == 1)
  54+ 5EDB ~            ; *******************************************************************************************************
  55+ 5EDB ~            ; same as TILERAM but for DEFUSR approach
  56+ 5EDB ~            ; input IX=pointer to input array, real data from +2
  57+ 5EDB ~            ; +02 = tile data pointer
  58+ 5EDB ~            ; +04 = tile columns
  59+ 5EDB ~            ; +06 = tile rows
  60+ 5EDB ~            ; +08 = destination pointer
  61+ 5EDB ~            ; +10 = destination columns
  62+ 5EDB ~            ; +12 = destination rows
  63+ 5EDB ~            ; +14 = destination begin column
  64+ 5EDB ~            ; +16 = destination begin row
  65+ 5EDB ~            ; +18 = number of tiles horizontally
  66+ 5EDB ~            ; +20 = number of tiles vertically
  67+ 5EDB ~            ; *******************************************************************************************************
  68+ 5EDB ~            TILERAM_DEFUSR:
  69+ 5EDB ~            	; tile data pointer
  70+ 5EDB ~            	LD L,(IX+2)
  71+ 5EDB ~            	LD H,(IX+3)
  72+ 5EDB ~            	LD (BLIT_STRUCT+0),HL
  73+ 5EDB ~            	; tile columns
  74+ 5EDB ~            	LD L,(IX+4)
  75+ 5EDB ~            	LD H,(IX+5)
  76+ 5EDB ~            	LD (BLIT_STRUCT+4),HL
  77+ 5EDB ~            	; tile rows
  78+ 5EDB ~            	LD L,(IX+6)
  79+ 5EDB ~            	LD H,(IX+7)
  80+ 5EDB ~            	LD (BLIT_STRUCT+2),HL
  81+ 5EDB ~            	; destintion pointer
  82+ 5EDB ~            	LD L,(IX+8)
  83+ 5EDB ~            	LD H,(IX+9)
  84+ 5EDB ~            	LD (BLIT_STRUCT+6),HL
  85+ 5EDB ~            	; destination columns
  86+ 5EDB ~            	LD A,(IX+10)
  87+ 5EDB ~            	LD (BLIT_TMP+0),A
  88+ 5EDB ~            	; destination rows
  89+ 5EDB ~            	LD A,(IX+12)
  90+ 5EDB ~            	LD (BLIT_TMP+1),A
  91+ 5EDB ~            	; destination begin column
  92+ 5EDB ~            	LD A,(IX+14)
  93+ 5EDB ~            	LD (BLIT_TMP+2),A
  94+ 5EDB ~            	; destination begin row
  95+ 5EDB ~            	LD A,(IX+16)
  96+ 5EDB ~            	LD (BLIT_TMP+3),A
  97+ 5EDB ~            	; number of tiles horizontally
  98+ 5EDB ~            	LD L,(IX+18)
  99+ 5EDB ~            	LD H,(IX+19)
 100+ 5EDB ~            	LD (BLIT_STRUCT+10),HL
 101+ 5EDB ~            	; number of tiles vertically
 102+ 5EDB ~            	LD L,(IX+20)
 103+ 5EDB ~            	LD H,(IX+21)
 104+ 5EDB ~            	LD (BLIT_STRUCT+12),HL
 105+ 5EDB ~             IF (BASIC_EXTENSION == 1) ; otherwise we just continue with code below
 106+ 5EDB ~            	JP TILERAM.COMMON
 107+ 5EDB ~             ENDIF
 108+ 5EDB               ENDIF
 109+ 5EDB
 110+ 5EDB              ; *******************************************************************************************************
 111+ 5EDB              ; function to handle CALL TILERAM basic extension
 112+ 5EDB              ; fills memory with tiles
 113+ 5EDB              ; TILERAM ( INT tile_data_pointer,
 114+ 5EDB              ;			INT tile_columns,
 115+ 5EDB              ;			INT tile_rows,
 116+ 5EDB              ;			INT destination_pointer,
 117+ 5EDB              ;			INT destination_columns,
 118+ 5EDB              ;			INT destination_rows,
 119+ 5EDB              ;			INT destination_begin_column,
 120+ 5EDB              ;			INT destination_begin_row,
 121+ 5EDB              ;			INT number_of_tiles_horizontally,
 122+ 5EDB              ;			INT	number_of_tiles_vertically )
 123+ 5EDB              ; will put ram in page 0 also, page 1 is already there
 124+ 5EDB              TILERAM:
 125+ 5EDB               IF (1 == 1)
 126+ 5EDB              	; opening (
 127+ 5EDB CD 45 65     	CALL CHKCHAR
 128+ 5EDE 28           	DB '('
 129+ 5EDF              	; get tile data pointer coordinate
 130+ 5EDF DD 21 2F 54  	LD IX, FRMQNT
 131+ 5EE3 CD 59 01     	CALL CALBAS
 132+ 5EE6 ED 53 35 62  	LD (BLIT_STRUCT+0), DE
 133+ 5EEA              	; comma
 134+ 5EEA CD 45 65     	CALL CHKCHAR
 135+ 5EED 2C           	DB ','
 136+ 5EEE              	; get tile columns
 137+ 5EEE DD 21 2F 54  	LD IX, FRMQNT
 138+ 5EF2 CD 59 01     	CALL CALBAS
 139+ 5EF5 ED 53 39 62  	LD (BLIT_STRUCT+4), DE
 140+ 5EF9              	; comma
 141+ 5EF9 CD 45 65     	CALL CHKCHAR
 142+ 5EFC 2C           	DB ','
 143+ 5EFD              	; get tile columns
 144+ 5EFD DD 21 2F 54  	LD IX, FRMQNT
 145+ 5F01 CD 59 01     	CALL CALBAS
 146+ 5F04 ED 53 37 62  	LD (BLIT_STRUCT+2), DE
 147+ 5F08              	; comma
 148+ 5F08 CD 45 65     	CALL CHKCHAR
 149+ 5F0B 2C           	DB ','
 150+ 5F0C              	; get destintion pointer
 151+ 5F0C DD 21 2F 54  	LD IX, FRMQNT
 152+ 5F10 CD 59 01     	CALL CALBAS
 153+ 5F13 ED 53 3B 62  	LD (BLIT_STRUCT+6), DE
 154+ 5F17              	; comma
 155+ 5F17 CD 45 65     	CALL CHKCHAR
 156+ 5F1A 2C           	DB ','
 157+ 5F1B              	; get destination columns
 158+ 5F1B DD 21 2F 54  	LD IX, FRMQNT
 159+ 5F1F CD 59 01     	CALL CALBAS
 160+ 5F22 7B           	LD A, E
 161+ 5F23 32 31 62     	LD (BLIT_TMP+0), A
 162+ 5F26              	; comma
 163+ 5F26 CD 45 65     	CALL CHKCHAR
 164+ 5F29 2C           	DB ','
 165+ 5F2A              	; get destination rows
 166+ 5F2A DD 21 2F 54  	LD IX, FRMQNT
 167+ 5F2E CD 59 01     	CALL CALBAS
 168+ 5F31 7B           	LD A, E
 169+ 5F32 32 32 62     	LD (BLIT_TMP+1), A
 170+ 5F35              	; comma
 171+ 5F35 CD 45 65     	CALL CHKCHAR
 172+ 5F38 2C           	DB ','
 173+ 5F39              	; get destination begin column
 174+ 5F39 DD 21 2F 54  	LD IX, FRMQNT
 175+ 5F3D CD 59 01     	CALL CALBAS
 176+ 5F40 7B           	LD A, E
 177+ 5F41 32 33 62     	LD (BLIT_TMP+2), A
 178+ 5F44              	; comma
 179+ 5F44 CD 45 65     	CALL CHKCHAR
 180+ 5F47 2C           	DB ','
 181+ 5F48              	; get destination begin row
 182+ 5F48 DD 21 2F 54  	LD IX, FRMQNT
 183+ 5F4C CD 59 01     	CALL CALBAS
 184+ 5F4F 7B           	LD A, E
 185+ 5F50 32 34 62     	LD (BLIT_TMP+3), A
 186+ 5F53              	; comma
 187+ 5F53 CD 45 65     	CALL CHKCHAR
 188+ 5F56 2C           	DB ','
 189+ 5F57              	; get number of tiles horizontally
 190+ 5F57 DD 21 2F 54  	LD IX, FRMQNT
 191+ 5F5B CD 59 01     	CALL CALBAS
 192+ 5F5E ED 53 3F 62  	LD (BLIT_STRUCT+10), DE
 193+ 5F62              	; comma
 194+ 5F62 CD 45 65     	CALL CHKCHAR
 195+ 5F65 2C           	DB ','
 196+ 5F66              	; get number of tiles vertically
 197+ 5F66 DD 21 2F 54  	LD IX, FRMQNT
 198+ 5F6A CD 59 01     	CALL CALBAS
 199+ 5F6D ED 53 41 62  	LD (BLIT_STRUCT+12), DE
 200+ 5F71              	; ending )
 201+ 5F71 CD 45 65     	CALL CHKCHAR
 202+ 5F74 29           	DB ')'
 203+ 5F75               ENDIF
 204+ 5F75              .COMMON:
 205+ 5F75 E5           	PUSH HL ; save position in BASIC buffer
 206+ 5F76
 207+ 5F76              	; calculate destination add to value
 208+ 5F76 26 00        	LD H, 0
 209+ 5F78 3A 31 62     	LD A, (BLIT_TMP+0)
 210+ 5F7B 6F           	LD L, A
 211+ 5F7C CD 32 64     	CALL HLx8
 212+ 5F7F 22 3D 62     	LD (BLIT_STRUCT+8), HL
 213+ 5F82              	; calculate pointer to background location
 214+ 5F82 21 00 00     	LD HL, 0
 215+ 5F85 3A 34 62     	LD A,(BLIT_TMP+3)
 216+ 5F88 B7           	OR A
 217+ 5F89 28 08        	JR Z, .L1
 218+ 5F8B 47           	LD B,A
 219+ 5F8C ED 5B 3D 62  	LD DE,(BLIT_STRUCT+8)
 220+ 5F90              .L0:
 221+ 5F90 19           	ADD HL, DE
 222+ 5F91 10 FD        	DJNZ .L0
 223+ 5F93              .L1:
 224+ 5F93 EB           	EX DE,HL
 225+ 5F94 26 00        	LD H,0
 226+ 5F96 3A 33 62     	LD A,(BLIT_TMP+2)
 227+ 5F99 6F           	LD L,A
 228+ 5F9A CD 32 64     	CALL HLx8
 229+ 5F9D 19           	ADD HL,DE
 230+ 5F9E ED 5B 3B 62  	LD DE,(BLIT_STRUCT+6)
 231+ 5FA2 19           	ADD HL,DE
 232+ 5FA3 22 3B 62     	LD (BLIT_STRUCT+6),HL
 233+ 5FA6 FD 21 AD 5F  	LD IY, .RET
 234+ 5FAA C3 F6 64     	JP ENABLE_PAGE0
 235+ 5FAD              .RET:
 236+ 5FAD FB           	EI
 237+ 5FAE              	; set RAM functions to call
 238+ 5FAE 21 C8 5F     	LD HL, .TILECOPY
 239+ 5FB1 22 BC 5E     	LD (TILE.CALL2+1), HL
 240+ 5FB4 21 D9 5F     	LD HL, .SETDESTROW
 241+ 5FB7 22 AE 5E     	LD (TILE.CALL1+1), HL
 242+ 5FBA DD 21 35 62  	LD IX,BLIT_STRUCT
 243+ 5FBE CD 93 5E     	CALL TILE
 244+ 5FC1
 245+ 5FC1 D1               POP DE
 246+ 5FC2 C1               POP BC
 247+ 5FC3 CD 6D 64         CALL RESTORE_PAGE_INFO
 248+ 5FC6
 249+ 5FC6 E1           	POP HL
 250+ 5FC7 C9           	RET
 251+ 5FC8              .TILECOPY:
 252+ 5FC8 ED A0       > LDI
 252+ 5FCA ED A0       > LDI
 252+ 5FCC ED A0       > LDI
 252+ 5FCE ED A0       > LDI
 252+ 5FD0 ED A0       > LDI
 252+ 5FD2 ED A0       > LDI
 252+ 5FD4 ED A0       > LDI
 252+ 5FD6 ED A0       > LDI
 253+ 5FD8 C9           	RET
 254+ 5FD9              .SETDESTROW:
 255+ 5FD9 ED 5B 31 62  	LD DE, (TILETMP1)
 256+ 5FDD C9           	RET
 257+ 5FDE              ; *******************************************************************************************************
 258+ 5FDE
 259+ 5FDE               IF (0 == 1)
 260+ 5FDE ~            ; *******************************************************************************************************
 261+ 5FDE ~            ; same as TILEVRM but for DEFUSR approach
 262+ 5FDE ~            ; input IX=pointer to input array, real data from +2
 263+ 5FDE ~            ; +02 = tile data pointer
 264+ 5FDE ~            ; +04 = tile columns
 265+ 5FDE ~            ; +06 = tile rows
 266+ 5FDE ~            ; +08 = destination begin column
 267+ 5FDE ~            ; +10 = destination begin row
 268+ 5FDE ~            ; +12 = number of tiles horizontally
 269+ 5FDE ~            ; +14 = number of tiles vertically
 270+ 5FDE ~            ; *******************************************************************************************************
 271+ 5FDE ~            TILEVRM_DEFUSR:
 272+ 5FDE ~            	; tile data pointer
 273+ 5FDE ~            	LD L,(IX+2)
 274+ 5FDE ~            	LD H,(IX+3)
 275+ 5FDE ~            	LD (BLIT_STRUCT+0),HL
 276+ 5FDE ~            	; tile columns
 277+ 5FDE ~            	LD L,(IX+4)
 278+ 5FDE ~            	LD H,(IX+5)
 279+ 5FDE ~            	LD (BLIT_STRUCT+4),HL
 280+ 5FDE ~            	; tile rows
 281+ 5FDE ~            	LD L,(IX+6)
 282+ 5FDE ~            	LD H,(IX+7)
 283+ 5FDE ~            	LD (BLIT_STRUCT+2),HL
 284+ 5FDE ~            	; destination begin column
 285+ 5FDE ~            	LD A,(IX+8)
 286+ 5FDE ~            	LD (BLIT_TMP+2),A
 287+ 5FDE ~            	; destination begin row
 288+ 5FDE ~            	LD A,(IX+10)
 289+ 5FDE ~            	LD (BLIT_TMP+3),A
 290+ 5FDE ~            	; number of tiles horizontally
 291+ 5FDE ~            	LD L,(IX+12)
 292+ 5FDE ~            	LD H,(IX+13)
 293+ 5FDE ~            	LD (BLIT_STRUCT+10),HL
 294+ 5FDE ~            	; number of tiles vertically
 295+ 5FDE ~            	LD L,(IX+14)
 296+ 5FDE ~            	LD H,(IX+15)
 297+ 5FDE ~            	LD (BLIT_STRUCT+12),HL
 298+ 5FDE ~             IF (BASIC_EXTENSION == 1) ; otherwise we just continue with code below
 299+ 5FDE ~            	JP TILEVRM.COMMON
 300+ 5FDE ~             ENDIF
 301+ 5FDE               ENDIF
 302+ 5FDE
 303+ 5FDE              ; *******************************************************************************************************
 304+ 5FDE              ; function to handle CALL TILEVRM basic extension
 305+ 5FDE              ; fills vram with tiles
 306+ 5FDE              ; TILEVRM ( INT tile_data_pointer,
 307+ 5FDE              ;			INT tile_columns,
 308+ 5FDE              ;			INT tile_rows,
 309+ 5FDE              ;			INT destination_begin_column,
 310+ 5FDE              ;			INT destination_begin_row,
 311+ 5FDE              ;			INT number_of_tiles_horizontally,
 312+ 5FDE              ;			INT	number_of_tiles_vertically )
 313+ 5FDE              ; will put ram in page 0 also, page 1 is already there
 314+ 5FDE              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
 315+ 5FDE              TILEVRM:
 316+ 5FDE               IF (1 == 1)
 317+ 5FDE              	; opening (
 318+ 5FDE CD 45 65     	CALL CHKCHAR
 319+ 5FE1 28           	DB '('
 320+ 5FE2              	; get tile data pointer coordinate
 321+ 5FE2 DD 21 2F 54  	LD IX, FRMQNT
 322+ 5FE6 CD 59 01     	CALL CALBAS
 323+ 5FE9 ED 53 35 62  	LD (BLIT_STRUCT+0), DE
 324+ 5FED              	; comma
 325+ 5FED CD 45 65     	CALL CHKCHAR
 326+ 5FF0 2C           	DB ','
 327+ 5FF1              	; get tile columns
 328+ 5FF1 DD 21 2F 54  	LD IX, FRMQNT
 329+ 5FF5 CD 59 01     	CALL CALBAS
 330+ 5FF8 ED 53 39 62  	LD (BLIT_STRUCT+4), DE
 331+ 5FFC              	; comma
 332+ 5FFC CD 45 65     	CALL CHKCHAR
 333+ 5FFF 2C           	DB ','
 334+ 6000              	; get tile columns
 335+ 6000 DD 21 2F 54  	LD IX, FRMQNT
 336+ 6004 CD 59 01     	CALL CALBAS
 337+ 6007 ED 53 37 62  	LD (BLIT_STRUCT+2), DE
 338+ 600B              	; comma
 339+ 600B CD 45 65     	CALL CHKCHAR
 340+ 600E 2C           	DB ','
 341+ 600F              	; get destination begin column
 342+ 600F DD 21 2F 54  	LD IX, FRMQNT
 343+ 6013 CD 59 01     	CALL CALBAS
 344+ 6016 7B           	LD A, E
 345+ 6017 32 33 62     	LD (BLIT_TMP+2), A
 346+ 601A              	; comma
 347+ 601A CD 45 65     	CALL CHKCHAR
 348+ 601D 2C           	DB ','
 349+ 601E              	; get destination begin row
 350+ 601E DD 21 2F 54  	LD IX, FRMQNT
 351+ 6022 CD 59 01     	CALL CALBAS
 352+ 6025 7B           	LD A, E
 353+ 6026 32 34 62     	LD (BLIT_TMP+3), A
 354+ 6029              	; comma
 355+ 6029 CD 45 65     	CALL CHKCHAR
 356+ 602C 2C           	DB ','
 357+ 602D              	; get number of tiles horizontally
 358+ 602D DD 21 2F 54  	LD IX, FRMQNT
 359+ 6031 CD 59 01     	CALL CALBAS
 360+ 6034 ED 53 3F 62  	LD (BLIT_STRUCT+10), DE
 361+ 6038              	; comma
 362+ 6038 CD 45 65     	CALL CHKCHAR
 363+ 603B 2C           	DB ','
 364+ 603C              	; get number of tiles vertically
 365+ 603C DD 21 2F 54  	LD IX, FRMQNT
 366+ 6040 CD 59 01     	CALL CALBAS
 367+ 6043 ED 53 41 62  	LD (BLIT_STRUCT+12), DE
 368+ 6047              	; ending )
 369+ 6047 CD 45 65     	CALL CHKCHAR
 370+ 604A 29           	DB ')'
 371+ 604B               ENDIF
 372+ 604B
 373+ 604B              .COMMON:
 374+ 604B E5           	PUSH HL ; save position in BASIC buffer
 375+ 604C
 376+ 604C              	; calculate destination add to value
 377+ 604C 21 00 01     	LD HL, 256
 378+ 604F 22 3D 62     	LD (BLIT_STRUCT+8), HL
 379+ 6052              	; calculate pointer to background location
 380+ 6052 3A 34 62     	LD A,(BLIT_TMP+3)
 381+ 6055 67           	LD H,A
 382+ 6056 2E 00        	LD L,0
 383+ 6058 EB           	EX DE,HL
 384+ 6059 26 00        	LD H,0
 385+ 605B 3A 33 62     	LD A,(BLIT_TMP+2)
 386+ 605E 6F           	LD L,A
 387+ 605F CD 32 64     	CALL HLx8
 388+ 6062 19           	ADD HL,DE
 389+ 6063 ED 5B CB F3  	LD DE,(GRPCGP)
 390+ 6067 19           	ADD HL,DE
 391+ 6068 22 3B 62     	LD (BLIT_STRUCT+6),HL
 392+ 606B FD 21 72 60  	LD IY, .RET
 393+ 606F C3 F6 64     	JP ENABLE_PAGE0
 394+ 6072              .RET:
 395+ 6072 FB           	EI
 396+ 6073              	; set RAM functions to call
 397+ 6073 21 8D 60     	LD HL, .TILECOPY
 398+ 6076 22 BC 5E     	LD (TILE.CALL2+1), HL
 399+ 6079 21 93 60     	LD HL, .SETDESTROW
 400+ 607C 22 AE 5E     	LD (TILE.CALL1+1), HL
 401+ 607F DD 21 35 62  	LD IX,BLIT_STRUCT
 402+ 6083 CD 93 5E     	CALL TILE
 403+ 6086
 404+ 6086 D1               POP DE
 405+ 6087 C1               POP BC
 406+ 6088 CD 6D 64         CALL RESTORE_PAGE_INFO
 407+ 608B
 408+ 608B E1           	POP HL
 409+ 608C C9           	RET
 410+ 608D              .TILECOPY:
 411+ 608D 01 98 08     	LD BC, #0898
 412+ 6090 C3 2A 64     	JP BBYTECOPY_NO_C
 413+ 6093              .SETDESTROW:
 414+ 6093 2A 31 62     	LD HL, (TILETMP1)
 415+ 6096 F3           	DI
 416+ 6097 CD 1D 64     	CALL SETWRT_LOCAL
 417+ 609A FB           	EI
 418+ 609B C9           	RET
 419+ 609C              ; *******************************************************************************************************
 420+ 609C
# file closed: asm\TILE.asm
 161  609C               ENDIF
 162  609C
 163  609C               IF (COLL_CMD == 1)
 164  609C               INCLUDE "COLLISION.asm"
# file opened: asm\COLLISION.asm
   1+ 609C              ; generic collision checking routines
   2+ 609C              ; in BASIC we use rectangle structure array DIM R%(7,n) of the format
   3+ 609C              ; R%(0,n) is active flag, <>0 active / 0 skipped in checks
   4+ 609C              ; R%(1,n) is either upper left x coordinate or sprite id (0-31) depending on R(7,n)
   5+ 609C              ; R%(2,n) is either upper left y coordinate or unused depending on R(7,n)
   6+ 609C              ; R%(3,n) x offset where rectangle begins
   7+ 609C              ; R%(4,n) y offset where rectangle begins
   8+ 609C              ; R%(5,n) is width
   9+ 609C              ; R%(6,n) is height
  10+ 609C              ; R%(7,0) is type, 0=generic where R%(1,0) contains x coordinate
  11+ 609C              ;                  <>0 sprite where R%(1,0) contains sprite id
  12+ 609C              ; for type sprite, upper left coordinates are taken from sprite attribute array
  13+ 609C
  14+ 609C              ; ************************************************************************************************
  15+ 609C              ; quick test if HL<=DE<=HL+BC
  16+ 609C              ; input BC=width, DE=x, HL=min
  17+ 609C              ; if not true flag C set
  18+ 609C              ; modifies AF
  19+ 609C              GENERIC_INNER_CHECK:
  20+ 609C E5               PUSH HL
  21+ 609D D5               PUSH DE
  22+ 609E EB               EX DE,HL
  23+ 609F A7               AND A
  24+ 60A0 ED 52            SBC HL, DE
  25+ 60A2 FA B0 60         JP M, .GENERIC_INNER_CHECK_NOT
  26+ 60A5 A7               AND A
  27+ 60A6 ED 42            SBC HL, BC
  28+ 60A8 28 03            JR Z, .L2
  29+ 60AA F2 B0 60         JP P, .GENERIC_INNER_CHECK_NOT
  30+ 60AD              .L2:
  31+ 60AD A7               AND A
  32+ 60AE 18 01            JR .EXIT
  33+ 60B0              .GENERIC_INNER_CHECK_NOT:
  34+ 60B0 37               SCF
  35+ 60B1              .EXIT:
  36+ 60B1 D1               POP DE
  37+ 60B2 E1               POP HL
  38+ 60B3 C9               RET
  39+ 60B4              ; ************************************************************************************************
  40+ 60B4
  41+ 60B4              ; ************************************************************************************************
  42+ 60B4              ; function to check if rectangles are overlapping
  43+ 60B4              ; input IX=IY=pointer to struct
  44+ 60B4              ;  +00 active flag
  45+ 60B4              ;  +02 x coordinate
  46+ 60B4              ;  +04 y coordinate
  47+ 60B4              ;  +06 x offset where rectangle begins
  48+ 60B4              ;  +08 y offset where rectangle begins
  49+ 60B4              ;  +10 width
  50+ 60B4              ;  +12 height
  51+ 60B4              ; where IY is used to read +2 and +4, and IX to read +6, +8, +10 and +12
  52+ 60B4              ; this is a hack to allow location being taken from sprite attributes table
  53+ 60B4              ; input BLIT_STRUCT data
  54+ 60B4              ;  +00 x coordinate
  55+ 60B4              ;  +02 y coordinate
  56+ 60B4              ;  +04 width
  57+ 60B4              ;  +06 height
  58+ 60B4              ; returns CF=1 if not overlapping, CF=0 if overlapping
  59+ 60B4              RECTANGLE_OVERLAP_CHECK:
  60+ 60B4                  ; first check which rectangle is higher
  61+ 60B4 DD 6E 0C         LD L,(IX+12)
  62+ 60B7 DD 66 0D         LD H,(IX+13)
  63+ 60BA ED 5B 3B 62      LD DE,(BLIT_STRUCT+6)
  64+ 60BE A7               AND A
  65+ 60BF ED 52            SBC HL,DE
  66+ 60C1 FD 6E 04         LD L,(IY+4)
  67+ 60C4 FD 66 05         LD H,(IY+5)
  68+ 60C7 DD 5E 08         LD E,(IX+8)
  69+ 60CA DD 56 09         LD D,(IX+9)
  70+ 60CD FA ED 60         JP M,.L1
  71+ 60D0                  ; equally high or IX defined one higher
  72+ 60D0                  ; check upper boundary
  73+ 60D0 19               ADD HL,DE
  74+ 60D1 ED 5B 37 62      LD DE,(BLIT_STRUCT+2)
  75+ 60D5 DD 4E 0C         LD C,(IX+12)
  76+ 60D8 DD 46 0D         LD B,(IX+13)
  77+ 60DB CD 9C 60         CALL GENERIC_INNER_CHECK
  78+ 60DE 30 29            JR NC,.INSIDE
  79+ 60E0                  ; check lower boundary
  80+ 60E0 E5               PUSH HL
  81+ 60E1 2A 3B 62         LD HL,(BLIT_STRUCT+6)
  82+ 60E4 19               ADD HL,DE
  83+ 60E5 EB               EX DE,HL
  84+ 60E6 E1               POP HL
  85+ 60E7 CD 9C 60         CALL GENERIC_INNER_CHECK
  86+ 60EA 30 1D            JR NC,.INSIDE
  87+ 60EC C9               RET ; not overlapping
  88+ 60ED              .L1:
  89+ 60ED                  ; rectangle defined in BLIT_STRUCT is higher
  90+ 60ED 19               ADD HL,DE
  91+ 60EE EB               EX DE,HL
  92+ 60EF 2A 37 62         LD HL,(BLIT_STRUCT+2)
  93+ 60F2 ED 4B 3B 62      LD BC,(BLIT_STRUCT+6)
  94+ 60F6 CD 9C 60         CALL GENERIC_INNER_CHECK
  95+ 60F9 30 0E            JR NC,.INSIDE
  96+ 60FB E5               PUSH HL
  97+ 60FC DD 6E 0C         LD L,(IX+12)
  98+ 60FF DD 66 0D         LD H,(IX+13)
  99+ 6102 19               ADD HL,DE
 100+ 6103 EB               EX DE,HL
 101+ 6104 E1               POP HL
 102+ 6105 CD 9C 60         CALL GENERIC_INNER_CHECK
 103+ 6108 D8               RET C
 104+ 6109              .INSIDE:
 105+ 6109                  ; check x coordinate
 106+ 6109                  ; first check which rectangle is wider
 107+ 6109 DD 6E 0A         LD L,(IX+10)
 108+ 610C DD 66 0B         LD H,(IX+11)
 109+ 610F ED 5B 39 62      LD DE,(BLIT_STRUCT+4)
 110+ 6113 A7               AND A
 111+ 6114 ED 52            SBC HL,DE
 112+ 6116 FD 6E 02         LD L,(IY+2)
 113+ 6119 FD 66 03         LD H,(IY+3)
 114+ 611C DD 5E 06         LD E,(IX+6)
 115+ 611F DD 56 07         LD D,(IX+7)
 116+ 6122 FA 3E 61         JP M,.L2
 117+ 6125                  ; equally wide or IX defined one wider
 118+ 6125                  ; check left boundary
 119+ 6125 19               ADD HL,DE
 120+ 6126 ED 5B 35 62      LD DE,(BLIT_STRUCT+0)
 121+ 612A DD 4E 0A         LD C,(IX+10)
 122+ 612D DD 46 0B         LD B,(IX+11)
 123+ 6130 CD 9C 60         CALL GENERIC_INNER_CHECK
 124+ 6133 D0               RET NC ; overlap
 125+ 6134                  ; check right boundary
 126+ 6134 E5               PUSH HL
 127+ 6135 2A 39 62         LD HL,(BLIT_STRUCT+4)
 128+ 6138 19               ADD HL,DE
 129+ 6139 EB               EX DE,HL
 130+ 613A E1               POP HL
 131+ 613B C3 9C 60         JP GENERIC_INNER_CHECK ; CF and result set by fn call
 132+ 613E              .L2:
 133+ 613E                  ; rectangle defined in BLIT_STRUCT is higher
 134+ 613E 19               ADD HL,DE
 135+ 613F EB               EX DE,HL
 136+ 6140 2A 35 62         LD HL,(BLIT_STRUCT+0)
 137+ 6143 ED 4B 39 62      LD BC,(BLIT_STRUCT+4)
 138+ 6147 CD 9C 60         CALL GENERIC_INNER_CHECK
 139+ 614A D0               RET NC ; overlap
 140+ 614B E5               PUSH HL
 141+ 614C DD 6E 0A         LD L,(IX+10)
 142+ 614F DD 66 0B         LD H,(IX+11)
 143+ 6152 19               ADD HL,DE
 144+ 6153 EB               EX DE,HL
 145+ 6154 E1               POP HL
 146+ 6155 C3 9C 60         JP GENERIC_INNER_CHECK
 147+ 6158              ; ************************************************************************************************
 148+ 6158
 149+ 6158              ; ************************************************************************************************
 150+ 6158              ; function tries to find rectangle overlap and returns an index if found
 151+ 6158              ; input BLIT_STRUCT data
 152+ 6158              ;  +00 x coordinate
 153+ 6158              ;  +02 y coordinate
 154+ 6158              ;  +04 width
 155+ 6158              ;  +06 height
 156+ 6158              ;  +08 number of items in a list, described under RECTANGLE_OVERLAP_CHECK
 157+ 6158              ;  +09 pointer to first element of R%(7,n)
 158+ 6158              ;  +11 pointer to INT result variable
 159+ 6158              ; returns CF=1 if not overlapping
 160+ 6158              ; returns A=list index and CF=0 if overlapping
 161+ 6158              FIND_OVERLAP:
 162+ 6158 3A 3D 62         LD A,(BLIT_STRUCT+8)
 163+ 615B 47               LD B,A
 164+ 615C DD 2A 3E 62      LD IX,(BLIT_STRUCT+9)
 165+ 6160              .L1:
 166+ 6160 C5               PUSH BC
 167+ 6161                  ; check active flag
 168+ 6161 DD 7E 00         LD A,(IX)
 169+ 6164 DD B6 01         OR (IX+1)
 170+ 6167 28 18            JR Z,.NEXT
 171+ 6169                  ; check type
 172+ 6169 DD 7E 0E         LD A,(IX+14)
 173+ 616C DD B6 0F         OR (IX+15)
 174+ 616F 20 1A            JR NZ,.L2
 175+ 6171 DD E5            PUSH IX
 176+ 6173 FD E1            POP IY
 177+ 6175              .L3:
 178+ 6175 CD B4 60         CALL RECTANGLE_OVERLAP_CHECK
 179+ 6178 38 07            JR C,.NEXT
 180+ 617A                  ; found
 181+ 617A C1               POP BC
 182+ 617B 3A 3D 62         LD A,(BLIT_STRUCT+8)
 183+ 617E 90               SUB B
 184+ 617F A7               AND A
 185+ 6180 C9               RET
 186+ 6181              .NEXT:
 187+ 6181 11 10 00         LD DE,16
 188+ 6184 DD 19            ADD IX,DE
 189+ 6186 C1               POP BC
 190+ 6187 10 D7            DJNZ .L1
 191+ 6189 37               SCF
 192+ 618A C9               RET
 193+ 618B              .L2:
 194+ 618B                  ; sprite, need to build a temporary data struct since x and y values are inversed
 195+ 618B                  ; at BLIT_STRUCT+13
 196+ 618B DD 7E 02         LD A,(IX+2) ; sprite ID
 197+ 618E CD 89 4D         CALL GETnthSPRATTR
 198+ 6191 FD 21 40 62      LD IY,BLIT_STRUCT+11
 199+ 6195 7E               LD A,(HL)
 200+ 6196 FD 77 04         LD (IY+4),A
 201+ 6199 23               INC HL
 202+ 619A 7E               LD A,(HL)
 203+ 619B FD 77 05         LD (IY+5),A
 204+ 619E 23               INC HL
 205+ 619F 7E               LD A,(HL)
 206+ 61A0 FD 77 02         LD (IY+2),A
 207+ 61A3 23               INC HL
 208+ 61A4 7E               LD A,(HL)
 209+ 61A5 FD 77 03         LD (IY+3),A
 210+ 61A8 18 CB            JR .L3
 211+ 61AA              ; ************************************************************************************************
 212+ 61AA
 213+ 61AA               IF (1 == 1)
 214+ 61AA              ; ************************************************************************************************
 215+ 61AA              ; function to handle CALL COLL basic extension
 216+ 61AA              ; checks for collision between player and other rectangles
 217+ 61AA              ; COLL ( INT result variable,
 218+ 61AA              ;	     INT player x value,
 219+ 61AA              ;	     INT player y value,
 220+ 61AA              ;	     INT player width,
 221+ 61AA              ;	     INT player height,
 222+ 61AA              ;	     INT number of items in a list,
 223+ 61AA              ;		 INT[6][n] rectangle struct )
 224+ 61AA              ; will fill result variable with index or -1 if no collision
 225+ 61AA              ; rectangle struct described under RECTANGLE_OVERLAP_CHECK
 226+ 61AA              COLL:
 227+ 61AA              	; opening (
 228+ 61AA CD 45 65     	CALL CHKCHAR
 229+ 61AD 28           	DB '('
 230+ 61AE              	; get address of result variable
 231+ 61AE DD 21 A4 5E  	LD IX, PTRGET
 232+ 61B2 CD 59 01     	CALL CALBAS
 233+ 61B5 ED 53 40 62  	LD (BLIT_STRUCT+11),DE
 234+ 61B9              	; comma
 235+ 61B9 CD 45 65     	CALL CHKCHAR
 236+ 61BC 2C           	DB ','
 237+ 61BD              	; get x
 238+ 61BD DD 21 2F 54  	LD IX, FRMQNT
 239+ 61C1 CD 59 01     	CALL CALBAS
 240+ 61C4 ED 53 35 62  	LD (BLIT_STRUCT+0),DE
 241+ 61C8              	; comma
 242+ 61C8 CD 45 65     	CALL CHKCHAR
 243+ 61CB 2C           	DB ','
 244+ 61CC              	; get y
 245+ 61CC DD 21 2F 54  	LD IX, FRMQNT
 246+ 61D0 CD 59 01     	CALL CALBAS
 247+ 61D3 ED 53 37 62  	LD (BLIT_STRUCT+2),DE
 248+ 61D7              	; comma
 249+ 61D7 CD 45 65     	CALL CHKCHAR
 250+ 61DA 2C           	DB ','
 251+ 61DB              	; get width
 252+ 61DB DD 21 2F 54  	LD IX, FRMQNT
 253+ 61DF CD 59 01     	CALL CALBAS
 254+ 61E2 ED 53 39 62  	LD (BLIT_STRUCT+4),DE
 255+ 61E6              	; comma
 256+ 61E6 CD 45 65     	CALL CHKCHAR
 257+ 61E9 2C           	DB ','
 258+ 61EA              	; get height
 259+ 61EA DD 21 2F 54  	LD IX, FRMQNT
 260+ 61EE CD 59 01     	CALL CALBAS
 261+ 61F1 ED 53 3B 62  	LD (BLIT_STRUCT+6),DE
 262+ 61F5              	; comma
 263+ 61F5 CD 45 65     	CALL CHKCHAR
 264+ 61F8 2C           	DB ','
 265+ 61F9              	; get number of items in a list
 266+ 61F9 DD 21 1C 52  	LD IX, GETBYT
 267+ 61FD CD 59 01     	CALL CALBAS
 268+ 6200 32 3D 62     	LD (BLIT_STRUCT+8),A
 269+ 6203              	; comma
 270+ 6203 CD 45 65     	CALL CHKCHAR
 271+ 6206 2C           	DB ','
 272+ 6207              	; get address of rectangle structure array DIM R%(7,n)
 273+ 6207 3A 3D 62     	LD A,(BLIT_STRUCT+8)
 274+ 620A 5F               LD E,A
 275+ 620B 3E 02            LD A,2
 276+ 620D 47           	LD B,A
 277+ 620E 16 07        	LD D,7
 278+ 6210 CD 72 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
 279+ 6213 ED 43 3E 62  	LD (BLIT_STRUCT+9),BC
 280+ 6217              	; ending )
 281+ 6217 CD 45 65     	CALL CHKCHAR
 282+ 621A 29           	DB ')'
 283+ 621B
 284+ 621B E5               PUSH HL
 285+ 621C CD 58 61         CALL FIND_OVERLAP
 286+ 621F 2A 40 62         LD HL,(BLIT_STRUCT+11)
 287+ 6222 38 06            JR C,.NOTFOUND
 288+ 6224 77               LD (HL),A
 289+ 6225 23               INC HL
 290+ 6226 36 00            LD (HL),0
 291+ 6228 E1               POP HL
 292+ 6229 C9               RET
 293+ 622A              .NOTFOUND:
 294+ 622A 36 FF            LD (HL),#FF
 295+ 622C 23               INC HL
 296+ 622D 36 FF            LD (HL),#FF
 297+ 622F E1               POP HL
 298+ 6230 C9               RET
 299+ 6231              ; ************************************************************************************************
 300+ 6231               ENDIF
 301+ 6231
 302+ 6231               IF (0 == 1)
 303+ 6231 ~            ; *******************************************************************************************************
 304+ 6231 ~            ; same as COLL but for DEFUSR approach
 305+ 6231 ~            ; input IX=pointer to input array, real data from +2
 306+ 6231 ~            ; +02 = pointer to result variable
 307+ 6231 ~            ; +04 = player X
 308+ 6231 ~            ; +06 = player Y
 309+ 6231 ~            ; +08 = player width
 310+ 6231 ~            ; +10 = player height
 311+ 6231 ~            ; +12 = number of list items
 312+ 6231 ~            ; +14 = pointer to list of collidable objects
 313+ 6231 ~            COLL_DEFUSR:
 314+ 6231 ~                PUSH IX
 315+ 6231 ~                POP HL
 316+ 6231 ~                .4 INC HL ; skip over to player x
 317+ 6231 ~                LD DE,BLIT_STRUCT
 318+ 6231 ~                LD BC,9
 319+ 6231 ~                LDIR ; copy over x,y,w,h,list item number
 320+ 6231 ~                LD A,(IX+14)
 321+ 6231 ~                LD (BLIT_STRUCT+9),A
 322+ 6231 ~                LD A,(IX+15)
 323+ 6231 ~                LD (BLIT_STRUCT+10),A ; address to collidable objects array
 324+ 6231 ~                LD A,(IX+2)
 325+ 6231 ~                LD (BLIT_STRUCT+11),A
 326+ 6231 ~                LD A,(IX+3)
 327+ 6231 ~                LD (BLIT_STRUCT+12),A ; address to results variable
 328+ 6231 ~                PUSH IX
 329+ 6231 ~                CALL FIND_OVERLAP
 330+ 6231 ~                POP IX
 331+ 6231 ~                LD L,(IX+2)
 332+ 6231 ~                LD H,(IX+3)
 333+ 6231 ~                JR C,.NOTFOUND
 334+ 6231 ~                LD (HL),A
 335+ 6231 ~                INC HL
 336+ 6231 ~                LD (HL),0
 337+ 6231 ~                RET
 338+ 6231 ~            .NOTFOUND:
 339+ 6231 ~                LD (HL),#FF
 340+ 6231 ~                INC HL
 341+ 6231 ~                LD (HL),#FF
 342+ 6231 ~                RET
 343+ 6231 ~            ; *******************************************************************************************************
 344+ 6231               ENDIF
 345+ 6231
# file closed: asm\COLLISION.asm
 165  6231               ENDIF
 166  6231
 167  6231               IF (0 == 1)
 168  6231 ~             INCLUDE "DEFUSR.asm"
 169  6231               ENDIF
 170  6231
 171  6231              ; temp variables for BLIT, TILE functions
 172  6231               IF (BLIT_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS + COLL_CMD > 0)
 173  6231              BLIT_TMP:
 174  6231              TILETMP1:
 175  6231              BLIT_TMP1:
 176  6231 00 00         DW 0
 177  6233              TILETMP2:
 178  6233              BLIT_TMP2:
 179  6233 00 00         DW 0
 180  6235              BLIT_STRUCT:
 181  6235 00 00 00...   DS 17
 182  6239               ENDIF
 183  6246
 184  6246               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 185  6246              VRAM_UPDATE_IN_PROGRESS:
 186  6246 00            DB 0
 187  6247               ENDIF
 188  6247
 189  6247              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 190  6247              ; per starting letter, if no commands with this letter, NULL value
 191  6247              CMDS:
 192  6247 85 63        	DW CMDS_A ; always present due to ARTINFO
 193  6249               IF (BLIT_CMDS + BOX_CMDS > 0) && (1 == 1)
 194  6249 48 63            DW CMDS_B ; B
 195  624B               ELSE
 196  624B ~            	DW 0
 197  624B               ENDIF
 198  624B               IF (COLL_CMD == 1) && (1 == 1)
 199  624B 7D 63        	DW CMDS_C ;
 200  624D               ELSE
 201  624D ~                DW 0 ; C
 202  624D               ENDIF
 203  624D 00 00            DW 0 ; D
 204  624F 00 00            DW 0 ; E
 205  6251               IF (VRAM_CMDS + RAM_CMDS > 0) && (1 == 1)
 206  6251 C8 62            DW CMDS_F; F
 207  6253               ELSE
 208  6253 ~            	DW 0
 209  6253               ENDIF
 210  6253               IF (GENCAL_CMD > 0) && (1 == 1)
 211  6253 DB 62            DW CMDS_G; G
 212  6255               ELSE
 213  6255 ~            	DW 0
 214  6255               ENDIF
 215  6255 00 00            DW 0 ; H
 216  6257 00 00            DW 0 ; I
 217  6259 00 00            DW 0 ; J
 218  625B 00 00            DW 0 ; K
 219  625D 00 00            DW 0 ; L
 220  625F               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0) && (1 == 1)
 221  625F 7B 62            DW CMDS_M ; M
 222  6261               ELSE
 223  6261 ~            	DW 0
 224  6261               ENDIF
 225  6261 00 00            DW 0 ; N
 226  6263 00 00            DW 0 ; O
 227  6265 00 00            DW 0 ; P
 228  6267 00 00            DW 0 ; Q
 229  6269 00 00            DW 0 ; R
 230  626B               IF (SOUND_CMDS + SPRITE_CMDS > 0) && (1 == 1)
 231  626B EF 62            DW CMDS_S ; S
 232  626D               ELSE
 233  626D ~            	DW 0
 234  626D               ENDIF
 235  626D               IF (TILE_CMDS > 0) && (1 == 1)
 236  626D 68 63            DW CMDS_T ; T
 237  626F               ELSE
 238  626F ~            	DW 0
 239  626F               ENDIF
 240  626F 00 00            DW 0 ; U
 241  6271               IF (VRAM_CMDS > 0) && (1 == 1)
 242  6271 E5 62            DW CMDS_V ; V
 243  6273               ELSE
 244  6273 ~            	DW 0
 245  6273               ENDIF
 246  6273 00 00            DW 0 ; W
 247  6275 00 00            DW 0 ; X
 248  6277 00 00            DW 0 ; Y
 249  6279 00 00            DW 0 ; Z
 250  627B
 251  627B               IF (1 == 1)
 252  627B              CMDS_M:
 253  627B               IF (VRAM_CMDS == 1)
 254  627B 4D 45 4D 56      DB "MEMVRM", 0
 254  627F 52 4D 00
 255  6282 F4 59            DW MEMVRM
 256  6284               ENDIF
 257  6284               IF (RAM_CMDS == 1)
 258  6284 4D 45 4D 43  	DB "MEMCPY", 0
 258  6288 50 59 00
 259  628B 32 58        	DW MEMCPY
 260  628D               ENDIF
 261  628D               IF (ANIM_CMDS == 1)
 262  628D 4D 41 58 41  	DB "MAXANIMITEMS",0
 262  6291 4E 49 4D 49
 262  6295 54 45 4D 53
 262  6299 00
 263  629A A0 4F        	DW MAXANIMITEMS
 264  629C 4D 41 58 41  	DB "MAXANIMDEFS",0
 264  62A0 4E 49 4D 44
 264  62A4 45 46 53 00
 265  62A8 30 51        	DW MAXANIMDEFS
 266  62AA 4D 41 58 41  	DB "MAXANIMSPRS",0
 266  62AE 4E 49 4D 53
 266  62B2 50 52 53 00
 267  62B6 C6 51        	DW MAXANIMSPRS
 268  62B8 4D 41 58 41     DB "MAXAUTOSGAMS",0
 268  62BC 55 54 4F 53
 268  62C0 47 41 4D 53
 268  62C4 00
 269  62C5 10 53           DW MAXAUTOSGAMS
 270  62C7               ENDIF
 271  62C7               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 272  62C7 00           	DB 0
 273  62C8               ENDIF
 274  62C8              CMDS_F:
 275  62C8               IF (VRAM_CMDS == 1)
 276  62C8 46 49 4C 56      DB "FILVRM", 0
 276  62CC 52 4D 00
 277  62CF A5 59            DW FILVRM
 278  62D1               ENDIF
 279  62D1               IF (RAM_CMDS == 1)
 280  62D1 46 49 4C 52      DB "FILRAM", 0
 280  62D5 41 4D 00
 281  62D8 75 58            DW FILRAM
 282  62DA               ENDIF
 283  62DA               IF (VRAM_CMDS + RAM_CMDS > 0)
 284  62DA 00               DB 0
 285  62DB               ENDIF
 286  62DB              CMDS_G:
 287  62DB               IF (GENCAL_CMD == 1)
 288  62DB 47 45 4E 43      DB "GENCAL", 0
 288  62DF 41 4C 00
 289  62E2 D4 5A            DW GENCAL
 290  62E4               ENDIF
 291  62E4               IF (GENCAL_CMD > 0)
 292  62E4 00           	DB	0
 293  62E5               ENDIF
 294  62E5              CMDS_V:
 295  62E5               IF (VRAM_CMDS == 1)
 296  62E5 56 52 4D 4D  	DB "VRMMEM", 0
 296  62E9 45 4D 00
 297  62EC 73 5A        	DW VRMMEM
 298  62EE               ENDIF
 299  62EE               IF (VRAM_CMDS > 0)
 300  62EE 00           	DB 0
 301  62EF               ENDIF
 302  62EF              CMDS_S:
 303  62EF               IF (SPRITE_CMDS + ANIM_CMDS > 0)
 304  62EF 53 47 41 4D      DB "SGAM",0
 304  62F3 00
 305  62F4 9E 56            DW SGAM
 306  62F6               ENDIF
 307  62F6               IF (SPRITE_CMDS == 1)
 308  62F6 53 50 52 47  	DB "SPRGRPMOV", 0
 308  62FA 52 50 4D 4F
 308  62FE 56 00
 309  6300 F8 4E        	DW SPRGRPMOV
 310  6302               ENDIF
 311  6302               IF (SOUND_CMDS == 1)
 312  6302 53 4E 44 53  	DB "SNDSFX", 0
 312  6306 46 58 00
 313  6309 4B 59        	DW SNDSFX
 314  630B 53 4E 44 50  	DB "SNDPLYON", 0
 314  630F 4C 59 4F 4E
 314  6313 00
 315  6314 15 59        	DW SNDPLYON
 316  6316 53 4E 44 50  	DB "SNDPLYOFF", 0
 316  631A 4C 59 4F 46
 316  631E 46 00
 317  6320 28 59        	DW SNDPLYOFF
 318  6322 53 4E 44 50  	DB "SNDPLYINI", 0
 318  6326 4C 59 49 4E
 318  632A 49 00
 319  632C CB 58        	DW SNDPLYINIT
 320  632E               ENDIF
 321  632E               IF (SPRITE_CMDS == 1)
 322  632E 53 50 52 45  	DB "SPRENABLE", 0
 322  6332 4E 41 42 4C
 322  6336 45 00
 323  6338 6E 4E        	DW SPRENABLE
 324  633A 53 50 52 44  	DB "SPRDISABLE", 0
 324  633E 49 53 41 42
 324  6342 4C 45 00
 325  6345 B5 4E        	DW SPRDISABLE
 326  6347               ENDIF
 327  6347               IF (SOUND_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 328  6347 00           	DB 0
 329  6348               ENDIF
 330  6348              CMDS_B:
 331  6348               IF (BLIT_CMDS == 1)
 332  6348 42 4C 49 54  	DB "BLIT", 0
 332  634C 00
 333  634D B4 5D        	DW BLIT
 334  634F               ENDIF
 335  634F               IF (BOX_CMDS == 1)
 336  634F 42 4F 58 4D  	DB "BOXMEMCPY", 0
 336  6353 45 4D 43 50
 336  6357 59 00
 337  6359 63 5B        	DW BOXMEMCPY
 338  635B 42 4F 58 4D  	DB "BOXMEMVRM", 0
 338  635F 45 4D 56 52
 338  6363 4D 00
 339  6365 F8 5B        	DW BOXMEMVRM
 340  6367               ENDIF
 341  6367               IF (BLIT_CMDS + BOX_CMDS > 0)
 342  6367 00           	DB 0
 343  6368               ENDIF
 344  6368              CMDS_T:
 345  6368               IF (TILE_CMDS == 1)
 346  6368 54 49 4C 45  	DB "TILERAM", 0
 346  636C 52 41 4D 00
 347  6370 DB 5E        	DW TILERAM
 348  6372 54 49 4C 45  	DB "TILEVRM", 0
 348  6376 56 52 4D 00
 349  637A DE 5F        	DW TILEVRM
 350  637C               ENDIF
 351  637C               IF (TILE_CMDS > 0)
 352  637C 00           	DB 0
 353  637D               ENDIF
 354  637D              CMDS_C:
 355  637D               IF (COLL_CMD == 1)
 356  637D 43 4F 4C 4C      DB "COLL", 0
 356  6381 00
 357  6382 AA 61            DW COLL
 358  6384               ENDIF
 359  6384               IF (COLL_CMD > 0)
 360  6384 00           	DB	0
 361  6385               ENDIF
 362  6385              CMDS_A:
 363  6385               IF (ANIM_CMDS == 1)
 364  6385 41 4E 49 4D     DB "ANIMSTEP",0
 364  6389 53 54 45 50
 364  638D 00
 365  638E E0 54           DW ANIMSTEP
 366  6390 41 4E 49 4D  	DB "ANIMSTART",0
 366  6394 53 54 41 52
 366  6398 54 00
 367  639A E5 54        	DW ANIMSTART
 368  639C 41 4E 49 4D  	DB "ANIMSTOP",0
 368  63A0 53 54 4F 50
 368  63A4 00
 369  63A5 EA 54        	DW ANIMSTOP
 370  63A7 41 4E 49 4D  	DB "ANIMITEMPAT",0
 370  63AB 49 54 45 4D
 370  63AF 50 41 54 00
 371  63B3 71 50        	DW ANIMITEMPAT
 372  63B5 41 4E 49 4D  	DB "ANIMITEMPTR",0
 372  63B9 49 54 45 4D
 372  63BD 50 54 52 00
 373  63C1 D7 50        	DW ANIMITEMPTR_CMD
 374  63C3 41 4E 49 4D  	DB "ANIMDEF",0
 374  63C7 44 45 46 00
 375  63CB 73 51        	DW ANIMDEF
 376  63CD 41 4E 49 4D  	DB "ANIMSPRITE",0
 376  63D1 53 50 52 49
 376  63D5 54 45 00
 377  63D8 1F 52        	DW ANIMSPRITE
 378  63DA 41 4E 49 4D     DB "ANIMCHAR",0
 378  63DE 43 48 41 52
 378  63E2 00
 379  63E3 97 52           DW ANIMCHAR
 380  63E5 41 55 54 4F     DB "AUTOSGAMDEF",0
 380  63E9 53 47 41 4D
 380  63ED 44 45 46 00
 381  63F1 6D 53           DW AUTOSGAMDEF
 382  63F3 41 55 54 4F     DB "AUTOSGAMSTART",0
 382  63F7 53 47 41 4D
 382  63FB 53 54 41 52
 382  63FF 54 00
 383  6401 A1 54           DW AUTOSGAMSTART
 384  6403 41 55 54 4F     DB "AUTOSGAMSTOP",0
 384  6407 53 47 41 4D
 384  640B 53 54 4F 50
 384  640F 00
 385  6410 DD 54           DW AUTOSGAMSTOP
 386  6412               ENDIF
 387  6412 41 52 54 49     DB "ARTINFO",0
 387  6416 4E 46 4F 00
 388  641A A7 65           DW ARTINFO
 389  641C 00           	DB 0
 390  641D               ELSE
 391  641D ~            CMDS_A:
 392  641D ~             DB "ARTINFO",0
 393  641D ~             DW ARTINFO
 394  641D ~             DB 0
 395  641D               ENDIF
 396  641D
 397  641D
 398  641D               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 399  641D              ; ****************************************************************************************************
 400  641D              ; function sets VRAM address
 401  641D              ; input HL=address
 402  641D              ; modifies AF
 403  641D              SETWRT_LOCAL:
 404  641D 7D           	LD	A,L
 405  641E D3 99        	OUT (099H),A
 406  6420 7C           	LD	A,H
 407  6421 E6 3F        	AND 03FH
 408  6423 F6 40        	OR	040H
 409  6425 D3 99        	OUT (099H),A
 410  6427 C9           	RET
 411  6428              ; ****************************************************************************************************
 412  6428               ENDIF
 413  6428
 414  6428               IF (VRAM_CMDS + TILE_CMDS > 0)
 415  6428              ; ****************************************************************************************************
 416  6428              ; function copies data from RAM to VRAM
 417  6428              ; input HL=address in RAM
 418  6428              ; input B=count
 419  6428              ; modifies AF, BC, HL
 420  6428              BBYTECOPY:
 421  6428 0E 98        	LD C,#98
 422  642A              BBYTECOPY_NO_C:
 423  642A ED A3        	OUTI
 424  642C C2 2A 64     	JP	NZ, BBYTECOPY_NO_C
 425  642F C9           	RET
 426  6430              ; ****************************************************************************************************
 427  6430               ENDIF
 428  6430
 429  6430              ; ****************************************************************************************************
 430  6430              ; function multiplies HL by 32
 431  6430              HLx32:
 432  6430 29           	ADD HL,HL
 433  6431              ; ****************************************************************************************************
 434  6431              ; function multiplies HL by 16
 435  6431              HLx16:
 436  6431 29           	ADD HL,HL
 437  6432              ; ****************************************************************************************************
 438  6432              ; function multiplies HL by 8
 439  6432              HLx8:
 440  6432 29          > ADD HL, HL
 440  6433 29          > ADD HL, HL
 440  6434 29          > ADD HL, HL
 441  6435 C9           	RET
 442  6436              ; ****************************************************************************************************
 443  6436
 444  6436              ; ****************************************************************************************************
 445  6436              ; function gets slot and subslot data for specific page
 446  6436              ; input A=page (0, 1 or 2)
 447  6436              ; output B = 0A8H register value
 448  6436              ; output D = 0 is no subslots, 1 if yes
 449  6436              ; output C = 0A8H value when page 3 slot equals to requested page slot
 450  6436              ; output E = subslot value if present
 451  6436              ; modifies AF, BC, DE, HL
 452  6436              GET_PAGE_INFO:
 453  6436 6F               LD L, A
 454  6437 C6 C1            ADD A, low (EXPTBL)
 455  6439 32 43 64         LD (GET_PAGE_INFO_L1+1), A
 456  643C DB A8            IN A, (0A8H)
 457  643E 47               LD B, A
 458  643F E6 3F            AND 03FH
 459  6441 4F               LD C, A
 460  6442              GET_PAGE_INFO_L1:
 461  6442 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 462  6445 E6 80            AND 080H
 463  6447 28 1B            JR Z, GET_PAGE_INFO_L2
 464  6449                  ; expanded
 465  6449 2D               DEC L
 466  644A FA 69 64         JP M, GET_PAGE_INFO_L3
 467  644D 2D               DEC L
 468  644E FA 67 64         JP M, GET_PAGE_INFO_L4
 469  6451                  ; page 2
 470  6451 07               RLCA
 471  6452 07               RLCA
 472  6453              GET_PAGE_INFO_L5:
 473  6453 E6 C0            AND 0C0H
 474  6455 B1               OR C
 475  6456 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 476  6458 4F               LD C, A
 477  6459 3A FF FF         LD A, (0FFFFH)
 478  645C 2F               CPL
 479  645D 5F               LD E, A
 480  645E 16 01            LD D, 1
 481  6460 78               LD A, B ; return stack
 482  6461 D3 A8            OUT (0A8H), A
 483  6463 C9               RET
 484  6464              GET_PAGE_INFO_L2:
 485  6464                  ; not expanded
 486  6464 16 00            LD D, 0
 487  6466 C9               RET
 488  6467              GET_PAGE_INFO_L4:
 489  6467                  ; page 1
 490  6467 0F               RRCA
 491  6468 0F               RRCA
 492  6469              GET_PAGE_INFO_L3:
 493  6469                  ; page 0
 494  6469 0F               RRCA
 495  646A 0F               RRCA
 496  646B 18 E6            JR GET_PAGE_INFO_L5
 497  646D              ; ****************************************************************************************************
 498  646D
 499  646D              ; ****************************************************************************************************
 500  646D              ; function returns original slot and subslot info
 501  646D              ; input B = 0A8H register value
 502  646D              ; input D = 0 is no subslots, 1 if yes
 503  646D              ; input C = 0A8H value when page 3 slot equals to requested page slot
 504  646D              ; input E = subslot value if present
 505  646D              ; modifies AF, disables interrupts
 506  646D              RESTORE_PAGE_INFO:
 507  646D F3              DI
 508  646E 7A              LD A, D
 509  646F B7              OR A
 510  6470 28 07           JR Z, RESTORE_PAGE_INFO_L1
 511  6472 79              LD A, C
 512  6473 D3 A8           OUT (0A8H), A
 513  6475 7B              LD A, E
 514  6476 32 FF FF        LD (0FFFFH), A
 515  6479              RESTORE_PAGE_INFO_L1:
 516  6479 78              LD A, B
 517  647A D3 A8           OUT (0A8H), A
 518  647C              NOACTION_DEFUSR: ; just a safe RET for use when DEFUSR table has an empty entry
 519  647C C9              RET
 520  647D              ; ****************************************************************************************************
 521  647D
 522  647D              ; *******************************************************************************************************
 523  647D              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 524  647D              ; INPUT:  A = SLOT ID: EXXXSSPP
 525  647D              ; E = EXPANDED FLAG
 526  647D              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 527  647D              ; PP = PRIMARY SLOT NUMBER
 528  647D              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 529  647D              ; CHANGES: AF, BC, DE
 530  647D
 531  647D              LOCAL_ENASLT:
 532  647D CD 9D 64         CALL L0353
 533  6480 FA 8A 64         JP M, L0340
 534  6483 DB A8            IN A, (0A8H)
 535  6485 A1               AND C
 536  6486 B0               OR B
 537  6487 D3 A8            OUT (0A8H), A
 538  6489 C9               RET
 539  648A              L0340:
 540  648A E5               PUSH HL
 541  648B CD C2 64         CALL L0378
 542  648E 4F               LD C, A
 543  648F 06 00            LD B, 0
 544  6491 7D               LD A, L
 545  6492 A4               AND H
 546  6493 B2               OR D
 547  6494 21 C5 FC         LD HL, 0FCC5H
 548  6497 09               ADD HL, BC
 549  6498 77               LD (HL), A
 550  6499 E1               POP HL
 551  649A 79               LD A, C
 552  649B 18 E0            JR LOCAL_ENASLT
 553  649D              L0353:
 554  649D F3               DI
 555  649E F5               PUSH AF
 556  649F 7C               LD A, H
 557  64A0 07               RLCA
 558  64A1 07               RLCA
 559  64A2 E6 03            AND 3
 560  64A4 5F               LD E, A
 561  64A5 3E C0            LD A, 0C0H
 562  64A7              L035D:
 563  64A7 07               RLCA
 564  64A8 07               RLCA
 565  64A9 1D               DEC E
 566  64AA F2 A7 64         JP P, L035D
 567  64AD 5F               LD E, A
 568  64AE 2F               CPL
 569  64AF 4F               LD C, A
 570  64B0 F1               POP AF
 571  64B1 F5               PUSH AF
 572  64B2 E6 03            AND 3
 573  64B4 3C               INC A
 574  64B5 47               LD B, A
 575  64B6 3E AB            LD A, 0ABH
 576  64B8              L036E:
 577  64B8 C6 55            ADD A, 055H
 578  64BA 10 FC            DJNZ L036E
 579  64BC 57               LD D, A
 580  64BD A3               AND E
 581  64BE 47               LD B, A
 582  64BF F1               POP AF
 583  64C0 A7               AND A
 584  64C1 C9               RET
 585  64C2              L0378:
 586  64C2 F5               PUSH AF
 587  64C3 7A               LD A, D
 588  64C4 E6 C0            AND 0C0H
 589  64C6 4F               LD C, A
 590  64C7 F1               POP AF
 591  64C8 F5               PUSH AF
 592  64C9 57               LD D, A
 593  64CA DB A8            IN A, (0A8H)
 594  64CC 47               LD B, A
 595  64CD E6 3F            AND 03FH
 596  64CF B1               OR C
 597  64D0 D3 A8            OUT (0A8H), A
 598  64D2 7A               LD A, D
 599  64D3 0F               RRCA
 600  64D4 0F               RRCA
 601  64D5 E6 03            AND 3
 602  64D7 57               LD D, A
 603  64D8 3E AB            LD A, 0ABH
 604  64DA              L0390:
 605  64DA C6 55            ADD A, 055H
 606  64DC 15               DEC D
 607  64DD F2 DA 64         JP P, L0390
 608  64E0 A3               AND E
 609  64E1 57               LD D, A
 610  64E2 7B               LD A, E
 611  64E3 2F               CPL
 612  64E4 67               LD H, A
 613  64E5 3A FF FF         LD A, (0FFFFH)
 614  64E8 2F               CPL
 615  64E9 6F               LD L, A
 616  64EA A4               AND H
 617  64EB B2               OR D
 618  64EC 32 FF FF         LD (0FFFFH), A
 619  64EF 78               LD A, B
 620  64F0 D3 A8            OUT (0A8H), A
 621  64F2 F1               POP AF
 622  64F3 E6 03            AND 3
 623  64F5 C9               RET
 624  64F6              ; *******************************************************************************************************
 625  64F6
 626  64F6              ; *******************************************************************************************************
 627  64F6              ; some common code to activate page 0 and place values needed to restore original page on stack
 628  64F6              ; input IY=return address
 629  64F6              ENABLE_PAGE0:
 630  64F6 F3              DI
 631  64F7 AF              XOR A
 632  64F8 CD 36 64        CALL GET_PAGE_INFO
 633  64FB C5              PUSH BC
 634  64FC D5              PUSH DE
 635  64FD 3A 41 F3        LD A, (RAMAD0)
 636  6500 26 00           LD H, 0
 637  6502 CD 7D 64        CALL LOCAL_ENASLT
 638  6505 FD E9        	JP (IY)
 639  6507              ; *******************************************************************************************************
 640  6507
 641  6507              ; General BASIC CALL-instruction handler
 642  6507              CALLHAND:
 643  6507 FB              EI
 644  6508 E5           	PUSH HL
 645  6509 21 47 62     	LD	HL, CMDS ; pointer table based on starting letter
 646  650C 3A 89 FD        LD A, (PROCNM)
 647  650F D6 41           SUB 'A'
 648  6511 87              ADD A, A
 649  6512 16 00           LD D, 0
 650  6514 5F              LD E, A
 651  6515 19              ADD HL, DE
 652  6516 5E              LD E, (HL)
 653  6517 23              INC HL
 654  6518 56              LD D, (HL)
 655  6519 7A              LD A, D
 656  651A B3              OR E
 657  651B 28 23           JR Z, .CMDNOTRECOGNIZED
 658  651D EB              EX DE, HL
 659  651E              .CHKCMD:
 660  651E 11 89 FD     	LD	DE, PROCNM
 661  6521              .LOOP:
 662  6521 1A              LD	A,(DE)
 663  6522 BE           	CP	(HL)
 664  6523 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 665  6525 13           	INC	DE
 666  6526 23           	INC	HL
 667  6527 A7           	AND	A
 668  6528 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 669  652A 5E           	LD	E,(HL)
 670  652B 23           	INC	HL
 671  652C 56           	LD	D,(HL)
 672  652D E1           	POP	HL		; routine address
 673  652E CD 4F 65     	CALL	GETPREVCHAR
 674  6531 CD 43 65     	CALL	.CALLDE		; Call routine
 675  6534 A7           	AND	A
 676  6535 C9           	RET
 677  6536
 678  6536              .TONEXTCMD:
 679  6536 0E FF        	LD	C,0FFH
 680  6538 AF           	XOR	A
 681  6539 ED B1        	CPIR			; Skip to end of instruction name
 682  653B 23           	INC	HL
 683  653C 23           	INC	HL		; Skip address
 684  653D BE           	CP	(HL)
 685  653E 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 686  6540              .CMDNOTRECOGNIZED:
 687  6540 E1           	POP	HL
 688  6541 37              SCF
 689  6542 C9           	RET
 690  6543
 691  6543              .CALLDE:
 692  6543 D5           	PUSH	DE
 693  6544 C9           	RET
 694  6545
 695  6545              ;---------------------------
 696  6545
 697  6545              ;GETSTRPNT:
 698  6545              ; OUT:
 699  6545              ; HL = String Address
 700  6545              ; B  = Lenght
 701  6545              ;        LD      HL,(USR)
 702  6545              ;        LD      B,(HL)
 703  6545              ;        INC     HL
 704  6545              ;        LD      E,(HL)
 705  6545              ;        INC     HL
 706  6545              ;        LD      D,(HL)
 707  6545              ;        EX      DE,HL
 708  6545              ;        RET
 709  6545
 710  6545              ;EVALTXTPARAM:
 711  6545              ;	CALL	CHKCHAR
 712  6545              ;	DEFB	"("             ; Check for (
 713  6545              ;	LD	IX,FRMEVL
 714  6545              ;	CALL	CALBAS		; Evaluate expression
 715  6545              ;       LD      A,(VALTYP)
 716  6545              ;        CP      3               ; Text type?
 717  6545              ;        JP      NZ,TYPE_MISMATCH
 718  6545              ;        PUSH	HL
 719  6545              ;        LD	IX,FRESTR         ; Free the temporary string
 720  6545              ;        CALL	CALBAS
 721  6545              ;        POP	HL
 722  6545              ;	CALL	CHKCHAR
 723  6545              ;	DEFB	")"             ; Check for )
 724  6545              ;        RET
 725  6545
 726  6545
 727  6545              CHKCHAR:
 728  6545 CD 4F 65     	CALL	GETPREVCHAR	; Get previous basic char
 729  6548 E3           	EX	(SP),HL
 730  6549 BE           	CP	(HL) 	        ; Check if good char
 731  654A 20 1D        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 732  654C 23           	INC	HL
 733  654D E3           	EX	(SP),HL
 734  654E 23           	INC	HL		; Get next basic char
 735  654F
 736  654F              GETPREVCHAR:
 737  654F 2B           	DEC HL
 738  6550 DD 21 66 46  	LD	IX,CHRGTR
 739  6554 CD 59 01     	CALL CALBAS
 740  6557 FB              EI
 741  6558 C9              RET
 742  6559
 743  6559
 744  6559              TYPE_MISMATCH:
 745  6559 1E 0D            LD E, 13 ; Type mismatch
 746  655B 18 0E            JR THROW_ERROR
 747  655D              SUBSCRIPT_OUT_OF_RANGE:
 748  655D 1E 09            LD E,9 ; subscript out of range
 749  655F 18 0A        	JR THROW_ERROR
 750  6561              OVERFLOW:
 751  6561 1E 06        	LD E,6
 752  6563 18 06        	JR THROW_ERROR
 753  6565              ILLEGAL_FUNCTION:
 754  6565 1E 05            LD E, 5 ; illegal function call
 755  6567 18 02            JR THROW_ERROR
 756  6569              SYNTAX_ERROR:
 757  6569 1E 02            LD E, 2 ; Syntax error
 758  656B              THROW_ERROR:
 759  656B DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 760  656F C3 59 01     	JP	CALBAS
 761  6572
 762  6572              ;---------------------------
 763  6572
 764  6572               IF (1 == 1)
 765  6572              ; *******************************************************************************************************
 766  6572              ; helper function to get pointer to BASIC array data
 767  6572              ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
 768  6572              ; input B=dimensions (1 or 2)
 769  6572              ; input D=minimal first dimension
 770  6572              ; input E=minimal second dimension, if applicable
 771  6572              ; returns BC=pointer to first data element
 772  6572              ; throws BASIC error if invalid type
 773  6572              GET_BASIC_ARRAY_DATA_POINTER:
 774  6572 D5           	PUSH DE
 775  6573 C5           	PUSH BC
 776  6574 F5           	PUSH AF
 777  6575 3E 01           LD A,1
 778  6577 32 A5 F6        LD (SUBFLG),A ; search for arrays only
 779  657A DD 21 A4 5E  	LD IX, PTRGET
 780  657E CD 59 01     	CALL CALBAS
 781  6581 AF              XOR A
 782  6582 32 A5 F6        LD (SUBFLG),A ; if not reset will cause syntax errors
 783  6585 3A 63 F6     	LD A,(VALTYP)
 784  6588 D1           	POP DE ; required type
 785  6589 BA           	CP D
 786  658A C2 59 65     	JP NZ,TYPE_MISMATCH
 787  658D 0A           	LD A,(BC)
 788  658E 03           	INC BC
 789  658F D1           	POP DE ; required number of dimensions
 790  6590 BA           	CP D
 791  6591 C2 59 65     	JP NZ,TYPE_MISMATCH
 792  6594 D1           	POP DE ; required minimal array dimensions
 793  6595 3D           	DEC A
 794  6596 28 07        	JR Z,.ONE_DIMENSION
 795  6598              	; 2-dimension array
 796  6598 0A           	LD A,(BC)
 797  6599 03          > INC BC
 797  659A 03          > INC BC
 798  659B BB           	CP E
 799  659C DA 5D 65     	JP C,SUBSCRIPT_OUT_OF_RANGE
 800  659F              .ONE_DIMENSION:
 801  659F 0A           	LD A,(BC)
 802  65A0 03          > INC BC
 802  65A1 03          > INC BC
 803  65A2 BA           	CP D
 804  65A3 DA 5D 65     	JP C,SUBSCRIPT_OUT_OF_RANGE
 805  65A6 C9           	RET
 806  65A7              ; *******************************************************************************************************
 807  65A7               ENDIF
 808  65A7
 809  65A7              ; *******************************************************************************************************
 810  65A7              ; function to handle CALL ARTINFO basic extension
 811  65A7              ; returns info about the extension
 812  65A7              ; _ARTINFO ( INT variable version,
 813  65A7              ;			    INT variable build_flags,
 814  65A7              ;			    INT variable free_memory_ptr )
 815  65A7              ; this function is always available and can be used to test if the extension is active
 816  65A7              ARTINFO:
 817  65A7              	; opening (
 818  65A7 CD 45 65     	CALL CHKCHAR
 819  65AA 28           	DB '('
 820  65AB              	; get address of version variable
 821  65AB DD 21 A4 5E  	LD IX, PTRGET
 822  65AF CD 59 01     	CALL CALBAS
 823  65B2 3A 12 40     	LD A,(VERSION)
 824  65B5 12              LD (DE),A
 825  65B6 13              INC DE
 826  65B7 3A 13 40        LD A,(VERSION+1)
 827  65BA 12              LD (DE),A
 828  65BB              	; comma
 829  65BB CD 45 65     	CALL CHKCHAR
 830  65BE 2C           	DB ','
 831  65BF              	; get address of build flags variable
 832  65BF DD 21 A4 5E  	LD IX, PTRGET
 833  65C3 CD 59 01     	CALL CALBAS
 834  65C6 E5              PUSH HL
 835  65C7 21 FF 07        LD HL,SOUND_CMDS+2*RAM_CMDS+4*VRAM_CMDS+8*BLIT_CMDS+16*SPRITE_CMDS+32*GENCAL_CMD+64*TILE_CMDS+128*BOX_CMDS+256*ANIM_CMDS+512*COLL_CMD+1024*1+2048*0
 836  65CA EB              EX DE,HL
 837  65CB 73              LD (HL),E
 838  65CC 23              INC HL
 839  65CD 72              LD (HL),D
 840  65CE E1              POP HL
 841  65CF              	; comma
 842  65CF CD 45 65     	CALL CHKCHAR
 843  65D2 2C           	DB ','
 844  65D3              	; get address of free memory variable
 845  65D3 DD 21 A4 5E  	LD IX, PTRGET
 846  65D7 CD 59 01     	CALL CALBAS
 847  65DA 3A 10 40     	LD A,(FREEMEMPTR)
 848  65DD 12              LD (DE),A
 849  65DE 13              INC DE
 850  65DF 3A 11 40        LD A,(FREEMEMPTR+1)
 851  65E2 12              LD (DE),A
 852  65E3              	; ending )
 853  65E3 CD 45 65     	CALL CHKCHAR
 854  65E6 29           	DB ')'
 855  65E7 C9           	RET
 856  65E8              ; *******************************************************************************************************
 857  65E8
 858  65E8              EXT_END:
 859  65E8
# file closed: asm\main.asm
