# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		   EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000              COLL_CMD       EQU 1
  14  4000
  15  4000              ; what to compile, provided in sjasmplus command line
  16  4000              ;BASIC_EXTENSION   EQU 1
  17  4000              ;DEFUSR_EXTENSION  EQU 0
  18  4000
  19  4000              CHPUT   EQU    #A2
  20  4000              CALBAS  EQU		#159
  21  4000              ERRHAND EQU    #406F
  22  4000              FRMEVL  EQU    #4C64
  23  4000              FRESTR  EQU		#67D0
  24  4000              ; FRMQNT = formula quantificator
  25  4000              ; input HL=pointer to current program expression
  26  4000              ; output HL=next address
  27  4000              ; output DE=integer datum
  28  4000              FRMQNT	EQU		#542F
  29  4000              ; GETBYT = get byte parameter
  30  4000              ; input HL=pointer to current program expression
  31  4000              ; output HL=next address
  32  4000              ; output A=E=byte read
  33  4000              GETBYT		EQU	#521C
  34  4000              CHRGTR  	   EQU   #4666
  35  4000              PTRGET		EQU 	#5EA4
  36  4000              SUBFLG		EQU	#F6A5
  37  4000              SYNCHR		EQU	#558C
  38  4000              VALTYP  	   EQU   #F663
  39  4000              DAC         EQU   #F7F6
  40  4000              USR     	   EQU   #F7F8
  41  4000              PROCNM		EQU	#FD89
  42  4000              BIOS_FILVRM EQU   #0056
  43  4000              CLIKSW		EQU	#F3DB
  44  4000
  45  4000              RAMAD0	   EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  46  4000              RAMAD1	   EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  47  4000              RAMAD2	   EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  48  4000              RAMAD3	   EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  49  4000              EXPTBL	   EQU   #FCC1
  50  4000              SCRMOD	   EQU   #FCAF ; current screen mode
  51  4000              REG1SAV     EQU   #F3E0 ; VDP(1)
  52  4000              JIFFY	      EQU   #FC9E
  53  4000              GRPPAT	   EQU   #F3CF ; SCREEN 2 sprite generator table address
  54  4000              GRPCGP		EQU	#F3CB ; SCREEN 2 pattern generator table address
  55  4000              GRPATR      EQU   #F3CD ; SCREEN 2 sprite attribute table address
  56  4000              T32PAT	   EQU   #F3C5 ; SCREEN 1 sprite generator table address
  57  4000              T32CGP      EQU   #F3C1 ; SCREEN 1 pattern ganarator table address
  58  4000              T32ATR      EQU   #F3C3 ; SCREEN 1 sprite attribute table address
  59  4000
  60  4000              ; BASIC error codes
  61  4000              ;01 NEXT without FOR
  62  4000              ;02 Syntax error
  63  4000              ;03 RETURN without GOSUB
  64  4000              ;04 Out of DATA
  65  4000              ;05 Illegal function call
  66  4000              ;06 Overflow
  67  4000              ;07 Out of memory
  68  4000              ;08 Undefined line number
  69  4000              ;09 Subscript out of range
  70  4000              ;10 Redimensioned array
  71  4000              ;11 Division by zero
  72  4000              ;12 Illegal direct
  73  4000              ;13 Type mismatch
  74  4000              ;14 Out of string space
  75  4000              ;15 String too long
  76  4000              ;16 String formula too complex
  77  4000              ;17 Can't CONTINUE
  78  4000              ;18 Undefined user function
  79  4000              ;19 Device I/O error
  80  4000              ;20 Verify error
  81  4000              ;21 No RESUME
  82  4000              ;22 RESUME without error
  83  4000              ;23 Unprintable error
  84  4000              ;24 Missing operand
  85  4000              ;25 Line buffer overflow
  86  4000              ;50 FIELD overflow
  87  4000              ;51 Internal error
  88  4000              ;52 Bad file number
  89  4000              ;53 File not found
  90  4000              ;54 File already open
  91  4000              ;55 Input past end
  92  4000              ;56 Bad file name
  93  4000              ;57 Direct statement in file
  94  4000              ;58 Sequential I/O only
  95  4000              ;59 File not OPEN
  96  4000
  97  4000
  98  4000               ; simulate cartridge with BASIC extension
  99  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
  99  4004 0F 65 00 00
  99  4008 00 00 00 00
  99  400C 00 00 00 00
 100  4010
 101  4010              ; this location #4010 stores last location used by basic extension
 102  4010              ; free memory after that point
 103  4010              FREEMEMPTR:
 104  4010 F0 65         DW EXT_END
 105  4012
 106  4012              ; this location #4012 stores extension version in DAA format
 107  4012              ; first byte is major version and second minor
 108  4012              VERSION:
 109  4012 00 90         DB #00, #90
 110  4014
 111  4014              ; this location #4014 contains a jump to entry point for DEFUSR approach
 112  4014              ; if excluded it contains 3xRET so that sound player can be at aspecific spot
 113  4014               IF (0 == 1)
 114  4014 ~               JP DEFUSR_ENTRY
 115  4014               ELSE
 116  4014 C9          > RET
 116  4015 C9          > RET
 116  4016 C9          > RET
 117  4017               ENDIF
 118  4017
 119  4017              ; binary included AKG player compiled at #4017
 120  4017               IF (SOUND_CMDS == 1)
 121  4017              	INCBIN "bin/AKG.bin"
 122  4CF3              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF3              MAIN_PLAYER_START EQU 04017H
   2+ 4CF3              PLY_AKG_START EQU 04017H
   3+ 4CF3              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 04020H
   4+ 4CF3              PLY_AKG_INITSOUNDEFFECTS EQU 04020H
   5+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04024H
   6+ 4CF3              PLY_AKG_PLAYSOUNDEFFECT EQU 04024H
   7+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04025H
   8+ 4CF3              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04025H
   9+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 0404CH
  10+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 0404CH
  11+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 0405AH
  12+ 4CF3              PLY_AKG_PSES_PLAY EQU 04093H
  13+ 4CF3              PLY_AKG_PSES_READFIRSTBYTE EQU 0409CH
  14+ 4CF3              PLY_AKG_PSES_S_ENDORLOOP EQU 040B4H
  15+ 4CF3              PLY_AKG_PSES_S_LOOP EQU 040BFH
  16+ 4CF3              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C5H
  17+ 4CF3              PLY_AKG_PSES_NOTREACHED EQU 040D8H
  18+ 4CF3              PLY_AKG_PSES_HARDWAREONLY EQU 040DCH
  19+ 4CF3              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E3H
  20+ 4CF3              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F5H
  21+ 4CF3              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FFH
  22+ 4CF3              PLY_AKG_PSES_H_AFTERRETRIG EQU 04109H
  23+ 4CF3              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411DH
  24+ 4CF3              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 04122H
  25+ 4CF3              PLY_AKG_PSES_READHARDWAREPERIOD EQU 0412AH
  26+ 4CF3              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04135H
  27+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 04141H
  28+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04143H
  29+ 4CF3              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04149H
  30+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414DH
  31+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414DH
  32+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414FH
  33+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414FH
  34+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414FH
  35+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 04150H
  36+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 04151H
  37+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04155H
  38+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04155H
  39+ 4CF3              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04155H
  40+ 4CF3              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415DH
  41+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04165H
  42+ 4CF3              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04165H
  43+ 4CF3              PLY_AKG_INIT EQU 04165H
  44+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04165H
  45+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04193H
  46+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A7H
  47+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B9H
  48+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D8H
  49+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E5H
  50+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL EQU 041EBH
  51+ 4CF3              PLY_AKG_INITTABLE0 EQU 041EEH
  52+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EEH
  53+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04208H
  54+ 4CF3              PLY_AKG_INITTABLE0_END EQU 04208H
  55+ 4CF3              PLY_AKG_INITTABLE1 EQU 04208H
  56+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04208H
  57+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 0420CH
  58+ 4CF3              PLY_AKG_INITTABLE1_END EQU 0420CH
  59+ 4CF3              PLY_AKG_INITTABLEORA EQU 0420CH
  60+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 0420CH
  61+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04224H
  62+ 4CF3              PLY_AKG_INITTABLEORA_END EQU 04224H
  63+ 4CF3              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04224H
  64+ 4CF3              PLY_AKG_STOP EQU 04224H
  65+ 4CF3              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04236H
  66+ 4CF3              PLY_AKG_PLAY EQU 04236H
  67+ 4CF3              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423EH
  68+ 4CF3              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04244H
  69+ 4CF3              PLY_AKG_READLINKER EQU 04249H
  70+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04249H
  71+ 4CF3              PLY_AKG_READLINKER_PTLINKER EQU 04249H
  72+ 4CF3              PLY_AKG_READLINKER_NOLOOP EQU 04254H
  73+ 4CF3              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428DH
  74+ 4CF3              PLY_AKG_READLINE EQU 04290H
  75+ 4CF3              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 04290H
  76+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04296H
  77+ 4CF3              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04296H
  78+ 4CF3              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A3H
  79+ 4CF3              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A7H
  80+ 4CF3              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042AAH
  81+ 4CF3              PLY_AKG_SPEEDTRACK_END EQU 042ADH
  82+ 4CF3              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042ADH
  83+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B3H
  84+ 4CF3              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B3H
  85+ 4CF3              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042C0H
  86+ 4CF3              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C4H
  87+ 4CF3              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C7H
  88+ 4CF3              PLY_AKG_EVENTTRACK_END EQU 042CAH
  89+ 4CF3              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042CAH
  90+ 4CF3              PLY_AKG_CHANNEL1_READTRACK EQU 042D6H
  91+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D6H
  92+ 4CF3              PLY_AKG_CHANNEL1_PTTRACK EQU 042D6H
  93+ 4CF3              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042F1H
  94+ 4CF3              PLY_AKG_CHANNEL1_WAIT EQU 042FCH
  95+ 4CF3              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04303H
  96+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04303H
  97+ 4CF3              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04303H
  98+ 4CF3              PLY_AKG_CHANNEL1_NOTE EQU 0430CH
  99+ 4CF3              PLY_AKG_BASENOTEINDEX EQU 0430CH
 100+ 4CF3              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430EH
 101+ 4CF3              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430EH
 102+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431EH
 103+ 4CF3              PLY_AKG_INSTRUMENTSTABLE EQU 0431EH
 104+ 4CF3              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 04330H
 105+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 04340H
 106+ 4CF3              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04368H
 107+ 4CF3              PLY_AKG_CHANNEL1_READCELLEND EQU 0436BH
 108+ 4CF3              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 0436BH
 109+ 4CF3              PLY_AKG_CHANNEL2_READTRACK EQU 04377H
 110+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04377H
 111+ 4CF3              PLY_AKG_CHANNEL2_PTTRACK EQU 04377H
 112+ 4CF3              PLY_AKG_CHANNEL2_SMALLWAIT EQU 04392H
 113+ 4CF3              PLY_AKG_CHANNEL2_WAIT EQU 0439DH
 114+ 4CF3              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A4H
 115+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A4H
 116+ 4CF3              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A4H
 117+ 4CF3              PLY_AKG_CHANNEL2_NOTE EQU 043ADH
 118+ 4CF3              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043B2H
 119+ 4CF3              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043B2H
 120+ 4CF3              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D4H
 121+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E4H
 122+ 4CF3              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 0440CH
 123+ 4CF3              PLY_AKG_CHANNEL2_READCELLEND EQU 0440FH
 124+ 4CF3              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440FH
 125+ 4CF3              PLY_AKG_CHANNEL3_READTRACK EQU 0441BH
 126+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 0441BH
 127+ 4CF3              PLY_AKG_CHANNEL3_PTTRACK EQU 0441BH
 128+ 4CF3              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04436H
 129+ 4CF3              PLY_AKG_CHANNEL3_WAIT EQU 04441H
 130+ 4CF3              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04448H
 131+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04448H
 132+ 4CF3              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04448H
 133+ 4CF3              PLY_AKG_CHANNEL3_NOTE EQU 04451H
 134+ 4CF3              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04456H
 135+ 4CF3              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04456H
 136+ 4CF3              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04478H
 137+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04488H
 138+ 4CF3              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044B0H
 139+ 4CF3              PLY_AKG_CHANNEL3_READCELLEND EQU 044B3H
 140+ 4CF3              PLY_AKG_CURRENTSPEED EQU 044B3H
 141+ 4CF3              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B5H
 142+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B8H
 143+ 4CF3              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B8H
 144+ 4CF3              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044BBH
 145+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BEH
 146+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BEH
 147+ 4CF3              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044CAH
 148+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044D1H
 149+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D4H
 150+ 4CF3              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044DAH
 151+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DDH
 152+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DDH
 153+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044EBH
 154+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044F0H
 155+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044FBH
 156+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FEH
 157+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FEH
 158+ 4CF3              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 04501H
 159+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04504H
 160+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04504H
 161+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450DH
 162+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04517H
 163+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 0451AH
 164+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 0451AH
 165+ 4CF3              PLY_AKG_CHANNEL1_PITCH EQU 0451AH
 166+ 4CF3              PLY_AKG_CHANNEL1_ISPITCH EQU 0451DH
 167+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 04522H
 168+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACK EQU 04522H
 169+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04526H
 170+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04528H
 171+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 0452AH
 172+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 04531H
 173+ 4CF3              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 04532H
 174+ 4CF3              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04535H
 175+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04535H
 176+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 04551H
 177+ 4CF3              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 04551H
 178+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455EH
 179+ 4CF3              PLY_AKG_CHANNEL1_GLIDEOVER EQU 04562H
 180+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 04572H
 181+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 04572H
 182+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04573H
 183+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04574H
 184+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04576H
 185+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04576H
 186+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04576H
 187+ 4CF3              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04577H
 188+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04578H
 189+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 0457AH
 190+ 4CF3              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 0457AH
 191+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 0457AH
 192+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 0457AH
 193+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 0457AH
 194+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457DH
 195+ 4CF3              PLY_AKG_CHANNEL1_PITCH_END EQU 0457FH
 196+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04587H
 197+ 4CF3              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04587H
 198+ 4CF3              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 0458AH
 199+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458DH
 200+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458DH
 201+ 4CF3              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04599H
 202+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 045A0H
 203+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A3H
 204+ 4CF3              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A9H
 205+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045ACH
 206+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045ACH
 207+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045BAH
 208+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BFH
 209+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045CAH
 210+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CDH
 211+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CDH
 212+ 4CF3              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045D0H
 213+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D3H
 214+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D3H
 215+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045DCH
 216+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E6H
 217+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E9H
 218+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E9H
 219+ 4CF3              PLY_AKG_CHANNEL2_PITCH EQU 045E9H
 220+ 4CF3              PLY_AKG_CHANNEL2_ISPITCH EQU 045ECH
 221+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045F1H
 222+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045F1H
 223+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F5H
 224+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F7H
 225+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F9H
 226+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 04600H
 227+ 4CF3              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 04601H
 228+ 4CF3              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04604H
 229+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04604H
 230+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 04620H
 231+ 4CF3              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 04620H
 232+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462DH
 233+ 4CF3              PLY_AKG_CHANNEL2_GLIDEOVER EQU 04631H
 234+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 04641H
 235+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 04641H
 236+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 04642H
 237+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04643H
 238+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04645H
 239+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04645H
 240+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04645H
 241+ 4CF3              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04646H
 242+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04647H
 243+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04649H
 244+ 4CF3              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04649H
 245+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04649H
 246+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04649H
 247+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04649H
 248+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_END EQU 0464CH
 249+ 4CF3              PLY_AKG_CHANNEL2_PITCH_END EQU 0464EH
 250+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04656H
 251+ 4CF3              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04656H
 252+ 4CF3              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04659H
 253+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 0465CH
 254+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 0465CH
 255+ 4CF3              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04668H
 256+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466FH
 257+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 04672H
 258+ 4CF3              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04678H
 259+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 0467BH
 260+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 0467BH
 261+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04689H
 262+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468EH
 263+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04699H
 264+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 0469CH
 265+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 0469CH
 266+ 4CF3              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469FH
 267+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 046A2H
 268+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE EQU 046A2H
 269+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046ABH
 270+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B5H
 271+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B8H
 272+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B8H
 273+ 4CF3              PLY_AKG_CHANNEL3_PITCH EQU 046B8H
 274+ 4CF3              PLY_AKG_CHANNEL3_ISPITCH EQU 046BBH
 275+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046C0H
 276+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046C0H
 277+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C4H
 278+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C6H
 279+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C8H
 280+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CFH
 281+ 4CF3              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046D0H
 282+ 4CF3              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D3H
 283+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D3H
 284+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046EFH
 285+ 4CF3              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046EFH
 286+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046FCH
 287+ 4CF3              PLY_AKG_CHANNEL3_GLIDEOVER EQU 04700H
 288+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 04710H
 289+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 04710H
 290+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 04711H
 291+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 04712H
 292+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04714H
 293+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04714H
 294+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04714H
 295+ 4CF3              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04715H
 296+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04716H
 297+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04718H
 298+ 4CF3              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04718H
 299+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04718H
 300+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04718H
 301+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04718H
 302+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_END EQU 0471BH
 303+ 4CF3              PLY_AKG_CHANNEL3_PITCH_END EQU 0471DH
 304+ 4CF3              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04729H
 305+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04729H
 306+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04729H
 307+ 4CF3              PLY_AKG_CHANNEL1_TRACKNOTE EQU 0472CH
 308+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472EH
 309+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04734H
 310+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04737H
 311+ 4CF3              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04737H
 312+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 0473AH
 313+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04743H
 314+ 4CF3              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 0474BH
 315+ 4CF3              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04758H
 316+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04758H
 317+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04758H
 318+ 4CF3              PLY_AKG_CHANNEL2_TRACKNOTE EQU 0475BH
 319+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475DH
 320+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04763H
 321+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04766H
 322+ 4CF3              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04766H
 323+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04769H
 324+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 04772H
 325+ 4CF3              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 0477AH
 326+ 4CF3              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04788H
 327+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04788H
 328+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04788H
 329+ 4CF3              PLY_AKG_CHANNEL3_TRACKNOTE EQU 0478BH
 330+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478DH
 331+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04793H
 332+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04796H
 333+ 4CF3              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04796H
 334+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04799H
 335+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 047A2H
 336+ 4CF3              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047AAH
 337+ 4CF3              PLY_AKG_SENDPSGREGISTERS EQU 047B9H
 338+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047C1H
 339+ 4CF3              PLY_AKG_PSGREG01_INSTR EQU 047C1H
 340+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047D1H
 341+ 4CF3              PLY_AKG_PSGREG23_INSTR EQU 047D1H
 342+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047E2H
 343+ 4CF3              PLY_AKG_PSGREG45_INSTR EQU 047E2H
 344+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F3H
 345+ 4CF3              PLY_AKG_PSGREG6_8_INSTR EQU 047F3H
 346+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04804H
 347+ 4CF3              PLY_AKG_PSGREG9_10_INSTR EQU 04804H
 348+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04815H
 349+ 4CF3              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04815H
 350+ 4CF3              PLY_AKG_PSGREG13_OLDVALUE EQU 0482AH
 351+ 4CF3              PLY_AKG_RETRIG EQU 0482CH
 352+ 4CF3              PLY_AKG_PSGREG13_INSTR EQU 0482EH
 353+ 4CF3              PLY_AKG_PSGREG13_END EQU 0483DH
 354+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483DH
 355+ 4CF3              PLY_AKG_SAVESP EQU 0483DH
 356+ 4CF3              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 04841H
 357+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTS EQU 04849H
 358+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04856H
 359+ 4CF3              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04856H
 360+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485EH
 361+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 0486BH
 362+ 4CF3              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 0486BH
 363+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTS EQU 04873H
 364+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487EH
 365+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS EQU 0487EH
 366+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488DH
 367+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488DH
 368+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04894H
 369+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A4H
 370+ 4CF3              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A4H
 371+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048ABH
 372+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048ABH
 373+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048AEH
 374+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B7H
 375+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B7H
 376+ 4CF3              PLY_AKG_READINSTRUMENTCELL EQU 048BDH
 377+ 4CF3              PLY_AKG_NOSOFTNOHARD EQU 048CAH
 378+ 4CF3              PLY_AKG_NSNH_NONOISE EQU 048DFH
 379+ 4CF3              PLY_AKG_SOFT EQU 048E2H
 380+ 4CF3              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E9H
 381+ 4CF3              PLY_AKG_S_NOTSIMPLE EQU 048F1H
 382+ 4CF3              PLY_AKG_S_AFTERSIMPLETEST EQU 048F4H
 383+ 4CF3              PLY_AKG_HARDTOSOFT EQU 04901H
 384+ 4CF3              PLY_AKG_HS_JUMPRATIO EQU 0490CH
 385+ 4CF3              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04939H
 386+ 4CF3              PLY_AKG_ENDWITHOUTLOOP EQU 0493BH
 387+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 0493BH
 388+ 4CF3              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 0493BH
 389+ 4CF3              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04943H
 390+ 4CF3              PLY_AKG_SH_JUMPRATIO EQU 04950H
 391+ 4CF3              PLY_AKG_SH_JUMPRATIOEND EQU 04971H
 392+ 4CF3              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 04980H
 393+ 4CF3              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04986H
 394+ 4CF3              PLY_AKG_H_OR_ENDWITHLOOP EQU 049A0H
 395+ 4CF3              PLY_AKG_H_RETRIGEND EQU 049B2H
 396+ 4CF3              PLY_AKG_H_AFTERRETRIG EQU 049B3H
 397+ 4CF3              PLY_AKG_ENDWITHLOOP EQU 049C5H
 398+ 4CF3              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049CCH
 399+ 4CF3              PLY_AKG_S_OR_H_NEXTBYTE EQU 049E2H
 400+ 4CF3              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049F0H
 401+ 4CF3              PLY_AKG_S_OR_H_AFTERPITCH EQU 04A00H
 402+ 4CF3              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0EH
 403+ 4CF3              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1DH
 404+ 4CF3              PLY_AKG_SHOHS_RETRIGEND EQU 04A2CH
 405+ 4CF3              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2DH
 406+ 4CF3              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3FH
 407+ 4CF3              PLY_AKG_EFFECTTABLE EQU 04A4DH
 408+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4DH
 409+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A71H
 410+ 4CF3              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A71H
 411+ 4CF3              PLY_AKG_EFFECT_RESET EQU 04A74H
 412+ 4CF3              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A76H
 413+ 4CF3              PLY_AKG_EFFECT_VOLUME EQU 04A91H
 414+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9DH
 415+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA3H
 416+ 4CF3              PLY_AKG_ARPEGGIOSTABLE EQU 04AA3H
 417+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04ACAH
 418+ 4CF3              PLY_AKG_EFFECT_PITCHTABLE EQU 04AD1H
 419+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD7H
 420+ 4CF3              PLY_AKG_PITCHESTABLE EQU 04AD7H
 421+ 4CF3              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFEH
 422+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B05H
 423+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B16H
 424+ 4CF3              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1DH
 425+ 4CF3              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2DH
 426+ 4CF3              PLY_AKG_EFFECT_PITCHUP EQU 04B42H
 427+ 4CF3              PLY_AKG_EFFECT_PITCHSTOP EQU 04B54H
 428+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B5BH
 429+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B85H
 430+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B85H
 431+ 4CF3              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9EH
 432+ 4CF3              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9EH
 433+ 4CF3              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BB0H
 434+ 4CF3              PLY_AKG_EFFECT_LEGATO EQU 04BC6H
 435+ 4CF3              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BDAH
 436+ 4CF3              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BE2H
 437+ 4CF3              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BEAH
 438+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BF2H
 439+ 4CF3              PLY_AKG_EVENT EQU 04BF2H
 440+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF3H
 441+ 4CF3              PLY_AKG_PERIODTABLE EQU 04BF3H
 442+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF3H
 443+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF3H
 444+ 4CF3              PLY_AKG_PERIODTABLE_END EQU 04CF3H
 445+ 4CF3              PLY_AKG_END EQU 04CF3H
 446+ 4CF3              MAIN_PLAYER_END EQU 04CF3H
 447+ 4CF3              TESTEREND EQU 04CF3H
 448+ 4CF3
# file closed: ./symbol/AKG.sym
 123  4CF3               ENDIF
 124  4CF3
 125  4CF3               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
   1+ 4CF3              ORIG.HTIMI:
   2+ 4CF3 00 00 00 00  	DB 0, 0, 0, 0, 0
   2+ 4CF7 00
   3+ 4CF8               EXPORT ORIG.HTIMI
   4+ 4CF8
   5+ 4CF8              ; *******************************************************************************************************
   6+ 4CF8              ; interrupt handler when page 0 enabled
   7+ 4CF8              ; we are here only if one of the extended basic commands have paged in page 0
   8+ 4CF8              ; which means we arrived from BASIC so page 2 is already good
   9+ 4CF8              VBLANK:
  10+ 4CF8              	EXPORT VBLANK
  11+ 4CF8
  12+ 4CF8 F5               PUSH AF
  13+ 4CF9              	; is VDP originator ?
  14+ 4CF9 DB 99        	IN	A, (099H)
  15+ 4CFB A7           	AND	A
  16+ 4CFC F2 23 4D     	JP P, .EXIT
  17+ 4CFF
  18+ 4CFF               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  19+ 4CFF C5               PUSH BC
  20+ 4D00 D5               PUSH DE
  21+ 4D01 E5               PUSH HL
  22+ 4D02 08               EX AF, AF'
  23+ 4D03 D9               EXX
  24+ 4D04 F5               PUSH AF
  25+ 4D05 C5               PUSH BC
  26+ 4D06 D5               PUSH DE
  27+ 4D07 E5               PUSH HL
  28+ 4D08 DD E5            PUSH IX
  29+ 4D0A FD E5            PUSH IY
  30+ 4D0C
  31+ 4D0C               IF (SPRITE_CMDS == 1)
  32+ 4D0C CD 5D 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  33+ 4D0F               ENDIF
  34+ 4D0F
  35+ 4D0F               IF (SOUND_CMDS == 1)
  36+ 4D0F 3A CA 58     	LD A, (SOUND_ENABLED)
  37+ 4D12 B7           	OR A
  38+ 4D13 C4 36 42     	CALL NZ,PLY_AKG_PLAY
  39+ 4D16               ENDIF
  40+ 4D16
  41+ 4D16                  ; increase JIFFY
  42+ 4D16                  ;LD HL,(JIFFY)
  43+ 4D16                  ;INC HL
  44+ 4D16                  ;LD (JIFFY),HL
  45+ 4D16
  46+ 4D16 FD E1            POP IY
  47+ 4D18 DD E1            POP IX
  48+ 4D1A E1               POP HL
  49+ 4D1B D1               POP DE
  50+ 4D1C C1               POP BC
  51+ 4D1D F1               POP AF
  52+ 4D1E 08               EX AF, AF'
  53+ 4D1F D9               EXX
  54+ 4D20 E1               POP HL
  55+ 4D21 D1               POP DE
  56+ 4D22 C1               POP BC
  57+ 4D23               ENDIF
  58+ 4D23
  59+ 4D23              .EXIT:
  60+ 4D23 F1           	POP AF
  61+ 4D24 FB           	EI
  62+ 4D25 ED 4D        	RETI
  63+ 4D27              ; *******************************************************************************************************
  64+ 4D27
  65+ 4D27              ; *******************************************************************************************************
  66+ 4D27              ; H.TIMI function
  67+ 4D27              ; we can end up here from anywhere so page in both page 0 and 2
  68+ 4D27              MBGE_HTIMI:
  69+ 4D27               EXPORT MBGE_HTIMI
  70+ 4D27
  71+ 4D27               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  72+ 4D27
  73+ 4D27 F5           	PUSH AF
  74+ 4D28
  75+ 4D28              	; enable page 2
  76+ 4D28 3E 02            LD A, 2
  77+ 4D2A CD 3E 64         CALL GET_PAGE_INFO
  78+ 4D2D C5               PUSH BC
  79+ 4D2E D5               PUSH DE
  80+ 4D2F 3A 43 F3         LD A, (RAMAD2)
  81+ 4D32 26 80            LD H, 080H
  82+ 4D34 CD 85 64         CALL LOCAL_ENASLT
  83+ 4D37              	; enable page 0
  84+ 4D37 AF               XOR A
  85+ 4D38 CD 3E 64         CALL GET_PAGE_INFO
  86+ 4D3B C5               PUSH BC
  87+ 4D3C D5               PUSH DE
  88+ 4D3D 3A 41 F3         LD A, (RAMAD0)
  89+ 4D40 26 00            LD H, 0
  90+ 4D42 CD 85 64         CALL LOCAL_ENASLT
  91+ 4D45
  92+ 4D45               IF (SPRITE_CMDS == 1)
  93+ 4D45 CD 5D 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  94+ 4D48               ENDIF
  95+ 4D48
  96+ 4D48               IF (SOUND_CMDS == 1)
  97+ 4D48 3A CA 58     	LD A, (SOUND_ENABLED)
  98+ 4D4B B7           	OR A
  99+ 4D4C C4 36 42     	CALL NZ,PLY_AKG_PLAY
 100+ 4D4F               ENDIF
 101+ 4D4F
 102+ 4D4F              	; restore page 0
 103+ 4D4F D1               POP DE
 104+ 4D50 C1               POP BC
 105+ 4D51 CD 75 64         CALL RESTORE_PAGE_INFO
 106+ 4D54              	; restore page 2
 107+ 4D54 D1               POP DE
 108+ 4D55 C1               POP BC
 109+ 4D56 CD 75 64         CALL RESTORE_PAGE_INFO
 110+ 4D59
 111+ 4D59 F1           	POP AF
 112+ 4D5A               ENDIF
 113+ 4D5A C3 F3 4C     	JP ORIG.HTIMI
 114+ 4D5D              ; *******************************************************************************************************
 115+ 4D5D
 116+ 4D5D              ; *******************************************************************************************************
 117+ 4D5D              ; function checks if the sprite system is initialized and what screen mode we are running
 118+ 4D5D              ; also checks if some VRAM modifying command is running
 119+ 4D5D              ; when that checks out calls sprite updates and animation processing
 120+ 4D5D              ; if in an unsupported mode disables sprite handling
 121+ 4D5D              PROCESS_SPRITES_AND_ANIMATIONS:
 122+ 4D5D              	; check if initialized
 123+ 4D5D 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
 124+ 4D60 B7           	OR A
 125+ 4D61 C8           	RET Z
 126+ 4D62              	; check screen mode
 127+ 4D62 3A AF FC     	LD A, (SCRMOD)
 128+ 4D65 3D           	DEC A
 129+ 4D66 28 08        	JR Z, .L0 ; screen 1
 130+ 4D68 3D           	DEC A
 131+ 4D69 28 05            JR Z, .L0 ; screen 2
 132+ 4D6B              	; unsupported screen mode, disable
 133+ 4D6B AF               XOR A
 134+ 4D6C 32 7F 4D         LD (SPRATR_INIT_STATUS),A
 135+ 4D6F C9               RET
 136+ 4D70              .L0:
 137+ 4D70                  ; check if anyone else is working with VRAM
 138+ 4D70 3A 4E 62         LD A,(VRAM_UPDATE_IN_PROGRESS)
 139+ 4D73 B7               OR A
 140+ 4D74 C0               RET NZ
 141+ 4D75
 142+ 4D75 CD 95 4D         CALL SPRATR_UPDATE
 143+ 4D78
 144+ 4D78               IF (ANIM_CMDS == 1)
 145+ 4D78 CD 76 55         CALL PROCESS_ANIMATIONS
 146+ 4D7B CD 41 57         CALL PROCESS_AUTOSGAMS
 147+ 4D7E               ENDIF
 148+ 4D7E C9               RET
 149+ 4D7F              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
 126  4D7F
 127  4D7F               IF (SPRITE_CMDS == 1)
 128  4D7F               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4D7F              ; commands and variables related to sprites
   2+ 4D7F
   3+ 4D7F              SPRATR_INIT_STATUS:
   4+ 4D7F 00            DB 0
   5+ 4D80              SPRATR_UPDATE_FLAG:
   6+ 4D80 00 00         DW 0
   7+ 4D82              SPRATR_DATA:
   8+ 4D82 00 00         DW 0
   9+ 4D84              SPRFLICKER_ENABLED:
  10+ 4D84 00            DB 0
  11+ 4D85              ; to support sprite flicker
  12+ 4D85              FLICKER:
  13+ 4D85 00            DB 0
  14+ 4D86              NUM_SPRITES_HANDLED:
  15+ 4D86 20            DB 32
  16+ 4D87
  17+ 4D87              ; to temporarily store stack pointer
  18+ 4D87              TMPSP:
  19+ 4D87 00 00         DW 0
  20+ 4D89
  21+ 4D89              ; *******************************************************************************************************
  22+ 4D89              ; helper function gets pointer to n-th entry in sprite attributes
  23+ 4D89              ; changes HL,DE
  24+ 4D89              GETnthSPRATTR:
  25+ 4D89 26 00            LD H,0
  26+ 4D8B 6F               LD L,A
  27+ 4D8C CD 3A 64         CALL HLx8
  28+ 4D8F ED 5B 82 4D      LD DE,(SPRATR_DATA)
  29+ 4D93 19               ADD HL,DE
  30+ 4D94 C9               RET
  31+ 4D95              ; *******************************************************************************************************
  32+ 4D95
  33+ 4D95              ; *******************************************************************************************************
  34+ 4D95              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  35+ 4D95              ; struct {
  36+ 4D95              ; DW y
  37+ 4D95              ; DW x
  38+ 4D95              ; DW pattern (0-63)
  39+ 4D95              ; DW color
  40+ 4D95              ; } [32]
  41+ 4D95              ; will hide sprites whose location is outside of visible area
  42+ 4D95              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  43+ 4D95              ; modifies AF, AF', BC, DE, HL, IX
  44+ 4D95              SPRATR_UPDATE:
  45+ 4D95              	; check if update requested
  46+ 4D95 2A 80 4D     	LD HL, (SPRATR_UPDATE_FLAG)
  47+ 4D98 7E           	LD A, (HL)
  48+ 4D99 B7           	OR A
  49+ 4D9A C8           	RET Z
  50+ 4D9B
  51+ 4D9B DD 21 86 4D  	LD IX,NUM_SPRITES_HANDLED
  52+ 4D9F DD 46 00     	LD B, (IX) ; sprite number
  53+ 4DA2 0E 98        	LD C, #98 ; register for vdp data output
  54+ 4DA4              	; set VDP address
  55+ 4DA4 3A AF FC         LD A,(SCRMOD)
  56+ 4DA7 3D               DEC A
  57+ 4DA8 20 05            JR NZ,.L4
  58+ 4DAA 2A C3 F3         LD HL, (T32ATR)
  59+ 4DAD 18 03            JR .L5
  60+ 4DAF              .L4:
  61+ 4DAF 2A CD F3         LD HL, (GRPATR)
  62+ 4DB2              .L5:
  63+ 4DB2 3A 84 4D     	LD A, (SPRFLICKER_ENABLED)
  64+ 4DB5 B7           	OR A
  65+ 4DB6 28 03        	JR Z, .L3
  66+ 4DB8 3A 85 4D     	LD A, (FLICKER)
  67+ 4DBB              .L3:
  68+ 4DBB 5F           	LD E, A
  69+ 4DBC 08           	EX AF, AF'
  70+ 4DBD 7B           	LD A, E
  71+ 4DBE 87           	ADD A, A
  72+ 4DBF 87           	ADD A, A
  73+ 4DC0 16 00        	LD D, 0
  74+ 4DC2 5F           	LD E, A
  75+ 4DC3 19           	ADD HL, DE
  76+ 4DC4 CD 25 64     	CALL SETWRT_LOCAL
  77+ 4DC7 ED 73 87 4D  	LD (TMPSP), SP
  78+ 4DCB ED 7B 82 4D  	LD SP, (SPRATR_DATA)
  79+ 4DCF
  80+ 4DCF              .LOOP:
  81+ 4DCF E1           	POP HL
  82+ 4DD0 24           	INC H
  83+ 4DD1 28 0D        	JR Z, .L1 ; negative number between -256 and -1
  84+ 4DD3 25           	DEC H
  85+ 4DD4 20 15        	JR NZ, .OUT3 ; sprite vertically can't be visible
  86+ 4DD6 7D           	LD A, L
  87+ 4DD7 FE C0        	CP 192
  88+ 4DD9 30 10        	JR NC, .OUT3
  89+ 4DDB 3D           	DEC A ; due to VDP rule that top of screen is -1
  90+ 4DDC 57           	LD D, A
  91+ 4DDD C3 04 4E     	JP .X
  92+ 4DE0              .L1:
  93+ 4DE0 7D           	LD A, L
  94+ 4DE1 C6 10        	ADD 16
  95+ 4DE3 FA EB 4D     	JP M, .OUT3 ; below -16
  96+ 4DE6 2D           	DEC L ; due to VDP rule that top of screen is -1
  97+ 4DE7 55           	LD D, L
  98+ 4DE8 C3 04 4E     	JP .X
  99+ 4DEB              .OUT3:
 100+ 4DEB E1           	POP HL ; skip x value
 101+ 4DEC              .OUT2:
 102+ 4DEC E1           	POP HL ; skip pattern
 103+ 4DED E1           	POP HL ; skip color
 104+ 4DEE 3E D1        	LD A, #D1
 105+ 4DF0 ED 79        	OUT (C), A ; sprite hidden
 106+ 4DF2 00          > NOP
 106+ 4DF3 00          > NOP
 106+ 4DF4 00          > NOP
 107+ 4DF5 ED 79        	OUT (C), A ; value unimportant
 108+ 4DF7 00          > NOP
 108+ 4DF8 00          > NOP
 108+ 4DF9 00          > NOP
 109+ 4DFA ED 79        	OUT (C), A ; value unimportant
 110+ 4DFC 00          > NOP
 110+ 4DFD 00          > NOP
 110+ 4DFE 00          > NOP
 111+ 4DFF ED 79        	OUT (C), A ; value unimportant
 112+ 4E01 C3 2F 4E     	JP .NEXT
 113+ 4E04              .X:
 114+ 4E04 E1           	POP HL
 115+ 4E05 24           	INC H
 116+ 4E06 28 08        	JR Z, .L2
 117+ 4E08 25           	DEC H
 118+ 4E09 20 E1        	JR NZ, .OUT2
 119+ 4E0B 1E 00        	LD E, 0 ; EC bit
 120+ 4E0D C3 19 4E     	JP .XY
 121+ 4E10              .L2:
 122+ 4E10 7D           	LD A, L
 123+ 4E11 C6 20        	ADD 32
 124+ 4E13 FA EC 4D     	JP M, .OUT2
 125+ 4E16 6F           	LD L, A
 126+ 4E17 1E 80        	LD E, #80
 127+ 4E19              .XY:
 128+ 4E19 ED 51        	OUT (C), D
 129+ 4E1B 3A E0 F3     	LD A, (REG1SAV)
 130+ 4E1E E6 02        	AND 2
 131+ 4E20 ED 69        	OUT (C), L
 132+ 4E22 E1           	POP HL ; pattern
 133+ 4E23 7D           	LD A, L
 134+ 4E24 28 02        	JR Z, .SMALLSPRITES
 135+ 4E26 87           	ADD A, A
 136+ 4E27 87           	ADD A, A ; needs to go at 4x
 137+ 4E28              .SMALLSPRITES:
 138+ 4E28 D3 98        	OUT (#98), A
 139+ 4E2A E1           	POP HL ; color
 140+ 4E2B 7D           	LD A, L
 141+ 4E2C B3           	OR E
 142+ 4E2D D3 98        	OUT (#98), A
 143+ 4E2F              .NEXT:
 144+ 4E2F 08           	EX AF, AF'
 145+ 4E30 3C           	INC A ; increase current sprite
 146+ 4E31 DD BE 00     	CP (IX) ; compare to maximum handled
 147+ 4E34 C2 54 4E     	JP NZ, .NEXT2 ; continue if not over
 148+ 4E37 AF           	XOR A ; back to zero
 149+ 4E38 08           	EX AF, AF'
 150+ 4E39 3A AF FC         LD A,(SCRMOD)
 151+ 4E3C 3D               DEC A
 152+ 4E3D 20 05            JR NZ,.L6
 153+ 4E3F 2A C3 F3         LD HL, (T32ATR)
 154+ 4E42 18 03            JR .L7
 155+ 4E44              .L6:
 156+ 4E44 2A CD F3         LD HL, (GRPATR)
 157+ 4E47              .L7:
 158+ 4E47              	; CALL SETWRT_LOCAL not allowed as SP modified
 159+ 4E47 7D           	LD	A, L
 160+ 4E48 D3 99        	OUT	(099H), A
 161+ 4E4A 7C           	LD	A, H
 162+ 4E4B E6 3F        	AND	03FH
 163+ 4E4D F6 40        	OR	040H
 164+ 4E4F D3 99        	OUT	(099H), A
 165+ 4E51 C3 55 4E     	JP .NEXT3
 166+ 4E54              .NEXT2:
 167+ 4E54 08           	EX AF, AF'
 168+ 4E55              .NEXT3:
 169+ 4E55 05           	DEC B
 170+ 4E56 C2 CF 4D     	JP NZ, .LOOP
 171+ 4E59 08           	EX AF, AF'
 172+ 4E5A 3C           	INC A ; increase flicker to start at the next one on next vblank
 173+ 4E5B DD BE 00     	CP (IX)
 174+ 4E5E 20 01        	JR NZ,.L8
 175+ 4E60 AF           	XOR A
 176+ 4E61              .L8:
 177+ 4E61 32 85 4D     	LD (FLICKER), A
 178+ 4E64
 179+ 4E64 ED 7B 87 4D  	LD SP, (TMPSP)
 180+ 4E68 2A 80 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 181+ 4E6B 36 00        	LD (HL), 0 ; zero out update flag
 182+ 4E6D C9           	RET
 183+ 4E6E              ; *******************************************************************************************************
 184+ 4E6E
 185+ 4E6E               IF (1 == 1)
 186+ 4E6E              ; *******************************************************************************************************
 187+ 4E6E              ; function to handle CALL SPRENABLE basic extension
 188+ 4E6E              ; initializes sprites handler
 189+ 4E6E              ; _SPRENABLE ( INT[3][31] variable sprites_attributes,
 190+ 4E6E              ;			   INT variable update_variable,
 191+ 4E6E              ;			   BYTE sprite_flicker_enabled,
 192+ 4E6E              ;			   BYTE num_sprites_handled )
 193+ 4E6E              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA, SPRFLICKER_ENABLED and NUM_SPRITES_HANDLED
 194+ 4E6E              SPRENABLE:
 195+ 4E6E              	; opening (
 196+ 4E6E CD 4D 65     	CALL CHKCHAR
 197+ 4E71 28           	DB '('
 198+ 4E72              	; get address of sprite attribute table DIM SA%(3,31)
 199+ 4E72 3E 02        	LD A,2
 200+ 4E74 06 02        	LD B,2
 201+ 4E76 11 20 04     	LD DE,#0420
 202+ 4E79 CD 7A 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
 203+ 4E7C ED 43 82 4D  	LD (SPRATR_DATA), BC
 204+ 4E80              	; comma
 205+ 4E80 CD 4D 65     	CALL CHKCHAR
 206+ 4E83 2C           	DB ','
 207+ 4E84              	; get address of sprite update flag
 208+ 4E84 DD 21 A4 5E  	LD IX, PTRGET
 209+ 4E88 CD 59 01     	CALL CALBAS
 210+ 4E8B ED 53 80 4D  	LD (SPRATR_UPDATE_FLAG), DE
 211+ 4E8F              	; comma
 212+ 4E8F CD 4D 65     	CALL CHKCHAR
 213+ 4E92 2C           	DB ','
 214+ 4E93              	; get flicker enabled flag
 215+ 4E93 DD 21 1C 52  	LD IX, GETBYT
 216+ 4E97 CD 59 01     	CALL CALBAS
 217+ 4E9A 32 84 4D     	LD (SPRFLICKER_ENABLED), A
 218+ 4E9D              	; comma
 219+ 4E9D CD 4D 65     	CALL CHKCHAR
 220+ 4EA0 2C           	DB ','
 221+ 4EA1              	; get number of handled sprites
 222+ 4EA1 DD 21 1C 52  	LD IX, GETBYT
 223+ 4EA5 CD 59 01     	CALL CALBAS
 224+ 4EA8 32 86 4D     	LD (NUM_SPRITES_HANDLED),A
 225+ 4EAB              	; ending )
 226+ 4EAB CD 4D 65     	CALL CHKCHAR
 227+ 4EAE 29           	DB ')'
 228+ 4EAF              .L0:
 229+ 4EAF 3E 01        	LD A, 1
 230+ 4EB1 32 7F 4D     	LD (SPRATR_INIT_STATUS), A
 231+ 4EB4 C9           	RET
 232+ 4EB5              ; *******************************************************************************************************
 233+ 4EB5               ENDIF
 234+ 4EB5
 235+ 4EB5               IF (0 == 1)
 236+ 4EB5 ~            ; same as SPRENABLE but for DEFUSR approach
 237+ 4EB5 ~            ; input IX=pointer to input array, real data from +2
 238+ 4EB5 ~            ; +2 = pointer to sprite attributes array data
 239+ 4EB5 ~            ; +4 = pointer to sprite update variable
 240+ 4EB5 ~            ; +6 = flicker flag
 241+ 4EB5 ~            ; +8 = number of sprites to handle
 242+ 4EB5 ~            SPRENABLE_DEFUSR:
 243+ 4EB5 ~            	LD L,(IX+2)
 244+ 4EB5 ~            	LD H,(IX+3)
 245+ 4EB5 ~            	LD (SPRATR_DATA),HL
 246+ 4EB5 ~            	LD L,(IX+4)
 247+ 4EB5 ~            	LD H,(IX+5)
 248+ 4EB5 ~            	LD (SPRATR_UPDATE_FLAG),HL
 249+ 4EB5 ~            	LD A,(IX+6)
 250+ 4EB5 ~            	LD (SPRFLICKER_ENABLED),A
 251+ 4EB5 ~            	LD A,(IX+8)
 252+ 4EB5 ~            	LD (NUM_SPRITES_HANDLED),A
 253+ 4EB5 ~             IF (BASIC_EXTENSION == 1)
 254+ 4EB5 ~            	JR SPRENABLE.L0
 255+ 4EB5 ~             ELSE
 256+ 4EB5 ~            	LD A, 1
 257+ 4EB5 ~            	LD (SPRATR_INIT_STATUS), A
 258+ 4EB5 ~            	RET
 259+ 4EB5 ~             ENDIF
 260+ 4EB5               ENDIF
 261+ 4EB5
 262+ 4EB5               IF (0 + 1 > 0)
 263+ 4EB5              ; *******************************************************************************************************
 264+ 4EB5              ; function to handle CALL SPRDISABLE basic extension
 265+ 4EB5              ; disables sprites handling
 266+ 4EB5              ; _SPRDISABLE
 267+ 4EB5              ; resets variable SPRATR_INIT_STATUS
 268+ 4EB5              SPRDISABLE:
 269+ 4EB5              SPRDISABLE_DEFUSR:
 270+ 4EB5 AF           	XOR A
 271+ 4EB6 32 7F 4D     	LD (SPRATR_INIT_STATUS), A
 272+ 4EB9 C9           	RET
 273+ 4EBA              ; *******************************************************************************************************
 274+ 4EBA               ENDIF
 275+ 4EBA
 276+ 4EBA              ; *******************************************************************************************************
 277+ 4EBA              ; function to handle CALL SPRSET basic extension
 278+ 4EBA              ; sets position, and optionally pattern and color of sprite
 279+ 4EBA              ; _SPRSET ( BYTE sprite_num , valid 0-31
 280+ 4EBA              ;			INT x,
 281+ 4EBA              ;			INT y,
 282+ 4EBA              ;			INT pattern, valid 0-63, otherwise ignored
 283+ 4EBA              ;			INT color, valid 0-15, otherwise ignored
 284+ 4EBA              ;SPRSET:
 285+ 4EBA              ;	LD A, (SPRATR_INIT_STATUS)
 286+ 4EBA              ;	OR A
 287+ 4EBA              ;	JR NZ, .L1
 288+ 4EBA              ;	LD E, 5 ; illegal function call
 289+ 4EBA              ;	JP THROW_ERROR
 290+ 4EBA              ;.L1:
 291+ 4EBA              ;	; opening (
 292+ 4EBA              ;	CALL CHKCHAR
 293+ 4EBA              ;	DB '('
 294+ 4EBA              ;	; get sprite number
 295+ 4EBA              ;	LD IX, GETBYT
 296+ 4EBA              ;	CALL CALBAS
 297+ 4EBA              ;	PUSH AF
 298+ 4EBA              ;	; comma
 299+ 4EBA              ;	CALL CHKCHAR
 300+ 4EBA              ;	DB ','
 301+ 4EBA              ;	; get x
 302+ 4EBA              ;	LD IX, FRMQNT
 303+ 4EBA              ;	CALL CALBAS
 304+ 4EBA              ;	PUSH DE
 305+ 4EBA              ;	; comma
 306+ 4EBA              ;	CALL CHKCHAR
 307+ 4EBA              ;	DB ','
 308+ 4EBA              ;	; get y
 309+ 4EBA              ;	LD IX, FRMQNT
 310+ 4EBA              ;	CALL CALBAS
 311+ 4EBA              ;	PUSH DE
 312+ 4EBA              ;	; comma
 313+ 4EBA              ;	CALL CHKCHAR
 314+ 4EBA              ;	DB ','
 315+ 4EBA              ;	; get pattern
 316+ 4EBA              ;	LD IX, FRMQNT
 317+ 4EBA              ;	CALL CALBAS
 318+ 4EBA              ;	PUSH DE
 319+ 4EBA              ;	; comma
 320+ 4EBA              ;	CALL CHKCHAR
 321+ 4EBA              ;	DB ','
 322+ 4EBA              ;	; get color
 323+ 4EBA              ;	LD IX, FRMQNT
 324+ 4EBA              ;	CALL CALBAS
 325+ 4EBA              ;	PUSH DE
 326+ 4EBA              ;	; ending )
 327+ 4EBA              ;	CALL CHKCHAR
 328+ 4EBA              ;	DB ')'
 329+ 4EBA              ;
 330+ 4EBA              ;   ; save position in BASIC text
 331+ 4EBA              ;	PUSH HL
 332+ 4EBA              ;	POP IX
 333+ 4EBA              ;
 334+ 4EBA              ;	POP BC ; color
 335+ 4EBA              ;	POP DE ; pattern
 336+ 4EBA              ;	EXX
 337+ 4EBA              ;	POP BC ; y
 338+ 4EBA              ;	POP DE ; x
 339+ 4EBA              ;	POP AF ; sprite number
 340+ 4EBA              ;	CP 32
 341+ 4EBA              ;	JR C, .L2
 342+ 4EBA              ;	LD E, 5 ; illegal function call
 343+ 4EBA              ;	JP THROW_ERROR
 344+ 4EBA              ;.L2:
 345+ 4EBA              ;	; find location in sprite attributes table
 346+ 4EBA              ;	PUSH DE
 347+ 4EBA              ;	CALL GETnthSPRATTR
 348+ 4EBA              ;	POP DE
 349+ 4EBA              ;	DI
 350+ 4EBA              ;	; set y
 351+ 4EBA              ;	LD (HL), C
 352+ 4EBA              ;	INC HL
 353+ 4EBA              ;	LD (HL), B
 354+ 4EBA              ;	INC HL
 355+ 4EBA              ;	; set x
 356+ 4EBA              ;	LD (HL), E
 357+ 4EBA              ;	INC HL
 358+ 4EBA              ;	LD (HL), D
 359+ 4EBA              ;	INC HL
 360+ 4EBA              ;	PUSH HL
 361+ 4EBA              ;	EXX
 362+ 4EBA              ;	POP HL
 363+ 4EBA              ;	; check if 0<=pattern<64
 364+ 4EBA              ;	LD A, D
 365+ 4EBA              ;	OR A
 366+ 4EBA              ;	JR NZ, .L3
 367+ 4EBA              ;	LD A, E
 368+ 4EBA              ;	CP 64
 369+ 4EBA              ;	JR NC, .L3
 370+ 4EBA              ;	; set pattern
 371+ 4EBA              ;	;ADD A, A
 372+ 4EBA              ;	;ADD A, A
 373+ 4EBA              ;	;ADD A, A
 374+ 4EBA              ;	LD (HL), A
 375+ 4EBA              ;	INC HL
 376+ 4EBA              ;	LD (HL), D
 377+ 4EBA              ;	INC HL
 378+ 4EBA              ;	JR .L4
 379+ 4EBA              ;.L3:
 380+ 4EBA              ;	; skip pattern
 381+ 4EBA              ;	.2 INC HL
 382+ 4EBA              ;.L4:
 383+ 4EBA              ;	; check if 0<=color<16
 384+ 4EBA              ;	LD A, B
 385+ 4EBA              ;	OR A
 386+ 4EBA              ;	JR NZ, .L5
 387+ 4EBA              ;	LD A, C
 388+ 4EBA              ;	CP 16
 389+ 4EBA              ;	JR NC, .L5
 390+ 4EBA              ;	; set color
 391+ 4EBA              ;	LD (HL), C
 392+ 4EBA              ;	INC HL
 393+ 4EBA              ;	LD (HL), B
 394+ 4EBA              ;
 395+ 4EBA              ;.L5:
 396+ 4EBA              ;	EI
 397+ 4EBA              ;	PUSH IX
 398+ 4EBA              ;	POP HL
 399+ 4EBA              ;	RET
 400+ 4EBA              ; *******************************************************************************************************
 401+ 4EBA
 402+ 4EBA              ; *******************************************************************************************************
 403+ 4EBA              ; function sets sprite location based on initial coordinates and offset provided
 404+ 4EBA              ; input A=sprite number in SPRATR_DATA , 0-31
 405+ 4EBA              ; input DE=initial x
 406+ 4EBA              ; input BC=initial y
 407+ 4EBA              ; input IY=location where delta y,x are located
 408+ 4EBA              ; modifies AF, HL, IX
 409+ 4EBA              SPRSET_DELTA_POS:
 410+ 4EBA D5           	PUSH DE
 411+ 4EBB CD 89 4D     	CALL GETnthSPRATTR
 412+ 4EBE E5           	PUSH HL
 413+ 4EBF DD E1        	POP IX
 414+ 4EC1 D1           	POP DE
 415+ 4EC2              	; IX=sprite's y location
 416+ 4EC2 FD 6E 00     	LD L, (IY)
 417+ 4EC5 FD 66 01     	LD H, (IY+1)
 418+ 4EC8 09           	ADD HL, BC
 419+ 4EC9 DD 75 00     	LD (IX), L
 420+ 4ECC DD 74 01     	LD (IX+1), H
 421+ 4ECF FD 6E 02     	LD L, (IY+2)
 422+ 4ED2 FD 66 03     	LD H, (IY+3)
 423+ 4ED5 19           	ADD HL, DE
 424+ 4ED6 DD 75 02     	LD (IX+2), L
 425+ 4ED9 DD 74 03     	LD (IX+3), H
 426+ 4EDC C9           	RET
 427+ 4EDD              ; *******************************************************************************************************
 428+ 4EDD
 429+ 4EDD              ; *******************************************************************************************************
 430+ 4EDD              ; helper function to set new locations for a set of sprites
 431+ 4EDD              ; input B=number of sprites
 432+ 4EDD              ; HL=pointer to list of sprites and offsets
 433+ 4EDD              SPR_UPDATE_LOC:
 434+ 4EDD 3E 01        	LD A,1
 435+ 4EDF 32 4E 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 436+ 4EE2 7E           	LD A, (HL)
 437+ 4EE3 23           	INC HL
 438+ 4EE4 23           	INC HL
 439+ 4EE5 E5           	PUSH HL
 440+ 4EE6 FD E1        	POP IY
 441+ 4EE8 D9           	EXX
 442+ 4EE9 CD BA 4E     	CALL SPRSET_DELTA_POS
 443+ 4EEC D9           	EXX
 444+ 4EED 23          > INC HL
 444+ 4EEE 23          > INC HL
 444+ 4EEF 23          > INC HL
 444+ 4EF0 23          > INC HL
 445+ 4EF1 10 EA        	DJNZ SPR_UPDATE_LOC
 446+ 4EF3 AF           	XOR A
 447+ 4EF4 32 4E 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 448+ 4EF7 C9           	RET
 449+ 4EF8              ; *******************************************************************************************************
 450+ 4EF8
 451+ 4EF8               IF (1 == 1)
 452+ 4EF8              ; *******************************************************************************************************
 453+ 4EF8              ; function to handle CALL SPRGRPMOV basic extension
 454+ 4EF8              ; sets position of a group of sprites described with
 455+ 4EF8              ; { int sprite_num, int delta_y, int delta_x } [count]
 456+ 4EF8              ; _SPRGRPMOV ( INT x,
 457+ 4EF8              ;			   INT y,
 458+ 4EF8              ;			   BYTE count,
 459+ 4EF8              ;			   INT[2][count] data_ptr
 460+ 4EF8              SPRGRPMOV:
 461+ 4EF8 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
 462+ 4EFB B7           	OR A
 463+ 4EFC CA 6D 65     	JP Z,ILLEGAL_FUNCTION
 464+ 4EFF              	; opening (
 465+ 4EFF CD 4D 65     	CALL CHKCHAR
 466+ 4F02 28           	DB '('
 467+ 4F03              	; get x
 468+ 4F03 DD 21 2F 54  	LD IX, FRMQNT
 469+ 4F07 CD 59 01     	CALL CALBAS
 470+ 4F0A ED 53 3D 62  	LD (BLIT_STRUCT),DE
 471+ 4F0E              	; comma
 472+ 4F0E CD 4D 65     	CALL CHKCHAR
 473+ 4F11 2C           	DB ','
 474+ 4F12              	; get y
 475+ 4F12 DD 21 2F 54  	LD IX, FRMQNT
 476+ 4F16 CD 59 01     	CALL CALBAS
 477+ 4F19 ED 53 3F 62  	LD (BLIT_STRUCT+2),DE
 478+ 4F1D              	; comma
 479+ 4F1D CD 4D 65     	CALL CHKCHAR
 480+ 4F20 2C           	DB ','
 481+ 4F21              	; get count
 482+ 4F21 DD 21 1C 52  	LD IX, GETBYT
 483+ 4F25 CD 59 01     	CALL CALBAS
 484+ 4F28 32 41 62     	LD (BLIT_STRUCT+4),A
 485+ 4F2B              	; comma
 486+ 4F2B CD 4D 65     	CALL CHKCHAR
 487+ 4F2E 2C           	DB ','
 488+ 4F2F              	; get sprite group definition array data pointer
 489+ 4F2F 3A 41 62     	LD A,(BLIT_STRUCT+4)
 490+ 4F32 5F           	LD E,A
 491+ 4F33 16 03        	LD D,3
 492+ 4F35 3E 02        	LD A,2
 493+ 4F37 47           	LD B,A
 494+ 4F38 CD 7A 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
 495+ 4F3B ED 43 42 62  	LD (BLIT_STRUCT+5),BC
 496+ 4F3F              	; ending )
 497+ 4F3F CD 4D 65     	CALL CHKCHAR
 498+ 4F42 29           	DB ')'
 499+ 4F43
 500+ 4F43 E5           	PUSH HL
 501+ 4F44
 502+ 4F44 D9               EXX
 503+ 4F45 ED 5B 3D 62      LD DE,(BLIT_STRUCT) ; initial x
 504+ 4F49 ED 4B 3F 62      LD BC,(BLIT_STRUCT+2) ; initial y
 505+ 4F4D D9               EXX
 506+ 4F4E 2A 42 62         LD HL,(BLIT_STRUCT+5) ; pointer to data
 507+ 4F51 3A 41 62         LD A,(BLIT_STRUCT+4) ; number of entries
 508+ 4F54 47               LD B,A
 509+ 4F55 CD DD 4E     	CALL SPR_UPDATE_LOC
 510+ 4F58
 511+ 4F58 E1           	POP HL
 512+ 4F59 C9           	RET
 513+ 4F5A              ; *******************************************************************************************************
 514+ 4F5A               ENDIF
 515+ 4F5A
 516+ 4F5A               IF (0 == 1)
 517+ 4F5A ~            ; *******************************************************************************************************
 518+ 4F5A ~            ; same as SPRGRPMOV but for DEFUSR approach
 519+ 4F5A ~            ; input IX=pointer to input array, real data from +2
 520+ 4F5A ~            ; +2 = X
 521+ 4F5A ~            ; +4 = Y
 522+ 4F5A ~            ; +6 = count
 523+ 4F5A ~            ; +8 = data pointer
 524+ 4F5A ~            SPRGRPMOV_DEFUSR:
 525+ 4F5A ~                EXX
 526+ 4F5A ~            	LD E,(IX+2)
 527+ 4F5A ~            	LD D,(IX+3) ; initial x
 528+ 4F5A ~            	LD C,(IX+4)
 529+ 4F5A ~            	LD B,(IX+5) ; initial y
 530+ 4F5A ~                EXX
 531+ 4F5A ~            	LD L,(IX+8)
 532+ 4F5A ~            	LD H,(IX+9) ; pointer to data
 533+ 4F5A ~                LD B,(IX+6) ; count
 534+ 4F5A ~                JP SPR_UPDATE_LOC
 535+ 4F5A ~            ; *******************************************************************************************************
 536+ 4F5A               ENDIF
# file closed: asm\SPRITES.asm
 129  4F5A               ENDIF
 130  4F5A
 131  4F5A               IF (ANIM_CMDS == 1)
 132  4F5A               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4F5A              ; sprite animation routines
   2+ 4F5A
   3+ 4F5A              ; number of animation items and pointer
   4+ 4F5A              ANIMITEMNUM:
   5+ 4F5A 00            DB 0
   6+ 4F5B              ANIMITEMPTR:
   7+ 4F5B F0 65         DW EXT_END
   8+ 4F5D              ; number of animation definitions and pointer
   9+ 4F5D              ANIMDEFNUM:
  10+ 4F5D 00            DB 0
  11+ 4F5E              ANIMDEFPTR:
  12+ 4F5E F0 65         DW EXT_END
  13+ 4F60              ; number of links between sprite and animation definitions
  14+ 4F60              ANIMSPRNUM:
  15+ 4F60 00            DB 0
  16+ 4F61              ANIMSPRPTR:
  17+ 4F61 F0 65         DW EXT_END
  18+ 4F63              ; number of automatic sprite group move and animate structures
  19+ 4F63              AUTOSGAMNUM:
  20+ 4F63 00            DB 0
  21+ 4F64              AUTOSGAMPTR:
  22+ 4F64 F0 65         DW EXT_END
  23+ 4F66
  24+ 4F66              ; ANIMATION ITEM
  25+ 4F66              ; byte type = [0 - pattern and color change
  26+ 4F66              ;              1 - pattern definition change ]
  27+ 4F66              ; word ticks - number of ticks to hold this state
  28+ 4F66              ; for type = 0
  29+ 4F66              ;   byte pattern;
  30+ 4F66              ;   byte color;
  31+ 4F66              ; for type = 1
  32+ 4F66              ;   work data_pointer;
  33+ 4F66              ; total size = 5b
  34+ 4F66
  35+ 4F66              ; ANIMATION DEFINITION
  36+ 4F66              ; byte number of items 1-15
  37+ 4F66              ; byte[15] anim_item;
  38+ 4F66              ; total size = 16b
  39+ 4F66
  40+ 4F66              ; SPRITE/CHAR ANIMATION
  41+ 4F66              ; +00 byte sprite/char number;
  42+ 4F66              ; +01 word time;
  43+ 4F66              ; +03 byte current item;
  44+ 4F66              ; +04 byte animation definition;
  45+ 4F66              ; +05 byte cyclic;
  46+ 4F66              ; +06 byte active;
  47+ 4F66              ; +07 byte 0=sprite, 1-3 character bank
  48+ 4F66              ; total size = 8b
  49+ 4F66
  50+ 4F66              ; AUTOMATIC SPRITE GROUP MOVE AND ANIMATE structure
  51+ 4F66              ; +00 pointer to X variable
  52+ 4F66              ; +02 pointer to Y variable
  53+ 4F66              ; +04 minimum value
  54+ 4F66              ; +06 maximal value
  55+ 4F66              ; +08 delta value
  56+ 4F66              ; +10 direction 0=horizontal, <>0 = vertical
  57+ 4F66              ; +11 sprite group size
  58+ 4F66              ; +12 sprite group pointer
  59+ 4F66              ; +14 animation list size
  60+ 4F66              ; +15 animation list pointer for negative delta values
  61+ 4F66              ; +17 animation list pointer for positive delta values
  62+ 4F66              ; +19 active flag
  63+ 4F66              ; +20 ticks for movement
  64+ 4F66              ; +22 timer
  65+ 4F66              ; total = 24b
  66+ 4F66
  67+ 4F66              ; *******************************************************************************************************
  68+ 4F66              ; helper function HL=A*5
  69+ 4F66              ; changes HL,DE
  70+ 4F66              Ax5:
  71+ 4F66 26 00            LD H,0
  72+ 4F68 6F               LD L,A
  73+ 4F69 54               LD D,H
  74+ 4F6A 5D               LD E,L
  75+ 4F6B 29               ADD HL,HL
  76+ 4F6C 29               ADD HL,HL
  77+ 4F6D 19               ADD HL,DE
  78+ 4F6E C9               RET
  79+ 4F6F              ; *******************************************************************************************************
  80+ 4F6F
  81+ 4F6F              ; *******************************************************************************************************
  82+ 4F6F              ; helper function gets pointer to n-th animation item
  83+ 4F6F              ; changes HL,DE
  84+ 4F6F              GETnthANIMITEM:
  85+ 4F6F CD 66 4F         CALL Ax5
  86+ 4F72 ED 5B 5B 4F      LD DE,(ANIMITEMPTR)
  87+ 4F76 19               ADD HL,DE
  88+ 4F77 C9               RET
  89+ 4F78              ; *******************************************************************************************************
  90+ 4F78
  91+ 4F78              ; *******************************************************************************************************
  92+ 4F78              ; helper function gets pointer to n-th entry in animation definition
  93+ 4F78              ; changes HL,DE
  94+ 4F78              GETnthANIMDEF:
  95+ 4F78 26 00            LD H,0
  96+ 4F7A 6F               LD L,A
  97+ 4F7B CD 39 64         CALL HLx16
  98+ 4F7E ED 5B 5E 4F      LD DE,(ANIMDEFPTR)
  99+ 4F82 19               ADD HL,DE
 100+ 4F83 C9               RET
 101+ 4F84              ; *******************************************************************************************************
 102+ 4F84
 103+ 4F84              ; *******************************************************************************************************
 104+ 4F84              ; helper function gets pointer to n-th entry in sprite animation
 105+ 4F84              ; changes HL,DE
 106+ 4F84              GETnthSPRANIM:
 107+ 4F84 26 00            LD H,0
 108+ 4F86 6F               LD L,A
 109+ 4F87 CD 3A 64         CALL HLx8
 110+ 4F8A ED 5B 61 4F      LD DE,(ANIMSPRPTR)
 111+ 4F8E 19               ADD HL,DE
 112+ 4F8F C9               RET
 113+ 4F90              ; *******************************************************************************************************
 114+ 4F90
 115+ 4F90              ; *******************************************************************************************************
 116+ 4F90              ; helper function gets pointer to n-th entry in autosgam table
 117+ 4F90              ; changes HL,DE
 118+ 4F90              GETnthAUTOSGAM:
 119+ 4F90 26 00            LD H,0
 120+ 4F92 6F               LD L,A
 121+ 4F93 CD 3A 64         CALL HLx8
 122+ 4F96 54               LD D,H
 123+ 4F97 5D               LD E,L
 124+ 4F98 29               ADD HL,HL
 125+ 4F99 19               ADD HL,DE
 126+ 4F9A ED 5B 64 4F      LD DE,(AUTOSGAMPTR)
 127+ 4F9E 19               ADD HL,DE
 128+ 4F9F C9               RET
 129+ 4FA0              ; *******************************************************************************************************
 130+ 4FA0
 131+ 4FA0               IF (0 == 1)
 132+ 4FA0 ~            ; *******************************************************************************************************
 133+ 4FA0 ~            ; same as MAXIANIMITEMS but for DEFUSR approach
 134+ 4FA0 ~            ; input IX=pointer to input array, real data from +2
 135+ 4FA0 ~            ; +2 = number
 136+ 4FA0 ~            MAXANIMITEMS_DEFUSR:
 137+ 4FA0 ~                LD A,(IX+2)
 138+ 4FA0 ~                JR MAXANIMITEMS.COMMON
 139+ 4FA0 ~            ; *******************************************************************************************************
 140+ 4FA0               ENDIF
 141+ 4FA0
 142+ 4FA0              ; *******************************************************************************************************
 143+ 4FA0              ; function to handle CALL MAXANIMITEMS basic extension
 144+ 4FA0              ; MAXANIMITEMS (BYTE number)
 145+ 4FA0              ; sets new number and moves memory buffers as needed
 146+ 4FA0              MAXANIMITEMS:
 147+ 4FA0               IF (1 == 1)
 148+ 4FA0              	; opening (
 149+ 4FA0 CD 4D 65     	CALL CHKCHAR
 150+ 4FA3 28           	DB '('
 151+ 4FA4              	; get value
 152+ 4FA4 DD 21 1C 52  	LD IX, GETBYT
 153+ 4FA8 CD 59 01     	CALL CALBAS
 154+ 4FAB F5               PUSH AF
 155+ 4FAC              	; ending )
 156+ 4FAC CD 4D 65     	CALL CHKCHAR
 157+ 4FAF 29           	DB ')'
 158+ 4FB0 F1               POP AF
 159+ 4FB1               ENDIF
 160+ 4FB1              .COMMON: ; entry for DEFUSR part, A=number
 161+ 4FB1 F3               DI
 162+ 4FB2              	; save position
 163+ 4FB2 E5           	PUSH HL
 164+ 4FB3              .ENTRY:
 165+ 4FB3 47               LD B,A
 166+ 4FB4 3A 5A 4F         LD A,(ANIMITEMNUM)
 167+ 4FB7 90               SUB B
 168+ 4FB8 28 28            JR Z, .EXIT; same value as before
 169+ 4FBA FD 21 5E 4F      LD IY,ANIMDEFPTR
 170+ 4FBE FA E5 4F         JP M, .INCREASE
 171+ 4FC1                  ; new value is lower than previous one
 172+ 4FC1 CD 04 50         CALL .SIZEDIFF
 173+ 4FC4 CD 1F 50         CALL .DECREASE_COMMON
 174+ 4FC7 2A 61 4F         LD HL,(ANIMSPRPTR)
 175+ 4FCA AF               XOR A
 176+ 4FCB ED 42            SBC HL,BC
 177+ 4FCD 22 61 4F         LD (ANIMSPRPTR),HL
 178+ 4FD0              .E1:
 179+ 4FD0 2A 64 4F         LD HL,(AUTOSGAMPTR)
 180+ 4FD3 AF               XOR A
 181+ 4FD4 ED 42            SBC HL,BC
 182+ 4FD6 22 64 4F         LD (AUTOSGAMPTR),HL
 183+ 4FD9              .E3:
 184+ 4FD9 2A 10 40         LD HL,(FREEMEMPTR)
 185+ 4FDC AF               XOR A
 186+ 4FDD ED 42            SBC HL,BC
 187+ 4FDF 22 10 40         LD (FREEMEMPTR),HL
 188+ 4FE2              .EXIT:
 189+ 4FE2 FB               EI
 190+ 4FE3 E1           	POP HL
 191+ 4FE4 C9           	RET
 192+ 4FE5              .INCREASE:
 193+ 4FE5 ED 44            NEG
 194+ 4FE7 CD 04 50         CALL .SIZEDIFF
 195+ 4FEA CD 4B 50         CALL .INCREASE_COMMON
 196+ 4FED 2A 61 4F         LD HL,(ANIMSPRPTR)
 197+ 4FF0 09               ADD HL,BC
 198+ 4FF1 22 61 4F         LD (ANIMSPRPTR),HL
 199+ 4FF4              .E2:
 200+ 4FF4 2A 64 4F         LD HL,(AUTOSGAMPTR)
 201+ 4FF7 09               ADD HL,BC
 202+ 4FF8 22 64 4F         LD (AUTOSGAMPTR),HL
 203+ 4FFB              .E4:
 204+ 4FFB 2A 10 40         LD HL,(FREEMEMPTR)
 205+ 4FFE 09               ADD HL,BC
 206+ 4FFF 22 10 40         LD (FREEMEMPTR),HL
 207+ 5002 18 DE            JR .EXIT
 208+ 5004              .SIZEDIFF:
 209+ 5004 CD 66 4F         CALL Ax5
 210+ 5007 78               LD A,B
 211+ 5008 32 5A 4F         LD (ANIMITEMNUM),A
 212+ 500B 44               LD B,H
 213+ 500C 4D               LD C,L
 214+ 500D C9               RET ; BC=size difference in bytes
 215+ 500E              .SIZETOMOVE:
 216+ 500E D5               PUSH DE
 217+ 500F 2A 10 40         LD HL,(FREEMEMPTR)
 218+ 5012 FD 5E 00         LD E,(IY)
 219+ 5015 FD 56 01         LD D,(IY+1)
 220+ 5018 AF               XOR A
 221+ 5019 ED 52            SBC HL,DE
 222+ 501B 44               LD B,H
 223+ 501C 4D               LD C,L
 224+ 501D D1               POP DE
 225+ 501E C9               RET
 226+ 501F              .DECREASE_COMMON:
 227+ 501F FD 6E 00         LD L,(IY)
 228+ 5022 FD 66 01         LD H,(IY+1)
 229+ 5025 AF               XOR A
 230+ 5026 ED 42            SBC HL,BC
 231+ 5028 EB               EX DE,HL
 232+ 5029 C5               PUSH BC
 233+ 502A CD 0E 50         CALL .SIZETOMOVE
 234+ 502D F3               DI
 235+ 502E 78               LD A,B
 236+ 502F B1               OR C
 237+ 5030 28 08            JR Z,.L1
 238+ 5032 FD 6E 00         LD L,(IY)
 239+ 5035 FD 66 01         LD H,(IY+1)
 240+ 5038 ED B0            LDIR
 241+ 503A              .L1:
 242+ 503A C1               POP BC
 243+ 503B FD 6E 00         LD L,(IY)
 244+ 503E FD 66 01         LD H,(IY+1)
 245+ 5041 AF               XOR A
 246+ 5042 ED 42            SBC HL,BC
 247+ 5044 FD 75 00         LD (IY),L
 248+ 5047 FD 74 01         LD (IY+1),H
 249+ 504A C9               RET
 250+ 504B              .INCREASE_COMMON:
 251+ 504B 2A 10 40         LD HL,(FREEMEMPTR)
 252+ 504E 2B               DEC HL
 253+ 504F AF               XOR A
 254+ 5050 ED 42            SBC HL,BC
 255+ 5052 EB               EX DE,HL
 256+ 5053 C5               PUSH BC
 257+ 5054 CD 0E 50         CALL .SIZETOMOVE
 258+ 5057 F3               DI
 259+ 5058 78               LD A,B
 260+ 5059 B1               OR C
 261+ 505A 28 06            JR Z,.L2
 262+ 505C 2A 10 40         LD HL,(FREEMEMPTR)
 263+ 505F 2B               DEC HL
 264+ 5060 ED B8            LDDR
 265+ 5062              .L2:
 266+ 5062 C1               POP BC
 267+ 5063 FD 6E 00         LD L,(IY)
 268+ 5066 FD 66 01         LD H,(IY+1)
 269+ 5069 09               ADD HL,BC
 270+ 506A FD 75 00         LD (IY),L
 271+ 506D FD 74 01         LD (IY+1),H
 272+ 5070 C9               RET
 273+ 5071              ; *******************************************************************************************************
 274+ 5071
 275+ 5071               IF (1 == 1)
 276+ 5071              ; *******************************************************************************************************
 277+ 5071              ; function to handle CALL ANIMITEMPAT basic extension
 278+ 5071              ; ANIMITEMPAT ( BYTE id,
 279+ 5071              ;               INT ticks >0,
 280+ 5071              ;               BYTE pattern,
 281+ 5071              ;               BYTE color )
 282+ 5071              ; fills animation item data, returns an error if ID out of bounds
 283+ 5071              ANIMITEMPAT:
 284+ 5071                  ; opening (
 285+ 5071 CD 4D 65     	CALL CHKCHAR
 286+ 5074 28           	DB '('
 287+ 5075              	; get id
 288+ 5075 DD 21 1C 52  	LD IX, GETBYT
 289+ 5079 CD 59 01     	CALL CALBAS
 290+ 507C F5               PUSH AF
 291+ 507D                  ; check if out of bounds
 292+ 507D 3C               INC A
 293+ 507E 4F               LD C,A
 294+ 507F 3A 5A 4F         LD A,(ANIMITEMNUM)
 295+ 5082 B9               CP C
 296+ 5083 DA 65 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 297+ 5086              	; comma
 298+ 5086 CD 4D 65     	CALL CHKCHAR
 299+ 5089 2C           	DB ','
 300+ 508A              	; get ticks
 301+ 508A DD 21 2F 54  	LD IX, FRMQNT
 302+ 508E CD 59 01     	CALL CALBAS
 303+ 5091 7A               LD A,D
 304+ 5092 B3               OR E
 305+ 5093 CA 69 65         JP Z, OVERFLOW
 306+ 5096 D5           	PUSH DE
 307+ 5097              	; comma
 308+ 5097 CD 4D 65     	CALL CHKCHAR
 309+ 509A 2C           	DB ','
 310+ 509B              	; get pattern
 311+ 509B DD 21 1C 52  	LD IX, GETBYT
 312+ 509F CD 59 01     	CALL CALBAS
 313+ 50A2 F5               PUSH AF
 314+ 50A3              	; comma
 315+ 50A3 CD 4D 65     	CALL CHKCHAR
 316+ 50A6 2C           	DB ','
 317+ 50A7              	; get color
 318+ 50A7 DD 21 1C 52  	LD IX, GETBYT
 319+ 50AB CD 59 01     	CALL CALBAS
 320+ 50AE F5               PUSH AF
 321+ 50AF              	; ending )
 322+ 50AF CD 4D 65     	CALL CHKCHAR
 323+ 50B2 29           	DB ')'
 324+ 50B3              .ENTRY:
 325+ 50B3 E5               PUSH HL
 326+ 50B4 DD E1            POP IX
 327+ 50B6 D9               EXX
 328+ 50B7 C1               POP BC ; color
 329+ 50B8 D1               POP DE ; pattern
 330+ 50B9 E1               POP HL ; ticks
 331+ 50BA D9               EXX
 332+ 50BB F1               POP AF
 333+ 50BC CD 6F 4F         CALL GETnthANIMITEM
 334+ 50BF E5               PUSH HL
 335+ 50C0 FD E1            POP IY
 336+ 50C2 D9               EXX
 337+ 50C3 FD 36 00 00      LD (IY),0 ; type=0
 338+ 50C7 FD 75 01         LD (IY+1),L
 339+ 50CA FD 74 02         LD (IY+2),H
 340+ 50CD FD 72 03         LD (IY+3),D
 341+ 50D0 FD 70 04         LD (IY+4),B
 342+ 50D3
 343+ 50D3 DD E5            PUSH IX
 344+ 50D5 E1               POP HL
 345+ 50D6 C9               RET
 346+ 50D7              ; *******************************************************************************************************
 347+ 50D7               ENDIF
 348+ 50D7
 349+ 50D7               IF (0 == 1)
 350+ 50D7 ~            ; *******************************************************************************************************
 351+ 50D7 ~            ; same as ANIMITEMPAT but for DEFUSR approach
 352+ 50D7 ~            ; input IX=pointer to input array, real data from +2
 353+ 50D7 ~            ; +02 = ID
 354+ 50D7 ~            ; +04 = ticks
 355+ 50D7 ~            ; +06 = pattern
 356+ 50D7 ~            ; +08 = color
 357+ 50D7 ~            ANIMITEMPAT_DEFUSR:
 358+ 50D7 ~                ; check if out of bounds
 359+ 50D7 ~                LD C,(IX+2)
 360+ 50D7 ~                INC C
 361+ 50D7 ~                LD A,(ANIMITEMNUM)
 362+ 50D7 ~                CP C
 363+ 50D7 ~                RET C ; out of bounds, prevent memory corruption
 364+ 50D7 ~                LD A,C
 365+ 50D7 ~                DEC A
 366+ 50D7 ~                CALL GETnthANIMITEM
 367+ 50D7 ~                LD (HL),0 ; type=0
 368+ 50D7 ~                INC HL
 369+ 50D7 ~                LD A,(IX+4) ; ticks low
 370+ 50D7 ~                LD (HL),A
 371+ 50D7 ~                INC HL
 372+ 50D7 ~                LD A,(IX+5) ; ticks high
 373+ 50D7 ~                LD (HL),A
 374+ 50D7 ~                INC HL
 375+ 50D7 ~                LD A,(IX+6) ; pattern
 376+ 50D7 ~                LD (HL),A
 377+ 50D7 ~                INC HL
 378+ 50D7 ~                LD A,(IX+8) ; color
 379+ 50D7 ~                LD (HL),A
 380+ 50D7 ~                RET
 381+ 50D7 ~            ; *******************************************************************************************************
 382+ 50D7               ENDIF
 383+ 50D7
 384+ 50D7               IF (1 == 1)
 385+ 50D7              ; *******************************************************************************************************
 386+ 50D7              ; function to handle CALL ANIMITEMPTR basic extension
 387+ 50D7              ; ANIMITEMPTR ( BYTE id,
 388+ 50D7              ;               INT ticks,
 389+ 50D7              ;               INT pointer,
 390+ 50D7              ; fills animation item data, returns an error if ID out of bounds
 391+ 50D7              ANIMITEMPTR_CMD:
 392+ 50D7                  ; opening (
 393+ 50D7 CD 4D 65     	CALL CHKCHAR
 394+ 50DA 28           	DB '('
 395+ 50DB              	; get id
 396+ 50DB DD 21 1C 52  	LD IX, GETBYT
 397+ 50DF CD 59 01     	CALL CALBAS
 398+ 50E2 F5               PUSH AF
 399+ 50E3                  ; check if out of bounds
 400+ 50E3 3C               INC A
 401+ 50E4 4F               LD C,A
 402+ 50E5 3A 5A 4F         LD A,(ANIMITEMNUM)
 403+ 50E8 B9               CP C
 404+ 50E9 DA 65 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 405+ 50EC              	; comma
 406+ 50EC CD 4D 65     	CALL CHKCHAR
 407+ 50EF 2C           	DB ','
 408+ 50F0              	; get ticks
 409+ 50F0 DD 21 2F 54  	LD IX, FRMQNT
 410+ 50F4 CD 59 01     	CALL CALBAS
 411+ 50F7 7A               LD A,D
 412+ 50F8 B3               OR E
 413+ 50F9 CA 69 65         JP Z,OVERFLOW
 414+ 50FC D5           	PUSH DE
 415+ 50FD              	; comma
 416+ 50FD CD 4D 65     	CALL CHKCHAR
 417+ 5100 2C           	DB ','
 418+ 5101              	; get pointer
 419+ 5101 DD 21 2F 54  	LD IX, FRMQNT
 420+ 5105 CD 59 01     	CALL CALBAS
 421+ 5108 D5           	PUSH DE
 422+ 5109              	; ending )
 423+ 5109 CD 4D 65     	CALL CHKCHAR
 424+ 510C 29           	DB ')'
 425+ 510D              .ENTRY:
 426+ 510D E5               PUSH HL
 427+ 510E DD E1            POP IX
 428+ 5110 D9               EXX
 429+ 5111 D1               POP DE ; pointer
 430+ 5112 E1               POP HL ; ticks
 431+ 5113 D9               EXX
 432+ 5114 F1               POP AF
 433+ 5115 CD 6F 4F         CALL GETnthANIMITEM
 434+ 5118 E5               PUSH HL
 435+ 5119 FD E1            POP IY
 436+ 511B D9               EXX
 437+ 511C FD 36 00 01      LD (IY),1 ; type=1
 438+ 5120 FD 75 01         LD (IY+1),L
 439+ 5123 FD 74 02         LD (IY+2),H
 440+ 5126 FD 73 03         LD (IY+3),E
 441+ 5129 FD 72 04         LD (IY+4),D
 442+ 512C
 443+ 512C DD E5            PUSH IX
 444+ 512E E1               POP HL
 445+ 512F C9               RET
 446+ 5130              ; *******************************************************************************************************
 447+ 5130               ENDIF
 448+ 5130
 449+ 5130               IF (0 == 1)
 450+ 5130 ~            ; *******************************************************************************************************
 451+ 5130 ~            ; same as ANIMITEMPTR but for DEFUSR approach
 452+ 5130 ~            ; input IX=pointer to input array, real data from +2
 453+ 5130 ~            ; +02 = ID
 454+ 5130 ~            ; +04 = ticks
 455+ 5130 ~            ; +06 = pointer
 456+ 5130 ~            ANIMITEMPTR_DEFUSR:
 457+ 5130 ~                ; check if out of bounds
 458+ 5130 ~                LD C,(IX+2)
 459+ 5130 ~                INC C
 460+ 5130 ~                LD A,(ANIMITEMNUM)
 461+ 5130 ~                CP C
 462+ 5130 ~                RET C ; out of bounds, prevent memory corruption
 463+ 5130 ~                LD A,C
 464+ 5130 ~                DEC A
 465+ 5130 ~                CALL GETnthANIMITEM
 466+ 5130 ~                LD (HL),1 ; type=1
 467+ 5130 ~                INC HL
 468+ 5130 ~                LD A,(IX+4) ; ticks low
 469+ 5130 ~                LD (HL),A
 470+ 5130 ~                INC HL
 471+ 5130 ~                LD A,(IX+5) ; ticks high
 472+ 5130 ~                LD (HL),A
 473+ 5130 ~                INC HL
 474+ 5130 ~                LD A,(IX+6) ; pointer low
 475+ 5130 ~                LD (HL),A
 476+ 5130 ~                INC HL
 477+ 5130 ~                LD A,(IX+7) ; pointer high
 478+ 5130 ~                LD (HL),A
 479+ 5130 ~                RET
 480+ 5130 ~            ; *******************************************************************************************************
 481+ 5130               ENDIF
 482+ 5130
 483+ 5130               IF (0 == 1)
 484+ 5130 ~            ; *******************************************************************************************************
 485+ 5130 ~            ; same as MAXANIMDEFS but for DEFUSR approach
 486+ 5130 ~            ; input IX=pointer to input array, real data from +2
 487+ 5130 ~            ; +2 = number
 488+ 5130 ~            MAXANIMDEFS_DEFUSR:
 489+ 5130 ~                LD A,(IX+2)
 490+ 5130 ~                JR MAXANIMDEFS.COMMON
 491+ 5130 ~            ; *******************************************************************************************************
 492+ 5130               ENDIF
 493+ 5130
 494+ 5130              ; *******************************************************************************************************
 495+ 5130              ; function to handle CALL MAXANIMDEFS basic extension
 496+ 5130              ; MAXANIMDEFS (BYTE number)
 497+ 5130              ; sets new number and moves memory buffers as needed
 498+ 5130              MAXANIMDEFS:
 499+ 5130               IF (1 == 1)
 500+ 5130              	; opening (
 501+ 5130 CD 4D 65     	CALL CHKCHAR
 502+ 5133 28           	DB '('
 503+ 5134              	; get value
 504+ 5134 DD 21 1C 52  	LD IX, GETBYT
 505+ 5138 CD 59 01     	CALL CALBAS
 506+ 513B F5               PUSH AF
 507+ 513C              	; ending )
 508+ 513C CD 4D 65     	CALL CHKCHAR
 509+ 513F 29           	DB ')'
 510+ 5140 F1               POP AF
 511+ 5141               ENDIF
 512+ 5141              .COMMON:
 513+ 5141 F3               DI
 514+ 5142              	; save position
 515+ 5142 E5           	PUSH HL
 516+ 5143              .ENTRY:
 517+ 5143 47               LD B,A
 518+ 5144 3A 5D 4F         LD A,(ANIMDEFNUM)
 519+ 5147 90               SUB B
 520+ 5148 CA E2 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 521+ 514B FD 21 61 4F      LD IY,ANIMSPRPTR
 522+ 514F FA 5B 51         JP M, .INCREASE
 523+ 5152                  ; new value is lower than previous one
 524+ 5152 CD 66 51         CALL .SIZEDIFF
 525+ 5155 CD 1F 50         CALL MAXANIMITEMS.DECREASE_COMMON
 526+ 5158 C3 D0 4F         JP MAXANIMITEMS.E1
 527+ 515B              .INCREASE:
 528+ 515B ED 44            NEG
 529+ 515D CD 66 51         CALL .SIZEDIFF
 530+ 5160 CD 4B 50         CALL MAXANIMITEMS.INCREASE_COMMON
 531+ 5163 C3 F4 4F         JP MAXANIMITEMS.E2
 532+ 5166              .SIZEDIFF:
 533+ 5166 26 00            LD H,0
 534+ 5168 6F               LD L,A
 535+ 5169 CD 39 64         CALL HLx16
 536+ 516C 78               LD A,B
 537+ 516D 32 5D 4F         LD (ANIMDEFNUM),A
 538+ 5170 44               LD B,H
 539+ 5171 4D               LD C,L
 540+ 5172 C9               RET ; BC=size difference in bytes
 541+ 5173              ; *******************************************************************************************************
 542+ 5173
 543+ 5173               IF (1 == 1)
 544+ 5173              ; *******************************************************************************************************
 545+ 5173              ; function to handle CALL ANIMDEF basic extension
 546+ 5173              ; ANIMITEMPAT ( BYTE id,
 547+ 5173              ;               BYTE size,
 548+ 5173              ;               INT[] list )
 549+ 5173              ; fills animation definition data, returns an error if out of bounds, or invalid type
 550+ 5173              ANIMDEF:
 551+ 5173                  ; opening (
 552+ 5173 CD 4D 65     	CALL CHKCHAR
 553+ 5176 28           	DB '('
 554+ 5177              	; get id
 555+ 5177 DD 21 1C 52  	LD IX, GETBYT
 556+ 517B CD 59 01     	CALL CALBAS
 557+ 517E F5               PUSH AF
 558+ 517F                  ; check if out of bounds
 559+ 517F 3C               INC A
 560+ 5180 4F               LD C,A
 561+ 5181 3A 5D 4F         LD A,(ANIMDEFNUM)
 562+ 5184 B9               CP C
 563+ 5185 DA 65 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 564+ 5188              	; comma
 565+ 5188 CD 4D 65     	CALL CHKCHAR
 566+ 518B 2C           	DB ','
 567+ 518C              	; get size
 568+ 518C DD 21 1C 52  	LD IX, GETBYT
 569+ 5190 CD 59 01     	CALL CALBAS
 570+ 5193 FE 10            CP 16
 571+ 5195 D2 69 65         JP NC, OVERFLOW
 572+ 5198 B7               OR A
 573+ 5199 CA 69 65         JP Z, OVERFLOW
 574+ 519C F5           	PUSH AF
 575+ 519D              	; comma
 576+ 519D CD 4D 65     	CALL CHKCHAR
 577+ 51A0 2C           	DB ','
 578+ 51A1              	; get pointer to a list of animation items in integer array format
 579+ 51A1                  ; get array pointer
 580+ 51A1 D1               POP DE
 581+ 51A2 D5               PUSH DE
 582+ 51A3 3E 02            LD A,2
 583+ 51A5 06 01            LD B,1
 584+ 51A7 CD 7A 65         CALL GET_BASIC_ARRAY_DATA_POINTER
 585+ 51AA C5               PUSH BC
 586+ 51AB              	; ending )
 587+ 51AB CD 4D 65     	CALL CHKCHAR
 588+ 51AE 29           	DB ')'
 589+ 51AF              .ENTRY:
 590+ 51AF E5               PUSH HL
 591+ 51B0 DD E1            POP IX
 592+ 51B2 D1               POP DE ; pointer to INT array
 593+ 51B3 C1               POP BC ; B=item number
 594+ 51B4 F1               POP AF ; id
 595+ 51B5 D5               PUSH DE
 596+ 51B6 CD 78 4F         CALL GETnthANIMDEF
 597+ 51B9 D1               POP DE
 598+ 51BA 70               LD (HL),B
 599+ 51BB              .L1:
 600+ 51BB 23               INC HL
 601+ 51BC 1A               LD A,(DE)
 602+ 51BD 13          > INC DE
 602+ 51BE 13          > INC DE
 603+ 51BF 77               LD (HL),A
 604+ 51C0 10 F9            DJNZ .L1
 605+ 51C2 DD E5            PUSH IX
 606+ 51C4 E1               POP HL
 607+ 51C5 C9               RET
 608+ 51C6              ; *******************************************************************************************************
 609+ 51C6               ENDIF
 610+ 51C6
 611+ 51C6               IF (0 == 1)
 612+ 51C6 ~            ; *******************************************************************************************************
 613+ 51C6 ~            ; same as ANIMDEF but for DEFUSR approach
 614+ 51C6 ~            ; input IX=pointer to input array, real data from +2
 615+ 51C6 ~            ; +02 = ID
 616+ 51C6 ~            ; +04 = list size
 617+ 51C6 ~            ; +06 = list pointer
 618+ 51C6 ~            ANIMDEF_DEFUSR:
 619+ 51C6 ~                ; check if out of bounds
 620+ 51C6 ~                LD C,(IX+2)
 621+ 51C6 ~                INC C
 622+ 51C6 ~                LD A,(ANIMDEFNUM)
 623+ 51C6 ~                CP C
 624+ 51C6 ~                RET C ; invalid id
 625+ 51C6 ~            	; get size
 626+ 51C6 ~                LD A,(IX+4)
 627+ 51C6 ~                CP 16
 628+ 51C6 ~                RET NC ; overflow
 629+ 51C6 ~                OR A
 630+ 51C6 ~                RET Z ; ID=0, invalid
 631+ 51C6 ~                LD B,A
 632+ 51C6 ~                LD A,C
 633+ 51C6 ~                DEC A
 634+ 51C6 ~                CALL GETnthANIMDEF
 635+ 51C6 ~                LD (HL),B
 636+ 51C6 ~                LD E,(IX+6)
 637+ 51C6 ~                LD D,(IX+7)
 638+ 51C6 ~            .L1:
 639+ 51C6 ~                INC HL
 640+ 51C6 ~                LD A,(DE)
 641+ 51C6 ~                .2 INC DE
 642+ 51C6 ~                LD (HL),A
 643+ 51C6 ~                DJNZ .L1
 644+ 51C6 ~                RET
 645+ 51C6 ~            ; *******************************************************************************************************
 646+ 51C6               ENDIF
 647+ 51C6
 648+ 51C6               IF (0 == 1)
 649+ 51C6 ~            ; *******************************************************************************************************
 650+ 51C6 ~            ; same as MAXANIMSPRS but for DEFUSR approach
 651+ 51C6 ~            ; input IX=pointer to input array, real data from +2
 652+ 51C6 ~            ; +2 = number
 653+ 51C6 ~            MAXANIMSPRS_DEFUSR:
 654+ 51C6 ~                LD A,(IX+2)
 655+ 51C6 ~                JR MAXANIMSPRS.COMMON
 656+ 51C6 ~            ; *******************************************************************************************************
 657+ 51C6               ENDIF
 658+ 51C6
 659+ 51C6              ; *******************************************************************************************************
 660+ 51C6              ; function to handle CALL MAXANIMSPRS basic extension
 661+ 51C6              ; MAXANIMSPRS (BYTE number)
 662+ 51C6              ; sets new number and moves memory buffers as needed
 663+ 51C6              MAXANIMSPRS:
 664+ 51C6               IF (1 == 1)
 665+ 51C6              	; opening (
 666+ 51C6 CD 4D 65     	CALL CHKCHAR
 667+ 51C9 28           	DB '('
 668+ 51CA              	; get value
 669+ 51CA DD 21 1C 52  	LD IX, GETBYT
 670+ 51CE CD 59 01     	CALL CALBAS
 671+ 51D1 F5               PUSH AF
 672+ 51D2              	; ending )
 673+ 51D2 CD 4D 65     	CALL CHKCHAR
 674+ 51D5 29           	DB ')'
 675+ 51D6 F1               POP AF
 676+ 51D7               ENDIF
 677+ 51D7              .COMMON:
 678+ 51D7 F3               DI
 679+ 51D8              	; save position
 680+ 51D8 E5           	PUSH HL
 681+ 51D9              .ENTRY:
 682+ 51D9 47               LD B,A
 683+ 51DA 3A 60 4F         LD A,(ANIMSPRNUM)
 684+ 51DD 90               SUB B
 685+ 51DE CA E2 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 686+ 51E1 FD 21 64 4F      LD IY,AUTOSGAMPTR
 687+ 51E5 FA F1 51         JP M, .INCREASE
 688+ 51E8                  ; new value is lower than previous one
 689+ 51E8 CD 12 52         CALL .SIZEDIFF
 690+ 51EB CD 1F 50         CALL MAXANIMITEMS.DECREASE_COMMON
 691+ 51EE C3 D9 4F         JP MAXANIMITEMS.E3
 692+ 51F1              .INCREASE:
 693+ 51F1 ED 44            NEG
 694+ 51F3 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 695+ 51F4 CD 12 52         CALL .SIZEDIFF
 696+ 51F7 CD 4B 50         CALL MAXANIMITEMS.INCREASE_COMMON
 697+ 51FA AF               XOR A
 698+ 51FB ED 42            SBC HL,BC ; location of new stuff
 699+ 51FD F1               POP AF
 700+ 51FE C5               PUSH BC
 701+ 51FF 47               LD B,A
 702+ 5200 11 08 00         LD DE,8
 703+ 5203 E5               PUSH HL
 704+ 5204 DD E1            POP IX
 705+ 5206              .L1:
 706+ 5206 DD 36 06 00      LD (IX+6),0 ; active flag
 707+ 520A DD 19            ADD IX,DE
 708+ 520C 10 F8            DJNZ .L1
 709+ 520E C1               POP BC
 710+ 520F C3 FB 4F         JP MAXANIMITEMS.E4
 711+ 5212              .SIZEDIFF:
 712+ 5212 26 00            LD H,0
 713+ 5214 6F               LD L,A
 714+ 5215 CD 3A 64         CALL HLx8
 715+ 5218 78               LD A,B
 716+ 5219 32 60 4F         LD (ANIMSPRNUM),A
 717+ 521C 44               LD B,H
 718+ 521D 4D               LD C,L
 719+ 521E C9               RET ; BC=size difference in bytes
 720+ 521F              ; *******************************************************************************************************
 721+ 521F
 722+ 521F               IF (1 == 1)
 723+ 521F              ; *******************************************************************************************************
 724+ 521F              ; function to handle CALL ANIMSPRITE basic extension
 725+ 521F              ; ANIMSPRITE ( BYTE id,
 726+ 521F              ;              BYTE sprite_number,
 727+ 521F              ;              BYTE animation_definition_id,
 728+ 521F              ;              BYTE cyclic_flag )
 729+ 521F              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 730+ 521F              ANIMSPRITE:
 731+ 521F                  ; opening (
 732+ 521F CD 4D 65     	CALL CHKCHAR
 733+ 5222 28           	DB '('
 734+ 5223              	; get sprite animation id
 735+ 5223 DD 21 1C 52  	LD IX, GETBYT
 736+ 5227 CD 59 01     	CALL CALBAS
 737+ 522A F5               PUSH AF
 738+ 522B 3C               INC A
 739+ 522C 4F               LD C,A
 740+ 522D 3A 60 4F         LD A,(ANIMSPRNUM)
 741+ 5230 B9               CP C
 742+ 5231 DA 65 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 743+ 5234              	; comma
 744+ 5234 CD 4D 65     	CALL CHKCHAR
 745+ 5237 2C           	DB ','
 746+ 5238              	; get sprite number
 747+ 5238 DD 21 1C 52  	LD IX, GETBYT
 748+ 523C CD 59 01     	CALL CALBAS
 749+ 523F F5               PUSH AF
 750+ 5240                  ; check if out of bounds
 751+ 5240 FE 20            CP 32
 752+ 5242 D2 65 65         JP NC, SUBSCRIPT_OUT_OF_RANGE
 753+ 5245              	; comma
 754+ 5245 CD 4D 65     	CALL CHKCHAR
 755+ 5248 2C           	DB ','
 756+ 5249              	; get animation definition id
 757+ 5249 DD 21 1C 52  	LD IX, GETBYT
 758+ 524D CD 59 01     	CALL CALBAS
 759+ 5250 F5               PUSH AF
 760+ 5251 3C               INC A
 761+ 5252 4F               LD C,A
 762+ 5253 3A 5D 4F         LD A,(ANIMDEFNUM)
 763+ 5256 B9               CP C
 764+ 5257 DA 65 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 765+ 525A              	; comma
 766+ 525A CD 4D 65     	CALL CHKCHAR
 767+ 525D 2C           	DB ','
 768+ 525E              	; get cyclic flag
 769+ 525E DD 21 1C 52  	LD IX, GETBYT
 770+ 5262 CD 59 01         CALL CALBAS
 771+ 5265 F5           	PUSH AF
 772+ 5266              	; ending )
 773+ 5266 CD 4D 65     	CALL CHKCHAR
 774+ 5269 29           	DB ')'
 775+ 526A              .ENTRY:
 776+ 526A E5               PUSH HL
 777+ 526B DD E1            POP IX
 778+ 526D D9               EXX
 779+ 526E D1               POP DE ; cyclic
 780+ 526F C1               POP BC ; animation definition id
 781+ 5270 E1               POP HL ; sprite number
 782+ 5271 D9               EXX
 783+ 5272 F1               POP AF ; sprite animation id
 784+ 5273 CD 84 4F         CALL GETnthSPRANIM
 785+ 5276 E5               PUSH HL
 786+ 5277 FD E1            POP IY
 787+ 5279 D9               EXX
 788+ 527A FD 74 00         LD (IY),H
 789+ 527D FD 70 04         LD (IY+4),B
 790+ 5280 FD 72 05         LD (IY+5),D
 791+ 5283                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 792+ 5283                  ; following will do preparation for ANIMSTEP situation
 793+ 5283                  ; current item set to above limit and timer to 1
 794+ 5283                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 795+ 5283 FD 36 03 FF      LD (IY+3),255
 796+ 5287 FD 36 01 01      LD (IY+1),1
 797+ 528B FD 36 02 00      LD (IY+2),0
 798+ 528F                  ; mark as sprite animation
 799+ 528F FD 36 07 00      LD (IY+7),0
 800+ 5293 DD E5            PUSH IX
 801+ 5295 E1               POP HL
 802+ 5296 C9               RET
 803+ 5297              ; *******************************************************************************************************
 804+ 5297               ENDIF
 805+ 5297
 806+ 5297               IF (0 == 1)
 807+ 5297 ~            ; *******************************************************************************************************
 808+ 5297 ~            ; same as ANIMSPRITE but for DEFUSR approach
 809+ 5297 ~            ; input IX=pointer to input array, real data from +2
 810+ 5297 ~            ; +02 = ID
 811+ 5297 ~            ; +04 = sprite number
 812+ 5297 ~            ; +06 = animation definition id
 813+ 5297 ~            ; +08 = cyclic flag
 814+ 5297 ~            ANIMSPRITE_DEFUSR:
 815+ 5297 ~                LD C,(IX+2)
 816+ 5297 ~                INC C
 817+ 5297 ~                LD A,(ANIMSPRNUM)
 818+ 5297 ~                CP C
 819+ 5297 ~                RET C ; invalid id
 820+ 5297 ~            	; get sprite number
 821+ 5297 ~                LD A,(IX+4)
 822+ 5297 ~                CP 32
 823+ 5297 ~                RET NC ; invalid sprite id
 824+ 5297 ~                LD B,(IX+6)
 825+ 5297 ~                INC B
 826+ 5297 ~                LD A,(ANIMDEFNUM)
 827+ 5297 ~                CP B
 828+ 5297 ~                RET C ; invalid animation definition id
 829+ 5297 ~                LD A,C
 830+ 5297 ~                DEC A
 831+ 5297 ~                CALL GETnthSPRANIM
 832+ 5297 ~                LD A,(IX+4)
 833+ 5297 ~                LD (HL),A ; +0
 834+ 5297 ~                INC HL
 835+ 5297 ~                LD (HL),1 ; +1
 836+ 5297 ~                INC HL
 837+ 5297 ~                LD (HL),0 ; +2
 838+ 5297 ~                INC HL
 839+ 5297 ~                LD (HL),255 ; +3
 840+ 5297 ~                INC HL
 841+ 5297 ~                DEC B
 842+ 5297 ~                LD (HL),B ; +4
 843+ 5297 ~                INC HL
 844+ 5297 ~                LD A,(IX+8) ; +5
 845+ 5297 ~                LD (HL),A
 846+ 5297 ~                INC HL
 847+ 5297 ~                INC HL
 848+ 5297 ~                LD (HL),0 ; +7
 849+ 5297 ~                RET
 850+ 5297 ~            ; *******************************************************************************************************
 851+ 5297               ENDIF
 852+ 5297
 853+ 5297
 854+ 5297               IF (1 == 1)
 855+ 5297              ; *******************************************************************************************************
 856+ 5297              ; function to handle CALL ANIMCHAR basic extension
 857+ 5297              ; ANIMCHAR ( BYTE id,
 858+ 5297              ;            INT character number 0-767,
 859+ 5297              ;            BYTE animation_definition_id,
 860+ 5297              ;            BYTE cyclic_flag )
 861+ 5297              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 862+ 5297              ANIMCHAR:
 863+ 5297                  ; opening (
 864+ 5297 CD 4D 65     	CALL CHKCHAR
 865+ 529A 28           	DB '('
 866+ 529B              	; get sprite animation id
 867+ 529B DD 21 1C 52  	LD IX, GETBYT
 868+ 529F CD 59 01     	CALL CALBAS
 869+ 52A2 F5               PUSH AF
 870+ 52A3 3C               INC A
 871+ 52A4 4F               LD C,A
 872+ 52A5 3A 60 4F         LD A,(ANIMSPRNUM)
 873+ 52A8 B9               CP C
 874+ 52A9 DA 65 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 875+ 52AC              	; comma
 876+ 52AC CD 4D 65     	CALL CHKCHAR
 877+ 52AF 2C           	DB ','
 878+ 52B0              	; get character number
 879+ 52B0 DD 21 2F 54  	LD IX, FRMQNT
 880+ 52B4 CD 59 01     	CALL CALBAS
 881+ 52B7 D5               PUSH DE
 882+ 52B8                  ; check if out of bounds
 883+ 52B8 7A               LD A,D
 884+ 52B9 FE 03            CP 3
 885+ 52BB D2 65 65         JP NC, SUBSCRIPT_OUT_OF_RANGE
 886+ 52BE              	; comma
 887+ 52BE CD 4D 65     	CALL CHKCHAR
 888+ 52C1 2C           	DB ','
 889+ 52C2              	; get animation definition id
 890+ 52C2 DD 21 1C 52  	LD IX, GETBYT
 891+ 52C6 CD 59 01     	CALL CALBAS
 892+ 52C9 F5               PUSH AF
 893+ 52CA 3C               INC A
 894+ 52CB 4F               LD C,A
 895+ 52CC 3A 5D 4F         LD A,(ANIMDEFNUM)
 896+ 52CF B9               CP C
 897+ 52D0 DA 65 65         JP C,SUBSCRIPT_OUT_OF_RANGE
 898+ 52D3              	; comma
 899+ 52D3 CD 4D 65     	CALL CHKCHAR
 900+ 52D6 2C           	DB ','
 901+ 52D7              	; get cyclic flag
 902+ 52D7 DD 21 1C 52  	LD IX, GETBYT
 903+ 52DB CD 59 01         CALL CALBAS
 904+ 52DE F5           	PUSH AF
 905+ 52DF              	; ending )
 906+ 52DF CD 4D 65     	CALL CHKCHAR
 907+ 52E2 29           	DB ')'
 908+ 52E3              .ENTRY:
 909+ 52E3 E5               PUSH HL
 910+ 52E4 DD E1            POP IX
 911+ 52E6 D9               EXX
 912+ 52E7 D1               POP DE ; cyclic
 913+ 52E8 C1               POP BC ; animation definition id
 914+ 52E9 E1               POP HL ; character number
 915+ 52EA D9               EXX
 916+ 52EB F1               POP AF ; sprite animation id
 917+ 52EC CD 84 4F         CALL GETnthSPRANIM
 918+ 52EF E5               PUSH HL
 919+ 52F0 FD E1            POP IY
 920+ 52F2 D9               EXX
 921+ 52F3 FD 75 00         LD (IY),L
 922+ 52F6 24               INC H ; save character bank+1
 923+ 52F7 FD 74 07         LD (IY+7),H
 924+ 52FA FD 70 04         LD (IY+4),B
 925+ 52FD FD 72 05         LD (IY+5),D
 926+ 5300                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 927+ 5300                  ; following will do preparation for ANIMSTEP situation
 928+ 5300                  ; current item set to above limit and timer to 1
 929+ 5300                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 930+ 5300 FD 36 03 FF      LD (IY+3),255
 931+ 5304 FD 36 01 01      LD (IY+1),1
 932+ 5308 FD 36 02 00      LD (IY+2),0
 933+ 530C DD E5            PUSH IX
 934+ 530E E1               POP HL
 935+ 530F C9               RET
 936+ 5310              ; *******************************************************************************************************
 937+ 5310               ENDIF
 938+ 5310
 939+ 5310               IF (0 == 1)
 940+ 5310 ~            ; *******************************************************************************************************
 941+ 5310 ~            ; same as ANIMCHAR but for DEFUSR approach
 942+ 5310 ~            ; input IX=pointer to input array, real data from +2
 943+ 5310 ~            ; +02 = ID
 944+ 5310 ~            ; +04 = character number
 945+ 5310 ~            ; +06 = animation definition id
 946+ 5310 ~            ; +08 = cyclic flag
 947+ 5310 ~            ANIMCHAR_DEFUSR:
 948+ 5310 ~                LD C,(IX+2)
 949+ 5310 ~                INC C
 950+ 5310 ~                LD A,(ANIMSPRNUM)
 951+ 5310 ~                CP C
 952+ 5310 ~                RET C ; invalid id
 953+ 5310 ~            	; get sprite number
 954+ 5310 ~                LD A,(IX+5)
 955+ 5310 ~                CP 3
 956+ 5310 ~                RET NC ; invalid character (>767)
 957+ 5310 ~                LD B,(IX+6)
 958+ 5310 ~                INC B
 959+ 5310 ~                LD A,(ANIMDEFNUM)
 960+ 5310 ~                CP B
 961+ 5310 ~                RET C ; invalid animation definition id
 962+ 5310 ~                LD A,C
 963+ 5310 ~                DEC A
 964+ 5310 ~                CALL GETnthSPRANIM
 965+ 5310 ~                LD A,(IX+4)
 966+ 5310 ~                LD (HL),A ; +0
 967+ 5310 ~                INC HL
 968+ 5310 ~                LD (HL),1 ; +1
 969+ 5310 ~                INC HL
 970+ 5310 ~                LD (HL),0 ; +2
 971+ 5310 ~                INC HL
 972+ 5310 ~                LD (HL),255 ; +3
 973+ 5310 ~                INC HL
 974+ 5310 ~                DEC B
 975+ 5310 ~                LD (HL),B ; +4
 976+ 5310 ~                INC HL
 977+ 5310 ~                LD A,(IX+8) ; +5
 978+ 5310 ~                LD (HL),A
 979+ 5310 ~                INC HL
 980+ 5310 ~                INC HL
 981+ 5310 ~                LD A,(IX+5)
 982+ 5310 ~                INC A
 983+ 5310 ~                LD (HL),A ; +7
 984+ 5310 ~                RET
 985+ 5310 ~            ; *******************************************************************************************************
 986+ 5310               ENDIF
 987+ 5310
 988+ 5310               IF (0 == 1)
 989+ 5310 ~            ; *******************************************************************************************************
 990+ 5310 ~            ; same as MAXAUTOSGAMS but for DEFUSR approach
 991+ 5310 ~            ; input IX=pointer to input array, real data from +2
 992+ 5310 ~            ; +2 = number
 993+ 5310 ~            MAXAUTOSGAMS_DEFUSR:
 994+ 5310 ~                LD A,(IX+2)
 995+ 5310 ~                JR MAXAUTOSGAMS.COMMON
 996+ 5310 ~            ; *******************************************************************************************************
 997+ 5310               ENDIF
 998+ 5310
 999+ 5310              ; *******************************************************************************************************
1000+ 5310              ; function to handle CALL MAXAUTOSGAMS basic extension
1001+ 5310              ; MAXAUTOSGAMS (BYTE number)
1002+ 5310              ; sets new number and moves memory buffers as needed
1003+ 5310              MAXAUTOSGAMS:
1004+ 5310               IF (1 == 1)
1005+ 5310              	; opening (
1006+ 5310 CD 4D 65     	CALL CHKCHAR
1007+ 5313 28           	DB '('
1008+ 5314              	; get value
1009+ 5314 DD 21 1C 52  	LD IX, GETBYT
1010+ 5318 CD 59 01     	CALL CALBAS
1011+ 531B F5               PUSH AF
1012+ 531C              	; ending )
1013+ 531C CD 4D 65     	CALL CHKCHAR
1014+ 531F 29           	DB ')'
1015+ 5320 F1               POP AF
1016+ 5321               ENDIF
1017+ 5321              .COMMON:
1018+ 5321 F3               DI
1019+ 5322              	; save position
1020+ 5322 E5           	PUSH HL
1021+ 5323              .ENTRY:
1022+ 5323 47               LD B,A
1023+ 5324 3A 63 4F         LD A,(AUTOSGAMNUM)
1024+ 5327 90               SUB B
1025+ 5328 CA E2 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
1026+ 532B FD 21 10 40      LD IY,FREEMEMPTR
1027+ 532F FA 3B 53         JP M, .INCREASE
1028+ 5332                  ; new value is lower than previous one
1029+ 5332 CD 5C 53         CALL .SIZEDIFF
1030+ 5335 CD 1F 50         CALL MAXANIMITEMS.DECREASE_COMMON
1031+ 5338 C3 E2 4F         JP MAXANIMITEMS.EXIT
1032+ 533B              .INCREASE:
1033+ 533B ED 44            NEG
1034+ 533D F5               PUSH AF; save difference for later to set active flag to 0 of new entires
1035+ 533E CD 5C 53         CALL .SIZEDIFF
1036+ 5341 CD 4B 50         CALL MAXANIMITEMS.INCREASE_COMMON
1037+ 5344 AF               XOR A
1038+ 5345 ED 42            SBC HL,BC ; location of new stuff
1039+ 5347 F1               POP AF
1040+ 5348 C5               PUSH BC
1041+ 5349 47               LD B,A
1042+ 534A 11 18 00         LD DE,24
1043+ 534D E5               PUSH HL
1044+ 534E DD E1            POP IX
1045+ 5350              .L1:
1046+ 5350 DD 36 13 00      LD (IX+19),0 ; active flag
1047+ 5354 DD 19            ADD IX,DE
1048+ 5356 10 F8            DJNZ .L1
1049+ 5358 C1               POP BC
1050+ 5359 C3 E2 4F         JP MAXANIMITEMS.EXIT
1051+ 535C              .SIZEDIFF:
1052+ 535C 26 00            LD H,0
1053+ 535E 6F               LD L,A
1054+ 535F CD 3A 64         CALL HLx8
1055+ 5362 54               LD D,H
1056+ 5363 5D               LD E,L
1057+ 5364 29               ADD HL,HL
1058+ 5365 19               ADD HL,DE
1059+ 5366 78               LD A,B
1060+ 5367 32 63 4F         LD (AUTOSGAMNUM),A
1061+ 536A 44               LD B,H
1062+ 536B 4D               LD C,L
1063+ 536C C9               RET ; BC=size difference in bytes
1064+ 536D              ; *******************************************************************************************************
1065+ 536D
1066+ 536D               IF (1 == 1)
1067+ 536D              ; *******************************************************************************************************
1068+ 536D              ; function to handle CALL AUTOSGAMDEF basic extension
1069+ 536D              ; AUTOSGAMDEF ( BYTE id,
1070+ 536D              ;               INT VARIABLE x, INT VARIABLE y,
1071+ 536D              ;               INT minimum, INT maximum, INT delta,
1072+ 536D              ;               INT direction =0 horizontal,
1073+ 536D              ;               INT ticks,
1074+ 536D              ;               BYTE sprite_group_count,
1075+ 536D              ;               INT[2][sprite_group_count] VARIABLE sprite_group,
1076+ 536D              ;               BYTE item_number,
1077+ 536D              ;               INT[] VARIABLE sprite_animations_negative_direction,
1078+ 536D              ;               INT[] VARIABLE sprite_animations_positive_direction
1079+ 536D              AUTOSGAMDEF:
1080+ 536D                  ; opening (
1081+ 536D CD 4D 65     	CALL CHKCHAR
1082+ 5370 28           	DB '('
1083+ 5371              	; get sprite animation id
1084+ 5371 DD 21 1C 52  	LD IX, GETBYT
1085+ 5375 CD 59 01     	CALL CALBAS
1086+ 5378 F5               PUSH AF
1087+ 5379 3C               INC A
1088+ 537A 4F               LD C,A
1089+ 537B 3A 63 4F         LD A,(AUTOSGAMNUM)
1090+ 537E B9               CP C
1091+ 537F DA 65 65         JP C,SUBSCRIPT_OUT_OF_RANGE
1092+ 5382 F1               POP AF
1093+ 5383 E5               PUSH HL
1094+ 5384 CD 90 4F         CALL GETnthAUTOSGAM
1095+ 5387 22 39 62         LD (BLIT_TMP),HL ; for later
1096+ 538A E1               POP HL
1097+ 538B              	; comma
1098+ 538B CD 4D 65     	CALL CHKCHAR
1099+ 538E 2C           	DB ','
1100+ 538F              	; get address of the X coordinate variable
1101+ 538F DD 21 A4 5E  	LD IX, PTRGET
1102+ 5393 CD 59 01     	CALL CALBAS
1103+ 5396 DD 2A 39 62  	LD IX,(BLIT_TMP)
1104+ 539A DD 73 00         LD (IX+0),E
1105+ 539D DD 72 01         LD (IX+1),D
1106+ 53A0              	; comma
1107+ 53A0 CD 4D 65     	CALL CHKCHAR
1108+ 53A3 2C           	DB ','
1109+ 53A4              	; get address of the Y coordinate variable
1110+ 53A4 DD 21 A4 5E  	LD IX, PTRGET
1111+ 53A8 CD 59 01     	CALL CALBAS
1112+ 53AB DD 2A 39 62  	LD IX,(BLIT_TMP)
1113+ 53AF DD 73 02         LD (IX+2),E
1114+ 53B2 DD 72 03         LD (IX+3),D
1115+ 53B5              	; comma
1116+ 53B5 CD 4D 65     	CALL CHKCHAR
1117+ 53B8 2C           	DB ','
1118+ 53B9              	; get minimum value
1119+ 53B9 DD 21 2F 54  	LD IX, FRMQNT
1120+ 53BD CD 59 01     	CALL CALBAS
1121+ 53C0 DD 2A 39 62  	LD IX,(BLIT_TMP)
1122+ 53C4 DD 73 04         LD (IX+4),E
1123+ 53C7 DD 72 05         LD (IX+5),D
1124+ 53CA              	; comma
1125+ 53CA CD 4D 65     	CALL CHKCHAR
1126+ 53CD 2C           	DB ','
1127+ 53CE              	; get maximum value
1128+ 53CE DD 21 2F 54  	LD IX, FRMQNT
1129+ 53D2 CD 59 01     	CALL CALBAS
1130+ 53D5 DD 2A 39 62  	LD IX,(BLIT_TMP)
1131+ 53D9 DD 73 06         LD (IX+6),E
1132+ 53DC DD 72 07         LD (IX+7),D
1133+ 53DF              	; comma
1134+ 53DF CD 4D 65     	CALL CHKCHAR
1135+ 53E2 2C           	DB ','
1136+ 53E3              	; get delta value
1137+ 53E3 DD 21 2F 54  	LD IX, FRMQNT
1138+ 53E7 CD 59 01     	CALL CALBAS
1139+ 53EA DD 2A 39 62  	LD IX,(BLIT_TMP)
1140+ 53EE DD 73 08         LD (IX+8),E
1141+ 53F1 DD 72 09         LD (IX+9),D
1142+ 53F4              	; comma
1143+ 53F4 CD 4D 65     	CALL CHKCHAR
1144+ 53F7 2C           	DB ','
1145+ 53F8              	; get direction value
1146+ 53F8 DD 21 2F 54  	LD IX, FRMQNT
1147+ 53FC CD 59 01     	CALL CALBAS
1148+ 53FF DD 2A 39 62  	LD IX,(BLIT_TMP)
1149+ 5403 DD 73 0A         LD (IX+10),E
1150+ 5406              	; comma
1151+ 5406 CD 4D 65     	CALL CHKCHAR
1152+ 5409 2C           	DB ','
1153+ 540A              	; get ticks value
1154+ 540A DD 21 2F 54  	LD IX, FRMQNT
1155+ 540E CD 59 01     	CALL CALBAS
1156+ 5411 DD 2A 39 62  	LD IX,(BLIT_TMP)
1157+ 5415 DD 73 14         LD (IX+20),E
1158+ 5418 DD 72 15         LD (IX+21),D
1159+ 541B              	; comma
1160+ 541B CD 4D 65     	CALL CHKCHAR
1161+ 541E 2C           	DB ','
1162+ 541F              	; get sprite group count
1163+ 541F DD 21 1C 52  	LD IX, GETBYT
1164+ 5423 CD 59 01     	CALL CALBAS
1165+ 5426 B7               OR A
1166+ 5427 CA 65 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
1167+ 542A DD 2A 39 62  	LD IX,(BLIT_TMP)
1168+ 542E DD 77 0B         LD (IX+11),A
1169+ 5431              	; comma
1170+ 5431 CD 4D 65     	CALL CHKCHAR
1171+ 5434 2C           	DB ','
1172+ 5435              	; get sprite group definition array data pointer
1173+ 5435 DD 2A 39 62  	LD IX,(BLIT_TMP)
1174+ 5439 DD 5E 0B         LD E,(IX+11)
1175+ 543C 16 03        	LD D,3
1176+ 543E 3E 02        	LD A,2
1177+ 5440 47           	LD B,A
1178+ 5441 CD 7A 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
1179+ 5444 DD 2A 39 62  	LD IX,(BLIT_TMP)
1180+ 5448 DD 71 0C     	LD (IX+12),C
1181+ 544B DD 70 0D         LD (IX+13),B
1182+ 544E              	; comma
1183+ 544E CD 4D 65     	CALL CHKCHAR
1184+ 5451 2C           	DB ','
1185+ 5452              	; get sprite animation array size
1186+ 5452 DD 21 1C 52  	LD IX,GETBYT
1187+ 5456 CD 59 01     	CALL CALBAS
1188+ 5459 DD 2A 39 62  	LD IX,(BLIT_TMP)
1189+ 545D DD 77 0E         LD (IX+14),A
1190+ 5460 B7               OR A
1191+ 5461 CA 65 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
1192+ 5464              	; comma
1193+ 5464 CD 4D 65     	CALL CHKCHAR
1194+ 5467 2C           	DB ','
1195+ 5468                  ; get array pointer for negative direction
1196+ 5468 DD 2A 39 62  	LD IX,(BLIT_TMP)
1197+ 546C DD 56 0E         LD D,(IX+14)
1198+ 546F 3E 02            LD A,2
1199+ 5471 06 01            LD B,1
1200+ 5473 CD 7A 65         CALL GET_BASIC_ARRAY_DATA_POINTER
1201+ 5476 DD 2A 39 62  	LD IX,(BLIT_TMP)
1202+ 547A DD 71 0F         LD (IX+15),C
1203+ 547D DD 70 10         LD (IX+16),B
1204+ 5480              	; comma
1205+ 5480 CD 4D 65     	CALL CHKCHAR
1206+ 5483 2C           	DB ','
1207+ 5484                  ; get array pointer for positive direction
1208+ 5484 DD 2A 39 62  	LD IX,(BLIT_TMP)
1209+ 5488 DD 56 0E         LD D,(IX+14)
1210+ 548B 3E 02            LD A,2
1211+ 548D 06 01            LD B,1
1212+ 548F CD 7A 65         CALL GET_BASIC_ARRAY_DATA_POINTER
1213+ 5492 DD 2A 39 62  	LD IX,(BLIT_TMP)
1214+ 5496 DD 71 11         LD (IX+17),C
1215+ 5499 DD 70 12         LD (IX+18),B
1216+ 549C              	; ending )
1217+ 549C CD 4D 65     	CALL CHKCHAR
1218+ 549F 29           	DB ')'
1219+ 54A0 C9               RET
1220+ 54A1              ; *******************************************************************************************************
1221+ 54A1               ENDIF
1222+ 54A1
1223+ 54A1               IF (0 == 1)
1224+ 54A1 ~            ; *******************************************************************************************************
1225+ 54A1 ~            ; same as AUTOSGAMDEF but for DEFUSR approach
1226+ 54A1 ~            ; input IX=pointer to input array, real data from +2
1227+ 54A1 ~            ; +02 = ID
1228+ 54A1 ~            ; +04 = pointer to X variable
1229+ 54A1 ~            ; +06 = pointer to Y variable
1230+ 54A1 ~            ; +08 = minimum
1231+ 54A1 ~            ; +10 = maximum
1232+ 54A1 ~            ; +12 = delta
1233+ 54A1 ~            ; +14 = direction
1234+ 54A1 ~            ; +16 = ticks
1235+ 54A1 ~            ; +18 = sprite group count
1236+ 54A1 ~            ; +20 = sprite group array pointer
1237+ 54A1 ~            ; +22 = item number
1238+ 54A1 ~            ; +24 = sprite animations negative direction array pointer
1239+ 54A1 ~            ; +26 = sprite animations positive direction array pointer
1240+ 54A1 ~            AUTOSGAMDEF_DEFUSR:
1241+ 54A1 ~                LD C,(IX+2)
1242+ 54A1 ~                INC C
1243+ 54A1 ~                LD A,(AUTOSGAMNUM)
1244+ 54A1 ~                CP C
1245+ 54A1 ~                RET C ; invalid id
1246+ 54A1 ~                LD A,C
1247+ 54A1 ~                DEC A
1248+ 54A1 ~                CALL GETnthAUTOSGAM
1249+ 54A1 ~                PUSH HL
1250+ 54A1 ~                POP IY
1251+ 54A1 ~                ; X variable
1252+ 54A1 ~                LD A,(IX+4)
1253+ 54A1 ~                LD (IY+0),A
1254+ 54A1 ~                LD A,(IX+5)
1255+ 54A1 ~                LD (IY+1),A
1256+ 54A1 ~            	; Y variable
1257+ 54A1 ~                LD A,(IX+6)
1258+ 54A1 ~                LD (IY+2),A
1259+ 54A1 ~                LD A,(IX+7)
1260+ 54A1 ~                LD (IY+3),A
1261+ 54A1 ~            	; get minimum value
1262+ 54A1 ~                LD A,(IX+8)
1263+ 54A1 ~                LD (IY+4),A
1264+ 54A1 ~                LD A,(IX+9)
1265+ 54A1 ~                LD (IY+5),A
1266+ 54A1 ~            	; get maximum value
1267+ 54A1 ~                LD A,(IX+10)
1268+ 54A1 ~                LD (IY+6),A
1269+ 54A1 ~                LD A,(IX+11)
1270+ 54A1 ~                LD (IY+7),A
1271+ 54A1 ~            	; get delta value
1272+ 54A1 ~                LD A,(IX+12)
1273+ 54A1 ~                LD (IY+8),A
1274+ 54A1 ~                LD A,(IX+13)
1275+ 54A1 ~                LD (IY+9),A
1276+ 54A1 ~            	; get direction value
1277+ 54A1 ~                LD A,(IX+14)
1278+ 54A1 ~                LD (IY+10),A
1279+ 54A1 ~            	; get ticks value
1280+ 54A1 ~                LD A,(IX+16)
1281+ 54A1 ~                LD (IY+20),A
1282+ 54A1 ~                LD A,(IX+17)
1283+ 54A1 ~                LD (IY+21),A
1284+ 54A1 ~            	; get sprite group count
1285+ 54A1 ~                LD A,(IX+18)
1286+ 54A1 ~                LD (IY+11),A
1287+ 54A1 ~            	; get sprite group definition array data pointer
1288+ 54A1 ~                LD A,(IX+20)
1289+ 54A1 ~                LD (IY+12),A
1290+ 54A1 ~                LD A,(IX+21)
1291+ 54A1 ~                LD (IY+13),A
1292+ 54A1 ~            	; get sprite animation array size
1293+ 54A1 ~                LD A,(IX+22)
1294+ 54A1 ~                LD (IY+14),A
1295+ 54A1 ~                ; get array pointer for negative direction
1296+ 54A1 ~                LD A,(IX+24)
1297+ 54A1 ~                LD (IY+15),A
1298+ 54A1 ~                LD A,(IX+25)
1299+ 54A1 ~                LD (IY+16),A
1300+ 54A1 ~                ; get array pointer for positive direction
1301+ 54A1 ~                LD A,(IX+26)
1302+ 54A1 ~                LD (IY+17),A
1303+ 54A1 ~                LD A,(IX+27)
1304+ 54A1 ~                LD (IY+18),A
1305+ 54A1 ~                RET
1306+ 54A1 ~            ; *******************************************************************************************************
1307+ 54A1               ENDIF
1308+ 54A1
1309+ 54A1               IF (1 == 1)
1310+ 54A1              ; *******************************************************************************************************
1311+ 54A1              ; function to handle CALL AUTOSGAMSTART basic extension
1312+ 54A1              ; AUTOSGAMSTART ( BYTE id )
1313+ 54A1              AUTOSGAMSTART:
1314+ 54A1 3E 01            LD A,1
1315+ 54A3              .COMMON:
1316+ 54A3 32 CF 54         LD (.SETVALUE+3),A
1317+ 54A6                  ; opening (
1318+ 54A6 CD 4D 65     	CALL CHKCHAR
1319+ 54A9 28           	DB '('
1320+ 54AA              	; get sprite animation id
1321+ 54AA DD 21 1C 52  	LD IX, GETBYT
1322+ 54AE CD 59 01     	CALL CALBAS
1323+ 54B1 F5               PUSH AF
1324+ 54B2 3C               INC A
1325+ 54B3 4F               LD C,A
1326+ 54B4 3A 63 4F         LD A,(AUTOSGAMNUM)
1327+ 54B7 B9               CP C
1328+ 54B8 DA 65 65         JP C,SUBSCRIPT_OUT_OF_RANGE
1329+ 54BB F1               POP AF
1330+ 54BC E5               PUSH HL
1331+ 54BD CD 90 4F         CALL GETnthAUTOSGAM
1332+ 54C0 E5               PUSH HL
1333+ 54C1 DD E1            POP IX
1334+ 54C3 E1               POP HL
1335+ 54C4 DD E5            PUSH IX
1336+ 54C6              	; ending )
1337+ 54C6 CD 4D 65     	CALL CHKCHAR
1338+ 54C9 29           	DB ')'
1339+ 54CA
1340+ 54CA                  ; so syntax is fine
1341+ 54CA DD E1            POP IX
1342+ 54CC              .SETVALUE:
1343+ 54CC DD 36 13 01      LD (IX+19),1 ; active flag
1344+ 54D0                  ; set initial timer
1345+ 54D0 DD 7E 14         LD A,(IX+20)
1346+ 54D3 DD 77 16         LD (IX+22),A
1347+ 54D6 DD 7E 15         LD A,(IX+21)
1348+ 54D9 DD 77 17         LD (IX+23),A
1349+ 54DC C9               RET
1350+ 54DD              ; *******************************************************************************************************
1351+ 54DD
1352+ 54DD              ; *******************************************************************************************************
1353+ 54DD              ; function to handle CALL AUTOSGAMSTOP basic extension
1354+ 54DD              ; AUTOSGAMSTOP ( BYTE id )
1355+ 54DD              AUTOSGAMSTOP:
1356+ 54DD AF               XOR A
1357+ 54DE 18 C3            JR AUTOSGAMSTART.COMMON
1358+ 54E0              ; *******************************************************************************************************
1359+ 54E0               ENDIF
1360+ 54E0
1361+ 54E0               IF (0 == 1)
1362+ 54E0 ~            ; *******************************************************************************************************
1363+ 54E0 ~            ; function to handle CALL AUTOSGAMSTART basic extension in DEFUSR mode
1364+ 54E0 ~            ; input IX=pointer to input array, real data from +2
1365+ 54E0 ~            ; +2 = source address
1366+ 54E0 ~            AUTOSGAMSTART_DEFUSR:
1367+ 54E0 ~                LD A,1
1368+ 54E0 ~            .COMMON:
1369+ 54E0 ~                LD (.SETVALUE+3),A
1370+ 54E0 ~                LD C,(IX+2)
1371+ 54E0 ~                INC C
1372+ 54E0 ~                LD A,(AUTOSGAMNUM)
1373+ 54E0 ~                CP C
1374+ 54E0 ~                RET C ; invalid id
1375+ 54E0 ~                LD A,C
1376+ 54E0 ~                DEC A
1377+ 54E0 ~                CALL GETnthAUTOSGAM
1378+ 54E0 ~                PUSH HL
1379+ 54E0 ~                POP IX
1380+ 54E0 ~            .SETVALUE:
1381+ 54E0 ~                LD (IX+19),1 ; active flag
1382+ 54E0 ~                ; set initial timer
1383+ 54E0 ~                LD A,(IX+20)
1384+ 54E0 ~                LD (IX+22),A
1385+ 54E0 ~                LD A,(IX+21)
1386+ 54E0 ~                LD (IX+23),A
1387+ 54E0 ~                RET
1388+ 54E0 ~            ; *******************************************************************************************************
1389+ 54E0 ~
1390+ 54E0 ~            ; *******************************************************************************************************
1391+ 54E0 ~            ; function to handle CALL AUTOSGAMSTOP basic extension in DEFUSR mode
1392+ 54E0 ~            ; input IX=pointer to input array, real data from +2
1393+ 54E0 ~            ; +2 = source address
1394+ 54E0 ~            AUTOSGAMSTOP_DEFUSR:
1395+ 54E0 ~                XOR A
1396+ 54E0 ~                JR AUTOSGAMSTART_DEFUSR.COMMON
1397+ 54E0 ~            ; *******************************************************************************************************
1398+ 54E0               ENDIF
1399+ 54E0
1400+ 54E0               IF (1 == 1)
1401+ 54E0              ; *******************************************************************************************************
1402+ 54E0              ; function to handle CALL ANIMSTEP basic extension
1403+ 54E0              ; two forms
1404+ 54E0              ; ANIMSTEP ( BYTE id )
1405+ 54E0              ; or
1406+ 54E0              ; ANIMSTEP ( BYTE item_number,
1407+ 54E0              ;            INT[] sprite_animations )
1408+ 54E0              ANIMSTEP:
1409+ 54E0 11 5F 55         LD DE,ANIMSTARTSTOP_COMMON.STEP
1410+ 54E3 18 08            JR ANIMSTARTSTOP_COMMON
1411+ 54E5              ; *******************************************************************************************************
1412+ 54E5              ; *******************************************************************************************************
1413+ 54E5              ; function to handle CALL ANIMSTART basic extension
1414+ 54E5              ; two forms
1415+ 54E5              ; ANIMSTART ( BYTE id )
1416+ 54E5              ; or
1417+ 54E5              ; ANIMSTART ( BYTE item_number,
1418+ 54E5              ;             INT[] sprite_animations )
1419+ 54E5              ; sets active flag to 1
1420+ 54E5              ANIMSTART:
1421+ 54E5 11 4D 55         LD DE,ANIMSTARTSTOP_COMMON.START
1422+ 54E8 18 03            JR ANIMSTARTSTOP_COMMON
1423+ 54EA              ; *******************************************************************************************************
1424+ 54EA              ; *******************************************************************************************************
1425+ 54EA              ; function to handle CALL ANIMSTOP basic extension
1426+ 54EA              ; two forms
1427+ 54EA              ; ANIMSTOP ( BYTE id )
1428+ 54EA              ; or
1429+ 54EA              ; ANIMSTOP ( BYTE item_number,
1430+ 54EA              ;            INT[] sprite_animations )
1431+ 54EA              ; sets active flag to 0
1432+ 54EA              ANIMSTOP:
1433+ 54EA 11 5A 55         LD DE,ANIMSTARTSTOP_COMMON.STOP
1434+ 54ED              ; *******************************************************************************************************
1435+ 54ED              ANIMSTARTSTOP_COMMON:
1436+ 54ED ED 53 4B 55      LD (ANIMSTARTSTOP_COMMON.FN+1),DE
1437+ 54F1                  ; opening (
1438+ 54F1 CD 4D 65     	CALL CHKCHAR
1439+ 54F4 28           	DB '('
1440+ 54F5              	; get sprite animation id or array size
1441+ 54F5 DD 21 1C 52  	LD IX,GETBYT
1442+ 54F9 CD 59 01     	CALL CALBAS
1443+ 54FC F5               PUSH AF
1444+ 54FD                  ; check if comma present
1445+ 54FD CD 57 65         CALL GETPREVCHAR
1446+ 5500 23               INC HL
1447+ 5501 FE 2C            CP ','
1448+ 5503 28 0E            JR Z,.L1
1449+ 5505 FE 29            CP ')'
1450+ 5507 C2 71 65         JP NZ,SYNTAX_ERROR
1451+ 550A                  ; ok so single argument variant
1452+ 550A F1               POP AF
1453+ 550B E5               PUSH HL
1454+ 550C F3               DI
1455+ 550D CD 39 55         CALL .SETVALUE
1456+ 5510 FB               EI
1457+ 5511 E1               POP HL
1458+ 5512 C9               RET
1459+ 5513              .L1:
1460+ 5513                  ; get array pointer
1461+ 5513 D1               POP DE
1462+ 5514 D5               PUSH DE
1463+ 5515 3E 02            LD A,2
1464+ 5517 06 01            LD B,1
1465+ 5519 CD 7A 65         CALL GET_BASIC_ARRAY_DATA_POINTER
1466+ 551C C5               PUSH BC
1467+ 551D              	; ending )
1468+ 551D CD 4D 65     	CALL CHKCHAR
1469+ 5520 29           	DB ')'
1470+ 5521 D1               POP DE ; array pointer
1471+ 5522 C1               POP BC ; number of items
1472+ 5523 78               LD A,B
1473+ 5524 B7               OR A
1474+ 5525 CA 65 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
1475+ 5528 E5               PUSH HL
1476+ 5529 F3               DI
1477+ 552A              .L2:
1478+ 552A C5               PUSH BC
1479+ 552B 1A               LD A,(DE)
1480+ 552C 13          > INC DE
1480+ 552D 13          > INC DE
1481+ 552E D5               PUSH DE
1482+ 552F CD 39 55         CALL .SETVALUE
1483+ 5532 D1               POP DE
1484+ 5533 C1               POP BC
1485+ 5534 10 F4            DJNZ .L2
1486+ 5536 FB               EI
1487+ 5537 E1               POP HL
1488+ 5538 C9               RET
1489+ 5539
1490+ 5539              .SETVALUE:
1491+ 5539 47               LD B,A
1492+ 553A 3C               INC A
1493+ 553B 4F               LD C,A
1494+ 553C 3A 60 4F         LD A,(ANIMSPRNUM)
1495+ 553F B9               CP C
1496+ 5540 DA 65 65         JP C,SUBSCRIPT_OUT_OF_RANGE
1497+ 5543 78               LD A,B
1498+ 5544 CD 84 4F         CALL GETnthSPRANIM
1499+ 5547 E5               PUSH HL
1500+ 5548 DD E1            POP IX
1501+ 554A              .FN:
1502+ 554A C3 00 00         JP 0
1503+ 554D              .START:
1504+ 554D DD 36 06 01      LD (IX+6),1 ; active flag
1505+ 5551 DD 36 03 00      LD (IX+3),0 ; current item
1506+ 5555 06 00            LD B,0 ; setup timer
1507+ 5557 C3 F0 55         JP SETUP_ANIM_STEP
1508+ 555A              .STOP:
1509+ 555A DD 36 06 00      LD (IX+6),0 ; active flag
1510+ 555E C9               RET
1511+ 555F              .STEP:
1512+ 555F 06 00            LD B,0
1513+ 5561 C3 94 55         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1514+ 5564              ; *******************************************************************************************************
1515+ 5564               ENDIF
1516+ 5564
1517+ 5564              ; *******************************************************************************************************
1518+ 5564              ; helper function to locate single animation and execute operation
1519+ 5564              ; needs to have jump set to a correct function
1520+ 5564              ; used by SGAM helper routines so always needed
1521+ 5564              ; input A=animation item
1522+ 5564              ANIM_SETVALUE:
1523+ 5564 47               LD B,A
1524+ 5565 3C               INC A
1525+ 5566 4F               LD C,A
1526+ 5567 3A 60 4F         LD A,(ANIMSPRNUM)
1527+ 556A B9               CP C
1528+ 556B D8               RET C ; out of range, so do nothing
1529+ 556C 78               LD A,B
1530+ 556D CD 84 4F         CALL GETnthSPRANIM
1531+ 5570 E5               PUSH HL
1532+ 5571 DD E1            POP IX
1533+ 5573              .FN:
1534+ 5573 C3 00 00         JP 0
1535+ 5576              ; *******************************************************************************************************
1536+ 5576
1537+ 5576               IF (0 == 1)
1538+ 5576 ~            ; *******************************************************************************************************
1539+ 5576 ~            ; helper function to set values of multiple animations
1540+ 5576 ~            ; needs to have jump set to a correct function
1541+ 5576 ~            ; input B=number of animation item
1542+ 5576 ~            ; input DE=animation item array
1543+ 5576 ~            ANIM_LIST_SETVALUE:
1544+ 5576 ~                DI
1545+ 5576 ~                PUSH BC
1546+ 5576 ~                LD A,(DE)
1547+ 5576 ~                .2 INC DE
1548+ 5576 ~                PUSH DE
1549+ 5576 ~                CALL ANIM_SETVALUE
1550+ 5576 ~                POP DE
1551+ 5576 ~                POP BC
1552+ 5576 ~                DJNZ ANIM_LIST_SETVALUE
1553+ 5576 ~                EI
1554+ 5576 ~                RET
1555+ 5576 ~            ; *******************************************************************************************************
1556+ 5576 ~
1557+ 5576 ~            ; *******************************************************************************************************
1558+ 5576 ~            ; function to handle single item ANIMSTEP in DEFUSR mode
1559+ 5576 ~            ; input IX=pointer to input array, real data from +2
1560+ 5576 ~            ; +2 = animation id
1561+ 5576 ~            ANIMSTEP_SINGLE_DEFUSR:
1562+ 5576 ~                LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1563+ 5576 ~            .L1:
1564+ 5576 ~                LD (ANIM_SETVALUE.FN+1),HL
1565+ 5576 ~                LD A,(IX+2)
1566+ 5576 ~                JR ANIM_SETVALUE
1567+ 5576 ~            .STEP:
1568+ 5576 ~                LD B,0
1569+ 5576 ~                JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1570+ 5576 ~            ; *******************************************************************************************************
1571+ 5576 ~
1572+ 5576 ~            ; *******************************************************************************************************
1573+ 5576 ~            ; function to handle multi item ANIMSTEP in DEFUSR mode
1574+ 5576 ~            ; input IX=pointer to input array, real data from +2
1575+ 5576 ~            ; +2 = list size
1576+ 5576 ~            ; +4 = array pointer holding items
1577+ 5576 ~            ANIMSTEP_MULTI_DEFUSR:
1578+ 5576 ~                LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1579+ 5576 ~            .L1:
1580+ 5576 ~                LD (ANIM_SETVALUE.FN+1),HL
1581+ 5576 ~                LD B,(IX+2)
1582+ 5576 ~                LD E,(IX+4)
1583+ 5576 ~                LD D,(IX+5)
1584+ 5576 ~                JR ANIM_LIST_SETVALUE
1585+ 5576 ~            ; *******************************************************************************************************
1586+ 5576 ~
1587+ 5576 ~            ; *******************************************************************************************************
1588+ 5576 ~            ; function to handle single item ANIMSTART in DEFUSR mode
1589+ 5576 ~            ; input IX=pointer to input array, real data from +2
1590+ 5576 ~            ; +2 = animation id
1591+ 5576 ~            ANIMSTART_SINGLE_DEFUSR:
1592+ 5576 ~                LD HL,ANIMSTART_SINGLE_DEFUSR.START
1593+ 5576 ~                JR ANIMSTEP_SINGLE_DEFUSR.L1
1594+ 5576 ~            .START:
1595+ 5576 ~                LD (IX+6),1 ; active flag
1596+ 5576 ~                LD (IX+3),0 ; current item
1597+ 5576 ~                LD B,0 ; setup timer
1598+ 5576 ~                JP SETUP_ANIM_STEP
1599+ 5576 ~            ; *******************************************************************************************************
1600+ 5576 ~
1601+ 5576 ~            ; *******************************************************************************************************
1602+ 5576 ~            ; function to handle multi item ANIMSTART in DEFUSR mode
1603+ 5576 ~            ; input IX=pointer to input array, real data from +2
1604+ 5576 ~            ; +2 = list size
1605+ 5576 ~            ; +4 = array pointer holding items
1606+ 5576 ~            ANIMSTART_MULTI_DEFUSR:
1607+ 5576 ~                LD HL,ANIMSTART_SINGLE_DEFUSR.START
1608+ 5576 ~                JR ANIMSTEP_MULTI_DEFUSR.L1
1609+ 5576 ~            ; *******************************************************************************************************
1610+ 5576 ~
1611+ 5576 ~            ; *******************************************************************************************************
1612+ 5576 ~            ; function to handle single item ANIMSTOP in DEFUSR mode
1613+ 5576 ~            ; input IX=pointer to input array, real data from +2
1614+ 5576 ~            ; +2 = animation id
1615+ 5576 ~            ANIMSTOP_SINGLE_DEFUSR:
1616+ 5576 ~                LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1617+ 5576 ~                JR ANIMSTEP_SINGLE_DEFUSR.L1
1618+ 5576 ~            .STOP:
1619+ 5576 ~                LD (IX+6),0 ; active flag
1620+ 5576 ~                RET
1621+ 5576 ~            ; *******************************************************************************************************
1622+ 5576 ~
1623+ 5576 ~            ; *******************************************************************************************************
1624+ 5576 ~            ; function to handle multi item ANIMSTOP in DEFUSR mode
1625+ 5576 ~            ; input IX=pointer to input array, real data from +2
1626+ 5576 ~            ; +2 = list size
1627+ 5576 ~            ; +4 = array pointer holding items
1628+ 5576 ~            ANIMSTOP_MULTI_DEFUSR:
1629+ 5576 ~                LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1630+ 5576 ~                JR ANIMSTEP_MULTI_DEFUSR.L1
1631+ 5576 ~            ; *******************************************************************************************************
1632+ 5576               ENDIF
1633+ 5576
1634+ 5576              ; *******************************************************************************************************
1635+ 5576              ; function processes animations during vblank period
1636+ 5576              PROCESS_ANIMATIONS:
1637+ 5576 3A 60 4F         LD A,(ANIMSPRNUM)
1638+ 5579 B7               OR A
1639+ 557A C8               RET Z; no animations defined
1640+ 557B 47               LD B,A
1641+ 557C DD 2A 61 4F      LD IX,(ANIMSPRPTR)
1642+ 5580              .L1:
1643+ 5580 C5               PUSH BC
1644+ 5581 06 00            LD B,0 ; normal mode, change on timer expiry only
1645+ 5583 CD 8F 55         CALL PROCESS_SINGLE_ANIMATION
1646+ 5586 11 08 00         LD DE,8
1647+ 5589 DD 19            ADD IX,DE
1648+ 558B C1               POP BC
1649+ 558C 10 F2            DJNZ .L1
1650+ 558E C9               RET
1651+ 558F              ; *******************************************************************************************************
1652+ 558F
1653+ 558F              ; *******************************************************************************************************
1654+ 558F              ; processes single sprite animation
1655+ 558F              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
1656+ 558F              ; on timer expiry goes to next animation item
1657+ 558F              ; input IX=sprite animation pointer
1658+ 558F              ; input B=1 force mode, activate animation action regardless of expired timer
1659+ 558F              PROCESS_SINGLE_ANIMATION:
1660+ 558F DD 7E 06         LD A,(IX+6); active
1661+ 5592 B7               OR A
1662+ 5593 C8               RET Z ; inactive animation
1663+ 5594              .INACTIVE_TOO:
1664+ 5594 DD 6E 01         LD L,(IX+1)
1665+ 5597 DD 66 02         LD H,(IX+2) ; HL=end time
1666+ 559A 2B               DEC HL
1667+ 559B DD 75 01         LD (IX+1),L
1668+ 559E DD 74 02         LD (IX+2),H
1669+ 55A1 7D               LD A,L
1670+ 55A2 B4               OR H
1671+ 55A3 28 06            JR Z,.STEP
1672+ 55A5 05               DEC B
1673+ 55A6 04               INC B
1674+ 55A7 C8               RET Z ; not forced mode, return
1675+ 55A8 C3 F0 55         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
1676+ 55AB              .STEP:
1677+ 55AB 06 00            LD B,0; setup timer
1678+ 55AD DD 34 03         INC (IX+3) ; current animation item
1679+ 55B0 C3 F0 55         JP SETUP_ANIM_STEP
1680+ 55B3              ; *******************************************************************************************************
1681+ 55B3
1682+ 55B3              ; *******************************************************************************************************
1683+ 55B3              ; function will setup sprite animation after current item change
1684+ 55B3              ; input A=current animation definition
1685+ 55B3              ; input IX=pointer to sprite animation
1686+ 55B3              ; input B=1 skip timer setup
1687+ 55B3              ; output IY=pointer to animation item
1688+ 55B3              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
1689+ 55B3              ; basically sets new end time for current animation
1690+ 55B3              INIT_CURRENT_ANIMATION:
1691+ 55B3 CD 78 4F         CALL GETnthANIMDEF
1692+ 55B6 DD 7E 03         LD A,(IX+3) ; current animation item
1693+ 55B9 BE               CP (HL) ; number of animation items in the animation definition
1694+ 55BA 38 0A            JR C,.L3 ; last item not reached
1695+ 55BC                  ; last item reached
1696+ 55BC DD 7E 05         LD A,(IX+5) ; cyclic flag
1697+ 55BF B7               OR A
1698+ 55C0 28 2C            JR Z,.ERROR ; non-cyclic animation
1699+ 55C2                  ; cyclic animation, restart
1700+ 55C2 DD 36 03 00      LD (IX+3),0; current item
1701+ 55C6              .L3:
1702+ 55C6                  ; HL = animation definition
1703+ 55C6 23               INC HL ; skip animation definition size field
1704+ 55C7 16 00            LD D,0
1705+ 55C9 DD 5E 03         LD E,(IX+3); current item
1706+ 55CC 19               ADD HL,DE
1707+ 55CD 4E               LD C,(HL) ; current animation item
1708+ 55CE 0C               INC C
1709+ 55CF 3A 5A 4F         LD A,(ANIMITEMNUM)
1710+ 55D2 B9               CP C
1711+ 55D3 38 19            JR C,.ERROR ; invalid animation item, stop animation
1712+ 55D5 0D               DEC C
1713+ 55D6 79               LD A,C
1714+ 55D7 CD 6F 4F         CALL GETnthANIMITEM
1715+ 55DA E5               PUSH HL
1716+ 55DB FD E1            POP IY ; IY=animation item
1717+ 55DD 05               DEC B
1718+ 55DE 28 0C            JR Z,.EXIT
1719+ 55E0 FD 5E 01         LD E,(IY+1)
1720+ 55E3 FD 56 02         LD D,(IY+2) ; duration
1721+ 55E6 DD 73 01         LD (IX+1),E
1722+ 55E9 DD 72 02         LD (IX+2),D
1723+ 55EC              .EXIT:
1724+ 55EC AF               XOR A
1725+ 55ED C9               RET
1726+ 55EE              .ERROR:
1727+ 55EE 37               SCF
1728+ 55EF C9               RET
1729+ 55F0              ; *******************************************************************************************************
1730+ 55F0
1731+ 55F0              ; *******************************************************************************************************
1732+ 55F0              ; function will display currect item and set up expiry time
1733+ 55F0              ; it will also stop the animation if expired
1734+ 55F0              ; sets sprite update flag if any changes in sprite data made
1735+ 55F0              ; input IX=current sprite animation
1736+ 55F0              ; input B=1 skip timer setup
1737+ 55F0              SETUP_ANIM_STEP:
1738+ 55F0 DD 4E 04         LD C,(IX+4) ; animation definition ID
1739+ 55F3 0C               INC C
1740+ 55F4 3A 5D 4F         LD A,(ANIMDEFNUM)
1741+ 55F7 B9               CP C
1742+ 55F8 30 05            JR NC,.L2
1743+ 55FA                  ; given animation item is outside of bounds, deactivate animation
1744+ 55FA              .STOPANIM:
1745+ 55FA DD 36 06 00      LD (IX+6),0
1746+ 55FE C9               RET
1747+ 55FF              .L2:
1748+ 55FF 0D               DEC C
1749+ 5600 79               LD A,C
1750+ 5601 CD B3 55         CALL INIT_CURRENT_ANIMATION
1751+ 5604 38 F4            JR C, .STOPANIM
1752+ 5606 FD 7E 00         LD A,(IY) ; type of animation item
1753+ 5609 B7               OR A
1754+ 560A 28 44            JR Z,.L4 ; change pattern and/or color
1755+ 560C              .PAT:
1756+ 560C                  ; change pattern definition
1757+ 560C                  ; check if sprite or character
1758+ 560C DD 7E 07         LD A,(IX+7)
1759+ 560F B7               OR A
1760+ 5610 20 58            JR NZ,.CHAR
1761+ 5612 DD 7E 00         LD A,(IX) ; sprite number
1762+ 5615 CD 89 4D         CALL GETnthSPRATTR
1763+ 5618 23          > INC HL ; skip y and x
1763+ 5619 23          > INC HL
1763+ 561A 23          > INC HL
1763+ 561B 23          > INC HL
1764+ 561C 7E               LD A,(HL); current pattern
1765+ 561D 26 00            LD H,0
1766+ 561F 6F               LD L,A
1767+ 5620 3A E0 F3         LD A,(REG1SAV)
1768+ 5623 E6 02            AND 2
1769+ 5625 20 07            JR NZ,.L6
1770+ 5627                  ; 8x8 sprite
1771+ 5627 CD 3A 64         CALL HLx8
1772+ 562A 06 08            LD B,8
1773+ 562C 18 05            JR .L5
1774+ 562E              .L6:
1775+ 562E CD 38 64         CALL HLx32
1776+ 5631 06 20            LD B,32
1777+ 5633              .L5:
1778+ 5633 3A AF FC         LD A,(SCRMOD)
1779+ 5636 3D               DEC A
1780+ 5637 20 06            JR NZ,.L10
1781+ 5639 ED 5B C5 F3      LD DE,(T32PAT)
1782+ 563D 18 04            JR .L7
1783+ 563F              .L10:
1784+ 563F ED 5B CF F3      LD DE,(GRPPAT)
1785+ 5643              .L7:
1786+ 5643 19               ADD HL,DE
1787+ 5644 CD 25 64         CALL SETWRT_LOCAL
1788+ 5647 FD 6E 03         LD L,(IY+3)
1789+ 564A FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
1790+ 564D C3 30 64         JP BBYTECOPY
1791+ 5650              .L4:
1792+ 5650                  ; change pattern and color in sprite attributes table
1793+ 5650 DD 7E 00         LD A,(IX) ; sprite number
1794+ 5653 CD 89 4D         CALL GETnthSPRATTR
1795+ 5656 23          > INC HL ; skip y and x
1795+ 5657 23          > INC HL
1795+ 5658 23          > INC HL
1795+ 5659 23          > INC HL
1796+ 565A FD 7E 03         LD A,(IY+3) ; new pattern
1797+ 565D 77               LD (HL),A
1798+ 565E 23          > INC HL
1798+ 565F 23          > INC HL
1799+ 5660 FD 7E 04         LD A,(IY+4) ; new color
1800+ 5663 77               LD (HL),A
1801+ 5664 2A 80 4D         LD HL,(SPRATR_UPDATE_FLAG)
1802+ 5667 36 01            LD (HL),1
1803+ 5669 C9               RET
1804+ 566A              .CHAR:
1805+ 566A DD 6E 00         LD L,(IX)
1806+ 566D 3D               DEC A
1807+ 566E 67               LD H,A
1808+ 566F CD 3A 64         CALL HLx8
1809+ 5672 3A AF FC         LD A,(SCRMOD)
1810+ 5675 3D               DEC A
1811+ 5676 20 06            JR NZ,.L8
1812+ 5678 ED 5B C1 F3      LD DE,(T32CGP)
1813+ 567C 18 04            JR .L9
1814+ 567E              .L8:
1815+ 567E ED 5B CB F3      LD DE,(GRPCGP)
1816+ 5682              .L9:
1817+ 5682 06 08            LD B,8
1818+ 5684 18 BD            JR .L7
1819+ 5686              ; *******************************************************************************************************
1820+ 5686
# file closed: asm\ANIMATION.asm
 133  5686               INCLUDE "SGAM.asm"
# file opened: asm\SGAM.asm
   1+ 5686              ; Sprite Group Animate and Move
   2+ 5686
   3+ 5686              ; *******************************************************************************************************
   4+ 5686              ; shared function to process a list of animations
   5+ 5686              ; input B=list size
   6+ 5686              ; input DE=list pointer
   7+ 5686              SGAM_PROCESS_ANIM_LIST:
   8+ 5686 21 99 56         LD HL,.STEP
   9+ 5689 22 74 55         LD (ANIM_SETVALUE.FN+1),HL
  10+ 568C              .L1:
  11+ 568C C5               PUSH BC
  12+ 568D 1A               LD A,(DE)
  13+ 568E 13          > INC DE
  13+ 568F 13          > INC DE
  14+ 5690 D5               PUSH DE
  15+ 5691 CD 64 55         CALL ANIM_SETVALUE
  16+ 5694 D1               POP DE
  17+ 5695 C1               POP BC
  18+ 5696 10 F4            DJNZ .L1
  19+ 5698 C9           	RET
  20+ 5699              .STEP:
  21+ 5699 06 01            LD B,1
  22+ 569B C3 94 55         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
  23+ 569E              ; *******************************************************************************************************
  24+ 569E
  25+ 569E               IF (1 == 1)
  26+ 569E              ; *******************************************************************************************************
  27+ 569E              ; function to handle CALL SGAM basic extension
  28+ 569E              ; sets position of a group of sprites as described in SPRGRPMOV
  29+ 569E              ; and manually animate a list of animations
  30+ 569E              ; _SGAM ( INT x,
  31+ 569E              ;	      INT y,
  32+ 569E              ;		  BYTE count,
  33+ 569E              ;		  INT[2][count] data_ptr,
  34+ 569E              ;         BYTE item_number,
  35+ 569E              ;         INT[] sprite_animations )
  36+ 569E              ; will put ram in page 0 also, page 1 is already there
  37+ 569E              SGAM:
  38+ 569E 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
  39+ 56A1 B7           	OR A
  40+ 56A2 CA 6D 65     	JP Z,ILLEGAL_FUNCTION
  41+ 56A5              	; opening (
  42+ 56A5 CD 4D 65     	CALL CHKCHAR
  43+ 56A8 28           	DB '('
  44+ 56A9              	; get x
  45+ 56A9 DD 21 2F 54  	LD IX, FRMQNT
  46+ 56AD CD 59 01     	CALL CALBAS
  47+ 56B0 ED 53 3D 62  	LD (BLIT_STRUCT),DE
  48+ 56B4              	; comma
  49+ 56B4 CD 4D 65     	CALL CHKCHAR
  50+ 56B7 2C           	DB ','
  51+ 56B8              	; get y
  52+ 56B8 DD 21 2F 54  	LD IX, FRMQNT
  53+ 56BC CD 59 01     	CALL CALBAS
  54+ 56BF ED 53 3F 62  	LD (BLIT_STRUCT+2),DE
  55+ 56C3              	; comma
  56+ 56C3 CD 4D 65     	CALL CHKCHAR
  57+ 56C6 2C           	DB ','
  58+ 56C7              	; get count
  59+ 56C7 DD 21 1C 52  	LD IX, GETBYT
  60+ 56CB CD 59 01     	CALL CALBAS
  61+ 56CE B7               OR A
  62+ 56CF CA 65 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
  63+ 56D2 32 41 62     	LD (BLIT_STRUCT+4),A
  64+ 56D5              	; comma
  65+ 56D5 CD 4D 65     	CALL CHKCHAR
  66+ 56D8 2C           	DB ','
  67+ 56D9              	; get sprite group definition array data pointer
  68+ 56D9 3A 41 62         LD A,(BLIT_STRUCT+4)
  69+ 56DC 5F           	LD E,A
  70+ 56DD 16 03        	LD D,3
  71+ 56DF 3E 02        	LD A,2
  72+ 56E1 47           	LD B,A
  73+ 56E2 CD 7A 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
  74+ 56E5 ED 43 42 62  	LD (BLIT_STRUCT+5),BC
  75+ 56E9              	; comma
  76+ 56E9 CD 4D 65     	CALL CHKCHAR
  77+ 56EC 2C           	DB ','
  78+ 56ED              	; get sprite animation array size
  79+ 56ED DD 21 1C 52  	LD IX,GETBYT
  80+ 56F1 CD 59 01     	CALL CALBAS
  81+ 56F4 32 44 62         LD (BLIT_STRUCT+7),A
  82+ 56F7 B7               OR A
  83+ 56F8 CA 65 65         JP Z,SUBSCRIPT_OUT_OF_RANGE
  84+ 56FB              	; comma
  85+ 56FB CD 4D 65     	CALL CHKCHAR
  86+ 56FE 2C           	DB ','
  87+ 56FF                  ; get array pointer
  88+ 56FF 3A 44 62         LD A,(BLIT_STRUCT+7)
  89+ 5702 57               LD D,A
  90+ 5703 3E 02            LD A,2
  91+ 5705 06 01            LD B,1
  92+ 5707 CD 7A 65         CALL GET_BASIC_ARRAY_DATA_POINTER
  93+ 570A ED 43 45 62      LD (BLIT_STRUCT+8),BC
  94+ 570E              	; ending )
  95+ 570E CD 4D 65     	CALL CHKCHAR
  96+ 5711 29           	DB ')'
  97+ 5712              .ENTRY:
  98+ 5712 E5               PUSH HL
  99+ 5713
 100+ 5713              	; enable page 0
 101+ 5713 FD 21 1A 57  	LD IY, .RET
 102+ 5717 C3 FE 64     	JP ENABLE_PAGE0
 103+ 571A              .RET:
 104+ 571A D9               EXX
 105+ 571B ED 5B 3D 62      LD DE,(BLIT_STRUCT) ; initial x
 106+ 571F ED 4B 3F 62      LD BC,(BLIT_STRUCT+2) ; initial y
 107+ 5723 D9               EXX
 108+ 5724 2A 42 62         LD HL,(BLIT_STRUCT+5) ; pointer to data
 109+ 5727 3A 41 62         LD A,(BLIT_STRUCT+4) ; number of entries
 110+ 572A 47               LD B,A
 111+ 572B CD DD 4E         CALL SPR_UPDATE_LOC
 112+ 572E
 113+ 572E 3A 44 62         LD A,(BLIT_STRUCT+7) ; anim number
 114+ 5731 47               LD B,A
 115+ 5732 ED 5B 45 62      LD DE,(BLIT_STRUCT+8) ; anim list
 116+ 5736 CD 86 56     	CALL SGAM_PROCESS_ANIM_LIST
 117+ 5739
 118+ 5739 D1               POP DE
 119+ 573A C1               POP BC
 120+ 573B CD 75 64         CALL RESTORE_PAGE_INFO
 121+ 573E FB               EI
 122+ 573F E1               POP HL
 123+ 5740 C9               RET
 124+ 5741              ; *******************************************************************************************************
 125+ 5741               ENDIF
 126+ 5741
 127+ 5741               IF (0 == 1)
 128+ 5741 ~            ; *******************************************************************************************************
 129+ 5741 ~            ; same as SGAM but for DEFUSR approach
 130+ 5741 ~            ; input IX=pointer to input array, real data from +2
 131+ 5741 ~            ; +02 = X
 132+ 5741 ~            ; +04 = Y
 133+ 5741 ~            ; +06 = count
 134+ 5741 ~            ; +08 = data pointer
 135+ 5741 ~            ; +10 = anim number
 136+ 5741 ~            ; +12 = sprite animations
 137+ 5741 ~            SGAM_DEFUSR:
 138+ 5741 ~            	; enable page 0
 139+ 5741 ~            	LD IY, .RET
 140+ 5741 ~            	JP ENABLE_PAGE0
 141+ 5741 ~            .RET:
 142+ 5741 ~            	EI
 143+ 5741 ~                EXX
 144+ 5741 ~            	LD E,(IX+2)
 145+ 5741 ~            	LD D,(IX+3) ; initial x
 146+ 5741 ~            	LD C,(IX+4)
 147+ 5741 ~            	LD B,(IX+5) ; initial y
 148+ 5741 ~                EXX
 149+ 5741 ~            	LD L,(IX+8)
 150+ 5741 ~            	LD H,(IX+9) ; pointer to data
 151+ 5741 ~                LD B,(IX+6) ; count
 152+ 5741 ~            	PUSH IX
 153+ 5741 ~                CALL SPR_UPDATE_LOC
 154+ 5741 ~            	POP IX
 155+ 5741 ~                LD B,(IX+10) ; anim number
 156+ 5741 ~            	LD E,(IX+12)
 157+ 5741 ~            	LD D,(IX+13)
 158+ 5741 ~            	CALL SGAM_PROCESS_ANIM_LIST
 159+ 5741 ~
 160+ 5741 ~                POP DE
 161+ 5741 ~                POP BC
 162+ 5741 ~                JP RESTORE_PAGE_INFO
 163+ 5741 ~            ; *******************************************************************************************************
 164+ 5741               ENDIF
 165+ 5741
 166+ 5741              ; *******************************************************************************************************
 167+ 5741              ; handles automatic move and animate sprite groups during interrupt
 168+ 5741              PROCESS_AUTOSGAMS:
 169+ 5741 3A 63 4F     	LD A,(AUTOSGAMNUM)
 170+ 5744 B7           	OR A
 171+ 5745 C8           	RET Z
 172+ 5746 47           	LD B,A
 173+ 5747 DD 2A 64 4F  	LD IX,(AUTOSGAMPTR)
 174+ 574B              .L1:
 175+ 574B C5           	PUSH BC
 176+ 574C DD 7E 13     	LD A,(IX+19) ; active flag
 177+ 574F B7           	OR A
 178+ 5750 28 28        	JR Z,.LOOPEND
 179+ 5752              	; active, check timer
 180+ 5752 DD 6E 16     	LD L,(IX+22)
 181+ 5755 DD 66 17     	LD H,(IX+23) ; timer
 182+ 5758 2B           	DEC HL
 183+ 5759 7C           	LD A,H
 184+ 575A B5           	OR L
 185+ 575B 28 08        	JR Z,.L2
 186+ 575D              	; not expired
 187+ 575D DD 75 16     	LD (IX+22),L
 188+ 5760 DD 74 17     	LD (IX+23),H
 189+ 5763 18 15        	JR .LOOPEND
 190+ 5765              .L2:
 191+ 5765              	; expired, process
 192+ 5765
 193+ 5765                  ; set initial timer
 194+ 5765 DD 7E 14         LD A,(IX+20)
 195+ 5768 DD 77 16         LD (IX+22),A
 196+ 576B DD 7E 15         LD A,(IX+21)
 197+ 576E DD 77 17         LD (IX+23),A
 198+ 5771
 199+ 5771 CD 83 57     	CALL .MOVE
 200+ 5774 CD EE 57     	CALL .UPDATELOC
 201+ 5777 CD 13 58     	CALL .PROCESS_ANIM_LIST
 202+ 577A
 203+ 577A              .LOOPEND:
 204+ 577A 11 18 00     	LD DE,24
 205+ 577D DD 19        	ADD IX,DE
 206+ 577F C1           	POP BC
 207+ 5780 10 C9        	DJNZ .L1
 208+ 5782 C9           	RET
 209+ 5783
 210+ 5783              .MOVE:
 211+ 5783              	; process movement
 212+ 5783 DD 7E 0A     	LD A,(IX+10) ; direction
 213+ 5786 B7           	OR A
 214+ 5787 28 08        	JR Z, .MOVE_L1
 215+ 5789              	; vertical
 216+ 5789 DD 6E 02     	LD L,(IX+2)
 217+ 578C DD 66 03     	LD H,(IX+3) ; vertical variable pointer
 218+ 578F 18 06        	JR .MOVE_L2
 219+ 5791              .MOVE_L1:
 220+ 5791              	; horizontal
 221+ 5791 DD 6E 00     	LD L,(IX+0)
 222+ 5794 DD 66 01     	LD H,(IX+1) ; horizontal variable pointer
 223+ 5797              .MOVE_L2:
 224+ 5797 E5           	PUSH HL
 225+ 5798 FD E1        	POP IY
 226+ 579A FD 6E 00     	LD L,(IY+0)
 227+ 579D FD 66 01     	LD H,(IY+1)
 228+ 57A0 DD 5E 08     	LD E,(IX+8)
 229+ 57A3 DD 56 09     	LD D,(IX+9) ; delta value
 230+ 57A6 19           	ADD HL,DE
 231+ 57A7 E5           	PUSH HL
 232+ 57A8 DD 5E 04     	LD E,(IX+4)
 233+ 57AB DD 56 05     	LD D,(IX+5) ; minimum value
 234+ 57AE A7           	AND A
 235+ 57AF ED 52        	SBC HL,DE
 236+ 57B1 FA CB 57     	JP M,.MOVE_L3 ; below minimum
 237+ 57B4 E1           	POP HL
 238+ 57B5 E5           	PUSH HL
 239+ 57B6 DD 5E 06     	LD E,(IX+6)
 240+ 57B9 DD 56 07     	LD D,(IX+7) ; maximum value
 241+ 57BC EB           	EX DE,HL
 242+ 57BD A7           	AND A
 243+ 57BE ED 52        	SBC HL,DE
 244+ 57C0 FA D3 57     	JP M,.MOVE_L4 ; above maximum
 245+ 57C3 E1           	POP HL
 246+ 57C4              	; within bounds
 247+ 57C4              .MOVE_L5:
 248+ 57C4 FD 75 00     	LD (IY+0),L
 249+ 57C7 FD 74 01     	LD (IY+1),H
 250+ 57CA C9           	RET
 251+ 57CB              .MOVE_L3:
 252+ 57CB E1           	POP HL
 253+ 57CC CD DF 57     	CALL .INVERSE_DELTA
 254+ 57CF 6B           	LD L,E
 255+ 57D0 62           	LD H,D
 256+ 57D1 18 F1        	JR .MOVE_L5
 257+ 57D3              .MOVE_L4:
 258+ 57D3 E1           	POP HL
 259+ 57D4 CD DF 57     	CALL .INVERSE_DELTA
 260+ 57D7 DD 6E 06     	LD L,(IX+6)
 261+ 57DA DD 66 07     	LD H,(IX+7) ; maximum
 262+ 57DD 18 E5        	JR .MOVE_L5
 263+ 57DF              .INVERSE_DELTA:
 264+ 57DF AF           	XOR A
 265+ 57E0 DD 96 08     	SUB (IX+8)
 266+ 57E3 DD 77 08     	LD (IX+8),A
 267+ 57E6 9F           	SBC A,A
 268+ 57E7 DD 96 09     	SUB (IX+9)
 269+ 57EA DD 77 09     	LD (IX+9),A
 270+ 57ED C9           	RET
 271+ 57EE
 272+ 57EE              .UPDATELOC:
 273+ 57EE DD E5        	PUSH IX
 274+ 57F0 D9           	EXX
 275+ 57F1 DD 6E 00     	LD L,(IX+0)
 276+ 57F4 DD 66 01     	LD H,(IX+1)
 277+ 57F7 5E           	LD E,(HL)
 278+ 57F8 23           	INC HL
 279+ 57F9 56           	LD D,(HL)
 280+ 57FA DD 6E 02     	LD L,(IX+2)
 281+ 57FD DD 66 03     	LD H,(IX+3)
 282+ 5800 4E           	LD C,(HL)
 283+ 5801 23           	INC HL
 284+ 5802 46           	LD B,(HL)
 285+ 5803 D9           	EXX
 286+ 5804 DD 6E 0C     	LD L,(IX+12)
 287+ 5807 DD 66 0D     	LD H,(IX+13) ; pointer to sprite group data
 288+ 580A DD 46 0B     	LD B,(IX+11) ; sprite group size
 289+ 580D CD DD 4E     	CALL SPR_UPDATE_LOC
 290+ 5810 DD E1        	POP IX
 291+ 5812 C9           	RET
 292+ 5813
 293+ 5813              .PROCESS_ANIM_LIST:
 294+ 5813 DD E5        	PUSH IX
 295+ 5815 DD 46 0E         LD B,(IX+14) ; anim list size
 296+ 5818 DD CB 09 7E  	BIT 7,(IX+9)
 297+ 581C 28 08        	JR Z,.PROCESS_ANIM_LIST_L1
 298+ 581E              	; negative direction
 299+ 581E DD 5E 0F     	LD E,(IX+15)
 300+ 5821 DD 56 10     	LD D,(IX+16)
 301+ 5824 18 06        	JR .PROCESS_ANIM_LIST_L2
 302+ 5826              .PROCESS_ANIM_LIST_L1:
 303+ 5826              	; positive direction
 304+ 5826 DD 5E 11     	LD E,(IX+17)
 305+ 5829 DD 56 12     	LD D,(IX+18)
 306+ 582C              .PROCESS_ANIM_LIST_L2:
 307+ 582C CD 86 56     	CALL SGAM_PROCESS_ANIM_LIST
 308+ 582F DD E1        	POP IX
 309+ 5831 C9           	RET
 310+ 5832              ; *******************************************************************************************************
 311+ 5832
# file closed: asm\SGAM.asm
 134  5832               ENDIF
 135  5832
 136  5832               IF (RAM_CMDS == 1)
 137  5832               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
   1+ 5832               IF (1 == 1)
   2+ 5832              ; *******************************************************************************************************
   3+ 5832              ; function to handle CALL MEMCPY basic extension
   4+ 5832              ; _MEMCPY ( INT source,
   5+ 5832              ;			INT destination,
   6+ 5832              ;			INT count,
   7+ 5832              ; will put ram in page 0 also, page 1 is already there
   8+ 5832              MEMCPY:
   9+ 5832              	; opening (
  10+ 5832 CD 4D 65     	CALL CHKCHAR
  11+ 5835 28           	DB '('
  12+ 5836              	; get source address
  13+ 5836 DD 21 2F 54  	LD IX, FRMQNT
  14+ 583A CD 59 01     	CALL CALBAS
  15+ 583D D5           	PUSH DE
  16+ 583E              	; comma
  17+ 583E CD 4D 65     	CALL CHKCHAR
  18+ 5841 2C           	DB ','
  19+ 5842              	; get destination address
  20+ 5842 DD 21 2F 54  	LD IX, FRMQNT
  21+ 5846 CD 59 01     	CALL CALBAS
  22+ 5849 D5           	PUSH DE
  23+ 584A              	; comma
  24+ 584A CD 4D 65     	CALL CHKCHAR
  25+ 584D 2C           	DB ','
  26+ 584E              	; get length
  27+ 584E DD 21 2F 54  	LD IX, FRMQNT
  28+ 5852 CD 59 01     	CALL CALBAS
  29+ 5855 D5           	PUSH DE
  30+ 5856              	; ending )
  31+ 5856 CD 4D 65     	CALL CHKCHAR
  32+ 5859 29           	DB ')'
  33+ 585A
  34+ 585A              	; save position
  35+ 585A E5           	PUSH HL
  36+ 585B DD E1        	POP IX
  37+ 585D
  38+ 585D C1           	POP BC ; count
  39+ 585E D1           	POP DE ; destination
  40+ 585F E1           	POP HL ; source
  41+ 5860 D9           	EXX
  42+ 5861              	; enable page 0
  43+ 5861 FD 21 68 58  	LD IY, .RET
  44+ 5865 C3 FE 64     	JP ENABLE_PAGE0
  45+ 5868              .RET:
  46+ 5868 FB           	EI
  47+ 5869 D9           	EXX
  48+ 586A ED B0        	LDIR
  49+ 586C D1               POP DE
  50+ 586D C1               POP BC
  51+ 586E CD 75 64         CALL RESTORE_PAGE_INFO
  52+ 5871 DD E5        	PUSH IX
  53+ 5873 E1           	POP HL
  54+ 5874 C9           	RET
  55+ 5875              ; *******************************************************************************************************
  56+ 5875               ENDIF
  57+ 5875
  58+ 5875               IF (0 == 1)
  59+ 5875 ~            ; *******************************************************************************************************
  60+ 5875 ~            ; same as MEMCPY but for DEFUSR approach
  61+ 5875 ~            ; input IX=pointer to input array, real data from +2
  62+ 5875 ~            ; +2 = source address
  63+ 5875 ~            ; +4 = destination address
  64+ 5875 ~            ; +6 = lenght
  65+ 5875 ~            MEMCPY_DEFUSR:
  66+ 5875 ~            	; enable page 0
  67+ 5875 ~            	LD IY, .RET
  68+ 5875 ~            	JP ENABLE_PAGE0
  69+ 5875 ~            .RET:
  70+ 5875 ~            	EI
  71+ 5875 ~            	LD L,(IX+2)
  72+ 5875 ~            	LD H,(IX+3)
  73+ 5875 ~            	LD E,(IX+4)
  74+ 5875 ~            	LD D,(IX+5)
  75+ 5875 ~            	LD C,(IX+6)
  76+ 5875 ~            	LD B,(IX+7)
  77+ 5875 ~            	LDIR
  78+ 5875 ~                POP DE
  79+ 5875 ~                POP BC
  80+ 5875 ~                JP RESTORE_PAGE_INFO
  81+ 5875 ~            ; *******************************************************************************************************
  82+ 5875               ENDIF
  83+ 5875
  84+ 5875               IF (1 == 1)
  85+ 5875              ; *******************************************************************************************************
  86+ 5875              ; function to handle CALL FILRAM basic extension
  87+ 5875              ; FILRAM ( INT start address,
  88+ 5875              ;		   INT count,
  89+ 5875              ;		   BYTE value )
  90+ 5875              ; will put ram in page 0 also, page 1 is already there
  91+ 5875              FILRAM:
  92+ 5875              	; opening (
  93+ 5875 CD 4D 65     	CALL CHKCHAR
  94+ 5878 28           	DB '('
  95+ 5879              	; get start address
  96+ 5879 DD 21 2F 54  	LD IX, FRMQNT
  97+ 587D CD 59 01     	CALL CALBAS
  98+ 5880 D5           	PUSH DE
  99+ 5881              	; comma
 100+ 5881 CD 4D 65     	CALL CHKCHAR
 101+ 5884 2C           	DB ','
 102+ 5885              	; get count
 103+ 5885 DD 21 2F 54  	LD IX, FRMQNT
 104+ 5889 CD 59 01     	CALL CALBAS
 105+ 588C D5           	PUSH DE
 106+ 588D              	; comma
 107+ 588D CD 4D 65     	CALL CHKCHAR
 108+ 5890 2C           	DB ','
 109+ 5891              	; get value
 110+ 5891 DD 21 1C 52  	LD IX, GETBYT
 111+ 5895 CD 59 01     	CALL CALBAS
 112+ 5898 F5           	PUSH AF
 113+ 5899              	; ending )
 114+ 5899 CD 4D 65     	CALL CHKCHAR
 115+ 589C 29           	DB ')'
 116+ 589D
 117+ 589D              	; save position
 118+ 589D E5           	PUSH HL
 119+ 589E DD E1        	POP IX
 120+ 58A0
 121+ 58A0 D1           	POP DE ; actually AF
 122+ 58A1 C1           	POP BC ; count
 123+ 58A2 E1           	POP HL ; start address
 124+ 58A3 78           	LD A, B
 125+ 58A4 B1           	OR C
 126+ 58A5 28 12        	JR Z, .EXIT ; 0 bytes to fill, skip
 127+ 58A7 D9           	EXX
 128+ 58A8              	; enable page 0
 129+ 58A8 FD 21 AF 58  	LD IY, .RET
 130+ 58AC C3 FE 64     	JP ENABLE_PAGE0
 131+ 58AF              .RET:
 132+ 58AF FB           	EI
 133+ 58B0 D9           	EXX
 134+ 58B1 CD BD 58     	CALL FILVRM_FILLVALUE
 135+ 58B4 D1               POP DE
 136+ 58B5 C1               POP BC
 137+ 58B6 CD 75 64         CALL RESTORE_PAGE_INFO
 138+ 58B9              .EXIT:
 139+ 58B9 DD E5        	PUSH IX
 140+ 58BB E1           	POP HL
 141+ 58BC C9           	RET
 142+ 58BD              ; *******************************************************************************************************
 143+ 58BD               ENDIF
 144+ 58BD
 145+ 58BD               IF (0 == 1)
 146+ 58BD ~            ; *******************************************************************************************************
 147+ 58BD ~            ; same as FILVRM but for DEFUSR approach
 148+ 58BD ~            ; input IX=pointer to input array, real data from +2
 149+ 58BD ~            ; +2 = start address
 150+ 58BD ~            ; +4 = count
 151+ 58BD ~            ; +6 = value
 152+ 58BD ~            FILRAM_DEFUSR:
 153+ 58BD ~            	; enable page 0
 154+ 58BD ~            	LD IY, .RET
 155+ 58BD ~            	JP ENABLE_PAGE0
 156+ 58BD ~            .RET:
 157+ 58BD ~            	EI
 158+ 58BD ~            	LD L,(IX+2)
 159+ 58BD ~            	LD H,(IX+3)
 160+ 58BD ~            	LD C,(IX+4)
 161+ 58BD ~            	LD B,(IX+5)
 162+ 58BD ~            	LD A,B
 163+ 58BD ~            	OR C
 164+ 58BD ~            	JR Z,.EXIT
 165+ 58BD ~            	LD D,(IX+6)
 166+ 58BD ~            	CALL FILVRM_FILLVALUE
 167+ 58BD ~            .EXIT:
 168+ 58BD ~                POP DE
 169+ 58BD ~                POP BC
 170+ 58BD ~                JP RESTORE_PAGE_INFO
 171+ 58BD ~            ; *******************************************************************************************************
 172+ 58BD               ENDIF
 173+ 58BD
 174+ 58BD              ; *******************************************************************************************************
 175+ 58BD              ; common function to fill RAM
 176+ 58BD              FILVRM_FILLVALUE:
 177+ 58BD 72               LD (HL), D
 178+ 58BE 54               LD D, H
 179+ 58BF 5D               LD E, L
 180+ 58C0 13               INC DE
 181+ 58C1 0B               DEC BC
 182+ 58C2 78           	LD A,B
 183+ 58C3 B1           	OR C
 184+ 58C4 C8           	RET Z ; if count was 1
 185+ 58C5 ED B0            LDIR
 186+ 58C7 C9               RET
 187+ 58C8              ; *******************************************************************************************************
# file closed: asm\MEMORY.asm
 138  58C8               ENDIF
 139  58C8
 140  58C8               IF (SOUND_CMDS == 1)
 141  58C8               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
   1+ 58C8              MUSIC_INIT_STATUS:
   2+ 58C8 00            DB 0
   3+ 58C9              SFX_INIT_STATUS:
   4+ 58C9 00            DB 0
   5+ 58CA              SOUND_ENABLED:
   6+ 58CA 00            DB 0
   7+ 58CB
   8+ 58CB               IF (1 == 1)
   9+ 58CB              ; *******************************************************************************************************
  10+ 58CB              ; function to handle CALL SNDPLYINIT basic extension
  11+ 58CB              ; initializes sound player
  12+ 58CB              ; _SNDPLYINIT ( INT music_offset,
  13+ 58CB              ;				INT sfx_offset, can be -1 if no SFX
  14+ 58CB              ; will put ram in page 0 also, page 1 is already there
  15+ 58CB              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
  16+ 58CB              SNDPLYINIT:
  17+ 58CB              	; opening (
  18+ 58CB CD 4D 65     	CALL CHKCHAR
  19+ 58CE 28           	DB '('
  20+ 58CF              	; get music address
  21+ 58CF DD 21 2F 54  	LD IX, FRMQNT
  22+ 58D3 CD 59 01     	CALL CALBAS
  23+ 58D6 D5           	PUSH DE
  24+ 58D7              	; comma
  25+ 58D7 CD 4D 65     	CALL CHKCHAR
  26+ 58DA 2C           	DB ','
  27+ 58DB              	; get sfx address
  28+ 58DB DD 21 2F 54  	LD IX, FRMQNT
  29+ 58DF CD 59 01     	CALL CALBAS
  30+ 58E2 D5           	PUSH DE
  31+ 58E3              	; ending )
  32+ 58E3 CD 4D 65     	CALL CHKCHAR
  33+ 58E6 29           	DB ')'
  34+ 58E7
  35+ 58E7                  ; save position in BASIC text
  36+ 58E7 44           	LD B, H
  37+ 58E8 4D           	LD C, L
  38+ 58E9
  39+ 58E9              	; pop LDIR parameters and store away for later
  40+ 58E9 D1           	POP DE ; sfx address
  41+ 58EA E1           	POP HL ; music address
  42+ 58EB C5           	PUSH BC ; basic text location
  43+ 58EC D9           	EXX
  44+ 58ED FD 21 F4 58  	LD IY, .RET
  45+ 58F1 C3 FE 64     	JP ENABLE_PAGE0
  46+ 58F4              .RET:
  47+ 58F4 D9           	EXX
  48+ 58F5
  49+ 58F5 D5           	PUSH DE
  50+ 58F6 AF           	XOR A
  51+ 58F7              	; HL = music location
  52+ 58F7 CD 65 41     	CALL PLY_AKG_INIT
  53+ 58FA 3E 01        	LD A, 1
  54+ 58FC 32 C8 58     	LD (MUSIC_INIT_STATUS), A
  55+ 58FF
  56+ 58FF E1           	POP HL ; SFX
  57+ 5900              	; check if SFX address -1
  58+ 5900 23           	INC HL
  59+ 5901 7D           	LD A, L
  60+ 5902 B4           	OR H
  61+ 5903 28 09        	JR Z,.L1
  62+ 5905 2B           	DEC HL
  63+ 5906 CD 20 40     	CALL PLY_AKG_INITSOUNDEFFECTS
  64+ 5909 3E 01        	LD A, 1
  65+ 590B 32 C9 58     	LD (SFX_INIT_STATUS), A
  66+ 590E              .L1:
  67+ 590E D1               POP DE
  68+ 590F C1               POP BC
  69+ 5910 CD 75 64         CALL RESTORE_PAGE_INFO
  70+ 5913
  71+ 5913 E1           	POP HL
  72+ 5914 C9           	RET
  73+ 5915              ; *******************************************************************************************************
  74+ 5915               ENDIF
  75+ 5915
  76+ 5915               IF (0 == 1)
  77+ 5915 ~            ; *******************************************************************************************************
  78+ 5915 ~            ; same as SNDPLYINI but for DEFUSR approach
  79+ 5915 ~            ; input IX=pointer to input array, real data from +2
  80+ 5915 ~            ; +2 = music address
  81+ 5915 ~            ; +4 = sfx address
  82+ 5915 ~            SNDPLYINI_DEFUSR:
  83+ 5915 ~            	LD IY, .RET
  84+ 5915 ~            	JP ENABLE_PAGE0
  85+ 5915 ~            .RET:
  86+ 5915 ~            	XOR A
  87+ 5915 ~            	LD L,(IX+2)
  88+ 5915 ~            	LD H,(IX+3)
  89+ 5915 ~            	PUSH IX
  90+ 5915 ~            	CALL PLY_AKG_INIT
  91+ 5915 ~            	POP IX
  92+ 5915 ~            	LD A, 1
  93+ 5915 ~            	LD (MUSIC_INIT_STATUS), A
  94+ 5915 ~
  95+ 5915 ~            	LD L,(IX+4)
  96+ 5915 ~            	LD H,(IX+5)
  97+ 5915 ~            	; check if SFX address -1
  98+ 5915 ~            	INC HL
  99+ 5915 ~            	LD A, L
 100+ 5915 ~            	OR H
 101+ 5915 ~            	JR Z,.L1
 102+ 5915 ~            	DEC HL
 103+ 5915 ~            	CALL PLY_AKG_INITSOUNDEFFECTS
 104+ 5915 ~            	LD A, 1
 105+ 5915 ~            	LD (SFX_INIT_STATUS), A
 106+ 5915 ~            .L1:
 107+ 5915 ~                POP DE
 108+ 5915 ~                POP BC
 109+ 5915 ~                JP RESTORE_PAGE_INFO
 110+ 5915 ~            ; *******************************************************************************************************
 111+ 5915               ENDIF
 112+ 5915
 113+ 5915              ; *******************************************************************************************************
 114+ 5915              ; function to handle CALL SNDPLYON basic extension
 115+ 5915              ; enables sound player
 116+ 5915              ; _SNDPLYON
 117+ 5915              ; sets SOUND_ENABLED variable to 1 if init call was done
 118+ 5915              ; if not throws out of data error
 119+ 5915              SNDPLYON_DEFUSR:
 120+ 5915              SNDPLYON:
 121+ 5915 3A C8 58     	LD A, (MUSIC_INIT_STATUS)
 122+ 5918 B7           	OR A
 123+ 5919 20 05        	JR NZ, .L1
 124+ 591B              	; player not initialized, throw error
 125+ 591B 1E 04        	LD E, 04 ; Out of DATA
 126+ 591D C3 73 65     	JP THROW_ERROR
 127+ 5920              .L1:
 128+ 5920 32 CA 58     	LD (SOUND_ENABLED), A
 129+ 5923              	; disable key click
 130+ 5923 AF           	XOR A
 131+ 5924 32 DB F3     	LD (CLIKSW), A
 132+ 5927 C9           	RET
 133+ 5928              ; *******************************************************************************************************
 134+ 5928
 135+ 5928              ; *******************************************************************************************************
 136+ 5928              ; function to handle CALL SNDPLYOFF basic extension
 137+ 5928              ; disables sound player
 138+ 5928              ; _SNDPLYOFF
 139+ 5928              ; sets SOUND_ENABLED variable to 0
 140+ 5928              ; calls AKG to stop music and SFX on all channels if initialized
 141+ 5928              SNDPLYOFF_DEFUSR:
 142+ 5928              SNDPLYOFF:
 143+ 5928 3A CA 58     	LD A, (SOUND_ENABLED)
 144+ 592B B7           	OR A
 145+ 592C C8           	RET Z ; already stopped
 146+ 592D AF           	XOR A
 147+ 592E 32 CA 58     	LD (SOUND_ENABLED), A
 148+ 5931 E5           	PUSH HL
 149+ 5932 CD 24 42     	CALL PLY_AKG_STOP
 150+ 5935 3A C9 58     	LD A, (SFX_INIT_STATUS)
 151+ 5938 B7           	OR A
 152+ 5939 28 0E        	JR Z, .EXIT ; SFX not in use
 153+ 593B AF           	XOR A
 154+ 593C CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 155+ 593F 3E 01        	LD A, 1
 156+ 5941 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 157+ 5944 3E 02        	LD A, 2
 158+ 5946 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 159+ 5949              .EXIT:
 160+ 5949 E1           	POP HL
 161+ 594A C9           	RET
 162+ 594B              ; *******************************************************************************************************
 163+ 594B
 164+ 594B               IF (1 == 1)
 165+ 594B              ; *******************************************************************************************************
 166+ 594B              ; function to handle CALL SNDSFX basic extension
 167+ 594B              ; plays a sound effect
 168+ 594B              ; _SNDSFX ( BYTE sfx_number, >0
 169+ 594B              ;			BYTE channel, = 0,1 or 2
 170+ 594B              ;			BYTE inverted_volume = 0-16, 0 being full volume
 171+ 594B              ; will put ram in page 0 also, page 1 is already there
 172+ 594B              ; if sound off throws illegal function call
 173+ 594B              ; if sfx not initialized, throws out of data
 174+ 594B              SNDSFX:
 175+ 594B              	; opening (
 176+ 594B CD 4D 65     	CALL CHKCHAR
 177+ 594E 28           	DB '('
 178+ 594F              	; get sfx_number
 179+ 594F DD 21 1C 52  	LD IX, GETBYT
 180+ 5953 CD 59 01     	CALL CALBAS
 181+ 5956 D5           	PUSH DE
 182+ 5957              	; comma
 183+ 5957 CD 4D 65     	CALL CHKCHAR
 184+ 595A 2C           	DB ','
 185+ 595B              	; get sfx address
 186+ 595B DD 21 1C 52  	LD IX, GETBYT
 187+ 595F CD 59 01     	CALL CALBAS
 188+ 5962 D5           	PUSH DE
 189+ 5963              	; comma
 190+ 5963 CD 4D 65     	CALL CHKCHAR
 191+ 5966 2C           	DB ','
 192+ 5967              	; get inverted volume
 193+ 5967 DD 21 1C 52  	LD IX, GETBYT
 194+ 596B CD 59 01     	CALL CALBAS
 195+ 596E D5           	PUSH DE
 196+ 596F              	; ending )
 197+ 596F CD 4D 65     	CALL CHKCHAR
 198+ 5972 29           	DB ')'
 199+ 5973
 200+ 5973 3A CA 58     	LD A, (SOUND_ENABLED)
 201+ 5976 B7           	OR A
 202+ 5977 20 05        	JR NZ, .L1
 203+ 5979              	; sound disabled, throw illegal function call
 204+ 5979 1E 05        	LD E, 5
 205+ 597B C3 73 65     	JP THROW_ERROR
 206+ 597E              .L1:
 207+ 597E 3A C9 58     	LD A, (SFX_INIT_STATUS)
 208+ 5981 B7           	OR A
 209+ 5982 20 05        	JR NZ, .L2
 210+ 5984              	; sfx data not initialized, throw out of data
 211+ 5984 1E 04        	LD E, 4
 212+ 5986 C3 73 65     	JP THROW_ERROR
 213+ 5989              .L2:
 214+ 5989              	; pop  parameters and store away for later
 215+ 5989 D1           	POP DE ; inverted volume
 216+ 598A 43           	LD B, E
 217+ 598B D1           	POP DE ; channel
 218+ 598C 4B           	LD C, E
 219+ 598D D1           	POP DE
 220+ 598E 7B           	LD A, E
 221+ 598F 08           	EX AF, AF'
 222+ 5990 E5           	PUSH HL ; basic text location
 223+ 5991 D9           	EXX
 224+ 5992 FD 21 99 59  	LD IY, .RET
 225+ 5996 C3 FE 64     	JP ENABLE_PAGE0
 226+ 5999              .RET:
 227+ 5999 D9           	EXX
 228+ 599A 08           	EX AF, AF'
 229+ 599B CD 24 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
 230+ 599E
 231+ 599E D1               POP DE
 232+ 599F C1               POP BC
 233+ 59A0 CD 75 64         CALL RESTORE_PAGE_INFO
 234+ 59A3
 235+ 59A3 E1           	POP HL
 236+ 59A4 C9           	RET
 237+ 59A5              ; *******************************************************************************************************
 238+ 59A5               ENDIF
 239+ 59A5
 240+ 59A5               IF (0 == 1)
 241+ 59A5 ~            ; *******************************************************************************************************
 242+ 59A5 ~            ; same as SNDSFX but for DEFUSR approach
 243+ 59A5 ~            ; input IX=pointer to input array, real data from +2
 244+ 59A5 ~            ; +2 = SFX number
 245+ 59A5 ~            ; +4 = channel
 246+ 59A5 ~            ; +6 = volume
 247+ 59A5 ~            SNDSFX_DEFUSR:
 248+ 59A5 ~            	LD A, (SOUND_ENABLED)
 249+ 59A5 ~            	OR A
 250+ 59A5 ~            	RET Z ; sound disabled, just exit
 251+ 59A5 ~            	LD A, (SFX_INIT_STATUS)
 252+ 59A5 ~            	OR A
 253+ 59A5 ~            	RET Z ; sfx data not initialized, just exit
 254+ 59A5 ~            	LD IY, .RET
 255+ 59A5 ~            	JP ENABLE_PAGE0
 256+ 59A5 ~            .RET:
 257+ 59A5 ~            	EI
 258+ 59A5 ~            	LD A,(IX+2) ; SFX number
 259+ 59A5 ~            	LD C,(IX+4) ; channel
 260+ 59A5 ~            	LD B,(IX+6) ; volume
 261+ 59A5 ~            	CALL PLY_AKG_PLAYSOUNDEFFECT
 262+ 59A5 ~                POP DE
 263+ 59A5 ~                POP BC
 264+ 59A5 ~                JP RESTORE_PAGE_INFO
 265+ 59A5 ~            ; *******************************************************************************************************
 266+ 59A5               ENDIF
# file closed: asm\SOUND.asm
 142  59A5               ENDIF
 143  59A5
 144  59A5               IF (VRAM_CMDS == 1)
 145  59A5               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
   1+ 59A5               IF (1 == 1)
   2+ 59A5              ; *******************************************************************************************************
   3+ 59A5              ; function to handle CALL FILVRM basic extension
   4+ 59A5              ; FILVRM ( INT offset,
   5+ 59A5              ;		   INT count,
   6+ 59A5              ;		   BYTE value,
   7+ 59A5              ;		   BYTE wait_vsync) >0 = true
   8+ 59A5              ; wait_vsync will issue HALT before copying
   9+ 59A5              FILVRM:
  10+ 59A5              	; opening (
  11+ 59A5 CD 4D 65     	CALL CHKCHAR
  12+ 59A8 28           	DB '('
  13+ 59A9              	; get offset address
  14+ 59A9 DD 21 2F 54  	LD IX, FRMQNT
  15+ 59AD CD 59 01     	CALL CALBAS
  16+ 59B0 D5           	PUSH DE
  17+ 59B1              	; comma
  18+ 59B1 CD 4D 65     	CALL CHKCHAR
  19+ 59B4 2C           	DB ','
  20+ 59B5              	; get count
  21+ 59B5 DD 21 2F 54  	LD IX, FRMQNT
  22+ 59B9 CD 59 01     	CALL CALBAS
  23+ 59BC D5           	PUSH DE
  24+ 59BD              	; comma
  25+ 59BD CD 4D 65     	CALL CHKCHAR
  26+ 59C0 2C           	DB ','
  27+ 59C1              	; get value
  28+ 59C1 DD 21 1C 52  	LD IX, GETBYT
  29+ 59C5 CD 59 01     	CALL CALBAS
  30+ 59C8 F5           	PUSH AF
  31+ 59C9              	; comma
  32+ 59C9 CD 4D 65     	CALL CHKCHAR
  33+ 59CC 2C           	DB ','
  34+ 59CD              	; get vsync wait
  35+ 59CD DD 21 1C 52  	LD IX, GETBYT
  36+ 59D1 CD 59 01     	CALL CALBAS
  37+ 59D4 F5           	PUSH AF
  38+ 59D5              	; ending )
  39+ 59D5 CD 4D 65     	CALL CHKCHAR
  40+ 59D8 29           	DB ')'
  41+ 59D9
  42+ 59D9              	; save position
  43+ 59D9 E5           	PUSH HL
  44+ 59DA DD E1        	POP IX
  45+ 59DC
  46+ 59DC              	; syntax ok
  47+ 59DC              	; wait for vsync if needed
  48+ 59DC F1           	POP AF
  49+ 59DD B7           	OR A
  50+ 59DE 28 01        	JR Z, .L1
  51+ 59E0 76           	HALT
  52+ 59E1
  53+ 59E1              .L1:
  54+ 59E1 3E 01        	LD A,1
  55+ 59E3 32 4E 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
  56+ 59E6 F1               POP AF ; value
  57+ 59E7 C1               POP BC ; count
  58+ 59E8 E1               POP HL ; offset
  59+ 59E9 CD 56 00         CALL BIOS_FILVRM
  60+ 59EC AF           	XOR A
  61+ 59ED 32 4E 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
  62+ 59F0
  63+ 59F0              .L3:
  64+ 59F0 DD E5        	PUSH IX
  65+ 59F2 E1           	POP HL
  66+ 59F3 C9           	RET
  67+ 59F4              ; *******************************************************************************************************
  68+ 59F4               ENDIF
  69+ 59F4
  70+ 59F4               IF (0 == 1)
  71+ 59F4 ~            ; *******************************************************************************************************
  72+ 59F4 ~            ; same as FILVRM but for DEFUSR approach
  73+ 59F4 ~            ; input IX=pointer to input array, real data from +2
  74+ 59F4 ~            ; +2 = offset
  75+ 59F4 ~            ; +4 = count
  76+ 59F4 ~            ; +6 = value
  77+ 59F4 ~            ; +8 = halt flag
  78+ 59F4 ~            FILVRM_DEFUSR:
  79+ 59F4 ~            	LD A,(IX+8)
  80+ 59F4 ~            	OR A
  81+ 59F4 ~            	JR Z,.L0
  82+ 59F4 ~            	HALT
  83+ 59F4 ~            .L0:
  84+ 59F4 ~            	LD A,1
  85+ 59F4 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  86+ 59F4 ~            	LD L,(IX+2)
  87+ 59F4 ~            	LD H,(IX+3)
  88+ 59F4 ~            	LD C,(IX+4)
  89+ 59F4 ~            	LD B,(IX+5)
  90+ 59F4 ~            	LD A,(IX+6)
  91+ 59F4 ~            	CALL BIOS_FILVRM
  92+ 59F4 ~            	XOR A
  93+ 59F4 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  94+ 59F4 ~            	RET
  95+ 59F4 ~            ; *******************************************************************************************************
  96+ 59F4               ENDIF
  97+ 59F4
  98+ 59F4               IF (1 == 1)
  99+ 59F4              ; *******************************************************************************************************
 100+ 59F4              ; function to handle CALL MEMVRM basic extension
 101+ 59F4              ; copies from RAM to VRAM
 102+ 59F4              ; _MEMVRM ( INT source,
 103+ 59F4              ;			INT destination,
 104+ 59F4              ;			INT count,
 105+ 59F4              ;			BYTE wait_vsync) >0 = true
 106+ 59F4              ; will put ram in page 0 also, page 1 is already there
 107+ 59F4              ; wait_vsync will issue HALT before copying
 108+ 59F4              MEMVRM:
 109+ 59F4              	; opening (
 110+ 59F4 CD 4D 65     	CALL CHKCHAR
 111+ 59F7 28           	DB '('
 112+ 59F8              	; get source address
 113+ 59F8 DD 21 2F 54  	LD IX, FRMQNT
 114+ 59FC CD 59 01     	CALL CALBAS
 115+ 59FF D5           	PUSH DE
 116+ 5A00              	; comma
 117+ 5A00 CD 4D 65     	CALL CHKCHAR
 118+ 5A03 2C           	DB ','
 119+ 5A04              	; get destination address
 120+ 5A04 DD 21 2F 54  	LD IX, FRMQNT
 121+ 5A08 CD 59 01     	CALL CALBAS
 122+ 5A0B D5           	PUSH DE
 123+ 5A0C              	; comma
 124+ 5A0C CD 4D 65     	CALL CHKCHAR
 125+ 5A0F 2C           	DB ','
 126+ 5A10              	; get length
 127+ 5A10 DD 21 2F 54  	LD IX, FRMQNT
 128+ 5A14 CD 59 01     	CALL CALBAS
 129+ 5A17 D5           	PUSH DE
 130+ 5A18              	; comma
 131+ 5A18 CD 4D 65     	CALL CHKCHAR
 132+ 5A1B 2C           	DB ','
 133+ 5A1C              	; get vsync wait
 134+ 5A1C DD 21 1C 52  	LD IX, GETBYT
 135+ 5A20 CD 59 01     	CALL CALBAS
 136+ 5A23 F5           	PUSH AF
 137+ 5A24              	; ending )
 138+ 5A24 CD 4D 65     	CALL CHKCHAR
 139+ 5A27 29           	DB ')'
 140+ 5A28
 141+ 5A28                  ; save position in BASIC text
 142+ 5A28 E5           	PUSH HL
 143+ 5A29 DD E1        	POP IX
 144+ 5A2B
 145+ 5A2B F1           	POP AF ; wait vsync
 146+ 5A2C B7           	OR A
 147+ 5A2D 28 05        	JR Z, .L1
 148+ 5A2F              	; TEST
 149+ 5A2F 2A 80 4D     	LD HL,(SPRATR_UPDATE_FLAG)
 150+ 5A32 77           	LD (HL),A
 151+ 5A33 76           	HALT
 152+ 5A34              .L1:
 153+ 5A34              	; pop LDIR parameters and store away for later
 154+ 5A34 C1           	POP BC ; count
 155+ 5A35 D1           	POP DE ; vram destination
 156+ 5A36 E1           	POP HL ; ram source
 157+ 5A37 D9           	EXX
 158+ 5A38 FD 21 3F 5A   	LD IY, .RET
 159+ 5A3C C3 FE 64     	JP ENABLE_PAGE0
 160+ 5A3F              .RET:
 161+ 5A3F FB           	EI
 162+ 5A40 D9           	EXX
 163+ 5A41 CD 4D 5A     	CALL VRAM_LDIRVM
 164+ 5A44 D1               POP DE
 165+ 5A45 C1               POP BC
 166+ 5A46 CD 75 64         CALL RESTORE_PAGE_INFO
 167+ 5A49 DD E5        	PUSH IX
 168+ 5A4B E1           	POP HL
 169+ 5A4C C9           	RET
 170+ 5A4D              ; *******************************************************************************************************
 171+ 5A4D               ENDIF
 172+ 5A4D
 173+ 5A4D               IF (0 == 1)
 174+ 5A4D ~            ; *******************************************************************************************************
 175+ 5A4D ~            ; same as MEMVRM but for DEFUSR approach
 176+ 5A4D ~            ; input IX=pointer to input array, real data from +2
 177+ 5A4D ~            ; +2 = source address
 178+ 5A4D ~            ; +4 = destination address
 179+ 5A4D ~            ; +6 = lenght
 180+ 5A4D ~            ; +8 = vsync wait flag
 181+ 5A4D ~            MEMVRM_DEFUSR:
 182+ 5A4D ~            	LD A,(IX+8)
 183+ 5A4D ~            	OR A
 184+ 5A4D ~            	JR Z,.L0
 185+ 5A4D ~            	HALT
 186+ 5A4D ~            .L0:
 187+ 5A4D ~            	; enable page 0
 188+ 5A4D ~            	LD IY, .RET
 189+ 5A4D ~            	JP ENABLE_PAGE0
 190+ 5A4D ~            .RET:
 191+ 5A4D ~            	EI
 192+ 5A4D ~            	LD L,(IX+2)
 193+ 5A4D ~            	LD H,(IX+3)
 194+ 5A4D ~            	LD E,(IX+4)
 195+ 5A4D ~            	LD D,(IX+5)
 196+ 5A4D ~            	LD C,(IX+6)
 197+ 5A4D ~            	LD B,(IX+7)
 198+ 5A4D ~            	CALL VRAM_LDIRVM
 199+ 5A4D ~                POP DE
 200+ 5A4D ~                POP BC
 201+ 5A4D ~                JP RESTORE_PAGE_INFO
 202+ 5A4D ~            ; *******************************************************************************************************
 203+ 5A4D               ENDIF
 204+ 5A4D
 205+ 5A4D              ; *******************************************************************************************************
 206+ 5A4D              ; common code to copy from memory to VRAM
 207+ 5A4D              ; input HL=RAM source
 208+ 5A4D              ; input DE=VRAM destination
 209+ 5A4D              ; BC=count
 210+ 5A4D              VRAM_LDIRVM:
 211+ 5A4D 3E 01        	LD A,1
 212+ 5A4F 32 4E 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 213+ 5A52 EB           	EX DE, HL
 214+ 5A53 F3           	DI
 215+ 5A54 CD 25 64     	CALL SETWRT_LOCAL
 216+ 5A57 FB           	EI
 217+ 5A58 EB           	EX DE, HL
 218+ 5A59 78           	LD A, B
 219+ 5A5A B7           	OR A
 220+ 5A5B 28 0D        	JR Z, .L3
 221+ 5A5D C5           	PUSH BC
 222+ 5A5E 0E 98        	LD C, #98
 223+ 5A60              .L2:
 224+ 5A60 50           	LD D, B
 225+ 5A61 06 00        	LD B, 0
 226+ 5A63 CD 32 64     	CALL BBYTECOPY_NO_C
 227+ 5A66 42           	LD B, D
 228+ 5A67 10 F7        	DJNZ .L2
 229+ 5A69 C1           	POP BC
 230+ 5A6A              .L3:
 231+ 5A6A 79           	LD A, C
 232+ 5A6B B7           	OR A
 233+ 5A6C 28 04        	JR Z,.L4
 234+ 5A6E 41           	LD B, C
 235+ 5A6F CD 30 64     	CALL BBYTECOPY
 236+ 5A72              .L4:
 237+ 5A72 AF           	XOR A
 238+ 5A73 32 4E 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 239+ 5A76 C9           	RET
 240+ 5A77              ; *******************************************************************************************************
 241+ 5A77
 242+ 5A77               IF (1 == 1)
 243+ 5A77              ; *******************************************************************************************************
 244+ 5A77              ; function to handle CALL VRMMEM basic extension
 245+ 5A77              ; copies from RAM to VRAM
 246+ 5A77              ; _VRMMEM ( INT source,
 247+ 5A77              ;			INT destination,
 248+ 5A77              ;			INT count
 249+ 5A77              ; will put ram in page 0 also, page 1 is already there
 250+ 5A77              VRMMEM:
 251+ 5A77              	; opening (
 252+ 5A77 CD 4D 65     	CALL CHKCHAR
 253+ 5A7A 28           	DB '('
 254+ 5A7B              	; get source address
 255+ 5A7B DD 21 2F 54  	LD IX, FRMQNT
 256+ 5A7F CD 59 01     	CALL CALBAS
 257+ 5A82 D5           	PUSH DE
 258+ 5A83              	; comma
 259+ 5A83 CD 4D 65     	CALL CHKCHAR
 260+ 5A86 2C           	DB ','
 261+ 5A87              	; get destination address
 262+ 5A87 DD 21 2F 54  	LD IX, FRMQNT
 263+ 5A8B CD 59 01     	CALL CALBAS
 264+ 5A8E D5           	PUSH DE
 265+ 5A8F              	; comma
 266+ 5A8F CD 4D 65     	CALL CHKCHAR
 267+ 5A92 2C           	DB ','
 268+ 5A93              	; get length
 269+ 5A93 DD 21 2F 54  	LD IX, FRMQNT
 270+ 5A97 CD 59 01     	CALL CALBAS
 271+ 5A9A D5           	PUSH DE
 272+ 5A9B              	; ending )
 273+ 5A9B CD 4D 65     	CALL CHKCHAR
 274+ 5A9E 29           	DB ')'
 275+ 5A9F
 276+ 5A9F                  ; save position in BASIC text
 277+ 5A9F E5           	PUSH HL
 278+ 5AA0 DD E1        	POP IX
 279+ 5AA2
 280+ 5AA2 C1           	POP BC ; count
 281+ 5AA3 D1           	POP DE ; destination
 282+ 5AA4 E1           	POP HL ; source
 283+ 5AA5 D9           	EXX
 284+ 5AA6 FD 21 AD 5A  	LD IY, .RET
 285+ 5AAA C3 FE 64     	JP ENABLE_PAGE0
 286+ 5AAD              .RET:
 287+ 5AAD FB           	EI
 288+ 5AAE D9           	EXX
 289+ 5AAF CD BB 5A     	CALL VRAM_LDIRMV
 290+ 5AB2 D1               POP DE
 291+ 5AB3 C1               POP BC
 292+ 5AB4 CD 75 64         CALL RESTORE_PAGE_INFO
 293+ 5AB7 DD E5        	PUSH IX
 294+ 5AB9 E1           	POP HL
 295+ 5ABA C9           	RET
 296+ 5ABB              ; *******************************************************************************************************
 297+ 5ABB               ENDIF
 298+ 5ABB
 299+ 5ABB               IF (0 == 1)
 300+ 5ABB ~            ; *******************************************************************************************************
 301+ 5ABB ~            ; same as VRMMEM but for DEFUSR approach
 302+ 5ABB ~            ; input IX=pointer to input array, real data from +2
 303+ 5ABB ~            ; +2 = source address
 304+ 5ABB ~            ; +4 = destination address
 305+ 5ABB ~            ; +6 = count
 306+ 5ABB ~            VRMMEM_DEFUSR:
 307+ 5ABB ~            	; enable page 0
 308+ 5ABB ~            	LD IY, .RET
 309+ 5ABB ~            	JP ENABLE_PAGE0
 310+ 5ABB ~            .RET:
 311+ 5ABB ~            	EI
 312+ 5ABB ~            	LD L,(IX+2)
 313+ 5ABB ~            	LD H,(IX+3)
 314+ 5ABB ~            	LD E,(IX+4)
 315+ 5ABB ~            	LD D,(IX+5)
 316+ 5ABB ~            	LD C,(IX+6)
 317+ 5ABB ~            	LD B,(IX+7)
 318+ 5ABB ~            	CALL VRAM_LDIRMV
 319+ 5ABB ~                POP DE
 320+ 5ABB ~                POP BC
 321+ 5ABB ~                JP RESTORE_PAGE_INFO
 322+ 5ABB ~            ; *******************************************************************************************************
 323+ 5ABB               ENDIF
 324+ 5ABB
 325+ 5ABB              ; *******************************************************************************************************
 326+ 5ABB              ; common code to copy from VRAM to RAM
 327+ 5ABB              ; input HL=VRAM source
 328+ 5ABB              ; input DE=RAM destination
 329+ 5ABB              ; BC=count
 330+ 5ABB              VRAM_LDIRMV:
 331+ 5ABB 3E 01        	LD A,1
 332+ 5ABD 32 4E 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 333+ 5AC0 7D           	LD	A, L
 334+ 5AC1 F3           	DI
 335+ 5AC2 D3 99        	OUT	(099H), A
 336+ 5AC4 7C           	LD	A, H
 337+ 5AC5 E6 3F        	AND	03FH
 338+ 5AC7 00           	NOP ; too fast VDP access per openMSX
 339+ 5AC8 D3 99        	OUT	(099H), A
 340+ 5ACA FB           	EI
 341+ 5ACB 00           	NOP
 342+ 5ACC 00           	NOP
 343+ 5ACD 00           	NOP ; too fast VDP access per openMSX
 344+ 5ACE              .L4:
 345+ 5ACE DB 98            IN A, (#98)
 346+ 5AD0 12           	LD (DE), A
 347+ 5AD1 13               INC DE
 348+ 5AD2 0B               DEC BC
 349+ 5AD3 79               LD A, C
 350+ 5AD4 B0               OR B
 351+ 5AD5 20 F7            JR NZ, .L4
 352+ 5AD7 AF           	XOR A
 353+ 5AD8 32 4E 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 354+ 5ADB C9               RET
 355+ 5ADC              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
 146  5ADC               ENDIF
 147  5ADC
 148  5ADC               IF (GENCAL_CMD == 1)
 149  5ADC               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
   1+ 5ADC               IF (0 == 1)
   2+ 5ADC ~            ; *******************************************************************************************************
   3+ 5ADC ~            ; same as GENCAL but for DEFUSR approach
   4+ 5ADC ~            ; input IX=pointer to input array, real data from +2
   5+ 5ADC ~            ; +2 = function address to call
   6+ 5ADC ~            ; +4 = register list array pointer
   7+ 5ADC ~            GENCAL_DEFUSR:
   8+ 5ADC ~                LD L,(IX+2)
   9+ 5ADC ~                LD H,(IX+3)
  10+ 5ADC ~                PUSH HL
  11+ 5ADC ~                LD L,(IX+4)
  12+ 5ADC ~                LD H,(IX+5)
  13+ 5ADC ~                PUSH HL
  14+ 5ADC ~                JR GENCAL.COMMON
  15+ 5ADC ~            ; *******************************************************************************************************
  16+ 5ADC               ENDIF
  17+ 5ADC
  18+ 5ADC              ; *******************************************************************************************************
  19+ 5ADC              ; function to handle CALL GENCAL basic extension
  20+ 5ADC              ; GENCAL ( INT fn_addr, = address of the function to call
  21+ 5ADC              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
  22+ 5ADC              ; output values of registers will also be stored at reg_list_ptr
  23+ 5ADC              GENCAL:
  24+ 5ADC               IF (1 == 1)
  25+ 5ADC              	; opening (
  26+ 5ADC CD 4D 65     	CALL CHKCHAR
  27+ 5ADF 28           	DB '('
  28+ 5AE0              	; get function address
  29+ 5AE0 DD 21 2F 54  	LD IX, FRMQNT
  30+ 5AE4 CD 59 01     	CALL CALBAS
  31+ 5AE7 D5           	PUSH DE
  32+ 5AE8              	; comma
  33+ 5AE8 CD 4D 65     	CALL CHKCHAR
  34+ 5AEB 2C           	DB ','
  35+ 5AEC              	; get pointer to register list
  36+ 5AEC 3E 02            LD A,2
  37+ 5AEE 06 01            LD B,1
  38+ 5AF0 11 00 05         LD DE,#0500
  39+ 5AF3 CD 7A 65         CALL GET_BASIC_ARRAY_DATA_POINTER
  40+ 5AF6 C5           	PUSH BC
  41+ 5AF7              	; ending )
  42+ 5AF7 CD 4D 65     	CALL CHKCHAR
  43+ 5AFA 29           	DB ')'
  44+ 5AFB               ENDIF
  45+ 5AFB              .COMMON:
  46+ 5AFB              	; save BASIC token position
  47+ 5AFB E5           	PUSH HL
  48+ 5AFC D9               EXX
  49+ 5AFD E1           	POP HL ; HL'=next basic token
  50+ 5AFE D9               EXX
  51+ 5AFF
  52+ 5AFF E1               POP HL ; get pointer to register values
  53+ 5B00 F3           	DI
  54+ 5B01 ED 73 3D 62      LD (BLIT_STRUCT), SP
  55+ 5B05 F9               LD SP, HL
  56+ 5B06 F1               POP AF
  57+ 5B07 C1               POP BC
  58+ 5B08 D1               POP DE
  59+ 5B09 E1               POP HL
  60+ 5B0A DD E1            POP IX
  61+ 5B0C FD E1            POP IY
  62+ 5B0E D9               EXX
  63+ 5B0F ED 73 3F 62      LD (BLIT_STRUCT+2), SP
  64+ 5B13 ED 7B 3D 62      LD SP, (BLIT_STRUCT)
  65+ 5B17 FB               EI
  66+ 5B18 D1               POP DE ; get function to call
  67+ 5B19 E5               PUSH HL
  68+ 5B1A CD 35 5B         CALL .EXXDECALL
  69+ 5B1D F3               DI
  70+ 5B1E ED 73 3D 62      LD (BLIT_STRUCT), SP
  71+ 5B22 ED 7B 3F 62      LD SP, (BLIT_STRUCT+2)
  72+ 5B26 FD E5            PUSH IY
  73+ 5B28 DD E5            PUSH IX
  74+ 5B2A E5               PUSH HL
  75+ 5B2B D5               PUSH DE
  76+ 5B2C C5               PUSH BC
  77+ 5B2D F5               PUSH AF
  78+ 5B2E ED 7B 3D 62      LD SP, (BLIT_STRUCT)
  79+ 5B32 FB               EI
  80+ 5B33 E1               POP HL
  81+ 5B34 C9           	RET
  82+ 5B35
  83+ 5B35              .EXXDECALL:
  84+ 5B35 D5               PUSH DE
  85+ 5B36 D9               EXX
  86+ 5B37 C9               RET
  87+ 5B38              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
 150  5B38               ENDIF
 151  5B38
 152  5B38               IF (BOX_CMDS == 1)
 153  5B38               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
   1+ 5B38              ; *******************************************************************************************************
   2+ 5B38              ; generic function to implement rectangle data copy
   3+ 5B38              ; should be modified to call appropriate function for memory or vram
   4+ 5B38              ; input IX=pointer to following structure
   5+ 5B38              ; +00 source data pointer
   6+ 5B38              ; +02 num bytes in a row
   7+ 5B38              ; +04 number of rows
   8+ 5B38              ; +06 source add-to value till next row
   9+ 5B38              ; +08 destination address
  10+ 5B38              ; +10 destination add-to value till next row
  11+ 5B38              ; modifies AF, BC, DE, HL
  12+ 5B38              RECTANGLE_COPY:
  13+ 5B38 DD 6E 00     	LD L, (IX+0)
  14+ 5B3B DD 66 01     	LD H, (IX+1) ; source address
  15+ 5B3E DD 5E 08     	LD E, (IX+8)
  16+ 5B41 DD 56 09     	LD D, (IX+9) ; destination
  17+ 5B44 DD 46 04     	LD B, (IX+4) ; row number
  18+ 5B47              .L1:
  19+ 5B47 C5           	PUSH BC
  20+ 5B48 E5           		PUSH HL
  21+ 5B49 D5           			PUSH DE
  22+ 5B4A DD 4E 02     				LD C, (IX+2)
  23+ 5B4D DD 46 03     				LD B, (IX+3) ; num bytes in a row
  24+ 5B50              .CALL1:
  25+ 5B50 CD 00 00     				CALL 0 ; set destination address from DE
  26+ 5B53              .CALL2:
  27+ 5B53 CD 00 00     				CALL 0 ; copy data fn
  28+ 5B56 E1           			POP HL
  29+ 5B57 DD 4E 0A     			LD C, (IX+10)
  30+ 5B5A DD 46 0B     			LD B, (IX+11) ; destination add-to
  31+ 5B5D 09           			ADD HL, BC
  32+ 5B5E EB           			EX DE, HL
  33+ 5B5F E1           		POP HL
  34+ 5B60 DD 4E 06     		LD C, (IX+6)
  35+ 5B63 DD 46 07     		LD B, (IX+7) ; src add-to
  36+ 5B66 09           		ADD HL, BC
  37+ 5B67 C1           	POP BC
  38+ 5B68 10 DD        	DJNZ .L1
  39+ 5B6A C9           	RET
  40+ 5B6B              ; *******************************************************************************************************
  41+ 5B6B
  42+ 5B6B               IF (1 == 1)
  43+ 5B6B              ; *******************************************************************************************************
  44+ 5B6B              ; function to handle CALL BOXMEMCPY basic extension
  45+ 5B6B              ; copies data with window like boundaries within ram
  46+ 5B6B              ; BOXMEMCPY ( INT source data pointer,
  47+ 5B6B              ;			  INT source number of bytes in a row,
  48+ 5B6B              ;			  INT number of rows,
  49+ 5B6B              ;			  INT source add-to value till next row,
  50+ 5B6B              ; 			  INT destination pointer,
  51+ 5B6B              ;			  INT destination add-to value till next row )
  52+ 5B6B              ; request_data_ptr described in RECTANGLE_COPY
  53+ 5B6B              ; will put ram in page 0 also, page 1 is already there
  54+ 5B6B              BOXMEMCPY:
  55+ 5B6B 11 75 5B     	LD DE,BOXMEMCPY_COMMON
  56+ 5B6E ED 53 ED 5B  	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
  57+ 5B72 C3 88 5B     	JP BOX_EXTENSION_PARAMS_COMMON
  58+ 5B75               ENDIF
  59+ 5B75
  60+ 5B75               IF (0 == 1)
  61+ 5B75 ~            ; *******************************************************************************************************
  62+ 5B75 ~            ; same as BOXMEMCPY but for DEFUSR approach
  63+ 5B75 ~            ; input IX=pointer to input array, real data from +2
  64+ 5B75 ~            ; +02 = source data pointer
  65+ 5B75 ~            ; +04 = source number of bytes in a row
  66+ 5B75 ~            ; +06 = number of rows
  67+ 5B75 ~            ; +08 = source add-to value till next row
  68+ 5B75 ~            ; +10 = destination pointer
  69+ 5B75 ~            ; +12 = destination add-to value till next row
  70+ 5B75 ~            BOXMEMCPY_DEFUSR:
  71+ 5B75 ~            	LD HL,BOXMEMCPY_COMMON
  72+ 5B75 ~            	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
  73+ 5B75 ~            	INC IX
  74+ 5B75 ~            	INC IX
  75+ 5B75 ~            	JP BOXCOMMON_DEFUSR
  76+ 5B75               ENDIF
  77+ 5B75
  78+ 5B75              BOXMEMCPY_COMMON:
  79+ 5B75 FB           	EI
  80+ 5B76              	; set RAM functions to call
  81+ 5B76 21 00 00     	LD HL, 0
  82+ 5B79 22 50 5B     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
  83+ 5B7C 22 52 5B     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
  84+ 5B7F 21 ED B0     	LD HL, #B0ED ; LDIR
  85+ 5B82 22 54 5B     	LD (RECTANGLE_COPY.CALL1+4), HL
  86+ 5B85 C3 F2 5B     	JP BOXCOMMON_DEFUSR.CALL
  87+ 5B88              ; *******************************************************************************************************
  88+ 5B88
  89+ 5B88               IF (1 == 1)
  90+ 5B88              ; *******************************************************************************************************
  91+ 5B88              ; common parts of BOX commands to load parameters
  92+ 5B88              BOX_EXTENSION_PARAMS_COMMON:
  93+ 5B88              	; opening (
  94+ 5B88 CD 4D 65     	CALL CHKCHAR
  95+ 5B8B 28           	DB '('
  96+ 5B8C              	; get source data pointer
  97+ 5B8C DD 21 2F 54  	LD IX, FRMQNT
  98+ 5B90 CD 59 01     	CALL CALBAS
  99+ 5B93 ED 53 3D 62  	LD (BLIT_STRUCT+0), DE
 100+ 5B97              	; comma
 101+ 5B97 CD 4D 65     	CALL CHKCHAR
 102+ 5B9A 2C           	DB ','
 103+ 5B9B              	; source number of bytes in a row
 104+ 5B9B DD 21 2F 54  	LD IX, FRMQNT
 105+ 5B9F CD 59 01     	CALL CALBAS
 106+ 5BA2 ED 53 3F 62  	LD (BLIT_STRUCT+2), DE
 107+ 5BA6              	; comma
 108+ 5BA6 CD 4D 65     	CALL CHKCHAR
 109+ 5BA9 2C           	DB ','
 110+ 5BAA              	; number of rows
 111+ 5BAA DD 21 2F 54  	LD IX, FRMQNT
 112+ 5BAE CD 59 01     	CALL CALBAS
 113+ 5BB1 ED 53 41 62  	LD (BLIT_STRUCT+4), DE
 114+ 5BB5              	; comma
 115+ 5BB5 CD 4D 65     	CALL CHKCHAR
 116+ 5BB8 2C           	DB ','
 117+ 5BB9              	; source add-to value till next row
 118+ 5BB9 DD 21 2F 54  	LD IX, FRMQNT
 119+ 5BBD CD 59 01     	CALL CALBAS
 120+ 5BC0 ED 53 43 62  	LD (BLIT_STRUCT+6), DE
 121+ 5BC4              	; comma
 122+ 5BC4 CD 4D 65     	CALL CHKCHAR
 123+ 5BC7 2C           	DB ','
 124+ 5BC8              	; destination pointer
 125+ 5BC8 DD 21 2F 54  	LD IX, FRMQNT
 126+ 5BCC CD 59 01     	CALL CALBAS
 127+ 5BCF ED 53 45 62  	LD (BLIT_STRUCT+8), DE
 128+ 5BD3              	; comma
 129+ 5BD3 CD 4D 65     	CALL CHKCHAR
 130+ 5BD6 2C           	DB ','
 131+ 5BD7              	; destination add-to value till next row
 132+ 5BD7 DD 21 2F 54  	LD IX, FRMQNT
 133+ 5BDB CD 59 01     	CALL CALBAS
 134+ 5BDE ED 53 47 62  	LD (BLIT_STRUCT+10), DE
 135+ 5BE2              	; ending )
 136+ 5BE2 CD 4D 65     	CALL CHKCHAR
 137+ 5BE5 29           	DB ')'
 138+ 5BE6 DD 21 3D 62  	LD IX,BLIT_STRUCT
 139+ 5BEA               ENDIF
 140+ 5BEA              BOXCOMMON_DEFUSR:
 141+ 5BEA E5           	PUSH HL ; save position in BASIC buffer
 142+ 5BEB              .ADDR:
 143+ 5BEB FD 21 00 00  	LD IY, 0 ; modified by code
 144+ 5BEF C3 FE 64     	JP ENABLE_PAGE0
 145+ 5BF2              .CALL:
 146+ 5BF2 CD 38 5B     	CALL RECTANGLE_COPY
 147+ 5BF5 AF           	XOR A
 148+ 5BF6 32 4E 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 149+ 5BF9
 150+ 5BF9 D1               POP DE
 151+ 5BFA C1               POP BC
 152+ 5BFB CD 75 64         CALL RESTORE_PAGE_INFO
 153+ 5BFE
 154+ 5BFE E1           	POP HL
 155+ 5BFF C9           	RET
 156+ 5C00              ; *******************************************************************************************************
 157+ 5C00
 158+ 5C00               IF (1 == 1)
 159+ 5C00              ; *******************************************************************************************************
 160+ 5C00              ; function to handle CALL BOXMEMVRM basic extension
 161+ 5C00              ; copies data with window like boundaries from ram to Vram
 162+ 5C00              ; BOXMEMVRM ( INT source data pointer,
 163+ 5C00              ;			  INT source number of bytes in a row,
 164+ 5C00              ;			  INT number of rows,
 165+ 5C00              ;			  INT source add-to value till next row,
 166+ 5C00              ; 			  INT destination pointer,
 167+ 5C00              ;			  INT destination add-to value till next row )
 168+ 5C00              ; request_data_ptr described in RECTANGLE_COPY
 169+ 5C00              ; will put ram in page 0 also, page 1 is already there
 170+ 5C00              BOXMEMVRM:
 171+ 5C00 11 0A 5C     	LD DE,BOXMEMVRM_COMMON
 172+ 5C03 ED 53 ED 5B  	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
 173+ 5C07 C3 88 5B     	JP BOX_EXTENSION_PARAMS_COMMON
 174+ 5C0A               ENDIF
 175+ 5C0A
 176+ 5C0A               IF (0 == 1)
 177+ 5C0A ~            ; *******************************************************************************************************
 178+ 5C0A ~            ; same as BOXMEMVRM but for DEFUSR approach
 179+ 5C0A ~            ; input IX=pointer to input array, real data from +2
 180+ 5C0A ~            ; +02 = source data pointer
 181+ 5C0A ~            ; +04 = source number of bytes in a row
 182+ 5C0A ~            ; +06 = number of rows
 183+ 5C0A ~            ; +08 = source add-to value till next row
 184+ 5C0A ~            ; +10 = destination pointer
 185+ 5C0A ~            ; +12 = destination add-to value till next row
 186+ 5C0A ~            BOXMEMVRM_DEFUSR:
 187+ 5C0A ~            	LD HL,BOXMEMVRM_COMMON
 188+ 5C0A ~            	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
 189+ 5C0A ~            	INC IX
 190+ 5C0A ~            	INC IX
 191+ 5C0A ~            	JP BOXCOMMON_DEFUSR
 192+ 5C0A               ENDIF
 193+ 5C0A
 194+ 5C0A              BOXMEMVRM_COMMON:
 195+ 5C0A FB           	EI
 196+ 5C0B              	; set RAM functions to call
 197+ 5C0B 21 25 5C     	LD HL, .SETDEST
 198+ 5C0E 22 51 5B     	LD (RECTANGLE_COPY.CALL1+1), HL
 199+ 5C11 21 2D 5C     	LD HL, .COPYDATA
 200+ 5C14 22 54 5B     	LD (RECTANGLE_COPY.CALL2+1), HL
 201+ 5C17 3E CD        	LD A, #CD ; CALL
 202+ 5C19 32 50 5B     	LD (RECTANGLE_COPY.CALL1), A
 203+ 5C1C 32 53 5B     	LD (RECTANGLE_COPY.CALL2), A
 204+ 5C1F              	;LD A,1
 205+ 5C1F 32 4E 62     	LD (VRAM_UPDATE_IN_PROGRESS),A
 206+ 5C22 C3 F2 5B     	JP BOXCOMMON_DEFUSR.CALL
 207+ 5C25              .SETDEST:
 208+ 5C25 EB           	EX DE, HL
 209+ 5C26 F3           	DI
 210+ 5C27 CD 25 64     	CALL SETWRT_LOCAL
 211+ 5C2A FB           	EI
 212+ 5C2B EB           	EX DE, HL
 213+ 5C2C C9           	RET
 214+ 5C2D              .COPYDATA:
 215+ 5C2D 41           	LD B, C
 216+ 5C2E C3 30 64     	JP BBYTECOPY
 217+ 5C31              ; *******************************************************************************************************
# file closed: asm\BOX.asm
 154  5C31               ENDIF
 155  5C31
 156  5C31               IF (BLIT_CMDS == 1)
 157  5C31               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
   1+ 5C31              ; *******************************************************************************************************
   2+ 5C31              ; function rotates mask and data of several characters and applies to background data
   3+ 5C31              ; this handles x-shift from 0 to 4
   4+ 5C31              ; contains self-modifying code that is set-up from external function
   5+ 5C31              ; input HL=pointer to mask data
   6+ 5C31              ; input HL'=pointer to character data
   7+ 5C31              ; input DE=output buffer containing background data
   8+ 5C31              ; input BC=DE+8
   9+ 5C31              ; input A=number of characters to process
  10+ 5C31              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  11+ 5C31              SHIFT04:
  12+ 5C31 08           	EX AF, AF'
  13+ 5C32 7E           	LD A, (HL) ; get mask
  14+ 5C33 D9           	EXX
  15+ 5C34 57           	LD D, A
  16+ 5C35 1E FF        	LD E, #FF
  17+ 5C37 37           	SCF
  18+ 5C38              .M1:
  19+ 5C38 18 FE        	JR .M1 ; this is self-modifying part
  20+ 5C3A CB 1A        	RR D
  21+ 5C3C CB 1B        	RR E
  22+ 5C3E CB 1A        	RR D
  23+ 5C40 CB 1B        	RR E
  24+ 5C42 CB 1A        	RR D
  25+ 5C44 CB 1B        	RR E
  26+ 5C46 CB 1A        	RR D
  27+ 5C48 CB 1B        	RR E
  28+ 5C4A
  29+ 5C4A 46           	LD B, (HL) ; get data
  30+ 5C4B 0E 00        	LD C, 0
  31+ 5C4D              .M2:
  32+ 5C4D 18 FE        	JR .M2 ; also self-modifying part
  33+ 5C4F CB 38        	SRL B
  34+ 5C51 CB 19        	RR C
  35+ 5C53 CB 38        	SRL B
  36+ 5C55 CB 19        	RR C
  37+ 5C57 CB 38        	SRL B
  38+ 5C59 CB 19        	RR C
  39+ 5C5B CB 38        	SRL B
  40+ 5C5D CB 19        	RR C
  41+ 5C5F
  42+ 5C5F D9           	EXX
  43+ 5C60 1A           	LD A, (DE) ; background
  44+ 5C61 D9           	EXX
  45+ 5C62 A2           	AND D
  46+ 5C63 B0           	OR B
  47+ 5C64 D9           	EXX
  48+ 5C65 12           	LD (DE), A
  49+ 5C66
  50+ 5C66 0A           	LD A, (BC)
  51+ 5C67 D9           	EXX
  52+ 5C68 A3           	AND E
  53+ 5C69 B1           	OR C
  54+ 5C6A 23           	INC HL
  55+ 5C6B D9           	EXX
  56+ 5C6C 02           	LD (BC), A
  57+ 5C6D
  58+ 5C6D 23           	INC HL
  59+ 5C6E 13           	INC DE
  60+ 5C6F 03           	INC BC
  61+ 5C70
  62+ 5C70 08           	EX AF, AF'
  63+ 5C71 3D           	DEC A
  64+ 5C72 C2 31 5C     	JP NZ, SHIFT04
  65+ 5C75 C9           	RET
  66+ 5C76              ; *******************************************************************************************************
  67+ 5C76
  68+ 5C76              ; *******************************************************************************************************
  69+ 5C76              ; function rotates mask and data of several characters and applies to background data
  70+ 5C76              ; this handles x-shift from 5 to 8
  71+ 5C76              ; contains self-modifying code that is set-up from external function
  72+ 5C76              ; input HL=pointer to mask data
  73+ 5C76              ; input HL'=pointer to character data
  74+ 5C76              ; input DE=output buffer containing background data
  75+ 5C76              ; input BC=DE+8
  76+ 5C76              ; input A=number of characters to process
  77+ 5C76              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  78+ 5C76              SHIFT58:
  79+ 5C76 08           	EX AF, AF'
  80+ 5C77 7E           	LD A, (HL) ; get mask
  81+ 5C78 D9           	EXX
  82+ 5C79 57           	LD D, A
  83+ 5C7A 1E FF        	LD E, #FF
  84+ 5C7C 37           	SCF
  85+ 5C7D              .M1:
  86+ 5C7D 18 FE        	JR .M1 ; this is self-modifying part
  87+ 5C7F CB 12        	RL D
  88+ 5C81 CB 13        	RL E
  89+ 5C83 CB 12        	RL D
  90+ 5C85 CB 13        	RL E
  91+ 5C87 CB 12        	RL D
  92+ 5C89 CB 13        	RL E
  93+ 5C8B
  94+ 5C8B 46           	LD B, (HL)
  95+ 5C8C 0E 00        	LD C, 0
  96+ 5C8E              .M2:
  97+ 5C8E 18 FE        	JR .M2 ; also self-modifying part
  98+ 5C90 CB 20        	SLA B
  99+ 5C92 CB 11        	RL C
 100+ 5C94 CB 20        	SLA B
 101+ 5C96 CB 11        	RL C
 102+ 5C98 CB 20        	SLA B
 103+ 5C9A CB 11        	RL C
 104+ 5C9C
 105+ 5C9C D9           	EXX
 106+ 5C9D 1A           	LD A, (DE) ; background
 107+ 5C9E D9           	EXX
 108+ 5C9F A3           	AND E
 109+ 5CA0 B1           	OR C
 110+ 5CA1 D9           	EXX
 111+ 5CA2 12           	LD (DE), A
 112+ 5CA3
 113+ 5CA3 0A           	LD A, (BC)
 114+ 5CA4 D9           	EXX
 115+ 5CA5 A2           	AND D
 116+ 5CA6 B0           	OR B
 117+ 5CA7 23           	INC HL
 118+ 5CA8 D9           	EXX
 119+ 5CA9 02           	LD (BC), A
 120+ 5CAA
 121+ 5CAA 23           	INC HL
 122+ 5CAB 13           	INC DE
 123+ 5CAC 03           	INC BC
 124+ 5CAD
 125+ 5CAD 08           	EX AF, AF'
 126+ 5CAE 3D           	DEC A
 127+ 5CAF C2 76 5C     	JP NZ, SHIFT58
 128+ 5CB2 C9           	RET
 129+ 5CB3              ; *******************************************************************************************************
 130+ 5CB3
 131+ 5CB3              ; *******************************************************************************************************
 132+ 5CB3              ; routine that shifts one row of characters
 133+ 5CB3              ; contains self-modifying code that is set-up from external function
 134+ 5CB3              ; input HL=pointer to mask data
 135+ 5CB3              ; input HL'=pointer to character data
 136+ 5CB3              ; input DE=output buffer containing background data
 137+ 5CB3              ; input A=number of characters to process
 138+ 5CB3              ; input IX=pointer to structure describing input data
 139+ 5CB3              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 140+ 5CB3              SHIFT_ROW:
 141+ 5CB3 F5           	PUSH AF
 142+ 5CB4 ED 53 39 62  		LD (BLIT_TMP1), DE
 143+ 5CB8 E5           		PUSH HL
 144+ 5CB9 CD FC 5C     			CALL .ADDYSHIFT
 145+ 5CBC E1           		POP HL
 146+ 5CBD ED 53 3B 62  		LD (BLIT_TMP2), DE ; DE+vertical shift
 147+ 5CC1              .L1:
 148+ 5CC1 3E 08        		LD A, 8
 149+ 5CC3 DD 96 02     		SUB (IX+2) ; y shift
 150+ 5CC6              .CALL1:
 151+ 5CC6 CD 00 00     		CALL 0
 152+ 5CC9 DD 7E 02     		LD A, (IX+2); y shift
 153+ 5CCC B7           		OR A
 154+ 5CCD 28 26        		JR Z, .DONE
 155+ 5CCF ED 5B 39 62  		LD DE, (BLIT_TMP1)
 156+ 5CD3 E5           		PUSH HL
 157+ 5CD4 CD 0A 5D     			CALL .DETONEXTROW
 158+ 5CD7 E1           		POP HL
 159+ 5CD8              .CALL2:
 160+ 5CD8 CD 00 00     		CALL 0
 161+ 5CDB ED 5B 39 62  		LD DE, (BLIT_TMP1)
 162+ 5CDF E5           		PUSH HL
 163+ 5CE0 CD 04 5D     			CALL .ADD8
 164+ 5CE3 E1           		POP HL
 165+ 5CE4 ED 53 39 62  		LD (BLIT_TMP1), DE
 166+ 5CE8 ED 5B 3B 62  		LD DE, (BLIT_TMP2)
 167+ 5CEC E5           		PUSH HL
 168+ 5CED CD 04 5D     			CALL .ADD8
 169+ 5CF0 E1           		POP HL
 170+ 5CF1 ED 53 3B 62  		LD (BLIT_TMP2), DE ; DE+vertical shift
 171+ 5CF5              .DONE:
 172+ 5CF5 F1           	POP AF
 173+ 5CF6 3D           	DEC A
 174+ 5CF7 C8           	RET Z
 175+ 5CF8 F5           	PUSH AF
 176+ 5CF9 C3 C1 5C     	JP .L1
 177+ 5CFC              .ADDYSHIFT:
 178+ 5CFC EB           	EX DE, HL
 179+ 5CFD 16 00        	LD D, 0
 180+ 5CFF DD 5E 02     	LD E, (IX+2); y shift
 181+ 5D02 18 0C        	JR .MOVDEBC
 182+ 5D04              .ADD8:
 183+ 5D04 21 08 00     	LD HL, 8
 184+ 5D07 C3 10 5D     	JP .MOVDEBC
 185+ 5D0A              .DETONEXTROW:
 186+ 5D0A DD 6E 06     	LD L, (IX+6)
 187+ 5D0D DD 66 07     	LD H, (IX+7) ; bkg add to value
 188+ 5D10              .MOVDEBC:
 189+ 5D10 19           	ADD HL, DE
 190+ 5D11 54           	LD D, H
 191+ 5D12 5D           	LD E, L
 192+ 5D13 01 08 00     	LD BC, 8
 193+ 5D16 09           	ADD HL, BC
 194+ 5D17 44           	LD B, H
 195+ 5D18 4D           	LD C, L
 196+ 5D19 C9           	RET
 197+ 5D1A              ; *******************************************************************************************************
 198+ 5D1A
 199+ 5D1A              ; *******************************************************************************************************
 200+ 5D1A              ; function rotates mask and character data and applies it to background
 201+ 5D1A              ; input IX=pointer to structure describing input data
 202+ 5D1A              ; +0  DW horizontal shift count 0-7 (low byte used)
 203+ 5D1A              ; +2  DW vertical shift count 0-7 (low byte used)
 204+ 5D1A              ; +4  DW background data start;
 205+ 5D1A              ; +6  DW background add to value to next row of background data
 206+ 5D1A              ; +8  DW mask data start;
 207+ 5D1A              ; +10  DW character data start;
 208+ 5D1A              ; +12 DW character&mask add to value to next row of data
 209+ 5D1A              ; +14 DW columns (low byte used)
 210+ 5D1A              ; +16 DW rows (low byte used)
 211+ 5D1A              SHIFT_MERGE_CHARACTER:
 212+ 5D1A DD 7E 00     	LD A, (IX) ; shift
 213+ 5D1D FE 05        	CP 5
 214+ 5D1F 38 25        	JR C, .RIGHT
 215+ 5D21              	; shifts 5-7, use rotate towards left 1-3
 216+ 5D21 21 76 5C     	LD HL, SHIFT58
 217+ 5D24 22 C7 5C     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 218+ 5D27 22 D9 5C     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 219+ 5D2A D6 05        	SUB 5
 220+ 5D2C 28 0D        	JR Z, .L1
 221+ 5D2E 87           	ADD A, A
 222+ 5D2F 87           	ADD A, A
 223+ 5D30 67           	LD H, A
 224+ 5D31 2E 18        	LD L, #18 ; JR opcode
 225+ 5D33 22 7D 5C     	LD (SHIFT58.M1), HL
 226+ 5D36 22 8E 5C     	LD (SHIFT58.M2), HL
 227+ 5D39 18 32        	JR .DO
 228+ 5D3B              .L1:
 229+ 5D3B 21 00 00     	LD HL, 0 ; 2xNOP opcode
 230+ 5D3E 22 7D 5C     	LD (SHIFT58.M1), HL
 231+ 5D41 22 8E 5C     	LD (SHIFT58.M2), HL
 232+ 5D44 18 27        	JR .DO
 233+ 5D46              .RIGHT:
 234+ 5D46              	; shifts 0-4, rotate towards right
 235+ 5D46 21 31 5C     	LD HL, SHIFT04
 236+ 5D49 22 C7 5C     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 237+ 5D4C 22 D9 5C     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 238+ 5D4F FE 04        	CP 4
 239+ 5D51 28 11        	JR Z, .R1
 240+ 5D53 D6 04        	SUB 4
 241+ 5D55 ED 44        	NEG
 242+ 5D57 87           	ADD A, A
 243+ 5D58 87           	ADD A, A
 244+ 5D59 67           	LD H, A
 245+ 5D5A 2E 18        	LD L, #18 ; JR opcode
 246+ 5D5C 22 38 5C     	LD (SHIFT04.M1), HL
 247+ 5D5F 22 4D 5C     	LD (SHIFT04.M2), HL
 248+ 5D62 18 09        	JR .DO
 249+ 5D64              .R1:
 250+ 5D64 21 00 00     	LD HL, 0 ; 2xNOP opcode
 251+ 5D67 22 38 5C     	LD (SHIFT04.M1), HL
 252+ 5D6A 22 4D 5C     	LD (SHIFT04.M2), HL
 253+ 5D6D              .DO:
 254+ 5D6D DD 46 10     	LD B, (IX+16) ; rows
 255+ 5D70 DD 6E 08     	LD L, (IX+8)
 256+ 5D73 DD 66 09     	LD H, (IX+9) ; mask data
 257+ 5D76 DD 5E 04     	LD E, (IX+4)
 258+ 5D79 DD 56 05     	LD D, (IX+5) ; background data
 259+ 5D7C D9           	EXX
 260+ 5D7D DD 6E 0A     	LD L, (IX+10)
 261+ 5D80 DD 66 0B     	LD H, (IX+11) ; character data
 262+ 5D83 D9           	EXX
 263+ 5D84              .LOOP:
 264+ 5D84 C5           	PUSH BC
 265+ 5D85 E5           		PUSH HL
 266+ 5D86 D5           			PUSH DE
 267+ 5D87 D9           				EXX
 268+ 5D88 E5           				PUSH HL
 269+ 5D89 D9           					EXX
 270+ 5D8A DD 7E 0E     					LD A, (IX+14) ; columns
 271+ 5D8D              .CALL:
 272+ 5D8D CD B3 5C     					CALL SHIFT_ROW
 273+ 5D90 E1           				POP HL
 274+ 5D91 DD 5E 0C     				LD E, (IX+12)
 275+ 5D94 DD 56 0D     				LD D, (IX+13) ; char data to next row
 276+ 5D97 19           				ADD HL, DE
 277+ 5D98 D9           				EXX
 278+ 5D99 E1           			POP HL
 279+ 5D9A DD 5E 06     			LD E, (IX+6)
 280+ 5D9D DD 56 07     			LD D, (IX+7) ; background to next row
 281+ 5DA0 19           			ADD HL, DE
 282+ 5DA1 EB           			EX DE, HL
 283+ 5DA2 E1           		POP HL
 284+ 5DA3 DD 4E 0C     		LD C, (IX+12)
 285+ 5DA6 DD 46 0D     		LD B, (IX+13) ; char data to next row
 286+ 5DA9 09           		ADD HL, BC
 287+ 5DAA C1           	POP BC
 288+ 5DAB 10 D7        	DJNZ .LOOP
 289+ 5DAD C9           	RET
 290+ 5DAE              ; *******************************************************************************************************
 291+ 5DAE
 292+ 5DAE              ; *******************************************************************************************************
 293+ 5DAE              ; helper function DE \ 8
 294+ 5DAE              DEdiv8:
 295+ 5DAE 7B           	LD A,E
 296+ 5DAF CB 2A        	SRA D
 297+ 5DB1 CB 1F            RR  A
 298+ 5DB3 CB 2A            SRA D
 299+ 5DB5 CB 1F            RR  A
 300+ 5DB7 CB 2A            SRA D
 301+ 5DB9 CB 1F            RR  A
 302+ 5DBB C9           	RET
 303+ 5DBC              ; *******************************************************************************************************
 304+ 5DBC
 305+ 5DBC               IF (0 == 1)
 306+ 5DBC ~            ; *******************************************************************************************************
 307+ 5DBC ~            ; function to handle BLIT basic extension through DEFUSR call in RAW format
 308+ 5DBC ~            ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 309+ 5DBC ~            ; +2  DW horizontal shift count 0-7 (low byte used)
 310+ 5DBC ~            ; +4  DW vertical shift count 0-7 (low byte used)
 311+ 5DBC ~            ; +6  DW background data start;
 312+ 5DBC ~            ; +8  DW background add to value to next row of background data
 313+ 5DBC ~            ; +10  DW mask data start;
 314+ 5DBC ~            ; +12  DW character data start;
 315+ 5DBC ~            ; +14 DW character&mask add to value to next row of data
 316+ 5DBC ~            ; +16 DW columns (low byte used)
 317+ 5DBC ~            ; +18 DW rows (low byte used)
 318+ 5DBC ~            ; will put ram in page 0 also, page 1 is already there
 319+ 5DBC ~            ;BLIT_DEFUSR:
 320+ 5DBC ~            ;	DI
 321+ 5DBC ~            ;	LD IY, .RET
 322+ 5DBC ~            ;	JP ENABLE_PAGE0
 323+ 5DBC ~            ;.RET:
 324+ 5DBC ~            ;	EI
 325+ 5DBC ~            ;	INC IX
 326+ 5DBC ~            ;	INC IX
 327+ 5DBC ~            ;	CALL SHIFT_MERGE_CHARACTER
 328+ 5DBC ~            ;
 329+ 5DBC ~            ;   POP DE
 330+ 5DBC ~            ;    POP BC
 331+ 5DBC ~            ;    JP RESTORE_PAGE_INFO
 332+ 5DBC ~            ; *******************************************************************************************************
 333+ 5DBC ~
 334+ 5DBC ~            ; *******************************************************************************************************
 335+ 5DBC ~            ; function to handle CALL BLIT basic extension in DEFUSR form
 336+ 5DBC ~            ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 337+ 5DBC ~            ; +02 x
 338+ 5DBC ~            ; +04 y
 339+ 5DBC ~            ; +06 char_data_pointer
 340+ 5DBC ~            ; +08 mask_data_pointer
 341+ 5DBC ~            ; +10 width
 342+ 5DBC ~            ; +12 height
 343+ 5DBC ~            ; +14 background_pointer
 344+ 5DBC ~            ; +16 background_width
 345+ 5DBC ~            ; BLIT ( INT x,
 346+ 5DBC ~            ;		 INT y,
 347+ 5DBC ~            ;		 INT char_data_pointer,
 348+ 5DBC ~            ;		 INT mask_data_pointer,
 349+ 5DBC ~            ;		 INT width (in characters),
 350+ 5DBC ~            ;		 INT height (in characters),
 351+ 5DBC ~            ;		 INT background_pointer (top left),
 352+ 5DBC ~            ;		 INT background_width (in characters),
 353+ 5DBC ~            BLIT_DEFUSR:
 354+ 5DBC ~            	LD E,(IX+2)
 355+ 5DBC ~            	LD D,(IX+3)
 356+ 5DBC ~            	LD A,E
 357+ 5DBC ~            	AND 7
 358+ 5DBC ~            	LD (BLIT_STRUCT+0),A
 359+ 5DBC ~            	CALL DEdiv8
 360+ 5DBC ~            	LD (BLIT_TMP+0),A
 361+ 5DBC ~            	LD E,(IX+4)
 362+ 5DBC ~            	LD D,(IX+5)
 363+ 5DBC ~            	LD A,E
 364+ 5DBC ~            	AND 7
 365+ 5DBC ~            	LD (BLIT_STRUCT+2),A
 366+ 5DBC ~            	CALL DEdiv8
 367+ 5DBC ~            	LD (BLIT_TMP+1),A
 368+ 5DBC ~            	LD L,(IX+6)
 369+ 5DBC ~            	LD H,(IX+7)
 370+ 5DBC ~            	LD (BLIT_STRUCT+10),HL
 371+ 5DBC ~            	LD L,(IX+8)
 372+ 5DBC ~            	LD H,(IX+9)
 373+ 5DBC ~            	LD (BLIT_STRUCT+8),HL
 374+ 5DBC ~            	LD A,(IX+10)
 375+ 5DBC ~            	LD (BLIT_STRUCT+14),A
 376+ 5DBC ~            	LD A,(IX+12)
 377+ 5DBC ~            	LD (BLIT_STRUCT+16),A
 378+ 5DBC ~            	LD L,(IX+14)
 379+ 5DBC ~            	LD H,(IX+15)
 380+ 5DBC ~            	LD (BLIT_STRUCT+4),HL
 381+ 5DBC ~            	;LD A,(IX+16)
 382+ 5DBC ~            	;LD (BLIT_TMP+2),A
 383+ 5DBC ~
 384+ 5DBC ~            	; calculate char&mask add to value
 385+ 5DBC ~            	LD H,0
 386+ 5DBC ~            	LD A,(BLIT_STRUCT+14)
 387+ 5DBC ~            	LD L,A
 388+ 5DBC ~            	CALL HLx8
 389+ 5DBC ~            	LD (BLIT_STRUCT+12),HL
 390+ 5DBC ~            	; calculate background add to value
 391+ 5DBC ~            	LD H,0
 392+ 5DBC ~            	LD L,(IX+16)
 393+ 5DBC ~            	CALL HLx8
 394+ 5DBC ~            	LD (BLIT_STRUCT+6),HL
 395+ 5DBC ~            	; calculate pointer to background location
 396+ 5DBC ~            	LD HL,0
 397+ 5DBC ~            	LD A,(BLIT_TMP+1)
 398+ 5DBC ~            	OR A
 399+ 5DBC ~            	JR Z, .L1
 400+ 5DBC ~            	LD B,A
 401+ 5DBC ~            	LD DE,(BLIT_STRUCT+6)
 402+ 5DBC ~            .L0:
 403+ 5DBC ~            	ADD HL, DE
 404+ 5DBC ~            	DJNZ .L0
 405+ 5DBC ~            .L1:
 406+ 5DBC ~            	EX DE,HL
 407+ 5DBC ~            	LD H,0
 408+ 5DBC ~            	LD A,(BLIT_TMP+0)
 409+ 5DBC ~            	LD L,A
 410+ 5DBC ~            	CALL HLx8
 411+ 5DBC ~            	ADD HL,DE
 412+ 5DBC ~            	LD DE,(BLIT_STRUCT+4)
 413+ 5DBC ~            	ADD HL,DE
 414+ 5DBC ~            	LD (BLIT_STRUCT+4),HL
 415+ 5DBC ~
 416+ 5DBC ~            	LD IY, .RET
 417+ 5DBC ~            	JP ENABLE_PAGE0
 418+ 5DBC ~            .RET:
 419+ 5DBC ~            	EI
 420+ 5DBC ~            	LD IX, BLIT_STRUCT
 421+ 5DBC ~            	CALL SHIFT_MERGE_CHARACTER
 422+ 5DBC ~
 423+ 5DBC ~                POP DE
 424+ 5DBC ~                POP BC
 425+ 5DBC ~                JP RESTORE_PAGE_INFO
 426+ 5DBC ~            ; *******************************************************************************************************
 427+ 5DBC               ENDIF
 428+ 5DBC
 429+ 5DBC               IF (1 == 1)
 430+ 5DBC              ; *******************************************************************************************************
 431+ 5DBC              ; function to handle CALL BLIT basic extension
 432+ 5DBC              ; rotates 1-bit character drawing horizontally with mask and character data and
 433+ 5DBC              ; fuses with background data and applies vertical shift too
 434+ 5DBC              ; in form without pointers
 435+ 5DBC              ; BLIT ( INT x,
 436+ 5DBC              ;		 INT y,
 437+ 5DBC              ;		 INT char_data_pointer,
 438+ 5DBC              ;		 INT mask_data_pointer,
 439+ 5DBC              ;		 INT width (in characters),
 440+ 5DBC              ;		 INT height (in characters),
 441+ 5DBC              ;		 INT background_pointer (top left),
 442+ 5DBC              ;		 INT background_width (in characters),
 443+ 5DBC              ; will put ram in page 0 also, page 1 is already there
 444+ 5DBC              BLIT:
 445+ 5DBC              	; opening (
 446+ 5DBC CD 4D 65     	CALL CHKCHAR
 447+ 5DBF 28           	DB '('
 448+ 5DC0              	; get x coordinate
 449+ 5DC0 DD 21 2F 54  	LD IX, FRMQNT
 450+ 5DC4 CD 59 01     	CALL CALBAS
 451+ 5DC7 7B           	LD A, E
 452+ 5DC8 E6 07        	AND 7
 453+ 5DCA 32 3D 62     	LD (BLIT_STRUCT+0), A
 454+ 5DCD CD AE 5D     	CALL DEdiv8
 455+ 5DD0 32 39 62     	LD (BLIT_TMP+0),A
 456+ 5DD3              	; comma
 457+ 5DD3 CD 4D 65     	CALL CHKCHAR
 458+ 5DD6 2C           	DB ','
 459+ 5DD7              	; get y coordinate
 460+ 5DD7 DD 21 2F 54  	LD IX, FRMQNT
 461+ 5DDB CD 59 01     	CALL CALBAS
 462+ 5DDE 7B           	LD A, E
 463+ 5DDF E6 07        	AND 7
 464+ 5DE1 32 3F 62     	LD (BLIT_STRUCT+2), A
 465+ 5DE4 CD AE 5D     	CALL DEdiv8
 466+ 5DE7 32 3A 62     	LD (BLIT_TMP+1),A
 467+ 5DEA              	; comma
 468+ 5DEA CD 4D 65     	CALL CHKCHAR
 469+ 5DED 2C           	DB ','
 470+ 5DEE              	; get char data pointer
 471+ 5DEE DD 21 2F 54  	LD IX, FRMQNT
 472+ 5DF2 CD 59 01     	CALL CALBAS
 473+ 5DF5 ED 53 47 62  	LD (BLIT_STRUCT+10), DE
 474+ 5DF9              	; comma
 475+ 5DF9 CD 4D 65     	CALL CHKCHAR
 476+ 5DFC 2C           	DB ','
 477+ 5DFD              	; get mask data pointer
 478+ 5DFD DD 21 2F 54  	LD IX, FRMQNT
 479+ 5E01 CD 59 01     	CALL CALBAS
 480+ 5E04 ED 53 45 62  	LD (BLIT_STRUCT+8), DE
 481+ 5E08              	; comma
 482+ 5E08 CD 4D 65     	CALL CHKCHAR
 483+ 5E0B 2C           	DB ','
 484+ 5E0C              	; get width
 485+ 5E0C DD 21 2F 54  	LD IX, FRMQNT
 486+ 5E10 CD 59 01     	CALL CALBAS
 487+ 5E13 7B           	LD A, E
 488+ 5E14 32 4B 62     	LD (BLIT_STRUCT+14), A
 489+ 5E17              	; comma
 490+ 5E17 CD 4D 65     	CALL CHKCHAR
 491+ 5E1A 2C           	DB ','
 492+ 5E1B              	; get height
 493+ 5E1B DD 21 2F 54  	LD IX, FRMQNT
 494+ 5E1F CD 59 01     	CALL CALBAS
 495+ 5E22 7B           	LD A, E
 496+ 5E23 32 4D 62     	LD (BLIT_STRUCT+16), A
 497+ 5E26              	; comma
 498+ 5E26 CD 4D 65     	CALL CHKCHAR
 499+ 5E29 2C           	DB ','
 500+ 5E2A              	; get background pointer
 501+ 5E2A DD 21 2F 54  	LD IX, FRMQNT
 502+ 5E2E CD 59 01     	CALL CALBAS
 503+ 5E31 ED 53 41 62  	LD (BLIT_STRUCT+4), DE
 504+ 5E35              	; comma
 505+ 5E35 CD 4D 65     	CALL CHKCHAR
 506+ 5E38 2C           	DB ','
 507+ 5E39              	; get background width
 508+ 5E39 DD 21 2F 54  	LD IX, FRMQNT
 509+ 5E3D CD 59 01     	CALL CALBAS
 510+ 5E40 7B           	LD A, E
 511+ 5E41 32 3B 62     	LD (BLIT_TMP+2), A
 512+ 5E44              	; ending )
 513+ 5E44 CD 4D 65     	CALL CHKCHAR
 514+ 5E47 29           	DB ')'
 515+ 5E48
 516+ 5E48 E5           	PUSH HL ; save position in BASIC buffer
 517+ 5E49
 518+ 5E49              	; calculate char&mask add to value
 519+ 5E49 26 00        	LD H, 0
 520+ 5E4B 3A 4B 62     	LD A, (BLIT_STRUCT+14)
 521+ 5E4E 6F           	LD L, A
 522+ 5E4F CD 3A 64     	CALL HLx8
 523+ 5E52 22 49 62     	LD (BLIT_STRUCT+12), HL
 524+ 5E55              	; calculate background add to value
 525+ 5E55 26 00        	LD H, 0
 526+ 5E57 3A 3B 62     	LD A, (BLIT_TMP+2)
 527+ 5E5A 6F           	LD L, A
 528+ 5E5B CD 3A 64     	CALL HLx8
 529+ 5E5E 22 43 62     	LD (BLIT_STRUCT+6), HL
 530+ 5E61              	; calculate pointer to background location
 531+ 5E61 21 00 00     	LD HL, 0
 532+ 5E64 3A 3A 62     	LD A,(BLIT_TMP+1)
 533+ 5E67 B7           	OR A
 534+ 5E68 28 08        	JR Z, .L1
 535+ 5E6A 47           	LD B,A
 536+ 5E6B ED 5B 43 62  	LD DE,(BLIT_STRUCT+6)
 537+ 5E6F              .L0:
 538+ 5E6F 19           	ADD HL, DE
 539+ 5E70 10 FD        	DJNZ .L0
 540+ 5E72              .L1:
 541+ 5E72 EB           	EX DE,HL
 542+ 5E73 26 00        	LD H,0
 543+ 5E75 3A 39 62     	LD A,(BLIT_TMP+0)
 544+ 5E78 6F           	LD L,A
 545+ 5E79 CD 3A 64     	CALL HLx8
 546+ 5E7C 19           	ADD HL,DE
 547+ 5E7D ED 5B 41 62  	LD DE,(BLIT_STRUCT+4)
 548+ 5E81 19           	ADD HL,DE
 549+ 5E82 22 41 62     	LD (BLIT_STRUCT+4),HL
 550+ 5E85
 551+ 5E85 FD 21 8C 5E  	LD IY, .RET
 552+ 5E89 C3 FE 64     	JP ENABLE_PAGE0
 553+ 5E8C              .RET:
 554+ 5E8C FB           	EI
 555+ 5E8D DD 21 3D 62  	LD IX, BLIT_STRUCT
 556+ 5E91 CD 1A 5D     	CALL SHIFT_MERGE_CHARACTER
 557+ 5E94
 558+ 5E94 D1               POP DE
 559+ 5E95 C1               POP BC
 560+ 5E96 CD 75 64         CALL RESTORE_PAGE_INFO
 561+ 5E99
 562+ 5E99 E1           	POP HL
 563+ 5E9A C9           	RET
 564+ 5E9B              ; *******************************************************************************************************
 565+ 5E9B               ENDIF
# file closed: asm\BLIT.asm
 158  5E9B               ENDIF
 159  5E9B
 160  5E9B               IF (TILE_CMDS == 1)
 161  5E9B               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
   1+ 5E9B              ; *******************************************************************************************************
   2+ 5E9B              ; generic function to implement tiling
   3+ 5E9B              ; should be modified to call appropriate function for memory or vram
   4+ 5E9B              ; input IX=pointer to following structure
   5+ 5E9B              ; +00 tile_data_ptr
   6+ 5E9B              ; +02 tile_rows
   7+ 5E9B              ; +04 tile_columns
   8+ 5E9B              ; +06 destination_address
   9+ 5E9B              ; +08 dest_to_next_row_add_to_value
  10+ 5E9B              ; +10 num_horizontal_tiles
  11+ 5E9B              ; +12 num_vertical_tiles
  12+ 5E9B              ; modifies AF, BC, DE, HL
  13+ 5E9B              TILE:
  14+ 5E9B DD 6E 06     	LD L, (IX+6)
  15+ 5E9E DD 66 07     	LD H, (IX+7) ; destination address
  16+ 5EA1 22 39 62     	LD (TILETMP1), HL
  17+ 5EA4 DD 46 0C     	LD B, (IX+12) ; vertical tile number
  18+ 5EA7              .L1:
  19+ 5EA7 C5           	PUSH BC
  20+ 5EA8 DD 6E 00     		LD L, (IX+0)
  21+ 5EAB DD 66 01     		LD H, (IX+1) ; tile address
  22+ 5EAE 22 3B 62     		LD (TILETMP2), HL
  23+ 5EB1 DD 46 02     		LD B, (IX+2) ; tile rows
  24+ 5EB4              .L2:
  25+ 5EB4 C5           		PUSH BC
  26+ 5EB5 CD 00 00     .CALL1:		CALL 0
  27+ 5EB8 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
  28+ 5EBB              .L3:
  29+ 5EBB C5           			PUSH BC
  30+ 5EBC 2A 3B 62     				LD HL, (TILETMP2)
  31+ 5EBF DD 46 04     				LD B, (IX+4) ; tile columns
  32+ 5EC2              .L4:
  33+ 5EC2 C5           				PUSH BC
  34+ 5EC3              .CALL2:
  35+ 5EC3 CD 00 00     					CALL 0
  36+ 5EC6 C1           				POP BC
  37+ 5EC7 10 F9        				DJNZ .L4
  38+ 5EC9 C1           			POP BC
  39+ 5ECA 10 EF        			DJNZ .L3
  40+ 5ECC 22 3B 62     			LD (TILETMP2), HL
  41+ 5ECF 2A 39 62     			LD HL, (TILETMP1)
  42+ 5ED2 DD 5E 08     			LD E, (IX+8)
  43+ 5ED5 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
  44+ 5ED8 19           			ADD HL, DE
  45+ 5ED9 22 39 62     			LD (TILETMP1), HL
  46+ 5EDC C1           		POP BC
  47+ 5EDD 10 D5        		DJNZ .L2
  48+ 5EDF C1           	POP BC
  49+ 5EE0 10 C5        	DJNZ .L1
  50+ 5EE2 C9           	RET
  51+ 5EE3              ; *******************************************************************************************************
  52+ 5EE3
  53+ 5EE3               IF (0 == 1)
  54+ 5EE3 ~            ; *******************************************************************************************************
  55+ 5EE3 ~            ; same as TILERAM but for DEFUSR approach
  56+ 5EE3 ~            ; input IX=pointer to input array, real data from +2
  57+ 5EE3 ~            ; +02 = tile data pointer
  58+ 5EE3 ~            ; +04 = tile columns
  59+ 5EE3 ~            ; +06 = tile rows
  60+ 5EE3 ~            ; +08 = destination pointer
  61+ 5EE3 ~            ; +10 = destination columns
  62+ 5EE3 ~            ; +12 = destination rows
  63+ 5EE3 ~            ; +14 = destination begin column
  64+ 5EE3 ~            ; +16 = destination begin row
  65+ 5EE3 ~            ; +18 = number of tiles horizontally
  66+ 5EE3 ~            ; +20 = number of tiles vertically
  67+ 5EE3 ~            ; *******************************************************************************************************
  68+ 5EE3 ~            TILERAM_DEFUSR:
  69+ 5EE3 ~            	; tile data pointer
  70+ 5EE3 ~            	LD L,(IX+2)
  71+ 5EE3 ~            	LD H,(IX+3)
  72+ 5EE3 ~            	LD (BLIT_STRUCT+0),HL
  73+ 5EE3 ~            	; tile columns
  74+ 5EE3 ~            	LD L,(IX+4)
  75+ 5EE3 ~            	LD H,(IX+5)
  76+ 5EE3 ~            	LD (BLIT_STRUCT+4),HL
  77+ 5EE3 ~            	; tile rows
  78+ 5EE3 ~            	LD L,(IX+6)
  79+ 5EE3 ~            	LD H,(IX+7)
  80+ 5EE3 ~            	LD (BLIT_STRUCT+2),HL
  81+ 5EE3 ~            	; destintion pointer
  82+ 5EE3 ~            	LD L,(IX+8)
  83+ 5EE3 ~            	LD H,(IX+9)
  84+ 5EE3 ~            	LD (BLIT_STRUCT+6),HL
  85+ 5EE3 ~            	; destination columns
  86+ 5EE3 ~            	LD A,(IX+10)
  87+ 5EE3 ~            	LD (BLIT_TMP+0),A
  88+ 5EE3 ~            	; destination rows
  89+ 5EE3 ~            	LD A,(IX+12)
  90+ 5EE3 ~            	LD (BLIT_TMP+1),A
  91+ 5EE3 ~            	; destination begin column
  92+ 5EE3 ~            	LD A,(IX+14)
  93+ 5EE3 ~            	LD (BLIT_TMP+2),A
  94+ 5EE3 ~            	; destination begin row
  95+ 5EE3 ~            	LD A,(IX+16)
  96+ 5EE3 ~            	LD (BLIT_TMP+3),A
  97+ 5EE3 ~            	; number of tiles horizontally
  98+ 5EE3 ~            	LD L,(IX+18)
  99+ 5EE3 ~            	LD H,(IX+19)
 100+ 5EE3 ~            	LD (BLIT_STRUCT+10),HL
 101+ 5EE3 ~            	; number of tiles vertically
 102+ 5EE3 ~            	LD L,(IX+20)
 103+ 5EE3 ~            	LD H,(IX+21)
 104+ 5EE3 ~            	LD (BLIT_STRUCT+12),HL
 105+ 5EE3 ~             IF (BASIC_EXTENSION == 1) ; otherwise we just continue with code below
 106+ 5EE3 ~            	JP TILERAM.COMMON
 107+ 5EE3 ~             ENDIF
 108+ 5EE3               ENDIF
 109+ 5EE3
 110+ 5EE3              ; *******************************************************************************************************
 111+ 5EE3              ; function to handle CALL TILERAM basic extension
 112+ 5EE3              ; fills memory with tiles
 113+ 5EE3              ; TILERAM ( INT tile_data_pointer,
 114+ 5EE3              ;			INT tile_columns,
 115+ 5EE3              ;			INT tile_rows,
 116+ 5EE3              ;			INT destination_pointer,
 117+ 5EE3              ;			INT destination_columns,
 118+ 5EE3              ;			INT destination_rows,
 119+ 5EE3              ;			INT destination_begin_column,
 120+ 5EE3              ;			INT destination_begin_row,
 121+ 5EE3              ;			INT number_of_tiles_horizontally,
 122+ 5EE3              ;			INT	number_of_tiles_vertically )
 123+ 5EE3              ; will put ram in page 0 also, page 1 is already there
 124+ 5EE3              TILERAM:
 125+ 5EE3               IF (1 == 1)
 126+ 5EE3              	; opening (
 127+ 5EE3 CD 4D 65     	CALL CHKCHAR
 128+ 5EE6 28           	DB '('
 129+ 5EE7              	; get tile data pointer coordinate
 130+ 5EE7 DD 21 2F 54  	LD IX, FRMQNT
 131+ 5EEB CD 59 01     	CALL CALBAS
 132+ 5EEE ED 53 3D 62  	LD (BLIT_STRUCT+0), DE
 133+ 5EF2              	; comma
 134+ 5EF2 CD 4D 65     	CALL CHKCHAR
 135+ 5EF5 2C           	DB ','
 136+ 5EF6              	; get tile columns
 137+ 5EF6 DD 21 2F 54  	LD IX, FRMQNT
 138+ 5EFA CD 59 01     	CALL CALBAS
 139+ 5EFD ED 53 41 62  	LD (BLIT_STRUCT+4), DE
 140+ 5F01              	; comma
 141+ 5F01 CD 4D 65     	CALL CHKCHAR
 142+ 5F04 2C           	DB ','
 143+ 5F05              	; get tile columns
 144+ 5F05 DD 21 2F 54  	LD IX, FRMQNT
 145+ 5F09 CD 59 01     	CALL CALBAS
 146+ 5F0C ED 53 3F 62  	LD (BLIT_STRUCT+2), DE
 147+ 5F10              	; comma
 148+ 5F10 CD 4D 65     	CALL CHKCHAR
 149+ 5F13 2C           	DB ','
 150+ 5F14              	; get destintion pointer
 151+ 5F14 DD 21 2F 54  	LD IX, FRMQNT
 152+ 5F18 CD 59 01     	CALL CALBAS
 153+ 5F1B ED 53 43 62  	LD (BLIT_STRUCT+6), DE
 154+ 5F1F              	; comma
 155+ 5F1F CD 4D 65     	CALL CHKCHAR
 156+ 5F22 2C           	DB ','
 157+ 5F23              	; get destination columns
 158+ 5F23 DD 21 2F 54  	LD IX, FRMQNT
 159+ 5F27 CD 59 01     	CALL CALBAS
 160+ 5F2A 7B           	LD A, E
 161+ 5F2B 32 39 62     	LD (BLIT_TMP+0), A
 162+ 5F2E              	; comma
 163+ 5F2E CD 4D 65     	CALL CHKCHAR
 164+ 5F31 2C           	DB ','
 165+ 5F32              	; get destination rows
 166+ 5F32 DD 21 2F 54  	LD IX, FRMQNT
 167+ 5F36 CD 59 01     	CALL CALBAS
 168+ 5F39 7B           	LD A, E
 169+ 5F3A 32 3A 62     	LD (BLIT_TMP+1), A
 170+ 5F3D              	; comma
 171+ 5F3D CD 4D 65     	CALL CHKCHAR
 172+ 5F40 2C           	DB ','
 173+ 5F41              	; get destination begin column
 174+ 5F41 DD 21 2F 54  	LD IX, FRMQNT
 175+ 5F45 CD 59 01     	CALL CALBAS
 176+ 5F48 7B           	LD A, E
 177+ 5F49 32 3B 62     	LD (BLIT_TMP+2), A
 178+ 5F4C              	; comma
 179+ 5F4C CD 4D 65     	CALL CHKCHAR
 180+ 5F4F 2C           	DB ','
 181+ 5F50              	; get destination begin row
 182+ 5F50 DD 21 2F 54  	LD IX, FRMQNT
 183+ 5F54 CD 59 01     	CALL CALBAS
 184+ 5F57 7B           	LD A, E
 185+ 5F58 32 3C 62     	LD (BLIT_TMP+3), A
 186+ 5F5B              	; comma
 187+ 5F5B CD 4D 65     	CALL CHKCHAR
 188+ 5F5E 2C           	DB ','
 189+ 5F5F              	; get number of tiles horizontally
 190+ 5F5F DD 21 2F 54  	LD IX, FRMQNT
 191+ 5F63 CD 59 01     	CALL CALBAS
 192+ 5F66 ED 53 47 62  	LD (BLIT_STRUCT+10), DE
 193+ 5F6A              	; comma
 194+ 5F6A CD 4D 65     	CALL CHKCHAR
 195+ 5F6D 2C           	DB ','
 196+ 5F6E              	; get number of tiles vertically
 197+ 5F6E DD 21 2F 54  	LD IX, FRMQNT
 198+ 5F72 CD 59 01     	CALL CALBAS
 199+ 5F75 ED 53 49 62  	LD (BLIT_STRUCT+12), DE
 200+ 5F79              	; ending )
 201+ 5F79 CD 4D 65     	CALL CHKCHAR
 202+ 5F7C 29           	DB ')'
 203+ 5F7D               ENDIF
 204+ 5F7D              .COMMON:
 205+ 5F7D E5           	PUSH HL ; save position in BASIC buffer
 206+ 5F7E
 207+ 5F7E              	; calculate destination add to value
 208+ 5F7E 26 00        	LD H, 0
 209+ 5F80 3A 39 62     	LD A, (BLIT_TMP+0)
 210+ 5F83 6F           	LD L, A
 211+ 5F84 CD 3A 64     	CALL HLx8
 212+ 5F87 22 45 62     	LD (BLIT_STRUCT+8), HL
 213+ 5F8A              	; calculate pointer to background location
 214+ 5F8A 21 00 00     	LD HL, 0
 215+ 5F8D 3A 3C 62     	LD A,(BLIT_TMP+3)
 216+ 5F90 B7           	OR A
 217+ 5F91 28 08        	JR Z, .L1
 218+ 5F93 47           	LD B,A
 219+ 5F94 ED 5B 45 62  	LD DE,(BLIT_STRUCT+8)
 220+ 5F98              .L0:
 221+ 5F98 19           	ADD HL, DE
 222+ 5F99 10 FD        	DJNZ .L0
 223+ 5F9B              .L1:
 224+ 5F9B EB           	EX DE,HL
 225+ 5F9C 26 00        	LD H,0
 226+ 5F9E 3A 3B 62     	LD A,(BLIT_TMP+2)
 227+ 5FA1 6F           	LD L,A
 228+ 5FA2 CD 3A 64     	CALL HLx8
 229+ 5FA5 19           	ADD HL,DE
 230+ 5FA6 ED 5B 43 62  	LD DE,(BLIT_STRUCT+6)
 231+ 5FAA 19           	ADD HL,DE
 232+ 5FAB 22 43 62     	LD (BLIT_STRUCT+6),HL
 233+ 5FAE FD 21 B5 5F  	LD IY, .RET
 234+ 5FB2 C3 FE 64     	JP ENABLE_PAGE0
 235+ 5FB5              .RET:
 236+ 5FB5 FB           	EI
 237+ 5FB6              	; set RAM functions to call
 238+ 5FB6 21 D0 5F     	LD HL, .TILECOPY
 239+ 5FB9 22 C4 5E     	LD (TILE.CALL2+1), HL
 240+ 5FBC 21 E1 5F     	LD HL, .SETDESTROW
 241+ 5FBF 22 B6 5E     	LD (TILE.CALL1+1), HL
 242+ 5FC2 DD 21 3D 62  	LD IX,BLIT_STRUCT
 243+ 5FC6 CD 9B 5E     	CALL TILE
 244+ 5FC9
 245+ 5FC9 D1               POP DE
 246+ 5FCA C1               POP BC
 247+ 5FCB CD 75 64         CALL RESTORE_PAGE_INFO
 248+ 5FCE
 249+ 5FCE E1           	POP HL
 250+ 5FCF C9           	RET
 251+ 5FD0              .TILECOPY:
 252+ 5FD0 ED A0       > LDI
 252+ 5FD2 ED A0       > LDI
 252+ 5FD4 ED A0       > LDI
 252+ 5FD6 ED A0       > LDI
 252+ 5FD8 ED A0       > LDI
 252+ 5FDA ED A0       > LDI
 252+ 5FDC ED A0       > LDI
 252+ 5FDE ED A0       > LDI
 253+ 5FE0 C9           	RET
 254+ 5FE1              .SETDESTROW:
 255+ 5FE1 ED 5B 39 62  	LD DE, (TILETMP1)
 256+ 5FE5 C9           	RET
 257+ 5FE6              ; *******************************************************************************************************
 258+ 5FE6
 259+ 5FE6               IF (0 == 1)
 260+ 5FE6 ~            ; *******************************************************************************************************
 261+ 5FE6 ~            ; same as TILEVRM but for DEFUSR approach
 262+ 5FE6 ~            ; input IX=pointer to input array, real data from +2
 263+ 5FE6 ~            ; +02 = tile data pointer
 264+ 5FE6 ~            ; +04 = tile columns
 265+ 5FE6 ~            ; +06 = tile rows
 266+ 5FE6 ~            ; +08 = destination begin column
 267+ 5FE6 ~            ; +10 = destination begin row
 268+ 5FE6 ~            ; +12 = number of tiles horizontally
 269+ 5FE6 ~            ; +14 = number of tiles vertically
 270+ 5FE6 ~            ; *******************************************************************************************************
 271+ 5FE6 ~            TILEVRM_DEFUSR:
 272+ 5FE6 ~            	; tile data pointer
 273+ 5FE6 ~            	LD L,(IX+2)
 274+ 5FE6 ~            	LD H,(IX+3)
 275+ 5FE6 ~            	LD (BLIT_STRUCT+0),HL
 276+ 5FE6 ~            	; tile columns
 277+ 5FE6 ~            	LD L,(IX+4)
 278+ 5FE6 ~            	LD H,(IX+5)
 279+ 5FE6 ~            	LD (BLIT_STRUCT+4),HL
 280+ 5FE6 ~            	; tile rows
 281+ 5FE6 ~            	LD L,(IX+6)
 282+ 5FE6 ~            	LD H,(IX+7)
 283+ 5FE6 ~            	LD (BLIT_STRUCT+2),HL
 284+ 5FE6 ~            	; destination begin column
 285+ 5FE6 ~            	LD A,(IX+8)
 286+ 5FE6 ~            	LD (BLIT_TMP+2),A
 287+ 5FE6 ~            	; destination begin row
 288+ 5FE6 ~            	LD A,(IX+10)
 289+ 5FE6 ~            	LD (BLIT_TMP+3),A
 290+ 5FE6 ~            	; number of tiles horizontally
 291+ 5FE6 ~            	LD L,(IX+12)
 292+ 5FE6 ~            	LD H,(IX+13)
 293+ 5FE6 ~            	LD (BLIT_STRUCT+10),HL
 294+ 5FE6 ~            	; number of tiles vertically
 295+ 5FE6 ~            	LD L,(IX+14)
 296+ 5FE6 ~            	LD H,(IX+15)
 297+ 5FE6 ~            	LD (BLIT_STRUCT+12),HL
 298+ 5FE6 ~             IF (BASIC_EXTENSION == 1) ; otherwise we just continue with code below
 299+ 5FE6 ~            	JP TILEVRM.COMMON
 300+ 5FE6 ~             ENDIF
 301+ 5FE6               ENDIF
 302+ 5FE6
 303+ 5FE6              ; *******************************************************************************************************
 304+ 5FE6              ; function to handle CALL TILEVRM basic extension
 305+ 5FE6              ; fills vram with tiles
 306+ 5FE6              ; TILEVRM ( INT tile_data_pointer,
 307+ 5FE6              ;			INT tile_columns,
 308+ 5FE6              ;			INT tile_rows,
 309+ 5FE6              ;			INT destination_begin_column,
 310+ 5FE6              ;			INT destination_begin_row,
 311+ 5FE6              ;			INT number_of_tiles_horizontally,
 312+ 5FE6              ;			INT	number_of_tiles_vertically )
 313+ 5FE6              ; will put ram in page 0 also, page 1 is already there
 314+ 5FE6              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
 315+ 5FE6              TILEVRM:
 316+ 5FE6               IF (1 == 1)
 317+ 5FE6              	; opening (
 318+ 5FE6 CD 4D 65     	CALL CHKCHAR
 319+ 5FE9 28           	DB '('
 320+ 5FEA              	; get tile data pointer coordinate
 321+ 5FEA DD 21 2F 54  	LD IX, FRMQNT
 322+ 5FEE CD 59 01     	CALL CALBAS
 323+ 5FF1 ED 53 3D 62  	LD (BLIT_STRUCT+0), DE
 324+ 5FF5              	; comma
 325+ 5FF5 CD 4D 65     	CALL CHKCHAR
 326+ 5FF8 2C           	DB ','
 327+ 5FF9              	; get tile columns
 328+ 5FF9 DD 21 2F 54  	LD IX, FRMQNT
 329+ 5FFD CD 59 01     	CALL CALBAS
 330+ 6000 ED 53 41 62  	LD (BLIT_STRUCT+4), DE
 331+ 6004              	; comma
 332+ 6004 CD 4D 65     	CALL CHKCHAR
 333+ 6007 2C           	DB ','
 334+ 6008              	; get tile columns
 335+ 6008 DD 21 2F 54  	LD IX, FRMQNT
 336+ 600C CD 59 01     	CALL CALBAS
 337+ 600F ED 53 3F 62  	LD (BLIT_STRUCT+2), DE
 338+ 6013              	; comma
 339+ 6013 CD 4D 65     	CALL CHKCHAR
 340+ 6016 2C           	DB ','
 341+ 6017              	; get destination begin column
 342+ 6017 DD 21 2F 54  	LD IX, FRMQNT
 343+ 601B CD 59 01     	CALL CALBAS
 344+ 601E 7B           	LD A, E
 345+ 601F 32 3B 62     	LD (BLIT_TMP+2), A
 346+ 6022              	; comma
 347+ 6022 CD 4D 65     	CALL CHKCHAR
 348+ 6025 2C           	DB ','
 349+ 6026              	; get destination begin row
 350+ 6026 DD 21 2F 54  	LD IX, FRMQNT
 351+ 602A CD 59 01     	CALL CALBAS
 352+ 602D 7B           	LD A, E
 353+ 602E 32 3C 62     	LD (BLIT_TMP+3), A
 354+ 6031              	; comma
 355+ 6031 CD 4D 65     	CALL CHKCHAR
 356+ 6034 2C           	DB ','
 357+ 6035              	; get number of tiles horizontally
 358+ 6035 DD 21 2F 54  	LD IX, FRMQNT
 359+ 6039 CD 59 01     	CALL CALBAS
 360+ 603C ED 53 47 62  	LD (BLIT_STRUCT+10), DE
 361+ 6040              	; comma
 362+ 6040 CD 4D 65     	CALL CHKCHAR
 363+ 6043 2C           	DB ','
 364+ 6044              	; get number of tiles vertically
 365+ 6044 DD 21 2F 54  	LD IX, FRMQNT
 366+ 6048 CD 59 01     	CALL CALBAS
 367+ 604B ED 53 49 62  	LD (BLIT_STRUCT+12), DE
 368+ 604F              	; ending )
 369+ 604F CD 4D 65     	CALL CHKCHAR
 370+ 6052 29           	DB ')'
 371+ 6053               ENDIF
 372+ 6053
 373+ 6053              .COMMON:
 374+ 6053 E5           	PUSH HL ; save position in BASIC buffer
 375+ 6054
 376+ 6054              	; calculate destination add to value
 377+ 6054 21 00 01     	LD HL, 256
 378+ 6057 22 45 62     	LD (BLIT_STRUCT+8), HL
 379+ 605A              	; calculate pointer to background location
 380+ 605A 3A 3C 62     	LD A,(BLIT_TMP+3)
 381+ 605D 67           	LD H,A
 382+ 605E 2E 00        	LD L,0
 383+ 6060 EB           	EX DE,HL
 384+ 6061 26 00        	LD H,0
 385+ 6063 3A 3B 62     	LD A,(BLIT_TMP+2)
 386+ 6066 6F           	LD L,A
 387+ 6067 CD 3A 64     	CALL HLx8
 388+ 606A 19           	ADD HL,DE
 389+ 606B ED 5B CB F3  	LD DE,(GRPCGP)
 390+ 606F 19           	ADD HL,DE
 391+ 6070 22 43 62     	LD (BLIT_STRUCT+6),HL
 392+ 6073 FD 21 7A 60  	LD IY, .RET
 393+ 6077 C3 FE 64     	JP ENABLE_PAGE0
 394+ 607A              .RET:
 395+ 607A FB           	EI
 396+ 607B              	; set RAM functions to call
 397+ 607B 21 95 60     	LD HL, .TILECOPY
 398+ 607E 22 C4 5E     	LD (TILE.CALL2+1), HL
 399+ 6081 21 9B 60     	LD HL, .SETDESTROW
 400+ 6084 22 B6 5E     	LD (TILE.CALL1+1), HL
 401+ 6087 DD 21 3D 62  	LD IX,BLIT_STRUCT
 402+ 608B CD 9B 5E     	CALL TILE
 403+ 608E
 404+ 608E D1               POP DE
 405+ 608F C1               POP BC
 406+ 6090 CD 75 64         CALL RESTORE_PAGE_INFO
 407+ 6093
 408+ 6093 E1           	POP HL
 409+ 6094 C9           	RET
 410+ 6095              .TILECOPY:
 411+ 6095 01 98 08     	LD BC, #0898
 412+ 6098 C3 32 64     	JP BBYTECOPY_NO_C
 413+ 609B              .SETDESTROW:
 414+ 609B 2A 39 62     	LD HL, (TILETMP1)
 415+ 609E F3           	DI
 416+ 609F CD 25 64     	CALL SETWRT_LOCAL
 417+ 60A2 FB           	EI
 418+ 60A3 C9           	RET
 419+ 60A4              ; *******************************************************************************************************
 420+ 60A4
# file closed: asm\TILE.asm
 162  60A4               ENDIF
 163  60A4
 164  60A4               IF (COLL_CMD == 1)
 165  60A4               INCLUDE "COLLISION.asm"
# file opened: asm\COLLISION.asm
   1+ 60A4              ; generic collision checking routines
   2+ 60A4              ; in BASIC we use rectangle structure array DIM R%(7,n) of the format
   3+ 60A4              ; R%(0,n) is active flag, <>0 active / 0 skipped in checks
   4+ 60A4              ; R%(1,n) is either upper left x coordinate or sprite id (0-31) depending on R(7,n)
   5+ 60A4              ; R%(2,n) is either upper left y coordinate or unused depending on R(7,n)
   6+ 60A4              ; R%(3,n) x offset where rectangle begins
   7+ 60A4              ; R%(4,n) y offset where rectangle begins
   8+ 60A4              ; R%(5,n) is width
   9+ 60A4              ; R%(6,n) is height
  10+ 60A4              ; R%(7,0) is type, 0=generic where R%(1,0) contains x coordinate
  11+ 60A4              ;                  <>0 sprite where R%(1,0) contains sprite id
  12+ 60A4              ; for type sprite, upper left coordinates are taken from sprite attribute array
  13+ 60A4
  14+ 60A4              ; ************************************************************************************************
  15+ 60A4              ; quick test if HL<=DE<=HL+BC
  16+ 60A4              ; input BC=width, DE=x, HL=min
  17+ 60A4              ; if not true flag C set
  18+ 60A4              ; modifies AF
  19+ 60A4              GENERIC_INNER_CHECK:
  20+ 60A4 E5               PUSH HL
  21+ 60A5 D5               PUSH DE
  22+ 60A6 EB               EX DE,HL
  23+ 60A7 A7               AND A
  24+ 60A8 ED 52            SBC HL, DE
  25+ 60AA FA B8 60         JP M, .GENERIC_INNER_CHECK_NOT
  26+ 60AD A7               AND A
  27+ 60AE ED 42            SBC HL, BC
  28+ 60B0 28 03            JR Z, .L2
  29+ 60B2 F2 B8 60         JP P, .GENERIC_INNER_CHECK_NOT
  30+ 60B5              .L2:
  31+ 60B5 A7               AND A
  32+ 60B6 18 01            JR .EXIT
  33+ 60B8              .GENERIC_INNER_CHECK_NOT:
  34+ 60B8 37               SCF
  35+ 60B9              .EXIT:
  36+ 60B9 D1               POP DE
  37+ 60BA E1               POP HL
  38+ 60BB C9               RET
  39+ 60BC              ; ************************************************************************************************
  40+ 60BC
  41+ 60BC              ; ************************************************************************************************
  42+ 60BC              ; function to check if rectangles are overlapping
  43+ 60BC              ; input IX=IY=pointer to struct
  44+ 60BC              ;  +00 active flag
  45+ 60BC              ;  +02 x coordinate
  46+ 60BC              ;  +04 y coordinate
  47+ 60BC              ;  +06 x offset where rectangle begins
  48+ 60BC              ;  +08 y offset where rectangle begins
  49+ 60BC              ;  +10 width
  50+ 60BC              ;  +12 height
  51+ 60BC              ; where IY is used to read +2 and +4, and IX to read +6, +8, +10 and +12
  52+ 60BC              ; this is a hack to allow location being taken from sprite attributes table
  53+ 60BC              ; input BLIT_STRUCT data
  54+ 60BC              ;  +00 x coordinate
  55+ 60BC              ;  +02 y coordinate
  56+ 60BC              ;  +04 width
  57+ 60BC              ;  +06 height
  58+ 60BC              ; returns CF=1 if not overlapping, CF=0 if overlapping
  59+ 60BC              RECTANGLE_OVERLAP_CHECK:
  60+ 60BC                  ; first check which rectangle is higher
  61+ 60BC DD 6E 0C         LD L,(IX+12)
  62+ 60BF DD 66 0D         LD H,(IX+13)
  63+ 60C2 ED 5B 43 62      LD DE,(BLIT_STRUCT+6)
  64+ 60C6 A7               AND A
  65+ 60C7 ED 52            SBC HL,DE
  66+ 60C9 FD 6E 04         LD L,(IY+4)
  67+ 60CC FD 66 05         LD H,(IY+5)
  68+ 60CF DD 5E 08         LD E,(IX+8)
  69+ 60D2 DD 56 09         LD D,(IX+9)
  70+ 60D5 FA F5 60         JP M,.L1
  71+ 60D8                  ; equally high or IX defined one higher
  72+ 60D8                  ; check upper boundary
  73+ 60D8 19               ADD HL,DE
  74+ 60D9 ED 5B 3F 62      LD DE,(BLIT_STRUCT+2)
  75+ 60DD DD 4E 0C         LD C,(IX+12)
  76+ 60E0 DD 46 0D         LD B,(IX+13)
  77+ 60E3 CD A4 60         CALL GENERIC_INNER_CHECK
  78+ 60E6 30 29            JR NC,.INSIDE
  79+ 60E8                  ; check lower boundary
  80+ 60E8 E5               PUSH HL
  81+ 60E9 2A 43 62         LD HL,(BLIT_STRUCT+6)
  82+ 60EC 19               ADD HL,DE
  83+ 60ED EB               EX DE,HL
  84+ 60EE E1               POP HL
  85+ 60EF CD A4 60         CALL GENERIC_INNER_CHECK
  86+ 60F2 30 1D            JR NC,.INSIDE
  87+ 60F4 C9               RET ; not overlapping
  88+ 60F5              .L1:
  89+ 60F5                  ; rectangle defined in BLIT_STRUCT is higher
  90+ 60F5 19               ADD HL,DE
  91+ 60F6 EB               EX DE,HL
  92+ 60F7 2A 3F 62         LD HL,(BLIT_STRUCT+2)
  93+ 60FA ED 4B 43 62      LD BC,(BLIT_STRUCT+6)
  94+ 60FE CD A4 60         CALL GENERIC_INNER_CHECK
  95+ 6101 30 0E            JR NC,.INSIDE
  96+ 6103 E5               PUSH HL
  97+ 6104 DD 6E 0C         LD L,(IX+12)
  98+ 6107 DD 66 0D         LD H,(IX+13)
  99+ 610A 19               ADD HL,DE
 100+ 610B EB               EX DE,HL
 101+ 610C E1               POP HL
 102+ 610D CD A4 60         CALL GENERIC_INNER_CHECK
 103+ 6110 D8               RET C
 104+ 6111              .INSIDE:
 105+ 6111                  ; check x coordinate
 106+ 6111                  ; first check which rectangle is wider
 107+ 6111 DD 6E 0A         LD L,(IX+10)
 108+ 6114 DD 66 0B         LD H,(IX+11)
 109+ 6117 ED 5B 41 62      LD DE,(BLIT_STRUCT+4)
 110+ 611B A7               AND A
 111+ 611C ED 52            SBC HL,DE
 112+ 611E FD 6E 02         LD L,(IY+2)
 113+ 6121 FD 66 03         LD H,(IY+3)
 114+ 6124 DD 5E 06         LD E,(IX+6)
 115+ 6127 DD 56 07         LD D,(IX+7)
 116+ 612A FA 46 61         JP M,.L2
 117+ 612D                  ; equally wide or IX defined one wider
 118+ 612D                  ; check left boundary
 119+ 612D 19               ADD HL,DE
 120+ 612E ED 5B 3D 62      LD DE,(BLIT_STRUCT+0)
 121+ 6132 DD 4E 0A         LD C,(IX+10)
 122+ 6135 DD 46 0B         LD B,(IX+11)
 123+ 6138 CD A4 60         CALL GENERIC_INNER_CHECK
 124+ 613B D0               RET NC ; overlap
 125+ 613C                  ; check right boundary
 126+ 613C E5               PUSH HL
 127+ 613D 2A 41 62         LD HL,(BLIT_STRUCT+4)
 128+ 6140 19               ADD HL,DE
 129+ 6141 EB               EX DE,HL
 130+ 6142 E1               POP HL
 131+ 6143 C3 A4 60         JP GENERIC_INNER_CHECK ; CF and result set by fn call
 132+ 6146              .L2:
 133+ 6146                  ; rectangle defined in BLIT_STRUCT is higher
 134+ 6146 19               ADD HL,DE
 135+ 6147 EB               EX DE,HL
 136+ 6148 2A 3D 62         LD HL,(BLIT_STRUCT+0)
 137+ 614B ED 4B 41 62      LD BC,(BLIT_STRUCT+4)
 138+ 614F CD A4 60         CALL GENERIC_INNER_CHECK
 139+ 6152 D0               RET NC ; overlap
 140+ 6153 E5               PUSH HL
 141+ 6154 DD 6E 0A         LD L,(IX+10)
 142+ 6157 DD 66 0B         LD H,(IX+11)
 143+ 615A 19               ADD HL,DE
 144+ 615B EB               EX DE,HL
 145+ 615C E1               POP HL
 146+ 615D C3 A4 60         JP GENERIC_INNER_CHECK
 147+ 6160              ; ************************************************************************************************
 148+ 6160
 149+ 6160              ; ************************************************************************************************
 150+ 6160              ; function tries to find rectangle overlap and returns an index if found
 151+ 6160              ; input BLIT_STRUCT data
 152+ 6160              ;  +00 x coordinate
 153+ 6160              ;  +02 y coordinate
 154+ 6160              ;  +04 width
 155+ 6160              ;  +06 height
 156+ 6160              ;  +08 number of items in a list, described under RECTANGLE_OVERLAP_CHECK
 157+ 6160              ;  +09 pointer to first element of R%(7,n)
 158+ 6160              ;  +11 pointer to INT result variable
 159+ 6160              ; returns CF=1 if not overlapping
 160+ 6160              ; returns A=list index and CF=0 if overlapping
 161+ 6160              FIND_OVERLAP:
 162+ 6160 3A 45 62         LD A,(BLIT_STRUCT+8)
 163+ 6163 47               LD B,A
 164+ 6164 DD 2A 46 62      LD IX,(BLIT_STRUCT+9)
 165+ 6168              .L1:
 166+ 6168 C5               PUSH BC
 167+ 6169                  ; check active flag
 168+ 6169 DD 7E 00         LD A,(IX)
 169+ 616C DD B6 01         OR (IX+1)
 170+ 616F 28 18            JR Z,.NEXT
 171+ 6171                  ; check type
 172+ 6171 DD 7E 0E         LD A,(IX+14)
 173+ 6174 DD B6 0F         OR (IX+15)
 174+ 6177 20 1A            JR NZ,.L2
 175+ 6179 DD E5            PUSH IX
 176+ 617B FD E1            POP IY
 177+ 617D              .L3:
 178+ 617D CD BC 60         CALL RECTANGLE_OVERLAP_CHECK
 179+ 6180 38 07            JR C,.NEXT
 180+ 6182                  ; found
 181+ 6182 C1               POP BC
 182+ 6183 3A 45 62         LD A,(BLIT_STRUCT+8)
 183+ 6186 90               SUB B
 184+ 6187 A7               AND A
 185+ 6188 C9               RET
 186+ 6189              .NEXT:
 187+ 6189 11 10 00         LD DE,16
 188+ 618C DD 19            ADD IX,DE
 189+ 618E C1               POP BC
 190+ 618F 10 D7            DJNZ .L1
 191+ 6191 37               SCF
 192+ 6192 C9               RET
 193+ 6193              .L2:
 194+ 6193                  ; sprite, need to build a temporary data struct since x and y values are inversed
 195+ 6193                  ; at BLIT_STRUCT+13
 196+ 6193 DD 7E 02         LD A,(IX+2) ; sprite ID
 197+ 6196 CD 89 4D         CALL GETnthSPRATTR
 198+ 6199 FD 21 48 62      LD IY,BLIT_STRUCT+11
 199+ 619D 7E               LD A,(HL)
 200+ 619E FD 77 04         LD (IY+4),A
 201+ 61A1 23               INC HL
 202+ 61A2 7E               LD A,(HL)
 203+ 61A3 FD 77 05         LD (IY+5),A
 204+ 61A6 23               INC HL
 205+ 61A7 7E               LD A,(HL)
 206+ 61A8 FD 77 02         LD (IY+2),A
 207+ 61AB 23               INC HL
 208+ 61AC 7E               LD A,(HL)
 209+ 61AD FD 77 03         LD (IY+3),A
 210+ 61B0 18 CB            JR .L3
 211+ 61B2              ; ************************************************************************************************
 212+ 61B2
 213+ 61B2               IF (1 == 1)
 214+ 61B2              ; ************************************************************************************************
 215+ 61B2              ; function to handle CALL COLL basic extension
 216+ 61B2              ; checks for collision between player and other rectangles
 217+ 61B2              ; COLL ( INT result variable,
 218+ 61B2              ;	     INT player x value,
 219+ 61B2              ;	     INT player y value,
 220+ 61B2              ;	     INT player width,
 221+ 61B2              ;	     INT player height,
 222+ 61B2              ;	     INT number of items in a list,
 223+ 61B2              ;		 INT[6][n] rectangle struct )
 224+ 61B2              ; will fill result variable with index or -1 if no collision
 225+ 61B2              ; rectangle struct described under RECTANGLE_OVERLAP_CHECK
 226+ 61B2              COLL:
 227+ 61B2              	; opening (
 228+ 61B2 CD 4D 65     	CALL CHKCHAR
 229+ 61B5 28           	DB '('
 230+ 61B6              	; get address of result variable
 231+ 61B6 DD 21 A4 5E  	LD IX, PTRGET
 232+ 61BA CD 59 01     	CALL CALBAS
 233+ 61BD ED 53 48 62  	LD (BLIT_STRUCT+11),DE
 234+ 61C1              	; comma
 235+ 61C1 CD 4D 65     	CALL CHKCHAR
 236+ 61C4 2C           	DB ','
 237+ 61C5              	; get x
 238+ 61C5 DD 21 2F 54  	LD IX, FRMQNT
 239+ 61C9 CD 59 01     	CALL CALBAS
 240+ 61CC ED 53 3D 62  	LD (BLIT_STRUCT+0),DE
 241+ 61D0              	; comma
 242+ 61D0 CD 4D 65     	CALL CHKCHAR
 243+ 61D3 2C           	DB ','
 244+ 61D4              	; get y
 245+ 61D4 DD 21 2F 54  	LD IX, FRMQNT
 246+ 61D8 CD 59 01     	CALL CALBAS
 247+ 61DB ED 53 3F 62  	LD (BLIT_STRUCT+2),DE
 248+ 61DF              	; comma
 249+ 61DF CD 4D 65     	CALL CHKCHAR
 250+ 61E2 2C           	DB ','
 251+ 61E3              	; get width
 252+ 61E3 DD 21 2F 54  	LD IX, FRMQNT
 253+ 61E7 CD 59 01     	CALL CALBAS
 254+ 61EA ED 53 41 62  	LD (BLIT_STRUCT+4),DE
 255+ 61EE              	; comma
 256+ 61EE CD 4D 65     	CALL CHKCHAR
 257+ 61F1 2C           	DB ','
 258+ 61F2              	; get height
 259+ 61F2 DD 21 2F 54  	LD IX, FRMQNT
 260+ 61F6 CD 59 01     	CALL CALBAS
 261+ 61F9 ED 53 43 62  	LD (BLIT_STRUCT+6),DE
 262+ 61FD              	; comma
 263+ 61FD CD 4D 65     	CALL CHKCHAR
 264+ 6200 2C           	DB ','
 265+ 6201              	; get number of items in a list
 266+ 6201 DD 21 1C 52  	LD IX, GETBYT
 267+ 6205 CD 59 01     	CALL CALBAS
 268+ 6208 32 45 62     	LD (BLIT_STRUCT+8),A
 269+ 620B              	; comma
 270+ 620B CD 4D 65     	CALL CHKCHAR
 271+ 620E 2C           	DB ','
 272+ 620F              	; get address of rectangle structure array DIM R%(7,n)
 273+ 620F 3A 45 62     	LD A,(BLIT_STRUCT+8)
 274+ 6212 5F               LD E,A
 275+ 6213 3E 02            LD A,2
 276+ 6215 47           	LD B,A
 277+ 6216 16 07        	LD D,7
 278+ 6218 CD 7A 65     	CALL GET_BASIC_ARRAY_DATA_POINTER
 279+ 621B ED 43 46 62  	LD (BLIT_STRUCT+9),BC
 280+ 621F              	; ending )
 281+ 621F CD 4D 65     	CALL CHKCHAR
 282+ 6222 29           	DB ')'
 283+ 6223
 284+ 6223 E5               PUSH HL
 285+ 6224 CD 60 61         CALL FIND_OVERLAP
 286+ 6227 2A 48 62         LD HL,(BLIT_STRUCT+11)
 287+ 622A 38 06            JR C,.NOTFOUND
 288+ 622C 77               LD (HL),A
 289+ 622D 23               INC HL
 290+ 622E 36 00            LD (HL),0
 291+ 6230 E1               POP HL
 292+ 6231 C9               RET
 293+ 6232              .NOTFOUND:
 294+ 6232 36 FF            LD (HL),#FF
 295+ 6234 23               INC HL
 296+ 6235 36 FF            LD (HL),#FF
 297+ 6237 E1               POP HL
 298+ 6238 C9               RET
 299+ 6239              ; ************************************************************************************************
 300+ 6239               ENDIF
 301+ 6239
 302+ 6239               IF (0 == 1)
 303+ 6239 ~            ; *******************************************************************************************************
 304+ 6239 ~            ; same as COLL but for DEFUSR approach
 305+ 6239 ~            ; input IX=pointer to input array, real data from +2
 306+ 6239 ~            ; +02 = pointer to result variable
 307+ 6239 ~            ; +04 = player X
 308+ 6239 ~            ; +06 = player Y
 309+ 6239 ~            ; +08 = player width
 310+ 6239 ~            ; +10 = player height
 311+ 6239 ~            ; +12 = number of list items
 312+ 6239 ~            ; +14 = pointer to list of collidable objects
 313+ 6239 ~            COLL_DEFUSR:
 314+ 6239 ~                PUSH IX
 315+ 6239 ~                POP HL
 316+ 6239 ~                .4 INC HL ; skip over to player x
 317+ 6239 ~                LD DE,BLIT_STRUCT
 318+ 6239 ~                LD BC,9
 319+ 6239 ~                LDIR ; copy over x,y,w,h,list item number
 320+ 6239 ~                LD A,(IX+14)
 321+ 6239 ~                LD (BLIT_STRUCT+9),A
 322+ 6239 ~                LD A,(IX+15)
 323+ 6239 ~                LD (BLIT_STRUCT+10),A ; address to collidable objects array
 324+ 6239 ~                LD A,(IX+2)
 325+ 6239 ~                LD (BLIT_STRUCT+11),A
 326+ 6239 ~                LD A,(IX+3)
 327+ 6239 ~                LD (BLIT_STRUCT+12),A ; address to results variable
 328+ 6239 ~                PUSH IX
 329+ 6239 ~                CALL FIND_OVERLAP
 330+ 6239 ~                POP IX
 331+ 6239 ~                LD L,(IX+2)
 332+ 6239 ~                LD H,(IX+3)
 333+ 6239 ~                JR C,.NOTFOUND
 334+ 6239 ~                LD (HL),A
 335+ 6239 ~                INC HL
 336+ 6239 ~                LD (HL),0
 337+ 6239 ~                RET
 338+ 6239 ~            .NOTFOUND:
 339+ 6239 ~                LD (HL),#FF
 340+ 6239 ~                INC HL
 341+ 6239 ~                LD (HL),#FF
 342+ 6239 ~                RET
 343+ 6239 ~            ; *******************************************************************************************************
 344+ 6239               ENDIF
 345+ 6239
# file closed: asm\COLLISION.asm
 166  6239               ENDIF
 167  6239
 168  6239               IF (0 == 1)
 169  6239 ~             INCLUDE "DEFUSR.asm"
 170  6239               ENDIF
 171  6239
 172  6239              ; temp variables for BLIT, TILE functions
 173  6239               IF (BLIT_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS + COLL_CMD > 0)
 174  6239              BLIT_TMP:
 175  6239              TILETMP1:
 176  6239              BLIT_TMP1:
 177  6239 00 00         DW 0
 178  623B              TILETMP2:
 179  623B              BLIT_TMP2:
 180  623B 00 00         DW 0
 181  623D              BLIT_STRUCT:
 182  623D 00 00 00...   DS 17
 183  6241               ENDIF
 184  624E
 185  624E               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 186  624E              VRAM_UPDATE_IN_PROGRESS:
 187  624E 00            DB 0
 188  624F               ENDIF
 189  624F
 190  624F              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 191  624F              ; per starting letter, if no commands with this letter, NULL value
 192  624F              CMDS:
 193  624F 8D 63        	DW CMDS_A ; always present due to ARTINFO
 194  6251               IF (BLIT_CMDS + BOX_CMDS > 0) && (1 == 1)
 195  6251 50 63            DW CMDS_B ; B
 196  6253               ELSE
 197  6253 ~            	DW 0
 198  6253               ENDIF
 199  6253               IF (COLL_CMD == 1) && (1 == 1)
 200  6253 85 63        	DW CMDS_C ;
 201  6255               ELSE
 202  6255 ~                DW 0 ; C
 203  6255               ENDIF
 204  6255 00 00            DW 0 ; D
 205  6257 00 00            DW 0 ; E
 206  6259               IF (VRAM_CMDS + RAM_CMDS > 0) && (1 == 1)
 207  6259 D0 62            DW CMDS_F; F
 208  625B               ELSE
 209  625B ~            	DW 0
 210  625B               ENDIF
 211  625B               IF (GENCAL_CMD > 0) && (1 == 1)
 212  625B E3 62            DW CMDS_G; G
 213  625D               ELSE
 214  625D ~            	DW 0
 215  625D               ENDIF
 216  625D 00 00            DW 0 ; H
 217  625F 00 00            DW 0 ; I
 218  6261 00 00            DW 0 ; J
 219  6263 00 00            DW 0 ; K
 220  6265 00 00            DW 0 ; L
 221  6267               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0) && (1 == 1)
 222  6267 83 62            DW CMDS_M ; M
 223  6269               ELSE
 224  6269 ~            	DW 0
 225  6269               ENDIF
 226  6269 00 00            DW 0 ; N
 227  626B 00 00            DW 0 ; O
 228  626D 00 00            DW 0 ; P
 229  626F 00 00            DW 0 ; Q
 230  6271 00 00            DW 0 ; R
 231  6273               IF (SOUND_CMDS + SPRITE_CMDS > 0) && (1 == 1)
 232  6273 F7 62            DW CMDS_S ; S
 233  6275               ELSE
 234  6275 ~            	DW 0
 235  6275               ENDIF
 236  6275               IF (TILE_CMDS > 0) && (1 == 1)
 237  6275 70 63            DW CMDS_T ; T
 238  6277               ELSE
 239  6277 ~            	DW 0
 240  6277               ENDIF
 241  6277 00 00            DW 0 ; U
 242  6279               IF (VRAM_CMDS > 0) && (1 == 1)
 243  6279 ED 62            DW CMDS_V ; V
 244  627B               ELSE
 245  627B ~            	DW 0
 246  627B               ENDIF
 247  627B 00 00            DW 0 ; W
 248  627D 00 00            DW 0 ; X
 249  627F 00 00            DW 0 ; Y
 250  6281 00 00            DW 0 ; Z
 251  6283
 252  6283               IF (1 == 1)
 253  6283              CMDS_M:
 254  6283               IF (VRAM_CMDS == 1)
 255  6283 4D 45 4D 56      DB "MEMVRM", 0
 255  6287 52 4D 00
 256  628A F4 59            DW MEMVRM
 257  628C               ENDIF
 258  628C               IF (RAM_CMDS == 1)
 259  628C 4D 45 4D 43  	DB "MEMCPY", 0
 259  6290 50 59 00
 260  6293 32 58        	DW MEMCPY
 261  6295               ENDIF
 262  6295               IF (ANIM_CMDS == 1)
 263  6295 4D 41 58 41  	DB "MAXANIMITEMS",0
 263  6299 4E 49 4D 49
 263  629D 54 45 4D 53
 263  62A1 00
 264  62A2 A0 4F        	DW MAXANIMITEMS
 265  62A4 4D 41 58 41  	DB "MAXANIMDEFS",0
 265  62A8 4E 49 4D 44
 265  62AC 45 46 53 00
 266  62B0 30 51        	DW MAXANIMDEFS
 267  62B2 4D 41 58 41  	DB "MAXANIMSPRS",0
 267  62B6 4E 49 4D 53
 267  62BA 50 52 53 00
 268  62BE C6 51        	DW MAXANIMSPRS
 269  62C0 4D 41 58 41     DB "MAXAUTOSGAMS",0
 269  62C4 55 54 4F 53
 269  62C8 47 41 4D 53
 269  62CC 00
 270  62CD 10 53           DW MAXAUTOSGAMS
 271  62CF               ENDIF
 272  62CF               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 273  62CF 00           	DB 0
 274  62D0               ENDIF
 275  62D0              CMDS_F:
 276  62D0               IF (VRAM_CMDS == 1)
 277  62D0 46 49 4C 56      DB "FILVRM", 0
 277  62D4 52 4D 00
 278  62D7 A5 59            DW FILVRM
 279  62D9               ENDIF
 280  62D9               IF (RAM_CMDS == 1)
 281  62D9 46 49 4C 52      DB "FILRAM", 0
 281  62DD 41 4D 00
 282  62E0 75 58            DW FILRAM
 283  62E2               ENDIF
 284  62E2               IF (VRAM_CMDS + RAM_CMDS > 0)
 285  62E2 00               DB 0
 286  62E3               ENDIF
 287  62E3              CMDS_G:
 288  62E3               IF (GENCAL_CMD == 1)
 289  62E3 47 45 4E 43      DB "GENCAL", 0
 289  62E7 41 4C 00
 290  62EA DC 5A            DW GENCAL
 291  62EC               ENDIF
 292  62EC               IF (GENCAL_CMD > 0)
 293  62EC 00           	DB	0
 294  62ED               ENDIF
 295  62ED              CMDS_V:
 296  62ED               IF (VRAM_CMDS == 1)
 297  62ED 56 52 4D 4D  	DB "VRMMEM", 0
 297  62F1 45 4D 00
 298  62F4 77 5A        	DW VRMMEM
 299  62F6               ENDIF
 300  62F6               IF (VRAM_CMDS > 0)
 301  62F6 00           	DB 0
 302  62F7               ENDIF
 303  62F7              CMDS_S:
 304  62F7               IF (SPRITE_CMDS + ANIM_CMDS > 0)
 305  62F7 53 47 41 4D      DB "SGAM",0
 305  62FB 00
 306  62FC 9E 56            DW SGAM
 307  62FE               ENDIF
 308  62FE               IF (SPRITE_CMDS == 1)
 309  62FE 53 50 52 47  	DB "SPRGRPMOV", 0
 309  6302 52 50 4D 4F
 309  6306 56 00
 310  6308 F8 4E        	DW SPRGRPMOV
 311  630A               ENDIF
 312  630A               IF (SOUND_CMDS == 1)
 313  630A 53 4E 44 53  	DB "SNDSFX", 0
 313  630E 46 58 00
 314  6311 4B 59        	DW SNDSFX
 315  6313 53 4E 44 50  	DB "SNDPLYON", 0
 315  6317 4C 59 4F 4E
 315  631B 00
 316  631C 15 59        	DW SNDPLYON
 317  631E 53 4E 44 50  	DB "SNDPLYOFF", 0
 317  6322 4C 59 4F 46
 317  6326 46 00
 318  6328 28 59        	DW SNDPLYOFF
 319  632A 53 4E 44 50  	DB "SNDPLYINI", 0
 319  632E 4C 59 49 4E
 319  6332 49 00
 320  6334 CB 58        	DW SNDPLYINIT
 321  6336               ENDIF
 322  6336               IF (SPRITE_CMDS == 1)
 323  6336 53 50 52 45  	DB "SPRENABLE", 0
 323  633A 4E 41 42 4C
 323  633E 45 00
 324  6340 6E 4E        	DW SPRENABLE
 325  6342 53 50 52 44  	DB "SPRDISABLE", 0
 325  6346 49 53 41 42
 325  634A 4C 45 00
 326  634D B5 4E        	DW SPRDISABLE
 327  634F               ENDIF
 328  634F               IF (SOUND_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 329  634F 00           	DB 0
 330  6350               ENDIF
 331  6350              CMDS_B:
 332  6350               IF (BLIT_CMDS == 1)
 333  6350 42 4C 49 54  	DB "BLIT", 0
 333  6354 00
 334  6355 BC 5D        	DW BLIT
 335  6357               ENDIF
 336  6357               IF (BOX_CMDS == 1)
 337  6357 42 4F 58 4D  	DB "BOXMEMCPY", 0
 337  635B 45 4D 43 50
 337  635F 59 00
 338  6361 6B 5B        	DW BOXMEMCPY
 339  6363 42 4F 58 4D  	DB "BOXMEMVRM", 0
 339  6367 45 4D 56 52
 339  636B 4D 00
 340  636D 00 5C        	DW BOXMEMVRM
 341  636F               ENDIF
 342  636F               IF (BLIT_CMDS + BOX_CMDS > 0)
 343  636F 00           	DB 0
 344  6370               ENDIF
 345  6370              CMDS_T:
 346  6370               IF (TILE_CMDS == 1)
 347  6370 54 49 4C 45  	DB "TILERAM", 0
 347  6374 52 41 4D 00
 348  6378 E3 5E        	DW TILERAM
 349  637A 54 49 4C 45  	DB "TILEVRM", 0
 349  637E 56 52 4D 00
 350  6382 E6 5F        	DW TILEVRM
 351  6384               ENDIF
 352  6384               IF (TILE_CMDS > 0)
 353  6384 00           	DB 0
 354  6385               ENDIF
 355  6385              CMDS_C:
 356  6385               IF (COLL_CMD == 1)
 357  6385 43 4F 4C 4C      DB "COLL", 0
 357  6389 00
 358  638A B2 61            DW COLL
 359  638C               ENDIF
 360  638C               IF (COLL_CMD > 0)
 361  638C 00           	DB	0
 362  638D               ENDIF
 363  638D              CMDS_A:
 364  638D               IF (ANIM_CMDS == 1)
 365  638D 41 4E 49 4D     DB "ANIMSTEP",0
 365  6391 53 54 45 50
 365  6395 00
 366  6396 E0 54           DW ANIMSTEP
 367  6398 41 4E 49 4D  	DB "ANIMSTART",0
 367  639C 53 54 41 52
 367  63A0 54 00
 368  63A2 E5 54        	DW ANIMSTART
 369  63A4 41 4E 49 4D  	DB "ANIMSTOP",0
 369  63A8 53 54 4F 50
 369  63AC 00
 370  63AD EA 54        	DW ANIMSTOP
 371  63AF 41 4E 49 4D  	DB "ANIMITEMPAT",0
 371  63B3 49 54 45 4D
 371  63B7 50 41 54 00
 372  63BB 71 50        	DW ANIMITEMPAT
 373  63BD 41 4E 49 4D  	DB "ANIMITEMPTR",0
 373  63C1 49 54 45 4D
 373  63C5 50 54 52 00
 374  63C9 D7 50        	DW ANIMITEMPTR_CMD
 375  63CB 41 4E 49 4D  	DB "ANIMDEF",0
 375  63CF 44 45 46 00
 376  63D3 73 51        	DW ANIMDEF
 377  63D5 41 4E 49 4D  	DB "ANIMSPRITE",0
 377  63D9 53 50 52 49
 377  63DD 54 45 00
 378  63E0 1F 52        	DW ANIMSPRITE
 379  63E2 41 4E 49 4D     DB "ANIMCHAR",0
 379  63E6 43 48 41 52
 379  63EA 00
 380  63EB 97 52           DW ANIMCHAR
 381  63ED 41 55 54 4F     DB "AUTOSGAMDEF",0
 381  63F1 53 47 41 4D
 381  63F5 44 45 46 00
 382  63F9 6D 53           DW AUTOSGAMDEF
 383  63FB 41 55 54 4F     DB "AUTOSGAMSTART",0
 383  63FF 53 47 41 4D
 383  6403 53 54 41 52
 383  6407 54 00
 384  6409 A1 54           DW AUTOSGAMSTART
 385  640B 41 55 54 4F     DB "AUTOSGAMSTOP",0
 385  640F 53 47 41 4D
 385  6413 53 54 4F 50
 385  6417 00
 386  6418 DD 54           DW AUTOSGAMSTOP
 387  641A               ENDIF
 388  641A 41 52 54 49     DB "ARTINFO",0
 388  641E 4E 46 4F 00
 389  6422 AF 65           DW ARTINFO
 390  6424 00           	DB 0
 391  6425               ELSE
 392  6425 ~            CMDS_A:
 393  6425 ~             DB "ARTINFO",0
 394  6425 ~             DW ARTINFO
 395  6425 ~             DB 0
 396  6425               ENDIF
 397  6425
 398  6425
 399  6425               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 400  6425              ; ****************************************************************************************************
 401  6425              ; function sets VRAM address
 402  6425              ; input HL=address
 403  6425              ; modifies AF
 404  6425              SETWRT_LOCAL:
 405  6425 7D           	LD	A,L
 406  6426 D3 99        	OUT (099H),A
 407  6428 7C           	LD	A,H
 408  6429 E6 3F        	AND 03FH
 409  642B F6 40        	OR	040H
 410  642D D3 99        	OUT (099H),A
 411  642F C9           	RET
 412  6430              ; ****************************************************************************************************
 413  6430               ENDIF
 414  6430
 415  6430               IF (VRAM_CMDS + TILE_CMDS > 0)
 416  6430              ; ****************************************************************************************************
 417  6430              ; function copies data from RAM to VRAM
 418  6430              ; input HL=address in RAM
 419  6430              ; input B=count
 420  6430              ; modifies AF, BC, HL
 421  6430              BBYTECOPY:
 422  6430 0E 98        	LD C,#98
 423  6432              BBYTECOPY_NO_C:
 424  6432 ED A3        	OUTI
 425  6434 C2 32 64     	JP	NZ, BBYTECOPY_NO_C
 426  6437 C9           	RET
 427  6438              ; ****************************************************************************************************
 428  6438               ENDIF
 429  6438
 430  6438              ; ****************************************************************************************************
 431  6438              ; function multiplies HL by 32
 432  6438              HLx32:
 433  6438 29           	ADD HL,HL
 434  6439              ; ****************************************************************************************************
 435  6439              ; function multiplies HL by 16
 436  6439              HLx16:
 437  6439 29           	ADD HL,HL
 438  643A              ; ****************************************************************************************************
 439  643A              ; function multiplies HL by 8
 440  643A              HLx8:
 441  643A 29          > ADD HL, HL
 441  643B 29          > ADD HL, HL
 441  643C 29          > ADD HL, HL
 442  643D C9           	RET
 443  643E              ; ****************************************************************************************************
 444  643E
 445  643E              ; ****************************************************************************************************
 446  643E              ; function gets slot and subslot data for specific page
 447  643E              ; input A=page (0, 1 or 2)
 448  643E              ; output B = 0A8H register value
 449  643E              ; output D = 0 is no subslots, 1 if yes
 450  643E              ; output C = 0A8H value when page 3 slot equals to requested page slot
 451  643E              ; output E = subslot value if present
 452  643E              ; modifies AF, BC, DE, HL
 453  643E              GET_PAGE_INFO:
 454  643E 6F               LD L, A
 455  643F C6 C1            ADD A, low (EXPTBL)
 456  6441 32 4B 64         LD (GET_PAGE_INFO_L1+1), A
 457  6444 DB A8            IN A, (0A8H)
 458  6446 47               LD B, A
 459  6447 E6 3F            AND 03FH
 460  6449 4F               LD C, A
 461  644A              GET_PAGE_INFO_L1:
 462  644A 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 463  644D E6 80            AND 080H
 464  644F 28 1B            JR Z, GET_PAGE_INFO_L2
 465  6451                  ; expanded
 466  6451 2D               DEC L
 467  6452 FA 71 64         JP M, GET_PAGE_INFO_L3
 468  6455 2D               DEC L
 469  6456 FA 6F 64         JP M, GET_PAGE_INFO_L4
 470  6459                  ; page 2
 471  6459 07               RLCA
 472  645A 07               RLCA
 473  645B              GET_PAGE_INFO_L5:
 474  645B E6 C0            AND 0C0H
 475  645D B1               OR C
 476  645E D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 477  6460 4F               LD C, A
 478  6461 3A FF FF         LD A, (0FFFFH)
 479  6464 2F               CPL
 480  6465 5F               LD E, A
 481  6466 16 01            LD D, 1
 482  6468 78               LD A, B ; return stack
 483  6469 D3 A8            OUT (0A8H), A
 484  646B C9               RET
 485  646C              GET_PAGE_INFO_L2:
 486  646C                  ; not expanded
 487  646C 16 00            LD D, 0
 488  646E C9               RET
 489  646F              GET_PAGE_INFO_L4:
 490  646F                  ; page 1
 491  646F 0F               RRCA
 492  6470 0F               RRCA
 493  6471              GET_PAGE_INFO_L3:
 494  6471                  ; page 0
 495  6471 0F               RRCA
 496  6472 0F               RRCA
 497  6473 18 E6            JR GET_PAGE_INFO_L5
 498  6475              ; ****************************************************************************************************
 499  6475
 500  6475              ; ****************************************************************************************************
 501  6475              ; function returns original slot and subslot info
 502  6475              ; input B = 0A8H register value
 503  6475              ; input D = 0 is no subslots, 1 if yes
 504  6475              ; input C = 0A8H value when page 3 slot equals to requested page slot
 505  6475              ; input E = subslot value if present
 506  6475              ; modifies AF, disables interrupts
 507  6475              RESTORE_PAGE_INFO:
 508  6475 F3              DI
 509  6476 7A              LD A, D
 510  6477 B7              OR A
 511  6478 28 07           JR Z, RESTORE_PAGE_INFO_L1
 512  647A 79              LD A, C
 513  647B D3 A8           OUT (0A8H), A
 514  647D 7B              LD A, E
 515  647E 32 FF FF        LD (0FFFFH), A
 516  6481              RESTORE_PAGE_INFO_L1:
 517  6481 78              LD A, B
 518  6482 D3 A8           OUT (0A8H), A
 519  6484              NOACTION_DEFUSR: ; just a safe RET for use when DEFUSR table has an empty entry
 520  6484 C9              RET
 521  6485              ; ****************************************************************************************************
 522  6485
 523  6485              ; *******************************************************************************************************
 524  6485              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 525  6485              ; INPUT:  A = SLOT ID: EXXXSSPP
 526  6485              ; E = EXPANDED FLAG
 527  6485              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 528  6485              ; PP = PRIMARY SLOT NUMBER
 529  6485              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 530  6485              ; CHANGES: AF, BC, DE
 531  6485
 532  6485              LOCAL_ENASLT:
 533  6485 CD A5 64         CALL L0353
 534  6488 FA 92 64         JP M, L0340
 535  648B DB A8            IN A, (0A8H)
 536  648D A1               AND C
 537  648E B0               OR B
 538  648F D3 A8            OUT (0A8H), A
 539  6491 C9               RET
 540  6492              L0340:
 541  6492 E5               PUSH HL
 542  6493 CD CA 64         CALL L0378
 543  6496 4F               LD C, A
 544  6497 06 00            LD B, 0
 545  6499 7D               LD A, L
 546  649A A4               AND H
 547  649B B2               OR D
 548  649C 21 C5 FC         LD HL, 0FCC5H
 549  649F 09               ADD HL, BC
 550  64A0 77               LD (HL), A
 551  64A1 E1               POP HL
 552  64A2 79               LD A, C
 553  64A3 18 E0            JR LOCAL_ENASLT
 554  64A5              L0353:
 555  64A5 F3               DI
 556  64A6 F5               PUSH AF
 557  64A7 7C               LD A, H
 558  64A8 07               RLCA
 559  64A9 07               RLCA
 560  64AA E6 03            AND 3
 561  64AC 5F               LD E, A
 562  64AD 3E C0            LD A, 0C0H
 563  64AF              L035D:
 564  64AF 07               RLCA
 565  64B0 07               RLCA
 566  64B1 1D               DEC E
 567  64B2 F2 AF 64         JP P, L035D
 568  64B5 5F               LD E, A
 569  64B6 2F               CPL
 570  64B7 4F               LD C, A
 571  64B8 F1               POP AF
 572  64B9 F5               PUSH AF
 573  64BA E6 03            AND 3
 574  64BC 3C               INC A
 575  64BD 47               LD B, A
 576  64BE 3E AB            LD A, 0ABH
 577  64C0              L036E:
 578  64C0 C6 55            ADD A, 055H
 579  64C2 10 FC            DJNZ L036E
 580  64C4 57               LD D, A
 581  64C5 A3               AND E
 582  64C6 47               LD B, A
 583  64C7 F1               POP AF
 584  64C8 A7               AND A
 585  64C9 C9               RET
 586  64CA              L0378:
 587  64CA F5               PUSH AF
 588  64CB 7A               LD A, D
 589  64CC E6 C0            AND 0C0H
 590  64CE 4F               LD C, A
 591  64CF F1               POP AF
 592  64D0 F5               PUSH AF
 593  64D1 57               LD D, A
 594  64D2 DB A8            IN A, (0A8H)
 595  64D4 47               LD B, A
 596  64D5 E6 3F            AND 03FH
 597  64D7 B1               OR C
 598  64D8 D3 A8            OUT (0A8H), A
 599  64DA 7A               LD A, D
 600  64DB 0F               RRCA
 601  64DC 0F               RRCA
 602  64DD E6 03            AND 3
 603  64DF 57               LD D, A
 604  64E0 3E AB            LD A, 0ABH
 605  64E2              L0390:
 606  64E2 C6 55            ADD A, 055H
 607  64E4 15               DEC D
 608  64E5 F2 E2 64         JP P, L0390
 609  64E8 A3               AND E
 610  64E9 57               LD D, A
 611  64EA 7B               LD A, E
 612  64EB 2F               CPL
 613  64EC 67               LD H, A
 614  64ED 3A FF FF         LD A, (0FFFFH)
 615  64F0 2F               CPL
 616  64F1 6F               LD L, A
 617  64F2 A4               AND H
 618  64F3 B2               OR D
 619  64F4 32 FF FF         LD (0FFFFH), A
 620  64F7 78               LD A, B
 621  64F8 D3 A8            OUT (0A8H), A
 622  64FA F1               POP AF
 623  64FB E6 03            AND 3
 624  64FD C9               RET
 625  64FE              ; *******************************************************************************************************
 626  64FE
 627  64FE              ; *******************************************************************************************************
 628  64FE              ; some common code to activate page 0 and place values needed to restore original page on stack
 629  64FE              ; input IY=return address
 630  64FE              ENABLE_PAGE0:
 631  64FE F3              DI
 632  64FF AF              XOR A
 633  6500 CD 3E 64        CALL GET_PAGE_INFO
 634  6503 C5              PUSH BC
 635  6504 D5              PUSH DE
 636  6505 3A 41 F3        LD A, (RAMAD0)
 637  6508 26 00           LD H, 0
 638  650A CD 85 64        CALL LOCAL_ENASLT
 639  650D FD E9        	JP (IY)
 640  650F              ; *******************************************************************************************************
 641  650F
 642  650F              ; General BASIC CALL-instruction handler
 643  650F              CALLHAND:
 644  650F FB              EI
 645  6510 E5           	PUSH HL
 646  6511 21 4F 62     	LD	HL, CMDS ; pointer table based on starting letter
 647  6514 3A 89 FD        LD A, (PROCNM)
 648  6517 D6 41           SUB 'A'
 649  6519 87              ADD A, A
 650  651A 16 00           LD D, 0
 651  651C 5F              LD E, A
 652  651D 19              ADD HL, DE
 653  651E 5E              LD E, (HL)
 654  651F 23              INC HL
 655  6520 56              LD D, (HL)
 656  6521 7A              LD A, D
 657  6522 B3              OR E
 658  6523 28 23           JR Z, .CMDNOTRECOGNIZED
 659  6525 EB              EX DE, HL
 660  6526              .CHKCMD:
 661  6526 11 89 FD     	LD	DE, PROCNM
 662  6529              .LOOP:
 663  6529 1A              LD	A,(DE)
 664  652A BE           	CP	(HL)
 665  652B 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 666  652D 13           	INC	DE
 667  652E 23           	INC	HL
 668  652F A7           	AND	A
 669  6530 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 670  6532 5E           	LD	E,(HL)
 671  6533 23           	INC	HL
 672  6534 56           	LD	D,(HL)
 673  6535 E1           	POP	HL		; routine address
 674  6536 CD 57 65     	CALL	GETPREVCHAR
 675  6539 CD 4B 65     	CALL	.CALLDE		; Call routine
 676  653C A7           	AND	A
 677  653D C9           	RET
 678  653E
 679  653E              .TONEXTCMD:
 680  653E 0E FF        	LD	C,0FFH
 681  6540 AF           	XOR	A
 682  6541 ED B1        	CPIR			; Skip to end of instruction name
 683  6543 23           	INC	HL
 684  6544 23           	INC	HL		; Skip address
 685  6545 BE           	CP	(HL)
 686  6546 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 687  6548              .CMDNOTRECOGNIZED:
 688  6548 E1           	POP	HL
 689  6549 37              SCF
 690  654A C9           	RET
 691  654B
 692  654B              .CALLDE:
 693  654B D5           	PUSH	DE
 694  654C C9           	RET
 695  654D
 696  654D              ;---------------------------
 697  654D
 698  654D              ;GETSTRPNT:
 699  654D              ; OUT:
 700  654D              ; HL = String Address
 701  654D              ; B  = Lenght
 702  654D              ;        LD      HL,(USR)
 703  654D              ;        LD      B,(HL)
 704  654D              ;        INC     HL
 705  654D              ;        LD      E,(HL)
 706  654D              ;        INC     HL
 707  654D              ;        LD      D,(HL)
 708  654D              ;        EX      DE,HL
 709  654D              ;        RET
 710  654D
 711  654D              ;EVALTXTPARAM:
 712  654D              ;	CALL	CHKCHAR
 713  654D              ;	DEFB	"("             ; Check for (
 714  654D              ;	LD	IX,FRMEVL
 715  654D              ;	CALL	CALBAS		; Evaluate expression
 716  654D              ;       LD      A,(VALTYP)
 717  654D              ;        CP      3               ; Text type?
 718  654D              ;        JP      NZ,TYPE_MISMATCH
 719  654D              ;        PUSH	HL
 720  654D              ;        LD	IX,FRESTR         ; Free the temporary string
 721  654D              ;        CALL	CALBAS
 722  654D              ;        POP	HL
 723  654D              ;	CALL	CHKCHAR
 724  654D              ;	DEFB	")"             ; Check for )
 725  654D              ;        RET
 726  654D
 727  654D
 728  654D              CHKCHAR:
 729  654D CD 57 65     	CALL	GETPREVCHAR	; Get previous basic char
 730  6550 E3           	EX	(SP),HL
 731  6551 BE           	CP	(HL) 	        ; Check if good char
 732  6552 20 1D        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 733  6554 23           	INC	HL
 734  6555 E3           	EX	(SP),HL
 735  6556 23           	INC	HL		; Get next basic char
 736  6557
 737  6557              GETPREVCHAR:
 738  6557 2B           	DEC HL
 739  6558 DD 21 66 46  	LD	IX,CHRGTR
 740  655C CD 59 01     	CALL CALBAS
 741  655F FB              EI
 742  6560 C9              RET
 743  6561
 744  6561
 745  6561              TYPE_MISMATCH:
 746  6561 1E 0D            LD E, 13 ; Type mismatch
 747  6563 18 0E            JR THROW_ERROR
 748  6565              SUBSCRIPT_OUT_OF_RANGE:
 749  6565 1E 09            LD E,9 ; subscript out of range
 750  6567 18 0A        	JR THROW_ERROR
 751  6569              OVERFLOW:
 752  6569 1E 06        	LD E,6
 753  656B 18 06        	JR THROW_ERROR
 754  656D              ILLEGAL_FUNCTION:
 755  656D 1E 05            LD E, 5 ; illegal function call
 756  656F 18 02            JR THROW_ERROR
 757  6571              SYNTAX_ERROR:
 758  6571 1E 02            LD E, 2 ; Syntax error
 759  6573              THROW_ERROR:
 760  6573 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 761  6577 C3 59 01     	JP	CALBAS
 762  657A
 763  657A              ;---------------------------
 764  657A
 765  657A               IF (1 == 1)
 766  657A              ; *******************************************************************************************************
 767  657A              ; helper function to get pointer to BASIC array data
 768  657A              ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
 769  657A              ; input B=dimensions (1 or 2)
 770  657A              ; input D=minimal first dimension
 771  657A              ; input E=minimal second dimension, if applicable
 772  657A              ; returns BC=pointer to first data element
 773  657A              ; throws BASIC error if invalid type
 774  657A              GET_BASIC_ARRAY_DATA_POINTER:
 775  657A D5           	PUSH DE
 776  657B C5           	PUSH BC
 777  657C F5           	PUSH AF
 778  657D 3E 01           LD A,1
 779  657F 32 A5 F6        LD (SUBFLG),A ; search for arrays only
 780  6582 DD 21 A4 5E  	LD IX, PTRGET
 781  6586 CD 59 01     	CALL CALBAS
 782  6589 AF              XOR A
 783  658A 32 A5 F6        LD (SUBFLG),A ; if not reset will cause syntax errors
 784  658D 3A 63 F6     	LD A,(VALTYP)
 785  6590 D1           	POP DE ; required type
 786  6591 BA           	CP D
 787  6592 C2 61 65     	JP NZ,TYPE_MISMATCH
 788  6595 0A           	LD A,(BC)
 789  6596 03           	INC BC
 790  6597 D1           	POP DE ; required number of dimensions
 791  6598 BA           	CP D
 792  6599 C2 61 65     	JP NZ,TYPE_MISMATCH
 793  659C D1           	POP DE ; required minimal array dimensions
 794  659D 3D           	DEC A
 795  659E 28 07        	JR Z,.ONE_DIMENSION
 796  65A0              	; 2-dimension array
 797  65A0 0A           	LD A,(BC)
 798  65A1 03          > INC BC
 798  65A2 03          > INC BC
 799  65A3 BB           	CP E
 800  65A4 DA 65 65     	JP C,SUBSCRIPT_OUT_OF_RANGE
 801  65A7              .ONE_DIMENSION:
 802  65A7 0A           	LD A,(BC)
 803  65A8 03          > INC BC
 803  65A9 03          > INC BC
 804  65AA BA           	CP D
 805  65AB DA 65 65     	JP C,SUBSCRIPT_OUT_OF_RANGE
 806  65AE C9           	RET
 807  65AF              ; *******************************************************************************************************
 808  65AF               ENDIF
 809  65AF
 810  65AF              ; *******************************************************************************************************
 811  65AF              ; function to handle CALL ARTINFO basic extension
 812  65AF              ; returns info about the extension
 813  65AF              ; _ARTINFO ( INT variable version,
 814  65AF              ;			    INT variable build_flags,
 815  65AF              ;			    INT variable free_memory_ptr )
 816  65AF              ; this function is always available and can be used to test if the extension is active
 817  65AF              ARTINFO:
 818  65AF              	; opening (
 819  65AF CD 4D 65     	CALL CHKCHAR
 820  65B2 28           	DB '('
 821  65B3              	; get address of version variable
 822  65B3 DD 21 A4 5E  	LD IX, PTRGET
 823  65B7 CD 59 01     	CALL CALBAS
 824  65BA 3A 12 40     	LD A,(VERSION)
 825  65BD 12              LD (DE),A
 826  65BE 13              INC DE
 827  65BF 3A 13 40        LD A,(VERSION+1)
 828  65C2 12              LD (DE),A
 829  65C3              	; comma
 830  65C3 CD 4D 65     	CALL CHKCHAR
 831  65C6 2C           	DB ','
 832  65C7              	; get address of build flags variable
 833  65C7 DD 21 A4 5E  	LD IX, PTRGET
 834  65CB CD 59 01     	CALL CALBAS
 835  65CE E5              PUSH HL
 836  65CF 21 FF 07        LD HL,SOUND_CMDS+2*RAM_CMDS+4*VRAM_CMDS+8*BLIT_CMDS+16*SPRITE_CMDS+32*GENCAL_CMD+64*TILE_CMDS+128*BOX_CMDS+256*ANIM_CMDS+512*COLL_CMD+1024*1+2048*0
 837  65D2 EB              EX DE,HL
 838  65D3 73              LD (HL),E
 839  65D4 23              INC HL
 840  65D5 72              LD (HL),D
 841  65D6 E1              POP HL
 842  65D7              	; comma
 843  65D7 CD 4D 65     	CALL CHKCHAR
 844  65DA 2C           	DB ','
 845  65DB              	; get address of free memory variable
 846  65DB DD 21 A4 5E  	LD IX, PTRGET
 847  65DF CD 59 01     	CALL CALBAS
 848  65E2 3A 10 40     	LD A,(FREEMEMPTR)
 849  65E5 12              LD (DE),A
 850  65E6 13              INC DE
 851  65E7 3A 11 40        LD A,(FREEMEMPTR+1)
 852  65EA 12              LD (DE),A
 853  65EB              	; ending )
 854  65EB CD 4D 65     	CALL CHKCHAR
 855  65EE 29           	DB ')'
 856  65EF C9           	RET
 857  65F0              ; *******************************************************************************************************
 858  65F0
 859  65F0              EXT_END:
 860  65F0
# file closed: asm\main.asm
