# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		   EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000              COLL_CMD       EQU 1
  14  4000              DECOMP_CMDS    EQU 1
  15  4000
  16  4000              ; what to compile, provided in sjasmplus command line
  17  4000              ;BASIC_EXTENSION   EQU 1
  18  4000              ;DEFUSR_EXTENSION  EQU 0
  19  4000
  20  4000              CHPUT   EQU    #A2
  21  4000              CALBAS  EQU		#159
  22  4000              ERRHAND EQU    #406F
  23  4000              FRMEVL  EQU    #4C64
  24  4000              FRESTR  EQU		#67D0
  25  4000              ; FRMQNT = formula quantificator
  26  4000              ; input HL=pointer to current program expression
  27  4000              ; output HL=next address
  28  4000              ; output DE=integer datum
  29  4000              FRMQNT	EQU		#542F
  30  4000              ; GETBYT = get byte parameter
  31  4000              ; input HL=pointer to current program expression
  32  4000              ; output HL=next address
  33  4000              ; output A=E=byte read
  34  4000              GETBYT		EQU	#521C
  35  4000              CHRGTR  	   EQU   #4666
  36  4000              PTRGET		EQU 	#5EA4
  37  4000              SUBFLG		EQU	#F6A5
  38  4000              SYNCHR		EQU	#558C
  39  4000              VALTYP  	   EQU   #F663
  40  4000              DAC         EQU   #F7F6
  41  4000              USR     	   EQU   #F7F8
  42  4000              PROCNM		EQU	#FD89
  43  4000              BIOS_FILVRM EQU   #0056
  44  4000              CLIKSW		EQU	#F3DB
  45  4000
  46  4000              RAMAD0	   EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  47  4000              RAMAD1	   EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  48  4000              RAMAD2	   EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  49  4000              RAMAD3	   EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  50  4000              EXPTBL	   EQU   #FCC1
  51  4000              SCRMOD	   EQU   #FCAF ; current screen mode
  52  4000              REG1SAV     EQU   #F3E0 ; VDP(1)
  53  4000              JIFFY	      EQU   #FC9E
  54  4000              GRPPAT	   EQU   #F3CF ; SCREEN 2 sprite generator table address
  55  4000              GRPCGP		EQU	#F3CB ; SCREEN 2 pattern generator table address
  56  4000              GRPATR      EQU   #F3CD ; SCREEN 2 sprite attribute table address
  57  4000              T32PAT	   EQU   #F3C5 ; SCREEN 1 sprite generator table address
  58  4000              T32CGP      EQU   #F3C1 ; SCREEN 1 pattern ganarator table address
  59  4000              T32ATR      EQU   #F3C3 ; SCREEN 1 sprite attribute table address
  60  4000
  61  4000              ; BASIC error codes
  62  4000              ;01 NEXT without FOR
  63  4000              ;02 Syntax error
  64  4000              ;03 RETURN without GOSUB
  65  4000              ;04 Out of DATA
  66  4000              ;05 Illegal function call
  67  4000              ;06 Overflow
  68  4000              ;07 Out of memory
  69  4000              ;08 Undefined line number
  70  4000              ;09 Subscript out of range
  71  4000              ;10 Redimensioned array
  72  4000              ;11 Division by zero
  73  4000              ;12 Illegal direct
  74  4000              ;13 Type mismatch
  75  4000              ;14 Out of string space
  76  4000              ;15 String too long
  77  4000              ;16 String formula too complex
  78  4000              ;17 Can't CONTINUE
  79  4000              ;18 Undefined user function
  80  4000              ;19 Device I/O error
  81  4000              ;20 Verify error
  82  4000              ;21 No RESUME
  83  4000              ;22 RESUME without error
  84  4000              ;23 Unprintable error
  85  4000              ;24 Missing operand
  86  4000              ;25 Line buffer overflow
  87  4000              ;50 FIELD overflow
  88  4000              ;51 Internal error
  89  4000              ;52 Bad file number
  90  4000              ;53 File not found
  91  4000              ;54 File already open
  92  4000              ;55 Input past end
  93  4000              ;56 Bad file name
  94  4000              ;57 Direct statement in file
  95  4000              ;58 Sequential I/O only
  96  4000              ;59 File not OPEN
  97  4000
  98  4000
  99  4000               ; simulate cartridge with BASIC extension
 100  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
 100  4004 ED 65 00 00
 100  4008 00 00 00 00
 100  400C 00 00 00 00
 101  4010
 102  4010              ; this location #4010 stores last location used by basic extension
 103  4010              ; free memory after that point
 104  4010              FREEMEMPTR:
 105  4010 CE 66         DW EXT_END
 106  4012
 107  4012              ; this location #4012 stores extension version in DAA format
 108  4012              ; first byte is major version and second minor
 109  4012              VERSION:
 110  4012 00 92         DB #00, #92
 111  4014
 112  4014              ; this location #4014 contains a jump to entry point for DEFUSR approach
 113  4014              ; if excluded it contains 3xRET so that sound player can be at aspecific spot
 114  4014               IF (0 == 1)
 115  4014 ~               JP DEFUSR_ENTRY
 116  4014               ELSE
 117  4014 C9          > RET
 117  4015 C9          > RET
 117  4016 C9          > RET
 118  4017               ENDIF
 119  4017
 120  4017              ; binary included AKG player compiled at #4017
 121  4017               IF (SOUND_CMDS == 1)
 122  4017              	INCBIN "bin/AKG.bin"
 123  4CF3              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF3              MAIN_PLAYER_START EQU 04017H
   2+ 4CF3              PLY_AKG_START EQU 04017H
   3+ 4CF3              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 04020H
   4+ 4CF3              PLY_AKG_INITSOUNDEFFECTS EQU 04020H
   5+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04024H
   6+ 4CF3              PLY_AKG_PLAYSOUNDEFFECT EQU 04024H
   7+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04025H
   8+ 4CF3              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04025H
   9+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 0404CH
  10+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 0404CH
  11+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 0405AH
  12+ 4CF3              PLY_AKG_PSES_PLAY EQU 04093H
  13+ 4CF3              PLY_AKG_PSES_READFIRSTBYTE EQU 0409CH
  14+ 4CF3              PLY_AKG_PSES_S_ENDORLOOP EQU 040B4H
  15+ 4CF3              PLY_AKG_PSES_S_LOOP EQU 040BFH
  16+ 4CF3              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C5H
  17+ 4CF3              PLY_AKG_PSES_NOTREACHED EQU 040D8H
  18+ 4CF3              PLY_AKG_PSES_HARDWAREONLY EQU 040DCH
  19+ 4CF3              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E3H
  20+ 4CF3              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F5H
  21+ 4CF3              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FFH
  22+ 4CF3              PLY_AKG_PSES_H_AFTERRETRIG EQU 04109H
  23+ 4CF3              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411DH
  24+ 4CF3              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 04122H
  25+ 4CF3              PLY_AKG_PSES_READHARDWAREPERIOD EQU 0412AH
  26+ 4CF3              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04135H
  27+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 04141H
  28+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04143H
  29+ 4CF3              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04149H
  30+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414DH
  31+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414DH
  32+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414FH
  33+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414FH
  34+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414FH
  35+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 04150H
  36+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 04151H
  37+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04155H
  38+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04155H
  39+ 4CF3              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04155H
  40+ 4CF3              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415DH
  41+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04165H
  42+ 4CF3              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04165H
  43+ 4CF3              PLY_AKG_INIT EQU 04165H
  44+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04165H
  45+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04193H
  46+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A7H
  47+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B9H
  48+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D8H
  49+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E5H
  50+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL EQU 041EBH
  51+ 4CF3              PLY_AKG_INITTABLE0 EQU 041EEH
  52+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EEH
  53+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04208H
  54+ 4CF3              PLY_AKG_INITTABLE0_END EQU 04208H
  55+ 4CF3              PLY_AKG_INITTABLE1 EQU 04208H
  56+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04208H
  57+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 0420CH
  58+ 4CF3              PLY_AKG_INITTABLE1_END EQU 0420CH
  59+ 4CF3              PLY_AKG_INITTABLEORA EQU 0420CH
  60+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 0420CH
  61+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04224H
  62+ 4CF3              PLY_AKG_INITTABLEORA_END EQU 04224H
  63+ 4CF3              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04224H
  64+ 4CF3              PLY_AKG_STOP EQU 04224H
  65+ 4CF3              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04236H
  66+ 4CF3              PLY_AKG_PLAY EQU 04236H
  67+ 4CF3              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423EH
  68+ 4CF3              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04244H
  69+ 4CF3              PLY_AKG_READLINKER EQU 04249H
  70+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04249H
  71+ 4CF3              PLY_AKG_READLINKER_PTLINKER EQU 04249H
  72+ 4CF3              PLY_AKG_READLINKER_NOLOOP EQU 04254H
  73+ 4CF3              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428DH
  74+ 4CF3              PLY_AKG_READLINE EQU 04290H
  75+ 4CF3              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 04290H
  76+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04296H
  77+ 4CF3              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04296H
  78+ 4CF3              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A3H
  79+ 4CF3              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A7H
  80+ 4CF3              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042AAH
  81+ 4CF3              PLY_AKG_SPEEDTRACK_END EQU 042ADH
  82+ 4CF3              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042ADH
  83+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B3H
  84+ 4CF3              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B3H
  85+ 4CF3              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042C0H
  86+ 4CF3              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C4H
  87+ 4CF3              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C7H
  88+ 4CF3              PLY_AKG_EVENTTRACK_END EQU 042CAH
  89+ 4CF3              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042CAH
  90+ 4CF3              PLY_AKG_CHANNEL1_READTRACK EQU 042D6H
  91+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D6H
  92+ 4CF3              PLY_AKG_CHANNEL1_PTTRACK EQU 042D6H
  93+ 4CF3              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042F1H
  94+ 4CF3              PLY_AKG_CHANNEL1_WAIT EQU 042FCH
  95+ 4CF3              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04303H
  96+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04303H
  97+ 4CF3              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04303H
  98+ 4CF3              PLY_AKG_CHANNEL1_NOTE EQU 0430CH
  99+ 4CF3              PLY_AKG_BASENOTEINDEX EQU 0430CH
 100+ 4CF3              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430EH
 101+ 4CF3              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430EH
 102+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431EH
 103+ 4CF3              PLY_AKG_INSTRUMENTSTABLE EQU 0431EH
 104+ 4CF3              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 04330H
 105+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 04340H
 106+ 4CF3              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04368H
 107+ 4CF3              PLY_AKG_CHANNEL1_READCELLEND EQU 0436BH
 108+ 4CF3              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 0436BH
 109+ 4CF3              PLY_AKG_CHANNEL2_READTRACK EQU 04377H
 110+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04377H
 111+ 4CF3              PLY_AKG_CHANNEL2_PTTRACK EQU 04377H
 112+ 4CF3              PLY_AKG_CHANNEL2_SMALLWAIT EQU 04392H
 113+ 4CF3              PLY_AKG_CHANNEL2_WAIT EQU 0439DH
 114+ 4CF3              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A4H
 115+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A4H
 116+ 4CF3              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A4H
 117+ 4CF3              PLY_AKG_CHANNEL2_NOTE EQU 043ADH
 118+ 4CF3              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043B2H
 119+ 4CF3              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043B2H
 120+ 4CF3              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D4H
 121+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E4H
 122+ 4CF3              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 0440CH
 123+ 4CF3              PLY_AKG_CHANNEL2_READCELLEND EQU 0440FH
 124+ 4CF3              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440FH
 125+ 4CF3              PLY_AKG_CHANNEL3_READTRACK EQU 0441BH
 126+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 0441BH
 127+ 4CF3              PLY_AKG_CHANNEL3_PTTRACK EQU 0441BH
 128+ 4CF3              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04436H
 129+ 4CF3              PLY_AKG_CHANNEL3_WAIT EQU 04441H
 130+ 4CF3              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04448H
 131+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04448H
 132+ 4CF3              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04448H
 133+ 4CF3              PLY_AKG_CHANNEL3_NOTE EQU 04451H
 134+ 4CF3              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04456H
 135+ 4CF3              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04456H
 136+ 4CF3              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04478H
 137+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04488H
 138+ 4CF3              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044B0H
 139+ 4CF3              PLY_AKG_CHANNEL3_READCELLEND EQU 044B3H
 140+ 4CF3              PLY_AKG_CURRENTSPEED EQU 044B3H
 141+ 4CF3              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B5H
 142+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B8H
 143+ 4CF3              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B8H
 144+ 4CF3              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044BBH
 145+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BEH
 146+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BEH
 147+ 4CF3              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044CAH
 148+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044D1H
 149+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D4H
 150+ 4CF3              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044DAH
 151+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DDH
 152+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DDH
 153+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044EBH
 154+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044F0H
 155+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044FBH
 156+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FEH
 157+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FEH
 158+ 4CF3              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 04501H
 159+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04504H
 160+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04504H
 161+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450DH
 162+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04517H
 163+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 0451AH
 164+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 0451AH
 165+ 4CF3              PLY_AKG_CHANNEL1_PITCH EQU 0451AH
 166+ 4CF3              PLY_AKG_CHANNEL1_ISPITCH EQU 0451DH
 167+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 04522H
 168+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACK EQU 04522H
 169+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04526H
 170+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04528H
 171+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 0452AH
 172+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 04531H
 173+ 4CF3              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 04532H
 174+ 4CF3              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04535H
 175+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04535H
 176+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 04551H
 177+ 4CF3              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 04551H
 178+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455EH
 179+ 4CF3              PLY_AKG_CHANNEL1_GLIDEOVER EQU 04562H
 180+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 04572H
 181+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 04572H
 182+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04573H
 183+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04574H
 184+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04576H
 185+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04576H
 186+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04576H
 187+ 4CF3              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04577H
 188+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04578H
 189+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 0457AH
 190+ 4CF3              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 0457AH
 191+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 0457AH
 192+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 0457AH
 193+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 0457AH
 194+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457DH
 195+ 4CF3              PLY_AKG_CHANNEL1_PITCH_END EQU 0457FH
 196+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04587H
 197+ 4CF3              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04587H
 198+ 4CF3              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 0458AH
 199+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458DH
 200+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458DH
 201+ 4CF3              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04599H
 202+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 045A0H
 203+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A3H
 204+ 4CF3              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A9H
 205+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045ACH
 206+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045ACH
 207+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045BAH
 208+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BFH
 209+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045CAH
 210+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CDH
 211+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CDH
 212+ 4CF3              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045D0H
 213+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D3H
 214+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D3H
 215+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045DCH
 216+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E6H
 217+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E9H
 218+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E9H
 219+ 4CF3              PLY_AKG_CHANNEL2_PITCH EQU 045E9H
 220+ 4CF3              PLY_AKG_CHANNEL2_ISPITCH EQU 045ECH
 221+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045F1H
 222+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045F1H
 223+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F5H
 224+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F7H
 225+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F9H
 226+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 04600H
 227+ 4CF3              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 04601H
 228+ 4CF3              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04604H
 229+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04604H
 230+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 04620H
 231+ 4CF3              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 04620H
 232+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462DH
 233+ 4CF3              PLY_AKG_CHANNEL2_GLIDEOVER EQU 04631H
 234+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 04641H
 235+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 04641H
 236+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 04642H
 237+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04643H
 238+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04645H
 239+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04645H
 240+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04645H
 241+ 4CF3              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04646H
 242+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04647H
 243+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04649H
 244+ 4CF3              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04649H
 245+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04649H
 246+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04649H
 247+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04649H
 248+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_END EQU 0464CH
 249+ 4CF3              PLY_AKG_CHANNEL2_PITCH_END EQU 0464EH
 250+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04656H
 251+ 4CF3              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04656H
 252+ 4CF3              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04659H
 253+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 0465CH
 254+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 0465CH
 255+ 4CF3              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04668H
 256+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466FH
 257+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 04672H
 258+ 4CF3              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04678H
 259+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 0467BH
 260+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 0467BH
 261+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04689H
 262+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468EH
 263+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04699H
 264+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 0469CH
 265+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 0469CH
 266+ 4CF3              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469FH
 267+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 046A2H
 268+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE EQU 046A2H
 269+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046ABH
 270+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B5H
 271+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B8H
 272+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B8H
 273+ 4CF3              PLY_AKG_CHANNEL3_PITCH EQU 046B8H
 274+ 4CF3              PLY_AKG_CHANNEL3_ISPITCH EQU 046BBH
 275+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046C0H
 276+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046C0H
 277+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C4H
 278+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C6H
 279+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C8H
 280+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CFH
 281+ 4CF3              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046D0H
 282+ 4CF3              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D3H
 283+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D3H
 284+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046EFH
 285+ 4CF3              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046EFH
 286+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046FCH
 287+ 4CF3              PLY_AKG_CHANNEL3_GLIDEOVER EQU 04700H
 288+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 04710H
 289+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 04710H
 290+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 04711H
 291+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 04712H
 292+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04714H
 293+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04714H
 294+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04714H
 295+ 4CF3              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04715H
 296+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04716H
 297+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04718H
 298+ 4CF3              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04718H
 299+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04718H
 300+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04718H
 301+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04718H
 302+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_END EQU 0471BH
 303+ 4CF3              PLY_AKG_CHANNEL3_PITCH_END EQU 0471DH
 304+ 4CF3              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04729H
 305+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04729H
 306+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04729H
 307+ 4CF3              PLY_AKG_CHANNEL1_TRACKNOTE EQU 0472CH
 308+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472EH
 309+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04734H
 310+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04737H
 311+ 4CF3              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04737H
 312+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 0473AH
 313+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04743H
 314+ 4CF3              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 0474BH
 315+ 4CF3              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04758H
 316+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04758H
 317+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04758H
 318+ 4CF3              PLY_AKG_CHANNEL2_TRACKNOTE EQU 0475BH
 319+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475DH
 320+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04763H
 321+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04766H
 322+ 4CF3              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04766H
 323+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04769H
 324+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 04772H
 325+ 4CF3              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 0477AH
 326+ 4CF3              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04788H
 327+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04788H
 328+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04788H
 329+ 4CF3              PLY_AKG_CHANNEL3_TRACKNOTE EQU 0478BH
 330+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478DH
 331+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04793H
 332+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04796H
 333+ 4CF3              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04796H
 334+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04799H
 335+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 047A2H
 336+ 4CF3              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047AAH
 337+ 4CF3              PLY_AKG_SENDPSGREGISTERS EQU 047B9H
 338+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047C1H
 339+ 4CF3              PLY_AKG_PSGREG01_INSTR EQU 047C1H
 340+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047D1H
 341+ 4CF3              PLY_AKG_PSGREG23_INSTR EQU 047D1H
 342+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047E2H
 343+ 4CF3              PLY_AKG_PSGREG45_INSTR EQU 047E2H
 344+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F3H
 345+ 4CF3              PLY_AKG_PSGREG6_8_INSTR EQU 047F3H
 346+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04804H
 347+ 4CF3              PLY_AKG_PSGREG9_10_INSTR EQU 04804H
 348+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04815H
 349+ 4CF3              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04815H
 350+ 4CF3              PLY_AKG_PSGREG13_OLDVALUE EQU 0482AH
 351+ 4CF3              PLY_AKG_RETRIG EQU 0482CH
 352+ 4CF3              PLY_AKG_PSGREG13_INSTR EQU 0482EH
 353+ 4CF3              PLY_AKG_PSGREG13_END EQU 0483DH
 354+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483DH
 355+ 4CF3              PLY_AKG_SAVESP EQU 0483DH
 356+ 4CF3              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 04841H
 357+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTS EQU 04849H
 358+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04856H
 359+ 4CF3              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04856H
 360+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485EH
 361+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 0486BH
 362+ 4CF3              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 0486BH
 363+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTS EQU 04873H
 364+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487EH
 365+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS EQU 0487EH
 366+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488DH
 367+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488DH
 368+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04894H
 369+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A4H
 370+ 4CF3              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A4H
 371+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048ABH
 372+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048ABH
 373+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048AEH
 374+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B7H
 375+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B7H
 376+ 4CF3              PLY_AKG_READINSTRUMENTCELL EQU 048BDH
 377+ 4CF3              PLY_AKG_NOSOFTNOHARD EQU 048CAH
 378+ 4CF3              PLY_AKG_NSNH_NONOISE EQU 048DFH
 379+ 4CF3              PLY_AKG_SOFT EQU 048E2H
 380+ 4CF3              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E9H
 381+ 4CF3              PLY_AKG_S_NOTSIMPLE EQU 048F1H
 382+ 4CF3              PLY_AKG_S_AFTERSIMPLETEST EQU 048F4H
 383+ 4CF3              PLY_AKG_HARDTOSOFT EQU 04901H
 384+ 4CF3              PLY_AKG_HS_JUMPRATIO EQU 0490CH
 385+ 4CF3              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04939H
 386+ 4CF3              PLY_AKG_ENDWITHOUTLOOP EQU 0493BH
 387+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 0493BH
 388+ 4CF3              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 0493BH
 389+ 4CF3              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04943H
 390+ 4CF3              PLY_AKG_SH_JUMPRATIO EQU 04950H
 391+ 4CF3              PLY_AKG_SH_JUMPRATIOEND EQU 04971H
 392+ 4CF3              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 04980H
 393+ 4CF3              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04986H
 394+ 4CF3              PLY_AKG_H_OR_ENDWITHLOOP EQU 049A0H
 395+ 4CF3              PLY_AKG_H_RETRIGEND EQU 049B2H
 396+ 4CF3              PLY_AKG_H_AFTERRETRIG EQU 049B3H
 397+ 4CF3              PLY_AKG_ENDWITHLOOP EQU 049C5H
 398+ 4CF3              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049CCH
 399+ 4CF3              PLY_AKG_S_OR_H_NEXTBYTE EQU 049E2H
 400+ 4CF3              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049F0H
 401+ 4CF3              PLY_AKG_S_OR_H_AFTERPITCH EQU 04A00H
 402+ 4CF3              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0EH
 403+ 4CF3              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1DH
 404+ 4CF3              PLY_AKG_SHOHS_RETRIGEND EQU 04A2CH
 405+ 4CF3              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2DH
 406+ 4CF3              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3FH
 407+ 4CF3              PLY_AKG_EFFECTTABLE EQU 04A4DH
 408+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4DH
 409+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A71H
 410+ 4CF3              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A71H
 411+ 4CF3              PLY_AKG_EFFECT_RESET EQU 04A74H
 412+ 4CF3              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A76H
 413+ 4CF3              PLY_AKG_EFFECT_VOLUME EQU 04A91H
 414+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9DH
 415+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA3H
 416+ 4CF3              PLY_AKG_ARPEGGIOSTABLE EQU 04AA3H
 417+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04ACAH
 418+ 4CF3              PLY_AKG_EFFECT_PITCHTABLE EQU 04AD1H
 419+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD7H
 420+ 4CF3              PLY_AKG_PITCHESTABLE EQU 04AD7H
 421+ 4CF3              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFEH
 422+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B05H
 423+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B16H
 424+ 4CF3              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1DH
 425+ 4CF3              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2DH
 426+ 4CF3              PLY_AKG_EFFECT_PITCHUP EQU 04B42H
 427+ 4CF3              PLY_AKG_EFFECT_PITCHSTOP EQU 04B54H
 428+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B5BH
 429+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B85H
 430+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B85H
 431+ 4CF3              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9EH
 432+ 4CF3              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9EH
 433+ 4CF3              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BB0H
 434+ 4CF3              PLY_AKG_EFFECT_LEGATO EQU 04BC6H
 435+ 4CF3              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BDAH
 436+ 4CF3              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BE2H
 437+ 4CF3              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BEAH
 438+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BF2H
 439+ 4CF3              PLY_AKG_EVENT EQU 04BF2H
 440+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF3H
 441+ 4CF3              PLY_AKG_PERIODTABLE EQU 04BF3H
 442+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF3H
 443+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF3H
 444+ 4CF3              PLY_AKG_PERIODTABLE_END EQU 04CF3H
 445+ 4CF3              PLY_AKG_END EQU 04CF3H
 446+ 4CF3              MAIN_PLAYER_END EQU 04CF3H
 447+ 4CF3              TESTEREND EQU 04CF3H
 448+ 4CF3
# file closed: ./symbol/AKG.sym
 124  4CF3               ENDIF
 125  4CF3
 126  4CF3               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
   1+ 4CF3              ORIG.HTIMI:
   2+ 4CF3 00 00 00 00  	DB 0, 0, 0, 0, 0
   2+ 4CF7 00
   3+ 4CF8               EXPORT ORIG.HTIMI
   4+ 4CF8
   5+ 4CF8              ; *******************************************************************************************************
   6+ 4CF8              ; interrupt handler when page 0 enabled
   7+ 4CF8              ; we are here only if one of the extended basic commands have paged in page 0
   8+ 4CF8              ; which means we arrived from BASIC so page 2 is already good
   9+ 4CF8              VBLANK:
  10+ 4CF8              	EXPORT VBLANK
  11+ 4CF8
  12+ 4CF8 F5               PUSH AF
  13+ 4CF9              	; is VDP originator ?
  14+ 4CF9 DB 99        	IN	A, (099H)
  15+ 4CFB A7           	AND	A
  16+ 4CFC F2 23 4D     	JP P, .EXIT
  17+ 4CFF
  18+ 4CFF               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  19+ 4CFF C5               PUSH BC
  20+ 4D00 D5               PUSH DE
  21+ 4D01 E5               PUSH HL
  22+ 4D02 08               EX AF, AF'
  23+ 4D03 D9               EXX
  24+ 4D04 F5               PUSH AF
  25+ 4D05 C5               PUSH BC
  26+ 4D06 D5               PUSH DE
  27+ 4D07 E5               PUSH HL
  28+ 4D08 DD E5            PUSH IX
  29+ 4D0A FD E5            PUSH IY
  30+ 4D0C
  31+ 4D0C               IF (SPRITE_CMDS == 1)
  32+ 4D0C CD 5D 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  33+ 4D0F               ENDIF
  34+ 4D0F
  35+ 4D0F               IF (SOUND_CMDS == 1)
  36+ 4D0F 3A CA 58     	LD A, (SOUND_ENABLED)
  37+ 4D12 B7           	OR A
  38+ 4D13 C4 36 42     	CALL NZ,PLY_AKG_PLAY
  39+ 4D16               ENDIF
  40+ 4D16
  41+ 4D16                  ; increase JIFFY
  42+ 4D16                  ;LD HL,(JIFFY)
  43+ 4D16                  ;INC HL
  44+ 4D16                  ;LD (JIFFY),HL
  45+ 4D16
  46+ 4D16 FD E1            POP IY
  47+ 4D18 DD E1            POP IX
  48+ 4D1A E1               POP HL
  49+ 4D1B D1               POP DE
  50+ 4D1C C1               POP BC
  51+ 4D1D F1               POP AF
  52+ 4D1E 08               EX AF, AF'
  53+ 4D1F D9               EXX
  54+ 4D20 E1               POP HL
  55+ 4D21 D1               POP DE
  56+ 4D22 C1               POP BC
  57+ 4D23               ENDIF
  58+ 4D23
  59+ 4D23              .EXIT:
  60+ 4D23 F1           	POP AF
  61+ 4D24 FB           	EI
  62+ 4D25 ED 4D        	RETI
  63+ 4D27              ; *******************************************************************************************************
  64+ 4D27
  65+ 4D27              ; *******************************************************************************************************
  66+ 4D27              ; H.TIMI function
  67+ 4D27              ; we can end up here from anywhere so page in both page 0 and 2
  68+ 4D27              MBGE_HTIMI:
  69+ 4D27               EXPORT MBGE_HTIMI
  70+ 4D27
  71+ 4D27               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  72+ 4D27
  73+ 4D27 F5           	PUSH AF
  74+ 4D28
  75+ 4D28              	; enable page 2
  76+ 4D28 3E 02            LD A, 2
  77+ 4D2A CD 1C 65         CALL GET_PAGE_INFO
  78+ 4D2D C5               PUSH BC
  79+ 4D2E D5               PUSH DE
  80+ 4D2F 3A 43 F3         LD A, (RAMAD2)
  81+ 4D32 26 80            LD H, 080H
  82+ 4D34 CD 63 65         CALL LOCAL_ENASLT
  83+ 4D37              	; enable page 0
  84+ 4D37 AF               XOR A
  85+ 4D38 CD 1C 65         CALL GET_PAGE_INFO
  86+ 4D3B C5               PUSH BC
  87+ 4D3C D5               PUSH DE
  88+ 4D3D 3A 41 F3         LD A, (RAMAD0)
  89+ 4D40 26 00            LD H, 0
  90+ 4D42 CD 63 65         CALL LOCAL_ENASLT
  91+ 4D45
  92+ 4D45               IF (SPRITE_CMDS == 1)
  93+ 4D45 CD 5D 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  94+ 4D48               ENDIF
  95+ 4D48
  96+ 4D48               IF (SOUND_CMDS == 1)
  97+ 4D48 3A CA 58     	LD A, (SOUND_ENABLED)
  98+ 4D4B B7           	OR A
  99+ 4D4C C4 36 42     	CALL NZ,PLY_AKG_PLAY
 100+ 4D4F               ENDIF
 101+ 4D4F
 102+ 4D4F              	; restore page 0
 103+ 4D4F D1               POP DE
 104+ 4D50 C1               POP BC
 105+ 4D51 CD 53 65         CALL RESTORE_PAGE_INFO
 106+ 4D54              	; restore page 2
 107+ 4D54 D1               POP DE
 108+ 4D55 C1               POP BC
 109+ 4D56 CD 53 65         CALL RESTORE_PAGE_INFO
 110+ 4D59
 111+ 4D59 F1           	POP AF
 112+ 4D5A               ENDIF
 113+ 4D5A C3 F3 4C     	JP ORIG.HTIMI
 114+ 4D5D              ; *******************************************************************************************************
 115+ 4D5D
 116+ 4D5D              ; *******************************************************************************************************
 117+ 4D5D              ; function checks if the sprite system is initialized and what screen mode we are running
 118+ 4D5D              ; also checks if some VRAM modifying command is running
 119+ 4D5D              ; when that checks out calls sprite updates and animation processing
 120+ 4D5D              ; if in an unsupported mode disables sprite handling
 121+ 4D5D              PROCESS_SPRITES_AND_ANIMATIONS:
 122+ 4D5D              	; check if initialized
 123+ 4D5D 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
 124+ 4D60 B7           	OR A
 125+ 4D61 C8           	RET Z
 126+ 4D62              	; check screen mode
 127+ 4D62 3A AF FC     	LD A, (SCRMOD)
 128+ 4D65 3D           	DEC A
 129+ 4D66 28 08        	JR Z, .L0 ; screen 1
 130+ 4D68 3D           	DEC A
 131+ 4D69 28 05            JR Z, .L0 ; screen 2
 132+ 4D6B              	; unsupported screen mode, disable
 133+ 4D6B AF               XOR A
 134+ 4D6C 32 7F 4D         LD (SPRATR_INIT_STATUS),A
 135+ 4D6F C9               RET
 136+ 4D70              .L0:
 137+ 4D70                  ; check if anyone else is working with VRAM
 138+ 4D70 3A 21 63         LD A,(VRAM_UPDATE_IN_PROGRESS)
 139+ 4D73 B7               OR A
 140+ 4D74 C0               RET NZ
 141+ 4D75
 142+ 4D75 CD 95 4D         CALL SPRATR_UPDATE
 143+ 4D78
 144+ 4D78               IF (ANIM_CMDS == 1)
 145+ 4D78 CD 76 55         CALL PROCESS_ANIMATIONS
 146+ 4D7B CD 41 57         CALL PROCESS_AUTOSGAMS
 147+ 4D7E               ENDIF
 148+ 4D7E C9               RET
 149+ 4D7F              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
 127  4D7F
 128  4D7F               IF (SPRITE_CMDS == 1)
 129  4D7F               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4D7F              ; commands and variables related to sprites
   2+ 4D7F
   3+ 4D7F              SPRATR_INIT_STATUS:
   4+ 4D7F 00            DB 0
   5+ 4D80              SPRATR_UPDATE_FLAG:
   6+ 4D80 00 00         DW 0
   7+ 4D82              SPRATR_DATA:
   8+ 4D82 00 00         DW 0
   9+ 4D84              SPRFLICKER_ENABLED:
  10+ 4D84 00            DB 0
  11+ 4D85              ; to support sprite flicker
  12+ 4D85              FLICKER:
  13+ 4D85 00            DB 0
  14+ 4D86              NUM_SPRITES_HANDLED:
  15+ 4D86 20            DB 32
  16+ 4D87
  17+ 4D87              ; to temporarily store stack pointer
  18+ 4D87              TMPSP:
  19+ 4D87 00 00         DW 0
  20+ 4D89
  21+ 4D89              ; *******************************************************************************************************
  22+ 4D89              ; helper function gets pointer to n-th entry in sprite attributes
  23+ 4D89              ; changes HL,DE
  24+ 4D89              GETnthSPRATTR:
  25+ 4D89 26 00            LD H,0
  26+ 4D8B 6F               LD L,A
  27+ 4D8C CD 18 65         CALL HLx8
  28+ 4D8F ED 5B 82 4D      LD DE,(SPRATR_DATA)
  29+ 4D93 19               ADD HL,DE
  30+ 4D94 C9               RET
  31+ 4D95              ; *******************************************************************************************************
  32+ 4D95
  33+ 4D95              ; *******************************************************************************************************
  34+ 4D95              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  35+ 4D95              ; struct {
  36+ 4D95              ; DW y
  37+ 4D95              ; DW x
  38+ 4D95              ; DW pattern (0-63)
  39+ 4D95              ; DW color
  40+ 4D95              ; } [32]
  41+ 4D95              ; will hide sprites whose location is outside of visible area
  42+ 4D95              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  43+ 4D95              ; modifies AF, AF', BC, DE, HL, IX
  44+ 4D95              SPRATR_UPDATE:
  45+ 4D95              	; check if update requested
  46+ 4D95 2A 80 4D     	LD HL, (SPRATR_UPDATE_FLAG)
  47+ 4D98 7E           	LD A, (HL)
  48+ 4D99 B7           	OR A
  49+ 4D9A C8           	RET Z
  50+ 4D9B
  51+ 4D9B DD 21 86 4D  	LD IX,NUM_SPRITES_HANDLED
  52+ 4D9F DD 46 00     	LD B, (IX) ; sprite number
  53+ 4DA2 0E 98        	LD C, #98 ; register for vdp data output
  54+ 4DA4              	; set VDP address
  55+ 4DA4 3A AF FC         LD A,(SCRMOD)
  56+ 4DA7 3D               DEC A
  57+ 4DA8 20 05            JR NZ,.L4
  58+ 4DAA 2A C3 F3         LD HL, (T32ATR)
  59+ 4DAD 18 03            JR .L5
  60+ 4DAF              .L4:
  61+ 4DAF 2A CD F3         LD HL, (GRPATR)
  62+ 4DB2              .L5:
  63+ 4DB2 3A 84 4D     	LD A, (SPRFLICKER_ENABLED)
  64+ 4DB5 B7           	OR A
  65+ 4DB6 28 03        	JR Z, .L3
  66+ 4DB8 3A 85 4D     	LD A, (FLICKER)
  67+ 4DBB              .L3:
  68+ 4DBB 5F           	LD E, A
  69+ 4DBC 08           	EX AF, AF'
  70+ 4DBD 7B           	LD A, E
  71+ 4DBE 87           	ADD A, A
  72+ 4DBF 87           	ADD A, A
  73+ 4DC0 16 00        	LD D, 0
  74+ 4DC2 5F           	LD E, A
  75+ 4DC3 19           	ADD HL, DE
  76+ 4DC4 CD 03 65     	CALL SETWRT_LOCAL
  77+ 4DC7 ED 73 87 4D  	LD (TMPSP), SP
  78+ 4DCB ED 7B 82 4D  	LD SP, (SPRATR_DATA)
  79+ 4DCF
  80+ 4DCF              .LOOP:
  81+ 4DCF E1           	POP HL
  82+ 4DD0 24           	INC H
  83+ 4DD1 28 0D        	JR Z, .L1 ; negative number between -256 and -1
  84+ 4DD3 25           	DEC H
  85+ 4DD4 20 15        	JR NZ, .OUT3 ; sprite vertically can't be visible
  86+ 4DD6 7D           	LD A, L
  87+ 4DD7 FE C0        	CP 192
  88+ 4DD9 30 10        	JR NC, .OUT3
  89+ 4DDB 3D           	DEC A ; due to VDP rule that top of screen is -1
  90+ 4DDC 57           	LD D, A
  91+ 4DDD C3 04 4E     	JP .X
  92+ 4DE0              .L1:
  93+ 4DE0 7D           	LD A, L
  94+ 4DE1 C6 10        	ADD 16
  95+ 4DE3 FA EB 4D     	JP M, .OUT3 ; below -16
  96+ 4DE6 2D           	DEC L ; due to VDP rule that top of screen is -1
  97+ 4DE7 55           	LD D, L
  98+ 4DE8 C3 04 4E     	JP .X
  99+ 4DEB              .OUT3:
 100+ 4DEB E1           	POP HL ; skip x value
 101+ 4DEC              .OUT2:
 102+ 4DEC E1           	POP HL ; skip pattern
 103+ 4DED E1           	POP HL ; skip color
 104+ 4DEE 3E D1        	LD A, #D1
 105+ 4DF0 ED 79        	OUT (C), A ; sprite hidden
 106+ 4DF2 00          > NOP
 106+ 4DF3 00          > NOP
 106+ 4DF4 00          > NOP
 107+ 4DF5 ED 79        	OUT (C), A ; value unimportant
 108+ 4DF7 00          > NOP
 108+ 4DF8 00          > NOP
 108+ 4DF9 00          > NOP
 109+ 4DFA ED 79        	OUT (C), A ; value unimportant
 110+ 4DFC 00          > NOP
 110+ 4DFD 00          > NOP
 110+ 4DFE 00          > NOP
 111+ 4DFF ED 79        	OUT (C), A ; value unimportant
 112+ 4E01 C3 2F 4E     	JP .NEXT
 113+ 4E04              .X:
 114+ 4E04 E1           	POP HL
 115+ 4E05 24           	INC H
 116+ 4E06 28 08        	JR Z, .L2
 117+ 4E08 25           	DEC H
 118+ 4E09 20 E1        	JR NZ, .OUT2
 119+ 4E0B 1E 00        	LD E, 0 ; EC bit
 120+ 4E0D C3 19 4E     	JP .XY
 121+ 4E10              .L2:
 122+ 4E10 7D           	LD A, L
 123+ 4E11 C6 20        	ADD 32
 124+ 4E13 FA EC 4D     	JP M, .OUT2
 125+ 4E16 6F           	LD L, A
 126+ 4E17 1E 80        	LD E, #80
 127+ 4E19              .XY:
 128+ 4E19 ED 51        	OUT (C), D
 129+ 4E1B 3A E0 F3     	LD A, (REG1SAV)
 130+ 4E1E E6 02        	AND 2
 131+ 4E20 ED 69        	OUT (C), L
 132+ 4E22 E1           	POP HL ; pattern
 133+ 4E23 7D           	LD A, L
 134+ 4E24 28 02        	JR Z, .SMALLSPRITES
 135+ 4E26 87           	ADD A, A
 136+ 4E27 87           	ADD A, A ; needs to go at 4x
 137+ 4E28              .SMALLSPRITES:
 138+ 4E28 D3 98        	OUT (#98), A
 139+ 4E2A E1           	POP HL ; color
 140+ 4E2B 7D           	LD A, L
 141+ 4E2C B3           	OR E
 142+ 4E2D D3 98        	OUT (#98), A
 143+ 4E2F              .NEXT:
 144+ 4E2F 08           	EX AF, AF'
 145+ 4E30 3C           	INC A ; increase current sprite
 146+ 4E31 DD BE 00     	CP (IX) ; compare to maximum handled
 147+ 4E34 C2 54 4E     	JP NZ, .NEXT2 ; continue if not over
 148+ 4E37 AF           	XOR A ; back to zero
 149+ 4E38 08           	EX AF, AF'
 150+ 4E39 3A AF FC         LD A,(SCRMOD)
 151+ 4E3C 3D               DEC A
 152+ 4E3D 20 05            JR NZ,.L6
 153+ 4E3F 2A C3 F3         LD HL, (T32ATR)
 154+ 4E42 18 03            JR .L7
 155+ 4E44              .L6:
 156+ 4E44 2A CD F3         LD HL, (GRPATR)
 157+ 4E47              .L7:
 158+ 4E47              	; CALL SETWRT_LOCAL not allowed as SP modified
 159+ 4E47 7D           	LD	A, L
 160+ 4E48 D3 99        	OUT	(099H), A
 161+ 4E4A 7C           	LD	A, H
 162+ 4E4B E6 3F        	AND	03FH
 163+ 4E4D F6 40        	OR	040H
 164+ 4E4F D3 99        	OUT	(099H), A
 165+ 4E51 C3 55 4E     	JP .NEXT3
 166+ 4E54              .NEXT2:
 167+ 4E54 08           	EX AF, AF'
 168+ 4E55              .NEXT3:
 169+ 4E55 05           	DEC B
 170+ 4E56 C2 CF 4D     	JP NZ, .LOOP
 171+ 4E59 08           	EX AF, AF'
 172+ 4E5A 3C           	INC A ; increase flicker to start at the next one on next vblank
 173+ 4E5B DD BE 00     	CP (IX)
 174+ 4E5E 20 01        	JR NZ,.L8
 175+ 4E60 AF           	XOR A
 176+ 4E61              .L8:
 177+ 4E61 32 85 4D     	LD (FLICKER), A
 178+ 4E64
 179+ 4E64 ED 7B 87 4D  	LD SP, (TMPSP)
 180+ 4E68 2A 80 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 181+ 4E6B 36 00        	LD (HL), 0 ; zero out update flag
 182+ 4E6D C9           	RET
 183+ 4E6E              ; *******************************************************************************************************
 184+ 4E6E
 185+ 4E6E               IF (1 == 1)
 186+ 4E6E              ; *******************************************************************************************************
 187+ 4E6E              ; function to handle CALL SPRENABLE basic extension
 188+ 4E6E              ; initializes sprites handler
 189+ 4E6E              ; _SPRENABLE ( INT[3][31] variable sprites_attributes,
 190+ 4E6E              ;			   INT variable update_variable,
 191+ 4E6E              ;			   BYTE sprite_flicker_enabled,
 192+ 4E6E              ;			   BYTE num_sprites_handled )
 193+ 4E6E              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA, SPRFLICKER_ENABLED and NUM_SPRITES_HANDLED
 194+ 4E6E              SPRENABLE:
 195+ 4E6E              	; opening (
 196+ 4E6E CD 2B 66     	CALL CHKCHAR
 197+ 4E71 28           	DB '('
 198+ 4E72              	; get address of sprite attribute table DIM SA%(3,31)
 199+ 4E72 3E 02        	LD A,2
 200+ 4E74 06 02        	LD B,2
 201+ 4E76 11 20 04     	LD DE,#0420
 202+ 4E79 CD 58 66     	CALL GET_BASIC_ARRAY_DATA_POINTER
 203+ 4E7C ED 43 82 4D  	LD (SPRATR_DATA), BC
 204+ 4E80              	; comma
 205+ 4E80 CD 2B 66     	CALL CHKCHAR
 206+ 4E83 2C           	DB ','
 207+ 4E84              	; get address of sprite update flag
 208+ 4E84 DD 21 A4 5E  	LD IX, PTRGET
 209+ 4E88 CD 59 01     	CALL CALBAS
 210+ 4E8B ED 53 80 4D  	LD (SPRATR_UPDATE_FLAG), DE
 211+ 4E8F              	; comma
 212+ 4E8F CD 2B 66     	CALL CHKCHAR
 213+ 4E92 2C           	DB ','
 214+ 4E93              	; get flicker enabled flag
 215+ 4E93 DD 21 1C 52  	LD IX, GETBYT
 216+ 4E97 CD 59 01     	CALL CALBAS
 217+ 4E9A 32 84 4D     	LD (SPRFLICKER_ENABLED), A
 218+ 4E9D              	; comma
 219+ 4E9D CD 2B 66     	CALL CHKCHAR
 220+ 4EA0 2C           	DB ','
 221+ 4EA1              	; get number of handled sprites
 222+ 4EA1 DD 21 1C 52  	LD IX, GETBYT
 223+ 4EA5 CD 59 01     	CALL CALBAS
 224+ 4EA8 32 86 4D     	LD (NUM_SPRITES_HANDLED),A
 225+ 4EAB              	; ending )
 226+ 4EAB CD 2B 66     	CALL CHKCHAR
 227+ 4EAE 29           	DB ')'
 228+ 4EAF              .L0:
 229+ 4EAF 3E 01        	LD A, 1
 230+ 4EB1 32 7F 4D     	LD (SPRATR_INIT_STATUS), A
 231+ 4EB4 C9           	RET
 232+ 4EB5              ; *******************************************************************************************************
 233+ 4EB5               ENDIF
 234+ 4EB5
 235+ 4EB5               IF (0 == 1)
 236+ 4EB5 ~            ; same as SPRENABLE but for DEFUSR approach
 237+ 4EB5 ~            ; input IX=pointer to input array, real data from +2
 238+ 4EB5 ~            ; +2 = pointer to sprite attributes array data
 239+ 4EB5 ~            ; +4 = pointer to sprite update variable
 240+ 4EB5 ~            ; +6 = flicker flag
 241+ 4EB5 ~            ; +8 = number of sprites to handle
 242+ 4EB5 ~            SPRENABLE_DEFUSR:
 243+ 4EB5 ~            	LD L,(IX+2)
 244+ 4EB5 ~            	LD H,(IX+3)
 245+ 4EB5 ~            	LD (SPRATR_DATA),HL
 246+ 4EB5 ~            	LD L,(IX+4)
 247+ 4EB5 ~            	LD H,(IX+5)
 248+ 4EB5 ~            	LD (SPRATR_UPDATE_FLAG),HL
 249+ 4EB5 ~            	LD A,(IX+6)
 250+ 4EB5 ~            	LD (SPRFLICKER_ENABLED),A
 251+ 4EB5 ~            	LD A,(IX+8)
 252+ 4EB5 ~            	LD (NUM_SPRITES_HANDLED),A
 253+ 4EB5 ~             IF (BASIC_EXTENSION == 1)
 254+ 4EB5 ~            	JR SPRENABLE.L0
 255+ 4EB5 ~             ELSE
 256+ 4EB5 ~            	LD A, 1
 257+ 4EB5 ~            	LD (SPRATR_INIT_STATUS), A
 258+ 4EB5 ~            	RET
 259+ 4EB5 ~             ENDIF
 260+ 4EB5               ENDIF
 261+ 4EB5
 262+ 4EB5               IF (0 + 1 > 0)
 263+ 4EB5              ; *******************************************************************************************************
 264+ 4EB5              ; function to handle CALL SPRDISABLE basic extension
 265+ 4EB5              ; disables sprites handling
 266+ 4EB5              ; _SPRDISABLE
 267+ 4EB5              ; resets variable SPRATR_INIT_STATUS
 268+ 4EB5              SPRDISABLE:
 269+ 4EB5              SPRDISABLE_DEFUSR:
 270+ 4EB5 AF           	XOR A
 271+ 4EB6 32 7F 4D     	LD (SPRATR_INIT_STATUS), A
 272+ 4EB9 C9           	RET
 273+ 4EBA              ; *******************************************************************************************************
 274+ 4EBA               ENDIF
 275+ 4EBA
 276+ 4EBA              ; *******************************************************************************************************
 277+ 4EBA              ; function to handle CALL SPRSET basic extension
 278+ 4EBA              ; sets position, and optionally pattern and color of sprite
 279+ 4EBA              ; _SPRSET ( BYTE sprite_num , valid 0-31
 280+ 4EBA              ;			INT x,
 281+ 4EBA              ;			INT y,
 282+ 4EBA              ;			INT pattern, valid 0-63, otherwise ignored
 283+ 4EBA              ;			INT color, valid 0-15, otherwise ignored
 284+ 4EBA              ;SPRSET:
 285+ 4EBA              ;	LD A, (SPRATR_INIT_STATUS)
 286+ 4EBA              ;	OR A
 287+ 4EBA              ;	JR NZ, .L1
 288+ 4EBA              ;	LD E, 5 ; illegal function call
 289+ 4EBA              ;	JP THROW_ERROR
 290+ 4EBA              ;.L1:
 291+ 4EBA              ;	; opening (
 292+ 4EBA              ;	CALL CHKCHAR
 293+ 4EBA              ;	DB '('
 294+ 4EBA              ;	; get sprite number
 295+ 4EBA              ;	LD IX, GETBYT
 296+ 4EBA              ;	CALL CALBAS
 297+ 4EBA              ;	PUSH AF
 298+ 4EBA              ;	; comma
 299+ 4EBA              ;	CALL CHKCHAR
 300+ 4EBA              ;	DB ','
 301+ 4EBA              ;	; get x
 302+ 4EBA              ;	LD IX, FRMQNT
 303+ 4EBA              ;	CALL CALBAS
 304+ 4EBA              ;	PUSH DE
 305+ 4EBA              ;	; comma
 306+ 4EBA              ;	CALL CHKCHAR
 307+ 4EBA              ;	DB ','
 308+ 4EBA              ;	; get y
 309+ 4EBA              ;	LD IX, FRMQNT
 310+ 4EBA              ;	CALL CALBAS
 311+ 4EBA              ;	PUSH DE
 312+ 4EBA              ;	; comma
 313+ 4EBA              ;	CALL CHKCHAR
 314+ 4EBA              ;	DB ','
 315+ 4EBA              ;	; get pattern
 316+ 4EBA              ;	LD IX, FRMQNT
 317+ 4EBA              ;	CALL CALBAS
 318+ 4EBA              ;	PUSH DE
 319+ 4EBA              ;	; comma
 320+ 4EBA              ;	CALL CHKCHAR
 321+ 4EBA              ;	DB ','
 322+ 4EBA              ;	; get color
 323+ 4EBA              ;	LD IX, FRMQNT
 324+ 4EBA              ;	CALL CALBAS
 325+ 4EBA              ;	PUSH DE
 326+ 4EBA              ;	; ending )
 327+ 4EBA              ;	CALL CHKCHAR
 328+ 4EBA              ;	DB ')'
 329+ 4EBA              ;
 330+ 4EBA              ;   ; save position in BASIC text
 331+ 4EBA              ;	PUSH HL
 332+ 4EBA              ;	POP IX
 333+ 4EBA              ;
 334+ 4EBA              ;	POP BC ; color
 335+ 4EBA              ;	POP DE ; pattern
 336+ 4EBA              ;	EXX
 337+ 4EBA              ;	POP BC ; y
 338+ 4EBA              ;	POP DE ; x
 339+ 4EBA              ;	POP AF ; sprite number
 340+ 4EBA              ;	CP 32
 341+ 4EBA              ;	JR C, .L2
 342+ 4EBA              ;	LD E, 5 ; illegal function call
 343+ 4EBA              ;	JP THROW_ERROR
 344+ 4EBA              ;.L2:
 345+ 4EBA              ;	; find location in sprite attributes table
 346+ 4EBA              ;	PUSH DE
 347+ 4EBA              ;	CALL GETnthSPRATTR
 348+ 4EBA              ;	POP DE
 349+ 4EBA              ;	DI
 350+ 4EBA              ;	; set y
 351+ 4EBA              ;	LD (HL), C
 352+ 4EBA              ;	INC HL
 353+ 4EBA              ;	LD (HL), B
 354+ 4EBA              ;	INC HL
 355+ 4EBA              ;	; set x
 356+ 4EBA              ;	LD (HL), E
 357+ 4EBA              ;	INC HL
 358+ 4EBA              ;	LD (HL), D
 359+ 4EBA              ;	INC HL
 360+ 4EBA              ;	PUSH HL
 361+ 4EBA              ;	EXX
 362+ 4EBA              ;	POP HL
 363+ 4EBA              ;	; check if 0<=pattern<64
 364+ 4EBA              ;	LD A, D
 365+ 4EBA              ;	OR A
 366+ 4EBA              ;	JR NZ, .L3
 367+ 4EBA              ;	LD A, E
 368+ 4EBA              ;	CP 64
 369+ 4EBA              ;	JR NC, .L3
 370+ 4EBA              ;	; set pattern
 371+ 4EBA              ;	;ADD A, A
 372+ 4EBA              ;	;ADD A, A
 373+ 4EBA              ;	;ADD A, A
 374+ 4EBA              ;	LD (HL), A
 375+ 4EBA              ;	INC HL
 376+ 4EBA              ;	LD (HL), D
 377+ 4EBA              ;	INC HL
 378+ 4EBA              ;	JR .L4
 379+ 4EBA              ;.L3:
 380+ 4EBA              ;	; skip pattern
 381+ 4EBA              ;	.2 INC HL
 382+ 4EBA              ;.L4:
 383+ 4EBA              ;	; check if 0<=color<16
 384+ 4EBA              ;	LD A, B
 385+ 4EBA              ;	OR A
 386+ 4EBA              ;	JR NZ, .L5
 387+ 4EBA              ;	LD A, C
 388+ 4EBA              ;	CP 16
 389+ 4EBA              ;	JR NC, .L5
 390+ 4EBA              ;	; set color
 391+ 4EBA              ;	LD (HL), C
 392+ 4EBA              ;	INC HL
 393+ 4EBA              ;	LD (HL), B
 394+ 4EBA              ;
 395+ 4EBA              ;.L5:
 396+ 4EBA              ;	EI
 397+ 4EBA              ;	PUSH IX
 398+ 4EBA              ;	POP HL
 399+ 4EBA              ;	RET
 400+ 4EBA              ; *******************************************************************************************************
 401+ 4EBA
 402+ 4EBA              ; *******************************************************************************************************
 403+ 4EBA              ; function sets sprite location based on initial coordinates and offset provided
 404+ 4EBA              ; input A=sprite number in SPRATR_DATA , 0-31
 405+ 4EBA              ; input DE=initial x
 406+ 4EBA              ; input BC=initial y
 407+ 4EBA              ; input IY=location where delta y,x are located
 408+ 4EBA              ; modifies AF, HL, IX
 409+ 4EBA              SPRSET_DELTA_POS:
 410+ 4EBA D5           	PUSH DE
 411+ 4EBB CD 89 4D     	CALL GETnthSPRATTR
 412+ 4EBE E5           	PUSH HL
 413+ 4EBF DD E1        	POP IX
 414+ 4EC1 D1           	POP DE
 415+ 4EC2              	; IX=sprite's y location
 416+ 4EC2 FD 6E 00     	LD L, (IY)
 417+ 4EC5 FD 66 01     	LD H, (IY+1)
 418+ 4EC8 09           	ADD HL, BC
 419+ 4EC9 DD 75 00     	LD (IX), L
 420+ 4ECC DD 74 01     	LD (IX+1), H
 421+ 4ECF FD 6E 02     	LD L, (IY+2)
 422+ 4ED2 FD 66 03     	LD H, (IY+3)
 423+ 4ED5 19           	ADD HL, DE
 424+ 4ED6 DD 75 02     	LD (IX+2), L
 425+ 4ED9 DD 74 03     	LD (IX+3), H
 426+ 4EDC C9           	RET
 427+ 4EDD              ; *******************************************************************************************************
 428+ 4EDD
 429+ 4EDD              ; *******************************************************************************************************
 430+ 4EDD              ; helper function to set new locations for a set of sprites
 431+ 4EDD              ; input B=number of sprites
 432+ 4EDD              ; HL=pointer to list of sprites and offsets
 433+ 4EDD              SPR_UPDATE_LOC:
 434+ 4EDD 3E 01        	LD A,1
 435+ 4EDF 32 21 63     	LD (VRAM_UPDATE_IN_PROGRESS),A
 436+ 4EE2 7E           	LD A, (HL)
 437+ 4EE3 23           	INC HL
 438+ 4EE4 23           	INC HL
 439+ 4EE5 E5           	PUSH HL
 440+ 4EE6 FD E1        	POP IY
 441+ 4EE8 D9           	EXX
 442+ 4EE9 CD BA 4E     	CALL SPRSET_DELTA_POS
 443+ 4EEC D9           	EXX
 444+ 4EED 23          > INC HL
 444+ 4EEE 23          > INC HL
 444+ 4EEF 23          > INC HL
 444+ 4EF0 23          > INC HL
 445+ 4EF1 10 EA        	DJNZ SPR_UPDATE_LOC
 446+ 4EF3 AF           	XOR A
 447+ 4EF4 32 21 63     	LD (VRAM_UPDATE_IN_PROGRESS),A
 448+ 4EF7 C9           	RET
 449+ 4EF8              ; *******************************************************************************************************
 450+ 4EF8
 451+ 4EF8               IF (1 == 1)
 452+ 4EF8              ; *******************************************************************************************************
 453+ 4EF8              ; function to handle CALL SPRGRPMOV basic extension
 454+ 4EF8              ; sets position of a group of sprites described with
 455+ 4EF8              ; { int sprite_num, int delta_y, int delta_x } [count]
 456+ 4EF8              ; _SPRGRPMOV ( INT x,
 457+ 4EF8              ;			   INT y,
 458+ 4EF8              ;			   BYTE count,
 459+ 4EF8              ;			   INT[2][count] data_ptr
 460+ 4EF8              SPRGRPMOV:
 461+ 4EF8 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
 462+ 4EFB B7           	OR A
 463+ 4EFC CA 4B 66     	JP Z,ILLEGAL_FUNCTION
 464+ 4EFF              	; opening (
 465+ 4EFF CD 2B 66     	CALL CHKCHAR
 466+ 4F02 28           	DB '('
 467+ 4F03              	; get x
 468+ 4F03 DD 21 2F 54  	LD IX, FRMQNT
 469+ 4F07 CD 59 01     	CALL CALBAS
 470+ 4F0A ED 53 10 63  	LD (BLIT_STRUCT),DE
 471+ 4F0E              	; comma
 472+ 4F0E CD 2B 66     	CALL CHKCHAR
 473+ 4F11 2C           	DB ','
 474+ 4F12              	; get y
 475+ 4F12 DD 21 2F 54  	LD IX, FRMQNT
 476+ 4F16 CD 59 01     	CALL CALBAS
 477+ 4F19 ED 53 12 63  	LD (BLIT_STRUCT+2),DE
 478+ 4F1D              	; comma
 479+ 4F1D CD 2B 66     	CALL CHKCHAR
 480+ 4F20 2C           	DB ','
 481+ 4F21              	; get count
 482+ 4F21 DD 21 1C 52  	LD IX, GETBYT
 483+ 4F25 CD 59 01     	CALL CALBAS
 484+ 4F28 32 14 63     	LD (BLIT_STRUCT+4),A
 485+ 4F2B              	; comma
 486+ 4F2B CD 2B 66     	CALL CHKCHAR
 487+ 4F2E 2C           	DB ','
 488+ 4F2F              	; get sprite group definition array data pointer
 489+ 4F2F 3A 14 63     	LD A,(BLIT_STRUCT+4)
 490+ 4F32 5F           	LD E,A
 491+ 4F33 16 03        	LD D,3
 492+ 4F35 3E 02        	LD A,2
 493+ 4F37 47           	LD B,A
 494+ 4F38 CD 58 66     	CALL GET_BASIC_ARRAY_DATA_POINTER
 495+ 4F3B ED 43 15 63  	LD (BLIT_STRUCT+5),BC
 496+ 4F3F              	; ending )
 497+ 4F3F CD 2B 66     	CALL CHKCHAR
 498+ 4F42 29           	DB ')'
 499+ 4F43
 500+ 4F43 E5           	PUSH HL
 501+ 4F44
 502+ 4F44 D9               EXX
 503+ 4F45 ED 5B 10 63      LD DE,(BLIT_STRUCT) ; initial x
 504+ 4F49 ED 4B 12 63      LD BC,(BLIT_STRUCT+2) ; initial y
 505+ 4F4D D9               EXX
 506+ 4F4E 2A 15 63         LD HL,(BLIT_STRUCT+5) ; pointer to data
 507+ 4F51 3A 14 63         LD A,(BLIT_STRUCT+4) ; number of entries
 508+ 4F54 47               LD B,A
 509+ 4F55 CD DD 4E     	CALL SPR_UPDATE_LOC
 510+ 4F58
 511+ 4F58 E1           	POP HL
 512+ 4F59 C9           	RET
 513+ 4F5A              ; *******************************************************************************************************
 514+ 4F5A               ENDIF
 515+ 4F5A
 516+ 4F5A               IF (0 == 1)
 517+ 4F5A ~            ; *******************************************************************************************************
 518+ 4F5A ~            ; same as SPRGRPMOV but for DEFUSR approach
 519+ 4F5A ~            ; input IX=pointer to input array, real data from +2
 520+ 4F5A ~            ; +2 = X
 521+ 4F5A ~            ; +4 = Y
 522+ 4F5A ~            ; +6 = count
 523+ 4F5A ~            ; +8 = data pointer
 524+ 4F5A ~            SPRGRPMOV_DEFUSR:
 525+ 4F5A ~                EXX
 526+ 4F5A ~            	LD E,(IX+2)
 527+ 4F5A ~            	LD D,(IX+3) ; initial x
 528+ 4F5A ~            	LD C,(IX+4)
 529+ 4F5A ~            	LD B,(IX+5) ; initial y
 530+ 4F5A ~                EXX
 531+ 4F5A ~            	LD L,(IX+8)
 532+ 4F5A ~            	LD H,(IX+9) ; pointer to data
 533+ 4F5A ~                LD B,(IX+6) ; count
 534+ 4F5A ~                JP SPR_UPDATE_LOC
 535+ 4F5A ~            ; *******************************************************************************************************
 536+ 4F5A               ENDIF
# file closed: asm\SPRITES.asm
 130  4F5A               ENDIF
 131  4F5A
 132  4F5A               IF (ANIM_CMDS == 1)
 133  4F5A               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4F5A              ; sprite animation routines
   2+ 4F5A
   3+ 4F5A              ; number of animation items and pointer
   4+ 4F5A              ANIMITEMNUM:
   5+ 4F5A 00            DB 0
   6+ 4F5B              ANIMITEMPTR:
   7+ 4F5B CE 66         DW EXT_END
   8+ 4F5D              ; number of animation definitions and pointer
   9+ 4F5D              ANIMDEFNUM:
  10+ 4F5D 00            DB 0
  11+ 4F5E              ANIMDEFPTR:
  12+ 4F5E CE 66         DW EXT_END
  13+ 4F60              ; number of links between sprite and animation definitions
  14+ 4F60              ANIMSPRNUM:
  15+ 4F60 00            DB 0
  16+ 4F61              ANIMSPRPTR:
  17+ 4F61 CE 66         DW EXT_END
  18+ 4F63              ; number of automatic sprite group move and animate structures
  19+ 4F63              AUTOSGAMNUM:
  20+ 4F63 00            DB 0
  21+ 4F64              AUTOSGAMPTR:
  22+ 4F64 CE 66         DW EXT_END
  23+ 4F66
  24+ 4F66              ; ANIMATION ITEM
  25+ 4F66              ; byte type = [0 - pattern and color change
  26+ 4F66              ;              1 - pattern definition change ]
  27+ 4F66              ; word ticks - number of ticks to hold this state
  28+ 4F66              ; for type = 0
  29+ 4F66              ;   byte pattern;
  30+ 4F66              ;   byte color;
  31+ 4F66              ; for type = 1
  32+ 4F66              ;   work data_pointer;
  33+ 4F66              ; total size = 5b
  34+ 4F66
  35+ 4F66              ; ANIMATION DEFINITION
  36+ 4F66              ; byte number of items 1-15
  37+ 4F66              ; byte[15] anim_item;
  38+ 4F66              ; total size = 16b
  39+ 4F66
  40+ 4F66              ; SPRITE/CHAR ANIMATION
  41+ 4F66              ; +00 byte sprite/char number;
  42+ 4F66              ; +01 word time;
  43+ 4F66              ; +03 byte current item;
  44+ 4F66              ; +04 byte animation definition;
  45+ 4F66              ; +05 byte cyclic;
  46+ 4F66              ; +06 byte active;
  47+ 4F66              ; +07 byte 0=sprite, 1-3 character bank
  48+ 4F66              ; total size = 8b
  49+ 4F66
  50+ 4F66              ; AUTOMATIC SPRITE GROUP MOVE AND ANIMATE structure
  51+ 4F66              ; +00 pointer to X variable
  52+ 4F66              ; +02 pointer to Y variable
  53+ 4F66              ; +04 minimum value
  54+ 4F66              ; +06 maximal value
  55+ 4F66              ; +08 delta value
  56+ 4F66              ; +10 direction 0=horizontal, <>0 = vertical
  57+ 4F66              ; +11 sprite group size
  58+ 4F66              ; +12 sprite group pointer
  59+ 4F66              ; +14 animation list size
  60+ 4F66              ; +15 animation list pointer for negative delta values
  61+ 4F66              ; +17 animation list pointer for positive delta values
  62+ 4F66              ; +19 active flag
  63+ 4F66              ; +20 ticks for movement
  64+ 4F66              ; +22 timer
  65+ 4F66              ; total = 24b
  66+ 4F66
  67+ 4F66              ; *******************************************************************************************************
  68+ 4F66              ; helper function HL=A*5
  69+ 4F66              ; changes HL,DE
  70+ 4F66              Ax5:
  71+ 4F66 26 00            LD H,0
  72+ 4F68 6F               LD L,A
  73+ 4F69 54               LD D,H
  74+ 4F6A 5D               LD E,L
  75+ 4F6B 29               ADD HL,HL
  76+ 4F6C 29               ADD HL,HL
  77+ 4F6D 19               ADD HL,DE
  78+ 4F6E C9               RET
  79+ 4F6F              ; *******************************************************************************************************
  80+ 4F6F
  81+ 4F6F              ; *******************************************************************************************************
  82+ 4F6F              ; helper function gets pointer to n-th animation item
  83+ 4F6F              ; changes HL,DE
  84+ 4F6F              GETnthANIMITEM:
  85+ 4F6F CD 66 4F         CALL Ax5
  86+ 4F72 ED 5B 5B 4F      LD DE,(ANIMITEMPTR)
  87+ 4F76 19               ADD HL,DE
  88+ 4F77 C9               RET
  89+ 4F78              ; *******************************************************************************************************
  90+ 4F78
  91+ 4F78              ; *******************************************************************************************************
  92+ 4F78              ; helper function gets pointer to n-th entry in animation definition
  93+ 4F78              ; changes HL,DE
  94+ 4F78              GETnthANIMDEF:
  95+ 4F78 26 00            LD H,0
  96+ 4F7A 6F               LD L,A
  97+ 4F7B CD 17 65         CALL HLx16
  98+ 4F7E ED 5B 5E 4F      LD DE,(ANIMDEFPTR)
  99+ 4F82 19               ADD HL,DE
 100+ 4F83 C9               RET
 101+ 4F84              ; *******************************************************************************************************
 102+ 4F84
 103+ 4F84              ; *******************************************************************************************************
 104+ 4F84              ; helper function gets pointer to n-th entry in sprite animation
 105+ 4F84              ; changes HL,DE
 106+ 4F84              GETnthSPRANIM:
 107+ 4F84 26 00            LD H,0
 108+ 4F86 6F               LD L,A
 109+ 4F87 CD 18 65         CALL HLx8
 110+ 4F8A ED 5B 61 4F      LD DE,(ANIMSPRPTR)
 111+ 4F8E 19               ADD HL,DE
 112+ 4F8F C9               RET
 113+ 4F90              ; *******************************************************************************************************
 114+ 4F90
 115+ 4F90              ; *******************************************************************************************************
 116+ 4F90              ; helper function gets pointer to n-th entry in autosgam table
 117+ 4F90              ; changes HL,DE
 118+ 4F90              GETnthAUTOSGAM:
 119+ 4F90 26 00            LD H,0
 120+ 4F92 6F               LD L,A
 121+ 4F93 CD 18 65         CALL HLx8
 122+ 4F96 54               LD D,H
 123+ 4F97 5D               LD E,L
 124+ 4F98 29               ADD HL,HL
 125+ 4F99 19               ADD HL,DE
 126+ 4F9A ED 5B 64 4F      LD DE,(AUTOSGAMPTR)
 127+ 4F9E 19               ADD HL,DE
 128+ 4F9F C9               RET
 129+ 4FA0              ; *******************************************************************************************************
 130+ 4FA0
 131+ 4FA0               IF (0 == 1)
 132+ 4FA0 ~            ; *******************************************************************************************************
 133+ 4FA0 ~            ; same as MAXIANIMITEMS but for DEFUSR approach
 134+ 4FA0 ~            ; input IX=pointer to input array, real data from +2
 135+ 4FA0 ~            ; +2 = number
 136+ 4FA0 ~            MAXANIMITEMS_DEFUSR:
 137+ 4FA0 ~                LD A,(IX+2)
 138+ 4FA0 ~                JR MAXANIMITEMS.COMMON
 139+ 4FA0 ~            ; *******************************************************************************************************
 140+ 4FA0               ENDIF
 141+ 4FA0
 142+ 4FA0              ; *******************************************************************************************************
 143+ 4FA0              ; function to handle CALL MAXANIMITEMS basic extension
 144+ 4FA0              ; MAXANIMITEMS (BYTE number)
 145+ 4FA0              ; sets new number and moves memory buffers as needed
 146+ 4FA0              MAXANIMITEMS:
 147+ 4FA0               IF (1 == 1)
 148+ 4FA0              	; opening (
 149+ 4FA0 CD 2B 66     	CALL CHKCHAR
 150+ 4FA3 28           	DB '('
 151+ 4FA4              	; get value
 152+ 4FA4 DD 21 1C 52  	LD IX, GETBYT
 153+ 4FA8 CD 59 01     	CALL CALBAS
 154+ 4FAB F5               PUSH AF
 155+ 4FAC              	; ending )
 156+ 4FAC CD 2B 66     	CALL CHKCHAR
 157+ 4FAF 29           	DB ')'
 158+ 4FB0 F1               POP AF
 159+ 4FB1               ENDIF
 160+ 4FB1              .COMMON: ; entry for DEFUSR part, A=number
 161+ 4FB1 F3               DI
 162+ 4FB2              	; save position
 163+ 4FB2 E5           	PUSH HL
 164+ 4FB3              .ENTRY:
 165+ 4FB3 47               LD B,A
 166+ 4FB4 3A 5A 4F         LD A,(ANIMITEMNUM)
 167+ 4FB7 90               SUB B
 168+ 4FB8 28 28            JR Z, .EXIT; same value as before
 169+ 4FBA FD 21 5E 4F      LD IY,ANIMDEFPTR
 170+ 4FBE FA E5 4F         JP M, .INCREASE
 171+ 4FC1                  ; new value is lower than previous one
 172+ 4FC1 CD 04 50         CALL .SIZEDIFF
 173+ 4FC4 CD 1F 50         CALL .DECREASE_COMMON
 174+ 4FC7 2A 61 4F         LD HL,(ANIMSPRPTR)
 175+ 4FCA AF               XOR A
 176+ 4FCB ED 42            SBC HL,BC
 177+ 4FCD 22 61 4F         LD (ANIMSPRPTR),HL
 178+ 4FD0              .E1:
 179+ 4FD0 2A 64 4F         LD HL,(AUTOSGAMPTR)
 180+ 4FD3 AF               XOR A
 181+ 4FD4 ED 42            SBC HL,BC
 182+ 4FD6 22 64 4F         LD (AUTOSGAMPTR),HL
 183+ 4FD9              .E3:
 184+ 4FD9 2A 10 40         LD HL,(FREEMEMPTR)
 185+ 4FDC AF               XOR A
 186+ 4FDD ED 42            SBC HL,BC
 187+ 4FDF 22 10 40         LD (FREEMEMPTR),HL
 188+ 4FE2              .EXIT:
 189+ 4FE2 FB               EI
 190+ 4FE3 E1           	POP HL
 191+ 4FE4 C9           	RET
 192+ 4FE5              .INCREASE:
 193+ 4FE5 ED 44            NEG
 194+ 4FE7 CD 04 50         CALL .SIZEDIFF
 195+ 4FEA CD 4B 50         CALL .INCREASE_COMMON
 196+ 4FED 2A 61 4F         LD HL,(ANIMSPRPTR)
 197+ 4FF0 09               ADD HL,BC
 198+ 4FF1 22 61 4F         LD (ANIMSPRPTR),HL
 199+ 4FF4              .E2:
 200+ 4FF4 2A 64 4F         LD HL,(AUTOSGAMPTR)
 201+ 4FF7 09               ADD HL,BC
 202+ 4FF8 22 64 4F         LD (AUTOSGAMPTR),HL
 203+ 4FFB              .E4:
 204+ 4FFB 2A 10 40         LD HL,(FREEMEMPTR)
 205+ 4FFE 09               ADD HL,BC
 206+ 4FFF 22 10 40         LD (FREEMEMPTR),HL
 207+ 5002 18 DE            JR .EXIT
 208+ 5004              .SIZEDIFF:
 209+ 5004 CD 66 4F         CALL Ax5
 210+ 5007 78               LD A,B
 211+ 5008 32 5A 4F         LD (ANIMITEMNUM),A
 212+ 500B 44               LD B,H
 213+ 500C 4D               LD C,L
 214+ 500D C9               RET ; BC=size difference in bytes
 215+ 500E              .SIZETOMOVE:
 216+ 500E D5               PUSH DE
 217+ 500F 2A 10 40         LD HL,(FREEMEMPTR)
 218+ 5012 FD 5E 00         LD E,(IY)
 219+ 5015 FD 56 01         LD D,(IY+1)
 220+ 5018 AF               XOR A
 221+ 5019 ED 52            SBC HL,DE
 222+ 501B 44               LD B,H
 223+ 501C 4D               LD C,L
 224+ 501D D1               POP DE
 225+ 501E C9               RET
 226+ 501F              .DECREASE_COMMON:
 227+ 501F FD 6E 00         LD L,(IY)
 228+ 5022 FD 66 01         LD H,(IY+1)
 229+ 5025 AF               XOR A
 230+ 5026 ED 42            SBC HL,BC
 231+ 5028 EB               EX DE,HL
 232+ 5029 C5               PUSH BC
 233+ 502A CD 0E 50         CALL .SIZETOMOVE
 234+ 502D F3               DI
 235+ 502E 78               LD A,B
 236+ 502F B1               OR C
 237+ 5030 28 08            JR Z,.L1
 238+ 5032 FD 6E 00         LD L,(IY)
 239+ 5035 FD 66 01         LD H,(IY+1)
 240+ 5038 ED B0            LDIR
 241+ 503A              .L1:
 242+ 503A C1               POP BC
 243+ 503B FD 6E 00         LD L,(IY)
 244+ 503E FD 66 01         LD H,(IY+1)
 245+ 5041 AF               XOR A
 246+ 5042 ED 42            SBC HL,BC
 247+ 5044 FD 75 00         LD (IY),L
 248+ 5047 FD 74 01         LD (IY+1),H
 249+ 504A C9               RET
 250+ 504B              .INCREASE_COMMON:
 251+ 504B 2A 10 40         LD HL,(FREEMEMPTR)
 252+ 504E 2B               DEC HL
 253+ 504F AF               XOR A
 254+ 5050 ED 42            SBC HL,BC
 255+ 5052 EB               EX DE,HL
 256+ 5053 C5               PUSH BC
 257+ 5054 CD 0E 50         CALL .SIZETOMOVE
 258+ 5057 F3               DI
 259+ 5058 78               LD A,B
 260+ 5059 B1               OR C
 261+ 505A 28 06            JR Z,.L2
 262+ 505C 2A 10 40         LD HL,(FREEMEMPTR)
 263+ 505F 2B               DEC HL
 264+ 5060 ED B8            LDDR
 265+ 5062              .L2:
 266+ 5062 C1               POP BC
 267+ 5063 FD 6E 00         LD L,(IY)
 268+ 5066 FD 66 01         LD H,(IY+1)
 269+ 5069 09               ADD HL,BC
 270+ 506A FD 75 00         LD (IY),L
 271+ 506D FD 74 01         LD (IY+1),H
 272+ 5070 C9               RET
 273+ 5071              ; *******************************************************************************************************
 274+ 5071
 275+ 5071               IF (1 == 1)
 276+ 5071              ; *******************************************************************************************************
 277+ 5071              ; function to handle CALL ANIMITEMPAT basic extension
 278+ 5071              ; ANIMITEMPAT ( BYTE id,
 279+ 5071              ;               INT ticks >0,
 280+ 5071              ;               BYTE pattern,
 281+ 5071              ;               BYTE color )
 282+ 5071              ; fills animation item data, returns an error if ID out of bounds
 283+ 5071              ANIMITEMPAT:
 284+ 5071                  ; opening (
 285+ 5071 CD 2B 66     	CALL CHKCHAR
 286+ 5074 28           	DB '('
 287+ 5075              	; get id
 288+ 5075 DD 21 1C 52  	LD IX, GETBYT
 289+ 5079 CD 59 01     	CALL CALBAS
 290+ 507C F5               PUSH AF
 291+ 507D                  ; check if out of bounds
 292+ 507D 3C               INC A
 293+ 507E 4F               LD C,A
 294+ 507F 3A 5A 4F         LD A,(ANIMITEMNUM)
 295+ 5082 B9               CP C
 296+ 5083 DA 43 66         JP C,SUBSCRIPT_OUT_OF_RANGE
 297+ 5086              	; comma
 298+ 5086 CD 2B 66     	CALL CHKCHAR
 299+ 5089 2C           	DB ','
 300+ 508A              	; get ticks
 301+ 508A DD 21 2F 54  	LD IX, FRMQNT
 302+ 508E CD 59 01     	CALL CALBAS
 303+ 5091 7A               LD A,D
 304+ 5092 B3               OR E
 305+ 5093 CA 47 66         JP Z, OVERFLOW
 306+ 5096 D5           	PUSH DE
 307+ 5097              	; comma
 308+ 5097 CD 2B 66     	CALL CHKCHAR
 309+ 509A 2C           	DB ','
 310+ 509B              	; get pattern
 311+ 509B DD 21 1C 52  	LD IX, GETBYT
 312+ 509F CD 59 01     	CALL CALBAS
 313+ 50A2 F5               PUSH AF
 314+ 50A3              	; comma
 315+ 50A3 CD 2B 66     	CALL CHKCHAR
 316+ 50A6 2C           	DB ','
 317+ 50A7              	; get color
 318+ 50A7 DD 21 1C 52  	LD IX, GETBYT
 319+ 50AB CD 59 01     	CALL CALBAS
 320+ 50AE F5               PUSH AF
 321+ 50AF              	; ending )
 322+ 50AF CD 2B 66     	CALL CHKCHAR
 323+ 50B2 29           	DB ')'
 324+ 50B3              .ENTRY:
 325+ 50B3 E5               PUSH HL
 326+ 50B4 DD E1            POP IX
 327+ 50B6 D9               EXX
 328+ 50B7 C1               POP BC ; color
 329+ 50B8 D1               POP DE ; pattern
 330+ 50B9 E1               POP HL ; ticks
 331+ 50BA D9               EXX
 332+ 50BB F1               POP AF
 333+ 50BC CD 6F 4F         CALL GETnthANIMITEM
 334+ 50BF E5               PUSH HL
 335+ 50C0 FD E1            POP IY
 336+ 50C2 D9               EXX
 337+ 50C3 FD 36 00 00      LD (IY),0 ; type=0
 338+ 50C7 FD 75 01         LD (IY+1),L
 339+ 50CA FD 74 02         LD (IY+2),H
 340+ 50CD FD 72 03         LD (IY+3),D
 341+ 50D0 FD 70 04         LD (IY+4),B
 342+ 50D3
 343+ 50D3 DD E5            PUSH IX
 344+ 50D5 E1               POP HL
 345+ 50D6 C9               RET
 346+ 50D7              ; *******************************************************************************************************
 347+ 50D7               ENDIF
 348+ 50D7
 349+ 50D7               IF (0 == 1)
 350+ 50D7 ~            ; *******************************************************************************************************
 351+ 50D7 ~            ; same as ANIMITEMPAT but for DEFUSR approach
 352+ 50D7 ~            ; input IX=pointer to input array, real data from +2
 353+ 50D7 ~            ; +02 = ID
 354+ 50D7 ~            ; +04 = ticks
 355+ 50D7 ~            ; +06 = pattern
 356+ 50D7 ~            ; +08 = color
 357+ 50D7 ~            ANIMITEMPAT_DEFUSR:
 358+ 50D7 ~                ; check if out of bounds
 359+ 50D7 ~                LD C,(IX+2)
 360+ 50D7 ~                INC C
 361+ 50D7 ~                LD A,(ANIMITEMNUM)
 362+ 50D7 ~                CP C
 363+ 50D7 ~                RET C ; out of bounds, prevent memory corruption
 364+ 50D7 ~                LD A,C
 365+ 50D7 ~                DEC A
 366+ 50D7 ~                CALL GETnthANIMITEM
 367+ 50D7 ~                LD (HL),0 ; type=0
 368+ 50D7 ~                INC HL
 369+ 50D7 ~                LD A,(IX+4) ; ticks low
 370+ 50D7 ~                LD (HL),A
 371+ 50D7 ~                INC HL
 372+ 50D7 ~                LD A,(IX+5) ; ticks high
 373+ 50D7 ~                LD (HL),A
 374+ 50D7 ~                INC HL
 375+ 50D7 ~                LD A,(IX+6) ; pattern
 376+ 50D7 ~                LD (HL),A
 377+ 50D7 ~                INC HL
 378+ 50D7 ~                LD A,(IX+8) ; color
 379+ 50D7 ~                LD (HL),A
 380+ 50D7 ~                RET
 381+ 50D7 ~            ; *******************************************************************************************************
 382+ 50D7               ENDIF
 383+ 50D7
 384+ 50D7               IF (1 == 1)
 385+ 50D7              ; *******************************************************************************************************
 386+ 50D7              ; function to handle CALL ANIMITEMPTR basic extension
 387+ 50D7              ; ANIMITEMPTR ( BYTE id,
 388+ 50D7              ;               INT ticks,
 389+ 50D7              ;               INT pointer,
 390+ 50D7              ; fills animation item data, returns an error if ID out of bounds
 391+ 50D7              ANIMITEMPTR_CMD:
 392+ 50D7                  ; opening (
 393+ 50D7 CD 2B 66     	CALL CHKCHAR
 394+ 50DA 28           	DB '('
 395+ 50DB              	; get id
 396+ 50DB DD 21 1C 52  	LD IX, GETBYT
 397+ 50DF CD 59 01     	CALL CALBAS
 398+ 50E2 F5               PUSH AF
 399+ 50E3                  ; check if out of bounds
 400+ 50E3 3C               INC A
 401+ 50E4 4F               LD C,A
 402+ 50E5 3A 5A 4F         LD A,(ANIMITEMNUM)
 403+ 50E8 B9               CP C
 404+ 50E9 DA 43 66         JP C,SUBSCRIPT_OUT_OF_RANGE
 405+ 50EC              	; comma
 406+ 50EC CD 2B 66     	CALL CHKCHAR
 407+ 50EF 2C           	DB ','
 408+ 50F0              	; get ticks
 409+ 50F0 DD 21 2F 54  	LD IX, FRMQNT
 410+ 50F4 CD 59 01     	CALL CALBAS
 411+ 50F7 7A               LD A,D
 412+ 50F8 B3               OR E
 413+ 50F9 CA 47 66         JP Z,OVERFLOW
 414+ 50FC D5           	PUSH DE
 415+ 50FD              	; comma
 416+ 50FD CD 2B 66     	CALL CHKCHAR
 417+ 5100 2C           	DB ','
 418+ 5101              	; get pointer
 419+ 5101 DD 21 2F 54  	LD IX, FRMQNT
 420+ 5105 CD 59 01     	CALL CALBAS
 421+ 5108 D5           	PUSH DE
 422+ 5109              	; ending )
 423+ 5109 CD 2B 66     	CALL CHKCHAR
 424+ 510C 29           	DB ')'
 425+ 510D              .ENTRY:
 426+ 510D E5               PUSH HL
 427+ 510E DD E1            POP IX
 428+ 5110 D9               EXX
 429+ 5111 D1               POP DE ; pointer
 430+ 5112 E1               POP HL ; ticks
 431+ 5113 D9               EXX
 432+ 5114 F1               POP AF
 433+ 5115 CD 6F 4F         CALL GETnthANIMITEM
 434+ 5118 E5               PUSH HL
 435+ 5119 FD E1            POP IY
 436+ 511B D9               EXX
 437+ 511C FD 36 00 01      LD (IY),1 ; type=1
 438+ 5120 FD 75 01         LD (IY+1),L
 439+ 5123 FD 74 02         LD (IY+2),H
 440+ 5126 FD 73 03         LD (IY+3),E
 441+ 5129 FD 72 04         LD (IY+4),D
 442+ 512C
 443+ 512C DD E5            PUSH IX
 444+ 512E E1               POP HL
 445+ 512F C9               RET
 446+ 5130              ; *******************************************************************************************************
 447+ 5130               ENDIF
 448+ 5130
 449+ 5130               IF (0 == 1)
 450+ 5130 ~            ; *******************************************************************************************************
 451+ 5130 ~            ; same as ANIMITEMPTR but for DEFUSR approach
 452+ 5130 ~            ; input IX=pointer to input array, real data from +2
 453+ 5130 ~            ; +02 = ID
 454+ 5130 ~            ; +04 = ticks
 455+ 5130 ~            ; +06 = pointer
 456+ 5130 ~            ANIMITEMPTR_DEFUSR:
 457+ 5130 ~                ; check if out of bounds
 458+ 5130 ~                LD C,(IX+2)
 459+ 5130 ~                INC C
 460+ 5130 ~                LD A,(ANIMITEMNUM)
 461+ 5130 ~                CP C
 462+ 5130 ~                RET C ; out of bounds, prevent memory corruption
 463+ 5130 ~                LD A,C
 464+ 5130 ~                DEC A
 465+ 5130 ~                CALL GETnthANIMITEM
 466+ 5130 ~                LD (HL),1 ; type=1
 467+ 5130 ~                INC HL
 468+ 5130 ~                LD A,(IX+4) ; ticks low
 469+ 5130 ~                LD (HL),A
 470+ 5130 ~                INC HL
 471+ 5130 ~                LD A,(IX+5) ; ticks high
 472+ 5130 ~                LD (HL),A
 473+ 5130 ~                INC HL
 474+ 5130 ~                LD A,(IX+6) ; pointer low
 475+ 5130 ~                LD (HL),A
 476+ 5130 ~                INC HL
 477+ 5130 ~                LD A,(IX+7) ; pointer high
 478+ 5130 ~                LD (HL),A
 479+ 5130 ~                RET
 480+ 5130 ~            ; *******************************************************************************************************
 481+ 5130               ENDIF
 482+ 5130
 483+ 5130               IF (0 == 1)
 484+ 5130 ~            ; *******************************************************************************************************
 485+ 5130 ~            ; same as MAXANIMDEFS but for DEFUSR approach
 486+ 5130 ~            ; input IX=pointer to input array, real data from +2
 487+ 5130 ~            ; +2 = number
 488+ 5130 ~            MAXANIMDEFS_DEFUSR:
 489+ 5130 ~                LD A,(IX+2)
 490+ 5130 ~                JR MAXANIMDEFS.COMMON
 491+ 5130 ~            ; *******************************************************************************************************
 492+ 5130               ENDIF
 493+ 5130
 494+ 5130              ; *******************************************************************************************************
 495+ 5130              ; function to handle CALL MAXANIMDEFS basic extension
 496+ 5130              ; MAXANIMDEFS (BYTE number)
 497+ 5130              ; sets new number and moves memory buffers as needed
 498+ 5130              MAXANIMDEFS:
 499+ 5130               IF (1 == 1)
 500+ 5130              	; opening (
 501+ 5130 CD 2B 66     	CALL CHKCHAR
 502+ 5133 28           	DB '('
 503+ 5134              	; get value
 504+ 5134 DD 21 1C 52  	LD IX, GETBYT
 505+ 5138 CD 59 01     	CALL CALBAS
 506+ 513B F5               PUSH AF
 507+ 513C              	; ending )
 508+ 513C CD 2B 66     	CALL CHKCHAR
 509+ 513F 29           	DB ')'
 510+ 5140 F1               POP AF
 511+ 5141               ENDIF
 512+ 5141              .COMMON:
 513+ 5141 F3               DI
 514+ 5142              	; save position
 515+ 5142 E5           	PUSH HL
 516+ 5143              .ENTRY:
 517+ 5143 47               LD B,A
 518+ 5144 3A 5D 4F         LD A,(ANIMDEFNUM)
 519+ 5147 90               SUB B
 520+ 5148 CA E2 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 521+ 514B FD 21 61 4F      LD IY,ANIMSPRPTR
 522+ 514F FA 5B 51         JP M, .INCREASE
 523+ 5152                  ; new value is lower than previous one
 524+ 5152 CD 66 51         CALL .SIZEDIFF
 525+ 5155 CD 1F 50         CALL MAXANIMITEMS.DECREASE_COMMON
 526+ 5158 C3 D0 4F         JP MAXANIMITEMS.E1
 527+ 515B              .INCREASE:
 528+ 515B ED 44            NEG
 529+ 515D CD 66 51         CALL .SIZEDIFF
 530+ 5160 CD 4B 50         CALL MAXANIMITEMS.INCREASE_COMMON
 531+ 5163 C3 F4 4F         JP MAXANIMITEMS.E2
 532+ 5166              .SIZEDIFF:
 533+ 5166 26 00            LD H,0
 534+ 5168 6F               LD L,A
 535+ 5169 CD 17 65         CALL HLx16
 536+ 516C 78               LD A,B
 537+ 516D 32 5D 4F         LD (ANIMDEFNUM),A
 538+ 5170 44               LD B,H
 539+ 5171 4D               LD C,L
 540+ 5172 C9               RET ; BC=size difference in bytes
 541+ 5173              ; *******************************************************************************************************
 542+ 5173
 543+ 5173               IF (1 == 1)
 544+ 5173              ; *******************************************************************************************************
 545+ 5173              ; function to handle CALL ANIMDEF basic extension
 546+ 5173              ; ANIMITEMPAT ( BYTE id,
 547+ 5173              ;               BYTE size,
 548+ 5173              ;               INT[] list )
 549+ 5173              ; fills animation definition data, returns an error if out of bounds, or invalid type
 550+ 5173              ANIMDEF:
 551+ 5173                  ; opening (
 552+ 5173 CD 2B 66     	CALL CHKCHAR
 553+ 5176 28           	DB '('
 554+ 5177              	; get id
 555+ 5177 DD 21 1C 52  	LD IX, GETBYT
 556+ 517B CD 59 01     	CALL CALBAS
 557+ 517E F5               PUSH AF
 558+ 517F                  ; check if out of bounds
 559+ 517F 3C               INC A
 560+ 5180 4F               LD C,A
 561+ 5181 3A 5D 4F         LD A,(ANIMDEFNUM)
 562+ 5184 B9               CP C
 563+ 5185 DA 43 66         JP C,SUBSCRIPT_OUT_OF_RANGE
 564+ 5188              	; comma
 565+ 5188 CD 2B 66     	CALL CHKCHAR
 566+ 518B 2C           	DB ','
 567+ 518C              	; get size
 568+ 518C DD 21 1C 52  	LD IX, GETBYT
 569+ 5190 CD 59 01     	CALL CALBAS
 570+ 5193 FE 10            CP 16
 571+ 5195 D2 47 66         JP NC, OVERFLOW
 572+ 5198 B7               OR A
 573+ 5199 CA 47 66         JP Z, OVERFLOW
 574+ 519C F5           	PUSH AF
 575+ 519D              	; comma
 576+ 519D CD 2B 66     	CALL CHKCHAR
 577+ 51A0 2C           	DB ','
 578+ 51A1              	; get pointer to a list of animation items in integer array format
 579+ 51A1                  ; get array pointer
 580+ 51A1 D1               POP DE
 581+ 51A2 D5               PUSH DE
 582+ 51A3 3E 02            LD A,2
 583+ 51A5 06 01            LD B,1
 584+ 51A7 CD 58 66         CALL GET_BASIC_ARRAY_DATA_POINTER
 585+ 51AA C5               PUSH BC
 586+ 51AB              	; ending )
 587+ 51AB CD 2B 66     	CALL CHKCHAR
 588+ 51AE 29           	DB ')'
 589+ 51AF              .ENTRY:
 590+ 51AF E5               PUSH HL
 591+ 51B0 DD E1            POP IX
 592+ 51B2 D1               POP DE ; pointer to INT array
 593+ 51B3 C1               POP BC ; B=item number
 594+ 51B4 F1               POP AF ; id
 595+ 51B5 D5               PUSH DE
 596+ 51B6 CD 78 4F         CALL GETnthANIMDEF
 597+ 51B9 D1               POP DE
 598+ 51BA 70               LD (HL),B
 599+ 51BB              .L1:
 600+ 51BB 23               INC HL
 601+ 51BC 1A               LD A,(DE)
 602+ 51BD 13          > INC DE
 602+ 51BE 13          > INC DE
 603+ 51BF 77               LD (HL),A
 604+ 51C0 10 F9            DJNZ .L1
 605+ 51C2 DD E5            PUSH IX
 606+ 51C4 E1               POP HL
 607+ 51C5 C9               RET
 608+ 51C6              ; *******************************************************************************************************
 609+ 51C6               ENDIF
 610+ 51C6
 611+ 51C6               IF (0 == 1)
 612+ 51C6 ~            ; *******************************************************************************************************
 613+ 51C6 ~            ; same as ANIMDEF but for DEFUSR approach
 614+ 51C6 ~            ; input IX=pointer to input array, real data from +2
 615+ 51C6 ~            ; +02 = ID
 616+ 51C6 ~            ; +04 = list size
 617+ 51C6 ~            ; +06 = list pointer
 618+ 51C6 ~            ANIMDEF_DEFUSR:
 619+ 51C6 ~                ; check if out of bounds
 620+ 51C6 ~                LD C,(IX+2)
 621+ 51C6 ~                INC C
 622+ 51C6 ~                LD A,(ANIMDEFNUM)
 623+ 51C6 ~                CP C
 624+ 51C6 ~                RET C ; invalid id
 625+ 51C6 ~            	; get size
 626+ 51C6 ~                LD A,(IX+4)
 627+ 51C6 ~                CP 16
 628+ 51C6 ~                RET NC ; overflow
 629+ 51C6 ~                OR A
 630+ 51C6 ~                RET Z ; ID=0, invalid
 631+ 51C6 ~                LD B,A
 632+ 51C6 ~                LD A,C
 633+ 51C6 ~                DEC A
 634+ 51C6 ~                CALL GETnthANIMDEF
 635+ 51C6 ~                LD (HL),B
 636+ 51C6 ~                LD E,(IX+6)
 637+ 51C6 ~                LD D,(IX+7)
 638+ 51C6 ~            .L1:
 639+ 51C6 ~                INC HL
 640+ 51C6 ~                LD A,(DE)
 641+ 51C6 ~                .2 INC DE
 642+ 51C6 ~                LD (HL),A
 643+ 51C6 ~                DJNZ .L1
 644+ 51C6 ~                RET
 645+ 51C6 ~            ; *******************************************************************************************************
 646+ 51C6               ENDIF
 647+ 51C6
 648+ 51C6               IF (0 == 1)
 649+ 51C6 ~            ; *******************************************************************************************************
 650+ 51C6 ~            ; same as MAXANIMSPRS but for DEFUSR approach
 651+ 51C6 ~            ; input IX=pointer to input array, real data from +2
 652+ 51C6 ~            ; +2 = number
 653+ 51C6 ~            MAXANIMSPRS_DEFUSR:
 654+ 51C6 ~                LD A,(IX+2)
 655+ 51C6 ~                JR MAXANIMSPRS.COMMON
 656+ 51C6 ~            ; *******************************************************************************************************
 657+ 51C6               ENDIF
 658+ 51C6
 659+ 51C6              ; *******************************************************************************************************
 660+ 51C6              ; function to handle CALL MAXANIMSPRS basic extension
 661+ 51C6              ; MAXANIMSPRS (BYTE number)
 662+ 51C6              ; sets new number and moves memory buffers as needed
 663+ 51C6              MAXANIMSPRS:
 664+ 51C6               IF (1 == 1)
 665+ 51C6              	; opening (
 666+ 51C6 CD 2B 66     	CALL CHKCHAR
 667+ 51C9 28           	DB '('
 668+ 51CA              	; get value
 669+ 51CA DD 21 1C 52  	LD IX, GETBYT
 670+ 51CE CD 59 01     	CALL CALBAS
 671+ 51D1 F5               PUSH AF
 672+ 51D2              	; ending )
 673+ 51D2 CD 2B 66     	CALL CHKCHAR
 674+ 51D5 29           	DB ')'
 675+ 51D6 F1               POP AF
 676+ 51D7               ENDIF
 677+ 51D7              .COMMON:
 678+ 51D7 F3               DI
 679+ 51D8              	; save position
 680+ 51D8 E5           	PUSH HL
 681+ 51D9              .ENTRY:
 682+ 51D9 47               LD B,A
 683+ 51DA 3A 60 4F         LD A,(ANIMSPRNUM)
 684+ 51DD 90               SUB B
 685+ 51DE CA E2 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 686+ 51E1 FD 21 64 4F      LD IY,AUTOSGAMPTR
 687+ 51E5 FA F1 51         JP M, .INCREASE
 688+ 51E8                  ; new value is lower than previous one
 689+ 51E8 CD 12 52         CALL .SIZEDIFF
 690+ 51EB CD 1F 50         CALL MAXANIMITEMS.DECREASE_COMMON
 691+ 51EE C3 D9 4F         JP MAXANIMITEMS.E3
 692+ 51F1              .INCREASE:
 693+ 51F1 ED 44            NEG
 694+ 51F3 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 695+ 51F4 CD 12 52         CALL .SIZEDIFF
 696+ 51F7 CD 4B 50         CALL MAXANIMITEMS.INCREASE_COMMON
 697+ 51FA AF               XOR A
 698+ 51FB ED 42            SBC HL,BC ; location of new stuff
 699+ 51FD F1               POP AF
 700+ 51FE C5               PUSH BC
 701+ 51FF 47               LD B,A
 702+ 5200 11 08 00         LD DE,8
 703+ 5203 E5               PUSH HL
 704+ 5204 DD E1            POP IX
 705+ 5206              .L1:
 706+ 5206 DD 36 06 00      LD (IX+6),0 ; active flag
 707+ 520A DD 19            ADD IX,DE
 708+ 520C 10 F8            DJNZ .L1
 709+ 520E C1               POP BC
 710+ 520F C3 FB 4F         JP MAXANIMITEMS.E4
 711+ 5212              .SIZEDIFF:
 712+ 5212 26 00            LD H,0
 713+ 5214 6F               LD L,A
 714+ 5215 CD 18 65         CALL HLx8
 715+ 5218 78               LD A,B
 716+ 5219 32 60 4F         LD (ANIMSPRNUM),A
 717+ 521C 44               LD B,H
 718+ 521D 4D               LD C,L
 719+ 521E C9               RET ; BC=size difference in bytes
 720+ 521F              ; *******************************************************************************************************
 721+ 521F
 722+ 521F               IF (1 == 1)
 723+ 521F              ; *******************************************************************************************************
 724+ 521F              ; function to handle CALL ANIMSPRITE basic extension
 725+ 521F              ; ANIMSPRITE ( BYTE id,
 726+ 521F              ;              BYTE sprite_number,
 727+ 521F              ;              BYTE animation_definition_id,
 728+ 521F              ;              BYTE cyclic_flag )
 729+ 521F              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 730+ 521F              ANIMSPRITE:
 731+ 521F                  ; opening (
 732+ 521F CD 2B 66     	CALL CHKCHAR
 733+ 5222 28           	DB '('
 734+ 5223              	; get sprite animation id
 735+ 5223 DD 21 1C 52  	LD IX, GETBYT
 736+ 5227 CD 59 01     	CALL CALBAS
 737+ 522A F5               PUSH AF
 738+ 522B 3C               INC A
 739+ 522C 4F               LD C,A
 740+ 522D 3A 60 4F         LD A,(ANIMSPRNUM)
 741+ 5230 B9               CP C
 742+ 5231 DA 43 66         JP C,SUBSCRIPT_OUT_OF_RANGE
 743+ 5234              	; comma
 744+ 5234 CD 2B 66     	CALL CHKCHAR
 745+ 5237 2C           	DB ','
 746+ 5238              	; get sprite number
 747+ 5238 DD 21 1C 52  	LD IX, GETBYT
 748+ 523C CD 59 01     	CALL CALBAS
 749+ 523F F5               PUSH AF
 750+ 5240                  ; check if out of bounds
 751+ 5240 FE 20            CP 32
 752+ 5242 D2 43 66         JP NC, SUBSCRIPT_OUT_OF_RANGE
 753+ 5245              	; comma
 754+ 5245 CD 2B 66     	CALL CHKCHAR
 755+ 5248 2C           	DB ','
 756+ 5249              	; get animation definition id
 757+ 5249 DD 21 1C 52  	LD IX, GETBYT
 758+ 524D CD 59 01     	CALL CALBAS
 759+ 5250 F5               PUSH AF
 760+ 5251 3C               INC A
 761+ 5252 4F               LD C,A
 762+ 5253 3A 5D 4F         LD A,(ANIMDEFNUM)
 763+ 5256 B9               CP C
 764+ 5257 DA 43 66         JP C,SUBSCRIPT_OUT_OF_RANGE
 765+ 525A              	; comma
 766+ 525A CD 2B 66     	CALL CHKCHAR
 767+ 525D 2C           	DB ','
 768+ 525E              	; get cyclic flag
 769+ 525E DD 21 1C 52  	LD IX, GETBYT
 770+ 5262 CD 59 01         CALL CALBAS
 771+ 5265 F5           	PUSH AF
 772+ 5266              	; ending )
 773+ 5266 CD 2B 66     	CALL CHKCHAR
 774+ 5269 29           	DB ')'
 775+ 526A              .ENTRY:
 776+ 526A E5               PUSH HL
 777+ 526B DD E1            POP IX
 778+ 526D D9               EXX
 779+ 526E D1               POP DE ; cyclic
 780+ 526F C1               POP BC ; animation definition id
 781+ 5270 E1               POP HL ; sprite number
 782+ 5271 D9               EXX
 783+ 5272 F1               POP AF ; sprite animation id
 784+ 5273 CD 84 4F         CALL GETnthSPRANIM
 785+ 5276 E5               PUSH HL
 786+ 5277 FD E1            POP IY
 787+ 5279 D9               EXX
 788+ 527A FD 74 00         LD (IY),H
 789+ 527D FD 70 04         LD (IY+4),B
 790+ 5280 FD 72 05         LD (IY+5),D
 791+ 5283                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 792+ 5283                  ; following will do preparation for ANIMSTEP situation
 793+ 5283                  ; current item set to above limit and timer to 1
 794+ 5283                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 795+ 5283 FD 36 03 FF      LD (IY+3),255
 796+ 5287 FD 36 01 01      LD (IY+1),1
 797+ 528B FD 36 02 00      LD (IY+2),0
 798+ 528F                  ; mark as sprite animation
 799+ 528F FD 36 07 00      LD (IY+7),0
 800+ 5293 DD E5            PUSH IX
 801+ 5295 E1               POP HL
 802+ 5296 C9               RET
 803+ 5297              ; *******************************************************************************************************
 804+ 5297               ENDIF
 805+ 5297
 806+ 5297               IF (0 == 1)
 807+ 5297 ~            ; *******************************************************************************************************
 808+ 5297 ~            ; same as ANIMSPRITE but for DEFUSR approach
 809+ 5297 ~            ; input IX=pointer to input array, real data from +2
 810+ 5297 ~            ; +02 = ID
 811+ 5297 ~            ; +04 = sprite number
 812+ 5297 ~            ; +06 = animation definition id
 813+ 5297 ~            ; +08 = cyclic flag
 814+ 5297 ~            ANIMSPRITE_DEFUSR:
 815+ 5297 ~                LD C,(IX+2)
 816+ 5297 ~                INC C
 817+ 5297 ~                LD A,(ANIMSPRNUM)
 818+ 5297 ~                CP C
 819+ 5297 ~                RET C ; invalid id
 820+ 5297 ~            	; get sprite number
 821+ 5297 ~                LD A,(IX+4)
 822+ 5297 ~                CP 32
 823+ 5297 ~                RET NC ; invalid sprite id
 824+ 5297 ~                LD B,(IX+6)
 825+ 5297 ~                INC B
 826+ 5297 ~                LD A,(ANIMDEFNUM)
 827+ 5297 ~                CP B
 828+ 5297 ~                RET C ; invalid animation definition id
 829+ 5297 ~                LD A,C
 830+ 5297 ~                DEC A
 831+ 5297 ~                CALL GETnthSPRANIM
 832+ 5297 ~                LD A,(IX+4)
 833+ 5297 ~                LD (HL),A ; +0
 834+ 5297 ~                INC HL
 835+ 5297 ~                LD (HL),1 ; +1
 836+ 5297 ~                INC HL
 837+ 5297 ~                LD (HL),0 ; +2
 838+ 5297 ~                INC HL
 839+ 5297 ~                LD (HL),255 ; +3
 840+ 5297 ~                INC HL
 841+ 5297 ~                DEC B
 842+ 5297 ~                LD (HL),B ; +4
 843+ 5297 ~                INC HL
 844+ 5297 ~                LD A,(IX+8) ; +5
 845+ 5297 ~                LD (HL),A
 846+ 5297 ~                INC HL
 847+ 5297 ~                INC HL
 848+ 5297 ~                LD (HL),0 ; +7
 849+ 5297 ~                RET
 850+ 5297 ~            ; *******************************************************************************************************
 851+ 5297               ENDIF
 852+ 5297
 853+ 5297
 854+ 5297               IF (1 == 1)
 855+ 5297              ; *******************************************************************************************************
 856+ 5297              ; function to handle CALL ANIMCHAR basic extension
 857+ 5297              ; ANIMCHAR ( BYTE id,
 858+ 5297              ;            INT character number 0-767,
 859+ 5297              ;            BYTE animation_definition_id,
 860+ 5297              ;            BYTE cyclic_flag )
 861+ 5297              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 862+ 5297              ANIMCHAR:
 863+ 5297                  ; opening (
 864+ 5297 CD 2B 66     	CALL CHKCHAR
 865+ 529A 28           	DB '('
 866+ 529B              	; get sprite animation id
 867+ 529B DD 21 1C 52  	LD IX, GETBYT
 868+ 529F CD 59 01     	CALL CALBAS
 869+ 52A2 F5               PUSH AF
 870+ 52A3 3C               INC A
 871+ 52A4 4F               LD C,A
 872+ 52A5 3A 60 4F         LD A,(ANIMSPRNUM)
 873+ 52A8 B9               CP C
 874+ 52A9 DA 43 66         JP C,SUBSCRIPT_OUT_OF_RANGE
 875+ 52AC              	; comma
 876+ 52AC CD 2B 66     	CALL CHKCHAR
 877+ 52AF 2C           	DB ','
 878+ 52B0              	; get character number
 879+ 52B0 DD 21 2F 54  	LD IX, FRMQNT
 880+ 52B4 CD 59 01     	CALL CALBAS
 881+ 52B7 D5               PUSH DE
 882+ 52B8                  ; check if out of bounds
 883+ 52B8 7A               LD A,D
 884+ 52B9 FE 03            CP 3
 885+ 52BB D2 43 66         JP NC, SUBSCRIPT_OUT_OF_RANGE
 886+ 52BE              	; comma
 887+ 52BE CD 2B 66     	CALL CHKCHAR
 888+ 52C1 2C           	DB ','
 889+ 52C2              	; get animation definition id
 890+ 52C2 DD 21 1C 52  	LD IX, GETBYT
 891+ 52C6 CD 59 01     	CALL CALBAS
 892+ 52C9 F5               PUSH AF
 893+ 52CA 3C               INC A
 894+ 52CB 4F               LD C,A
 895+ 52CC 3A 5D 4F         LD A,(ANIMDEFNUM)
 896+ 52CF B9               CP C
 897+ 52D0 DA 43 66         JP C,SUBSCRIPT_OUT_OF_RANGE
 898+ 52D3              	; comma
 899+ 52D3 CD 2B 66     	CALL CHKCHAR
 900+ 52D6 2C           	DB ','
 901+ 52D7              	; get cyclic flag
 902+ 52D7 DD 21 1C 52  	LD IX, GETBYT
 903+ 52DB CD 59 01         CALL CALBAS
 904+ 52DE F5           	PUSH AF
 905+ 52DF              	; ending )
 906+ 52DF CD 2B 66     	CALL CHKCHAR
 907+ 52E2 29           	DB ')'
 908+ 52E3              .ENTRY:
 909+ 52E3 E5               PUSH HL
 910+ 52E4 DD E1            POP IX
 911+ 52E6 D9               EXX
 912+ 52E7 D1               POP DE ; cyclic
 913+ 52E8 C1               POP BC ; animation definition id
 914+ 52E9 E1               POP HL ; character number
 915+ 52EA D9               EXX
 916+ 52EB F1               POP AF ; sprite animation id
 917+ 52EC CD 84 4F         CALL GETnthSPRANIM
 918+ 52EF E5               PUSH HL
 919+ 52F0 FD E1            POP IY
 920+ 52F2 D9               EXX
 921+ 52F3 FD 75 00         LD (IY),L
 922+ 52F6 24               INC H ; save character bank+1
 923+ 52F7 FD 74 07         LD (IY+7),H
 924+ 52FA FD 70 04         LD (IY+4),B
 925+ 52FD FD 72 05         LD (IY+5),D
 926+ 5300                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 927+ 5300                  ; following will do preparation for ANIMSTEP situation
 928+ 5300                  ; current item set to above limit and timer to 1
 929+ 5300                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 930+ 5300 FD 36 03 FF      LD (IY+3),255
 931+ 5304 FD 36 01 01      LD (IY+1),1
 932+ 5308 FD 36 02 00      LD (IY+2),0
 933+ 530C DD E5            PUSH IX
 934+ 530E E1               POP HL
 935+ 530F C9               RET
 936+ 5310              ; *******************************************************************************************************
 937+ 5310               ENDIF
 938+ 5310
 939+ 5310               IF (0 == 1)
 940+ 5310 ~            ; *******************************************************************************************************
 941+ 5310 ~            ; same as ANIMCHAR but for DEFUSR approach
 942+ 5310 ~            ; input IX=pointer to input array, real data from +2
 943+ 5310 ~            ; +02 = ID
 944+ 5310 ~            ; +04 = character number
 945+ 5310 ~            ; +06 = animation definition id
 946+ 5310 ~            ; +08 = cyclic flag
 947+ 5310 ~            ANIMCHAR_DEFUSR:
 948+ 5310 ~                LD C,(IX+2)
 949+ 5310 ~                INC C
 950+ 5310 ~                LD A,(ANIMSPRNUM)
 951+ 5310 ~                CP C
 952+ 5310 ~                RET C ; invalid id
 953+ 5310 ~            	; get sprite number
 954+ 5310 ~                LD A,(IX+5)
 955+ 5310 ~                CP 3
 956+ 5310 ~                RET NC ; invalid character (>767)
 957+ 5310 ~                LD B,(IX+6)
 958+ 5310 ~                INC B
 959+ 5310 ~                LD A,(ANIMDEFNUM)
 960+ 5310 ~                CP B
 961+ 5310 ~                RET C ; invalid animation definition id
 962+ 5310 ~                LD A,C
 963+ 5310 ~                DEC A
 964+ 5310 ~                CALL GETnthSPRANIM
 965+ 5310 ~                LD A,(IX+4)
 966+ 5310 ~                LD (HL),A ; +0
 967+ 5310 ~                INC HL
 968+ 5310 ~                LD (HL),1 ; +1
 969+ 5310 ~                INC HL
 970+ 5310 ~                LD (HL),0 ; +2
 971+ 5310 ~                INC HL
 972+ 5310 ~                LD (HL),255 ; +3
 973+ 5310 ~                INC HL
 974+ 5310 ~                DEC B
 975+ 5310 ~                LD (HL),B ; +4
 976+ 5310 ~                INC HL
 977+ 5310 ~                LD A,(IX+8) ; +5
 978+ 5310 ~                LD (HL),A
 979+ 5310 ~                INC HL
 980+ 5310 ~                INC HL
 981+ 5310 ~                LD A,(IX+5)
 982+ 5310 ~                INC A
 983+ 5310 ~                LD (HL),A ; +7
 984+ 5310 ~                RET
 985+ 5310 ~            ; *******************************************************************************************************
 986+ 5310               ENDIF
 987+ 5310
 988+ 5310               IF (0 == 1)
 989+ 5310 ~            ; *******************************************************************************************************
 990+ 5310 ~            ; same as MAXAUTOSGAMS but for DEFUSR approach
 991+ 5310 ~            ; input IX=pointer to input array, real data from +2
 992+ 5310 ~            ; +2 = number
 993+ 5310 ~            MAXAUTOSGAMS_DEFUSR:
 994+ 5310 ~                LD A,(IX+2)
 995+ 5310 ~                JR MAXAUTOSGAMS.COMMON
 996+ 5310 ~            ; *******************************************************************************************************
 997+ 5310               ENDIF
 998+ 5310
 999+ 5310              ; *******************************************************************************************************
1000+ 5310              ; function to handle CALL MAXAUTOSGAMS basic extension
1001+ 5310              ; MAXAUTOSGAMS (BYTE number)
1002+ 5310              ; sets new number and moves memory buffers as needed
1003+ 5310              MAXAUTOSGAMS:
1004+ 5310               IF (1 == 1)
1005+ 5310              	; opening (
1006+ 5310 CD 2B 66     	CALL CHKCHAR
1007+ 5313 28           	DB '('
1008+ 5314              	; get value
1009+ 5314 DD 21 1C 52  	LD IX, GETBYT
1010+ 5318 CD 59 01     	CALL CALBAS
1011+ 531B F5               PUSH AF
1012+ 531C              	; ending )
1013+ 531C CD 2B 66     	CALL CHKCHAR
1014+ 531F 29           	DB ')'
1015+ 5320 F1               POP AF
1016+ 5321               ENDIF
1017+ 5321              .COMMON:
1018+ 5321 F3               DI
1019+ 5322              	; save position
1020+ 5322 E5           	PUSH HL
1021+ 5323              .ENTRY:
1022+ 5323 47               LD B,A
1023+ 5324 3A 63 4F         LD A,(AUTOSGAMNUM)
1024+ 5327 90               SUB B
1025+ 5328 CA E2 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
1026+ 532B FD 21 10 40      LD IY,FREEMEMPTR
1027+ 532F FA 3B 53         JP M, .INCREASE
1028+ 5332                  ; new value is lower than previous one
1029+ 5332 CD 5C 53         CALL .SIZEDIFF
1030+ 5335 CD 1F 50         CALL MAXANIMITEMS.DECREASE_COMMON
1031+ 5338 C3 E2 4F         JP MAXANIMITEMS.EXIT
1032+ 533B              .INCREASE:
1033+ 533B ED 44            NEG
1034+ 533D F5               PUSH AF; save difference for later to set active flag to 0 of new entires
1035+ 533E CD 5C 53         CALL .SIZEDIFF
1036+ 5341 CD 4B 50         CALL MAXANIMITEMS.INCREASE_COMMON
1037+ 5344 AF               XOR A
1038+ 5345 ED 42            SBC HL,BC ; location of new stuff
1039+ 5347 F1               POP AF
1040+ 5348 C5               PUSH BC
1041+ 5349 47               LD B,A
1042+ 534A 11 18 00         LD DE,24
1043+ 534D E5               PUSH HL
1044+ 534E DD E1            POP IX
1045+ 5350              .L1:
1046+ 5350 DD 36 13 00      LD (IX+19),0 ; active flag
1047+ 5354 DD 19            ADD IX,DE
1048+ 5356 10 F8            DJNZ .L1
1049+ 5358 C1               POP BC
1050+ 5359 C3 E2 4F         JP MAXANIMITEMS.EXIT
1051+ 535C              .SIZEDIFF:
1052+ 535C 26 00            LD H,0
1053+ 535E 6F               LD L,A
1054+ 535F CD 18 65         CALL HLx8
1055+ 5362 54               LD D,H
1056+ 5363 5D               LD E,L
1057+ 5364 29               ADD HL,HL
1058+ 5365 19               ADD HL,DE
1059+ 5366 78               LD A,B
1060+ 5367 32 63 4F         LD (AUTOSGAMNUM),A
1061+ 536A 44               LD B,H
1062+ 536B 4D               LD C,L
1063+ 536C C9               RET ; BC=size difference in bytes
1064+ 536D              ; *******************************************************************************************************
1065+ 536D
1066+ 536D               IF (1 == 1)
1067+ 536D              ; *******************************************************************************************************
1068+ 536D              ; function to handle CALL AUTOSGAMDEF basic extension
1069+ 536D              ; AUTOSGAMDEF ( BYTE id,
1070+ 536D              ;               INT VARIABLE x, INT VARIABLE y,
1071+ 536D              ;               INT minimum, INT maximum, INT delta,
1072+ 536D              ;               INT direction =0 horizontal,
1073+ 536D              ;               INT ticks,
1074+ 536D              ;               BYTE sprite_group_count,
1075+ 536D              ;               INT[2][sprite_group_count] VARIABLE sprite_group,
1076+ 536D              ;               BYTE item_number,
1077+ 536D              ;               INT[] VARIABLE sprite_animations_negative_direction,
1078+ 536D              ;               INT[] VARIABLE sprite_animations_positive_direction
1079+ 536D              AUTOSGAMDEF:
1080+ 536D                  ; opening (
1081+ 536D CD 2B 66     	CALL CHKCHAR
1082+ 5370 28           	DB '('
1083+ 5371              	; get sprite animation id
1084+ 5371 DD 21 1C 52  	LD IX, GETBYT
1085+ 5375 CD 59 01     	CALL CALBAS
1086+ 5378 F5               PUSH AF
1087+ 5379 3C               INC A
1088+ 537A 4F               LD C,A
1089+ 537B 3A 63 4F         LD A,(AUTOSGAMNUM)
1090+ 537E B9               CP C
1091+ 537F DA 43 66         JP C,SUBSCRIPT_OUT_OF_RANGE
1092+ 5382 F1               POP AF
1093+ 5383 E5               PUSH HL
1094+ 5384 CD 90 4F         CALL GETnthAUTOSGAM
1095+ 5387 22 0C 63         LD (BLIT_TMP),HL ; for later
1096+ 538A E1               POP HL
1097+ 538B              	; comma
1098+ 538B CD 2B 66     	CALL CHKCHAR
1099+ 538E 2C           	DB ','
1100+ 538F              	; get address of the X coordinate variable
1101+ 538F DD 21 A4 5E  	LD IX, PTRGET
1102+ 5393 CD 59 01     	CALL CALBAS
1103+ 5396 DD 2A 0C 63  	LD IX,(BLIT_TMP)
1104+ 539A DD 73 00         LD (IX+0),E
1105+ 539D DD 72 01         LD (IX+1),D
1106+ 53A0              	; comma
1107+ 53A0 CD 2B 66     	CALL CHKCHAR
1108+ 53A3 2C           	DB ','
1109+ 53A4              	; get address of the Y coordinate variable
1110+ 53A4 DD 21 A4 5E  	LD IX, PTRGET
1111+ 53A8 CD 59 01     	CALL CALBAS
1112+ 53AB DD 2A 0C 63  	LD IX,(BLIT_TMP)
1113+ 53AF DD 73 02         LD (IX+2),E
1114+ 53B2 DD 72 03         LD (IX+3),D
1115+ 53B5              	; comma
1116+ 53B5 CD 2B 66     	CALL CHKCHAR
1117+ 53B8 2C           	DB ','
1118+ 53B9              	; get minimum value
1119+ 53B9 DD 21 2F 54  	LD IX, FRMQNT
1120+ 53BD CD 59 01     	CALL CALBAS
1121+ 53C0 DD 2A 0C 63  	LD IX,(BLIT_TMP)
1122+ 53C4 DD 73 04         LD (IX+4),E
1123+ 53C7 DD 72 05         LD (IX+5),D
1124+ 53CA              	; comma
1125+ 53CA CD 2B 66     	CALL CHKCHAR
1126+ 53CD 2C           	DB ','
1127+ 53CE              	; get maximum value
1128+ 53CE DD 21 2F 54  	LD IX, FRMQNT
1129+ 53D2 CD 59 01     	CALL CALBAS
1130+ 53D5 DD 2A 0C 63  	LD IX,(BLIT_TMP)
1131+ 53D9 DD 73 06         LD (IX+6),E
1132+ 53DC DD 72 07         LD (IX+7),D
1133+ 53DF              	; comma
1134+ 53DF CD 2B 66     	CALL CHKCHAR
1135+ 53E2 2C           	DB ','
1136+ 53E3              	; get delta value
1137+ 53E3 DD 21 2F 54  	LD IX, FRMQNT
1138+ 53E7 CD 59 01     	CALL CALBAS
1139+ 53EA DD 2A 0C 63  	LD IX,(BLIT_TMP)
1140+ 53EE DD 73 08         LD (IX+8),E
1141+ 53F1 DD 72 09         LD (IX+9),D
1142+ 53F4              	; comma
1143+ 53F4 CD 2B 66     	CALL CHKCHAR
1144+ 53F7 2C           	DB ','
1145+ 53F8              	; get direction value
1146+ 53F8 DD 21 2F 54  	LD IX, FRMQNT
1147+ 53FC CD 59 01     	CALL CALBAS
1148+ 53FF DD 2A 0C 63  	LD IX,(BLIT_TMP)
1149+ 5403 DD 73 0A         LD (IX+10),E
1150+ 5406              	; comma
1151+ 5406 CD 2B 66     	CALL CHKCHAR
1152+ 5409 2C           	DB ','
1153+ 540A              	; get ticks value
1154+ 540A DD 21 2F 54  	LD IX, FRMQNT
1155+ 540E CD 59 01     	CALL CALBAS
1156+ 5411 DD 2A 0C 63  	LD IX,(BLIT_TMP)
1157+ 5415 DD 73 14         LD (IX+20),E
1158+ 5418 DD 72 15         LD (IX+21),D
1159+ 541B              	; comma
1160+ 541B CD 2B 66     	CALL CHKCHAR
1161+ 541E 2C           	DB ','
1162+ 541F              	; get sprite group count
1163+ 541F DD 21 1C 52  	LD IX, GETBYT
1164+ 5423 CD 59 01     	CALL CALBAS
1165+ 5426 B7               OR A
1166+ 5427 CA 43 66         JP Z,SUBSCRIPT_OUT_OF_RANGE
1167+ 542A DD 2A 0C 63  	LD IX,(BLIT_TMP)
1168+ 542E DD 77 0B         LD (IX+11),A
1169+ 5431              	; comma
1170+ 5431 CD 2B 66     	CALL CHKCHAR
1171+ 5434 2C           	DB ','
1172+ 5435              	; get sprite group definition array data pointer
1173+ 5435 DD 2A 0C 63  	LD IX,(BLIT_TMP)
1174+ 5439 DD 5E 0B         LD E,(IX+11)
1175+ 543C 16 03        	LD D,3
1176+ 543E 3E 02        	LD A,2
1177+ 5440 47           	LD B,A
1178+ 5441 CD 58 66     	CALL GET_BASIC_ARRAY_DATA_POINTER
1179+ 5444 DD 2A 0C 63  	LD IX,(BLIT_TMP)
1180+ 5448 DD 71 0C     	LD (IX+12),C
1181+ 544B DD 70 0D         LD (IX+13),B
1182+ 544E              	; comma
1183+ 544E CD 2B 66     	CALL CHKCHAR
1184+ 5451 2C           	DB ','
1185+ 5452              	; get sprite animation array size
1186+ 5452 DD 21 1C 52  	LD IX,GETBYT
1187+ 5456 CD 59 01     	CALL CALBAS
1188+ 5459 DD 2A 0C 63  	LD IX,(BLIT_TMP)
1189+ 545D DD 77 0E         LD (IX+14),A
1190+ 5460 B7               OR A
1191+ 5461 CA 43 66         JP Z,SUBSCRIPT_OUT_OF_RANGE
1192+ 5464              	; comma
1193+ 5464 CD 2B 66     	CALL CHKCHAR
1194+ 5467 2C           	DB ','
1195+ 5468                  ; get array pointer for negative direction
1196+ 5468 DD 2A 0C 63  	LD IX,(BLIT_TMP)
1197+ 546C DD 56 0E         LD D,(IX+14)
1198+ 546F 3E 02            LD A,2
1199+ 5471 06 01            LD B,1
1200+ 5473 CD 58 66         CALL GET_BASIC_ARRAY_DATA_POINTER
1201+ 5476 DD 2A 0C 63  	LD IX,(BLIT_TMP)
1202+ 547A DD 71 0F         LD (IX+15),C
1203+ 547D DD 70 10         LD (IX+16),B
1204+ 5480              	; comma
1205+ 5480 CD 2B 66     	CALL CHKCHAR
1206+ 5483 2C           	DB ','
1207+ 5484                  ; get array pointer for positive direction
1208+ 5484 DD 2A 0C 63  	LD IX,(BLIT_TMP)
1209+ 5488 DD 56 0E         LD D,(IX+14)
1210+ 548B 3E 02            LD A,2
1211+ 548D 06 01            LD B,1
1212+ 548F CD 58 66         CALL GET_BASIC_ARRAY_DATA_POINTER
1213+ 5492 DD 2A 0C 63  	LD IX,(BLIT_TMP)
1214+ 5496 DD 71 11         LD (IX+17),C
1215+ 5499 DD 70 12         LD (IX+18),B
1216+ 549C              	; ending )
1217+ 549C CD 2B 66     	CALL CHKCHAR
1218+ 549F 29           	DB ')'
1219+ 54A0 C9               RET
1220+ 54A1              ; *******************************************************************************************************
1221+ 54A1               ENDIF
1222+ 54A1
1223+ 54A1               IF (0 == 1)
1224+ 54A1 ~            ; *******************************************************************************************************
1225+ 54A1 ~            ; same as AUTOSGAMDEF but for DEFUSR approach
1226+ 54A1 ~            ; input IX=pointer to input array, real data from +2
1227+ 54A1 ~            ; +02 = ID
1228+ 54A1 ~            ; +04 = pointer to X variable
1229+ 54A1 ~            ; +06 = pointer to Y variable
1230+ 54A1 ~            ; +08 = minimum
1231+ 54A1 ~            ; +10 = maximum
1232+ 54A1 ~            ; +12 = delta
1233+ 54A1 ~            ; +14 = direction
1234+ 54A1 ~            ; +16 = ticks
1235+ 54A1 ~            ; +18 = sprite group count
1236+ 54A1 ~            ; +20 = sprite group array pointer
1237+ 54A1 ~            ; +22 = item number
1238+ 54A1 ~            ; +24 = sprite animations negative direction array pointer
1239+ 54A1 ~            ; +26 = sprite animations positive direction array pointer
1240+ 54A1 ~            AUTOSGAMDEF_DEFUSR:
1241+ 54A1 ~                LD C,(IX+2)
1242+ 54A1 ~                INC C
1243+ 54A1 ~                LD A,(AUTOSGAMNUM)
1244+ 54A1 ~                CP C
1245+ 54A1 ~                RET C ; invalid id
1246+ 54A1 ~                LD A,C
1247+ 54A1 ~                DEC A
1248+ 54A1 ~                CALL GETnthAUTOSGAM
1249+ 54A1 ~                PUSH HL
1250+ 54A1 ~                POP IY
1251+ 54A1 ~                ; X variable
1252+ 54A1 ~                LD A,(IX+4)
1253+ 54A1 ~                LD (IY+0),A
1254+ 54A1 ~                LD A,(IX+5)
1255+ 54A1 ~                LD (IY+1),A
1256+ 54A1 ~            	; Y variable
1257+ 54A1 ~                LD A,(IX+6)
1258+ 54A1 ~                LD (IY+2),A
1259+ 54A1 ~                LD A,(IX+7)
1260+ 54A1 ~                LD (IY+3),A
1261+ 54A1 ~            	; get minimum value
1262+ 54A1 ~                LD A,(IX+8)
1263+ 54A1 ~                LD (IY+4),A
1264+ 54A1 ~                LD A,(IX+9)
1265+ 54A1 ~                LD (IY+5),A
1266+ 54A1 ~            	; get maximum value
1267+ 54A1 ~                LD A,(IX+10)
1268+ 54A1 ~                LD (IY+6),A
1269+ 54A1 ~                LD A,(IX+11)
1270+ 54A1 ~                LD (IY+7),A
1271+ 54A1 ~            	; get delta value
1272+ 54A1 ~                LD A,(IX+12)
1273+ 54A1 ~                LD (IY+8),A
1274+ 54A1 ~                LD A,(IX+13)
1275+ 54A1 ~                LD (IY+9),A
1276+ 54A1 ~            	; get direction value
1277+ 54A1 ~                LD A,(IX+14)
1278+ 54A1 ~                LD (IY+10),A
1279+ 54A1 ~            	; get ticks value
1280+ 54A1 ~                LD A,(IX+16)
1281+ 54A1 ~                LD (IY+20),A
1282+ 54A1 ~                LD A,(IX+17)
1283+ 54A1 ~                LD (IY+21),A
1284+ 54A1 ~            	; get sprite group count
1285+ 54A1 ~                LD A,(IX+18)
1286+ 54A1 ~                LD (IY+11),A
1287+ 54A1 ~            	; get sprite group definition array data pointer
1288+ 54A1 ~                LD A,(IX+20)
1289+ 54A1 ~                LD (IY+12),A
1290+ 54A1 ~                LD A,(IX+21)
1291+ 54A1 ~                LD (IY+13),A
1292+ 54A1 ~            	; get sprite animation array size
1293+ 54A1 ~                LD A,(IX+22)
1294+ 54A1 ~                LD (IY+14),A
1295+ 54A1 ~                ; get array pointer for negative direction
1296+ 54A1 ~                LD A,(IX+24)
1297+ 54A1 ~                LD (IY+15),A
1298+ 54A1 ~                LD A,(IX+25)
1299+ 54A1 ~                LD (IY+16),A
1300+ 54A1 ~                ; get array pointer for positive direction
1301+ 54A1 ~                LD A,(IX+26)
1302+ 54A1 ~                LD (IY+17),A
1303+ 54A1 ~                LD A,(IX+27)
1304+ 54A1 ~                LD (IY+18),A
1305+ 54A1 ~                RET
1306+ 54A1 ~            ; *******************************************************************************************************
1307+ 54A1               ENDIF
1308+ 54A1
1309+ 54A1               IF (1 == 1)
1310+ 54A1              ; *******************************************************************************************************
1311+ 54A1              ; function to handle CALL AUTOSGAMSTART basic extension
1312+ 54A1              ; AUTOSGAMSTART ( BYTE id )
1313+ 54A1              AUTOSGAMSTART:
1314+ 54A1 3E 01            LD A,1
1315+ 54A3              .COMMON:
1316+ 54A3 32 CF 54         LD (.SETVALUE+3),A
1317+ 54A6                  ; opening (
1318+ 54A6 CD 2B 66     	CALL CHKCHAR
1319+ 54A9 28           	DB '('
1320+ 54AA              	; get sprite animation id
1321+ 54AA DD 21 1C 52  	LD IX, GETBYT
1322+ 54AE CD 59 01     	CALL CALBAS
1323+ 54B1 F5               PUSH AF
1324+ 54B2 3C               INC A
1325+ 54B3 4F               LD C,A
1326+ 54B4 3A 63 4F         LD A,(AUTOSGAMNUM)
1327+ 54B7 B9               CP C
1328+ 54B8 DA 43 66         JP C,SUBSCRIPT_OUT_OF_RANGE
1329+ 54BB F1               POP AF
1330+ 54BC E5               PUSH HL
1331+ 54BD CD 90 4F         CALL GETnthAUTOSGAM
1332+ 54C0 E5               PUSH HL
1333+ 54C1 DD E1            POP IX
1334+ 54C3 E1               POP HL
1335+ 54C4 DD E5            PUSH IX
1336+ 54C6              	; ending )
1337+ 54C6 CD 2B 66     	CALL CHKCHAR
1338+ 54C9 29           	DB ')'
1339+ 54CA
1340+ 54CA                  ; so syntax is fine
1341+ 54CA DD E1            POP IX
1342+ 54CC              .SETVALUE:
1343+ 54CC DD 36 13 01      LD (IX+19),1 ; active flag
1344+ 54D0                  ; set initial timer
1345+ 54D0 DD 7E 14         LD A,(IX+20)
1346+ 54D3 DD 77 16         LD (IX+22),A
1347+ 54D6 DD 7E 15         LD A,(IX+21)
1348+ 54D9 DD 77 17         LD (IX+23),A
1349+ 54DC C9               RET
1350+ 54DD              ; *******************************************************************************************************
1351+ 54DD
1352+ 54DD              ; *******************************************************************************************************
1353+ 54DD              ; function to handle CALL AUTOSGAMSTOP basic extension
1354+ 54DD              ; AUTOSGAMSTOP ( BYTE id )
1355+ 54DD              AUTOSGAMSTOP:
1356+ 54DD AF               XOR A
1357+ 54DE 18 C3            JR AUTOSGAMSTART.COMMON
1358+ 54E0              ; *******************************************************************************************************
1359+ 54E0               ENDIF
1360+ 54E0
1361+ 54E0               IF (0 == 1)
1362+ 54E0 ~            ; *******************************************************************************************************
1363+ 54E0 ~            ; function to handle CALL AUTOSGAMSTART basic extension in DEFUSR mode
1364+ 54E0 ~            ; input IX=pointer to input array, real data from +2
1365+ 54E0 ~            ; +2 = source address
1366+ 54E0 ~            AUTOSGAMSTART_DEFUSR:
1367+ 54E0 ~                LD A,1
1368+ 54E0 ~            .COMMON:
1369+ 54E0 ~                LD (.SETVALUE+3),A
1370+ 54E0 ~                LD C,(IX+2)
1371+ 54E0 ~                INC C
1372+ 54E0 ~                LD A,(AUTOSGAMNUM)
1373+ 54E0 ~                CP C
1374+ 54E0 ~                RET C ; invalid id
1375+ 54E0 ~                LD A,C
1376+ 54E0 ~                DEC A
1377+ 54E0 ~                CALL GETnthAUTOSGAM
1378+ 54E0 ~                PUSH HL
1379+ 54E0 ~                POP IX
1380+ 54E0 ~            .SETVALUE:
1381+ 54E0 ~                LD (IX+19),1 ; active flag
1382+ 54E0 ~                ; set initial timer
1383+ 54E0 ~                LD A,(IX+20)
1384+ 54E0 ~                LD (IX+22),A
1385+ 54E0 ~                LD A,(IX+21)
1386+ 54E0 ~                LD (IX+23),A
1387+ 54E0 ~                RET
1388+ 54E0 ~            ; *******************************************************************************************************
1389+ 54E0 ~
1390+ 54E0 ~            ; *******************************************************************************************************
1391+ 54E0 ~            ; function to handle CALL AUTOSGAMSTOP basic extension in DEFUSR mode
1392+ 54E0 ~            ; input IX=pointer to input array, real data from +2
1393+ 54E0 ~            ; +2 = source address
1394+ 54E0 ~            AUTOSGAMSTOP_DEFUSR:
1395+ 54E0 ~                XOR A
1396+ 54E0 ~                JR AUTOSGAMSTART_DEFUSR.COMMON
1397+ 54E0 ~            ; *******************************************************************************************************
1398+ 54E0               ENDIF
1399+ 54E0
1400+ 54E0               IF (1 == 1)
1401+ 54E0              ; *******************************************************************************************************
1402+ 54E0              ; function to handle CALL ANIMSTEP basic extension
1403+ 54E0              ; two forms
1404+ 54E0              ; ANIMSTEP ( BYTE id )
1405+ 54E0              ; or
1406+ 54E0              ; ANIMSTEP ( BYTE item_number,
1407+ 54E0              ;            INT[] sprite_animations )
1408+ 54E0              ANIMSTEP:
1409+ 54E0 11 5F 55         LD DE,ANIMSTARTSTOP_COMMON.STEP
1410+ 54E3 18 08            JR ANIMSTARTSTOP_COMMON
1411+ 54E5              ; *******************************************************************************************************
1412+ 54E5              ; *******************************************************************************************************
1413+ 54E5              ; function to handle CALL ANIMSTART basic extension
1414+ 54E5              ; two forms
1415+ 54E5              ; ANIMSTART ( BYTE id )
1416+ 54E5              ; or
1417+ 54E5              ; ANIMSTART ( BYTE item_number,
1418+ 54E5              ;             INT[] sprite_animations )
1419+ 54E5              ; sets active flag to 1
1420+ 54E5              ANIMSTART:
1421+ 54E5 11 4D 55         LD DE,ANIMSTARTSTOP_COMMON.START
1422+ 54E8 18 03            JR ANIMSTARTSTOP_COMMON
1423+ 54EA              ; *******************************************************************************************************
1424+ 54EA              ; *******************************************************************************************************
1425+ 54EA              ; function to handle CALL ANIMSTOP basic extension
1426+ 54EA              ; two forms
1427+ 54EA              ; ANIMSTOP ( BYTE id )
1428+ 54EA              ; or
1429+ 54EA              ; ANIMSTOP ( BYTE item_number,
1430+ 54EA              ;            INT[] sprite_animations )
1431+ 54EA              ; sets active flag to 0
1432+ 54EA              ANIMSTOP:
1433+ 54EA 11 5A 55         LD DE,ANIMSTARTSTOP_COMMON.STOP
1434+ 54ED              ; *******************************************************************************************************
1435+ 54ED              ANIMSTARTSTOP_COMMON:
1436+ 54ED ED 53 4B 55      LD (ANIMSTARTSTOP_COMMON.FN+1),DE
1437+ 54F1                  ; opening (
1438+ 54F1 CD 2B 66     	CALL CHKCHAR
1439+ 54F4 28           	DB '('
1440+ 54F5              	; get sprite animation id or array size
1441+ 54F5 DD 21 1C 52  	LD IX,GETBYT
1442+ 54F9 CD 59 01     	CALL CALBAS
1443+ 54FC F5               PUSH AF
1444+ 54FD                  ; check if comma present
1445+ 54FD CD 35 66         CALL GETPREVCHAR
1446+ 5500 23               INC HL
1447+ 5501 FE 2C            CP ','
1448+ 5503 28 0E            JR Z,.L1
1449+ 5505 FE 29            CP ')'
1450+ 5507 C2 4F 66         JP NZ,SYNTAX_ERROR
1451+ 550A                  ; ok so single argument variant
1452+ 550A F1               POP AF
1453+ 550B E5               PUSH HL
1454+ 550C F3               DI
1455+ 550D CD 39 55         CALL .SETVALUE
1456+ 5510 FB               EI
1457+ 5511 E1               POP HL
1458+ 5512 C9               RET
1459+ 5513              .L1:
1460+ 5513                  ; get array pointer
1461+ 5513 D1               POP DE
1462+ 5514 D5               PUSH DE
1463+ 5515 3E 02            LD A,2
1464+ 5517 06 01            LD B,1
1465+ 5519 CD 58 66         CALL GET_BASIC_ARRAY_DATA_POINTER
1466+ 551C C5               PUSH BC
1467+ 551D              	; ending )
1468+ 551D CD 2B 66     	CALL CHKCHAR
1469+ 5520 29           	DB ')'
1470+ 5521 D1               POP DE ; array pointer
1471+ 5522 C1               POP BC ; number of items
1472+ 5523 78               LD A,B
1473+ 5524 B7               OR A
1474+ 5525 CA 43 66         JP Z,SUBSCRIPT_OUT_OF_RANGE
1475+ 5528 E5               PUSH HL
1476+ 5529 F3               DI
1477+ 552A              .L2:
1478+ 552A C5               PUSH BC
1479+ 552B 1A               LD A,(DE)
1480+ 552C 13          > INC DE
1480+ 552D 13          > INC DE
1481+ 552E D5               PUSH DE
1482+ 552F CD 39 55         CALL .SETVALUE
1483+ 5532 D1               POP DE
1484+ 5533 C1               POP BC
1485+ 5534 10 F4            DJNZ .L2
1486+ 5536 FB               EI
1487+ 5537 E1               POP HL
1488+ 5538 C9               RET
1489+ 5539
1490+ 5539              .SETVALUE:
1491+ 5539 47               LD B,A
1492+ 553A 3C               INC A
1493+ 553B 4F               LD C,A
1494+ 553C 3A 60 4F         LD A,(ANIMSPRNUM)
1495+ 553F B9               CP C
1496+ 5540 DA 43 66         JP C,SUBSCRIPT_OUT_OF_RANGE
1497+ 5543 78               LD A,B
1498+ 5544 CD 84 4F         CALL GETnthSPRANIM
1499+ 5547 E5               PUSH HL
1500+ 5548 DD E1            POP IX
1501+ 554A              .FN:
1502+ 554A C3 00 00         JP 0
1503+ 554D              .START:
1504+ 554D DD 36 06 01      LD (IX+6),1 ; active flag
1505+ 5551 DD 36 03 00      LD (IX+3),0 ; current item
1506+ 5555 06 00            LD B,0 ; setup timer
1507+ 5557 C3 F0 55         JP SETUP_ANIM_STEP
1508+ 555A              .STOP:
1509+ 555A DD 36 06 00      LD (IX+6),0 ; active flag
1510+ 555E C9               RET
1511+ 555F              .STEP:
1512+ 555F 06 00            LD B,0
1513+ 5561 C3 94 55         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1514+ 5564              ; *******************************************************************************************************
1515+ 5564               ENDIF
1516+ 5564
1517+ 5564              ; *******************************************************************************************************
1518+ 5564              ; helper function to locate single animation and execute operation
1519+ 5564              ; needs to have jump set to a correct function
1520+ 5564              ; used by SGAM helper routines so always needed
1521+ 5564              ; input A=animation item
1522+ 5564              ANIM_SETVALUE:
1523+ 5564 47               LD B,A
1524+ 5565 3C               INC A
1525+ 5566 4F               LD C,A
1526+ 5567 3A 60 4F         LD A,(ANIMSPRNUM)
1527+ 556A B9               CP C
1528+ 556B D8               RET C ; out of range, so do nothing
1529+ 556C 78               LD A,B
1530+ 556D CD 84 4F         CALL GETnthSPRANIM
1531+ 5570 E5               PUSH HL
1532+ 5571 DD E1            POP IX
1533+ 5573              .FN:
1534+ 5573 C3 00 00         JP 0
1535+ 5576              ; *******************************************************************************************************
1536+ 5576
1537+ 5576               IF (0 == 1)
1538+ 5576 ~            ; *******************************************************************************************************
1539+ 5576 ~            ; helper function to set values of multiple animations
1540+ 5576 ~            ; needs to have jump set to a correct function
1541+ 5576 ~            ; input B=number of animation item
1542+ 5576 ~            ; input DE=animation item array
1543+ 5576 ~            ANIM_LIST_SETVALUE:
1544+ 5576 ~                DI
1545+ 5576 ~                PUSH BC
1546+ 5576 ~                LD A,(DE)
1547+ 5576 ~                .2 INC DE
1548+ 5576 ~                PUSH DE
1549+ 5576 ~                CALL ANIM_SETVALUE
1550+ 5576 ~                POP DE
1551+ 5576 ~                POP BC
1552+ 5576 ~                DJNZ ANIM_LIST_SETVALUE
1553+ 5576 ~                EI
1554+ 5576 ~                RET
1555+ 5576 ~            ; *******************************************************************************************************
1556+ 5576 ~
1557+ 5576 ~            ; *******************************************************************************************************
1558+ 5576 ~            ; function to handle single item ANIMSTEP in DEFUSR mode
1559+ 5576 ~            ; input IX=pointer to input array, real data from +2
1560+ 5576 ~            ; +2 = animation id
1561+ 5576 ~            ANIMSTEP_SINGLE_DEFUSR:
1562+ 5576 ~                LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1563+ 5576 ~            .L1:
1564+ 5576 ~                LD (ANIM_SETVALUE.FN+1),HL
1565+ 5576 ~                LD A,(IX+2)
1566+ 5576 ~                JR ANIM_SETVALUE
1567+ 5576 ~            .STEP:
1568+ 5576 ~                LD B,0
1569+ 5576 ~                JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1570+ 5576 ~            ; *******************************************************************************************************
1571+ 5576 ~
1572+ 5576 ~            ; *******************************************************************************************************
1573+ 5576 ~            ; function to handle multi item ANIMSTEP in DEFUSR mode
1574+ 5576 ~            ; input IX=pointer to input array, real data from +2
1575+ 5576 ~            ; +2 = list size
1576+ 5576 ~            ; +4 = array pointer holding items
1577+ 5576 ~            ANIMSTEP_MULTI_DEFUSR:
1578+ 5576 ~                LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1579+ 5576 ~            .L1:
1580+ 5576 ~                LD (ANIM_SETVALUE.FN+1),HL
1581+ 5576 ~                LD B,(IX+2)
1582+ 5576 ~                LD E,(IX+4)
1583+ 5576 ~                LD D,(IX+5)
1584+ 5576 ~                JR ANIM_LIST_SETVALUE
1585+ 5576 ~            ; *******************************************************************************************************
1586+ 5576 ~
1587+ 5576 ~            ; *******************************************************************************************************
1588+ 5576 ~            ; function to handle single item ANIMSTART in DEFUSR mode
1589+ 5576 ~            ; input IX=pointer to input array, real data from +2
1590+ 5576 ~            ; +2 = animation id
1591+ 5576 ~            ANIMSTART_SINGLE_DEFUSR:
1592+ 5576 ~                LD HL,ANIMSTART_SINGLE_DEFUSR.START
1593+ 5576 ~                JR ANIMSTEP_SINGLE_DEFUSR.L1
1594+ 5576 ~            .START:
1595+ 5576 ~                LD (IX+6),1 ; active flag
1596+ 5576 ~                LD (IX+3),0 ; current item
1597+ 5576 ~                LD B,0 ; setup timer
1598+ 5576 ~                JP SETUP_ANIM_STEP
1599+ 5576 ~            ; *******************************************************************************************************
1600+ 5576 ~
1601+ 5576 ~            ; *******************************************************************************************************
1602+ 5576 ~            ; function to handle multi item ANIMSTART in DEFUSR mode
1603+ 5576 ~            ; input IX=pointer to input array, real data from +2
1604+ 5576 ~            ; +2 = list size
1605+ 5576 ~            ; +4 = array pointer holding items
1606+ 5576 ~            ANIMSTART_MULTI_DEFUSR:
1607+ 5576 ~                LD HL,ANIMSTART_SINGLE_DEFUSR.START
1608+ 5576 ~                JR ANIMSTEP_MULTI_DEFUSR.L1
1609+ 5576 ~            ; *******************************************************************************************************
1610+ 5576 ~
1611+ 5576 ~            ; *******************************************************************************************************
1612+ 5576 ~            ; function to handle single item ANIMSTOP in DEFUSR mode
1613+ 5576 ~            ; input IX=pointer to input array, real data from +2
1614+ 5576 ~            ; +2 = animation id
1615+ 5576 ~            ANIMSTOP_SINGLE_DEFUSR:
1616+ 5576 ~                LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1617+ 5576 ~                JR ANIMSTEP_SINGLE_DEFUSR.L1
1618+ 5576 ~            .STOP:
1619+ 5576 ~                LD (IX+6),0 ; active flag
1620+ 5576 ~                RET
1621+ 5576 ~            ; *******************************************************************************************************
1622+ 5576 ~
1623+ 5576 ~            ; *******************************************************************************************************
1624+ 5576 ~            ; function to handle multi item ANIMSTOP in DEFUSR mode
1625+ 5576 ~            ; input IX=pointer to input array, real data from +2
1626+ 5576 ~            ; +2 = list size
1627+ 5576 ~            ; +4 = array pointer holding items
1628+ 5576 ~            ANIMSTOP_MULTI_DEFUSR:
1629+ 5576 ~                LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1630+ 5576 ~                JR ANIMSTEP_MULTI_DEFUSR.L1
1631+ 5576 ~            ; *******************************************************************************************************
1632+ 5576               ENDIF
1633+ 5576
1634+ 5576              ; *******************************************************************************************************
1635+ 5576              ; function processes animations during vblank period
1636+ 5576              PROCESS_ANIMATIONS:
1637+ 5576 3A 60 4F         LD A,(ANIMSPRNUM)
1638+ 5579 B7               OR A
1639+ 557A C8               RET Z; no animations defined
1640+ 557B 47               LD B,A
1641+ 557C DD 2A 61 4F      LD IX,(ANIMSPRPTR)
1642+ 5580              .L1:
1643+ 5580 C5               PUSH BC
1644+ 5581 06 00            LD B,0 ; normal mode, change on timer expiry only
1645+ 5583 CD 8F 55         CALL PROCESS_SINGLE_ANIMATION
1646+ 5586 11 08 00         LD DE,8
1647+ 5589 DD 19            ADD IX,DE
1648+ 558B C1               POP BC
1649+ 558C 10 F2            DJNZ .L1
1650+ 558E C9               RET
1651+ 558F              ; *******************************************************************************************************
1652+ 558F
1653+ 558F              ; *******************************************************************************************************
1654+ 558F              ; processes single sprite animation
1655+ 558F              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
1656+ 558F              ; on timer expiry goes to next animation item
1657+ 558F              ; input IX=sprite animation pointer
1658+ 558F              ; input B=1 force mode, activate animation action regardless of expired timer
1659+ 558F              PROCESS_SINGLE_ANIMATION:
1660+ 558F DD 7E 06         LD A,(IX+6); active
1661+ 5592 B7               OR A
1662+ 5593 C8               RET Z ; inactive animation
1663+ 5594              .INACTIVE_TOO:
1664+ 5594 DD 6E 01         LD L,(IX+1)
1665+ 5597 DD 66 02         LD H,(IX+2) ; HL=end time
1666+ 559A 2B               DEC HL
1667+ 559B DD 75 01         LD (IX+1),L
1668+ 559E DD 74 02         LD (IX+2),H
1669+ 55A1 7D               LD A,L
1670+ 55A2 B4               OR H
1671+ 55A3 28 06            JR Z,.STEP
1672+ 55A5 05               DEC B
1673+ 55A6 04               INC B
1674+ 55A7 C8               RET Z ; not forced mode, return
1675+ 55A8 C3 F0 55         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
1676+ 55AB              .STEP:
1677+ 55AB 06 00            LD B,0; setup timer
1678+ 55AD DD 34 03         INC (IX+3) ; current animation item
1679+ 55B0 C3 F0 55         JP SETUP_ANIM_STEP
1680+ 55B3              ; *******************************************************************************************************
1681+ 55B3
1682+ 55B3              ; *******************************************************************************************************
1683+ 55B3              ; function will setup sprite animation after current item change
1684+ 55B3              ; input A=current animation definition
1685+ 55B3              ; input IX=pointer to sprite animation
1686+ 55B3              ; input B=1 skip timer setup
1687+ 55B3              ; output IY=pointer to animation item
1688+ 55B3              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
1689+ 55B3              ; basically sets new end time for current animation
1690+ 55B3              INIT_CURRENT_ANIMATION:
1691+ 55B3 CD 78 4F         CALL GETnthANIMDEF
1692+ 55B6 DD 7E 03         LD A,(IX+3) ; current animation item
1693+ 55B9 BE               CP (HL) ; number of animation items in the animation definition
1694+ 55BA 38 0A            JR C,.L3 ; last item not reached
1695+ 55BC                  ; last item reached
1696+ 55BC DD 7E 05         LD A,(IX+5) ; cyclic flag
1697+ 55BF B7               OR A
1698+ 55C0 28 2C            JR Z,.ERROR ; non-cyclic animation
1699+ 55C2                  ; cyclic animation, restart
1700+ 55C2 DD 36 03 00      LD (IX+3),0; current item
1701+ 55C6              .L3:
1702+ 55C6                  ; HL = animation definition
1703+ 55C6 23               INC HL ; skip animation definition size field
1704+ 55C7 16 00            LD D,0
1705+ 55C9 DD 5E 03         LD E,(IX+3); current item
1706+ 55CC 19               ADD HL,DE
1707+ 55CD 4E               LD C,(HL) ; current animation item
1708+ 55CE 0C               INC C
1709+ 55CF 3A 5A 4F         LD A,(ANIMITEMNUM)
1710+ 55D2 B9               CP C
1711+ 55D3 38 19            JR C,.ERROR ; invalid animation item, stop animation
1712+ 55D5 0D               DEC C
1713+ 55D6 79               LD A,C
1714+ 55D7 CD 6F 4F         CALL GETnthANIMITEM
1715+ 55DA E5               PUSH HL
1716+ 55DB FD E1            POP IY ; IY=animation item
1717+ 55DD 05               DEC B
1718+ 55DE 28 0C            JR Z,.EXIT
1719+ 55E0 FD 5E 01         LD E,(IY+1)
1720+ 55E3 FD 56 02         LD D,(IY+2) ; duration
1721+ 55E6 DD 73 01         LD (IX+1),E
1722+ 55E9 DD 72 02         LD (IX+2),D
1723+ 55EC              .EXIT:
1724+ 55EC AF               XOR A
1725+ 55ED C9               RET
1726+ 55EE              .ERROR:
1727+ 55EE 37               SCF
1728+ 55EF C9               RET
1729+ 55F0              ; *******************************************************************************************************
1730+ 55F0
1731+ 55F0              ; *******************************************************************************************************
1732+ 55F0              ; function will display currect item and set up expiry time
1733+ 55F0              ; it will also stop the animation if expired
1734+ 55F0              ; sets sprite update flag if any changes in sprite data made
1735+ 55F0              ; input IX=current sprite animation
1736+ 55F0              ; input B=1 skip timer setup
1737+ 55F0              SETUP_ANIM_STEP:
1738+ 55F0 DD 4E 04         LD C,(IX+4) ; animation definition ID
1739+ 55F3 0C               INC C
1740+ 55F4 3A 5D 4F         LD A,(ANIMDEFNUM)
1741+ 55F7 B9               CP C
1742+ 55F8 30 05            JR NC,.L2
1743+ 55FA                  ; given animation item is outside of bounds, deactivate animation
1744+ 55FA              .STOPANIM:
1745+ 55FA DD 36 06 00      LD (IX+6),0
1746+ 55FE C9               RET
1747+ 55FF              .L2:
1748+ 55FF 0D               DEC C
1749+ 5600 79               LD A,C
1750+ 5601 CD B3 55         CALL INIT_CURRENT_ANIMATION
1751+ 5604 38 F4            JR C, .STOPANIM
1752+ 5606 FD 7E 00         LD A,(IY) ; type of animation item
1753+ 5609 B7               OR A
1754+ 560A 28 44            JR Z,.L4 ; change pattern and/or color
1755+ 560C              .PAT:
1756+ 560C                  ; change pattern definition
1757+ 560C                  ; check if sprite or character
1758+ 560C DD 7E 07         LD A,(IX+7)
1759+ 560F B7               OR A
1760+ 5610 20 58            JR NZ,.CHAR
1761+ 5612 DD 7E 00         LD A,(IX) ; sprite number
1762+ 5615 CD 89 4D         CALL GETnthSPRATTR
1763+ 5618 23          > INC HL ; skip y and x
1763+ 5619 23          > INC HL
1763+ 561A 23          > INC HL
1763+ 561B 23          > INC HL
1764+ 561C 7E               LD A,(HL); current pattern
1765+ 561D 26 00            LD H,0
1766+ 561F 6F               LD L,A
1767+ 5620 3A E0 F3         LD A,(REG1SAV)
1768+ 5623 E6 02            AND 2
1769+ 5625 20 07            JR NZ,.L6
1770+ 5627                  ; 8x8 sprite
1771+ 5627 CD 18 65         CALL HLx8
1772+ 562A 06 08            LD B,8
1773+ 562C 18 05            JR .L5
1774+ 562E              .L6:
1775+ 562E CD 16 65         CALL HLx32
1776+ 5631 06 20            LD B,32
1777+ 5633              .L5:
1778+ 5633 3A AF FC         LD A,(SCRMOD)
1779+ 5636 3D               DEC A
1780+ 5637 20 06            JR NZ,.L10
1781+ 5639 ED 5B C5 F3      LD DE,(T32PAT)
1782+ 563D 18 04            JR .L7
1783+ 563F              .L10:
1784+ 563F ED 5B CF F3      LD DE,(GRPPAT)
1785+ 5643              .L7:
1786+ 5643 19               ADD HL,DE
1787+ 5644 CD 03 65         CALL SETWRT_LOCAL
1788+ 5647 FD 6E 03         LD L,(IY+3)
1789+ 564A FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
1790+ 564D C3 0E 65         JP BBYTECOPY
1791+ 5650              .L4:
1792+ 5650                  ; change pattern and color in sprite attributes table
1793+ 5650 DD 7E 00         LD A,(IX) ; sprite number
1794+ 5653 CD 89 4D         CALL GETnthSPRATTR
1795+ 5656 23          > INC HL ; skip y and x
1795+ 5657 23          > INC HL
1795+ 5658 23          > INC HL
1795+ 5659 23          > INC HL
1796+ 565A FD 7E 03         LD A,(IY+3) ; new pattern
1797+ 565D 77               LD (HL),A
1798+ 565E 23          > INC HL
1798+ 565F 23          > INC HL
1799+ 5660 FD 7E 04         LD A,(IY+4) ; new color
1800+ 5663 77               LD (HL),A
1801+ 5664 2A 80 4D         LD HL,(SPRATR_UPDATE_FLAG)
1802+ 5667 36 01            LD (HL),1
1803+ 5669 C9               RET
1804+ 566A              .CHAR:
1805+ 566A DD 6E 00         LD L,(IX)
1806+ 566D 3D               DEC A
1807+ 566E 67               LD H,A
1808+ 566F CD 18 65         CALL HLx8
1809+ 5672 3A AF FC         LD A,(SCRMOD)
1810+ 5675 3D               DEC A
1811+ 5676 20 06            JR NZ,.L8
1812+ 5678 ED 5B C1 F3      LD DE,(T32CGP)
1813+ 567C 18 04            JR .L9
1814+ 567E              .L8:
1815+ 567E ED 5B CB F3      LD DE,(GRPCGP)
1816+ 5682              .L9:
1817+ 5682 06 08            LD B,8
1818+ 5684 18 BD            JR .L7
1819+ 5686              ; *******************************************************************************************************
1820+ 5686
# file closed: asm\ANIMATION.asm
 134  5686               INCLUDE "SGAM.asm"
# file opened: asm\SGAM.asm
   1+ 5686              ; Sprite Group Animate and Move
   2+ 5686
   3+ 5686              ; *******************************************************************************************************
   4+ 5686              ; shared function to process a list of animations
   5+ 5686              ; input B=list size
   6+ 5686              ; input DE=list pointer
   7+ 5686              SGAM_PROCESS_ANIM_LIST:
   8+ 5686 21 99 56         LD HL,.STEP
   9+ 5689 22 74 55         LD (ANIM_SETVALUE.FN+1),HL
  10+ 568C              .L1:
  11+ 568C C5               PUSH BC
  12+ 568D 1A               LD A,(DE)
  13+ 568E 13          > INC DE
  13+ 568F 13          > INC DE
  14+ 5690 D5               PUSH DE
  15+ 5691 CD 64 55         CALL ANIM_SETVALUE
  16+ 5694 D1               POP DE
  17+ 5695 C1               POP BC
  18+ 5696 10 F4            DJNZ .L1
  19+ 5698 C9           	RET
  20+ 5699              .STEP:
  21+ 5699 06 01            LD B,1
  22+ 569B C3 94 55         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
  23+ 569E              ; *******************************************************************************************************
  24+ 569E
  25+ 569E               IF (1 == 1)
  26+ 569E              ; *******************************************************************************************************
  27+ 569E              ; function to handle CALL SGAM basic extension
  28+ 569E              ; sets position of a group of sprites as described in SPRGRPMOV
  29+ 569E              ; and manually animate a list of animations
  30+ 569E              ; _SGAM ( INT x,
  31+ 569E              ;	      INT y,
  32+ 569E              ;		  BYTE count,
  33+ 569E              ;		  INT[2][count] data_ptr,
  34+ 569E              ;         BYTE item_number,
  35+ 569E              ;         INT[] sprite_animations )
  36+ 569E              ; will put ram in page 0 also, page 1 is already there
  37+ 569E              SGAM:
  38+ 569E 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
  39+ 56A1 B7           	OR A
  40+ 56A2 CA 4B 66     	JP Z,ILLEGAL_FUNCTION
  41+ 56A5              	; opening (
  42+ 56A5 CD 2B 66     	CALL CHKCHAR
  43+ 56A8 28           	DB '('
  44+ 56A9              	; get x
  45+ 56A9 DD 21 2F 54  	LD IX, FRMQNT
  46+ 56AD CD 59 01     	CALL CALBAS
  47+ 56B0 ED 53 10 63  	LD (BLIT_STRUCT),DE
  48+ 56B4              	; comma
  49+ 56B4 CD 2B 66     	CALL CHKCHAR
  50+ 56B7 2C           	DB ','
  51+ 56B8              	; get y
  52+ 56B8 DD 21 2F 54  	LD IX, FRMQNT
  53+ 56BC CD 59 01     	CALL CALBAS
  54+ 56BF ED 53 12 63  	LD (BLIT_STRUCT+2),DE
  55+ 56C3              	; comma
  56+ 56C3 CD 2B 66     	CALL CHKCHAR
  57+ 56C6 2C           	DB ','
  58+ 56C7              	; get count
  59+ 56C7 DD 21 1C 52  	LD IX, GETBYT
  60+ 56CB CD 59 01     	CALL CALBAS
  61+ 56CE B7               OR A
  62+ 56CF CA 43 66         JP Z,SUBSCRIPT_OUT_OF_RANGE
  63+ 56D2 32 14 63     	LD (BLIT_STRUCT+4),A
  64+ 56D5              	; comma
  65+ 56D5 CD 2B 66     	CALL CHKCHAR
  66+ 56D8 2C           	DB ','
  67+ 56D9              	; get sprite group definition array data pointer
  68+ 56D9 3A 14 63         LD A,(BLIT_STRUCT+4)
  69+ 56DC 5F           	LD E,A
  70+ 56DD 16 03        	LD D,3
  71+ 56DF 3E 02        	LD A,2
  72+ 56E1 47           	LD B,A
  73+ 56E2 CD 58 66     	CALL GET_BASIC_ARRAY_DATA_POINTER
  74+ 56E5 ED 43 15 63  	LD (BLIT_STRUCT+5),BC
  75+ 56E9              	; comma
  76+ 56E9 CD 2B 66     	CALL CHKCHAR
  77+ 56EC 2C           	DB ','
  78+ 56ED              	; get sprite animation array size
  79+ 56ED DD 21 1C 52  	LD IX,GETBYT
  80+ 56F1 CD 59 01     	CALL CALBAS
  81+ 56F4 32 17 63         LD (BLIT_STRUCT+7),A
  82+ 56F7 B7               OR A
  83+ 56F8 CA 43 66         JP Z,SUBSCRIPT_OUT_OF_RANGE
  84+ 56FB              	; comma
  85+ 56FB CD 2B 66     	CALL CHKCHAR
  86+ 56FE 2C           	DB ','
  87+ 56FF                  ; get array pointer
  88+ 56FF 3A 17 63         LD A,(BLIT_STRUCT+7)
  89+ 5702 57               LD D,A
  90+ 5703 3E 02            LD A,2
  91+ 5705 06 01            LD B,1
  92+ 5707 CD 58 66         CALL GET_BASIC_ARRAY_DATA_POINTER
  93+ 570A ED 43 18 63      LD (BLIT_STRUCT+8),BC
  94+ 570E              	; ending )
  95+ 570E CD 2B 66     	CALL CHKCHAR
  96+ 5711 29           	DB ')'
  97+ 5712              .ENTRY:
  98+ 5712 E5               PUSH HL
  99+ 5713
 100+ 5713              	; enable page 0
 101+ 5713 FD 21 1A 57  	LD IY, .RET
 102+ 5717 C3 DC 65     	JP ENABLE_PAGE0
 103+ 571A              .RET:
 104+ 571A D9               EXX
 105+ 571B ED 5B 10 63      LD DE,(BLIT_STRUCT) ; initial x
 106+ 571F ED 4B 12 63      LD BC,(BLIT_STRUCT+2) ; initial y
 107+ 5723 D9               EXX
 108+ 5724 2A 15 63         LD HL,(BLIT_STRUCT+5) ; pointer to data
 109+ 5727 3A 14 63         LD A,(BLIT_STRUCT+4) ; number of entries
 110+ 572A 47               LD B,A
 111+ 572B CD DD 4E         CALL SPR_UPDATE_LOC
 112+ 572E
 113+ 572E 3A 17 63         LD A,(BLIT_STRUCT+7) ; anim number
 114+ 5731 47               LD B,A
 115+ 5732 ED 5B 18 63      LD DE,(BLIT_STRUCT+8) ; anim list
 116+ 5736 CD 86 56     	CALL SGAM_PROCESS_ANIM_LIST
 117+ 5739
 118+ 5739 D1               POP DE
 119+ 573A C1               POP BC
 120+ 573B CD 53 65         CALL RESTORE_PAGE_INFO
 121+ 573E FB               EI
 122+ 573F E1               POP HL
 123+ 5740 C9               RET
 124+ 5741              ; *******************************************************************************************************
 125+ 5741               ENDIF
 126+ 5741
 127+ 5741               IF (0 == 1)
 128+ 5741 ~            ; *******************************************************************************************************
 129+ 5741 ~            ; same as SGAM but for DEFUSR approach
 130+ 5741 ~            ; input IX=pointer to input array, real data from +2
 131+ 5741 ~            ; +02 = X
 132+ 5741 ~            ; +04 = Y
 133+ 5741 ~            ; +06 = count
 134+ 5741 ~            ; +08 = data pointer
 135+ 5741 ~            ; +10 = anim number
 136+ 5741 ~            ; +12 = sprite animations
 137+ 5741 ~            SGAM_DEFUSR:
 138+ 5741 ~            	; enable page 0
 139+ 5741 ~            	LD IY, .RET
 140+ 5741 ~            	JP ENABLE_PAGE0
 141+ 5741 ~            .RET:
 142+ 5741 ~            	EI
 143+ 5741 ~                EXX
 144+ 5741 ~            	LD E,(IX+2)
 145+ 5741 ~            	LD D,(IX+3) ; initial x
 146+ 5741 ~            	LD C,(IX+4)
 147+ 5741 ~            	LD B,(IX+5) ; initial y
 148+ 5741 ~                EXX
 149+ 5741 ~            	LD L,(IX+8)
 150+ 5741 ~            	LD H,(IX+9) ; pointer to data
 151+ 5741 ~                LD B,(IX+6) ; count
 152+ 5741 ~            	PUSH IX
 153+ 5741 ~                CALL SPR_UPDATE_LOC
 154+ 5741 ~            	POP IX
 155+ 5741 ~                LD B,(IX+10) ; anim number
 156+ 5741 ~            	LD E,(IX+12)
 157+ 5741 ~            	LD D,(IX+13)
 158+ 5741 ~            	CALL SGAM_PROCESS_ANIM_LIST
 159+ 5741 ~
 160+ 5741 ~                POP DE
 161+ 5741 ~                POP BC
 162+ 5741 ~                JP RESTORE_PAGE_INFO
 163+ 5741 ~            ; *******************************************************************************************************
 164+ 5741               ENDIF
 165+ 5741
 166+ 5741              ; *******************************************************************************************************
 167+ 5741              ; handles automatic move and animate sprite groups during interrupt
 168+ 5741              PROCESS_AUTOSGAMS:
 169+ 5741 3A 63 4F     	LD A,(AUTOSGAMNUM)
 170+ 5744 B7           	OR A
 171+ 5745 C8           	RET Z
 172+ 5746 47           	LD B,A
 173+ 5747 DD 2A 64 4F  	LD IX,(AUTOSGAMPTR)
 174+ 574B              .L1:
 175+ 574B C5           	PUSH BC
 176+ 574C DD 7E 13     	LD A,(IX+19) ; active flag
 177+ 574F B7           	OR A
 178+ 5750 28 28        	JR Z,.LOOPEND
 179+ 5752              	; active, check timer
 180+ 5752 DD 6E 16     	LD L,(IX+22)
 181+ 5755 DD 66 17     	LD H,(IX+23) ; timer
 182+ 5758 2B           	DEC HL
 183+ 5759 7C           	LD A,H
 184+ 575A B5           	OR L
 185+ 575B 28 08        	JR Z,.L2
 186+ 575D              	; not expired
 187+ 575D DD 75 16     	LD (IX+22),L
 188+ 5760 DD 74 17     	LD (IX+23),H
 189+ 5763 18 15        	JR .LOOPEND
 190+ 5765              .L2:
 191+ 5765              	; expired, process
 192+ 5765
 193+ 5765                  ; set initial timer
 194+ 5765 DD 7E 14         LD A,(IX+20)
 195+ 5768 DD 77 16         LD (IX+22),A
 196+ 576B DD 7E 15         LD A,(IX+21)
 197+ 576E DD 77 17         LD (IX+23),A
 198+ 5771
 199+ 5771 CD 83 57     	CALL .MOVE
 200+ 5774 CD EE 57     	CALL .UPDATELOC
 201+ 5777 CD 13 58     	CALL .PROCESS_ANIM_LIST
 202+ 577A
 203+ 577A              .LOOPEND:
 204+ 577A 11 18 00     	LD DE,24
 205+ 577D DD 19        	ADD IX,DE
 206+ 577F C1           	POP BC
 207+ 5780 10 C9        	DJNZ .L1
 208+ 5782 C9           	RET
 209+ 5783
 210+ 5783              .MOVE:
 211+ 5783              	; process movement
 212+ 5783 DD 7E 0A     	LD A,(IX+10) ; direction
 213+ 5786 B7           	OR A
 214+ 5787 28 08        	JR Z, .MOVE_L1
 215+ 5789              	; vertical
 216+ 5789 DD 6E 02     	LD L,(IX+2)
 217+ 578C DD 66 03     	LD H,(IX+3) ; vertical variable pointer
 218+ 578F 18 06        	JR .MOVE_L2
 219+ 5791              .MOVE_L1:
 220+ 5791              	; horizontal
 221+ 5791 DD 6E 00     	LD L,(IX+0)
 222+ 5794 DD 66 01     	LD H,(IX+1) ; horizontal variable pointer
 223+ 5797              .MOVE_L2:
 224+ 5797 E5           	PUSH HL
 225+ 5798 FD E1        	POP IY
 226+ 579A FD 6E 00     	LD L,(IY+0)
 227+ 579D FD 66 01     	LD H,(IY+1)
 228+ 57A0 DD 5E 08     	LD E,(IX+8)
 229+ 57A3 DD 56 09     	LD D,(IX+9) ; delta value
 230+ 57A6 19           	ADD HL,DE
 231+ 57A7 E5           	PUSH HL
 232+ 57A8 DD 5E 04     	LD E,(IX+4)
 233+ 57AB DD 56 05     	LD D,(IX+5) ; minimum value
 234+ 57AE A7           	AND A
 235+ 57AF ED 52        	SBC HL,DE
 236+ 57B1 FA CB 57     	JP M,.MOVE_L3 ; below minimum
 237+ 57B4 E1           	POP HL
 238+ 57B5 E5           	PUSH HL
 239+ 57B6 DD 5E 06     	LD E,(IX+6)
 240+ 57B9 DD 56 07     	LD D,(IX+7) ; maximum value
 241+ 57BC EB           	EX DE,HL
 242+ 57BD A7           	AND A
 243+ 57BE ED 52        	SBC HL,DE
 244+ 57C0 FA D3 57     	JP M,.MOVE_L4 ; above maximum
 245+ 57C3 E1           	POP HL
 246+ 57C4              	; within bounds
 247+ 57C4              .MOVE_L5:
 248+ 57C4 FD 75 00     	LD (IY+0),L
 249+ 57C7 FD 74 01     	LD (IY+1),H
 250+ 57CA C9           	RET
 251+ 57CB              .MOVE_L3:
 252+ 57CB E1           	POP HL
 253+ 57CC CD DF 57     	CALL .INVERSE_DELTA
 254+ 57CF 6B           	LD L,E
 255+ 57D0 62           	LD H,D
 256+ 57D1 18 F1        	JR .MOVE_L5
 257+ 57D3              .MOVE_L4:
 258+ 57D3 E1           	POP HL
 259+ 57D4 CD DF 57     	CALL .INVERSE_DELTA
 260+ 57D7 DD 6E 06     	LD L,(IX+6)
 261+ 57DA DD 66 07     	LD H,(IX+7) ; maximum
 262+ 57DD 18 E5        	JR .MOVE_L5
 263+ 57DF              .INVERSE_DELTA:
 264+ 57DF AF           	XOR A
 265+ 57E0 DD 96 08     	SUB (IX+8)
 266+ 57E3 DD 77 08     	LD (IX+8),A
 267+ 57E6 9F           	SBC A,A
 268+ 57E7 DD 96 09     	SUB (IX+9)
 269+ 57EA DD 77 09     	LD (IX+9),A
 270+ 57ED C9           	RET
 271+ 57EE
 272+ 57EE              .UPDATELOC:
 273+ 57EE DD E5        	PUSH IX
 274+ 57F0 D9           	EXX
 275+ 57F1 DD 6E 00     	LD L,(IX+0)
 276+ 57F4 DD 66 01     	LD H,(IX+1)
 277+ 57F7 5E           	LD E,(HL)
 278+ 57F8 23           	INC HL
 279+ 57F9 56           	LD D,(HL)
 280+ 57FA DD 6E 02     	LD L,(IX+2)
 281+ 57FD DD 66 03     	LD H,(IX+3)
 282+ 5800 4E           	LD C,(HL)
 283+ 5801 23           	INC HL
 284+ 5802 46           	LD B,(HL)
 285+ 5803 D9           	EXX
 286+ 5804 DD 6E 0C     	LD L,(IX+12)
 287+ 5807 DD 66 0D     	LD H,(IX+13) ; pointer to sprite group data
 288+ 580A DD 46 0B     	LD B,(IX+11) ; sprite group size
 289+ 580D CD DD 4E     	CALL SPR_UPDATE_LOC
 290+ 5810 DD E1        	POP IX
 291+ 5812 C9           	RET
 292+ 5813
 293+ 5813              .PROCESS_ANIM_LIST:
 294+ 5813 DD E5        	PUSH IX
 295+ 5815 DD 46 0E         LD B,(IX+14) ; anim list size
 296+ 5818 DD CB 09 7E  	BIT 7,(IX+9)
 297+ 581C 28 08        	JR Z,.PROCESS_ANIM_LIST_L1
 298+ 581E              	; negative direction
 299+ 581E DD 5E 0F     	LD E,(IX+15)
 300+ 5821 DD 56 10     	LD D,(IX+16)
 301+ 5824 18 06        	JR .PROCESS_ANIM_LIST_L2
 302+ 5826              .PROCESS_ANIM_LIST_L1:
 303+ 5826              	; positive direction
 304+ 5826 DD 5E 11     	LD E,(IX+17)
 305+ 5829 DD 56 12     	LD D,(IX+18)
 306+ 582C              .PROCESS_ANIM_LIST_L2:
 307+ 582C CD 86 56     	CALL SGAM_PROCESS_ANIM_LIST
 308+ 582F DD E1        	POP IX
 309+ 5831 C9           	RET
 310+ 5832              ; *******************************************************************************************************
 311+ 5832
# file closed: asm\SGAM.asm
 135  5832               ENDIF
 136  5832
 137  5832               IF (RAM_CMDS == 1)
 138  5832               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
   1+ 5832               IF (1 == 1)
   2+ 5832              ; *******************************************************************************************************
   3+ 5832              ; function to handle CALL MEMCPY basic extension
   4+ 5832              ; _MEMCPY ( INT source,
   5+ 5832              ;			INT destination,
   6+ 5832              ;			INT count,
   7+ 5832              ; will put ram in page 0 also, page 1 is already there
   8+ 5832              MEMCPY:
   9+ 5832              	; opening (
  10+ 5832 CD 2B 66     	CALL CHKCHAR
  11+ 5835 28           	DB '('
  12+ 5836              	; get source address
  13+ 5836 DD 21 2F 54  	LD IX, FRMQNT
  14+ 583A CD 59 01     	CALL CALBAS
  15+ 583D D5           	PUSH DE
  16+ 583E              	; comma
  17+ 583E CD 2B 66     	CALL CHKCHAR
  18+ 5841 2C           	DB ','
  19+ 5842              	; get destination address
  20+ 5842 DD 21 2F 54  	LD IX, FRMQNT
  21+ 5846 CD 59 01     	CALL CALBAS
  22+ 5849 D5           	PUSH DE
  23+ 584A              	; comma
  24+ 584A CD 2B 66     	CALL CHKCHAR
  25+ 584D 2C           	DB ','
  26+ 584E              	; get length
  27+ 584E DD 21 2F 54  	LD IX, FRMQNT
  28+ 5852 CD 59 01     	CALL CALBAS
  29+ 5855 D5           	PUSH DE
  30+ 5856              	; ending )
  31+ 5856 CD 2B 66     	CALL CHKCHAR
  32+ 5859 29           	DB ')'
  33+ 585A
  34+ 585A              	; save position
  35+ 585A E5           	PUSH HL
  36+ 585B DD E1        	POP IX
  37+ 585D
  38+ 585D C1           	POP BC ; count
  39+ 585E D1           	POP DE ; destination
  40+ 585F E1           	POP HL ; source
  41+ 5860 D9           	EXX
  42+ 5861              	; enable page 0
  43+ 5861 FD 21 68 58  	LD IY, .RET
  44+ 5865 C3 DC 65     	JP ENABLE_PAGE0
  45+ 5868              .RET:
  46+ 5868 FB           	EI
  47+ 5869 D9           	EXX
  48+ 586A ED B0        	LDIR
  49+ 586C D1               POP DE
  50+ 586D C1               POP BC
  51+ 586E CD 53 65         CALL RESTORE_PAGE_INFO
  52+ 5871 DD E5        	PUSH IX
  53+ 5873 E1           	POP HL
  54+ 5874 C9           	RET
  55+ 5875              ; *******************************************************************************************************
  56+ 5875               ENDIF
  57+ 5875
  58+ 5875               IF (0 == 1)
  59+ 5875 ~            ; *******************************************************************************************************
  60+ 5875 ~            ; same as MEMCPY but for DEFUSR approach
  61+ 5875 ~            ; input IX=pointer to input array, real data from +2
  62+ 5875 ~            ; +2 = source address
  63+ 5875 ~            ; +4 = destination address
  64+ 5875 ~            ; +6 = lenght
  65+ 5875 ~            MEMCPY_DEFUSR:
  66+ 5875 ~            	; enable page 0
  67+ 5875 ~            	LD IY, .RET
  68+ 5875 ~            	JP ENABLE_PAGE0
  69+ 5875 ~            .RET:
  70+ 5875 ~            	EI
  71+ 5875 ~            	LD L,(IX+2)
  72+ 5875 ~            	LD H,(IX+3)
  73+ 5875 ~            	LD E,(IX+4)
  74+ 5875 ~            	LD D,(IX+5)
  75+ 5875 ~            	LD C,(IX+6)
  76+ 5875 ~            	LD B,(IX+7)
  77+ 5875 ~            	LDIR
  78+ 5875 ~                POP DE
  79+ 5875 ~                POP BC
  80+ 5875 ~                JP RESTORE_PAGE_INFO
  81+ 5875 ~            ; *******************************************************************************************************
  82+ 5875               ENDIF
  83+ 5875
  84+ 5875               IF (1 == 1)
  85+ 5875              ; *******************************************************************************************************
  86+ 5875              ; function to handle CALL FILRAM basic extension
  87+ 5875              ; FILRAM ( INT start address,
  88+ 5875              ;		   INT count,
  89+ 5875              ;		   BYTE value )
  90+ 5875              ; will put ram in page 0 also, page 1 is already there
  91+ 5875              FILRAM:
  92+ 5875              	; opening (
  93+ 5875 CD 2B 66     	CALL CHKCHAR
  94+ 5878 28           	DB '('
  95+ 5879              	; get start address
  96+ 5879 DD 21 2F 54  	LD IX, FRMQNT
  97+ 587D CD 59 01     	CALL CALBAS
  98+ 5880 D5           	PUSH DE
  99+ 5881              	; comma
 100+ 5881 CD 2B 66     	CALL CHKCHAR
 101+ 5884 2C           	DB ','
 102+ 5885              	; get count
 103+ 5885 DD 21 2F 54  	LD IX, FRMQNT
 104+ 5889 CD 59 01     	CALL CALBAS
 105+ 588C D5           	PUSH DE
 106+ 588D              	; comma
 107+ 588D CD 2B 66     	CALL CHKCHAR
 108+ 5890 2C           	DB ','
 109+ 5891              	; get value
 110+ 5891 DD 21 1C 52  	LD IX, GETBYT
 111+ 5895 CD 59 01     	CALL CALBAS
 112+ 5898 F5           	PUSH AF
 113+ 5899              	; ending )
 114+ 5899 CD 2B 66     	CALL CHKCHAR
 115+ 589C 29           	DB ')'
 116+ 589D
 117+ 589D              	; save position
 118+ 589D E5           	PUSH HL
 119+ 589E DD E1        	POP IX
 120+ 58A0
 121+ 58A0 D1           	POP DE ; actually AF
 122+ 58A1 C1           	POP BC ; count
 123+ 58A2 E1           	POP HL ; start address
 124+ 58A3 78           	LD A, B
 125+ 58A4 B1           	OR C
 126+ 58A5 28 12        	JR Z, .EXIT ; 0 bytes to fill, skip
 127+ 58A7 D9           	EXX
 128+ 58A8              	; enable page 0
 129+ 58A8 FD 21 AF 58  	LD IY, .RET
 130+ 58AC C3 DC 65     	JP ENABLE_PAGE0
 131+ 58AF              .RET:
 132+ 58AF FB           	EI
 133+ 58B0 D9           	EXX
 134+ 58B1 CD BD 58     	CALL FILVRM_FILLVALUE
 135+ 58B4 D1               POP DE
 136+ 58B5 C1               POP BC
 137+ 58B6 CD 53 65         CALL RESTORE_PAGE_INFO
 138+ 58B9              .EXIT:
 139+ 58B9 DD E5        	PUSH IX
 140+ 58BB E1           	POP HL
 141+ 58BC C9           	RET
 142+ 58BD              ; *******************************************************************************************************
 143+ 58BD               ENDIF
 144+ 58BD
 145+ 58BD               IF (0 == 1)
 146+ 58BD ~            ; *******************************************************************************************************
 147+ 58BD ~            ; same as FILVRM but for DEFUSR approach
 148+ 58BD ~            ; input IX=pointer to input array, real data from +2
 149+ 58BD ~            ; +2 = start address
 150+ 58BD ~            ; +4 = count
 151+ 58BD ~            ; +6 = value
 152+ 58BD ~            FILRAM_DEFUSR:
 153+ 58BD ~            	; enable page 0
 154+ 58BD ~            	LD IY, .RET
 155+ 58BD ~            	JP ENABLE_PAGE0
 156+ 58BD ~            .RET:
 157+ 58BD ~            	EI
 158+ 58BD ~            	LD L,(IX+2)
 159+ 58BD ~            	LD H,(IX+3)
 160+ 58BD ~            	LD C,(IX+4)
 161+ 58BD ~            	LD B,(IX+5)
 162+ 58BD ~            	LD A,B
 163+ 58BD ~            	OR C
 164+ 58BD ~            	JR Z,.EXIT
 165+ 58BD ~            	LD D,(IX+6)
 166+ 58BD ~            	CALL FILVRM_FILLVALUE
 167+ 58BD ~            .EXIT:
 168+ 58BD ~                POP DE
 169+ 58BD ~                POP BC
 170+ 58BD ~                JP RESTORE_PAGE_INFO
 171+ 58BD ~            ; *******************************************************************************************************
 172+ 58BD               ENDIF
 173+ 58BD
 174+ 58BD              ; *******************************************************************************************************
 175+ 58BD              ; common function to fill RAM
 176+ 58BD              FILVRM_FILLVALUE:
 177+ 58BD 72               LD (HL), D
 178+ 58BE 54               LD D, H
 179+ 58BF 5D               LD E, L
 180+ 58C0 13               INC DE
 181+ 58C1 0B               DEC BC
 182+ 58C2 78           	LD A,B
 183+ 58C3 B1           	OR C
 184+ 58C4 C8           	RET Z ; if count was 1
 185+ 58C5 ED B0            LDIR
 186+ 58C7 C9               RET
 187+ 58C8              ; *******************************************************************************************************
# file closed: asm\MEMORY.asm
 139  58C8               ENDIF
 140  58C8
 141  58C8               IF (SOUND_CMDS == 1)
 142  58C8               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
   1+ 58C8              MUSIC_INIT_STATUS:
   2+ 58C8 00            DB 0
   3+ 58C9              SFX_INIT_STATUS:
   4+ 58C9 00            DB 0
   5+ 58CA              SOUND_ENABLED:
   6+ 58CA 00            DB 0
   7+ 58CB
   8+ 58CB               IF (1 == 1)
   9+ 58CB              ; *******************************************************************************************************
  10+ 58CB              ; function to handle CALL SNDPLYINIT basic extension
  11+ 58CB              ; initializes sound player
  12+ 58CB              ; _SNDPLYINIT ( INT music_offset,
  13+ 58CB              ;				INT sfx_offset, can be -1 if no SFX
  14+ 58CB              ; will put ram in page 0 also, page 1 is already there
  15+ 58CB              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
  16+ 58CB              SNDPLYINIT:
  17+ 58CB              	; opening (
  18+ 58CB CD 2B 66     	CALL CHKCHAR
  19+ 58CE 28           	DB '('
  20+ 58CF              	; get music address
  21+ 58CF DD 21 2F 54  	LD IX, FRMQNT
  22+ 58D3 CD 59 01     	CALL CALBAS
  23+ 58D6 D5           	PUSH DE
  24+ 58D7              	; comma
  25+ 58D7 CD 2B 66     	CALL CHKCHAR
  26+ 58DA 2C           	DB ','
  27+ 58DB              	; get sfx address
  28+ 58DB DD 21 2F 54  	LD IX, FRMQNT
  29+ 58DF CD 59 01     	CALL CALBAS
  30+ 58E2 D5           	PUSH DE
  31+ 58E3              	; ending )
  32+ 58E3 CD 2B 66     	CALL CHKCHAR
  33+ 58E6 29           	DB ')'
  34+ 58E7
  35+ 58E7                  ; save position in BASIC text
  36+ 58E7 44           	LD B, H
  37+ 58E8 4D           	LD C, L
  38+ 58E9
  39+ 58E9              	; pop LDIR parameters and store away for later
  40+ 58E9 D1           	POP DE ; sfx address
  41+ 58EA E1           	POP HL ; music address
  42+ 58EB C5           	PUSH BC ; basic text location
  43+ 58EC D9           	EXX
  44+ 58ED FD 21 F4 58  	LD IY, .RET
  45+ 58F1 C3 DC 65     	JP ENABLE_PAGE0
  46+ 58F4              .RET:
  47+ 58F4 D9           	EXX
  48+ 58F5
  49+ 58F5 D5           	PUSH DE
  50+ 58F6 AF           	XOR A
  51+ 58F7              	; HL = music location
  52+ 58F7 CD 65 41     	CALL PLY_AKG_INIT
  53+ 58FA 3E 01        	LD A, 1
  54+ 58FC 32 C8 58     	LD (MUSIC_INIT_STATUS), A
  55+ 58FF
  56+ 58FF E1           	POP HL ; SFX
  57+ 5900              	; check if SFX address -1
  58+ 5900 23           	INC HL
  59+ 5901 7D           	LD A, L
  60+ 5902 B4           	OR H
  61+ 5903 28 09        	JR Z,.L1
  62+ 5905 2B           	DEC HL
  63+ 5906 CD 20 40     	CALL PLY_AKG_INITSOUNDEFFECTS
  64+ 5909 3E 01        	LD A, 1
  65+ 590B 32 C9 58     	LD (SFX_INIT_STATUS), A
  66+ 590E              .L1:
  67+ 590E D1               POP DE
  68+ 590F C1               POP BC
  69+ 5910 CD 53 65         CALL RESTORE_PAGE_INFO
  70+ 5913
  71+ 5913 E1           	POP HL
  72+ 5914 C9           	RET
  73+ 5915              ; *******************************************************************************************************
  74+ 5915               ENDIF
  75+ 5915
  76+ 5915               IF (0 == 1)
  77+ 5915 ~            ; *******************************************************************************************************
  78+ 5915 ~            ; same as SNDPLYINI but for DEFUSR approach
  79+ 5915 ~            ; input IX=pointer to input array, real data from +2
  80+ 5915 ~            ; +2 = music address
  81+ 5915 ~            ; +4 = sfx address
  82+ 5915 ~            SNDPLYINI_DEFUSR:
  83+ 5915 ~            	LD IY, .RET
  84+ 5915 ~            	JP ENABLE_PAGE0
  85+ 5915 ~            .RET:
  86+ 5915 ~            	XOR A
  87+ 5915 ~            	LD L,(IX+2)
  88+ 5915 ~            	LD H,(IX+3)
  89+ 5915 ~            	PUSH IX
  90+ 5915 ~            	CALL PLY_AKG_INIT
  91+ 5915 ~            	POP IX
  92+ 5915 ~            	LD A, 1
  93+ 5915 ~            	LD (MUSIC_INIT_STATUS), A
  94+ 5915 ~
  95+ 5915 ~            	LD L,(IX+4)
  96+ 5915 ~            	LD H,(IX+5)
  97+ 5915 ~            	; check if SFX address -1
  98+ 5915 ~            	INC HL
  99+ 5915 ~            	LD A, L
 100+ 5915 ~            	OR H
 101+ 5915 ~            	JR Z,.L1
 102+ 5915 ~            	DEC HL
 103+ 5915 ~            	CALL PLY_AKG_INITSOUNDEFFECTS
 104+ 5915 ~            	LD A, 1
 105+ 5915 ~            	LD (SFX_INIT_STATUS), A
 106+ 5915 ~            .L1:
 107+ 5915 ~                POP DE
 108+ 5915 ~                POP BC
 109+ 5915 ~                JP RESTORE_PAGE_INFO
 110+ 5915 ~            ; *******************************************************************************************************
 111+ 5915               ENDIF
 112+ 5915
 113+ 5915              ; *******************************************************************************************************
 114+ 5915              ; function to handle CALL SNDPLYON basic extension
 115+ 5915              ; enables sound player
 116+ 5915              ; _SNDPLYON
 117+ 5915              ; sets SOUND_ENABLED variable to 1 if init call was done
 118+ 5915              ; if not throws out of data error
 119+ 5915              SNDPLYON_DEFUSR:
 120+ 5915              SNDPLYON:
 121+ 5915 3A C8 58     	LD A, (MUSIC_INIT_STATUS)
 122+ 5918 B7           	OR A
 123+ 5919 20 05        	JR NZ, .L1
 124+ 591B              	; player not initialized, throw error
 125+ 591B 1E 04        	LD E, 04 ; Out of DATA
 126+ 591D C3 51 66     	JP THROW_ERROR
 127+ 5920              .L1:
 128+ 5920 32 CA 58     	LD (SOUND_ENABLED), A
 129+ 5923              	; disable key click
 130+ 5923 AF           	XOR A
 131+ 5924 32 DB F3     	LD (CLIKSW), A
 132+ 5927 C9           	RET
 133+ 5928              ; *******************************************************************************************************
 134+ 5928
 135+ 5928              ; *******************************************************************************************************
 136+ 5928              ; function to handle CALL SNDPLYOFF basic extension
 137+ 5928              ; disables sound player
 138+ 5928              ; _SNDPLYOFF
 139+ 5928              ; sets SOUND_ENABLED variable to 0
 140+ 5928              ; calls AKG to stop music and SFX on all channels if initialized
 141+ 5928              SNDPLYOFF_DEFUSR:
 142+ 5928              SNDPLYOFF:
 143+ 5928 3A CA 58     	LD A, (SOUND_ENABLED)
 144+ 592B B7           	OR A
 145+ 592C C8           	RET Z ; already stopped
 146+ 592D AF           	XOR A
 147+ 592E 32 CA 58     	LD (SOUND_ENABLED), A
 148+ 5931 E5           	PUSH HL
 149+ 5932 CD 24 42     	CALL PLY_AKG_STOP
 150+ 5935 3A C9 58     	LD A, (SFX_INIT_STATUS)
 151+ 5938 B7           	OR A
 152+ 5939 28 0E        	JR Z, .EXIT ; SFX not in use
 153+ 593B AF           	XOR A
 154+ 593C CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 155+ 593F 3E 01        	LD A, 1
 156+ 5941 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 157+ 5944 3E 02        	LD A, 2
 158+ 5946 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 159+ 5949              .EXIT:
 160+ 5949 E1           	POP HL
 161+ 594A C9           	RET
 162+ 594B              ; *******************************************************************************************************
 163+ 594B
 164+ 594B               IF (1 == 1)
 165+ 594B              ; *******************************************************************************************************
 166+ 594B              ; function to handle CALL SNDSFX basic extension
 167+ 594B              ; plays a sound effect
 168+ 594B              ; _SNDSFX ( BYTE sfx_number, >0
 169+ 594B              ;			BYTE channel, = 0,1 or 2
 170+ 594B              ;			BYTE inverted_volume = 0-16, 0 being full volume
 171+ 594B              ; will put ram in page 0 also, page 1 is already there
 172+ 594B              ; if sound off throws illegal function call
 173+ 594B              ; if sfx not initialized, throws out of data
 174+ 594B              SNDSFX:
 175+ 594B              	; opening (
 176+ 594B CD 2B 66     	CALL CHKCHAR
 177+ 594E 28           	DB '('
 178+ 594F              	; get sfx_number
 179+ 594F DD 21 1C 52  	LD IX, GETBYT
 180+ 5953 CD 59 01     	CALL CALBAS
 181+ 5956 D5           	PUSH DE
 182+ 5957              	; comma
 183+ 5957 CD 2B 66     	CALL CHKCHAR
 184+ 595A 2C           	DB ','
 185+ 595B              	; get sfx address
 186+ 595B DD 21 1C 52  	LD IX, GETBYT
 187+ 595F CD 59 01     	CALL CALBAS
 188+ 5962 D5           	PUSH DE
 189+ 5963              	; comma
 190+ 5963 CD 2B 66     	CALL CHKCHAR
 191+ 5966 2C           	DB ','
 192+ 5967              	; get inverted volume
 193+ 5967 DD 21 1C 52  	LD IX, GETBYT
 194+ 596B CD 59 01     	CALL CALBAS
 195+ 596E D5           	PUSH DE
 196+ 596F              	; ending )
 197+ 596F CD 2B 66     	CALL CHKCHAR
 198+ 5972 29           	DB ')'
 199+ 5973
 200+ 5973 3A CA 58     	LD A, (SOUND_ENABLED)
 201+ 5976 B7           	OR A
 202+ 5977 20 05        	JR NZ, .L1
 203+ 5979              	; sound disabled, throw illegal function call
 204+ 5979 1E 05        	LD E, 5
 205+ 597B C3 51 66     	JP THROW_ERROR
 206+ 597E              .L1:
 207+ 597E 3A C9 58     	LD A, (SFX_INIT_STATUS)
 208+ 5981 B7           	OR A
 209+ 5982 20 05        	JR NZ, .L2
 210+ 5984              	; sfx data not initialized, throw out of data
 211+ 5984 1E 04        	LD E, 4
 212+ 5986 C3 51 66     	JP THROW_ERROR
 213+ 5989              .L2:
 214+ 5989              	; pop  parameters and store away for later
 215+ 5989 D1           	POP DE ; inverted volume
 216+ 598A 43           	LD B, E
 217+ 598B D1           	POP DE ; channel
 218+ 598C 4B           	LD C, E
 219+ 598D D1           	POP DE
 220+ 598E 7B           	LD A, E
 221+ 598F 08           	EX AF, AF'
 222+ 5990 E5           	PUSH HL ; basic text location
 223+ 5991 D9           	EXX
 224+ 5992 FD 21 99 59  	LD IY, .RET
 225+ 5996 C3 DC 65     	JP ENABLE_PAGE0
 226+ 5999              .RET:
 227+ 5999 D9           	EXX
 228+ 599A 08           	EX AF, AF'
 229+ 599B CD 24 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
 230+ 599E
 231+ 599E D1               POP DE
 232+ 599F C1               POP BC
 233+ 59A0 CD 53 65         CALL RESTORE_PAGE_INFO
 234+ 59A3
 235+ 59A3 E1           	POP HL
 236+ 59A4 C9           	RET
 237+ 59A5              ; *******************************************************************************************************
 238+ 59A5               ENDIF
 239+ 59A5
 240+ 59A5               IF (0 == 1)
 241+ 59A5 ~            ; *******************************************************************************************************
 242+ 59A5 ~            ; same as SNDSFX but for DEFUSR approach
 243+ 59A5 ~            ; input IX=pointer to input array, real data from +2
 244+ 59A5 ~            ; +2 = SFX number
 245+ 59A5 ~            ; +4 = channel
 246+ 59A5 ~            ; +6 = volume
 247+ 59A5 ~            SNDSFX_DEFUSR:
 248+ 59A5 ~            	LD A, (SOUND_ENABLED)
 249+ 59A5 ~            	OR A
 250+ 59A5 ~            	RET Z ; sound disabled, just exit
 251+ 59A5 ~            	LD A, (SFX_INIT_STATUS)
 252+ 59A5 ~            	OR A
 253+ 59A5 ~            	RET Z ; sfx data not initialized, just exit
 254+ 59A5 ~            	LD IY, .RET
 255+ 59A5 ~            	JP ENABLE_PAGE0
 256+ 59A5 ~            .RET:
 257+ 59A5 ~            	EI
 258+ 59A5 ~            	LD A,(IX+2) ; SFX number
 259+ 59A5 ~            	LD C,(IX+4) ; channel
 260+ 59A5 ~            	LD B,(IX+6) ; volume
 261+ 59A5 ~            	CALL PLY_AKG_PLAYSOUNDEFFECT
 262+ 59A5 ~                POP DE
 263+ 59A5 ~                POP BC
 264+ 59A5 ~                JP RESTORE_PAGE_INFO
 265+ 59A5 ~            ; *******************************************************************************************************
 266+ 59A5               ENDIF
# file closed: asm\SOUND.asm
 143  59A5               ENDIF
 144  59A5
 145  59A5               IF (VRAM_CMDS == 1)
 146  59A5               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
   1+ 59A5               IF (1 == 1)
   2+ 59A5              ; *******************************************************************************************************
   3+ 59A5              ; function to handle CALL FILVRM basic extension
   4+ 59A5              ; FILVRM ( INT offset,
   5+ 59A5              ;		   INT count,
   6+ 59A5              ;		   BYTE value,
   7+ 59A5              ;		   BYTE wait_vsync) >0 = true
   8+ 59A5              ; wait_vsync will issue HALT before copying
   9+ 59A5              FILVRM:
  10+ 59A5              	; opening (
  11+ 59A5 CD 2B 66     	CALL CHKCHAR
  12+ 59A8 28           	DB '('
  13+ 59A9              	; get offset address
  14+ 59A9 DD 21 2F 54  	LD IX, FRMQNT
  15+ 59AD CD 59 01     	CALL CALBAS
  16+ 59B0 D5           	PUSH DE
  17+ 59B1              	; comma
  18+ 59B1 CD 2B 66     	CALL CHKCHAR
  19+ 59B4 2C           	DB ','
  20+ 59B5              	; get count
  21+ 59B5 DD 21 2F 54  	LD IX, FRMQNT
  22+ 59B9 CD 59 01     	CALL CALBAS
  23+ 59BC D5           	PUSH DE
  24+ 59BD              	; comma
  25+ 59BD CD 2B 66     	CALL CHKCHAR
  26+ 59C0 2C           	DB ','
  27+ 59C1              	; get value
  28+ 59C1 DD 21 1C 52  	LD IX, GETBYT
  29+ 59C5 CD 59 01     	CALL CALBAS
  30+ 59C8 F5           	PUSH AF
  31+ 59C9              	; comma
  32+ 59C9 CD 2B 66     	CALL CHKCHAR
  33+ 59CC 2C           	DB ','
  34+ 59CD              	; get vsync wait
  35+ 59CD DD 21 1C 52  	LD IX, GETBYT
  36+ 59D1 CD 59 01     	CALL CALBAS
  37+ 59D4 F5           	PUSH AF
  38+ 59D5              	; ending )
  39+ 59D5 CD 2B 66     	CALL CHKCHAR
  40+ 59D8 29           	DB ')'
  41+ 59D9
  42+ 59D9              	; save position
  43+ 59D9 E5           	PUSH HL
  44+ 59DA DD E1        	POP IX
  45+ 59DC
  46+ 59DC              	; syntax ok
  47+ 59DC              	; wait for vsync if needed
  48+ 59DC F1           	POP AF
  49+ 59DD B7           	OR A
  50+ 59DE 28 01        	JR Z, .L1
  51+ 59E0 76           	HALT
  52+ 59E1
  53+ 59E1              .L1:
  54+ 59E1 3E 01        	LD A,1
  55+ 59E3 32 21 63     	LD (VRAM_UPDATE_IN_PROGRESS),A
  56+ 59E6 F1               POP AF ; value
  57+ 59E7 C1               POP BC ; count
  58+ 59E8 E1               POP HL ; offset
  59+ 59E9 CD 56 00         CALL BIOS_FILVRM
  60+ 59EC AF           	XOR A
  61+ 59ED 32 21 63     	LD (VRAM_UPDATE_IN_PROGRESS),A
  62+ 59F0
  63+ 59F0              .L3:
  64+ 59F0 DD E5        	PUSH IX
  65+ 59F2 E1           	POP HL
  66+ 59F3 C9           	RET
  67+ 59F4              ; *******************************************************************************************************
  68+ 59F4               ENDIF
  69+ 59F4
  70+ 59F4               IF (0 == 1)
  71+ 59F4 ~            ; *******************************************************************************************************
  72+ 59F4 ~            ; same as FILVRM but for DEFUSR approach
  73+ 59F4 ~            ; input IX=pointer to input array, real data from +2
  74+ 59F4 ~            ; +2 = offset
  75+ 59F4 ~            ; +4 = count
  76+ 59F4 ~            ; +6 = value
  77+ 59F4 ~            ; +8 = halt flag
  78+ 59F4 ~            FILVRM_DEFUSR:
  79+ 59F4 ~            	LD A,(IX+8)
  80+ 59F4 ~            	OR A
  81+ 59F4 ~            	JR Z,.L0
  82+ 59F4 ~            	HALT
  83+ 59F4 ~            .L0:
  84+ 59F4 ~            	LD A,1
  85+ 59F4 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  86+ 59F4 ~            	LD L,(IX+2)
  87+ 59F4 ~            	LD H,(IX+3)
  88+ 59F4 ~            	LD C,(IX+4)
  89+ 59F4 ~            	LD B,(IX+5)
  90+ 59F4 ~            	LD A,(IX+6)
  91+ 59F4 ~            	CALL BIOS_FILVRM
  92+ 59F4 ~            	XOR A
  93+ 59F4 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  94+ 59F4 ~            	RET
  95+ 59F4 ~            ; *******************************************************************************************************
  96+ 59F4               ENDIF
  97+ 59F4
  98+ 59F4               IF (1 == 1)
  99+ 59F4              ; *******************************************************************************************************
 100+ 59F4              ; function to handle CALL MEMVRM basic extension
 101+ 59F4              ; copies from RAM to VRAM
 102+ 59F4              ; if flag != 0 it will issue HALT before copying
 103+ 59F4              ; if bit 1 of flag set and sprite system initialized it will set sprite update flag
 104+ 59F4              ; _MEMVRM ( INT source,
 105+ 59F4              ;			INT destination,
 106+ 59F4              ;			INT count,
 107+ 59F4              ;			BYTE flag)
 108+ 59F4              ; will put ram in page 0 also, page 1 is already there
 109+ 59F4              MEMVRM:
 110+ 59F4              	; opening (
 111+ 59F4 CD 2B 66     	CALL CHKCHAR
 112+ 59F7 28           	DB '('
 113+ 59F8              	; get source address
 114+ 59F8 DD 21 2F 54  	LD IX, FRMQNT
 115+ 59FC CD 59 01     	CALL CALBAS
 116+ 59FF D5           	PUSH DE
 117+ 5A00              	; comma
 118+ 5A00 CD 2B 66     	CALL CHKCHAR
 119+ 5A03 2C           	DB ','
 120+ 5A04              	; get destination address
 121+ 5A04 DD 21 2F 54  	LD IX, FRMQNT
 122+ 5A08 CD 59 01     	CALL CALBAS
 123+ 5A0B D5           	PUSH DE
 124+ 5A0C              	; comma
 125+ 5A0C CD 2B 66     	CALL CHKCHAR
 126+ 5A0F 2C           	DB ','
 127+ 5A10              	; get length
 128+ 5A10 DD 21 2F 54  	LD IX, FRMQNT
 129+ 5A14 CD 59 01     	CALL CALBAS
 130+ 5A17 D5           	PUSH DE
 131+ 5A18              	; comma
 132+ 5A18 CD 2B 66     	CALL CHKCHAR
 133+ 5A1B 2C           	DB ','
 134+ 5A1C              	; get vsync wait
 135+ 5A1C DD 21 1C 52  	LD IX, GETBYT
 136+ 5A20 CD 59 01     	CALL CALBAS
 137+ 5A23 F5           	PUSH AF
 138+ 5A24              	; ending )
 139+ 5A24 CD 2B 66     	CALL CHKCHAR
 140+ 5A27 29           	DB ')'
 141+ 5A28
 142+ 5A28                  ; save position in BASIC text
 143+ 5A28 E5           	PUSH HL
 144+ 5A29 DD E1        	POP IX
 145+ 5A2B
 146+ 5A2B F1           	POP AF ; wait vsync
 147+ 5A2C B7           	OR A
 148+ 5A2D 28 0F        	JR Z, .L1
 149+ 5A2F              	; check for special case to set sprite update flag
 150+ 5A2F              	IF (SPRITE_CMDS == 1)
 151+ 5A2F E6 02        		AND 2
 152+ 5A31 28 0A        		JR Z,.L2
 153+ 5A33 3A 7F 4D     		LD A, (SPRATR_INIT_STATUS)
 154+ 5A36 B7           		OR A
 155+ 5A37 28 04        		JR Z,.L2
 156+ 5A39 2A 80 4D     		LD HL,(SPRATR_UPDATE_FLAG)
 157+ 5A3C 77           		LD (HL),A
 158+ 5A3D              	ENDIF
 159+ 5A3D              .L2:
 160+ 5A3D 76           	HALT
 161+ 5A3E              .L1:
 162+ 5A3E              	; pop LDIR parameters and store away for later
 163+ 5A3E C1           	POP BC ; count
 164+ 5A3F D1           	POP DE ; vram destination
 165+ 5A40 E1           	POP HL ; ram source
 166+ 5A41 D9           	EXX
 167+ 5A42 FD 21 49 5A   	LD IY, .RET
 168+ 5A46 C3 DC 65     	JP ENABLE_PAGE0
 169+ 5A49              .RET:
 170+ 5A49 FB           	EI
 171+ 5A4A D9           	EXX
 172+ 5A4B CD 57 5A     	CALL VRAM_LDIRVM
 173+ 5A4E D1               POP DE
 174+ 5A4F C1               POP BC
 175+ 5A50 CD 53 65         CALL RESTORE_PAGE_INFO
 176+ 5A53 DD E5        	PUSH IX
 177+ 5A55 E1           	POP HL
 178+ 5A56 C9           	RET
 179+ 5A57              ; *******************************************************************************************************
 180+ 5A57               ENDIF
 181+ 5A57
 182+ 5A57               IF (0 == 1)
 183+ 5A57 ~            ; *******************************************************************************************************
 184+ 5A57 ~            ; same as MEMVRM but for DEFUSR approach
 185+ 5A57 ~            ; input IX=pointer to input array, real data from +2
 186+ 5A57 ~            ; +2 = source address
 187+ 5A57 ~            ; +4 = destination address
 188+ 5A57 ~            ; +6 = lenght
 189+ 5A57 ~            ; +8 = flag
 190+ 5A57 ~            MEMVRM_DEFUSR:
 191+ 5A57 ~            	LD A,(IX+8)
 192+ 5A57 ~            	OR A
 193+ 5A57 ~            	JR Z,.L0
 194+ 5A57 ~            	IF (SPRITE_CMDS == 1)
 195+ 5A57 ~            		AND 2
 196+ 5A57 ~            		JR Z,.L2
 197+ 5A57 ~            		LD A, (SPRATR_INIT_STATUS)
 198+ 5A57 ~            		OR A
 199+ 5A57 ~            		JR Z,.L2
 200+ 5A57 ~            		LD HL,(SPRATR_UPDATE_FLAG)
 201+ 5A57 ~            		LD (HL),A
 202+ 5A57 ~            	ENDIF
 203+ 5A57 ~            .L2:
 204+ 5A57 ~            	HALT
 205+ 5A57 ~            .L0:
 206+ 5A57 ~            	; enable page 0
 207+ 5A57 ~            	LD IY, .RET
 208+ 5A57 ~            	JP ENABLE_PAGE0
 209+ 5A57 ~            .RET:
 210+ 5A57 ~            	EI
 211+ 5A57 ~            	LD L,(IX+2)
 212+ 5A57 ~            	LD H,(IX+3)
 213+ 5A57 ~            	LD E,(IX+4)
 214+ 5A57 ~            	LD D,(IX+5)
 215+ 5A57 ~            	LD C,(IX+6)
 216+ 5A57 ~            	LD B,(IX+7)
 217+ 5A57 ~            	CALL VRAM_LDIRVM
 218+ 5A57 ~                POP DE
 219+ 5A57 ~                POP BC
 220+ 5A57 ~                JP RESTORE_PAGE_INFO
 221+ 5A57 ~            ; *******************************************************************************************************
 222+ 5A57               ENDIF
 223+ 5A57
 224+ 5A57              ; *******************************************************************************************************
 225+ 5A57              ; common code to copy from memory to VRAM
 226+ 5A57              ; input HL=RAM source
 227+ 5A57              ; input DE=VRAM destination
 228+ 5A57              ; BC=count
 229+ 5A57              VRAM_LDIRVM:
 230+ 5A57 3E 01        	LD A,1
 231+ 5A59 32 21 63     	LD (VRAM_UPDATE_IN_PROGRESS),A
 232+ 5A5C EB           	EX DE, HL
 233+ 5A5D F3           	DI
 234+ 5A5E CD 03 65     	CALL SETWRT_LOCAL
 235+ 5A61 FB           	EI
 236+ 5A62 EB           	EX DE, HL
 237+ 5A63 78           	LD A, B
 238+ 5A64 B7           	OR A
 239+ 5A65 28 0D        	JR Z, .L3
 240+ 5A67 C5           	PUSH BC
 241+ 5A68 0E 98        	LD C, #98
 242+ 5A6A              .L2:
 243+ 5A6A 50           	LD D, B
 244+ 5A6B 06 00        	LD B, 0
 245+ 5A6D CD 10 65     	CALL BBYTECOPY_NO_C
 246+ 5A70 42           	LD B, D
 247+ 5A71 10 F7        	DJNZ .L2
 248+ 5A73 C1           	POP BC
 249+ 5A74              .L3:
 250+ 5A74 79           	LD A, C
 251+ 5A75 B7           	OR A
 252+ 5A76 28 04        	JR Z,.L4
 253+ 5A78 41           	LD B, C
 254+ 5A79 CD 0E 65     	CALL BBYTECOPY
 255+ 5A7C              .L4:
 256+ 5A7C AF           	XOR A
 257+ 5A7D 32 21 63     	LD (VRAM_UPDATE_IN_PROGRESS),A
 258+ 5A80 C9           	RET
 259+ 5A81              ; *******************************************************************************************************
 260+ 5A81
 261+ 5A81               IF (1 == 1)
 262+ 5A81              ; *******************************************************************************************************
 263+ 5A81              ; function to handle CALL VRMMEM basic extension
 264+ 5A81              ; copies from VRAM to RAM
 265+ 5A81              ; _VRMMEM ( INT source,
 266+ 5A81              ;			INT destination,
 267+ 5A81              ;			INT count
 268+ 5A81              ; will put ram in page 0 also, page 1 is already there
 269+ 5A81              VRMMEM:
 270+ 5A81              	; opening (
 271+ 5A81 CD 2B 66     	CALL CHKCHAR
 272+ 5A84 28           	DB '('
 273+ 5A85              	; get source address
 274+ 5A85 DD 21 2F 54  	LD IX, FRMQNT
 275+ 5A89 CD 59 01     	CALL CALBAS
 276+ 5A8C D5           	PUSH DE
 277+ 5A8D              	; comma
 278+ 5A8D CD 2B 66     	CALL CHKCHAR
 279+ 5A90 2C           	DB ','
 280+ 5A91              	; get destination address
 281+ 5A91 DD 21 2F 54  	LD IX, FRMQNT
 282+ 5A95 CD 59 01     	CALL CALBAS
 283+ 5A98 D5           	PUSH DE
 284+ 5A99              	; comma
 285+ 5A99 CD 2B 66     	CALL CHKCHAR
 286+ 5A9C 2C           	DB ','
 287+ 5A9D              	; get length
 288+ 5A9D DD 21 2F 54  	LD IX, FRMQNT
 289+ 5AA1 CD 59 01     	CALL CALBAS
 290+ 5AA4 D5           	PUSH DE
 291+ 5AA5              	; ending )
 292+ 5AA5 CD 2B 66     	CALL CHKCHAR
 293+ 5AA8 29           	DB ')'
 294+ 5AA9
 295+ 5AA9                  ; save position in BASIC text
 296+ 5AA9 E5           	PUSH HL
 297+ 5AAA DD E1        	POP IX
 298+ 5AAC
 299+ 5AAC C1           	POP BC ; count
 300+ 5AAD D1           	POP DE ; destination
 301+ 5AAE E1           	POP HL ; source
 302+ 5AAF D9           	EXX
 303+ 5AB0 FD 21 B7 5A  	LD IY, .RET
 304+ 5AB4 C3 DC 65     	JP ENABLE_PAGE0
 305+ 5AB7              .RET:
 306+ 5AB7 FB           	EI
 307+ 5AB8 D9           	EXX
 308+ 5AB9 CD C5 5A     	CALL VRAM_LDIRMV
 309+ 5ABC D1               POP DE
 310+ 5ABD C1               POP BC
 311+ 5ABE CD 53 65         CALL RESTORE_PAGE_INFO
 312+ 5AC1 DD E5        	PUSH IX
 313+ 5AC3 E1           	POP HL
 314+ 5AC4 C9           	RET
 315+ 5AC5              ; *******************************************************************************************************
 316+ 5AC5               ENDIF
 317+ 5AC5
 318+ 5AC5               IF (0 == 1)
 319+ 5AC5 ~            ; *******************************************************************************************************
 320+ 5AC5 ~            ; same as VRMMEM but for DEFUSR approach
 321+ 5AC5 ~            ; input IX=pointer to input array, real data from +2
 322+ 5AC5 ~            ; +2 = source address
 323+ 5AC5 ~            ; +4 = destination address
 324+ 5AC5 ~            ; +6 = count
 325+ 5AC5 ~            VRMMEM_DEFUSR:
 326+ 5AC5 ~            	; enable page 0
 327+ 5AC5 ~            	LD IY, .RET
 328+ 5AC5 ~            	JP ENABLE_PAGE0
 329+ 5AC5 ~            .RET:
 330+ 5AC5 ~            	EI
 331+ 5AC5 ~            	LD L,(IX+2)
 332+ 5AC5 ~            	LD H,(IX+3)
 333+ 5AC5 ~            	LD E,(IX+4)
 334+ 5AC5 ~            	LD D,(IX+5)
 335+ 5AC5 ~            	LD C,(IX+6)
 336+ 5AC5 ~            	LD B,(IX+7)
 337+ 5AC5 ~            	CALL VRAM_LDIRMV
 338+ 5AC5 ~                POP DE
 339+ 5AC5 ~                POP BC
 340+ 5AC5 ~                JP RESTORE_PAGE_INFO
 341+ 5AC5 ~            ; *******************************************************************************************************
 342+ 5AC5               ENDIF
 343+ 5AC5
 344+ 5AC5              ; *******************************************************************************************************
 345+ 5AC5              ; common code to copy from VRAM to RAM
 346+ 5AC5              ; input HL=VRAM source
 347+ 5AC5              ; input DE=RAM destination
 348+ 5AC5              ; BC=count
 349+ 5AC5              VRAM_LDIRMV:
 350+ 5AC5 3E 01        	LD A,1
 351+ 5AC7 32 21 63     	LD (VRAM_UPDATE_IN_PROGRESS),A
 352+ 5ACA 7D           	LD	A, L
 353+ 5ACB F3           	DI
 354+ 5ACC D3 99        	OUT	(099H), A
 355+ 5ACE 7C           	LD	A, H
 356+ 5ACF E6 3F        	AND	03FH
 357+ 5AD1 00           	NOP ; too fast VDP access per openMSX
 358+ 5AD2 D3 99        	OUT	(099H), A
 359+ 5AD4 FB           	EI
 360+ 5AD5 00           	NOP
 361+ 5AD6 00           	NOP
 362+ 5AD7 00           	NOP ; too fast VDP access per openMSX
 363+ 5AD8              .L4:
 364+ 5AD8 DB 98            IN A, (#98)
 365+ 5ADA 12           	LD (DE), A
 366+ 5ADB 13               INC DE
 367+ 5ADC 0B               DEC BC
 368+ 5ADD 79               LD A, C
 369+ 5ADE B0               OR B
 370+ 5ADF 20 F7            JR NZ, .L4
 371+ 5AE1 AF           	XOR A
 372+ 5AE2 32 21 63     	LD (VRAM_UPDATE_IN_PROGRESS),A
 373+ 5AE5 C9               RET
 374+ 5AE6              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
 147  5AE6               ENDIF
 148  5AE6
 149  5AE6               IF (GENCAL_CMD == 1)
 150  5AE6               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
   1+ 5AE6               IF (0 == 1)
   2+ 5AE6 ~            ; *******************************************************************************************************
   3+ 5AE6 ~            ; same as GENCAL but for DEFUSR approach
   4+ 5AE6 ~            ; input IX=pointer to input array, real data from +2
   5+ 5AE6 ~            ; +2 = function address to call
   6+ 5AE6 ~            ; +4 = register list array pointer
   7+ 5AE6 ~            GENCAL_DEFUSR:
   8+ 5AE6 ~                LD L,(IX+2)
   9+ 5AE6 ~                LD H,(IX+3)
  10+ 5AE6 ~                PUSH HL
  11+ 5AE6 ~                LD L,(IX+4)
  12+ 5AE6 ~                LD H,(IX+5)
  13+ 5AE6 ~                PUSH HL
  14+ 5AE6 ~                JR GENCAL.COMMON
  15+ 5AE6 ~            ; *******************************************************************************************************
  16+ 5AE6               ENDIF
  17+ 5AE6
  18+ 5AE6              ; *******************************************************************************************************
  19+ 5AE6              ; function to handle CALL GENCAL basic extension
  20+ 5AE6              ; GENCAL ( INT fn_addr, = address of the function to call
  21+ 5AE6              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
  22+ 5AE6              ; output values of registers will also be stored at reg_list_ptr
  23+ 5AE6              GENCAL:
  24+ 5AE6               IF (1 == 1)
  25+ 5AE6              	; opening (
  26+ 5AE6 CD 2B 66     	CALL CHKCHAR
  27+ 5AE9 28           	DB '('
  28+ 5AEA              	; get function address
  29+ 5AEA DD 21 2F 54  	LD IX, FRMQNT
  30+ 5AEE CD 59 01     	CALL CALBAS
  31+ 5AF1 D5           	PUSH DE
  32+ 5AF2              	; comma
  33+ 5AF2 CD 2B 66     	CALL CHKCHAR
  34+ 5AF5 2C           	DB ','
  35+ 5AF6              	; get pointer to register list
  36+ 5AF6 3E 02            LD A,2
  37+ 5AF8 06 01            LD B,1
  38+ 5AFA 11 00 05         LD DE,#0500
  39+ 5AFD CD 58 66         CALL GET_BASIC_ARRAY_DATA_POINTER
  40+ 5B00 C5           	PUSH BC
  41+ 5B01              	; ending )
  42+ 5B01 CD 2B 66     	CALL CHKCHAR
  43+ 5B04 29           	DB ')'
  44+ 5B05               ENDIF
  45+ 5B05              .COMMON:
  46+ 5B05              	; save BASIC token position
  47+ 5B05 E5           	PUSH HL
  48+ 5B06 D9               EXX
  49+ 5B07 E1           	POP HL ; HL'=next basic token
  50+ 5B08 D9               EXX
  51+ 5B09
  52+ 5B09 E1               POP HL ; get pointer to register values
  53+ 5B0A F3           	DI
  54+ 5B0B ED 73 10 63      LD (BLIT_STRUCT), SP
  55+ 5B0F F9               LD SP, HL
  56+ 5B10 F1               POP AF
  57+ 5B11 C1               POP BC
  58+ 5B12 D1               POP DE
  59+ 5B13 E1               POP HL
  60+ 5B14 DD E1            POP IX
  61+ 5B16 FD E1            POP IY
  62+ 5B18 D9               EXX
  63+ 5B19 ED 73 12 63      LD (BLIT_STRUCT+2), SP
  64+ 5B1D ED 7B 10 63      LD SP, (BLIT_STRUCT)
  65+ 5B21 FB               EI
  66+ 5B22 D1               POP DE ; get function to call
  67+ 5B23 E5               PUSH HL
  68+ 5B24 CD 3F 5B         CALL .EXXDECALL
  69+ 5B27 F3               DI
  70+ 5B28 ED 73 10 63      LD (BLIT_STRUCT), SP
  71+ 5B2C ED 7B 12 63      LD SP, (BLIT_STRUCT+2)
  72+ 5B30 FD E5            PUSH IY
  73+ 5B32 DD E5            PUSH IX
  74+ 5B34 E5               PUSH HL
  75+ 5B35 D5               PUSH DE
  76+ 5B36 C5               PUSH BC
  77+ 5B37 F5               PUSH AF
  78+ 5B38 ED 7B 10 63      LD SP, (BLIT_STRUCT)
  79+ 5B3C FB               EI
  80+ 5B3D E1               POP HL
  81+ 5B3E C9           	RET
  82+ 5B3F
  83+ 5B3F              .EXXDECALL:
  84+ 5B3F D5               PUSH DE
  85+ 5B40 D9               EXX
  86+ 5B41 C9               RET
  87+ 5B42              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
 151  5B42               ENDIF
 152  5B42
 153  5B42               IF (BOX_CMDS == 1)
 154  5B42               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
   1+ 5B42              ; *******************************************************************************************************
   2+ 5B42              ; generic function to implement rectangle data copy
   3+ 5B42              ; should be modified to call appropriate function for memory or vram
   4+ 5B42              ; input IX=pointer to following structure
   5+ 5B42              ; +00 source data pointer
   6+ 5B42              ; +02 num bytes in a row
   7+ 5B42              ; +04 number of rows
   8+ 5B42              ; +06 source add-to value till next row
   9+ 5B42              ; +08 destination address
  10+ 5B42              ; +10 destination add-to value till next row
  11+ 5B42              ; modifies AF, BC, DE, HL
  12+ 5B42              RECTANGLE_COPY:
  13+ 5B42 DD 6E 00     	LD L, (IX+0)
  14+ 5B45 DD 66 01     	LD H, (IX+1) ; source address
  15+ 5B48 DD 5E 08     	LD E, (IX+8)
  16+ 5B4B DD 56 09     	LD D, (IX+9) ; destination
  17+ 5B4E DD 46 04     	LD B, (IX+4) ; row number
  18+ 5B51              .L1:
  19+ 5B51 C5           	PUSH BC
  20+ 5B52 E5           		PUSH HL
  21+ 5B53 D5           			PUSH DE
  22+ 5B54 DD 4E 02     				LD C, (IX+2)
  23+ 5B57 DD 46 03     				LD B, (IX+3) ; num bytes in a row
  24+ 5B5A              .CALL1:
  25+ 5B5A CD 00 00     				CALL 0 ; set destination address from DE
  26+ 5B5D              .CALL2:
  27+ 5B5D CD 00 00     				CALL 0 ; copy data fn
  28+ 5B60 E1           			POP HL
  29+ 5B61 DD 4E 0A     			LD C, (IX+10)
  30+ 5B64 DD 46 0B     			LD B, (IX+11) ; destination add-to
  31+ 5B67 09           			ADD HL, BC
  32+ 5B68 EB           			EX DE, HL
  33+ 5B69 E1           		POP HL
  34+ 5B6A DD 4E 06     		LD C, (IX+6)
  35+ 5B6D DD 46 07     		LD B, (IX+7) ; src add-to
  36+ 5B70 09           		ADD HL, BC
  37+ 5B71 C1           	POP BC
  38+ 5B72 10 DD        	DJNZ .L1
  39+ 5B74 C9           	RET
  40+ 5B75              ; *******************************************************************************************************
  41+ 5B75
  42+ 5B75               IF (1 == 1)
  43+ 5B75              ; *******************************************************************************************************
  44+ 5B75              ; function to handle CALL BOXMEMCPY basic extension
  45+ 5B75              ; copies data with window like boundaries within ram
  46+ 5B75              ; BOXMEMCPY ( INT source data pointer,
  47+ 5B75              ;			  INT source number of bytes in a row,
  48+ 5B75              ;			  INT number of rows,
  49+ 5B75              ;			  INT source add-to value till next row,
  50+ 5B75              ; 			  INT destination pointer,
  51+ 5B75              ;			  INT destination add-to value till next row )
  52+ 5B75              ; request_data_ptr described in RECTANGLE_COPY
  53+ 5B75              ; will put ram in page 0 also, page 1 is already there
  54+ 5B75              BOXMEMCPY:
  55+ 5B75 11 7F 5B     	LD DE,BOXMEMCPY_COMMON
  56+ 5B78 ED 53 F7 5B  	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
  57+ 5B7C C3 92 5B     	JP BOX_EXTENSION_PARAMS_COMMON
  58+ 5B7F               ENDIF
  59+ 5B7F
  60+ 5B7F               IF (0 == 1)
  61+ 5B7F ~            ; *******************************************************************************************************
  62+ 5B7F ~            ; same as BOXMEMCPY but for DEFUSR approach
  63+ 5B7F ~            ; input IX=pointer to input array, real data from +2
  64+ 5B7F ~            ; +02 = source data pointer
  65+ 5B7F ~            ; +04 = source number of bytes in a row
  66+ 5B7F ~            ; +06 = number of rows
  67+ 5B7F ~            ; +08 = source add-to value till next row
  68+ 5B7F ~            ; +10 = destination pointer
  69+ 5B7F ~            ; +12 = destination add-to value till next row
  70+ 5B7F ~            BOXMEMCPY_DEFUSR:
  71+ 5B7F ~            	LD HL,BOXMEMCPY_COMMON
  72+ 5B7F ~            	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
  73+ 5B7F ~            	INC IX
  74+ 5B7F ~            	INC IX
  75+ 5B7F ~            	JP BOXCOMMON_DEFUSR
  76+ 5B7F               ENDIF
  77+ 5B7F
  78+ 5B7F              BOXMEMCPY_COMMON:
  79+ 5B7F FB           	EI
  80+ 5B80              	; set RAM functions to call
  81+ 5B80 21 00 00     	LD HL, 0
  82+ 5B83 22 5A 5B     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
  83+ 5B86 22 5C 5B     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
  84+ 5B89 21 ED B0     	LD HL, #B0ED ; LDIR
  85+ 5B8C 22 5E 5B     	LD (RECTANGLE_COPY.CALL1+4), HL
  86+ 5B8F C3 FC 5B     	JP BOXCOMMON_DEFUSR.CALL
  87+ 5B92              ; *******************************************************************************************************
  88+ 5B92
  89+ 5B92               IF (1 == 1)
  90+ 5B92              ; *******************************************************************************************************
  91+ 5B92              ; common parts of BOX commands to load parameters
  92+ 5B92              BOX_EXTENSION_PARAMS_COMMON:
  93+ 5B92              	; opening (
  94+ 5B92 CD 2B 66     	CALL CHKCHAR
  95+ 5B95 28           	DB '('
  96+ 5B96              	; get source data pointer
  97+ 5B96 DD 21 2F 54  	LD IX, FRMQNT
  98+ 5B9A CD 59 01     	CALL CALBAS
  99+ 5B9D ED 53 10 63  	LD (BLIT_STRUCT+0), DE
 100+ 5BA1              	; comma
 101+ 5BA1 CD 2B 66     	CALL CHKCHAR
 102+ 5BA4 2C           	DB ','
 103+ 5BA5              	; source number of bytes in a row
 104+ 5BA5 DD 21 2F 54  	LD IX, FRMQNT
 105+ 5BA9 CD 59 01     	CALL CALBAS
 106+ 5BAC ED 53 12 63  	LD (BLIT_STRUCT+2), DE
 107+ 5BB0              	; comma
 108+ 5BB0 CD 2B 66     	CALL CHKCHAR
 109+ 5BB3 2C           	DB ','
 110+ 5BB4              	; number of rows
 111+ 5BB4 DD 21 2F 54  	LD IX, FRMQNT
 112+ 5BB8 CD 59 01     	CALL CALBAS
 113+ 5BBB ED 53 14 63  	LD (BLIT_STRUCT+4), DE
 114+ 5BBF              	; comma
 115+ 5BBF CD 2B 66     	CALL CHKCHAR
 116+ 5BC2 2C           	DB ','
 117+ 5BC3              	; source add-to value till next row
 118+ 5BC3 DD 21 2F 54  	LD IX, FRMQNT
 119+ 5BC7 CD 59 01     	CALL CALBAS
 120+ 5BCA ED 53 16 63  	LD (BLIT_STRUCT+6), DE
 121+ 5BCE              	; comma
 122+ 5BCE CD 2B 66     	CALL CHKCHAR
 123+ 5BD1 2C           	DB ','
 124+ 5BD2              	; destination pointer
 125+ 5BD2 DD 21 2F 54  	LD IX, FRMQNT
 126+ 5BD6 CD 59 01     	CALL CALBAS
 127+ 5BD9 ED 53 18 63  	LD (BLIT_STRUCT+8), DE
 128+ 5BDD              	; comma
 129+ 5BDD CD 2B 66     	CALL CHKCHAR
 130+ 5BE0 2C           	DB ','
 131+ 5BE1              	; destination add-to value till next row
 132+ 5BE1 DD 21 2F 54  	LD IX, FRMQNT
 133+ 5BE5 CD 59 01     	CALL CALBAS
 134+ 5BE8 ED 53 1A 63  	LD (BLIT_STRUCT+10), DE
 135+ 5BEC              	; ending )
 136+ 5BEC CD 2B 66     	CALL CHKCHAR
 137+ 5BEF 29           	DB ')'
 138+ 5BF0 DD 21 10 63  	LD IX,BLIT_STRUCT
 139+ 5BF4               ENDIF
 140+ 5BF4              BOXCOMMON_DEFUSR:
 141+ 5BF4 E5           	PUSH HL ; save position in BASIC buffer
 142+ 5BF5              .ADDR:
 143+ 5BF5 FD 21 00 00  	LD IY, 0 ; modified by code
 144+ 5BF9 C3 DC 65     	JP ENABLE_PAGE0
 145+ 5BFC              .CALL:
 146+ 5BFC CD 42 5B     	CALL RECTANGLE_COPY
 147+ 5BFF AF           	XOR A
 148+ 5C00 32 21 63     	LD (VRAM_UPDATE_IN_PROGRESS),A
 149+ 5C03
 150+ 5C03 D1               POP DE
 151+ 5C04 C1               POP BC
 152+ 5C05 CD 53 65         CALL RESTORE_PAGE_INFO
 153+ 5C08
 154+ 5C08 E1           	POP HL
 155+ 5C09 C9           	RET
 156+ 5C0A              ; *******************************************************************************************************
 157+ 5C0A
 158+ 5C0A               IF (1 == 1)
 159+ 5C0A              ; *******************************************************************************************************
 160+ 5C0A              ; function to handle CALL BOXMEMVRM basic extension
 161+ 5C0A              ; copies data with window like boundaries from ram to Vram
 162+ 5C0A              ; BOXMEMVRM ( INT source data pointer,
 163+ 5C0A              ;			  INT source number of bytes in a row,
 164+ 5C0A              ;			  INT number of rows,
 165+ 5C0A              ;			  INT source add-to value till next row,
 166+ 5C0A              ; 			  INT destination pointer,
 167+ 5C0A              ;			  INT destination add-to value till next row )
 168+ 5C0A              ; request_data_ptr described in RECTANGLE_COPY
 169+ 5C0A              ; will put ram in page 0 also, page 1 is already there
 170+ 5C0A              BOXMEMVRM:
 171+ 5C0A 11 14 5C     	LD DE,BOXMEMVRM_COMMON
 172+ 5C0D ED 53 F7 5B  	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
 173+ 5C11 C3 92 5B     	JP BOX_EXTENSION_PARAMS_COMMON
 174+ 5C14               ENDIF
 175+ 5C14
 176+ 5C14               IF (0 == 1)
 177+ 5C14 ~            ; *******************************************************************************************************
 178+ 5C14 ~            ; same as BOXMEMVRM but for DEFUSR approach
 179+ 5C14 ~            ; input IX=pointer to input array, real data from +2
 180+ 5C14 ~            ; +02 = source data pointer
 181+ 5C14 ~            ; +04 = source number of bytes in a row
 182+ 5C14 ~            ; +06 = number of rows
 183+ 5C14 ~            ; +08 = source add-to value till next row
 184+ 5C14 ~            ; +10 = destination pointer
 185+ 5C14 ~            ; +12 = destination add-to value till next row
 186+ 5C14 ~            BOXMEMVRM_DEFUSR:
 187+ 5C14 ~            	LD HL,BOXMEMVRM_COMMON
 188+ 5C14 ~            	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
 189+ 5C14 ~            	INC IX
 190+ 5C14 ~            	INC IX
 191+ 5C14 ~            	JP BOXCOMMON_DEFUSR
 192+ 5C14               ENDIF
 193+ 5C14
 194+ 5C14              BOXMEMVRM_COMMON:
 195+ 5C14 FB           	EI
 196+ 5C15              	; set RAM functions to call
 197+ 5C15 21 2F 5C     	LD HL, .SETDEST
 198+ 5C18 22 5B 5B     	LD (RECTANGLE_COPY.CALL1+1), HL
 199+ 5C1B 21 37 5C     	LD HL, .COPYDATA
 200+ 5C1E 22 5E 5B     	LD (RECTANGLE_COPY.CALL2+1), HL
 201+ 5C21 3E CD        	LD A, #CD ; CALL
 202+ 5C23 32 5A 5B     	LD (RECTANGLE_COPY.CALL1), A
 203+ 5C26 32 5D 5B     	LD (RECTANGLE_COPY.CALL2), A
 204+ 5C29              	;LD A,1
 205+ 5C29 32 21 63     	LD (VRAM_UPDATE_IN_PROGRESS),A
 206+ 5C2C C3 FC 5B     	JP BOXCOMMON_DEFUSR.CALL
 207+ 5C2F              .SETDEST:
 208+ 5C2F EB           	EX DE, HL
 209+ 5C30 F3           	DI
 210+ 5C31 CD 03 65     	CALL SETWRT_LOCAL
 211+ 5C34 FB           	EI
 212+ 5C35 EB           	EX DE, HL
 213+ 5C36 C9           	RET
 214+ 5C37              .COPYDATA:
 215+ 5C37 41           	LD B, C
 216+ 5C38 C3 0E 65     	JP BBYTECOPY
 217+ 5C3B              ; *******************************************************************************************************
# file closed: asm\BOX.asm
 155  5C3B               ENDIF
 156  5C3B
 157  5C3B               IF (BLIT_CMDS == 1)
 158  5C3B               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
   1+ 5C3B              ; *******************************************************************************************************
   2+ 5C3B              ; function rotates mask and data of several characters and applies to background data
   3+ 5C3B              ; this handles x-shift from 0 to 4
   4+ 5C3B              ; contains self-modifying code that is set-up from external function
   5+ 5C3B              ; input HL=pointer to mask data
   6+ 5C3B              ; input HL'=pointer to character data
   7+ 5C3B              ; input DE=output buffer containing background data
   8+ 5C3B              ; input BC=DE+8
   9+ 5C3B              ; input A=number of characters to process
  10+ 5C3B              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  11+ 5C3B              SHIFT04:
  12+ 5C3B 08           	EX AF, AF'
  13+ 5C3C 7E           	LD A, (HL) ; get mask
  14+ 5C3D D9           	EXX
  15+ 5C3E 57           	LD D, A
  16+ 5C3F 1E FF        	LD E, #FF
  17+ 5C41 37           	SCF
  18+ 5C42              .M1:
  19+ 5C42 18 FE        	JR .M1 ; this is self-modifying part
  20+ 5C44 CB 1A        	RR D
  21+ 5C46 CB 1B        	RR E
  22+ 5C48 CB 1A        	RR D
  23+ 5C4A CB 1B        	RR E
  24+ 5C4C CB 1A        	RR D
  25+ 5C4E CB 1B        	RR E
  26+ 5C50 CB 1A        	RR D
  27+ 5C52 CB 1B        	RR E
  28+ 5C54
  29+ 5C54 46           	LD B, (HL) ; get data
  30+ 5C55 0E 00        	LD C, 0
  31+ 5C57              .M2:
  32+ 5C57 18 FE        	JR .M2 ; also self-modifying part
  33+ 5C59 CB 38        	SRL B
  34+ 5C5B CB 19        	RR C
  35+ 5C5D CB 38        	SRL B
  36+ 5C5F CB 19        	RR C
  37+ 5C61 CB 38        	SRL B
  38+ 5C63 CB 19        	RR C
  39+ 5C65 CB 38        	SRL B
  40+ 5C67 CB 19        	RR C
  41+ 5C69
  42+ 5C69 D9           	EXX
  43+ 5C6A 1A           	LD A, (DE) ; background
  44+ 5C6B D9           	EXX
  45+ 5C6C A2           	AND D
  46+ 5C6D B0           	OR B
  47+ 5C6E D9           	EXX
  48+ 5C6F 12           	LD (DE), A
  49+ 5C70
  50+ 5C70 0A           	LD A, (BC)
  51+ 5C71 D9           	EXX
  52+ 5C72 A3           	AND E
  53+ 5C73 B1           	OR C
  54+ 5C74 23           	INC HL
  55+ 5C75 D9           	EXX
  56+ 5C76 02           	LD (BC), A
  57+ 5C77
  58+ 5C77 23           	INC HL
  59+ 5C78 13           	INC DE
  60+ 5C79 03           	INC BC
  61+ 5C7A
  62+ 5C7A 08           	EX AF, AF'
  63+ 5C7B 3D           	DEC A
  64+ 5C7C C2 3B 5C     	JP NZ, SHIFT04
  65+ 5C7F C9           	RET
  66+ 5C80              ; *******************************************************************************************************
  67+ 5C80
  68+ 5C80              ; *******************************************************************************************************
  69+ 5C80              ; function rotates mask and data of several characters and applies to background data
  70+ 5C80              ; this handles x-shift from 5 to 8
  71+ 5C80              ; contains self-modifying code that is set-up from external function
  72+ 5C80              ; input HL=pointer to mask data
  73+ 5C80              ; input HL'=pointer to character data
  74+ 5C80              ; input DE=output buffer containing background data
  75+ 5C80              ; input BC=DE+8
  76+ 5C80              ; input A=number of characters to process
  77+ 5C80              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  78+ 5C80              SHIFT58:
  79+ 5C80 08           	EX AF, AF'
  80+ 5C81 7E           	LD A, (HL) ; get mask
  81+ 5C82 D9           	EXX
  82+ 5C83 57           	LD D, A
  83+ 5C84 1E FF        	LD E, #FF
  84+ 5C86 37           	SCF
  85+ 5C87              .M1:
  86+ 5C87 18 FE        	JR .M1 ; this is self-modifying part
  87+ 5C89 CB 12        	RL D
  88+ 5C8B CB 13        	RL E
  89+ 5C8D CB 12        	RL D
  90+ 5C8F CB 13        	RL E
  91+ 5C91 CB 12        	RL D
  92+ 5C93 CB 13        	RL E
  93+ 5C95
  94+ 5C95 46           	LD B, (HL)
  95+ 5C96 0E 00        	LD C, 0
  96+ 5C98              .M2:
  97+ 5C98 18 FE        	JR .M2 ; also self-modifying part
  98+ 5C9A CB 20        	SLA B
  99+ 5C9C CB 11        	RL C
 100+ 5C9E CB 20        	SLA B
 101+ 5CA0 CB 11        	RL C
 102+ 5CA2 CB 20        	SLA B
 103+ 5CA4 CB 11        	RL C
 104+ 5CA6
 105+ 5CA6 D9           	EXX
 106+ 5CA7 1A           	LD A, (DE) ; background
 107+ 5CA8 D9           	EXX
 108+ 5CA9 A3           	AND E
 109+ 5CAA B1           	OR C
 110+ 5CAB D9           	EXX
 111+ 5CAC 12           	LD (DE), A
 112+ 5CAD
 113+ 5CAD 0A           	LD A, (BC)
 114+ 5CAE D9           	EXX
 115+ 5CAF A2           	AND D
 116+ 5CB0 B0           	OR B
 117+ 5CB1 23           	INC HL
 118+ 5CB2 D9           	EXX
 119+ 5CB3 02           	LD (BC), A
 120+ 5CB4
 121+ 5CB4 23           	INC HL
 122+ 5CB5 13           	INC DE
 123+ 5CB6 03           	INC BC
 124+ 5CB7
 125+ 5CB7 08           	EX AF, AF'
 126+ 5CB8 3D           	DEC A
 127+ 5CB9 C2 80 5C     	JP NZ, SHIFT58
 128+ 5CBC C9           	RET
 129+ 5CBD              ; *******************************************************************************************************
 130+ 5CBD
 131+ 5CBD              ; *******************************************************************************************************
 132+ 5CBD              ; routine that shifts one row of characters
 133+ 5CBD              ; contains self-modifying code that is set-up from external function
 134+ 5CBD              ; input HL=pointer to mask data
 135+ 5CBD              ; input HL'=pointer to character data
 136+ 5CBD              ; input DE=output buffer containing background data
 137+ 5CBD              ; input A=number of characters to process
 138+ 5CBD              ; input IX=pointer to structure describing input data
 139+ 5CBD              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 140+ 5CBD              SHIFT_ROW:
 141+ 5CBD F5           	PUSH AF
 142+ 5CBE ED 53 0C 63  		LD (BLIT_TMP1), DE
 143+ 5CC2 E5           		PUSH HL
 144+ 5CC3 CD 06 5D     			CALL .ADDYSHIFT
 145+ 5CC6 E1           		POP HL
 146+ 5CC7 ED 53 0E 63  		LD (BLIT_TMP2), DE ; DE+vertical shift
 147+ 5CCB              .L1:
 148+ 5CCB 3E 08        		LD A, 8
 149+ 5CCD DD 96 02     		SUB (IX+2) ; y shift
 150+ 5CD0              .CALL1:
 151+ 5CD0 CD 00 00     		CALL 0
 152+ 5CD3 DD 7E 02     		LD A, (IX+2); y shift
 153+ 5CD6 B7           		OR A
 154+ 5CD7 28 26        		JR Z, .DONE
 155+ 5CD9 ED 5B 0C 63  		LD DE, (BLIT_TMP1)
 156+ 5CDD E5           		PUSH HL
 157+ 5CDE CD 14 5D     			CALL .DETONEXTROW
 158+ 5CE1 E1           		POP HL
 159+ 5CE2              .CALL2:
 160+ 5CE2 CD 00 00     		CALL 0
 161+ 5CE5 ED 5B 0C 63  		LD DE, (BLIT_TMP1)
 162+ 5CE9 E5           		PUSH HL
 163+ 5CEA CD 0E 5D     			CALL .ADD8
 164+ 5CED E1           		POP HL
 165+ 5CEE ED 53 0C 63  		LD (BLIT_TMP1), DE
 166+ 5CF2 ED 5B 0E 63  		LD DE, (BLIT_TMP2)
 167+ 5CF6 E5           		PUSH HL
 168+ 5CF7 CD 0E 5D     			CALL .ADD8
 169+ 5CFA E1           		POP HL
 170+ 5CFB ED 53 0E 63  		LD (BLIT_TMP2), DE ; DE+vertical shift
 171+ 5CFF              .DONE:
 172+ 5CFF F1           	POP AF
 173+ 5D00 3D           	DEC A
 174+ 5D01 C8           	RET Z
 175+ 5D02 F5           	PUSH AF
 176+ 5D03 C3 CB 5C     	JP .L1
 177+ 5D06              .ADDYSHIFT:
 178+ 5D06 EB           	EX DE, HL
 179+ 5D07 16 00        	LD D, 0
 180+ 5D09 DD 5E 02     	LD E, (IX+2); y shift
 181+ 5D0C 18 0C        	JR .MOVDEBC
 182+ 5D0E              .ADD8:
 183+ 5D0E 21 08 00     	LD HL, 8
 184+ 5D11 C3 1A 5D     	JP .MOVDEBC
 185+ 5D14              .DETONEXTROW:
 186+ 5D14 DD 6E 06     	LD L, (IX+6)
 187+ 5D17 DD 66 07     	LD H, (IX+7) ; bkg add to value
 188+ 5D1A              .MOVDEBC:
 189+ 5D1A 19           	ADD HL, DE
 190+ 5D1B 54           	LD D, H
 191+ 5D1C 5D           	LD E, L
 192+ 5D1D 01 08 00     	LD BC, 8
 193+ 5D20 09           	ADD HL, BC
 194+ 5D21 44           	LD B, H
 195+ 5D22 4D           	LD C, L
 196+ 5D23 C9           	RET
 197+ 5D24              ; *******************************************************************************************************
 198+ 5D24
 199+ 5D24              ; *******************************************************************************************************
 200+ 5D24              ; function rotates mask and character data and applies it to background
 201+ 5D24              ; input IX=pointer to structure describing input data
 202+ 5D24              ; +0  DW horizontal shift count 0-7 (low byte used)
 203+ 5D24              ; +2  DW vertical shift count 0-7 (low byte used)
 204+ 5D24              ; +4  DW background data start;
 205+ 5D24              ; +6  DW background add to value to next row of background data
 206+ 5D24              ; +8  DW mask data start;
 207+ 5D24              ; +10  DW character data start;
 208+ 5D24              ; +12 DW character&mask add to value to next row of data
 209+ 5D24              ; +14 DW columns (low byte used)
 210+ 5D24              ; +16 DW rows (low byte used)
 211+ 5D24              SHIFT_MERGE_CHARACTER:
 212+ 5D24 DD 7E 00     	LD A, (IX) ; shift
 213+ 5D27 FE 05        	CP 5
 214+ 5D29 38 25        	JR C, .RIGHT
 215+ 5D2B              	; shifts 5-7, use rotate towards left 1-3
 216+ 5D2B 21 80 5C     	LD HL, SHIFT58
 217+ 5D2E 22 D1 5C     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 218+ 5D31 22 E3 5C     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 219+ 5D34 D6 05        	SUB 5
 220+ 5D36 28 0D        	JR Z, .L1
 221+ 5D38 87           	ADD A, A
 222+ 5D39 87           	ADD A, A
 223+ 5D3A 67           	LD H, A
 224+ 5D3B 2E 18        	LD L, #18 ; JR opcode
 225+ 5D3D 22 87 5C     	LD (SHIFT58.M1), HL
 226+ 5D40 22 98 5C     	LD (SHIFT58.M2), HL
 227+ 5D43 18 32        	JR .DO
 228+ 5D45              .L1:
 229+ 5D45 21 00 00     	LD HL, 0 ; 2xNOP opcode
 230+ 5D48 22 87 5C     	LD (SHIFT58.M1), HL
 231+ 5D4B 22 98 5C     	LD (SHIFT58.M2), HL
 232+ 5D4E 18 27        	JR .DO
 233+ 5D50              .RIGHT:
 234+ 5D50              	; shifts 0-4, rotate towards right
 235+ 5D50 21 3B 5C     	LD HL, SHIFT04
 236+ 5D53 22 D1 5C     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 237+ 5D56 22 E3 5C     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 238+ 5D59 FE 04        	CP 4
 239+ 5D5B 28 11        	JR Z, .R1
 240+ 5D5D D6 04        	SUB 4
 241+ 5D5F ED 44        	NEG
 242+ 5D61 87           	ADD A, A
 243+ 5D62 87           	ADD A, A
 244+ 5D63 67           	LD H, A
 245+ 5D64 2E 18        	LD L, #18 ; JR opcode
 246+ 5D66 22 42 5C     	LD (SHIFT04.M1), HL
 247+ 5D69 22 57 5C     	LD (SHIFT04.M2), HL
 248+ 5D6C 18 09        	JR .DO
 249+ 5D6E              .R1:
 250+ 5D6E 21 00 00     	LD HL, 0 ; 2xNOP opcode
 251+ 5D71 22 42 5C     	LD (SHIFT04.M1), HL
 252+ 5D74 22 57 5C     	LD (SHIFT04.M2), HL
 253+ 5D77              .DO:
 254+ 5D77 DD 46 10     	LD B, (IX+16) ; rows
 255+ 5D7A DD 6E 08     	LD L, (IX+8)
 256+ 5D7D DD 66 09     	LD H, (IX+9) ; mask data
 257+ 5D80 DD 5E 04     	LD E, (IX+4)
 258+ 5D83 DD 56 05     	LD D, (IX+5) ; background data
 259+ 5D86 D9           	EXX
 260+ 5D87 DD 6E 0A     	LD L, (IX+10)
 261+ 5D8A DD 66 0B     	LD H, (IX+11) ; character data
 262+ 5D8D D9           	EXX
 263+ 5D8E              .LOOP:
 264+ 5D8E C5           	PUSH BC
 265+ 5D8F E5           		PUSH HL
 266+ 5D90 D5           			PUSH DE
 267+ 5D91 D9           				EXX
 268+ 5D92 E5           				PUSH HL
 269+ 5D93 D9           					EXX
 270+ 5D94 DD 7E 0E     					LD A, (IX+14) ; columns
 271+ 5D97              .CALL:
 272+ 5D97 CD BD 5C     					CALL SHIFT_ROW
 273+ 5D9A E1           				POP HL
 274+ 5D9B DD 5E 0C     				LD E, (IX+12)
 275+ 5D9E DD 56 0D     				LD D, (IX+13) ; char data to next row
 276+ 5DA1 19           				ADD HL, DE
 277+ 5DA2 D9           				EXX
 278+ 5DA3 E1           			POP HL
 279+ 5DA4 DD 5E 06     			LD E, (IX+6)
 280+ 5DA7 DD 56 07     			LD D, (IX+7) ; background to next row
 281+ 5DAA 19           			ADD HL, DE
 282+ 5DAB EB           			EX DE, HL
 283+ 5DAC E1           		POP HL
 284+ 5DAD DD 4E 0C     		LD C, (IX+12)
 285+ 5DB0 DD 46 0D     		LD B, (IX+13) ; char data to next row
 286+ 5DB3 09           		ADD HL, BC
 287+ 5DB4 C1           	POP BC
 288+ 5DB5 10 D7        	DJNZ .LOOP
 289+ 5DB7 C9           	RET
 290+ 5DB8              ; *******************************************************************************************************
 291+ 5DB8
 292+ 5DB8              ; *******************************************************************************************************
 293+ 5DB8              ; helper function DE \ 8
 294+ 5DB8              DEdiv8:
 295+ 5DB8 7B           	LD A,E
 296+ 5DB9 CB 2A        	SRA D
 297+ 5DBB CB 1F            RR  A
 298+ 5DBD CB 2A            SRA D
 299+ 5DBF CB 1F            RR  A
 300+ 5DC1 CB 2A            SRA D
 301+ 5DC3 CB 1F            RR  A
 302+ 5DC5 C9           	RET
 303+ 5DC6              ; *******************************************************************************************************
 304+ 5DC6
 305+ 5DC6               IF (0 == 1)
 306+ 5DC6 ~            ; *******************************************************************************************************
 307+ 5DC6 ~            ; function to handle BLIT basic extension through DEFUSR call in RAW format
 308+ 5DC6 ~            ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 309+ 5DC6 ~            ; +2  DW horizontal shift count 0-7 (low byte used)
 310+ 5DC6 ~            ; +4  DW vertical shift count 0-7 (low byte used)
 311+ 5DC6 ~            ; +6  DW background data start;
 312+ 5DC6 ~            ; +8  DW background add to value to next row of background data
 313+ 5DC6 ~            ; +10  DW mask data start;
 314+ 5DC6 ~            ; +12  DW character data start;
 315+ 5DC6 ~            ; +14 DW character&mask add to value to next row of data
 316+ 5DC6 ~            ; +16 DW columns (low byte used)
 317+ 5DC6 ~            ; +18 DW rows (low byte used)
 318+ 5DC6 ~            ; will put ram in page 0 also, page 1 is already there
 319+ 5DC6 ~            ;BLIT_DEFUSR:
 320+ 5DC6 ~            ;	DI
 321+ 5DC6 ~            ;	LD IY, .RET
 322+ 5DC6 ~            ;	JP ENABLE_PAGE0
 323+ 5DC6 ~            ;.RET:
 324+ 5DC6 ~            ;	EI
 325+ 5DC6 ~            ;	INC IX
 326+ 5DC6 ~            ;	INC IX
 327+ 5DC6 ~            ;	CALL SHIFT_MERGE_CHARACTER
 328+ 5DC6 ~            ;
 329+ 5DC6 ~            ;   POP DE
 330+ 5DC6 ~            ;    POP BC
 331+ 5DC6 ~            ;    JP RESTORE_PAGE_INFO
 332+ 5DC6 ~            ; *******************************************************************************************************
 333+ 5DC6 ~
 334+ 5DC6 ~            ; *******************************************************************************************************
 335+ 5DC6 ~            ; function to handle CALL BLIT basic extension in DEFUSR form
 336+ 5DC6 ~            ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 337+ 5DC6 ~            ; +02 x
 338+ 5DC6 ~            ; +04 y
 339+ 5DC6 ~            ; +06 char_data_pointer
 340+ 5DC6 ~            ; +08 mask_data_pointer
 341+ 5DC6 ~            ; +10 width
 342+ 5DC6 ~            ; +12 height
 343+ 5DC6 ~            ; +14 background_pointer
 344+ 5DC6 ~            ; +16 background_width
 345+ 5DC6 ~            ; BLIT ( INT x,
 346+ 5DC6 ~            ;		 INT y,
 347+ 5DC6 ~            ;		 INT char_data_pointer,
 348+ 5DC6 ~            ;		 INT mask_data_pointer,
 349+ 5DC6 ~            ;		 INT width (in characters),
 350+ 5DC6 ~            ;		 INT height (in characters),
 351+ 5DC6 ~            ;		 INT background_pointer (top left),
 352+ 5DC6 ~            ;		 INT background_width (in characters),
 353+ 5DC6 ~            BLIT_DEFUSR:
 354+ 5DC6 ~            	LD E,(IX+2)
 355+ 5DC6 ~            	LD D,(IX+3)
 356+ 5DC6 ~            	LD A,E
 357+ 5DC6 ~            	AND 7
 358+ 5DC6 ~            	LD (BLIT_STRUCT+0),A
 359+ 5DC6 ~            	CALL DEdiv8
 360+ 5DC6 ~            	LD (BLIT_TMP+0),A
 361+ 5DC6 ~            	LD E,(IX+4)
 362+ 5DC6 ~            	LD D,(IX+5)
 363+ 5DC6 ~            	LD A,E
 364+ 5DC6 ~            	AND 7
 365+ 5DC6 ~            	LD (BLIT_STRUCT+2),A
 366+ 5DC6 ~            	CALL DEdiv8
 367+ 5DC6 ~            	LD (BLIT_TMP+1),A
 368+ 5DC6 ~            	LD L,(IX+6)
 369+ 5DC6 ~            	LD H,(IX+7)
 370+ 5DC6 ~            	LD (BLIT_STRUCT+10),HL
 371+ 5DC6 ~            	LD L,(IX+8)
 372+ 5DC6 ~            	LD H,(IX+9)
 373+ 5DC6 ~            	LD (BLIT_STRUCT+8),HL
 374+ 5DC6 ~            	LD A,(IX+10)
 375+ 5DC6 ~            	LD (BLIT_STRUCT+14),A
 376+ 5DC6 ~            	LD A,(IX+12)
 377+ 5DC6 ~            	LD (BLIT_STRUCT+16),A
 378+ 5DC6 ~            	LD L,(IX+14)
 379+ 5DC6 ~            	LD H,(IX+15)
 380+ 5DC6 ~            	LD (BLIT_STRUCT+4),HL
 381+ 5DC6 ~            	;LD A,(IX+16)
 382+ 5DC6 ~            	;LD (BLIT_TMP+2),A
 383+ 5DC6 ~
 384+ 5DC6 ~            	; calculate char&mask add to value
 385+ 5DC6 ~            	LD H,0
 386+ 5DC6 ~            	LD A,(BLIT_STRUCT+14)
 387+ 5DC6 ~            	LD L,A
 388+ 5DC6 ~            	CALL HLx8
 389+ 5DC6 ~            	LD (BLIT_STRUCT+12),HL
 390+ 5DC6 ~            	; calculate background add to value
 391+ 5DC6 ~            	LD H,0
 392+ 5DC6 ~            	LD L,(IX+16)
 393+ 5DC6 ~            	CALL HLx8
 394+ 5DC6 ~            	LD (BLIT_STRUCT+6),HL
 395+ 5DC6 ~            	; calculate pointer to background location
 396+ 5DC6 ~            	LD HL,0
 397+ 5DC6 ~            	LD A,(BLIT_TMP+1)
 398+ 5DC6 ~            	OR A
 399+ 5DC6 ~            	JR Z, .L1
 400+ 5DC6 ~            	LD B,A
 401+ 5DC6 ~            	LD DE,(BLIT_STRUCT+6)
 402+ 5DC6 ~            .L0:
 403+ 5DC6 ~            	ADD HL, DE
 404+ 5DC6 ~            	DJNZ .L0
 405+ 5DC6 ~            .L1:
 406+ 5DC6 ~            	EX DE,HL
 407+ 5DC6 ~            	LD H,0
 408+ 5DC6 ~            	LD A,(BLIT_TMP+0)
 409+ 5DC6 ~            	LD L,A
 410+ 5DC6 ~            	CALL HLx8
 411+ 5DC6 ~            	ADD HL,DE
 412+ 5DC6 ~            	LD DE,(BLIT_STRUCT+4)
 413+ 5DC6 ~            	ADD HL,DE
 414+ 5DC6 ~            	LD (BLIT_STRUCT+4),HL
 415+ 5DC6 ~
 416+ 5DC6 ~            	LD IY, .RET
 417+ 5DC6 ~            	JP ENABLE_PAGE0
 418+ 5DC6 ~            .RET:
 419+ 5DC6 ~            	EI
 420+ 5DC6 ~            	LD IX, BLIT_STRUCT
 421+ 5DC6 ~            	CALL SHIFT_MERGE_CHARACTER
 422+ 5DC6 ~
 423+ 5DC6 ~                POP DE
 424+ 5DC6 ~                POP BC
 425+ 5DC6 ~                JP RESTORE_PAGE_INFO
 426+ 5DC6 ~            ; *******************************************************************************************************
 427+ 5DC6               ENDIF
 428+ 5DC6
 429+ 5DC6               IF (1 == 1)
 430+ 5DC6              ; *******************************************************************************************************
 431+ 5DC6              ; function to handle CALL BLIT basic extension
 432+ 5DC6              ; rotates 1-bit character drawing horizontally with mask and character data and
 433+ 5DC6              ; fuses with background data and applies vertical shift too
 434+ 5DC6              ; in form without pointers
 435+ 5DC6              ; BLIT ( INT x,
 436+ 5DC6              ;		 INT y,
 437+ 5DC6              ;		 INT char_data_pointer,
 438+ 5DC6              ;		 INT mask_data_pointer,
 439+ 5DC6              ;		 INT width (in characters),
 440+ 5DC6              ;		 INT height (in characters),
 441+ 5DC6              ;		 INT background_pointer (top left),
 442+ 5DC6              ;		 INT background_width (in characters),
 443+ 5DC6              ; will put ram in page 0 also, page 1 is already there
 444+ 5DC6              BLIT:
 445+ 5DC6              	; opening (
 446+ 5DC6 CD 2B 66     	CALL CHKCHAR
 447+ 5DC9 28           	DB '('
 448+ 5DCA              	; get x coordinate
 449+ 5DCA DD 21 2F 54  	LD IX, FRMQNT
 450+ 5DCE CD 59 01     	CALL CALBAS
 451+ 5DD1 7B           	LD A, E
 452+ 5DD2 E6 07        	AND 7
 453+ 5DD4 32 10 63     	LD (BLIT_STRUCT+0), A
 454+ 5DD7 CD B8 5D     	CALL DEdiv8
 455+ 5DDA 32 0C 63     	LD (BLIT_TMP+0),A
 456+ 5DDD              	; comma
 457+ 5DDD CD 2B 66     	CALL CHKCHAR
 458+ 5DE0 2C           	DB ','
 459+ 5DE1              	; get y coordinate
 460+ 5DE1 DD 21 2F 54  	LD IX, FRMQNT
 461+ 5DE5 CD 59 01     	CALL CALBAS
 462+ 5DE8 7B           	LD A, E
 463+ 5DE9 E6 07        	AND 7
 464+ 5DEB 32 12 63     	LD (BLIT_STRUCT+2), A
 465+ 5DEE CD B8 5D     	CALL DEdiv8
 466+ 5DF1 32 0D 63     	LD (BLIT_TMP+1),A
 467+ 5DF4              	; comma
 468+ 5DF4 CD 2B 66     	CALL CHKCHAR
 469+ 5DF7 2C           	DB ','
 470+ 5DF8              	; get char data pointer
 471+ 5DF8 DD 21 2F 54  	LD IX, FRMQNT
 472+ 5DFC CD 59 01     	CALL CALBAS
 473+ 5DFF ED 53 1A 63  	LD (BLIT_STRUCT+10), DE
 474+ 5E03              	; comma
 475+ 5E03 CD 2B 66     	CALL CHKCHAR
 476+ 5E06 2C           	DB ','
 477+ 5E07              	; get mask data pointer
 478+ 5E07 DD 21 2F 54  	LD IX, FRMQNT
 479+ 5E0B CD 59 01     	CALL CALBAS
 480+ 5E0E ED 53 18 63  	LD (BLIT_STRUCT+8), DE
 481+ 5E12              	; comma
 482+ 5E12 CD 2B 66     	CALL CHKCHAR
 483+ 5E15 2C           	DB ','
 484+ 5E16              	; get width
 485+ 5E16 DD 21 2F 54  	LD IX, FRMQNT
 486+ 5E1A CD 59 01     	CALL CALBAS
 487+ 5E1D 7B           	LD A, E
 488+ 5E1E 32 1E 63     	LD (BLIT_STRUCT+14), A
 489+ 5E21              	; comma
 490+ 5E21 CD 2B 66     	CALL CHKCHAR
 491+ 5E24 2C           	DB ','
 492+ 5E25              	; get height
 493+ 5E25 DD 21 2F 54  	LD IX, FRMQNT
 494+ 5E29 CD 59 01     	CALL CALBAS
 495+ 5E2C 7B           	LD A, E
 496+ 5E2D 32 20 63     	LD (BLIT_STRUCT+16), A
 497+ 5E30              	; comma
 498+ 5E30 CD 2B 66     	CALL CHKCHAR
 499+ 5E33 2C           	DB ','
 500+ 5E34              	; get background pointer
 501+ 5E34 DD 21 2F 54  	LD IX, FRMQNT
 502+ 5E38 CD 59 01     	CALL CALBAS
 503+ 5E3B ED 53 14 63  	LD (BLIT_STRUCT+4), DE
 504+ 5E3F              	; comma
 505+ 5E3F CD 2B 66     	CALL CHKCHAR
 506+ 5E42 2C           	DB ','
 507+ 5E43              	; get background width
 508+ 5E43 DD 21 2F 54  	LD IX, FRMQNT
 509+ 5E47 CD 59 01     	CALL CALBAS
 510+ 5E4A 7B           	LD A, E
 511+ 5E4B 32 0E 63     	LD (BLIT_TMP+2), A
 512+ 5E4E              	; ending )
 513+ 5E4E CD 2B 66     	CALL CHKCHAR
 514+ 5E51 29           	DB ')'
 515+ 5E52
 516+ 5E52 E5           	PUSH HL ; save position in BASIC buffer
 517+ 5E53
 518+ 5E53              	; calculate char&mask add to value
 519+ 5E53 26 00        	LD H, 0
 520+ 5E55 3A 1E 63     	LD A, (BLIT_STRUCT+14)
 521+ 5E58 6F           	LD L, A
 522+ 5E59 CD 18 65     	CALL HLx8
 523+ 5E5C 22 1C 63     	LD (BLIT_STRUCT+12), HL
 524+ 5E5F              	; calculate background add to value
 525+ 5E5F 26 00        	LD H, 0
 526+ 5E61 3A 0E 63     	LD A, (BLIT_TMP+2)
 527+ 5E64 6F           	LD L, A
 528+ 5E65 CD 18 65     	CALL HLx8
 529+ 5E68 22 16 63     	LD (BLIT_STRUCT+6), HL
 530+ 5E6B              	; calculate pointer to background location
 531+ 5E6B 21 00 00     	LD HL, 0
 532+ 5E6E 3A 0D 63     	LD A,(BLIT_TMP+1)
 533+ 5E71 B7           	OR A
 534+ 5E72 28 08        	JR Z, .L1
 535+ 5E74 47           	LD B,A
 536+ 5E75 ED 5B 16 63  	LD DE,(BLIT_STRUCT+6)
 537+ 5E79              .L0:
 538+ 5E79 19           	ADD HL, DE
 539+ 5E7A 10 FD        	DJNZ .L0
 540+ 5E7C              .L1:
 541+ 5E7C EB           	EX DE,HL
 542+ 5E7D 26 00        	LD H,0
 543+ 5E7F 3A 0C 63     	LD A,(BLIT_TMP+0)
 544+ 5E82 6F           	LD L,A
 545+ 5E83 CD 18 65     	CALL HLx8
 546+ 5E86 19           	ADD HL,DE
 547+ 5E87 ED 5B 14 63  	LD DE,(BLIT_STRUCT+4)
 548+ 5E8B 19           	ADD HL,DE
 549+ 5E8C 22 14 63     	LD (BLIT_STRUCT+4),HL
 550+ 5E8F
 551+ 5E8F FD 21 96 5E  	LD IY, .RET
 552+ 5E93 C3 DC 65     	JP ENABLE_PAGE0
 553+ 5E96              .RET:
 554+ 5E96 FB           	EI
 555+ 5E97 DD 21 10 63  	LD IX, BLIT_STRUCT
 556+ 5E9B CD 24 5D     	CALL SHIFT_MERGE_CHARACTER
 557+ 5E9E
 558+ 5E9E D1               POP DE
 559+ 5E9F C1               POP BC
 560+ 5EA0 CD 53 65         CALL RESTORE_PAGE_INFO
 561+ 5EA3
 562+ 5EA3 E1           	POP HL
 563+ 5EA4 C9           	RET
 564+ 5EA5              ; *******************************************************************************************************
 565+ 5EA5               ENDIF
# file closed: asm\BLIT.asm
 159  5EA5               ENDIF
 160  5EA5
 161  5EA5               IF (TILE_CMDS == 1)
 162  5EA5               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
   1+ 5EA5              ; *******************************************************************************************************
   2+ 5EA5              ; generic function to implement tiling
   3+ 5EA5              ; should be modified to call appropriate function for memory or vram
   4+ 5EA5              ; input IX=pointer to following structure
   5+ 5EA5              ; +00 tile_data_ptr
   6+ 5EA5              ; +02 tile_rows
   7+ 5EA5              ; +04 tile_columns
   8+ 5EA5              ; +06 destination_address
   9+ 5EA5              ; +08 dest_to_next_row_add_to_value
  10+ 5EA5              ; +10 num_horizontal_tiles
  11+ 5EA5              ; +12 num_vertical_tiles
  12+ 5EA5              ; modifies AF, BC, DE, HL
  13+ 5EA5              TILE:
  14+ 5EA5 DD 6E 06     	LD L, (IX+6)
  15+ 5EA8 DD 66 07     	LD H, (IX+7) ; destination address
  16+ 5EAB 22 0C 63     	LD (TILETMP1), HL
  17+ 5EAE DD 46 0C     	LD B, (IX+12) ; vertical tile number
  18+ 5EB1              .L1:
  19+ 5EB1 C5           	PUSH BC
  20+ 5EB2 DD 6E 00     		LD L, (IX+0)
  21+ 5EB5 DD 66 01     		LD H, (IX+1) ; tile address
  22+ 5EB8 22 0E 63     		LD (TILETMP2), HL
  23+ 5EBB DD 46 02     		LD B, (IX+2) ; tile rows
  24+ 5EBE              .L2:
  25+ 5EBE C5           		PUSH BC
  26+ 5EBF CD 00 00     .CALL1:		CALL 0
  27+ 5EC2 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
  28+ 5EC5              .L3:
  29+ 5EC5 C5           			PUSH BC
  30+ 5EC6 2A 0E 63     				LD HL, (TILETMP2)
  31+ 5EC9 DD 46 04     				LD B, (IX+4) ; tile columns
  32+ 5ECC              .L4:
  33+ 5ECC C5           				PUSH BC
  34+ 5ECD              .CALL2:
  35+ 5ECD CD 00 00     					CALL 0
  36+ 5ED0 C1           				POP BC
  37+ 5ED1 10 F9        				DJNZ .L4
  38+ 5ED3 C1           			POP BC
  39+ 5ED4 10 EF        			DJNZ .L3
  40+ 5ED6 22 0E 63     			LD (TILETMP2), HL
  41+ 5ED9 2A 0C 63     			LD HL, (TILETMP1)
  42+ 5EDC DD 5E 08     			LD E, (IX+8)
  43+ 5EDF DD 56 09     			LD D, (IX+9) ; add to value for dest next row
  44+ 5EE2 19           			ADD HL, DE
  45+ 5EE3 22 0C 63     			LD (TILETMP1), HL
  46+ 5EE6 C1           		POP BC
  47+ 5EE7 10 D5        		DJNZ .L2
  48+ 5EE9 C1           	POP BC
  49+ 5EEA 10 C5        	DJNZ .L1
  50+ 5EEC C9           	RET
  51+ 5EED              ; *******************************************************************************************************
  52+ 5EED
  53+ 5EED               IF (0 == 1)
  54+ 5EED ~            ; *******************************************************************************************************
  55+ 5EED ~            ; same as TILERAM but for DEFUSR approach
  56+ 5EED ~            ; input IX=pointer to input array, real data from +2
  57+ 5EED ~            ; +02 = tile data pointer
  58+ 5EED ~            ; +04 = tile columns
  59+ 5EED ~            ; +06 = tile rows
  60+ 5EED ~            ; +08 = destination pointer
  61+ 5EED ~            ; +10 = destination columns
  62+ 5EED ~            ; +12 = destination rows
  63+ 5EED ~            ; +14 = destination begin column
  64+ 5EED ~            ; +16 = destination begin row
  65+ 5EED ~            ; +18 = number of tiles horizontally
  66+ 5EED ~            ; +20 = number of tiles vertically
  67+ 5EED ~            ; *******************************************************************************************************
  68+ 5EED ~            TILERAM_DEFUSR:
  69+ 5EED ~            	; tile data pointer
  70+ 5EED ~            	LD L,(IX+2)
  71+ 5EED ~            	LD H,(IX+3)
  72+ 5EED ~            	LD (BLIT_STRUCT+0),HL
  73+ 5EED ~            	; tile columns
  74+ 5EED ~            	LD L,(IX+4)
  75+ 5EED ~            	LD H,(IX+5)
  76+ 5EED ~            	LD (BLIT_STRUCT+4),HL
  77+ 5EED ~            	; tile rows
  78+ 5EED ~            	LD L,(IX+6)
  79+ 5EED ~            	LD H,(IX+7)
  80+ 5EED ~            	LD (BLIT_STRUCT+2),HL
  81+ 5EED ~            	; destintion pointer
  82+ 5EED ~            	LD L,(IX+8)
  83+ 5EED ~            	LD H,(IX+9)
  84+ 5EED ~            	LD (BLIT_STRUCT+6),HL
  85+ 5EED ~            	; destination columns
  86+ 5EED ~            	LD A,(IX+10)
  87+ 5EED ~            	LD (BLIT_TMP+0),A
  88+ 5EED ~            	; destination rows
  89+ 5EED ~            	LD A,(IX+12)
  90+ 5EED ~            	LD (BLIT_TMP+1),A
  91+ 5EED ~            	; destination begin column
  92+ 5EED ~            	LD A,(IX+14)
  93+ 5EED ~            	LD (BLIT_TMP+2),A
  94+ 5EED ~            	; destination begin row
  95+ 5EED ~            	LD A,(IX+16)
  96+ 5EED ~            	LD (BLIT_TMP+3),A
  97+ 5EED ~            	; number of tiles horizontally
  98+ 5EED ~            	LD L,(IX+18)
  99+ 5EED ~            	LD H,(IX+19)
 100+ 5EED ~            	LD (BLIT_STRUCT+10),HL
 101+ 5EED ~            	; number of tiles vertically
 102+ 5EED ~            	LD L,(IX+20)
 103+ 5EED ~            	LD H,(IX+21)
 104+ 5EED ~            	LD (BLIT_STRUCT+12),HL
 105+ 5EED ~             IF (BASIC_EXTENSION == 1) ; otherwise we just continue with code below
 106+ 5EED ~            	JP TILERAM.COMMON
 107+ 5EED ~             ENDIF
 108+ 5EED               ENDIF
 109+ 5EED
 110+ 5EED              ; *******************************************************************************************************
 111+ 5EED              ; function to handle CALL TILERAM basic extension
 112+ 5EED              ; fills memory with tiles
 113+ 5EED              ; TILERAM ( INT tile_data_pointer,
 114+ 5EED              ;			INT tile_columns,
 115+ 5EED              ;			INT tile_rows,
 116+ 5EED              ;			INT destination_pointer,
 117+ 5EED              ;			INT destination_columns,
 118+ 5EED              ;			INT destination_rows,
 119+ 5EED              ;			INT destination_begin_column,
 120+ 5EED              ;			INT destination_begin_row,
 121+ 5EED              ;			INT number_of_tiles_horizontally,
 122+ 5EED              ;			INT	number_of_tiles_vertically )
 123+ 5EED              ; will put ram in page 0 also, page 1 is already there
 124+ 5EED              TILERAM:
 125+ 5EED               IF (1 == 1)
 126+ 5EED              	; opening (
 127+ 5EED CD 2B 66     	CALL CHKCHAR
 128+ 5EF0 28           	DB '('
 129+ 5EF1              	; get tile data pointer coordinate
 130+ 5EF1 DD 21 2F 54  	LD IX, FRMQNT
 131+ 5EF5 CD 59 01     	CALL CALBAS
 132+ 5EF8 ED 53 10 63  	LD (BLIT_STRUCT+0), DE
 133+ 5EFC              	; comma
 134+ 5EFC CD 2B 66     	CALL CHKCHAR
 135+ 5EFF 2C           	DB ','
 136+ 5F00              	; get tile columns
 137+ 5F00 DD 21 2F 54  	LD IX, FRMQNT
 138+ 5F04 CD 59 01     	CALL CALBAS
 139+ 5F07 ED 53 14 63  	LD (BLIT_STRUCT+4), DE
 140+ 5F0B              	; comma
 141+ 5F0B CD 2B 66     	CALL CHKCHAR
 142+ 5F0E 2C           	DB ','
 143+ 5F0F              	; get tile columns
 144+ 5F0F DD 21 2F 54  	LD IX, FRMQNT
 145+ 5F13 CD 59 01     	CALL CALBAS
 146+ 5F16 ED 53 12 63  	LD (BLIT_STRUCT+2), DE
 147+ 5F1A              	; comma
 148+ 5F1A CD 2B 66     	CALL CHKCHAR
 149+ 5F1D 2C           	DB ','
 150+ 5F1E              	; get destintion pointer
 151+ 5F1E DD 21 2F 54  	LD IX, FRMQNT
 152+ 5F22 CD 59 01     	CALL CALBAS
 153+ 5F25 ED 53 16 63  	LD (BLIT_STRUCT+6), DE
 154+ 5F29              	; comma
 155+ 5F29 CD 2B 66     	CALL CHKCHAR
 156+ 5F2C 2C           	DB ','
 157+ 5F2D              	; get destination columns
 158+ 5F2D DD 21 2F 54  	LD IX, FRMQNT
 159+ 5F31 CD 59 01     	CALL CALBAS
 160+ 5F34 7B           	LD A, E
 161+ 5F35 32 0C 63     	LD (BLIT_TMP+0), A
 162+ 5F38              	; comma
 163+ 5F38 CD 2B 66     	CALL CHKCHAR
 164+ 5F3B 2C           	DB ','
 165+ 5F3C              	; get destination rows
 166+ 5F3C DD 21 2F 54  	LD IX, FRMQNT
 167+ 5F40 CD 59 01     	CALL CALBAS
 168+ 5F43 7B           	LD A, E
 169+ 5F44 32 0D 63     	LD (BLIT_TMP+1), A
 170+ 5F47              	; comma
 171+ 5F47 CD 2B 66     	CALL CHKCHAR
 172+ 5F4A 2C           	DB ','
 173+ 5F4B              	; get destination begin column
 174+ 5F4B DD 21 2F 54  	LD IX, FRMQNT
 175+ 5F4F CD 59 01     	CALL CALBAS
 176+ 5F52 7B           	LD A, E
 177+ 5F53 32 0E 63     	LD (BLIT_TMP+2), A
 178+ 5F56              	; comma
 179+ 5F56 CD 2B 66     	CALL CHKCHAR
 180+ 5F59 2C           	DB ','
 181+ 5F5A              	; get destination begin row
 182+ 5F5A DD 21 2F 54  	LD IX, FRMQNT
 183+ 5F5E CD 59 01     	CALL CALBAS
 184+ 5F61 7B           	LD A, E
 185+ 5F62 32 0F 63     	LD (BLIT_TMP+3), A
 186+ 5F65              	; comma
 187+ 5F65 CD 2B 66     	CALL CHKCHAR
 188+ 5F68 2C           	DB ','
 189+ 5F69              	; get number of tiles horizontally
 190+ 5F69 DD 21 2F 54  	LD IX, FRMQNT
 191+ 5F6D CD 59 01     	CALL CALBAS
 192+ 5F70 ED 53 1A 63  	LD (BLIT_STRUCT+10), DE
 193+ 5F74              	; comma
 194+ 5F74 CD 2B 66     	CALL CHKCHAR
 195+ 5F77 2C           	DB ','
 196+ 5F78              	; get number of tiles vertically
 197+ 5F78 DD 21 2F 54  	LD IX, FRMQNT
 198+ 5F7C CD 59 01     	CALL CALBAS
 199+ 5F7F ED 53 1C 63  	LD (BLIT_STRUCT+12), DE
 200+ 5F83              	; ending )
 201+ 5F83 CD 2B 66     	CALL CHKCHAR
 202+ 5F86 29           	DB ')'
 203+ 5F87               ENDIF
 204+ 5F87              .COMMON:
 205+ 5F87 E5           	PUSH HL ; save position in BASIC buffer
 206+ 5F88
 207+ 5F88              	; calculate destination add to value
 208+ 5F88 26 00        	LD H, 0
 209+ 5F8A 3A 0C 63     	LD A, (BLIT_TMP+0)
 210+ 5F8D 6F           	LD L, A
 211+ 5F8E CD 18 65     	CALL HLx8
 212+ 5F91 22 18 63     	LD (BLIT_STRUCT+8), HL
 213+ 5F94              	; calculate pointer to background location
 214+ 5F94 21 00 00     	LD HL, 0
 215+ 5F97 3A 0F 63     	LD A,(BLIT_TMP+3)
 216+ 5F9A B7           	OR A
 217+ 5F9B 28 08        	JR Z, .L1
 218+ 5F9D 47           	LD B,A
 219+ 5F9E ED 5B 18 63  	LD DE,(BLIT_STRUCT+8)
 220+ 5FA2              .L0:
 221+ 5FA2 19           	ADD HL, DE
 222+ 5FA3 10 FD        	DJNZ .L0
 223+ 5FA5              .L1:
 224+ 5FA5 EB           	EX DE,HL
 225+ 5FA6 26 00        	LD H,0
 226+ 5FA8 3A 0E 63     	LD A,(BLIT_TMP+2)
 227+ 5FAB 6F           	LD L,A
 228+ 5FAC CD 18 65     	CALL HLx8
 229+ 5FAF 19           	ADD HL,DE
 230+ 5FB0 ED 5B 16 63  	LD DE,(BLIT_STRUCT+6)
 231+ 5FB4 19           	ADD HL,DE
 232+ 5FB5 22 16 63     	LD (BLIT_STRUCT+6),HL
 233+ 5FB8 FD 21 BF 5F  	LD IY, .RET
 234+ 5FBC C3 DC 65     	JP ENABLE_PAGE0
 235+ 5FBF              .RET:
 236+ 5FBF FB           	EI
 237+ 5FC0              	; set RAM functions to call
 238+ 5FC0 21 DA 5F     	LD HL, .TILECOPY
 239+ 5FC3 22 CE 5E     	LD (TILE.CALL2+1), HL
 240+ 5FC6 21 EB 5F     	LD HL, .SETDESTROW
 241+ 5FC9 22 C0 5E     	LD (TILE.CALL1+1), HL
 242+ 5FCC DD 21 10 63  	LD IX,BLIT_STRUCT
 243+ 5FD0 CD A5 5E     	CALL TILE
 244+ 5FD3
 245+ 5FD3 D1               POP DE
 246+ 5FD4 C1               POP BC
 247+ 5FD5 CD 53 65         CALL RESTORE_PAGE_INFO
 248+ 5FD8
 249+ 5FD8 E1           	POP HL
 250+ 5FD9 C9           	RET
 251+ 5FDA              .TILECOPY:
 252+ 5FDA ED A0       > LDI
 252+ 5FDC ED A0       > LDI
 252+ 5FDE ED A0       > LDI
 252+ 5FE0 ED A0       > LDI
 252+ 5FE2 ED A0       > LDI
 252+ 5FE4 ED A0       > LDI
 252+ 5FE6 ED A0       > LDI
 252+ 5FE8 ED A0       > LDI
 253+ 5FEA C9           	RET
 254+ 5FEB              .SETDESTROW:
 255+ 5FEB ED 5B 0C 63  	LD DE, (TILETMP1)
 256+ 5FEF C9           	RET
 257+ 5FF0              ; *******************************************************************************************************
 258+ 5FF0
 259+ 5FF0               IF (0 == 1)
 260+ 5FF0 ~            ; *******************************************************************************************************
 261+ 5FF0 ~            ; same as TILEVRM but for DEFUSR approach
 262+ 5FF0 ~            ; input IX=pointer to input array, real data from +2
 263+ 5FF0 ~            ; +02 = tile data pointer
 264+ 5FF0 ~            ; +04 = tile columns
 265+ 5FF0 ~            ; +06 = tile rows
 266+ 5FF0 ~            ; +08 = destination begin column
 267+ 5FF0 ~            ; +10 = destination begin row
 268+ 5FF0 ~            ; +12 = number of tiles horizontally
 269+ 5FF0 ~            ; +14 = number of tiles vertically
 270+ 5FF0 ~            ; *******************************************************************************************************
 271+ 5FF0 ~            TILEVRM_DEFUSR:
 272+ 5FF0 ~            	; tile data pointer
 273+ 5FF0 ~            	LD L,(IX+2)
 274+ 5FF0 ~            	LD H,(IX+3)
 275+ 5FF0 ~            	LD (BLIT_STRUCT+0),HL
 276+ 5FF0 ~            	; tile columns
 277+ 5FF0 ~            	LD L,(IX+4)
 278+ 5FF0 ~            	LD H,(IX+5)
 279+ 5FF0 ~            	LD (BLIT_STRUCT+4),HL
 280+ 5FF0 ~            	; tile rows
 281+ 5FF0 ~            	LD L,(IX+6)
 282+ 5FF0 ~            	LD H,(IX+7)
 283+ 5FF0 ~            	LD (BLIT_STRUCT+2),HL
 284+ 5FF0 ~            	; destination begin column
 285+ 5FF0 ~            	LD A,(IX+8)
 286+ 5FF0 ~            	LD (BLIT_TMP+2),A
 287+ 5FF0 ~            	; destination begin row
 288+ 5FF0 ~            	LD A,(IX+10)
 289+ 5FF0 ~            	LD (BLIT_TMP+3),A
 290+ 5FF0 ~            	; number of tiles horizontally
 291+ 5FF0 ~            	LD L,(IX+12)
 292+ 5FF0 ~            	LD H,(IX+13)
 293+ 5FF0 ~            	LD (BLIT_STRUCT+10),HL
 294+ 5FF0 ~            	; number of tiles vertically
 295+ 5FF0 ~            	LD L,(IX+14)
 296+ 5FF0 ~            	LD H,(IX+15)
 297+ 5FF0 ~            	LD (BLIT_STRUCT+12),HL
 298+ 5FF0 ~             IF (BASIC_EXTENSION == 1) ; otherwise we just continue with code below
 299+ 5FF0 ~            	JP TILEVRM.COMMON
 300+ 5FF0 ~             ENDIF
 301+ 5FF0               ENDIF
 302+ 5FF0
 303+ 5FF0              ; *******************************************************************************************************
 304+ 5FF0              ; function to handle CALL TILEVRM basic extension
 305+ 5FF0              ; fills vram with tiles
 306+ 5FF0              ; TILEVRM ( INT tile_data_pointer,
 307+ 5FF0              ;			INT tile_columns,
 308+ 5FF0              ;			INT tile_rows,
 309+ 5FF0              ;			INT destination_begin_column,
 310+ 5FF0              ;			INT destination_begin_row,
 311+ 5FF0              ;			INT number_of_tiles_horizontally,
 312+ 5FF0              ;			INT	number_of_tiles_vertically )
 313+ 5FF0              ; will put ram in page 0 also, page 1 is already there
 314+ 5FF0              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
 315+ 5FF0              TILEVRM:
 316+ 5FF0               IF (1 == 1)
 317+ 5FF0              	; opening (
 318+ 5FF0 CD 2B 66     	CALL CHKCHAR
 319+ 5FF3 28           	DB '('
 320+ 5FF4              	; get tile data pointer coordinate
 321+ 5FF4 DD 21 2F 54  	LD IX, FRMQNT
 322+ 5FF8 CD 59 01     	CALL CALBAS
 323+ 5FFB ED 53 10 63  	LD (BLIT_STRUCT+0), DE
 324+ 5FFF              	; comma
 325+ 5FFF CD 2B 66     	CALL CHKCHAR
 326+ 6002 2C           	DB ','
 327+ 6003              	; get tile columns
 328+ 6003 DD 21 2F 54  	LD IX, FRMQNT
 329+ 6007 CD 59 01     	CALL CALBAS
 330+ 600A ED 53 14 63  	LD (BLIT_STRUCT+4), DE
 331+ 600E              	; comma
 332+ 600E CD 2B 66     	CALL CHKCHAR
 333+ 6011 2C           	DB ','
 334+ 6012              	; get tile columns
 335+ 6012 DD 21 2F 54  	LD IX, FRMQNT
 336+ 6016 CD 59 01     	CALL CALBAS
 337+ 6019 ED 53 12 63  	LD (BLIT_STRUCT+2), DE
 338+ 601D              	; comma
 339+ 601D CD 2B 66     	CALL CHKCHAR
 340+ 6020 2C           	DB ','
 341+ 6021              	; get destination begin column
 342+ 6021 DD 21 2F 54  	LD IX, FRMQNT
 343+ 6025 CD 59 01     	CALL CALBAS
 344+ 6028 7B           	LD A, E
 345+ 6029 32 0E 63     	LD (BLIT_TMP+2), A
 346+ 602C              	; comma
 347+ 602C CD 2B 66     	CALL CHKCHAR
 348+ 602F 2C           	DB ','
 349+ 6030              	; get destination begin row
 350+ 6030 DD 21 2F 54  	LD IX, FRMQNT
 351+ 6034 CD 59 01     	CALL CALBAS
 352+ 6037 7B           	LD A, E
 353+ 6038 32 0F 63     	LD (BLIT_TMP+3), A
 354+ 603B              	; comma
 355+ 603B CD 2B 66     	CALL CHKCHAR
 356+ 603E 2C           	DB ','
 357+ 603F              	; get number of tiles horizontally
 358+ 603F DD 21 2F 54  	LD IX, FRMQNT
 359+ 6043 CD 59 01     	CALL CALBAS
 360+ 6046 ED 53 1A 63  	LD (BLIT_STRUCT+10), DE
 361+ 604A              	; comma
 362+ 604A CD 2B 66     	CALL CHKCHAR
 363+ 604D 2C           	DB ','
 364+ 604E              	; get number of tiles vertically
 365+ 604E DD 21 2F 54  	LD IX, FRMQNT
 366+ 6052 CD 59 01     	CALL CALBAS
 367+ 6055 ED 53 1C 63  	LD (BLIT_STRUCT+12), DE
 368+ 6059              	; ending )
 369+ 6059 CD 2B 66     	CALL CHKCHAR
 370+ 605C 29           	DB ')'
 371+ 605D               ENDIF
 372+ 605D
 373+ 605D              .COMMON:
 374+ 605D E5           	PUSH HL ; save position in BASIC buffer
 375+ 605E
 376+ 605E              	; calculate destination add to value
 377+ 605E 21 00 01     	LD HL, 256
 378+ 6061 22 18 63     	LD (BLIT_STRUCT+8), HL
 379+ 6064              	; calculate pointer to background location
 380+ 6064 3A 0F 63     	LD A,(BLIT_TMP+3)
 381+ 6067 67           	LD H,A
 382+ 6068 2E 00        	LD L,0
 383+ 606A EB           	EX DE,HL
 384+ 606B 26 00        	LD H,0
 385+ 606D 3A 0E 63     	LD A,(BLIT_TMP+2)
 386+ 6070 6F           	LD L,A
 387+ 6071 CD 18 65     	CALL HLx8
 388+ 6074 19           	ADD HL,DE
 389+ 6075 ED 5B CB F3  	LD DE,(GRPCGP)
 390+ 6079 19           	ADD HL,DE
 391+ 607A 22 16 63     	LD (BLIT_STRUCT+6),HL
 392+ 607D FD 21 84 60  	LD IY, .RET
 393+ 6081 C3 DC 65     	JP ENABLE_PAGE0
 394+ 6084              .RET:
 395+ 6084 FB           	EI
 396+ 6085              	; set RAM functions to call
 397+ 6085 21 9F 60     	LD HL, .TILECOPY
 398+ 6088 22 CE 5E     	LD (TILE.CALL2+1), HL
 399+ 608B 21 A5 60     	LD HL, .SETDESTROW
 400+ 608E 22 C0 5E     	LD (TILE.CALL1+1), HL
 401+ 6091 DD 21 10 63  	LD IX,BLIT_STRUCT
 402+ 6095 CD A5 5E     	CALL TILE
 403+ 6098
 404+ 6098 D1               POP DE
 405+ 6099 C1               POP BC
 406+ 609A CD 53 65         CALL RESTORE_PAGE_INFO
 407+ 609D
 408+ 609D E1           	POP HL
 409+ 609E C9           	RET
 410+ 609F              .TILECOPY:
 411+ 609F 01 98 08     	LD BC, #0898
 412+ 60A2 C3 10 65     	JP BBYTECOPY_NO_C
 413+ 60A5              .SETDESTROW:
 414+ 60A5 2A 0C 63     	LD HL, (TILETMP1)
 415+ 60A8 F3           	DI
 416+ 60A9 CD 03 65     	CALL SETWRT_LOCAL
 417+ 60AC FB           	EI
 418+ 60AD C9           	RET
 419+ 60AE              ; *******************************************************************************************************
 420+ 60AE
# file closed: asm\TILE.asm
 163  60AE               ENDIF
 164  60AE
 165  60AE               IF (COLL_CMD == 1)
 166  60AE               INCLUDE "COLLISION.asm"
# file opened: asm\COLLISION.asm
   1+ 60AE              ; generic collision checking routines
   2+ 60AE              ; in BASIC we use rectangle structure array DIM R%(7,n) of the format
   3+ 60AE              ; R%(0,n) is active flag, <>0 active / 0 skipped in checks
   4+ 60AE              ; R%(1,n) is either upper left x coordinate or sprite id (0-31) depending on R(7,n)
   5+ 60AE              ; R%(2,n) is either upper left y coordinate or unused depending on R(7,n)
   6+ 60AE              ; R%(3,n) x offset where rectangle begins
   7+ 60AE              ; R%(4,n) y offset where rectangle begins
   8+ 60AE              ; R%(5,n) is width
   9+ 60AE              ; R%(6,n) is height
  10+ 60AE              ; R%(7,0) is type, 0=generic where R%(1,0) contains x coordinate
  11+ 60AE              ;                  <>0 sprite where R%(1,0) contains sprite id
  12+ 60AE              ; for type sprite, upper left coordinates are taken from sprite attribute array
  13+ 60AE
  14+ 60AE              ; ************************************************************************************************
  15+ 60AE              ; quick test if HL<=DE<=HL+BC
  16+ 60AE              ; input BC=width, DE=x, HL=min
  17+ 60AE              ; if not true flag C set
  18+ 60AE              ; modifies AF
  19+ 60AE              GENERIC_INNER_CHECK:
  20+ 60AE E5               PUSH HL
  21+ 60AF D5               PUSH DE
  22+ 60B0 EB               EX DE,HL
  23+ 60B1 A7               AND A
  24+ 60B2 ED 52            SBC HL, DE
  25+ 60B4 FA C2 60         JP M, .GENERIC_INNER_CHECK_NOT
  26+ 60B7 A7               AND A
  27+ 60B8 ED 42            SBC HL, BC
  28+ 60BA 28 03            JR Z, .L2
  29+ 60BC F2 C2 60         JP P, .GENERIC_INNER_CHECK_NOT
  30+ 60BF              .L2:
  31+ 60BF A7               AND A
  32+ 60C0 18 01            JR .EXIT
  33+ 60C2              .GENERIC_INNER_CHECK_NOT:
  34+ 60C2 37               SCF
  35+ 60C3              .EXIT:
  36+ 60C3 D1               POP DE
  37+ 60C4 E1               POP HL
  38+ 60C5 C9               RET
  39+ 60C6              ; ************************************************************************************************
  40+ 60C6
  41+ 60C6              ; ************************************************************************************************
  42+ 60C6              ; function to check if rectangles are overlapping
  43+ 60C6              ; input IX=IY=pointer to struct
  44+ 60C6              ;  +00 active flag
  45+ 60C6              ;  +02 x coordinate
  46+ 60C6              ;  +04 y coordinate
  47+ 60C6              ;  +06 x offset where rectangle begins
  48+ 60C6              ;  +08 y offset where rectangle begins
  49+ 60C6              ;  +10 width
  50+ 60C6              ;  +12 height
  51+ 60C6              ; where IY is used to read +2 and +4, and IX to read +6, +8, +10 and +12
  52+ 60C6              ; this is a hack to allow location being taken from sprite attributes table
  53+ 60C6              ; input BLIT_STRUCT data
  54+ 60C6              ;  +00 x coordinate
  55+ 60C6              ;  +02 y coordinate
  56+ 60C6              ;  +04 width
  57+ 60C6              ;  +06 height
  58+ 60C6              ; returns CF=1 if not overlapping, CF=0 if overlapping
  59+ 60C6              RECTANGLE_OVERLAP_CHECK:
  60+ 60C6                  ; first check which rectangle is higher
  61+ 60C6 DD 6E 0C         LD L,(IX+12)
  62+ 60C9 DD 66 0D         LD H,(IX+13)
  63+ 60CC ED 5B 16 63      LD DE,(BLIT_STRUCT+6)
  64+ 60D0 A7               AND A
  65+ 60D1 ED 52            SBC HL,DE
  66+ 60D3 FD 6E 04         LD L,(IY+4)
  67+ 60D6 FD 66 05         LD H,(IY+5)
  68+ 60D9 DD 5E 08         LD E,(IX+8)
  69+ 60DC DD 56 09         LD D,(IX+9)
  70+ 60DF FA FF 60         JP M,.L1
  71+ 60E2                  ; equally high or IX defined one higher
  72+ 60E2                  ; check upper boundary
  73+ 60E2 19               ADD HL,DE
  74+ 60E3 ED 5B 12 63      LD DE,(BLIT_STRUCT+2)
  75+ 60E7 DD 4E 0C         LD C,(IX+12)
  76+ 60EA DD 46 0D         LD B,(IX+13)
  77+ 60ED CD AE 60         CALL GENERIC_INNER_CHECK
  78+ 60F0 30 29            JR NC,.INSIDE
  79+ 60F2                  ; check lower boundary
  80+ 60F2 E5               PUSH HL
  81+ 60F3 2A 16 63         LD HL,(BLIT_STRUCT+6)
  82+ 60F6 19               ADD HL,DE
  83+ 60F7 EB               EX DE,HL
  84+ 60F8 E1               POP HL
  85+ 60F9 CD AE 60         CALL GENERIC_INNER_CHECK
  86+ 60FC 30 1D            JR NC,.INSIDE
  87+ 60FE C9               RET ; not overlapping
  88+ 60FF              .L1:
  89+ 60FF                  ; rectangle defined in BLIT_STRUCT is higher
  90+ 60FF 19               ADD HL,DE
  91+ 6100 EB               EX DE,HL
  92+ 6101 2A 12 63         LD HL,(BLIT_STRUCT+2)
  93+ 6104 ED 4B 16 63      LD BC,(BLIT_STRUCT+6)
  94+ 6108 CD AE 60         CALL GENERIC_INNER_CHECK
  95+ 610B 30 0E            JR NC,.INSIDE
  96+ 610D E5               PUSH HL
  97+ 610E DD 6E 0C         LD L,(IX+12)
  98+ 6111 DD 66 0D         LD H,(IX+13)
  99+ 6114 19               ADD HL,DE
 100+ 6115 EB               EX DE,HL
 101+ 6116 E1               POP HL
 102+ 6117 CD AE 60         CALL GENERIC_INNER_CHECK
 103+ 611A D8               RET C
 104+ 611B              .INSIDE:
 105+ 611B                  ; check x coordinate
 106+ 611B                  ; first check which rectangle is wider
 107+ 611B DD 6E 0A         LD L,(IX+10)
 108+ 611E DD 66 0B         LD H,(IX+11)
 109+ 6121 ED 5B 14 63      LD DE,(BLIT_STRUCT+4)
 110+ 6125 A7               AND A
 111+ 6126 ED 52            SBC HL,DE
 112+ 6128 FD 6E 02         LD L,(IY+2)
 113+ 612B FD 66 03         LD H,(IY+3)
 114+ 612E DD 5E 06         LD E,(IX+6)
 115+ 6131 DD 56 07         LD D,(IX+7)
 116+ 6134 FA 50 61         JP M,.L2
 117+ 6137                  ; equally wide or IX defined one wider
 118+ 6137                  ; check left boundary
 119+ 6137 19               ADD HL,DE
 120+ 6138 ED 5B 10 63      LD DE,(BLIT_STRUCT+0)
 121+ 613C DD 4E 0A         LD C,(IX+10)
 122+ 613F DD 46 0B         LD B,(IX+11)
 123+ 6142 CD AE 60         CALL GENERIC_INNER_CHECK
 124+ 6145 D0               RET NC ; overlap
 125+ 6146                  ; check right boundary
 126+ 6146 E5               PUSH HL
 127+ 6147 2A 14 63         LD HL,(BLIT_STRUCT+4)
 128+ 614A 19               ADD HL,DE
 129+ 614B EB               EX DE,HL
 130+ 614C E1               POP HL
 131+ 614D C3 AE 60         JP GENERIC_INNER_CHECK ; CF and result set by fn call
 132+ 6150              .L2:
 133+ 6150                  ; rectangle defined in BLIT_STRUCT is higher
 134+ 6150 19               ADD HL,DE
 135+ 6151 EB               EX DE,HL
 136+ 6152 2A 10 63         LD HL,(BLIT_STRUCT+0)
 137+ 6155 ED 4B 14 63      LD BC,(BLIT_STRUCT+4)
 138+ 6159 CD AE 60         CALL GENERIC_INNER_CHECK
 139+ 615C D0               RET NC ; overlap
 140+ 615D E5               PUSH HL
 141+ 615E DD 6E 0A         LD L,(IX+10)
 142+ 6161 DD 66 0B         LD H,(IX+11)
 143+ 6164 19               ADD HL,DE
 144+ 6165 EB               EX DE,HL
 145+ 6166 E1               POP HL
 146+ 6167 C3 AE 60         JP GENERIC_INNER_CHECK
 147+ 616A              ; ************************************************************************************************
 148+ 616A
 149+ 616A              ; ************************************************************************************************
 150+ 616A              ; function tries to find rectangle overlap and returns an index if found
 151+ 616A              ; input BLIT_STRUCT data
 152+ 616A              ;  +00 x coordinate
 153+ 616A              ;  +02 y coordinate
 154+ 616A              ;  +04 width
 155+ 616A              ;  +06 height
 156+ 616A              ;  +08 number of items in a list, described under RECTANGLE_OVERLAP_CHECK
 157+ 616A              ;  +09 pointer to first element of R%(7,n)
 158+ 616A              ;  +11 pointer to INT result variable
 159+ 616A              ; returns CF=1 if not overlapping
 160+ 616A              ; returns A=list index and CF=0 if overlapping
 161+ 616A              FIND_OVERLAP:
 162+ 616A 3A 18 63         LD A,(BLIT_STRUCT+8)
 163+ 616D 47               LD B,A
 164+ 616E DD 2A 19 63      LD IX,(BLIT_STRUCT+9)
 165+ 6172              .L1:
 166+ 6172 C5               PUSH BC
 167+ 6173                  ; check active flag
 168+ 6173 DD 7E 00         LD A,(IX)
 169+ 6176 DD B6 01         OR (IX+1)
 170+ 6179 28 18            JR Z,.NEXT
 171+ 617B                  ; check type
 172+ 617B DD 7E 0E         LD A,(IX+14)
 173+ 617E DD B6 0F         OR (IX+15)
 174+ 6181 20 1A            JR NZ,.L2
 175+ 6183 DD E5            PUSH IX
 176+ 6185 FD E1            POP IY
 177+ 6187              .L3:
 178+ 6187 CD C6 60         CALL RECTANGLE_OVERLAP_CHECK
 179+ 618A 38 07            JR C,.NEXT
 180+ 618C                  ; found
 181+ 618C C1               POP BC
 182+ 618D 3A 18 63         LD A,(BLIT_STRUCT+8)
 183+ 6190 90               SUB B
 184+ 6191 A7               AND A
 185+ 6192 C9               RET
 186+ 6193              .NEXT:
 187+ 6193 11 10 00         LD DE,16
 188+ 6196 DD 19            ADD IX,DE
 189+ 6198 C1               POP BC
 190+ 6199 10 D7            DJNZ .L1
 191+ 619B 37               SCF
 192+ 619C C9               RET
 193+ 619D              .L2:
 194+ 619D                  ; sprite, need to build a temporary data struct since x and y values are inversed
 195+ 619D                  ; at BLIT_STRUCT+13
 196+ 619D DD 7E 02         LD A,(IX+2) ; sprite ID
 197+ 61A0 CD 89 4D         CALL GETnthSPRATTR
 198+ 61A3 FD 21 1B 63      LD IY,BLIT_STRUCT+11
 199+ 61A7 7E               LD A,(HL)
 200+ 61A8 FD 77 04         LD (IY+4),A
 201+ 61AB 23               INC HL
 202+ 61AC 7E               LD A,(HL)
 203+ 61AD FD 77 05         LD (IY+5),A
 204+ 61B0 23               INC HL
 205+ 61B1 7E               LD A,(HL)
 206+ 61B2 FD 77 02         LD (IY+2),A
 207+ 61B5 23               INC HL
 208+ 61B6 7E               LD A,(HL)
 209+ 61B7 FD 77 03         LD (IY+3),A
 210+ 61BA 18 CB            JR .L3
 211+ 61BC              ; ************************************************************************************************
 212+ 61BC
 213+ 61BC               IF (1 == 1)
 214+ 61BC              ; ************************************************************************************************
 215+ 61BC              ; function to handle CALL COLL basic extension
 216+ 61BC              ; checks for collision between player and other rectangles
 217+ 61BC              ; COLL ( INT result variable,
 218+ 61BC              ;	     INT player x value,
 219+ 61BC              ;	     INT player y value,
 220+ 61BC              ;	     INT player width,
 221+ 61BC              ;	     INT player height,
 222+ 61BC              ;	     INT number of items in a list,
 223+ 61BC              ;		 INT[6][n] rectangle struct )
 224+ 61BC              ; will fill result variable with index or -1 if no collision
 225+ 61BC              ; rectangle struct described under RECTANGLE_OVERLAP_CHECK
 226+ 61BC              COLL:
 227+ 61BC              	; opening (
 228+ 61BC CD 2B 66     	CALL CHKCHAR
 229+ 61BF 28           	DB '('
 230+ 61C0              	; get address of result variable
 231+ 61C0 DD 21 A4 5E  	LD IX, PTRGET
 232+ 61C4 CD 59 01     	CALL CALBAS
 233+ 61C7 ED 53 1B 63  	LD (BLIT_STRUCT+11),DE
 234+ 61CB              	; comma
 235+ 61CB CD 2B 66     	CALL CHKCHAR
 236+ 61CE 2C           	DB ','
 237+ 61CF              	; get x
 238+ 61CF DD 21 2F 54  	LD IX, FRMQNT
 239+ 61D3 CD 59 01     	CALL CALBAS
 240+ 61D6 ED 53 10 63  	LD (BLIT_STRUCT+0),DE
 241+ 61DA              	; comma
 242+ 61DA CD 2B 66     	CALL CHKCHAR
 243+ 61DD 2C           	DB ','
 244+ 61DE              	; get y
 245+ 61DE DD 21 2F 54  	LD IX, FRMQNT
 246+ 61E2 CD 59 01     	CALL CALBAS
 247+ 61E5 ED 53 12 63  	LD (BLIT_STRUCT+2),DE
 248+ 61E9              	; comma
 249+ 61E9 CD 2B 66     	CALL CHKCHAR
 250+ 61EC 2C           	DB ','
 251+ 61ED              	; get width
 252+ 61ED DD 21 2F 54  	LD IX, FRMQNT
 253+ 61F1 CD 59 01     	CALL CALBAS
 254+ 61F4 ED 53 14 63  	LD (BLIT_STRUCT+4),DE
 255+ 61F8              	; comma
 256+ 61F8 CD 2B 66     	CALL CHKCHAR
 257+ 61FB 2C           	DB ','
 258+ 61FC              	; get height
 259+ 61FC DD 21 2F 54  	LD IX, FRMQNT
 260+ 6200 CD 59 01     	CALL CALBAS
 261+ 6203 ED 53 16 63  	LD (BLIT_STRUCT+6),DE
 262+ 6207              	; comma
 263+ 6207 CD 2B 66     	CALL CHKCHAR
 264+ 620A 2C           	DB ','
 265+ 620B              	; get number of items in a list
 266+ 620B DD 21 1C 52  	LD IX, GETBYT
 267+ 620F CD 59 01     	CALL CALBAS
 268+ 6212 32 18 63     	LD (BLIT_STRUCT+8),A
 269+ 6215              	; comma
 270+ 6215 CD 2B 66     	CALL CHKCHAR
 271+ 6218 2C           	DB ','
 272+ 6219              	; get address of rectangle structure array DIM R%(7,n)
 273+ 6219 3A 18 63     	LD A,(BLIT_STRUCT+8)
 274+ 621C 5F               LD E,A
 275+ 621D 3E 02            LD A,2
 276+ 621F 47           	LD B,A
 277+ 6220 16 07        	LD D,7
 278+ 6222 CD 58 66     	CALL GET_BASIC_ARRAY_DATA_POINTER
 279+ 6225 ED 43 19 63  	LD (BLIT_STRUCT+9),BC
 280+ 6229              	; ending )
 281+ 6229 CD 2B 66     	CALL CHKCHAR
 282+ 622C 29           	DB ')'
 283+ 622D
 284+ 622D E5               PUSH HL
 285+ 622E CD 6A 61         CALL FIND_OVERLAP
 286+ 6231 2A 1B 63         LD HL,(BLIT_STRUCT+11)
 287+ 6234 38 06            JR C,.NOTFOUND
 288+ 6236 77               LD (HL),A
 289+ 6237 23               INC HL
 290+ 6238 36 00            LD (HL),0
 291+ 623A E1               POP HL
 292+ 623B C9               RET
 293+ 623C              .NOTFOUND:
 294+ 623C 36 FF            LD (HL),#FF
 295+ 623E 23               INC HL
 296+ 623F 36 FF            LD (HL),#FF
 297+ 6241 E1               POP HL
 298+ 6242 C9               RET
 299+ 6243              ; ************************************************************************************************
 300+ 6243               ENDIF
 301+ 6243
 302+ 6243               IF (0 == 1)
 303+ 6243 ~            ; *******************************************************************************************************
 304+ 6243 ~            ; same as COLL but for DEFUSR approach
 305+ 6243 ~            ; input IX=pointer to input array, real data from +2
 306+ 6243 ~            ; +02 = pointer to result variable
 307+ 6243 ~            ; +04 = player X
 308+ 6243 ~            ; +06 = player Y
 309+ 6243 ~            ; +08 = player width
 310+ 6243 ~            ; +10 = player height
 311+ 6243 ~            ; +12 = number of list items
 312+ 6243 ~            ; +14 = pointer to list of collidable objects
 313+ 6243 ~            COLL_DEFUSR:
 314+ 6243 ~                PUSH IX
 315+ 6243 ~                POP HL
 316+ 6243 ~                .4 INC HL ; skip over to player x
 317+ 6243 ~                LD DE,BLIT_STRUCT
 318+ 6243 ~                LD BC,9
 319+ 6243 ~                LDIR ; copy over x,y,w,h,list item number
 320+ 6243 ~                LD A,(IX+14)
 321+ 6243 ~                LD (BLIT_STRUCT+9),A
 322+ 6243 ~                LD A,(IX+15)
 323+ 6243 ~                LD (BLIT_STRUCT+10),A ; address to collidable objects array
 324+ 6243 ~                LD A,(IX+2)
 325+ 6243 ~                LD (BLIT_STRUCT+11),A
 326+ 6243 ~                LD A,(IX+3)
 327+ 6243 ~                LD (BLIT_STRUCT+12),A ; address to results variable
 328+ 6243 ~                PUSH IX
 329+ 6243 ~                CALL FIND_OVERLAP
 330+ 6243 ~                POP IX
 331+ 6243 ~                LD L,(IX+2)
 332+ 6243 ~                LD H,(IX+3)
 333+ 6243 ~                JR C,.NOTFOUND
 334+ 6243 ~                LD (HL),A
 335+ 6243 ~                INC HL
 336+ 6243 ~                LD (HL),0
 337+ 6243 ~                RET
 338+ 6243 ~            .NOTFOUND:
 339+ 6243 ~                LD (HL),#FF
 340+ 6243 ~                INC HL
 341+ 6243 ~                LD (HL),#FF
 342+ 6243 ~                RET
 343+ 6243 ~            ; *******************************************************************************************************
 344+ 6243               ENDIF
 345+ 6243
# file closed: asm\COLLISION.asm
 167  6243               ENDIF
 168  6243
 169  6243               IF (DECOMP_CMDS == 1)
 170  6243               INCLUDE "decomp.asm"
# file opened: asm\decomp.asm
   1+ 6243              ; -----------------------------------------------------------------------------
   2+ 6243              ; ZX0 decoder by Einar Saukas & Urusergi
   3+ 6243              ; "Standard" version (68 bytes only)
   4+ 6243              ; -----------------------------------------------------------------------------
   5+ 6243              ; Parameters:
   6+ 6243              ;   HL: source address (compressed data)
   7+ 6243              ;   DE: destination address (decompressing)
   8+ 6243              ; -----------------------------------------------------------------------------
   9+ 6243
  10+ 6243              dzx0_standard:
  11+ 6243 01 FF FF             ld      bc, $ffff               ; preserve default offset 1
  12+ 6246 C5                   push    bc
  13+ 6247 03                   inc     bc
  14+ 6248 3E 80                ld      a, $80
  15+ 624A              dzx0s_literals:
  16+ 624A CD 7A 62             call    dzx0s_elias             ; obtain length
  17+ 624D              dzx0_ldir_1:
  18+ 624D ED B0                ldir                            ; copy literals
  19+ 624F 00                   nop                             ; placeholder for call
  20+ 6250 87                   add     a, a                    ; copy from last offset or new offset?
  21+ 6251 38 0E                jr      c, dzx0s_new_offset
  22+ 6253 CD 7A 62             call    dzx0s_elias             ; obtain length
  23+ 6256              dzx0s_copy:
  24+ 6256 E3                   ex      (sp), hl                ; preserve source, restore offset
  25+ 6257 E5                   push    hl                      ; preserve offset
  26+ 6258 19                   add     hl, de                  ; calculate destination - offset
  27+ 6259              dzx0_ldir_2:
  28+ 6259 ED B0                ldir                            ; copy from offset
  29+ 625B 00                   nop                             ; placeholder for call
  30+ 625C E1                   pop     hl                      ; restore offset
  31+ 625D E3                   ex      (sp), hl                ; preserve offset, restore source
  32+ 625E 87                   add     a, a                    ; copy from literals or new offset?
  33+ 625F 30 E9                jr      nc, dzx0s_literals
  34+ 6261              dzx0s_new_offset:
  35+ 6261 C1                   pop     bc                      ; discard last offset
  36+ 6262 0E FE                ld      c, $fe                  ; prepare negative offset
  37+ 6264 CD 7B 62             call    dzx0s_elias_loop        ; obtain offset MSB
  38+ 6267 0C                   inc     c
  39+ 6268 C8                   ret     z                       ; check end marker
  40+ 6269 41                   ld      b, c
  41+ 626A 4E                   ld      c, (hl)                 ; obtain offset LSB
  42+ 626B 23                   inc     hl
  43+ 626C CB 18                rr      b                       ; last offset bit becomes first length bit
  44+ 626E CB 19                rr      c
  45+ 6270 C5                   push    bc                      ; preserve new offset
  46+ 6271 01 01 00             ld      bc, 1                   ; obtain length
  47+ 6274 D4 82 62             call    nc, dzx0s_elias_backtrack
  48+ 6277 03                   inc     bc
  49+ 6278 18 DC                jr      dzx0s_copy
  50+ 627A              dzx0s_elias:
  51+ 627A 0C                   inc     c                       ; interlaced Elias gamma coding
  52+ 627B              dzx0s_elias_loop:
  53+ 627B 87                   add     a, a
  54+ 627C 20 03                jr      nz, dzx0s_elias_skip
  55+ 627E 7E                   ld      a, (hl)                 ; load another group of 8 bits
  56+ 627F 23                   inc     hl
  57+ 6280 17                   rla
  58+ 6281              dzx0s_elias_skip:
  59+ 6281 D8                   ret     c
  60+ 6282              dzx0s_elias_backtrack:
  61+ 6282 87                   add     a, a
  62+ 6283 CB 11                rl      c
  63+ 6285 CB 10                rl      b
  64+ 6287 18 F2                jr      dzx0s_elias_loop
  65+ 6289              ; -----------------------------------------------------------------------------
  66+ 6289
  67+ 6289              ; *******************************************************************************************************
  68+ 6289              ; helper function for VRAM unpack to save AF prior to calling VRAM copy fn
  69+ 6289              DXZ0s_VRAM_LDIR:
  70+ 6289 F5                   PUSH AF ; save AF used by algorithm
  71+ 628A D5                   PUSH DE
  72+ 628B C5                   PUSH BC
  73+ 628C CD 57 5A             CALL VRAM_LDIRVM
  74+ 628F C1                   POP BC
  75+ 6290 EB                   EX DE,HL
  76+ 6291 E1                   POP HL
  77+ 6292 09                   ADD HL,BC
  78+ 6293 EB                   EX DE,HL
  79+ 6294 01 00 00             LD BC,0
  80+ 6297 F1                   POP AF
  81+ 6298 C9                   RET
  82+ 6299              ; *******************************************************************************************************
  83+ 6299
  84+ 6299              ; *******************************************************************************************************
  85+ 6299              ; helper function to get a byte from VRAM address at HL and place it at DE
  86+ 6299              VPOKE_VPEEK:
  87+ 6299 F3                   DI
  88+ 629A CD 03 65             CALL SETWRT_LOCAL
  89+ 629D E3                   EX (SP),HL
  90+ 629E E3                   EX (SP),HL
  91+ 629F DB 98                IN A,(#98)
  92+ 62A1 F5                   PUSH AF
  93+ 62A2 EB                   EX DE,HL
  94+ 62A3 CD 03 65             CALL SETWRT_LOCAL
  95+ 62A6 E3                   EX (SP),HL
  96+ 62A7 E3                   EX (SP),HL
  97+ 62A8 EB                   EX DE,HL
  98+ 62A9 F1                   POP AF
  99+ 62AA D3 98                OUT (#98),A
 100+ 62AC FB                   EI
 101+ 62AD C9                   RET
 102+ 62AE              ; *******************************************************************************************************
 103+ 62AE
 104+ 62AE               IF (1 == 1)
 105+ 62AE              ; *******************************************************************************************************
 106+ 62AE              ; function to handle CALL VUNPACK basic extension
 107+ 62AE              ; _VUNPACK ( INT source,
 108+ 62AE              ;			 INT destination )
 109+ 62AE              ; will put ram in page 0 also, page 1 is already there
 110+ 62AE              ; *******************************************************************************************************
 111+ 62AE              VUNPACK:
 112+ 62AE 3E CD            LD A, #CD ; CALL
 113+ 62B0 32 4D 62         LD (dzx0_ldir_1), A
 114+ 62B3 32 59 62         LD (dzx0_ldir_2), A
 115+ 62B6 11 89 62         LD DE, DXZ0s_VRAM_LDIR
 116+ 62B9 ED 53 4E 62      LD (dzx0_ldir_1 + 1), DE
 117+ 62BD ED 53 5A 62      LD (dzx0_ldir_2 + 1), DE
 118+ 62C1 18 12            JR UNPACK_COMMON
 119+ 62C3              ; function to handle CALL UNPACK basic extension
 120+ 62C3              ; _UNPACK ( INT source,
 121+ 62C3              ;			INT destination )
 122+ 62C3              ; will put ram in page 0 also, page 1 is already there
 123+ 62C3              UNPACK:
 124+ 62C3 11 ED B0         LD DE, #B0ED ; LDIR
 125+ 62C6 ED 53 4D 62      LD (dzx0_ldir_1), DE
 126+ 62CA ED 53 59 62      LD (dzx0_ldir_2), DE
 127+ 62CE AF               XOR A ; NOP
 128+ 62CF 32 4F 62         LD (dzx0_ldir_1 + 2), A
 129+ 62D2 32 5B 62         LD (dzx0_ldir_2 + 2), A
 130+ 62D5              UNPACK_COMMON:
 131+ 62D5              	; opening (
 132+ 62D5 CD 2B 66     	CALL CHKCHAR
 133+ 62D8 28           	DB '('
 134+ 62D9              	; get source address
 135+ 62D9 DD 21 2F 54  	LD IX, FRMQNT
 136+ 62DD CD 59 01     	CALL CALBAS
 137+ 62E0 D5           	PUSH DE
 138+ 62E1              	; comma
 139+ 62E1 CD 2B 66     	CALL CHKCHAR
 140+ 62E4 2C           	DB ','
 141+ 62E5              	; get destination address
 142+ 62E5 DD 21 2F 54  	LD IX, FRMQNT
 143+ 62E9 CD 59 01     	CALL CALBAS
 144+ 62EC D5           	PUSH DE
 145+ 62ED              	; ending )
 146+ 62ED CD 2B 66     	CALL CHKCHAR
 147+ 62F0 29           	DB ')'
 148+ 62F1
 149+ 62F1              	; save position
 150+ 62F1 E5           	PUSH HL
 151+ 62F2 DD E1        	POP IX
 152+ 62F4
 153+ 62F4 D1           	POP DE ; destination
 154+ 62F5 E1           	POP HL ; source
 155+ 62F6 D9           	EXX
 156+ 62F7              	; enable page 0
 157+ 62F7 FD 21 FE 62  	LD IY, .RET
 158+ 62FB C3 DC 65     	JP ENABLE_PAGE0
 159+ 62FE              .RET:
 160+ 62FE FB           	EI
 161+ 62FF D9           	EXX
 162+ 6300 CD 43 62     	CALL dzx0_standard
 163+ 6303 D1                   POP DE
 164+ 6304 C1                   POP BC
 165+ 6305 CD 53 65             CALL RESTORE_PAGE_INFO
 166+ 6308 DD E5        	PUSH IX
 167+ 630A E1           	POP HL
 168+ 630B C9           	RET
 169+ 630C              ; *******************************************************************************************************
 170+ 630C               ENDIF
 171+ 630C
 172+ 630C               IF (0 == 1)
 173+ 630C ~            ; *******************************************************************************************************
 174+ 630C ~            ; same as VUNPACK but for DEFUSR approach
 175+ 630C ~            ; input IX=pointer to input array, real data from +2
 176+ 630C ~            ; +2 = source address
 177+ 630C ~            ; +4 = destination address
 178+ 630C ~            ; *******************************************************************************************************
 179+ 630C ~            VUNPACK_DEFUSR:
 180+ 630C ~                LD A, #CD ; CALL
 181+ 630C ~                LD (dzx0_ldir_1), A
 182+ 630C ~                LD (dzx0_ldir_2), A
 183+ 630C ~                LD HL, DXZ0s_VRAM_LDIR
 184+ 630C ~                LD (dzx0_ldir_1 + 1), HL
 185+ 630C ~                LD (dzx0_ldir_2 + 1), HL
 186+ 630C ~                JR UNPACK_DEFUSR_COMMON
 187+ 630C ~            ; same as UNPACK but for DEFUSR approach
 188+ 630C ~            ; input IX=pointer to input array, real data from +2
 189+ 630C ~            ; +2 = source address
 190+ 630C ~            ; +4 = destination address
 191+ 630C ~            UNPACK_DEFUSR:
 192+ 630C ~                LD HL, #B0ED ; LDIR
 193+ 630C ~                LD (dzx0_ldir_1), HL
 194+ 630C ~                LD (dzx0_ldir_2), HL
 195+ 630C ~                XOR A ; NOP
 196+ 630C ~                LD (dzx0_ldir_1 + 2), A
 197+ 630C ~                LD (dzx0_ldir_2 + 2), A
 198+ 630C ~            UNPACK_DEFUSR_COMMON:
 199+ 630C ~            	; enable page 0
 200+ 630C ~            	LD IY, .RET
 201+ 630C ~            	JP ENABLE_PAGE0
 202+ 630C ~            .RET:
 203+ 630C ~            	EI
 204+ 630C ~            	LD L,(IX+2)
 205+ 630C ~            	LD H,(IX+3)
 206+ 630C ~            	LD E,(IX+4)
 207+ 630C ~            	LD D,(IX+5)
 208+ 630C ~            	CALL dzx0_standard
 209+ 630C ~                POP DE
 210+ 630C ~                POP BC
 211+ 630C ~                JP RESTORE_PAGE_INFO
 212+ 630C ~            ; *******************************************************************************************************
 213+ 630C               ENDIF
# file closed: asm\decomp.asm
 171  630C               ENDIF
 172  630C
 173  630C               IF (0 == 1)
 174  630C ~             INCLUDE "DEFUSR.asm"
 175  630C               ENDIF
 176  630C
 177  630C              ; temp variables for BLIT, TILE functions
 178  630C               IF (BLIT_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS + COLL_CMD > 0)
 179  630C              BLIT_TMP:
 180  630C              TILETMP1:
 181  630C              BLIT_TMP1:
 182  630C 00 00         DW 0
 183  630E              TILETMP2:
 184  630E              BLIT_TMP2:
 185  630E 00 00         DW 0
 186  6310              BLIT_STRUCT:
 187  6310 00 00 00...   DS 17
 188  6314               ENDIF
 189  6321
 190  6321               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 191  6321              VRAM_UPDATE_IN_PROGRESS:
 192  6321 00            DB 0
 193  6322               ENDIF
 194  6322
 195  6322              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 196  6322              ; per starting letter, if no commands with this letter, NULL value
 197  6322              CMDS:
 198  6322 6B 64        	DW CMDS_A ; always present due to ARTINFO
 199  6324               IF (BLIT_CMDS + BOX_CMDS > 0) && (1 == 1)
 200  6324 28 64            DW CMDS_B ; B
 201  6326               ELSE
 202  6326 ~            	DW 0
 203  6326               ENDIF
 204  6326               IF (COLL_CMD == 1) && (1 == 1)
 205  6326 5B 64        	DW CMDS_C ;
 206  6328               ELSE
 207  6328 ~                DW 0 ; C
 208  6328               ENDIF
 209  6328 00 00            DW 0 ; D
 210  632A 00 00            DW 0 ; E
 211  632C               IF (VRAM_CMDS + RAM_CMDS > 0) && (1 == 1)
 212  632C A2 63            DW CMDS_F; F
 213  632E               ELSE
 214  632E ~            	DW 0
 215  632E               ENDIF
 216  632E               IF (GENCAL_CMD > 0) && (1 == 1)
 217  632E B4 63            DW CMDS_G; G
 218  6330               ELSE
 219  6330 ~            	DW 0
 220  6330               ENDIF
 221  6330 00 00            DW 0 ; H
 222  6332 00 00            DW 0 ; I
 223  6334 00 00            DW 0 ; J
 224  6336 00 00            DW 0 ; K
 225  6338 00 00            DW 0 ; L
 226  633A               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0) && (1 == 1)
 227  633A 56 63            DW CMDS_M ; M
 228  633C               ELSE
 229  633C ~            	DW 0
 230  633C               ENDIF
 231  633C 00 00            DW 0 ; N
 232  633E 00 00            DW 0 ; O
 233  6340 00 00            DW 0 ; P
 234  6342 00 00            DW 0 ; Q
 235  6344 00 00            DW 0 ; R
 236  6346               IF (SOUND_CMDS + SPRITE_CMDS > 0) && (1 == 1)
 237  6346 D0 63            DW CMDS_S ; S
 238  6348               ELSE
 239  6348 ~            	DW 0
 240  6348               ENDIF
 241  6348               IF (TILE_CMDS > 0) && (1 == 1)
 242  6348 47 64            DW CMDS_T ; T
 243  634A               ELSE
 244  634A ~            	DW 0
 245  634A               ENDIF
 246  634A               IF (DECOMP_CMDS > 0) && (1 == 1)
 247  634A 62 64            DW CMDS_U ; U
 248  634C               ELSE
 249  634C ~            	DW 0
 250  634C               ENDIF
 251  634C               IF ((VRAM_CMDS > 0) || (VRAM_CMDS + DECOMP_CMDS > 1)) && (1 == 1)
 252  634C BD 63            DW CMDS_V ; V
 253  634E               ELSE
 254  634E ~            	DW 0
 255  634E               ENDIF
 256  634E 00 00            DW 0 ; W
 257  6350 00 00            DW 0 ; X
 258  6352 00 00            DW 0 ; Y
 259  6354 00 00            DW 0 ; Z
 260  6356
 261  6356               IF (1 == 1)
 262  6356               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 263  6356              CMDS_M:
 264  6356               IF (VRAM_CMDS == 1)
 265  6356 4D 45 4D 56      DB "MEMVRM", 0
 265  635A 52 4D 00
 266  635D F4 59            DW MEMVRM
 267  635F               ENDIF
 268  635F               IF (RAM_CMDS == 1)
 269  635F 4D 45 4D 43  	DB "MEMCPY", 0
 269  6363 50 59 00
 270  6366 32 58        	DW MEMCPY
 271  6368               ENDIF
 272  6368               IF (ANIM_CMDS == 1)
 273  6368 4D 41 58 41  	DB "MAXANIMITEMS",0
 273  636C 4E 49 4D 49
 273  6370 54 45 4D 53
 273  6374 00
 274  6375 A0 4F        	DW MAXANIMITEMS
 275  6377 4D 41 58 41  	DB "MAXANIMDEFS",0
 275  637B 4E 49 4D 44
 275  637F 45 46 53 00
 276  6383 30 51        	DW MAXANIMDEFS
 277  6385 4D 41 58 41  	DB "MAXANIMSPRS",0
 277  6389 4E 49 4D 53
 277  638D 50 52 53 00
 278  6391 C6 51        	DW MAXANIMSPRS
 279  6393 4D 41 58 41     DB "MAXAUTOSGAMS",0
 279  6397 55 54 4F 53
 279  639B 47 41 4D 53
 279  639F 00
 280  63A0 10 53           DW MAXAUTOSGAMS
 281  63A2               ENDIF
 282  63A2               ENDIF
 283  63A2
 284  63A2               IF (VRAM_CMDS + RAM_CMDS > 0)
 285  63A2              CMDS_F:
 286  63A2               IF (VRAM_CMDS == 1)
 287  63A2 46 49 4C 56      DB "FILVRM", 0
 287  63A6 52 4D 00
 288  63A9 A5 59            DW FILVRM
 289  63AB               ENDIF
 290  63AB               IF (RAM_CMDS == 1)
 291  63AB 46 49 4C 52      DB "FILRAM", 0
 291  63AF 41 4D 00
 292  63B2 75 58            DW FILRAM
 293  63B4               ENDIF
 294  63B4               ENDIF
 295  63B4
 296  63B4               IF (GENCAL_CMD > 0)
 297  63B4              CMDS_G:
 298  63B4               IF (GENCAL_CMD == 1)
 299  63B4 47 45 4E 43      DB "GENCAL", 0
 299  63B8 41 4C 00
 300  63BB E6 5A            DW GENCAL
 301  63BD               ENDIF
 302  63BD               ENDIF
 303  63BD
 304  63BD               IF (VRAM_CMDS > 0)
 305  63BD              CMDS_V:
 306  63BD               IF (VRAM_CMDS == 1)
 307  63BD 56 52 4D 4D  	DB "VRMMEM", 0
 307  63C1 45 4D 00
 308  63C4 81 5A        	DW VRMMEM
 309  63C6               ENDIF
 310  63C6               IF (DECOMP_CMDS == 1)
 311  63C6 56 55 4E 50  	DB "VUNPACK", 0
 311  63CA 41 43 4B 00
 312  63CE AE 62        	DW VUNPACK
 313  63D0               ENDIF
 314  63D0               ENDIF
 315  63D0
 316  63D0               IF (SOUND_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 317  63D0              CMDS_S:
 318  63D0               IF (SPRITE_CMDS + ANIM_CMDS > 0)
 319  63D0 53 47 41 4D      DB "SGAM",0
 319  63D4 00
 320  63D5 9E 56            DW SGAM
 321  63D7               ENDIF
 322  63D7               IF (SPRITE_CMDS == 1)
 323  63D7 53 50 52 47  	DB "SPRGRPMOV", 0
 323  63DB 52 50 4D 4F
 323  63DF 56 00
 324  63E1 F8 4E        	DW SPRGRPMOV
 325  63E3               ENDIF
 326  63E3               IF (SOUND_CMDS == 1)
 327  63E3 53 4E 44 53  	DB "SNDSFX", 0
 327  63E7 46 58 00
 328  63EA 4B 59        	DW SNDSFX
 329  63EC 53 4E 44 50  	DB "SNDPLYON", 0
 329  63F0 4C 59 4F 4E
 329  63F4 00
 330  63F5 15 59        	DW SNDPLYON
 331  63F7 53 4E 44 50  	DB "SNDPLYOFF", 0
 331  63FB 4C 59 4F 46
 331  63FF 46 00
 332  6401 28 59        	DW SNDPLYOFF
 333  6403 53 4E 44 50  	DB "SNDPLYINI", 0
 333  6407 4C 59 49 4E
 333  640B 49 00
 334  640D CB 58        	DW SNDPLYINIT
 335  640F               ENDIF
 336  640F               IF (SPRITE_CMDS == 1)
 337  640F 53 50 52 45  	DB "SPRENABLE", 0
 337  6413 4E 41 42 4C
 337  6417 45 00
 338  6419 6E 4E        	DW SPRENABLE
 339  641B 53 50 52 44  	DB "SPRDISABLE", 0
 339  641F 49 53 41 42
 339  6423 4C 45 00
 340  6426 B5 4E        	DW SPRDISABLE
 341  6428               ENDIF
 342  6428               ENDIF
 343  6428
 344  6428               IF (BLIT_CMDS + BOX_CMDS > 0)
 345  6428              CMDS_B:
 346  6428               IF (BLIT_CMDS == 1)
 347  6428 42 4C 49 54  	DB "BLIT", 0
 347  642C 00
 348  642D C6 5D        	DW BLIT
 349  642F               ENDIF
 350  642F               IF (BOX_CMDS == 1)
 351  642F 42 4F 58 4D  	DB "BOXMEMCPY", 0
 351  6433 45 4D 43 50
 351  6437 59 00
 352  6439 75 5B        	DW BOXMEMCPY
 353  643B 42 4F 58 4D  	DB "BOXMEMVRM", 0
 353  643F 45 4D 56 52
 353  6443 4D 00
 354  6445 0A 5C        	DW BOXMEMVRM
 355  6447               ENDIF
 356  6447               ENDIF
 357  6447
 358  6447               IF (TILE_CMDS > 0)
 359  6447              CMDS_T:
 360  6447               IF (TILE_CMDS == 1)
 361  6447 54 49 4C 45  	DB "TILERAM", 0
 361  644B 52 41 4D 00
 362  644F ED 5E        	DW TILERAM
 363  6451 54 49 4C 45  	DB "TILEVRM", 0
 363  6455 56 52 4D 00
 364  6459 F0 5F        	DW TILEVRM
 365  645B               ENDIF
 366  645B               ENDIF
 367  645B
 368  645B               IF (COLL_CMD > 0)
 369  645B              CMDS_C:
 370  645B               IF (COLL_CMD == 1)
 371  645B 43 4F 4C 4C      DB "COLL", 0
 371  645F 00
 372  6460 BC 61            DW COLL
 373  6462               ENDIF
 374  6462               ENDIF
 375  6462
 376  6462               IF (DECOMP_CMDS > 0)
 377  6462              CMDS_U:
 378  6462               IF (DECOMP_CMDS == 1)
 379  6462 55 4E 50 41      DB "UNPACK", 0
 379  6466 43 4B 00
 380  6469 C3 62            DW UNPACK
 381  646B               ENDIF
 382  646B               ENDIF
 383  646B
 384  646B              CMDS_A:
 385  646B               IF (ANIM_CMDS == 1)
 386  646B 41 4E 49 4D     DB "ANIMSTEP",0
 386  646F 53 54 45 50
 386  6473 00
 387  6474 E0 54           DW ANIMSTEP
 388  6476 41 4E 49 4D  	DB "ANIMSTART",0
 388  647A 53 54 41 52
 388  647E 54 00
 389  6480 E5 54        	DW ANIMSTART
 390  6482 41 4E 49 4D  	DB "ANIMSTOP",0
 390  6486 53 54 4F 50
 390  648A 00
 391  648B EA 54        	DW ANIMSTOP
 392  648D 41 4E 49 4D  	DB "ANIMITEMPAT",0
 392  6491 49 54 45 4D
 392  6495 50 41 54 00
 393  6499 71 50        	DW ANIMITEMPAT
 394  649B 41 4E 49 4D  	DB "ANIMITEMPTR",0
 394  649F 49 54 45 4D
 394  64A3 50 54 52 00
 395  64A7 D7 50        	DW ANIMITEMPTR_CMD
 396  64A9 41 4E 49 4D  	DB "ANIMDEF",0
 396  64AD 44 45 46 00
 397  64B1 73 51        	DW ANIMDEF
 398  64B3 41 4E 49 4D  	DB "ANIMSPRITE",0
 398  64B7 53 50 52 49
 398  64BB 54 45 00
 399  64BE 1F 52        	DW ANIMSPRITE
 400  64C0 41 4E 49 4D     DB "ANIMCHAR",0
 400  64C4 43 48 41 52
 400  64C8 00
 401  64C9 97 52           DW ANIMCHAR
 402  64CB 41 55 54 4F     DB "AUTOSGAMDEF",0
 402  64CF 53 47 41 4D
 402  64D3 44 45 46 00
 403  64D7 6D 53           DW AUTOSGAMDEF
 404  64D9 41 55 54 4F     DB "AUTOSGAMSTART",0
 404  64DD 53 47 41 4D
 404  64E1 53 54 41 52
 404  64E5 54 00
 405  64E7 A1 54           DW AUTOSGAMSTART
 406  64E9 41 55 54 4F     DB "AUTOSGAMSTOP",0
 406  64ED 53 47 41 4D
 406  64F1 53 54 4F 50
 406  64F5 00
 407  64F6 DD 54           DW AUTOSGAMSTOP
 408  64F8               ENDIF
 409  64F8 41 52 54 49     DB "ARTINFO",0
 409  64FC 4E 46 4F 00
 410  6500 8D 66           DW ARTINFO
 411  6502 00           	DB 0
 412  6503               ELSE // if not BASIC extension
 413  6503 ~            CMDS_A:
 414  6503 ~               DB "ARTINFO",0
 415  6503 ~               DW ARTINFO
 416  6503 ~            	DB 0
 417  6503               ENDIF
 418  6503
 419  6503               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 420  6503              ; ****************************************************************************************************
 421  6503              ; function sets VRAM address
 422  6503              ; input HL=address
 423  6503              ; modifies AF
 424  6503              SETWRT_LOCAL:
 425  6503 7D           	LD	A,L
 426  6504 D3 99        	OUT (099H),A
 427  6506 7C           	LD	A,H
 428  6507 E6 3F        	AND 03FH
 429  6509 F6 40        	OR	040H
 430  650B D3 99        	OUT (099H),A
 431  650D C9           	RET
 432  650E              ; ****************************************************************************************************
 433  650E               ENDIF
 434  650E
 435  650E               IF (VRAM_CMDS + TILE_CMDS > 0)
 436  650E              ; ****************************************************************************************************
 437  650E              ; function copies data from RAM to VRAM
 438  650E              ; input HL=address in RAM
 439  650E              ; input B=count
 440  650E              ; modifies AF, BC, HL
 441  650E              BBYTECOPY:
 442  650E 0E 98        	LD C,#98
 443  6510              BBYTECOPY_NO_C:
 444  6510 ED A3        	OUTI
 445  6512 C2 10 65     	JP	NZ, BBYTECOPY_NO_C
 446  6515 C9           	RET
 447  6516              ; ****************************************************************************************************
 448  6516               ENDIF
 449  6516
 450  6516              ; ****************************************************************************************************
 451  6516              ; function multiplies HL by 32
 452  6516              HLx32:
 453  6516 29           	ADD HL,HL
 454  6517              ; ****************************************************************************************************
 455  6517              ; function multiplies HL by 16
 456  6517              HLx16:
 457  6517 29           	ADD HL,HL
 458  6518              ; ****************************************************************************************************
 459  6518              ; function multiplies HL by 8
 460  6518              HLx8:
 461  6518 29          > ADD HL, HL
 461  6519 29          > ADD HL, HL
 461  651A 29          > ADD HL, HL
 462  651B C9           	RET
 463  651C              ; ****************************************************************************************************
 464  651C
 465  651C              ; ****************************************************************************************************
 466  651C              ; function gets slot and subslot data for specific page
 467  651C              ; input A=page (0, 1 or 2)
 468  651C              ; output B = 0A8H register value
 469  651C              ; output D = 0 is no subslots, 1 if yes
 470  651C              ; output C = 0A8H value when page 3 slot equals to requested page slot
 471  651C              ; output E = subslot value if present
 472  651C              ; modifies AF, BC, DE, HL
 473  651C              GET_PAGE_INFO:
 474  651C 6F               LD L, A
 475  651D C6 C1            ADD A, low (EXPTBL)
 476  651F 32 29 65         LD (GET_PAGE_INFO_L1+1), A
 477  6522 DB A8            IN A, (0A8H)
 478  6524 47               LD B, A
 479  6525 E6 3F            AND 03FH
 480  6527 4F               LD C, A
 481  6528              GET_PAGE_INFO_L1:
 482  6528 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 483  652B E6 80            AND 080H
 484  652D 28 1B            JR Z, GET_PAGE_INFO_L2
 485  652F                  ; expanded
 486  652F 2D               DEC L
 487  6530 FA 4F 65         JP M, GET_PAGE_INFO_L3
 488  6533 2D               DEC L
 489  6534 FA 4D 65         JP M, GET_PAGE_INFO_L4
 490  6537                  ; page 2
 491  6537 07               RLCA
 492  6538 07               RLCA
 493  6539              GET_PAGE_INFO_L5:
 494  6539 E6 C0            AND 0C0H
 495  653B B1               OR C
 496  653C D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 497  653E 4F               LD C, A
 498  653F 3A FF FF         LD A, (0FFFFH)
 499  6542 2F               CPL
 500  6543 5F               LD E, A
 501  6544 16 01            LD D, 1
 502  6546 78               LD A, B ; return stack
 503  6547 D3 A8            OUT (0A8H), A
 504  6549 C9               RET
 505  654A              GET_PAGE_INFO_L2:
 506  654A                  ; not expanded
 507  654A 16 00            LD D, 0
 508  654C C9               RET
 509  654D              GET_PAGE_INFO_L4:
 510  654D                  ; page 1
 511  654D 0F               RRCA
 512  654E 0F               RRCA
 513  654F              GET_PAGE_INFO_L3:
 514  654F                  ; page 0
 515  654F 0F               RRCA
 516  6550 0F               RRCA
 517  6551 18 E6            JR GET_PAGE_INFO_L5
 518  6553              ; ****************************************************************************************************
 519  6553
 520  6553              ; ****************************************************************************************************
 521  6553              ; function returns original slot and subslot info
 522  6553              ; input B = 0A8H register value
 523  6553              ; input D = 0 is no subslots, 1 if yes
 524  6553              ; input C = 0A8H value when page 3 slot equals to requested page slot
 525  6553              ; input E = subslot value if present
 526  6553              ; modifies AF, disables interrupts
 527  6553              RESTORE_PAGE_INFO:
 528  6553 F3              DI
 529  6554 7A              LD A, D
 530  6555 B7              OR A
 531  6556 28 07           JR Z, RESTORE_PAGE_INFO_L1
 532  6558 79              LD A, C
 533  6559 D3 A8           OUT (0A8H), A
 534  655B 7B              LD A, E
 535  655C 32 FF FF        LD (0FFFFH), A
 536  655F              RESTORE_PAGE_INFO_L1:
 537  655F 78              LD A, B
 538  6560 D3 A8           OUT (0A8H), A
 539  6562              NOACTION_DEFUSR: ; just a safe RET for use when DEFUSR table has an empty entry
 540  6562 C9              RET
 541  6563              ; ****************************************************************************************************
 542  6563
 543  6563              ; *******************************************************************************************************
 544  6563              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 545  6563              ; INPUT:  A = SLOT ID: EXXXSSPP
 546  6563              ; E = EXPANDED FLAG
 547  6563              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 548  6563              ; PP = PRIMARY SLOT NUMBER
 549  6563              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 550  6563              ; CHANGES: AF, BC, DE
 551  6563
 552  6563              LOCAL_ENASLT:
 553  6563 CD 83 65         CALL L0353
 554  6566 FA 70 65         JP M, L0340
 555  6569 DB A8            IN A, (0A8H)
 556  656B A1               AND C
 557  656C B0               OR B
 558  656D D3 A8            OUT (0A8H), A
 559  656F C9               RET
 560  6570              L0340:
 561  6570 E5               PUSH HL
 562  6571 CD A8 65         CALL L0378
 563  6574 4F               LD C, A
 564  6575 06 00            LD B, 0
 565  6577 7D               LD A, L
 566  6578 A4               AND H
 567  6579 B2               OR D
 568  657A 21 C5 FC         LD HL, 0FCC5H
 569  657D 09               ADD HL, BC
 570  657E 77               LD (HL), A
 571  657F E1               POP HL
 572  6580 79               LD A, C
 573  6581 18 E0            JR LOCAL_ENASLT
 574  6583              L0353:
 575  6583 F3               DI
 576  6584 F5               PUSH AF
 577  6585 7C               LD A, H
 578  6586 07               RLCA
 579  6587 07               RLCA
 580  6588 E6 03            AND 3
 581  658A 5F               LD E, A
 582  658B 3E C0            LD A, 0C0H
 583  658D              L035D:
 584  658D 07               RLCA
 585  658E 07               RLCA
 586  658F 1D               DEC E
 587  6590 F2 8D 65         JP P, L035D
 588  6593 5F               LD E, A
 589  6594 2F               CPL
 590  6595 4F               LD C, A
 591  6596 F1               POP AF
 592  6597 F5               PUSH AF
 593  6598 E6 03            AND 3
 594  659A 3C               INC A
 595  659B 47               LD B, A
 596  659C 3E AB            LD A, 0ABH
 597  659E              L036E:
 598  659E C6 55            ADD A, 055H
 599  65A0 10 FC            DJNZ L036E
 600  65A2 57               LD D, A
 601  65A3 A3               AND E
 602  65A4 47               LD B, A
 603  65A5 F1               POP AF
 604  65A6 A7               AND A
 605  65A7 C9               RET
 606  65A8              L0378:
 607  65A8 F5               PUSH AF
 608  65A9 7A               LD A, D
 609  65AA E6 C0            AND 0C0H
 610  65AC 4F               LD C, A
 611  65AD F1               POP AF
 612  65AE F5               PUSH AF
 613  65AF 57               LD D, A
 614  65B0 DB A8            IN A, (0A8H)
 615  65B2 47               LD B, A
 616  65B3 E6 3F            AND 03FH
 617  65B5 B1               OR C
 618  65B6 D3 A8            OUT (0A8H), A
 619  65B8 7A               LD A, D
 620  65B9 0F               RRCA
 621  65BA 0F               RRCA
 622  65BB E6 03            AND 3
 623  65BD 57               LD D, A
 624  65BE 3E AB            LD A, 0ABH
 625  65C0              L0390:
 626  65C0 C6 55            ADD A, 055H
 627  65C2 15               DEC D
 628  65C3 F2 C0 65         JP P, L0390
 629  65C6 A3               AND E
 630  65C7 57               LD D, A
 631  65C8 7B               LD A, E
 632  65C9 2F               CPL
 633  65CA 67               LD H, A
 634  65CB 3A FF FF         LD A, (0FFFFH)
 635  65CE 2F               CPL
 636  65CF 6F               LD L, A
 637  65D0 A4               AND H
 638  65D1 B2               OR D
 639  65D2 32 FF FF         LD (0FFFFH), A
 640  65D5 78               LD A, B
 641  65D6 D3 A8            OUT (0A8H), A
 642  65D8 F1               POP AF
 643  65D9 E6 03            AND 3
 644  65DB C9               RET
 645  65DC              ; *******************************************************************************************************
 646  65DC
 647  65DC              ; *******************************************************************************************************
 648  65DC              ; some common code to activate page 0 and place values needed to restore original page on stack
 649  65DC              ; input IY=return address
 650  65DC              ENABLE_PAGE0:
 651  65DC F3              DI
 652  65DD AF              XOR A
 653  65DE CD 1C 65        CALL GET_PAGE_INFO
 654  65E1 C5              PUSH BC
 655  65E2 D5              PUSH DE
 656  65E3 3A 41 F3        LD A, (RAMAD0)
 657  65E6 26 00           LD H, 0
 658  65E8 CD 63 65        CALL LOCAL_ENASLT
 659  65EB FD E9        	JP (IY)
 660  65ED              ; *******************************************************************************************************
 661  65ED
 662  65ED              ; General BASIC CALL-instruction handler
 663  65ED              CALLHAND:
 664  65ED FB              EI
 665  65EE E5           	PUSH HL
 666  65EF 21 22 63     	LD	HL, CMDS ; pointer table based on starting letter
 667  65F2 3A 89 FD        LD A, (PROCNM)
 668  65F5 D6 41           SUB 'A'
 669  65F7 87              ADD A, A
 670  65F8 16 00           LD D, 0
 671  65FA 5F              LD E, A
 672  65FB 19              ADD HL, DE
 673  65FC 5E              LD E, (HL)
 674  65FD 23              INC HL
 675  65FE 56              LD D, (HL)
 676  65FF 7A              LD A, D
 677  6600 B3              OR E
 678  6601 28 23           JR Z, .CMDNOTRECOGNIZED
 679  6603 EB              EX DE, HL
 680  6604              .CHKCMD:
 681  6604 11 89 FD     	LD	DE, PROCNM
 682  6607              .LOOP:
 683  6607 1A              LD	A,(DE)
 684  6608 BE           	CP	(HL)
 685  6609 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 686  660B 13           	INC	DE
 687  660C 23           	INC	HL
 688  660D A7           	AND	A
 689  660E 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 690  6610 5E           	LD	E,(HL)
 691  6611 23           	INC	HL
 692  6612 56           	LD	D,(HL)
 693  6613 E1           	POP	HL		; routine address
 694  6614 CD 35 66     	CALL	GETPREVCHAR
 695  6617 CD 29 66     	CALL	.CALLDE		; Call routine
 696  661A A7           	AND	A
 697  661B C9           	RET
 698  661C
 699  661C              .TONEXTCMD:
 700  661C 0E FF        	LD	C,0FFH
 701  661E AF           	XOR	A
 702  661F ED B1        	CPIR			; Skip to end of instruction name
 703  6621 23           	INC	HL
 704  6622 23           	INC	HL		; Skip address
 705  6623 BE           	CP	(HL)
 706  6624 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 707  6626              .CMDNOTRECOGNIZED:
 708  6626 E1           	POP	HL
 709  6627 37              SCF
 710  6628 C9           	RET
 711  6629
 712  6629              .CALLDE:
 713  6629 D5           	PUSH	DE
 714  662A C9           	RET
 715  662B
 716  662B              ;---------------------------
 717  662B
 718  662B              ;GETSTRPNT:
 719  662B              ; OUT:
 720  662B              ; HL = String Address
 721  662B              ; B  = Lenght
 722  662B              ;        LD      HL,(USR)
 723  662B              ;        LD      B,(HL)
 724  662B              ;        INC     HL
 725  662B              ;        LD      E,(HL)
 726  662B              ;        INC     HL
 727  662B              ;        LD      D,(HL)
 728  662B              ;        EX      DE,HL
 729  662B              ;        RET
 730  662B
 731  662B              ;EVALTXTPARAM:
 732  662B              ;	CALL	CHKCHAR
 733  662B              ;	DEFB	"("             ; Check for (
 734  662B              ;	LD	IX,FRMEVL
 735  662B              ;	CALL	CALBAS		; Evaluate expression
 736  662B              ;       LD      A,(VALTYP)
 737  662B              ;        CP      3               ; Text type?
 738  662B              ;        JP      NZ,TYPE_MISMATCH
 739  662B              ;        PUSH	HL
 740  662B              ;        LD	IX,FRESTR         ; Free the temporary string
 741  662B              ;        CALL	CALBAS
 742  662B              ;        POP	HL
 743  662B              ;	CALL	CHKCHAR
 744  662B              ;	DEFB	")"             ; Check for )
 745  662B              ;        RET
 746  662B
 747  662B
 748  662B              CHKCHAR:
 749  662B CD 35 66     	CALL	GETPREVCHAR	; Get previous basic char
 750  662E E3           	EX	(SP),HL
 751  662F BE           	CP	(HL) 	        ; Check if good char
 752  6630 20 1D        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 753  6632 23           	INC	HL
 754  6633 E3           	EX	(SP),HL
 755  6634 23           	INC	HL		; Get next basic char
 756  6635
 757  6635              GETPREVCHAR:
 758  6635 2B           	DEC HL
 759  6636 DD 21 66 46  	LD	IX,CHRGTR
 760  663A CD 59 01     	CALL CALBAS
 761  663D FB              EI
 762  663E C9              RET
 763  663F
 764  663F
 765  663F              TYPE_MISMATCH:
 766  663F 1E 0D            LD E, 13 ; Type mismatch
 767  6641 18 0E            JR THROW_ERROR
 768  6643              SUBSCRIPT_OUT_OF_RANGE:
 769  6643 1E 09            LD E,9 ; subscript out of range
 770  6645 18 0A        	JR THROW_ERROR
 771  6647              OVERFLOW:
 772  6647 1E 06        	LD E,6
 773  6649 18 06        	JR THROW_ERROR
 774  664B              ILLEGAL_FUNCTION:
 775  664B 1E 05            LD E, 5 ; illegal function call
 776  664D 18 02            JR THROW_ERROR
 777  664F              SYNTAX_ERROR:
 778  664F 1E 02            LD E, 2 ; Syntax error
 779  6651              THROW_ERROR:
 780  6651 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 781  6655 C3 59 01     	JP	CALBAS
 782  6658
 783  6658              ;---------------------------
 784  6658
 785  6658               IF (1 == 1)
 786  6658              ; *******************************************************************************************************
 787  6658              ; helper function to get pointer to BASIC array data
 788  6658              ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
 789  6658              ; input B=dimensions (1 or 2)
 790  6658              ; input D=minimal first dimension
 791  6658              ; input E=minimal second dimension, if applicable
 792  6658              ; returns BC=pointer to first data element
 793  6658              ; throws BASIC error if invalid type
 794  6658              GET_BASIC_ARRAY_DATA_POINTER:
 795  6658 D5           	PUSH DE
 796  6659 C5           	PUSH BC
 797  665A F5           	PUSH AF
 798  665B 3E 01           LD A,1
 799  665D 32 A5 F6        LD (SUBFLG),A ; search for arrays only
 800  6660 DD 21 A4 5E  	LD IX, PTRGET
 801  6664 CD 59 01     	CALL CALBAS
 802  6667 AF              XOR A
 803  6668 32 A5 F6        LD (SUBFLG),A ; if not reset will cause syntax errors
 804  666B 3A 63 F6     	LD A,(VALTYP)
 805  666E D1           	POP DE ; required type
 806  666F BA           	CP D
 807  6670 C2 3F 66     	JP NZ,TYPE_MISMATCH
 808  6673 0A           	LD A,(BC)
 809  6674 03           	INC BC
 810  6675 D1           	POP DE ; required number of dimensions
 811  6676 BA           	CP D
 812  6677 C2 3F 66     	JP NZ,TYPE_MISMATCH
 813  667A D1           	POP DE ; required minimal array dimensions
 814  667B 3D           	DEC A
 815  667C 28 07        	JR Z,.ONE_DIMENSION
 816  667E              	; 2-dimension array
 817  667E 0A           	LD A,(BC)
 818  667F 03          > INC BC
 818  6680 03          > INC BC
 819  6681 BB           	CP E
 820  6682 DA 43 66     	JP C,SUBSCRIPT_OUT_OF_RANGE
 821  6685              .ONE_DIMENSION:
 822  6685 0A           	LD A,(BC)
 823  6686 03          > INC BC
 823  6687 03          > INC BC
 824  6688 BA           	CP D
 825  6689 DA 43 66     	JP C,SUBSCRIPT_OUT_OF_RANGE
 826  668C C9           	RET
 827  668D              ; *******************************************************************************************************
 828  668D               ENDIF
 829  668D
 830  668D              ; *******************************************************************************************************
 831  668D              ; function to handle CALL ARTINFO basic extension
 832  668D              ; returns info about the extension
 833  668D              ; _ARTINFO ( INT variable version,
 834  668D              ;			    INT variable build_flags,
 835  668D              ;			    INT variable free_memory_ptr )
 836  668D              ; this function is always available and can be used to test if the extension is active
 837  668D              ARTINFO:
 838  668D              	; opening (
 839  668D CD 2B 66     	CALL CHKCHAR
 840  6690 28           	DB '('
 841  6691              	; get address of version variable
 842  6691 DD 21 A4 5E  	LD IX, PTRGET
 843  6695 CD 59 01     	CALL CALBAS
 844  6698 3A 12 40     	LD A,(VERSION)
 845  669B 12              LD (DE),A
 846  669C 13              INC DE
 847  669D 3A 13 40        LD A,(VERSION+1)
 848  66A0 12              LD (DE),A
 849  66A1              	; comma
 850  66A1 CD 2B 66     	CALL CHKCHAR
 851  66A4 2C           	DB ','
 852  66A5              	; get address of build flags variable
 853  66A5 DD 21 A4 5E  	LD IX, PTRGET
 854  66A9 CD 59 01     	CALL CALBAS
 855  66AC E5              PUSH HL
 856  66AD 21 FF 17        LD HL,SOUND_CMDS+2*RAM_CMDS+4*VRAM_CMDS+8*BLIT_CMDS+16*SPRITE_CMDS+32*GENCAL_CMD+64*TILE_CMDS+128*BOX_CMDS+256*ANIM_CMDS+512*COLL_CMD+1024*1+2048*0+4096*DECOMP_CMDS
 857  66B0 EB              EX DE,HL
 858  66B1 73              LD (HL),E
 859  66B2 23              INC HL
 860  66B3 72              LD (HL),D
 861  66B4 E1              POP HL
 862  66B5              	; comma
 863  66B5 CD 2B 66     	CALL CHKCHAR
 864  66B8 2C           	DB ','
 865  66B9              	; get address of free memory variable
 866  66B9 DD 21 A4 5E  	LD IX, PTRGET
 867  66BD CD 59 01     	CALL CALBAS
 868  66C0 3A 10 40     	LD A,(FREEMEMPTR)
 869  66C3 12              LD (DE),A
 870  66C4 13              INC DE
 871  66C5 3A 11 40        LD A,(FREEMEMPTR+1)
 872  66C8 12              LD (DE),A
 873  66C9              	; ending )
 874  66C9 CD 2B 66     	CALL CHKCHAR
 875  66CC 29           	DB ')'
 876  66CD C9           	RET
 877  66CE              ; *******************************************************************************************************
 878  66CE
 879  66CE              EXT_END:
 880  66CE
# file closed: asm\main.asm
