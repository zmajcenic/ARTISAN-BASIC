# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		   EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000              COLL_CMD       EQU 1
  14  4000              DECOMP_CMDS    EQU 1
  15  4000              DLOAD_CMD      EQU 1
  16  4000
  17  4000              ; what to compile, provided in sjasmplus command line
  18  4000              ;BASIC_EXTENSION   EQU 1
  19  4000              ;DEFUSR_EXTENSION  EQU 0
  20  4000
  21  4000              CHPUT   EQU    #A2
  22  4000              CALBAS  EQU		#159
  23  4000              ERRHAND EQU    #406F
  24  4000              FRMEVL  EQU    #4C64
  25  4000              FRESTR  EQU		#67D0
  26  4000              ; FRMQNT = formula quantificator
  27  4000              ; input HL=pointer to current program expression
  28  4000              ; output HL=next address
  29  4000              ; output DE=integer datum
  30  4000              FRMQNT	EQU		#542F
  31  4000              ; GETBYT = get byte parameter
  32  4000              ; input HL=pointer to current program expression
  33  4000              ; output HL=next address
  34  4000              ; output A=E=byte read
  35  4000              GETBYT		EQU	#521C
  36  4000              CHRGTR  	   EQU   #4666
  37  4000              PTRGET		EQU 	#5EA4
  38  4000              SUBFLG		EQU	#F6A5
  39  4000              SYNCHR		EQU	#558C
  40  4000              VALTYP  	   EQU   #F663
  41  4000              DAC         EQU   #F7F6
  42  4000              USR     	   EQU   #F7F8
  43  4000              PROCNM		EQU	#FD89
  44  4000              BIOS_FILVRM EQU   #0056
  45  4000              CLIKSW		EQU	#F3DB
  46  4000
  47  4000              RAMAD0	   EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  48  4000              RAMAD1	   EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  49  4000              RAMAD2	   EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  50  4000              RAMAD3	   EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  51  4000              EXPTBL	   EQU   #FCC1
  52  4000              SCRMOD	   EQU   #FCAF ; current screen mode
  53  4000              REG1SAV     EQU   #F3E0 ; VDP(1)
  54  4000              JIFFY	      EQU   #FC9E
  55  4000              GRPPAT	   EQU   #F3CF ; SCREEN 2 sprite generator table address
  56  4000              GRPCGP		EQU	#F3CB ; SCREEN 2 pattern generator table address
  57  4000              GRPATR      EQU   #F3CD ; SCREEN 2 sprite attribute table address
  58  4000              T32PAT	   EQU   #F3C5 ; SCREEN 1 sprite generator table address
  59  4000              T32CGP      EQU   #F3C1 ; SCREEN 1 pattern ganarator table address
  60  4000              T32ATR      EQU   #F3C3 ; SCREEN 1 sprite attribute table address
  61  4000
  62  4000              FCB0        EQU   #F353 ; location of FCB 0
  63  4000              BDOS        EQU   #F37D ; disk functions
  64  4000              NULBUF      EQU   #F862 ; disk buffer of 256 bytes address
  65  4000
  66  4000              ; BASIC error codes
  67  4000              ;01 NEXT without FOR
  68  4000              ;02 Syntax error
  69  4000              ;03 RETURN without GOSUB
  70  4000              ;04 Out of DATA
  71  4000              ;05 Illegal function call
  72  4000              ;06 Overflow
  73  4000              ;07 Out of memory
  74  4000              ;08 Undefined line number
  75  4000              ;09 Subscript out of range
  76  4000              ;10 Redimensioned array
  77  4000              ;11 Division by zero
  78  4000              ;12 Illegal direct
  79  4000              ;13 Type mismatch
  80  4000              ;14 Out of string space
  81  4000              ;15 String too long
  82  4000              ;16 String formula too complex
  83  4000              ;17 Can't CONTINUE
  84  4000              ;18 Undefined user function
  85  4000              ;19 Device I/O error
  86  4000              ;20 Verify error
  87  4000              ;21 No RESUME
  88  4000              ;22 RESUME without error
  89  4000              ;23 Unprintable error
  90  4000              ;24 Missing operand
  91  4000              ;25 Line buffer overflow
  92  4000              ;50 FIELD overflow
  93  4000              ;51 Internal error
  94  4000              ;52 Bad file number
  95  4000              ;53 File not found
  96  4000              ;54 File already open
  97  4000              ;55 Input past end
  98  4000              ;56 Bad file name
  99  4000              ;57 Direct statement in file
 100  4000              ;58 Sequential I/O only
 101  4000              ;59 File not OPEN
 102  4000
 103  4000
 104  4000               ; simulate cartridge with BASIC extension
 105  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
 105  4004 4A 67 00 00
 105  4008 00 00 00 00
 105  400C 00 00 00 00
 106  4010
 107  4010              ; this location #4010 stores last location used by basic extension
 108  4010              ; free memory after that point
 109  4010              FREEMEMPTR:
 110  4010 63 68         DW EXT_END
 111  4012
 112  4012              ; this location #4012 stores extension version in DAA format
 113  4012              ; first byte is major version and second minor
 114  4012              VERSION:
 115  4012 00 93         DB #00, #93
 116  4014
 117  4014              ; this location #4014 contains a jump to entry point for DEFUSR approach
 118  4014              ; if excluded it contains 3xRET so that sound player can be at aspecific spot
 119  4014               IF (0 == 1)
 120  4014 ~               JP DEFUSR_ENTRY
 121  4014               ELSE
 122  4014 C9          > RET
 122  4015 C9          > RET
 122  4016 C9          > RET
 123  4017               ENDIF
 124  4017
 125  4017              ; binary included AKG player compiled at #4017
 126  4017               IF (SOUND_CMDS == 1)
 127  4017              	INCBIN "bin/AKG.bin"
 128  4CF3              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF3              MAIN_PLAYER_START EQU 04017H
   2+ 4CF3              PLY_AKG_START EQU 04017H
   3+ 4CF3              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 04020H
   4+ 4CF3              PLY_AKG_INITSOUNDEFFECTS EQU 04020H
   5+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04024H
   6+ 4CF3              PLY_AKG_PLAYSOUNDEFFECT EQU 04024H
   7+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04025H
   8+ 4CF3              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04025H
   9+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 0404CH
  10+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 0404CH
  11+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 0405AH
  12+ 4CF3              PLY_AKG_PSES_PLAY EQU 04093H
  13+ 4CF3              PLY_AKG_PSES_READFIRSTBYTE EQU 0409CH
  14+ 4CF3              PLY_AKG_PSES_S_ENDORLOOP EQU 040B4H
  15+ 4CF3              PLY_AKG_PSES_S_LOOP EQU 040BFH
  16+ 4CF3              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C5H
  17+ 4CF3              PLY_AKG_PSES_NOTREACHED EQU 040D8H
  18+ 4CF3              PLY_AKG_PSES_HARDWAREONLY EQU 040DCH
  19+ 4CF3              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E3H
  20+ 4CF3              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F5H
  21+ 4CF3              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FFH
  22+ 4CF3              PLY_AKG_PSES_H_AFTERRETRIG EQU 04109H
  23+ 4CF3              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411DH
  24+ 4CF3              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 04122H
  25+ 4CF3              PLY_AKG_PSES_READHARDWAREPERIOD EQU 0412AH
  26+ 4CF3              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04135H
  27+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 04141H
  28+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04143H
  29+ 4CF3              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04149H
  30+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414DH
  31+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414DH
  32+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414FH
  33+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414FH
  34+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414FH
  35+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 04150H
  36+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 04151H
  37+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04155H
  38+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04155H
  39+ 4CF3              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04155H
  40+ 4CF3              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415DH
  41+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04165H
  42+ 4CF3              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04165H
  43+ 4CF3              PLY_AKG_INIT EQU 04165H
  44+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04165H
  45+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04193H
  46+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A7H
  47+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B9H
  48+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D8H
  49+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E5H
  50+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL EQU 041EBH
  51+ 4CF3              PLY_AKG_INITTABLE0 EQU 041EEH
  52+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EEH
  53+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04208H
  54+ 4CF3              PLY_AKG_INITTABLE0_END EQU 04208H
  55+ 4CF3              PLY_AKG_INITTABLE1 EQU 04208H
  56+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04208H
  57+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 0420CH
  58+ 4CF3              PLY_AKG_INITTABLE1_END EQU 0420CH
  59+ 4CF3              PLY_AKG_INITTABLEORA EQU 0420CH
  60+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 0420CH
  61+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04224H
  62+ 4CF3              PLY_AKG_INITTABLEORA_END EQU 04224H
  63+ 4CF3              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04224H
  64+ 4CF3              PLY_AKG_STOP EQU 04224H
  65+ 4CF3              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04236H
  66+ 4CF3              PLY_AKG_PLAY EQU 04236H
  67+ 4CF3              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423EH
  68+ 4CF3              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04244H
  69+ 4CF3              PLY_AKG_READLINKER EQU 04249H
  70+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04249H
  71+ 4CF3              PLY_AKG_READLINKER_PTLINKER EQU 04249H
  72+ 4CF3              PLY_AKG_READLINKER_NOLOOP EQU 04254H
  73+ 4CF3              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428DH
  74+ 4CF3              PLY_AKG_READLINE EQU 04290H
  75+ 4CF3              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 04290H
  76+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04296H
  77+ 4CF3              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04296H
  78+ 4CF3              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A3H
  79+ 4CF3              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A7H
  80+ 4CF3              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042AAH
  81+ 4CF3              PLY_AKG_SPEEDTRACK_END EQU 042ADH
  82+ 4CF3              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042ADH
  83+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B3H
  84+ 4CF3              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B3H
  85+ 4CF3              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042C0H
  86+ 4CF3              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C4H
  87+ 4CF3              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C7H
  88+ 4CF3              PLY_AKG_EVENTTRACK_END EQU 042CAH
  89+ 4CF3              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042CAH
  90+ 4CF3              PLY_AKG_CHANNEL1_READTRACK EQU 042D6H
  91+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D6H
  92+ 4CF3              PLY_AKG_CHANNEL1_PTTRACK EQU 042D6H
  93+ 4CF3              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042F1H
  94+ 4CF3              PLY_AKG_CHANNEL1_WAIT EQU 042FCH
  95+ 4CF3              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04303H
  96+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04303H
  97+ 4CF3              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04303H
  98+ 4CF3              PLY_AKG_CHANNEL1_NOTE EQU 0430CH
  99+ 4CF3              PLY_AKG_BASENOTEINDEX EQU 0430CH
 100+ 4CF3              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430EH
 101+ 4CF3              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430EH
 102+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431EH
 103+ 4CF3              PLY_AKG_INSTRUMENTSTABLE EQU 0431EH
 104+ 4CF3              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 04330H
 105+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 04340H
 106+ 4CF3              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04368H
 107+ 4CF3              PLY_AKG_CHANNEL1_READCELLEND EQU 0436BH
 108+ 4CF3              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 0436BH
 109+ 4CF3              PLY_AKG_CHANNEL2_READTRACK EQU 04377H
 110+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04377H
 111+ 4CF3              PLY_AKG_CHANNEL2_PTTRACK EQU 04377H
 112+ 4CF3              PLY_AKG_CHANNEL2_SMALLWAIT EQU 04392H
 113+ 4CF3              PLY_AKG_CHANNEL2_WAIT EQU 0439DH
 114+ 4CF3              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A4H
 115+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A4H
 116+ 4CF3              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A4H
 117+ 4CF3              PLY_AKG_CHANNEL2_NOTE EQU 043ADH
 118+ 4CF3              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043B2H
 119+ 4CF3              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043B2H
 120+ 4CF3              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D4H
 121+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E4H
 122+ 4CF3              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 0440CH
 123+ 4CF3              PLY_AKG_CHANNEL2_READCELLEND EQU 0440FH
 124+ 4CF3              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440FH
 125+ 4CF3              PLY_AKG_CHANNEL3_READTRACK EQU 0441BH
 126+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 0441BH
 127+ 4CF3              PLY_AKG_CHANNEL3_PTTRACK EQU 0441BH
 128+ 4CF3              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04436H
 129+ 4CF3              PLY_AKG_CHANNEL3_WAIT EQU 04441H
 130+ 4CF3              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04448H
 131+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04448H
 132+ 4CF3              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04448H
 133+ 4CF3              PLY_AKG_CHANNEL3_NOTE EQU 04451H
 134+ 4CF3              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04456H
 135+ 4CF3              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04456H
 136+ 4CF3              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04478H
 137+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04488H
 138+ 4CF3              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044B0H
 139+ 4CF3              PLY_AKG_CHANNEL3_READCELLEND EQU 044B3H
 140+ 4CF3              PLY_AKG_CURRENTSPEED EQU 044B3H
 141+ 4CF3              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B5H
 142+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B8H
 143+ 4CF3              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B8H
 144+ 4CF3              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044BBH
 145+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BEH
 146+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BEH
 147+ 4CF3              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044CAH
 148+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044D1H
 149+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D4H
 150+ 4CF3              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044DAH
 151+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DDH
 152+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DDH
 153+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044EBH
 154+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044F0H
 155+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044FBH
 156+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FEH
 157+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FEH
 158+ 4CF3              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 04501H
 159+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04504H
 160+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04504H
 161+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450DH
 162+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04517H
 163+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 0451AH
 164+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 0451AH
 165+ 4CF3              PLY_AKG_CHANNEL1_PITCH EQU 0451AH
 166+ 4CF3              PLY_AKG_CHANNEL1_ISPITCH EQU 0451DH
 167+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 04522H
 168+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACK EQU 04522H
 169+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04526H
 170+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04528H
 171+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 0452AH
 172+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 04531H
 173+ 4CF3              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 04532H
 174+ 4CF3              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04535H
 175+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04535H
 176+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 04551H
 177+ 4CF3              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 04551H
 178+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455EH
 179+ 4CF3              PLY_AKG_CHANNEL1_GLIDEOVER EQU 04562H
 180+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 04572H
 181+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 04572H
 182+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04573H
 183+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04574H
 184+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04576H
 185+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04576H
 186+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04576H
 187+ 4CF3              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04577H
 188+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04578H
 189+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 0457AH
 190+ 4CF3              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 0457AH
 191+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 0457AH
 192+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 0457AH
 193+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 0457AH
 194+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457DH
 195+ 4CF3              PLY_AKG_CHANNEL1_PITCH_END EQU 0457FH
 196+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04587H
 197+ 4CF3              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04587H
 198+ 4CF3              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 0458AH
 199+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458DH
 200+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458DH
 201+ 4CF3              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04599H
 202+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 045A0H
 203+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A3H
 204+ 4CF3              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A9H
 205+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045ACH
 206+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045ACH
 207+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045BAH
 208+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BFH
 209+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045CAH
 210+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CDH
 211+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CDH
 212+ 4CF3              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045D0H
 213+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D3H
 214+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D3H
 215+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045DCH
 216+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E6H
 217+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E9H
 218+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E9H
 219+ 4CF3              PLY_AKG_CHANNEL2_PITCH EQU 045E9H
 220+ 4CF3              PLY_AKG_CHANNEL2_ISPITCH EQU 045ECH
 221+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045F1H
 222+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045F1H
 223+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F5H
 224+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F7H
 225+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F9H
 226+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 04600H
 227+ 4CF3              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 04601H
 228+ 4CF3              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04604H
 229+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04604H
 230+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 04620H
 231+ 4CF3              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 04620H
 232+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462DH
 233+ 4CF3              PLY_AKG_CHANNEL2_GLIDEOVER EQU 04631H
 234+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 04641H
 235+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 04641H
 236+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 04642H
 237+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04643H
 238+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04645H
 239+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04645H
 240+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04645H
 241+ 4CF3              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04646H
 242+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04647H
 243+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04649H
 244+ 4CF3              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04649H
 245+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04649H
 246+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04649H
 247+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04649H
 248+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_END EQU 0464CH
 249+ 4CF3              PLY_AKG_CHANNEL2_PITCH_END EQU 0464EH
 250+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04656H
 251+ 4CF3              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04656H
 252+ 4CF3              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04659H
 253+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 0465CH
 254+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 0465CH
 255+ 4CF3              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04668H
 256+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466FH
 257+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 04672H
 258+ 4CF3              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04678H
 259+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 0467BH
 260+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 0467BH
 261+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04689H
 262+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468EH
 263+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04699H
 264+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 0469CH
 265+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 0469CH
 266+ 4CF3              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469FH
 267+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 046A2H
 268+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE EQU 046A2H
 269+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046ABH
 270+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B5H
 271+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B8H
 272+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B8H
 273+ 4CF3              PLY_AKG_CHANNEL3_PITCH EQU 046B8H
 274+ 4CF3              PLY_AKG_CHANNEL3_ISPITCH EQU 046BBH
 275+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046C0H
 276+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046C0H
 277+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C4H
 278+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C6H
 279+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C8H
 280+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CFH
 281+ 4CF3              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046D0H
 282+ 4CF3              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D3H
 283+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D3H
 284+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046EFH
 285+ 4CF3              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046EFH
 286+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046FCH
 287+ 4CF3              PLY_AKG_CHANNEL3_GLIDEOVER EQU 04700H
 288+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 04710H
 289+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 04710H
 290+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 04711H
 291+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 04712H
 292+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04714H
 293+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04714H
 294+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04714H
 295+ 4CF3              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04715H
 296+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04716H
 297+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04718H
 298+ 4CF3              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04718H
 299+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04718H
 300+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04718H
 301+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04718H
 302+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_END EQU 0471BH
 303+ 4CF3              PLY_AKG_CHANNEL3_PITCH_END EQU 0471DH
 304+ 4CF3              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04729H
 305+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04729H
 306+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04729H
 307+ 4CF3              PLY_AKG_CHANNEL1_TRACKNOTE EQU 0472CH
 308+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472EH
 309+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04734H
 310+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04737H
 311+ 4CF3              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04737H
 312+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 0473AH
 313+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04743H
 314+ 4CF3              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 0474BH
 315+ 4CF3              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04758H
 316+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04758H
 317+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04758H
 318+ 4CF3              PLY_AKG_CHANNEL2_TRACKNOTE EQU 0475BH
 319+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475DH
 320+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04763H
 321+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04766H
 322+ 4CF3              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04766H
 323+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04769H
 324+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 04772H
 325+ 4CF3              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 0477AH
 326+ 4CF3              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04788H
 327+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04788H
 328+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04788H
 329+ 4CF3              PLY_AKG_CHANNEL3_TRACKNOTE EQU 0478BH
 330+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478DH
 331+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04793H
 332+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04796H
 333+ 4CF3              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04796H
 334+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04799H
 335+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 047A2H
 336+ 4CF3              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047AAH
 337+ 4CF3              PLY_AKG_SENDPSGREGISTERS EQU 047B9H
 338+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047C1H
 339+ 4CF3              PLY_AKG_PSGREG01_INSTR EQU 047C1H
 340+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047D1H
 341+ 4CF3              PLY_AKG_PSGREG23_INSTR EQU 047D1H
 342+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047E2H
 343+ 4CF3              PLY_AKG_PSGREG45_INSTR EQU 047E2H
 344+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F3H
 345+ 4CF3              PLY_AKG_PSGREG6_8_INSTR EQU 047F3H
 346+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04804H
 347+ 4CF3              PLY_AKG_PSGREG9_10_INSTR EQU 04804H
 348+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04815H
 349+ 4CF3              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04815H
 350+ 4CF3              PLY_AKG_PSGREG13_OLDVALUE EQU 0482AH
 351+ 4CF3              PLY_AKG_RETRIG EQU 0482CH
 352+ 4CF3              PLY_AKG_PSGREG13_INSTR EQU 0482EH
 353+ 4CF3              PLY_AKG_PSGREG13_END EQU 0483DH
 354+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483DH
 355+ 4CF3              PLY_AKG_SAVESP EQU 0483DH
 356+ 4CF3              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 04841H
 357+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTS EQU 04849H
 358+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04856H
 359+ 4CF3              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04856H
 360+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485EH
 361+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 0486BH
 362+ 4CF3              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 0486BH
 363+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTS EQU 04873H
 364+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487EH
 365+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS EQU 0487EH
 366+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488DH
 367+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488DH
 368+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04894H
 369+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A4H
 370+ 4CF3              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A4H
 371+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048ABH
 372+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048ABH
 373+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048AEH
 374+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B7H
 375+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B7H
 376+ 4CF3              PLY_AKG_READINSTRUMENTCELL EQU 048BDH
 377+ 4CF3              PLY_AKG_NOSOFTNOHARD EQU 048CAH
 378+ 4CF3              PLY_AKG_NSNH_NONOISE EQU 048DFH
 379+ 4CF3              PLY_AKG_SOFT EQU 048E2H
 380+ 4CF3              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E9H
 381+ 4CF3              PLY_AKG_S_NOTSIMPLE EQU 048F1H
 382+ 4CF3              PLY_AKG_S_AFTERSIMPLETEST EQU 048F4H
 383+ 4CF3              PLY_AKG_HARDTOSOFT EQU 04901H
 384+ 4CF3              PLY_AKG_HS_JUMPRATIO EQU 0490CH
 385+ 4CF3              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04939H
 386+ 4CF3              PLY_AKG_ENDWITHOUTLOOP EQU 0493BH
 387+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 0493BH
 388+ 4CF3              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 0493BH
 389+ 4CF3              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04943H
 390+ 4CF3              PLY_AKG_SH_JUMPRATIO EQU 04950H
 391+ 4CF3              PLY_AKG_SH_JUMPRATIOEND EQU 04971H
 392+ 4CF3              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 04980H
 393+ 4CF3              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04986H
 394+ 4CF3              PLY_AKG_H_OR_ENDWITHLOOP EQU 049A0H
 395+ 4CF3              PLY_AKG_H_RETRIGEND EQU 049B2H
 396+ 4CF3              PLY_AKG_H_AFTERRETRIG EQU 049B3H
 397+ 4CF3              PLY_AKG_ENDWITHLOOP EQU 049C5H
 398+ 4CF3              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049CCH
 399+ 4CF3              PLY_AKG_S_OR_H_NEXTBYTE EQU 049E2H
 400+ 4CF3              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049F0H
 401+ 4CF3              PLY_AKG_S_OR_H_AFTERPITCH EQU 04A00H
 402+ 4CF3              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0EH
 403+ 4CF3              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1DH
 404+ 4CF3              PLY_AKG_SHOHS_RETRIGEND EQU 04A2CH
 405+ 4CF3              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2DH
 406+ 4CF3              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3FH
 407+ 4CF3              PLY_AKG_EFFECTTABLE EQU 04A4DH
 408+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4DH
 409+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A71H
 410+ 4CF3              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A71H
 411+ 4CF3              PLY_AKG_EFFECT_RESET EQU 04A74H
 412+ 4CF3              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A76H
 413+ 4CF3              PLY_AKG_EFFECT_VOLUME EQU 04A91H
 414+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9DH
 415+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA3H
 416+ 4CF3              PLY_AKG_ARPEGGIOSTABLE EQU 04AA3H
 417+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04ACAH
 418+ 4CF3              PLY_AKG_EFFECT_PITCHTABLE EQU 04AD1H
 419+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD7H
 420+ 4CF3              PLY_AKG_PITCHESTABLE EQU 04AD7H
 421+ 4CF3              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFEH
 422+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B05H
 423+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B16H
 424+ 4CF3              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1DH
 425+ 4CF3              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2DH
 426+ 4CF3              PLY_AKG_EFFECT_PITCHUP EQU 04B42H
 427+ 4CF3              PLY_AKG_EFFECT_PITCHSTOP EQU 04B54H
 428+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B5BH
 429+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B85H
 430+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B85H
 431+ 4CF3              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9EH
 432+ 4CF3              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9EH
 433+ 4CF3              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BB0H
 434+ 4CF3              PLY_AKG_EFFECT_LEGATO EQU 04BC6H
 435+ 4CF3              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BDAH
 436+ 4CF3              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BE2H
 437+ 4CF3              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BEAH
 438+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BF2H
 439+ 4CF3              PLY_AKG_EVENT EQU 04BF2H
 440+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF3H
 441+ 4CF3              PLY_AKG_PERIODTABLE EQU 04BF3H
 442+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF3H
 443+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF3H
 444+ 4CF3              PLY_AKG_PERIODTABLE_END EQU 04CF3H
 445+ 4CF3              PLY_AKG_END EQU 04CF3H
 446+ 4CF3              MAIN_PLAYER_END EQU 04CF3H
 447+ 4CF3              TESTEREND EQU 04CF3H
 448+ 4CF3
# file closed: ./symbol/AKG.sym
 129  4CF3               ENDIF
 130  4CF3
 131  4CF3               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
   1+ 4CF3              ORIG.HTIMI:
   2+ 4CF3 00 00 00 00  	DB 0, 0, 0, 0, 0
   2+ 4CF7 00
   3+ 4CF8               EXPORT ORIG.HTIMI
   4+ 4CF8
   5+ 4CF8              ; *******************************************************************************************************
   6+ 4CF8              ; interrupt handler when page 0 enabled
   7+ 4CF8              ; we are here only if one of the extended basic commands have paged in page 0
   8+ 4CF8              ; which means we arrived from BASIC so page 2 is already good
   9+ 4CF8              VBLANK:
  10+ 4CF8              	EXPORT VBLANK
  11+ 4CF8
  12+ 4CF8 F5               PUSH AF
  13+ 4CF9              	; is VDP originator ?
  14+ 4CF9 DB 99        	IN	A, (099H)
  15+ 4CFB A7           	AND	A
  16+ 4CFC F2 2A 4D     	JP P, .EXIT
  17+ 4CFF
  18+ 4CFF               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  19+ 4CFF C5               PUSH BC
  20+ 4D00 D5               PUSH DE
  21+ 4D01 E5               PUSH HL
  22+ 4D02 08               EX AF, AF'
  23+ 4D03 D9               EXX
  24+ 4D04 F5               PUSH AF
  25+ 4D05 C5               PUSH BC
  26+ 4D06 D5               PUSH DE
  27+ 4D07 E5               PUSH HL
  28+ 4D08 DD E5            PUSH IX
  29+ 4D0A FD E5            PUSH IY
  30+ 4D0C
  31+ 4D0C               IF (SPRITE_CMDS == 1)
  32+ 4D0C CD 64 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  33+ 4D0F               ENDIF
  34+ 4D0F
  35+ 4D0F               IF (SOUND_CMDS == 1)
  36+ 4D0F 3A C4 58     	LD A, (SOUND_ENABLED)
  37+ 4D12 B7           	OR A
  38+ 4D13 C4 36 42     	CALL NZ,PLY_AKG_PLAY
  39+ 4D16               ENDIF
  40+ 4D16
  41+ 4D16                  ; increase JIFFY
  42+ 4D16 2A 9E FC         LD HL,(JIFFY)
  43+ 4D19 23               INC HL
  44+ 4D1A 22 9E FC         LD (JIFFY),HL
  45+ 4D1D
  46+ 4D1D FD E1            POP IY
  47+ 4D1F DD E1            POP IX
  48+ 4D21 E1               POP HL
  49+ 4D22 D1               POP DE
  50+ 4D23 C1               POP BC
  51+ 4D24 F1               POP AF
  52+ 4D25 08               EX AF, AF'
  53+ 4D26 D9               EXX
  54+ 4D27 E1               POP HL
  55+ 4D28 D1               POP DE
  56+ 4D29 C1               POP BC
  57+ 4D2A               ENDIF
  58+ 4D2A
  59+ 4D2A              .EXIT:
  60+ 4D2A F1           	POP AF
  61+ 4D2B FB           	EI
  62+ 4D2C ED 4D        	RETI
  63+ 4D2E              ; *******************************************************************************************************
  64+ 4D2E
  65+ 4D2E              ; *******************************************************************************************************
  66+ 4D2E              ; H.TIMI function
  67+ 4D2E              ; we can end up here from anywhere so page in both page 0 and 2
  68+ 4D2E              MBGE_HTIMI:
  69+ 4D2E               EXPORT MBGE_HTIMI
  70+ 4D2E
  71+ 4D2E               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  72+ 4D2E
  73+ 4D2E F5           	PUSH AF
  74+ 4D2F
  75+ 4D2F              	; enable page 2
  76+ 4D2F 3E 02            LD A, 2
  77+ 4D31 CD 79 66         CALL GET_PAGE_INFO
  78+ 4D34 C5               PUSH BC
  79+ 4D35 D5               PUSH DE
  80+ 4D36 3A 43 F3         LD A, (RAMAD2)
  81+ 4D39 26 80            LD H, 080H
  82+ 4D3B CD C0 66         CALL LOCAL_ENASLT
  83+ 4D3E              	; enable page 0
  84+ 4D3E AF               XOR A
  85+ 4D3F CD 79 66         CALL GET_PAGE_INFO
  86+ 4D42 C5               PUSH BC
  87+ 4D43 D5               PUSH DE
  88+ 4D44 3A 41 F3         LD A, (RAMAD0)
  89+ 4D47 26 00            LD H, 0
  90+ 4D49 CD C0 66         CALL LOCAL_ENASLT
  91+ 4D4C
  92+ 4D4C               IF (SPRITE_CMDS == 1)
  93+ 4D4C CD 64 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  94+ 4D4F               ENDIF
  95+ 4D4F
  96+ 4D4F               IF (SOUND_CMDS == 1)
  97+ 4D4F 3A C4 58     	LD A, (SOUND_ENABLED)
  98+ 4D52 B7           	OR A
  99+ 4D53 C4 36 42     	CALL NZ,PLY_AKG_PLAY
 100+ 4D56               ENDIF
 101+ 4D56
 102+ 4D56              	; restore page 0
 103+ 4D56 D1               POP DE
 104+ 4D57 C1               POP BC
 105+ 4D58 CD B0 66         CALL RESTORE_PAGE_INFO
 106+ 4D5B              	; restore page 2
 107+ 4D5B D1               POP DE
 108+ 4D5C C1               POP BC
 109+ 4D5D CD B0 66         CALL RESTORE_PAGE_INFO
 110+ 4D60
 111+ 4D60 F1           	POP AF
 112+ 4D61               ENDIF
 113+ 4D61 C3 F3 4C     	JP ORIG.HTIMI
 114+ 4D64              ; *******************************************************************************************************
 115+ 4D64
 116+ 4D64              ; *******************************************************************************************************
 117+ 4D64              ; function checks if the sprite system is initialized and what screen mode we are running
 118+ 4D64              ; also checks if some VRAM modifying command is running
 119+ 4D64              ; when that checks out calls sprite updates and animation processing
 120+ 4D64              ; if in an unsupported mode disables sprite handling
 121+ 4D64              PROCESS_SPRITES_AND_ANIMATIONS:
 122+ 4D64              	; check if initialized
 123+ 4D64 3A 86 4D     	LD A, (SPRATR_INIT_STATUS)
 124+ 4D67 B7           	OR A
 125+ 4D68 C8           	RET Z
 126+ 4D69              	; check screen mode
 127+ 4D69 3A AF FC     	LD A, (SCRMOD)
 128+ 4D6C 3D           	DEC A
 129+ 4D6D 28 08        	JR Z, .L0 ; screen 1
 130+ 4D6F 3D           	DEC A
 131+ 4D70 28 05            JR Z, .L0 ; screen 2
 132+ 4D72              	; unsupported screen mode, disable
 133+ 4D72 AF               XOR A
 134+ 4D73 32 86 4D         LD (SPRATR_INIT_STATUS),A
 135+ 4D76 C9               RET
 136+ 4D77              .L0:
 137+ 4D77                  ; check if anyone else is working with VRAM
 138+ 4D77 3A 62 64         LD A,(VRAM_UPDATE_IN_PROGRESS)
 139+ 4D7A B7               OR A
 140+ 4D7B C0               RET NZ
 141+ 4D7C
 142+ 4D7C CD 9C 4D         CALL SPRATR_UPDATE
 143+ 4D7F
 144+ 4D7F               IF (ANIM_CMDS == 1)
 145+ 4D7F CD 7D 55         CALL PROCESS_ANIMATIONS
 146+ 4D82 CD 48 57         CALL PROCESS_AUTOSGAMS
 147+ 4D85               ENDIF
 148+ 4D85 C9               RET
 149+ 4D86              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
 132  4D86
 133  4D86               IF (SPRITE_CMDS == 1)
 134  4D86               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4D86              ; commands and variables related to sprites
   2+ 4D86
   3+ 4D86              SPRATR_INIT_STATUS:
   4+ 4D86 00            DB 0
   5+ 4D87              SPRATR_UPDATE_FLAG:
   6+ 4D87 00 00         DW 0
   7+ 4D89              SPRATR_DATA:
   8+ 4D89 00 00         DW 0
   9+ 4D8B              SPRFLICKER_ENABLED:
  10+ 4D8B 00            DB 0
  11+ 4D8C              ; to support sprite flicker
  12+ 4D8C              FLICKER:
  13+ 4D8C 00            DB 0
  14+ 4D8D              NUM_SPRITES_HANDLED:
  15+ 4D8D 20            DB 32
  16+ 4D8E
  17+ 4D8E              ; to temporarily store stack pointer
  18+ 4D8E              TMPSP:
  19+ 4D8E 00 00         DW 0
  20+ 4D90
  21+ 4D90              ; *******************************************************************************************************
  22+ 4D90              ; helper function gets pointer to n-th entry in sprite attributes
  23+ 4D90              ; changes HL,DE
  24+ 4D90              GETnthSPRATTR:
  25+ 4D90 26 00            LD H,0
  26+ 4D92 6F               LD L,A
  27+ 4D93 CD 75 66         CALL HLx8
  28+ 4D96 ED 5B 89 4D      LD DE,(SPRATR_DATA)
  29+ 4D9A 19               ADD HL,DE
  30+ 4D9B C9               RET
  31+ 4D9C              ; *******************************************************************************************************
  32+ 4D9C
  33+ 4D9C              ; *******************************************************************************************************
  34+ 4D9C              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  35+ 4D9C              ; struct {
  36+ 4D9C              ; DW y
  37+ 4D9C              ; DW x
  38+ 4D9C              ; DW pattern (0-63)
  39+ 4D9C              ; DW color
  40+ 4D9C              ; } [32]
  41+ 4D9C              ; will hide sprites whose location is outside of visible area
  42+ 4D9C              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  43+ 4D9C              ; modifies AF, AF', BC, DE, HL, IX
  44+ 4D9C              SPRATR_UPDATE:
  45+ 4D9C              	; check if update requested
  46+ 4D9C 2A 87 4D     	LD HL, (SPRATR_UPDATE_FLAG)
  47+ 4D9F 7E           	LD A, (HL)
  48+ 4DA0 B7           	OR A
  49+ 4DA1 C8           	RET Z
  50+ 4DA2
  51+ 4DA2 DD 21 8D 4D  	LD IX,NUM_SPRITES_HANDLED
  52+ 4DA6 DD 46 00     	LD B, (IX) ; sprite number
  53+ 4DA9 0E 98        	LD C, #98 ; register for vdp data output
  54+ 4DAB              	; set VDP address
  55+ 4DAB 3A AF FC         LD A,(SCRMOD)
  56+ 4DAE 3D               DEC A
  57+ 4DAF 20 05            JR NZ,.L4
  58+ 4DB1 2A C3 F3         LD HL, (T32ATR)
  59+ 4DB4 18 03            JR .L5
  60+ 4DB6              .L4:
  61+ 4DB6 2A CD F3         LD HL, (GRPATR)
  62+ 4DB9              .L5:
  63+ 4DB9 3A 8B 4D     	LD A, (SPRFLICKER_ENABLED)
  64+ 4DBC B7           	OR A
  65+ 4DBD 28 03        	JR Z, .L3
  66+ 4DBF 3A 8C 4D     	LD A, (FLICKER)
  67+ 4DC2              .L3:
  68+ 4DC2 5F           	LD E, A
  69+ 4DC3 08           	EX AF, AF'
  70+ 4DC4 7B           	LD A, E
  71+ 4DC5 87           	ADD A, A
  72+ 4DC6 87           	ADD A, A
  73+ 4DC7 16 00        	LD D, 0
  74+ 4DC9 5F           	LD E, A
  75+ 4DCA 19           	ADD HL, DE
  76+ 4DCB CD 56 66     	CALL SETWRT_LOCAL_WRITE
  77+ 4DCE ED 73 8E 4D  	LD (TMPSP), SP
  78+ 4DD2 ED 7B 89 4D  	LD SP, (SPRATR_DATA)
  79+ 4DD6
  80+ 4DD6              .LOOP:
  81+ 4DD6 E1           	POP HL
  82+ 4DD7 24           	INC H
  83+ 4DD8 28 0D        	JR Z, .L1 ; negative number between -256 and -1
  84+ 4DDA 25           	DEC H
  85+ 4DDB 20 15        	JR NZ, .OUT3 ; sprite vertically can't be visible
  86+ 4DDD 7D           	LD A, L
  87+ 4DDE FE C0        	CP 192
  88+ 4DE0 30 10        	JR NC, .OUT3
  89+ 4DE2 3D           	DEC A ; due to VDP rule that top of screen is -1
  90+ 4DE3 57           	LD D, A
  91+ 4DE4 C3 0B 4E     	JP .X
  92+ 4DE7              .L1:
  93+ 4DE7 7D           	LD A, L
  94+ 4DE8 C6 10        	ADD 16
  95+ 4DEA FA F2 4D     	JP M, .OUT3 ; below -16
  96+ 4DED 2D           	DEC L ; due to VDP rule that top of screen is -1
  97+ 4DEE 55           	LD D, L
  98+ 4DEF C3 0B 4E     	JP .X
  99+ 4DF2              .OUT3:
 100+ 4DF2 E1           	POP HL ; skip x value
 101+ 4DF3              .OUT2:
 102+ 4DF3 E1           	POP HL ; skip pattern
 103+ 4DF4 E1           	POP HL ; skip color
 104+ 4DF5 3E D1        	LD A, #D1
 105+ 4DF7 ED 79        	OUT (C), A ; sprite hidden
 106+ 4DF9 00          > NOP
 106+ 4DFA 00          > NOP
 106+ 4DFB 00          > NOP
 107+ 4DFC ED 79        	OUT (C), A ; value unimportant
 108+ 4DFE 00          > NOP
 108+ 4DFF 00          > NOP
 108+ 4E00 00          > NOP
 109+ 4E01 ED 79        	OUT (C), A ; value unimportant
 110+ 4E03 00          > NOP
 110+ 4E04 00          > NOP
 110+ 4E05 00          > NOP
 111+ 4E06 ED 79        	OUT (C), A ; value unimportant
 112+ 4E08 C3 36 4E     	JP .NEXT
 113+ 4E0B              .X:
 114+ 4E0B E1           	POP HL
 115+ 4E0C 24           	INC H
 116+ 4E0D 28 08        	JR Z, .L2
 117+ 4E0F 25           	DEC H
 118+ 4E10 20 E1        	JR NZ, .OUT2
 119+ 4E12 1E 00        	LD E, 0 ; EC bit
 120+ 4E14 C3 20 4E     	JP .XY
 121+ 4E17              .L2:
 122+ 4E17 7D           	LD A, L
 123+ 4E18 C6 20        	ADD 32
 124+ 4E1A FA F3 4D     	JP M, .OUT2
 125+ 4E1D 6F           	LD L, A
 126+ 4E1E 1E 80        	LD E, #80
 127+ 4E20              .XY:
 128+ 4E20 ED 51        	OUT (C), D
 129+ 4E22 3A E0 F3     	LD A, (REG1SAV)
 130+ 4E25 E6 02        	AND 2
 131+ 4E27 ED 69        	OUT (C), L
 132+ 4E29 E1           	POP HL ; pattern
 133+ 4E2A 7D           	LD A, L
 134+ 4E2B 28 02        	JR Z, .SMALLSPRITES
 135+ 4E2D 87           	ADD A, A
 136+ 4E2E 87           	ADD A, A ; needs to go at 4x
 137+ 4E2F              .SMALLSPRITES:
 138+ 4E2F D3 98        	OUT (#98), A
 139+ 4E31 E1           	POP HL ; color
 140+ 4E32 7D           	LD A, L
 141+ 4E33 B3           	OR E
 142+ 4E34 D3 98        	OUT (#98), A
 143+ 4E36              .NEXT:
 144+ 4E36 08           	EX AF, AF'
 145+ 4E37 3C           	INC A ; increase current sprite
 146+ 4E38 DD BE 00     	CP (IX) ; compare to maximum handled
 147+ 4E3B C2 5B 4E     	JP NZ, .NEXT2 ; continue if not over
 148+ 4E3E AF           	XOR A ; back to zero
 149+ 4E3F 08           	EX AF, AF'
 150+ 4E40 3A AF FC         LD A,(SCRMOD)
 151+ 4E43 3D               DEC A
 152+ 4E44 20 05            JR NZ,.L6
 153+ 4E46 2A C3 F3         LD HL, (T32ATR)
 154+ 4E49 18 03            JR .L7
 155+ 4E4B              .L6:
 156+ 4E4B 2A CD F3         LD HL, (GRPATR)
 157+ 4E4E              .L7:
 158+ 4E4E              	; CALL SETWRT_LOCAL not allowed as SP modified
 159+ 4E4E 7D           	LD	A, L
 160+ 4E4F D3 99        	OUT	(099H), A
 161+ 4E51 7C           	LD	A, H
 162+ 4E52 E6 3F        	AND	03FH
 163+ 4E54 F6 40        	OR	040H
 164+ 4E56 D3 99        	OUT	(099H), A
 165+ 4E58 C3 5C 4E     	JP .NEXT3
 166+ 4E5B              .NEXT2:
 167+ 4E5B 08           	EX AF, AF'
 168+ 4E5C              .NEXT3:
 169+ 4E5C 05           	DEC B
 170+ 4E5D C2 D6 4D     	JP NZ, .LOOP
 171+ 4E60 08           	EX AF, AF'
 172+ 4E61 3C           	INC A ; increase flicker to start at the next one on next vblank
 173+ 4E62 DD BE 00     	CP (IX)
 174+ 4E65 20 01        	JR NZ,.L8
 175+ 4E67 AF           	XOR A
 176+ 4E68              .L8:
 177+ 4E68 32 8C 4D     	LD (FLICKER), A
 178+ 4E6B
 179+ 4E6B ED 7B 8E 4D  	LD SP, (TMPSP)
 180+ 4E6F 2A 87 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 181+ 4E72 36 00        	LD (HL), 0 ; zero out update flag
 182+ 4E74 C9           	RET
 183+ 4E75              ; *******************************************************************************************************
 184+ 4E75
 185+ 4E75               IF (1 == 1)
 186+ 4E75              ; *******************************************************************************************************
 187+ 4E75              ; function to handle CALL SPRENABLE basic extension
 188+ 4E75              ; initializes sprites handler
 189+ 4E75              ; _SPRENABLE ( INT[3][31] variable sprites_attributes,
 190+ 4E75              ;			   INT variable update_variable,
 191+ 4E75              ;			   BYTE sprite_flicker_enabled,
 192+ 4E75              ;			   BYTE num_sprites_handled )
 193+ 4E75              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA, SPRFLICKER_ENABLED and NUM_SPRITES_HANDLED
 194+ 4E75              SPRENABLE:
 195+ 4E75              	; opening (
 196+ 4E75 CD 88 67     	CALL CHKCHAR
 197+ 4E78 28           	DB '('
 198+ 4E79              	; get address of sprite attribute table DIM SA%(3,31)
 199+ 4E79 3E 02        	LD A,2
 200+ 4E7B 06 02        	LD B,2
 201+ 4E7D 11 20 04     	LD DE,#0420
 202+ 4E80 CD ED 67     	CALL GET_BASIC_ARRAY_DATA_POINTER
 203+ 4E83 ED 43 89 4D  	LD (SPRATR_DATA), BC
 204+ 4E87              	; comma
 205+ 4E87 CD 88 67     	CALL CHKCHAR
 206+ 4E8A 2C           	DB ','
 207+ 4E8B              	; get address of sprite update flag
 208+ 4E8B DD 21 A4 5E  	LD IX, PTRGET
 209+ 4E8F CD 59 01     	CALL CALBAS
 210+ 4E92 ED 53 87 4D  	LD (SPRATR_UPDATE_FLAG), DE
 211+ 4E96              	; comma
 212+ 4E96 CD 88 67     	CALL CHKCHAR
 213+ 4E99 2C           	DB ','
 214+ 4E9A              	; get flicker enabled flag
 215+ 4E9A DD 21 1C 52  	LD IX, GETBYT
 216+ 4E9E CD 59 01     	CALL CALBAS
 217+ 4EA1 32 8B 4D     	LD (SPRFLICKER_ENABLED), A
 218+ 4EA4              	; comma
 219+ 4EA4 CD 88 67     	CALL CHKCHAR
 220+ 4EA7 2C           	DB ','
 221+ 4EA8              	; get number of handled sprites
 222+ 4EA8 DD 21 1C 52  	LD IX, GETBYT
 223+ 4EAC CD 59 01     	CALL CALBAS
 224+ 4EAF 32 8D 4D     	LD (NUM_SPRITES_HANDLED),A
 225+ 4EB2              	; ending )
 226+ 4EB2 CD 88 67     	CALL CHKCHAR
 227+ 4EB5 29           	DB ')'
 228+ 4EB6              .L0:
 229+ 4EB6 3E 01        	LD A, 1
 230+ 4EB8 32 86 4D     	LD (SPRATR_INIT_STATUS), A
 231+ 4EBB C9           	RET
 232+ 4EBC              ; *******************************************************************************************************
 233+ 4EBC               ENDIF
 234+ 4EBC
 235+ 4EBC               IF (0 == 1)
 236+ 4EBC ~            ; same as SPRENABLE but for DEFUSR approach
 237+ 4EBC ~            ; input IX=pointer to input array, real data from +2
 238+ 4EBC ~            ; +2 = pointer to sprite attributes array data
 239+ 4EBC ~            ; +4 = pointer to sprite update variable
 240+ 4EBC ~            ; +6 = flicker flag
 241+ 4EBC ~            ; +8 = number of sprites to handle
 242+ 4EBC ~            SPRENABLE_DEFUSR:
 243+ 4EBC ~            	LD L,(IX+2)
 244+ 4EBC ~            	LD H,(IX+3)
 245+ 4EBC ~            	LD (SPRATR_DATA),HL
 246+ 4EBC ~            	LD L,(IX+4)
 247+ 4EBC ~            	LD H,(IX+5)
 248+ 4EBC ~            	LD (SPRATR_UPDATE_FLAG),HL
 249+ 4EBC ~            	LD A,(IX+6)
 250+ 4EBC ~            	LD (SPRFLICKER_ENABLED),A
 251+ 4EBC ~            	LD A,(IX+8)
 252+ 4EBC ~            	LD (NUM_SPRITES_HANDLED),A
 253+ 4EBC ~            	LD A, 1
 254+ 4EBC ~            	LD (SPRATR_INIT_STATUS), A
 255+ 4EBC ~            	XOR A ; success
 256+ 4EBC ~            	RET
 257+ 4EBC               ENDIF
 258+ 4EBC
 259+ 4EBC               IF (0 + 1 > 0)
 260+ 4EBC              ; *******************************************************************************************************
 261+ 4EBC              ; function to handle CALL SPRDISABLE basic extension
 262+ 4EBC              ; disables sprites handling
 263+ 4EBC              ; _SPRDISABLE
 264+ 4EBC              ; resets variable SPRATR_INIT_STATUS
 265+ 4EBC              SPRDISABLE:
 266+ 4EBC              SPRDISABLE_DEFUSR:
 267+ 4EBC AF           	XOR A
 268+ 4EBD 32 86 4D     	LD (SPRATR_INIT_STATUS), A
 269+ 4EC0 C9           	RET
 270+ 4EC1              ; *******************************************************************************************************
 271+ 4EC1               ENDIF
 272+ 4EC1
 273+ 4EC1              ; *******************************************************************************************************
 274+ 4EC1              ; function to handle CALL SPRSET basic extension
 275+ 4EC1              ; sets position, and optionally pattern and color of sprite
 276+ 4EC1              ; _SPRSET ( BYTE sprite_num , valid 0-31
 277+ 4EC1              ;			INT x,
 278+ 4EC1              ;			INT y,
 279+ 4EC1              ;			INT pattern, valid 0-63, otherwise ignored
 280+ 4EC1              ;			INT color, valid 0-15, otherwise ignored
 281+ 4EC1              ;SPRSET:
 282+ 4EC1              ;	LD A, (SPRATR_INIT_STATUS)
 283+ 4EC1              ;	OR A
 284+ 4EC1              ;	JR NZ, .L1
 285+ 4EC1              ;	LD E, 5 ; illegal function call
 286+ 4EC1              ;	JP THROW_ERROR
 287+ 4EC1              ;.L1:
 288+ 4EC1              ;	; opening (
 289+ 4EC1              ;	CALL CHKCHAR
 290+ 4EC1              ;	DB '('
 291+ 4EC1              ;	; get sprite number
 292+ 4EC1              ;	LD IX, GETBYT
 293+ 4EC1              ;	CALL CALBAS
 294+ 4EC1              ;	PUSH AF
 295+ 4EC1              ;	; comma
 296+ 4EC1              ;	CALL CHKCHAR
 297+ 4EC1              ;	DB ','
 298+ 4EC1              ;	; get x
 299+ 4EC1              ;	LD IX, FRMQNT
 300+ 4EC1              ;	CALL CALBAS
 301+ 4EC1              ;	PUSH DE
 302+ 4EC1              ;	; comma
 303+ 4EC1              ;	CALL CHKCHAR
 304+ 4EC1              ;	DB ','
 305+ 4EC1              ;	; get y
 306+ 4EC1              ;	LD IX, FRMQNT
 307+ 4EC1              ;	CALL CALBAS
 308+ 4EC1              ;	PUSH DE
 309+ 4EC1              ;	; comma
 310+ 4EC1              ;	CALL CHKCHAR
 311+ 4EC1              ;	DB ','
 312+ 4EC1              ;	; get pattern
 313+ 4EC1              ;	LD IX, FRMQNT
 314+ 4EC1              ;	CALL CALBAS
 315+ 4EC1              ;	PUSH DE
 316+ 4EC1              ;	; comma
 317+ 4EC1              ;	CALL CHKCHAR
 318+ 4EC1              ;	DB ','
 319+ 4EC1              ;	; get color
 320+ 4EC1              ;	LD IX, FRMQNT
 321+ 4EC1              ;	CALL CALBAS
 322+ 4EC1              ;	PUSH DE
 323+ 4EC1              ;	; ending )
 324+ 4EC1              ;	CALL CHKCHAR
 325+ 4EC1              ;	DB ')'
 326+ 4EC1              ;
 327+ 4EC1              ;   ; save position in BASIC text
 328+ 4EC1              ;	PUSH HL
 329+ 4EC1              ;	POP IX
 330+ 4EC1              ;
 331+ 4EC1              ;	POP BC ; color
 332+ 4EC1              ;	POP DE ; pattern
 333+ 4EC1              ;	EXX
 334+ 4EC1              ;	POP BC ; y
 335+ 4EC1              ;	POP DE ; x
 336+ 4EC1              ;	POP AF ; sprite number
 337+ 4EC1              ;	CP 32
 338+ 4EC1              ;	JR C, .L2
 339+ 4EC1              ;	LD E, 5 ; illegal function call
 340+ 4EC1              ;	JP THROW_ERROR
 341+ 4EC1              ;.L2:
 342+ 4EC1              ;	; find location in sprite attributes table
 343+ 4EC1              ;	PUSH DE
 344+ 4EC1              ;	CALL GETnthSPRATTR
 345+ 4EC1              ;	POP DE
 346+ 4EC1              ;	DI
 347+ 4EC1              ;	; set y
 348+ 4EC1              ;	LD (HL), C
 349+ 4EC1              ;	INC HL
 350+ 4EC1              ;	LD (HL), B
 351+ 4EC1              ;	INC HL
 352+ 4EC1              ;	; set x
 353+ 4EC1              ;	LD (HL), E
 354+ 4EC1              ;	INC HL
 355+ 4EC1              ;	LD (HL), D
 356+ 4EC1              ;	INC HL
 357+ 4EC1              ;	PUSH HL
 358+ 4EC1              ;	EXX
 359+ 4EC1              ;	POP HL
 360+ 4EC1              ;	; check if 0<=pattern<64
 361+ 4EC1              ;	LD A, D
 362+ 4EC1              ;	OR A
 363+ 4EC1              ;	JR NZ, .L3
 364+ 4EC1              ;	LD A, E
 365+ 4EC1              ;	CP 64
 366+ 4EC1              ;	JR NC, .L3
 367+ 4EC1              ;	; set pattern
 368+ 4EC1              ;	;ADD A, A
 369+ 4EC1              ;	;ADD A, A
 370+ 4EC1              ;	;ADD A, A
 371+ 4EC1              ;	LD (HL), A
 372+ 4EC1              ;	INC HL
 373+ 4EC1              ;	LD (HL), D
 374+ 4EC1              ;	INC HL
 375+ 4EC1              ;	JR .L4
 376+ 4EC1              ;.L3:
 377+ 4EC1              ;	; skip pattern
 378+ 4EC1              ;	.2 INC HL
 379+ 4EC1              ;.L4:
 380+ 4EC1              ;	; check if 0<=color<16
 381+ 4EC1              ;	LD A, B
 382+ 4EC1              ;	OR A
 383+ 4EC1              ;	JR NZ, .L5
 384+ 4EC1              ;	LD A, C
 385+ 4EC1              ;	CP 16
 386+ 4EC1              ;	JR NC, .L5
 387+ 4EC1              ;	; set color
 388+ 4EC1              ;	LD (HL), C
 389+ 4EC1              ;	INC HL
 390+ 4EC1              ;	LD (HL), B
 391+ 4EC1              ;
 392+ 4EC1              ;.L5:
 393+ 4EC1              ;	EI
 394+ 4EC1              ;	PUSH IX
 395+ 4EC1              ;	POP HL
 396+ 4EC1              ;	RET
 397+ 4EC1              ; *******************************************************************************************************
 398+ 4EC1
 399+ 4EC1              ; *******************************************************************************************************
 400+ 4EC1              ; function sets sprite location based on initial coordinates and offset provided
 401+ 4EC1              ; input A=sprite number in SPRATR_DATA , 0-31
 402+ 4EC1              ; input DE=initial x
 403+ 4EC1              ; input BC=initial y
 404+ 4EC1              ; input IY=location where delta y,x are located
 405+ 4EC1              ; modifies AF, HL, IX
 406+ 4EC1              SPRSET_DELTA_POS:
 407+ 4EC1 D5           	PUSH DE
 408+ 4EC2 CD 90 4D     	CALL GETnthSPRATTR
 409+ 4EC5 E5           	PUSH HL
 410+ 4EC6 DD E1        	POP IX
 411+ 4EC8 D1           	POP DE
 412+ 4EC9              	; IX=sprite's y location
 413+ 4EC9 FD 6E 00     	LD L, (IY)
 414+ 4ECC FD 66 01     	LD H, (IY+1)
 415+ 4ECF 09           	ADD HL, BC
 416+ 4ED0 DD 75 00     	LD (IX), L
 417+ 4ED3 DD 74 01     	LD (IX+1), H
 418+ 4ED6 FD 6E 02     	LD L, (IY+2)
 419+ 4ED9 FD 66 03     	LD H, (IY+3)
 420+ 4EDC 19           	ADD HL, DE
 421+ 4EDD DD 75 02     	LD (IX+2), L
 422+ 4EE0 DD 74 03     	LD (IX+3), H
 423+ 4EE3 C9           	RET
 424+ 4EE4              ; *******************************************************************************************************
 425+ 4EE4
 426+ 4EE4              ; *******************************************************************************************************
 427+ 4EE4              ; helper function to set new locations for a set of sprites
 428+ 4EE4              ; input B=number of sprites
 429+ 4EE4              ; HL=pointer to list of sprites and offsets
 430+ 4EE4              SPR_UPDATE_LOC:
 431+ 4EE4 3E 01        	LD A,1
 432+ 4EE6 32 62 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 433+ 4EE9 7E           	LD A, (HL)
 434+ 4EEA 23           	INC HL
 435+ 4EEB 23           	INC HL
 436+ 4EEC E5           	PUSH HL
 437+ 4EED FD E1        	POP IY
 438+ 4EEF D9           	EXX
 439+ 4EF0 CD C1 4E     	CALL SPRSET_DELTA_POS
 440+ 4EF3 D9           	EXX
 441+ 4EF4 23          > INC HL
 441+ 4EF5 23          > INC HL
 441+ 4EF6 23          > INC HL
 441+ 4EF7 23          > INC HL
 442+ 4EF8 10 EA        	DJNZ SPR_UPDATE_LOC
 443+ 4EFA AF           	XOR A
 444+ 4EFB 32 62 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 445+ 4EFE C9           	RET
 446+ 4EFF              ; *******************************************************************************************************
 447+ 4EFF
 448+ 4EFF               IF (1 == 1)
 449+ 4EFF              ; *******************************************************************************************************
 450+ 4EFF              ; function to handle CALL SPRGRPMOV basic extension
 451+ 4EFF              ; sets position of a group of sprites described with
 452+ 4EFF              ; { int sprite_num, int delta_y, int delta_x } [count]
 453+ 4EFF              ; _SPRGRPMOV ( INT x,
 454+ 4EFF              ;			   INT y,
 455+ 4EFF              ;			   BYTE count,
 456+ 4EFF              ;			   INT[2][count] data_ptr
 457+ 4EFF              SPRGRPMOV:
 458+ 4EFF 3A 86 4D     	LD A, (SPRATR_INIT_STATUS)
 459+ 4F02 B7           	OR A
 460+ 4F03 CA B4 67     	JP Z,ILLEGAL_FUNCTION
 461+ 4F06              	; opening (
 462+ 4F06 CD 88 67     	CALL CHKCHAR
 463+ 4F09 28           	DB '('
 464+ 4F0A              	; get x
 465+ 4F0A DD 21 2F 54  	LD IX, FRMQNT
 466+ 4F0E CD 59 01     	CALL CALBAS
 467+ 4F11 ED 53 51 64  	LD (TMP_STRUCT),DE
 468+ 4F15              	; comma
 469+ 4F15 CD 88 67     	CALL CHKCHAR
 470+ 4F18 2C           	DB ','
 471+ 4F19              	; get y
 472+ 4F19 DD 21 2F 54  	LD IX, FRMQNT
 473+ 4F1D CD 59 01     	CALL CALBAS
 474+ 4F20 ED 53 53 64  	LD (TMP_STRUCT+2),DE
 475+ 4F24              	; comma
 476+ 4F24 CD 88 67     	CALL CHKCHAR
 477+ 4F27 2C           	DB ','
 478+ 4F28              	; get count
 479+ 4F28 DD 21 1C 52  	LD IX, GETBYT
 480+ 4F2C CD 59 01     	CALL CALBAS
 481+ 4F2F 32 55 64     	LD (TMP_STRUCT+4),A
 482+ 4F32              	; comma
 483+ 4F32 CD 88 67     	CALL CHKCHAR
 484+ 4F35 2C           	DB ','
 485+ 4F36              	; get sprite group definition array data pointer
 486+ 4F36 3A 55 64     	LD A,(TMP_STRUCT+4)
 487+ 4F39 5F           	LD E,A
 488+ 4F3A 16 03        	LD D,3
 489+ 4F3C 3E 02        	LD A,2
 490+ 4F3E 47           	LD B,A
 491+ 4F3F CD ED 67     	CALL GET_BASIC_ARRAY_DATA_POINTER
 492+ 4F42 ED 43 56 64  	LD (TMP_STRUCT+5),BC
 493+ 4F46              	; ending )
 494+ 4F46 CD 88 67     	CALL CHKCHAR
 495+ 4F49 29           	DB ')'
 496+ 4F4A
 497+ 4F4A E5           	PUSH HL
 498+ 4F4B
 499+ 4F4B D9               EXX
 500+ 4F4C ED 5B 51 64      LD DE,(TMP_STRUCT) ; initial x
 501+ 4F50 ED 4B 53 64      LD BC,(TMP_STRUCT+2) ; initial y
 502+ 4F54 D9               EXX
 503+ 4F55 2A 56 64         LD HL,(TMP_STRUCT+5) ; pointer to data
 504+ 4F58 3A 55 64         LD A,(TMP_STRUCT+4) ; number of entries
 505+ 4F5B 47               LD B,A
 506+ 4F5C CD E4 4E     	CALL SPR_UPDATE_LOC
 507+ 4F5F
 508+ 4F5F E1           	POP HL
 509+ 4F60 C9           	RET
 510+ 4F61              ; *******************************************************************************************************
 511+ 4F61               ENDIF
 512+ 4F61
 513+ 4F61               IF (0 == 1)
 514+ 4F61 ~            ; *******************************************************************************************************
 515+ 4F61 ~            ; same as SPRGRPMOV but for DEFUSR approach
 516+ 4F61 ~            ; input IX=pointer to input array, real data from +2
 517+ 4F61 ~            ; +2 = X
 518+ 4F61 ~            ; +4 = Y
 519+ 4F61 ~            ; +6 = count
 520+ 4F61 ~            ; +8 = data pointer
 521+ 4F61 ~            SPRGRPMOV_DEFUSR:
 522+ 4F61 ~                EXX
 523+ 4F61 ~            	LD E,(IX+2)
 524+ 4F61 ~            	LD D,(IX+3) ; initial x
 525+ 4F61 ~            	LD C,(IX+4)
 526+ 4F61 ~            	LD B,(IX+5) ; initial y
 527+ 4F61 ~                EXX
 528+ 4F61 ~            	LD L,(IX+8)
 529+ 4F61 ~            	LD H,(IX+9) ; pointer to data
 530+ 4F61 ~                LD B,(IX+6) ; count
 531+ 4F61 ~                JP SPR_UPDATE_LOC
 532+ 4F61 ~            ; *******************************************************************************************************
 533+ 4F61               ENDIF
# file closed: asm\SPRITES.asm
 135  4F61               ENDIF
 136  4F61
 137  4F61               IF (ANIM_CMDS == 1)
 138  4F61               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4F61              ; sprite animation routines
   2+ 4F61
   3+ 4F61              ; number of animation items and pointer
   4+ 4F61              ANIMITEMNUM:
   5+ 4F61 00            DB 0
   6+ 4F62              ANIMITEMPTR:
   7+ 4F62 63 68         DW EXT_END
   8+ 4F64              ; number of animation definitions and pointer
   9+ 4F64              ANIMDEFNUM:
  10+ 4F64 00            DB 0
  11+ 4F65              ANIMDEFPTR:
  12+ 4F65 63 68         DW EXT_END
  13+ 4F67              ; number of links between sprite and animation definitions
  14+ 4F67              ANIMSPRNUM:
  15+ 4F67 00            DB 0
  16+ 4F68              ANIMSPRPTR:
  17+ 4F68 63 68         DW EXT_END
  18+ 4F6A              ; number of automatic sprite group move and animate structures
  19+ 4F6A              AUTOSGAMNUM:
  20+ 4F6A 00            DB 0
  21+ 4F6B              AUTOSGAMPTR:
  22+ 4F6B 63 68         DW EXT_END
  23+ 4F6D
  24+ 4F6D              ; ANIMATION ITEM
  25+ 4F6D              ; byte type = [0 - pattern and color change
  26+ 4F6D              ;              1 - pattern definition change ]
  27+ 4F6D              ; word ticks - number of ticks to hold this state
  28+ 4F6D              ; for type = 0
  29+ 4F6D              ;   byte pattern;
  30+ 4F6D              ;   byte color;
  31+ 4F6D              ; for type = 1
  32+ 4F6D              ;   work data_pointer;
  33+ 4F6D              ; total size = 5b
  34+ 4F6D
  35+ 4F6D              ; ANIMATION DEFINITION
  36+ 4F6D              ; byte number of items 1-15
  37+ 4F6D              ; byte[15] anim_item;
  38+ 4F6D              ; total size = 16b
  39+ 4F6D
  40+ 4F6D              ; SPRITE/CHAR ANIMATION
  41+ 4F6D              ; +00 byte sprite/char number;
  42+ 4F6D              ; +01 word time;
  43+ 4F6D              ; +03 byte current item;
  44+ 4F6D              ; +04 byte animation definition;
  45+ 4F6D              ; +05 byte cyclic;
  46+ 4F6D              ; +06 byte active;
  47+ 4F6D              ; +07 byte 0=sprite, 1-3 character bank
  48+ 4F6D              ; total size = 8b
  49+ 4F6D
  50+ 4F6D              ; AUTOMATIC SPRITE GROUP MOVE AND ANIMATE structure
  51+ 4F6D              ; +00 pointer to X variable
  52+ 4F6D              ; +02 pointer to Y variable
  53+ 4F6D              ; +04 minimum value
  54+ 4F6D              ; +06 maximal value
  55+ 4F6D              ; +08 delta value
  56+ 4F6D              ; +10 direction 0=horizontal, <>0 = vertical
  57+ 4F6D              ; +11 sprite group size
  58+ 4F6D              ; +12 sprite group pointer
  59+ 4F6D              ; +14 animation list size
  60+ 4F6D              ; +15 animation list pointer for negative delta values
  61+ 4F6D              ; +17 animation list pointer for positive delta values
  62+ 4F6D              ; +19 active flag
  63+ 4F6D              ; +20 ticks for movement
  64+ 4F6D              ; +22 timer
  65+ 4F6D              ; total = 24b
  66+ 4F6D
  67+ 4F6D              ; *******************************************************************************************************
  68+ 4F6D              ; helper function HL=A*5
  69+ 4F6D              ; changes HL,DE
  70+ 4F6D              Ax5:
  71+ 4F6D 26 00            LD H,0
  72+ 4F6F 6F               LD L,A
  73+ 4F70 54               LD D,H
  74+ 4F71 5D               LD E,L
  75+ 4F72 29               ADD HL,HL
  76+ 4F73 29               ADD HL,HL
  77+ 4F74 19               ADD HL,DE
  78+ 4F75 C9               RET
  79+ 4F76              ; *******************************************************************************************************
  80+ 4F76
  81+ 4F76              ; *******************************************************************************************************
  82+ 4F76              ; helper function gets pointer to n-th animation item
  83+ 4F76              ; changes HL,DE
  84+ 4F76              GETnthANIMITEM:
  85+ 4F76 CD 6D 4F         CALL Ax5
  86+ 4F79 ED 5B 62 4F      LD DE,(ANIMITEMPTR)
  87+ 4F7D 19               ADD HL,DE
  88+ 4F7E C9               RET
  89+ 4F7F              ; *******************************************************************************************************
  90+ 4F7F
  91+ 4F7F              ; *******************************************************************************************************
  92+ 4F7F              ; helper function gets pointer to n-th entry in animation definition
  93+ 4F7F              ; changes HL,DE
  94+ 4F7F              GETnthANIMDEF:
  95+ 4F7F 26 00            LD H,0
  96+ 4F81 6F               LD L,A
  97+ 4F82 CD 74 66         CALL HLx16
  98+ 4F85 ED 5B 65 4F      LD DE,(ANIMDEFPTR)
  99+ 4F89 19               ADD HL,DE
 100+ 4F8A C9               RET
 101+ 4F8B              ; *******************************************************************************************************
 102+ 4F8B
 103+ 4F8B              ; *******************************************************************************************************
 104+ 4F8B              ; helper function gets pointer to n-th entry in sprite animation
 105+ 4F8B              ; changes HL,DE
 106+ 4F8B              GETnthSPRANIM:
 107+ 4F8B 26 00            LD H,0
 108+ 4F8D 6F               LD L,A
 109+ 4F8E CD 75 66         CALL HLx8
 110+ 4F91 ED 5B 68 4F      LD DE,(ANIMSPRPTR)
 111+ 4F95 19               ADD HL,DE
 112+ 4F96 C9               RET
 113+ 4F97              ; *******************************************************************************************************
 114+ 4F97
 115+ 4F97              ; *******************************************************************************************************
 116+ 4F97              ; helper function gets pointer to n-th entry in autosgam table
 117+ 4F97              ; changes HL,DE
 118+ 4F97              GETnthAUTOSGAM:
 119+ 4F97 26 00            LD H,0
 120+ 4F99 6F               LD L,A
 121+ 4F9A CD 75 66         CALL HLx8
 122+ 4F9D 54               LD D,H
 123+ 4F9E 5D               LD E,L
 124+ 4F9F 29               ADD HL,HL
 125+ 4FA0 19               ADD HL,DE
 126+ 4FA1 ED 5B 6B 4F      LD DE,(AUTOSGAMPTR)
 127+ 4FA5 19               ADD HL,DE
 128+ 4FA6 C9               RET
 129+ 4FA7              ; *******************************************************************************************************
 130+ 4FA7
 131+ 4FA7               IF (0 == 1)
 132+ 4FA7 ~            ; *******************************************************************************************************
 133+ 4FA7 ~            ; same as MAXIANIMITEMS but for DEFUSR approach
 134+ 4FA7 ~            ; input IX=pointer to input array, real data from +2
 135+ 4FA7 ~            ; +2 = number
 136+ 4FA7 ~            MAXANIMITEMS_DEFUSR:
 137+ 4FA7 ~                LD A,(IX+2)
 138+ 4FA7 ~                CALL MAXANIMITEMS.COMMON
 139+ 4FA7 ~                XOR A ; success
 140+ 4FA7 ~                RET
 141+ 4FA7 ~            ; *******************************************************************************************************
 142+ 4FA7               ENDIF
 143+ 4FA7
 144+ 4FA7              ; *******************************************************************************************************
 145+ 4FA7              ; function to handle CALL MAXANIMITEMS basic extension
 146+ 4FA7              ; MAXANIMITEMS (BYTE number)
 147+ 4FA7              ; sets new number and moves memory buffers as needed
 148+ 4FA7              MAXANIMITEMS:
 149+ 4FA7               IF (1 == 1)
 150+ 4FA7              	; opening (
 151+ 4FA7 CD 88 67     	CALL CHKCHAR
 152+ 4FAA 28           	DB '('
 153+ 4FAB              	; get value
 154+ 4FAB DD 21 1C 52  	LD IX, GETBYT
 155+ 4FAF CD 59 01     	CALL CALBAS
 156+ 4FB2 F5               PUSH AF
 157+ 4FB3              	; ending )
 158+ 4FB3 CD 88 67     	CALL CHKCHAR
 159+ 4FB6 29           	DB ')'
 160+ 4FB7 F1               POP AF
 161+ 4FB8               ENDIF
 162+ 4FB8              .COMMON: ; entry for DEFUSR part, A=number
 163+ 4FB8 F3               DI
 164+ 4FB9              	; save position
 165+ 4FB9 E5           	PUSH HL
 166+ 4FBA              .ENTRY:
 167+ 4FBA 47               LD B,A
 168+ 4FBB 3A 61 4F         LD A,(ANIMITEMNUM)
 169+ 4FBE 90               SUB B
 170+ 4FBF 28 28            JR Z, .EXIT; same value as before
 171+ 4FC1 FD 21 65 4F      LD IY,ANIMDEFPTR
 172+ 4FC5 FA EC 4F         JP M, .INCREASE
 173+ 4FC8                  ; new value is lower than previous one
 174+ 4FC8 CD 0B 50         CALL .SIZEDIFF
 175+ 4FCB CD 26 50         CALL .DECREASE_COMMON
 176+ 4FCE 2A 68 4F         LD HL,(ANIMSPRPTR)
 177+ 4FD1 AF               XOR A
 178+ 4FD2 ED 42            SBC HL,BC
 179+ 4FD4 22 68 4F         LD (ANIMSPRPTR),HL
 180+ 4FD7              .E1:
 181+ 4FD7 2A 6B 4F         LD HL,(AUTOSGAMPTR)
 182+ 4FDA AF               XOR A
 183+ 4FDB ED 42            SBC HL,BC
 184+ 4FDD 22 6B 4F         LD (AUTOSGAMPTR),HL
 185+ 4FE0              .E3:
 186+ 4FE0 2A 10 40         LD HL,(FREEMEMPTR)
 187+ 4FE3 AF               XOR A
 188+ 4FE4 ED 42            SBC HL,BC
 189+ 4FE6 22 10 40         LD (FREEMEMPTR),HL
 190+ 4FE9              .EXIT:
 191+ 4FE9 FB               EI
 192+ 4FEA E1           	POP HL
 193+ 4FEB C9           	RET
 194+ 4FEC              .INCREASE:
 195+ 4FEC ED 44            NEG
 196+ 4FEE CD 0B 50         CALL .SIZEDIFF
 197+ 4FF1 CD 52 50         CALL .INCREASE_COMMON
 198+ 4FF4 2A 68 4F         LD HL,(ANIMSPRPTR)
 199+ 4FF7 09               ADD HL,BC
 200+ 4FF8 22 68 4F         LD (ANIMSPRPTR),HL
 201+ 4FFB              .E2:
 202+ 4FFB 2A 6B 4F         LD HL,(AUTOSGAMPTR)
 203+ 4FFE 09               ADD HL,BC
 204+ 4FFF 22 6B 4F         LD (AUTOSGAMPTR),HL
 205+ 5002              .E4:
 206+ 5002 2A 10 40         LD HL,(FREEMEMPTR)
 207+ 5005 09               ADD HL,BC
 208+ 5006 22 10 40         LD (FREEMEMPTR),HL
 209+ 5009 18 DE            JR .EXIT
 210+ 500B              .SIZEDIFF:
 211+ 500B CD 6D 4F         CALL Ax5
 212+ 500E 78               LD A,B
 213+ 500F 32 61 4F         LD (ANIMITEMNUM),A
 214+ 5012 44               LD B,H
 215+ 5013 4D               LD C,L
 216+ 5014 C9               RET ; BC=size difference in bytes
 217+ 5015              .SIZETOMOVE:
 218+ 5015 D5               PUSH DE
 219+ 5016 2A 10 40         LD HL,(FREEMEMPTR)
 220+ 5019 FD 5E 00         LD E,(IY)
 221+ 501C FD 56 01         LD D,(IY+1)
 222+ 501F AF               XOR A
 223+ 5020 ED 52            SBC HL,DE
 224+ 5022 44               LD B,H
 225+ 5023 4D               LD C,L
 226+ 5024 D1               POP DE
 227+ 5025 C9               RET
 228+ 5026              .DECREASE_COMMON:
 229+ 5026 FD 6E 00         LD L,(IY)
 230+ 5029 FD 66 01         LD H,(IY+1)
 231+ 502C AF               XOR A
 232+ 502D ED 42            SBC HL,BC
 233+ 502F EB               EX DE,HL
 234+ 5030 C5               PUSH BC
 235+ 5031 CD 15 50         CALL .SIZETOMOVE
 236+ 5034 F3               DI
 237+ 5035 78               LD A,B
 238+ 5036 B1               OR C
 239+ 5037 28 08            JR Z,.L1
 240+ 5039 FD 6E 00         LD L,(IY)
 241+ 503C FD 66 01         LD H,(IY+1)
 242+ 503F ED B0            LDIR
 243+ 5041              .L1:
 244+ 5041 C1               POP BC
 245+ 5042 FD 6E 00         LD L,(IY)
 246+ 5045 FD 66 01         LD H,(IY+1)
 247+ 5048 AF               XOR A
 248+ 5049 ED 42            SBC HL,BC
 249+ 504B FD 75 00         LD (IY),L
 250+ 504E FD 74 01         LD (IY+1),H
 251+ 5051 C9               RET
 252+ 5052              .INCREASE_COMMON:
 253+ 5052 2A 10 40         LD HL,(FREEMEMPTR)
 254+ 5055 2B               DEC HL
 255+ 5056 AF               XOR A
 256+ 5057 ED 42            SBC HL,BC
 257+ 5059 EB               EX DE,HL
 258+ 505A C5               PUSH BC
 259+ 505B CD 15 50         CALL .SIZETOMOVE
 260+ 505E F3               DI
 261+ 505F 78               LD A,B
 262+ 5060 B1               OR C
 263+ 5061 28 06            JR Z,.L2
 264+ 5063 2A 10 40         LD HL,(FREEMEMPTR)
 265+ 5066 2B               DEC HL
 266+ 5067 ED B8            LDDR
 267+ 5069              .L2:
 268+ 5069 C1               POP BC
 269+ 506A FD 6E 00         LD L,(IY)
 270+ 506D FD 66 01         LD H,(IY+1)
 271+ 5070 09               ADD HL,BC
 272+ 5071 FD 75 00         LD (IY),L
 273+ 5074 FD 74 01         LD (IY+1),H
 274+ 5077 C9               RET
 275+ 5078              ; *******************************************************************************************************
 276+ 5078
 277+ 5078               IF (1 == 1)
 278+ 5078              ; *******************************************************************************************************
 279+ 5078              ; function to handle CALL ANIMITEMPAT basic extension
 280+ 5078              ; ANIMITEMPAT ( BYTE id,
 281+ 5078              ;               INT ticks >0,
 282+ 5078              ;               BYTE pattern,
 283+ 5078              ;               BYTE color )
 284+ 5078              ; fills animation item data, returns an error if ID out of bounds
 285+ 5078              ANIMITEMPAT:
 286+ 5078                  ; opening (
 287+ 5078 CD 88 67     	CALL CHKCHAR
 288+ 507B 28           	DB '('
 289+ 507C              	; get id
 290+ 507C DD 21 1C 52  	LD IX, GETBYT
 291+ 5080 CD 59 01     	CALL CALBAS
 292+ 5083 F5               PUSH AF
 293+ 5084                  ; check if out of bounds
 294+ 5084 3C               INC A
 295+ 5085 4F               LD C,A
 296+ 5086 3A 61 4F         LD A,(ANIMITEMNUM)
 297+ 5089 B9               CP C
 298+ 508A DA AC 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 299+ 508D              	; comma
 300+ 508D CD 88 67     	CALL CHKCHAR
 301+ 5090 2C           	DB ','
 302+ 5091              	; get ticks
 303+ 5091 DD 21 2F 54  	LD IX, FRMQNT
 304+ 5095 CD 59 01     	CALL CALBAS
 305+ 5098 7A               LD A,D
 306+ 5099 B3               OR E
 307+ 509A CA B0 67         JP Z, OVERFLOW
 308+ 509D D5           	PUSH DE
 309+ 509E              	; comma
 310+ 509E CD 88 67     	CALL CHKCHAR
 311+ 50A1 2C           	DB ','
 312+ 50A2              	; get pattern
 313+ 50A2 DD 21 1C 52  	LD IX, GETBYT
 314+ 50A6 CD 59 01     	CALL CALBAS
 315+ 50A9 F5               PUSH AF
 316+ 50AA              	; comma
 317+ 50AA CD 88 67     	CALL CHKCHAR
 318+ 50AD 2C           	DB ','
 319+ 50AE              	; get color
 320+ 50AE DD 21 1C 52  	LD IX, GETBYT
 321+ 50B2 CD 59 01     	CALL CALBAS
 322+ 50B5 F5               PUSH AF
 323+ 50B6              	; ending )
 324+ 50B6 CD 88 67     	CALL CHKCHAR
 325+ 50B9 29           	DB ')'
 326+ 50BA              .ENTRY:
 327+ 50BA E5               PUSH HL
 328+ 50BB DD E1            POP IX
 329+ 50BD D9               EXX
 330+ 50BE C1               POP BC ; color
 331+ 50BF D1               POP DE ; pattern
 332+ 50C0 E1               POP HL ; ticks
 333+ 50C1 D9               EXX
 334+ 50C2 F1               POP AF
 335+ 50C3 CD 76 4F         CALL GETnthANIMITEM
 336+ 50C6 E5               PUSH HL
 337+ 50C7 FD E1            POP IY
 338+ 50C9 D9               EXX
 339+ 50CA FD 36 00 00      LD (IY),0 ; type=0
 340+ 50CE FD 75 01         LD (IY+1),L
 341+ 50D1 FD 74 02         LD (IY+2),H
 342+ 50D4 FD 72 03         LD (IY+3),D
 343+ 50D7 FD 70 04         LD (IY+4),B
 344+ 50DA
 345+ 50DA DD E5            PUSH IX
 346+ 50DC E1               POP HL
 347+ 50DD C9               RET
 348+ 50DE              ; *******************************************************************************************************
 349+ 50DE               ENDIF
 350+ 50DE
 351+ 50DE               IF (0 == 1)
 352+ 50DE ~            ; *******************************************************************************************************
 353+ 50DE ~            ; same as ANIMITEMPAT but for DEFUSR approach
 354+ 50DE ~            ; input IX=pointer to input array, real data from +2
 355+ 50DE ~            ; +02 = ID
 356+ 50DE ~            ; +04 = ticks
 357+ 50DE ~            ; +06 = pattern
 358+ 50DE ~            ; +08 = color
 359+ 50DE ~            ANIMITEMPAT_DEFUSR:
 360+ 50DE ~                ; check if out of bounds
 361+ 50DE ~                LD C,(IX+2)
 362+ 50DE ~                INC C
 363+ 50DE ~                LD A,(ANIMITEMNUM)
 364+ 50DE ~                CP C
 365+ 50DE ~                JR C,.ERR ; out of bounds, prevent memory corruption
 366+ 50DE ~                LD A,C
 367+ 50DE ~                DEC A
 368+ 50DE ~                CALL GETnthANIMITEM
 369+ 50DE ~                LD (HL),0 ; type=0
 370+ 50DE ~                INC HL
 371+ 50DE ~                LD A,(IX+4) ; ticks low
 372+ 50DE ~                LD (HL),A
 373+ 50DE ~                INC HL
 374+ 50DE ~                LD A,(IX+5) ; ticks high
 375+ 50DE ~                LD (HL),A
 376+ 50DE ~                INC HL
 377+ 50DE ~                LD A,(IX+6) ; pattern
 378+ 50DE ~                LD (HL),A
 379+ 50DE ~                INC HL
 380+ 50DE ~                LD A,(IX+8) ; color
 381+ 50DE ~                LD (HL),A
 382+ 50DE ~                XOR A ; success
 383+ 50DE ~                RET
 384+ 50DE ~            .ERR:
 385+ 50DE ~                LD A,1
 386+ 50DE ~                RET
 387+ 50DE ~            ; *******************************************************************************************************
 388+ 50DE               ENDIF
 389+ 50DE
 390+ 50DE               IF (1 == 1)
 391+ 50DE              ; *******************************************************************************************************
 392+ 50DE              ; function to handle CALL ANIMITEMPTR basic extension
 393+ 50DE              ; ANIMITEMPTR ( BYTE id,
 394+ 50DE              ;               INT ticks,
 395+ 50DE              ;               INT pointer,
 396+ 50DE              ; fills animation item data, returns an error if ID out of bounds
 397+ 50DE              ANIMITEMPTR_CMD:
 398+ 50DE                  ; opening (
 399+ 50DE CD 88 67     	CALL CHKCHAR
 400+ 50E1 28           	DB '('
 401+ 50E2              	; get id
 402+ 50E2 DD 21 1C 52  	LD IX, GETBYT
 403+ 50E6 CD 59 01     	CALL CALBAS
 404+ 50E9 F5               PUSH AF
 405+ 50EA                  ; check if out of bounds
 406+ 50EA 3C               INC A
 407+ 50EB 4F               LD C,A
 408+ 50EC 3A 61 4F         LD A,(ANIMITEMNUM)
 409+ 50EF B9               CP C
 410+ 50F0 DA AC 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 411+ 50F3              	; comma
 412+ 50F3 CD 88 67     	CALL CHKCHAR
 413+ 50F6 2C           	DB ','
 414+ 50F7              	; get ticks
 415+ 50F7 DD 21 2F 54  	LD IX, FRMQNT
 416+ 50FB CD 59 01     	CALL CALBAS
 417+ 50FE 7A               LD A,D
 418+ 50FF B3               OR E
 419+ 5100 CA B0 67         JP Z,OVERFLOW
 420+ 5103 D5           	PUSH DE
 421+ 5104              	; comma
 422+ 5104 CD 88 67     	CALL CHKCHAR
 423+ 5107 2C           	DB ','
 424+ 5108              	; get pointer
 425+ 5108 DD 21 2F 54  	LD IX, FRMQNT
 426+ 510C CD 59 01     	CALL CALBAS
 427+ 510F D5           	PUSH DE
 428+ 5110              	; ending )
 429+ 5110 CD 88 67     	CALL CHKCHAR
 430+ 5113 29           	DB ')'
 431+ 5114              .ENTRY:
 432+ 5114 E5               PUSH HL
 433+ 5115 DD E1            POP IX
 434+ 5117 D9               EXX
 435+ 5118 D1               POP DE ; pointer
 436+ 5119 E1               POP HL ; ticks
 437+ 511A D9               EXX
 438+ 511B F1               POP AF
 439+ 511C CD 76 4F         CALL GETnthANIMITEM
 440+ 511F E5               PUSH HL
 441+ 5120 FD E1            POP IY
 442+ 5122 D9               EXX
 443+ 5123 FD 36 00 01      LD (IY),1 ; type=1
 444+ 5127 FD 75 01         LD (IY+1),L
 445+ 512A FD 74 02         LD (IY+2),H
 446+ 512D FD 73 03         LD (IY+3),E
 447+ 5130 FD 72 04         LD (IY+4),D
 448+ 5133
 449+ 5133 DD E5            PUSH IX
 450+ 5135 E1               POP HL
 451+ 5136 C9               RET
 452+ 5137              ; *******************************************************************************************************
 453+ 5137               ENDIF
 454+ 5137
 455+ 5137               IF (0 == 1)
 456+ 5137 ~            ; *******************************************************************************************************
 457+ 5137 ~            ; same as ANIMITEMPTR but for DEFUSR approach
 458+ 5137 ~            ; input IX=pointer to input array, real data from +2
 459+ 5137 ~            ; +02 = ID
 460+ 5137 ~            ; +04 = ticks
 461+ 5137 ~            ; +06 = pointer
 462+ 5137 ~            ANIMITEMPTR_DEFUSR:
 463+ 5137 ~                ; check if out of bounds
 464+ 5137 ~                LD C,(IX+2)
 465+ 5137 ~                INC C
 466+ 5137 ~                LD A,(ANIMITEMNUM)
 467+ 5137 ~                CP C
 468+ 5137 ~                JR C,.ERR ; out of bounds, prevent memory corruption
 469+ 5137 ~                LD A,C
 470+ 5137 ~                DEC A
 471+ 5137 ~                CALL GETnthANIMITEM
 472+ 5137 ~                LD (HL),1 ; type=1
 473+ 5137 ~                INC HL
 474+ 5137 ~                LD A,(IX+4) ; ticks low
 475+ 5137 ~                LD (HL),A
 476+ 5137 ~                INC HL
 477+ 5137 ~                LD A,(IX+5) ; ticks high
 478+ 5137 ~                LD (HL),A
 479+ 5137 ~                INC HL
 480+ 5137 ~                LD A,(IX+6) ; pointer low
 481+ 5137 ~                LD (HL),A
 482+ 5137 ~                INC HL
 483+ 5137 ~                LD A,(IX+7) ; pointer high
 484+ 5137 ~                LD (HL),A
 485+ 5137 ~                XOR A ; success
 486+ 5137 ~                RET
 487+ 5137 ~            .ERR:
 488+ 5137 ~                LD A,1
 489+ 5137 ~                RET
 490+ 5137 ~            ; *******************************************************************************************************
 491+ 5137               ENDIF
 492+ 5137
 493+ 5137               IF (0 == 1)
 494+ 5137 ~            ; *******************************************************************************************************
 495+ 5137 ~            ; same as MAXANIMDEFS but for DEFUSR approach
 496+ 5137 ~            ; input IX=pointer to input array, real data from +2
 497+ 5137 ~            ; +2 = number
 498+ 5137 ~            MAXANIMDEFS_DEFUSR:
 499+ 5137 ~                LD A,(IX+2)
 500+ 5137 ~                CALL MAXANIMDEFS.COMMON
 501+ 5137 ~                XOR A ; success
 502+ 5137 ~                RET
 503+ 5137 ~            ; *******************************************************************************************************
 504+ 5137               ENDIF
 505+ 5137
 506+ 5137              ; *******************************************************************************************************
 507+ 5137              ; function to handle CALL MAXANIMDEFS basic extension
 508+ 5137              ; MAXANIMDEFS (BYTE number)
 509+ 5137              ; sets new number and moves memory buffers as needed
 510+ 5137              MAXANIMDEFS:
 511+ 5137               IF (1 == 1)
 512+ 5137              	; opening (
 513+ 5137 CD 88 67     	CALL CHKCHAR
 514+ 513A 28           	DB '('
 515+ 513B              	; get value
 516+ 513B DD 21 1C 52  	LD IX, GETBYT
 517+ 513F CD 59 01     	CALL CALBAS
 518+ 5142 F5               PUSH AF
 519+ 5143              	; ending )
 520+ 5143 CD 88 67     	CALL CHKCHAR
 521+ 5146 29           	DB ')'
 522+ 5147 F1               POP AF
 523+ 5148               ENDIF
 524+ 5148              .COMMON:
 525+ 5148 F3               DI
 526+ 5149              	; save position
 527+ 5149 E5           	PUSH HL
 528+ 514A              .ENTRY:
 529+ 514A 47               LD B,A
 530+ 514B 3A 64 4F         LD A,(ANIMDEFNUM)
 531+ 514E 90               SUB B
 532+ 514F CA E9 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 533+ 5152 FD 21 68 4F      LD IY,ANIMSPRPTR
 534+ 5156 FA 62 51         JP M, .INCREASE
 535+ 5159                  ; new value is lower than previous one
 536+ 5159 CD 6D 51         CALL .SIZEDIFF
 537+ 515C CD 26 50         CALL MAXANIMITEMS.DECREASE_COMMON
 538+ 515F C3 D7 4F         JP MAXANIMITEMS.E1
 539+ 5162              .INCREASE:
 540+ 5162 ED 44            NEG
 541+ 5164 CD 6D 51         CALL .SIZEDIFF
 542+ 5167 CD 52 50         CALL MAXANIMITEMS.INCREASE_COMMON
 543+ 516A C3 FB 4F         JP MAXANIMITEMS.E2
 544+ 516D              .SIZEDIFF:
 545+ 516D 26 00            LD H,0
 546+ 516F 6F               LD L,A
 547+ 5170 CD 74 66         CALL HLx16
 548+ 5173 78               LD A,B
 549+ 5174 32 64 4F         LD (ANIMDEFNUM),A
 550+ 5177 44               LD B,H
 551+ 5178 4D               LD C,L
 552+ 5179 C9               RET ; BC=size difference in bytes
 553+ 517A              ; *******************************************************************************************************
 554+ 517A
 555+ 517A               IF (1 == 1)
 556+ 517A              ; *******************************************************************************************************
 557+ 517A              ; function to handle CALL ANIMDEF basic extension
 558+ 517A              ; ANIMITEMPAT ( BYTE id,
 559+ 517A              ;               BYTE size,
 560+ 517A              ;               INT[] list )
 561+ 517A              ; fills animation definition data, returns an error if out of bounds, or invalid type
 562+ 517A              ANIMDEF:
 563+ 517A                  ; opening (
 564+ 517A CD 88 67     	CALL CHKCHAR
 565+ 517D 28           	DB '('
 566+ 517E              	; get id
 567+ 517E DD 21 1C 52  	LD IX, GETBYT
 568+ 5182 CD 59 01     	CALL CALBAS
 569+ 5185 F5               PUSH AF
 570+ 5186                  ; check if out of bounds
 571+ 5186 3C               INC A
 572+ 5187 4F               LD C,A
 573+ 5188 3A 64 4F         LD A,(ANIMDEFNUM)
 574+ 518B B9               CP C
 575+ 518C DA AC 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 576+ 518F              	; comma
 577+ 518F CD 88 67     	CALL CHKCHAR
 578+ 5192 2C           	DB ','
 579+ 5193              	; get size
 580+ 5193 DD 21 1C 52  	LD IX, GETBYT
 581+ 5197 CD 59 01     	CALL CALBAS
 582+ 519A FE 10            CP 16
 583+ 519C D2 B0 67         JP NC, OVERFLOW
 584+ 519F B7               OR A
 585+ 51A0 CA B0 67         JP Z, OVERFLOW
 586+ 51A3 F5           	PUSH AF
 587+ 51A4              	; comma
 588+ 51A4 CD 88 67     	CALL CHKCHAR
 589+ 51A7 2C           	DB ','
 590+ 51A8              	; get pointer to a list of animation items in integer array format
 591+ 51A8                  ; get array pointer
 592+ 51A8 D1               POP DE
 593+ 51A9 D5               PUSH DE
 594+ 51AA 3E 02            LD A,2
 595+ 51AC 06 01            LD B,1
 596+ 51AE CD ED 67         CALL GET_BASIC_ARRAY_DATA_POINTER
 597+ 51B1 C5               PUSH BC
 598+ 51B2              	; ending )
 599+ 51B2 CD 88 67     	CALL CHKCHAR
 600+ 51B5 29           	DB ')'
 601+ 51B6              .ENTRY:
 602+ 51B6 E5               PUSH HL
 603+ 51B7 DD E1            POP IX
 604+ 51B9 D1               POP DE ; pointer to INT array
 605+ 51BA C1               POP BC ; B=item number
 606+ 51BB F1               POP AF ; id
 607+ 51BC D5               PUSH DE
 608+ 51BD CD 7F 4F         CALL GETnthANIMDEF
 609+ 51C0 D1               POP DE
 610+ 51C1 70               LD (HL),B
 611+ 51C2              .L1:
 612+ 51C2 23               INC HL
 613+ 51C3 1A               LD A,(DE)
 614+ 51C4 13          > INC DE
 614+ 51C5 13          > INC DE
 615+ 51C6 77               LD (HL),A
 616+ 51C7 10 F9            DJNZ .L1
 617+ 51C9 DD E5            PUSH IX
 618+ 51CB E1               POP HL
 619+ 51CC C9               RET
 620+ 51CD              ; *******************************************************************************************************
 621+ 51CD               ENDIF
 622+ 51CD
 623+ 51CD               IF (0 == 1)
 624+ 51CD ~            ; *******************************************************************************************************
 625+ 51CD ~            ; same as ANIMDEF but for DEFUSR approach
 626+ 51CD ~            ; input IX=pointer to input array, real data from +2
 627+ 51CD ~            ; +02 = ID
 628+ 51CD ~            ; +04 = list size
 629+ 51CD ~            ; +06 = list pointer
 630+ 51CD ~            ANIMDEF_DEFUSR:
 631+ 51CD ~                ; check if out of bounds
 632+ 51CD ~                LD C,(IX+2)
 633+ 51CD ~                INC C
 634+ 51CD ~                LD A,(ANIMDEFNUM)
 635+ 51CD ~                CP C
 636+ 51CD ~                JR C,.ERR ; invalid id
 637+ 51CD ~            	; get size
 638+ 51CD ~                LD A,(IX+4)
 639+ 51CD ~                CP 16
 640+ 51CD ~                RET NC ; overflow
 641+ 51CD ~                OR A
 642+ 51CD ~                RET Z ; ID=0, invalid
 643+ 51CD ~                LD B,A
 644+ 51CD ~                LD A,C
 645+ 51CD ~                DEC A
 646+ 51CD ~                CALL GETnthANIMDEF
 647+ 51CD ~                LD (HL),B
 648+ 51CD ~                LD E,(IX+6)
 649+ 51CD ~                LD D,(IX+7)
 650+ 51CD ~            .L1:
 651+ 51CD ~                INC HL
 652+ 51CD ~                LD A,(DE)
 653+ 51CD ~                .2 INC DE
 654+ 51CD ~                LD (HL),A
 655+ 51CD ~                DJNZ .L1
 656+ 51CD ~                XOR A ; success
 657+ 51CD ~                RET
 658+ 51CD ~            .ERR:
 659+ 51CD ~                LD A,1
 660+ 51CD ~                RET
 661+ 51CD ~            ; *******************************************************************************************************
 662+ 51CD               ENDIF
 663+ 51CD
 664+ 51CD               IF (0 == 1)
 665+ 51CD ~            ; *******************************************************************************************************
 666+ 51CD ~            ; same as MAXANIMSPRS but for DEFUSR approach
 667+ 51CD ~            ; input IX=pointer to input array, real data from +2
 668+ 51CD ~            ; +2 = number
 669+ 51CD ~            MAXANIMSPRS_DEFUSR:
 670+ 51CD ~                LD A,(IX+2)
 671+ 51CD ~                CALL MAXANIMSPRS.COMMON
 672+ 51CD ~                XOR A ; success
 673+ 51CD ~                RET
 674+ 51CD ~            ; *******************************************************************************************************
 675+ 51CD               ENDIF
 676+ 51CD
 677+ 51CD              ; *******************************************************************************************************
 678+ 51CD              ; function to handle CALL MAXANIMSPRS basic extension
 679+ 51CD              ; MAXANIMSPRS (BYTE number)
 680+ 51CD              ; sets new number and moves memory buffers as needed
 681+ 51CD              MAXANIMSPRS:
 682+ 51CD               IF (1 == 1)
 683+ 51CD              	; opening (
 684+ 51CD CD 88 67     	CALL CHKCHAR
 685+ 51D0 28           	DB '('
 686+ 51D1              	; get value
 687+ 51D1 DD 21 1C 52  	LD IX, GETBYT
 688+ 51D5 CD 59 01     	CALL CALBAS
 689+ 51D8 F5               PUSH AF
 690+ 51D9              	; ending )
 691+ 51D9 CD 88 67     	CALL CHKCHAR
 692+ 51DC 29           	DB ')'
 693+ 51DD F1               POP AF
 694+ 51DE               ENDIF
 695+ 51DE              .COMMON:
 696+ 51DE F3               DI
 697+ 51DF              	; save position
 698+ 51DF E5           	PUSH HL
 699+ 51E0              .ENTRY:
 700+ 51E0 47               LD B,A
 701+ 51E1 3A 67 4F         LD A,(ANIMSPRNUM)
 702+ 51E4 90               SUB B
 703+ 51E5 CA E9 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 704+ 51E8 FD 21 6B 4F      LD IY,AUTOSGAMPTR
 705+ 51EC FA F8 51         JP M, .INCREASE
 706+ 51EF                  ; new value is lower than previous one
 707+ 51EF CD 19 52         CALL .SIZEDIFF
 708+ 51F2 CD 26 50         CALL MAXANIMITEMS.DECREASE_COMMON
 709+ 51F5 C3 E0 4F         JP MAXANIMITEMS.E3
 710+ 51F8              .INCREASE:
 711+ 51F8 ED 44            NEG
 712+ 51FA F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 713+ 51FB CD 19 52         CALL .SIZEDIFF
 714+ 51FE CD 52 50         CALL MAXANIMITEMS.INCREASE_COMMON
 715+ 5201 AF               XOR A
 716+ 5202 ED 42            SBC HL,BC ; location of new stuff
 717+ 5204 F1               POP AF
 718+ 5205 C5               PUSH BC
 719+ 5206 47               LD B,A
 720+ 5207 11 08 00         LD DE,8
 721+ 520A E5               PUSH HL
 722+ 520B DD E1            POP IX
 723+ 520D              .L1:
 724+ 520D DD 36 06 00      LD (IX+6),0 ; active flag
 725+ 5211 DD 19            ADD IX,DE
 726+ 5213 10 F8            DJNZ .L1
 727+ 5215 C1               POP BC
 728+ 5216 C3 02 50         JP MAXANIMITEMS.E4
 729+ 5219              .SIZEDIFF:
 730+ 5219 26 00            LD H,0
 731+ 521B 6F               LD L,A
 732+ 521C CD 75 66         CALL HLx8
 733+ 521F 78               LD A,B
 734+ 5220 32 67 4F         LD (ANIMSPRNUM),A
 735+ 5223 44               LD B,H
 736+ 5224 4D               LD C,L
 737+ 5225 C9               RET ; BC=size difference in bytes
 738+ 5226              ; *******************************************************************************************************
 739+ 5226
 740+ 5226               IF (1 == 1)
 741+ 5226              ; *******************************************************************************************************
 742+ 5226              ; function to handle CALL ANIMSPRITE basic extension
 743+ 5226              ; ANIMSPRITE ( BYTE id,
 744+ 5226              ;              BYTE sprite_number,
 745+ 5226              ;              BYTE animation_definition_id,
 746+ 5226              ;              BYTE cyclic_flag )
 747+ 5226              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 748+ 5226              ANIMSPRITE:
 749+ 5226                  ; opening (
 750+ 5226 CD 88 67     	CALL CHKCHAR
 751+ 5229 28           	DB '('
 752+ 522A              	; get sprite animation id
 753+ 522A DD 21 1C 52  	LD IX, GETBYT
 754+ 522E CD 59 01     	CALL CALBAS
 755+ 5231 F5               PUSH AF
 756+ 5232 3C               INC A
 757+ 5233 4F               LD C,A
 758+ 5234 3A 67 4F         LD A,(ANIMSPRNUM)
 759+ 5237 B9               CP C
 760+ 5238 DA AC 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 761+ 523B              	; comma
 762+ 523B CD 88 67     	CALL CHKCHAR
 763+ 523E 2C           	DB ','
 764+ 523F              	; get sprite number
 765+ 523F DD 21 1C 52  	LD IX, GETBYT
 766+ 5243 CD 59 01     	CALL CALBAS
 767+ 5246 F5               PUSH AF
 768+ 5247                  ; check if out of bounds
 769+ 5247 FE 20            CP 32
 770+ 5249 D2 AC 67         JP NC, SUBSCRIPT_OUT_OF_RANGE
 771+ 524C              	; comma
 772+ 524C CD 88 67     	CALL CHKCHAR
 773+ 524F 2C           	DB ','
 774+ 5250              	; get animation definition id
 775+ 5250 DD 21 1C 52  	LD IX, GETBYT
 776+ 5254 CD 59 01     	CALL CALBAS
 777+ 5257 F5               PUSH AF
 778+ 5258 3C               INC A
 779+ 5259 4F               LD C,A
 780+ 525A 3A 64 4F         LD A,(ANIMDEFNUM)
 781+ 525D B9               CP C
 782+ 525E DA AC 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 783+ 5261              	; comma
 784+ 5261 CD 88 67     	CALL CHKCHAR
 785+ 5264 2C           	DB ','
 786+ 5265              	; get cyclic flag
 787+ 5265 DD 21 1C 52  	LD IX, GETBYT
 788+ 5269 CD 59 01         CALL CALBAS
 789+ 526C F5           	PUSH AF
 790+ 526D              	; ending )
 791+ 526D CD 88 67     	CALL CHKCHAR
 792+ 5270 29           	DB ')'
 793+ 5271              .ENTRY:
 794+ 5271 E5               PUSH HL
 795+ 5272 DD E1            POP IX
 796+ 5274 D9               EXX
 797+ 5275 D1               POP DE ; cyclic
 798+ 5276 C1               POP BC ; animation definition id
 799+ 5277 E1               POP HL ; sprite number
 800+ 5278 D9               EXX
 801+ 5279 F1               POP AF ; sprite animation id
 802+ 527A CD 8B 4F         CALL GETnthSPRANIM
 803+ 527D E5               PUSH HL
 804+ 527E FD E1            POP IY
 805+ 5280 D9               EXX
 806+ 5281 FD 74 00         LD (IY),H
 807+ 5284 FD 70 04         LD (IY+4),B
 808+ 5287 FD 72 05         LD (IY+5),D
 809+ 528A                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 810+ 528A                  ; following will do preparation for ANIMSTEP situation
 811+ 528A                  ; current item set to above limit and timer to 1
 812+ 528A                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 813+ 528A FD 36 03 FF      LD (IY+3),255
 814+ 528E FD 36 01 01      LD (IY+1),1
 815+ 5292 FD 36 02 00      LD (IY+2),0
 816+ 5296                  ; mark as sprite animation
 817+ 5296 FD 36 07 00      LD (IY+7),0
 818+ 529A DD E5            PUSH IX
 819+ 529C E1               POP HL
 820+ 529D C9               RET
 821+ 529E              ; *******************************************************************************************************
 822+ 529E               ENDIF
 823+ 529E
 824+ 529E               IF (0 == 1)
 825+ 529E ~            ; *******************************************************************************************************
 826+ 529E ~            ; same as ANIMSPRITE but for DEFUSR approach
 827+ 529E ~            ; input IX=pointer to input array, real data from +2
 828+ 529E ~            ; +02 = ID
 829+ 529E ~            ; +04 = sprite number
 830+ 529E ~            ; +06 = animation definition id
 831+ 529E ~            ; +08 = cyclic flag
 832+ 529E ~            ANIMSPRITE_DEFUSR:
 833+ 529E ~                LD C,(IX+2)
 834+ 529E ~                INC C
 835+ 529E ~                LD A,(ANIMSPRNUM)
 836+ 529E ~                CP C
 837+ 529E ~                JR C,.ERR ; invalid id
 838+ 529E ~            	; get sprite number
 839+ 529E ~                LD A,(IX+4)
 840+ 529E ~                CP 32
 841+ 529E ~                JR NC,.ERR ; invalid sprite id
 842+ 529E ~                LD B,(IX+6)
 843+ 529E ~                INC B
 844+ 529E ~                LD A,(ANIMDEFNUM)
 845+ 529E ~                CP B
 846+ 529E ~                JR C,.ERR ; invalid animation definition id
 847+ 529E ~                LD A,C
 848+ 529E ~                DEC A
 849+ 529E ~                CALL GETnthSPRANIM
 850+ 529E ~                LD A,(IX+4)
 851+ 529E ~                LD (HL),A ; +0
 852+ 529E ~                INC HL
 853+ 529E ~                LD (HL),1 ; +1
 854+ 529E ~                INC HL
 855+ 529E ~                LD (HL),0 ; +2
 856+ 529E ~                INC HL
 857+ 529E ~                LD (HL),255 ; +3
 858+ 529E ~                INC HL
 859+ 529E ~                DEC B
 860+ 529E ~                LD (HL),B ; +4
 861+ 529E ~                INC HL
 862+ 529E ~                LD A,(IX+8) ; +5
 863+ 529E ~                LD (HL),A
 864+ 529E ~                INC HL
 865+ 529E ~                INC HL
 866+ 529E ~                LD (HL),0 ; +7
 867+ 529E ~                XOR A ; success
 868+ 529E ~                RET
 869+ 529E ~            .ERR:
 870+ 529E ~                LD A,1
 871+ 529E ~                RET
 872+ 529E ~            ; *******************************************************************************************************
 873+ 529E               ENDIF
 874+ 529E
 875+ 529E
 876+ 529E               IF (1 == 1)
 877+ 529E              ; *******************************************************************************************************
 878+ 529E              ; function to handle CALL ANIMCHAR basic extension
 879+ 529E              ; ANIMCHAR ( BYTE id,
 880+ 529E              ;            INT character number 0-767,
 881+ 529E              ;            BYTE animation_definition_id,
 882+ 529E              ;            BYTE cyclic_flag )
 883+ 529E              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 884+ 529E              ANIMCHAR:
 885+ 529E                  ; opening (
 886+ 529E CD 88 67     	CALL CHKCHAR
 887+ 52A1 28           	DB '('
 888+ 52A2              	; get sprite animation id
 889+ 52A2 DD 21 1C 52  	LD IX, GETBYT
 890+ 52A6 CD 59 01     	CALL CALBAS
 891+ 52A9 F5               PUSH AF
 892+ 52AA 3C               INC A
 893+ 52AB 4F               LD C,A
 894+ 52AC 3A 67 4F         LD A,(ANIMSPRNUM)
 895+ 52AF B9               CP C
 896+ 52B0 DA AC 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 897+ 52B3              	; comma
 898+ 52B3 CD 88 67     	CALL CHKCHAR
 899+ 52B6 2C           	DB ','
 900+ 52B7              	; get character number
 901+ 52B7 DD 21 2F 54  	LD IX, FRMQNT
 902+ 52BB CD 59 01     	CALL CALBAS
 903+ 52BE D5               PUSH DE
 904+ 52BF                  ; check if out of bounds
 905+ 52BF 7A               LD A,D
 906+ 52C0 FE 03            CP 3
 907+ 52C2 D2 AC 67         JP NC, SUBSCRIPT_OUT_OF_RANGE
 908+ 52C5              	; comma
 909+ 52C5 CD 88 67     	CALL CHKCHAR
 910+ 52C8 2C           	DB ','
 911+ 52C9              	; get animation definition id
 912+ 52C9 DD 21 1C 52  	LD IX, GETBYT
 913+ 52CD CD 59 01     	CALL CALBAS
 914+ 52D0 F5               PUSH AF
 915+ 52D1 3C               INC A
 916+ 52D2 4F               LD C,A
 917+ 52D3 3A 64 4F         LD A,(ANIMDEFNUM)
 918+ 52D6 B9               CP C
 919+ 52D7 DA AC 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 920+ 52DA              	; comma
 921+ 52DA CD 88 67     	CALL CHKCHAR
 922+ 52DD 2C           	DB ','
 923+ 52DE              	; get cyclic flag
 924+ 52DE DD 21 1C 52  	LD IX, GETBYT
 925+ 52E2 CD 59 01         CALL CALBAS
 926+ 52E5 F5           	PUSH AF
 927+ 52E6              	; ending )
 928+ 52E6 CD 88 67     	CALL CHKCHAR
 929+ 52E9 29           	DB ')'
 930+ 52EA              .ENTRY:
 931+ 52EA E5               PUSH HL
 932+ 52EB DD E1            POP IX
 933+ 52ED D9               EXX
 934+ 52EE D1               POP DE ; cyclic
 935+ 52EF C1               POP BC ; animation definition id
 936+ 52F0 E1               POP HL ; character number
 937+ 52F1 D9               EXX
 938+ 52F2 F1               POP AF ; sprite animation id
 939+ 52F3 CD 8B 4F         CALL GETnthSPRANIM
 940+ 52F6 E5               PUSH HL
 941+ 52F7 FD E1            POP IY
 942+ 52F9 D9               EXX
 943+ 52FA FD 75 00         LD (IY),L
 944+ 52FD 24               INC H ; save character bank+1
 945+ 52FE FD 74 07         LD (IY+7),H
 946+ 5301 FD 70 04         LD (IY+4),B
 947+ 5304 FD 72 05         LD (IY+5),D
 948+ 5307                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 949+ 5307                  ; following will do preparation for ANIMSTEP situation
 950+ 5307                  ; current item set to above limit and timer to 1
 951+ 5307                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 952+ 5307 FD 36 03 FF      LD (IY+3),255
 953+ 530B FD 36 01 01      LD (IY+1),1
 954+ 530F FD 36 02 00      LD (IY+2),0
 955+ 5313 DD E5            PUSH IX
 956+ 5315 E1               POP HL
 957+ 5316 C9               RET
 958+ 5317              ; *******************************************************************************************************
 959+ 5317               ENDIF
 960+ 5317
 961+ 5317               IF (0 == 1)
 962+ 5317 ~            ; *******************************************************************************************************
 963+ 5317 ~            ; same as ANIMCHAR but for DEFUSR approach
 964+ 5317 ~            ; input IX=pointer to input array, real data from +2
 965+ 5317 ~            ; +02 = ID
 966+ 5317 ~            ; +04 = character number
 967+ 5317 ~            ; +06 = animation definition id
 968+ 5317 ~            ; +08 = cyclic flag
 969+ 5317 ~            ANIMCHAR_DEFUSR:
 970+ 5317 ~                LD C,(IX+2)
 971+ 5317 ~                INC C
 972+ 5317 ~                LD A,(ANIMSPRNUM)
 973+ 5317 ~                CP C
 974+ 5317 ~                JR C,.ERR ; invalid id
 975+ 5317 ~            	; get sprite number
 976+ 5317 ~                LD A,(IX+5)
 977+ 5317 ~                CP 3
 978+ 5317 ~                JR NC,.ERR ; invalid character (>767)
 979+ 5317 ~                LD B,(IX+6)
 980+ 5317 ~                INC B
 981+ 5317 ~                LD A,(ANIMDEFNUM)
 982+ 5317 ~                CP B
 983+ 5317 ~                JR C,.ERR ; invalid animation definition id
 984+ 5317 ~                LD A,C
 985+ 5317 ~                DEC A
 986+ 5317 ~                CALL GETnthSPRANIM
 987+ 5317 ~                LD A,(IX+4)
 988+ 5317 ~                LD (HL),A ; +0
 989+ 5317 ~                INC HL
 990+ 5317 ~                LD (HL),1 ; +1
 991+ 5317 ~                INC HL
 992+ 5317 ~                LD (HL),0 ; +2
 993+ 5317 ~                INC HL
 994+ 5317 ~                LD (HL),255 ; +3
 995+ 5317 ~                INC HL
 996+ 5317 ~                DEC B
 997+ 5317 ~                LD (HL),B ; +4
 998+ 5317 ~                INC HL
 999+ 5317 ~                LD A,(IX+8) ; +5
1000+ 5317 ~                LD (HL),A
1001+ 5317 ~                INC HL
1002+ 5317 ~                INC HL
1003+ 5317 ~                LD A,(IX+5)
1004+ 5317 ~                INC A
1005+ 5317 ~                LD (HL),A ; +7
1006+ 5317 ~                XOR A ; success
1007+ 5317 ~                RET
1008+ 5317 ~            .ERR:
1009+ 5317 ~                LD A,1
1010+ 5317 ~                RET
1011+ 5317 ~            ; *******************************************************************************************************
1012+ 5317               ENDIF
1013+ 5317
1014+ 5317               IF (0 == 1)
1015+ 5317 ~            ; *******************************************************************************************************
1016+ 5317 ~            ; same as MAXAUTOSGAMS but for DEFUSR approach
1017+ 5317 ~            ; input IX=pointer to input array, real data from +2
1018+ 5317 ~            ; +2 = number
1019+ 5317 ~            MAXAUTOSGAMS_DEFUSR:
1020+ 5317 ~                LD A,(IX+2)
1021+ 5317 ~                CALL MAXAUTOSGAMS.COMMON
1022+ 5317 ~                XOR A ; success
1023+ 5317 ~                RET
1024+ 5317 ~            ; *******************************************************************************************************
1025+ 5317               ENDIF
1026+ 5317
1027+ 5317              ; *******************************************************************************************************
1028+ 5317              ; function to handle CALL MAXAUTOSGAMS basic extension
1029+ 5317              ; MAXAUTOSGAMS (BYTE number)
1030+ 5317              ; sets new number and moves memory buffers as needed
1031+ 5317              MAXAUTOSGAMS:
1032+ 5317               IF (1 == 1)
1033+ 5317              	; opening (
1034+ 5317 CD 88 67     	CALL CHKCHAR
1035+ 531A 28           	DB '('
1036+ 531B              	; get value
1037+ 531B DD 21 1C 52  	LD IX, GETBYT
1038+ 531F CD 59 01     	CALL CALBAS
1039+ 5322 F5               PUSH AF
1040+ 5323              	; ending )
1041+ 5323 CD 88 67     	CALL CHKCHAR
1042+ 5326 29           	DB ')'
1043+ 5327 F1               POP AF
1044+ 5328               ENDIF
1045+ 5328              .COMMON:
1046+ 5328 F3               DI
1047+ 5329              	; save position
1048+ 5329 E5           	PUSH HL
1049+ 532A              .ENTRY:
1050+ 532A 47               LD B,A
1051+ 532B 3A 6A 4F         LD A,(AUTOSGAMNUM)
1052+ 532E 90               SUB B
1053+ 532F CA E9 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
1054+ 5332 FD 21 10 40      LD IY,FREEMEMPTR
1055+ 5336 FA 42 53         JP M, .INCREASE
1056+ 5339                  ; new value is lower than previous one
1057+ 5339 CD 63 53         CALL .SIZEDIFF
1058+ 533C CD 26 50         CALL MAXANIMITEMS.DECREASE_COMMON
1059+ 533F C3 E9 4F         JP MAXANIMITEMS.EXIT
1060+ 5342              .INCREASE:
1061+ 5342 ED 44            NEG
1062+ 5344 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
1063+ 5345 CD 63 53         CALL .SIZEDIFF
1064+ 5348 CD 52 50         CALL MAXANIMITEMS.INCREASE_COMMON
1065+ 534B AF               XOR A
1066+ 534C ED 42            SBC HL,BC ; location of new stuff
1067+ 534E F1               POP AF
1068+ 534F C5               PUSH BC
1069+ 5350 47               LD B,A
1070+ 5351 11 18 00         LD DE,24
1071+ 5354 E5               PUSH HL
1072+ 5355 DD E1            POP IX
1073+ 5357              .L1:
1074+ 5357 DD 36 13 00      LD (IX+19),0 ; active flag
1075+ 535B DD 19            ADD IX,DE
1076+ 535D 10 F8            DJNZ .L1
1077+ 535F C1               POP BC
1078+ 5360 C3 E9 4F         JP MAXANIMITEMS.EXIT
1079+ 5363              .SIZEDIFF:
1080+ 5363 26 00            LD H,0
1081+ 5365 6F               LD L,A
1082+ 5366 CD 75 66         CALL HLx8
1083+ 5369 54               LD D,H
1084+ 536A 5D               LD E,L
1085+ 536B 29               ADD HL,HL
1086+ 536C 19               ADD HL,DE
1087+ 536D 78               LD A,B
1088+ 536E 32 6A 4F         LD (AUTOSGAMNUM),A
1089+ 5371 44               LD B,H
1090+ 5372 4D               LD C,L
1091+ 5373 C9               RET ; BC=size difference in bytes
1092+ 5374              ; *******************************************************************************************************
1093+ 5374
1094+ 5374               IF (1 == 1)
1095+ 5374              ; *******************************************************************************************************
1096+ 5374              ; function to handle CALL AUTOSGAMDEF basic extension
1097+ 5374              ; AUTOSGAMDEF ( BYTE id,
1098+ 5374              ;               INT VARIABLE x, INT VARIABLE y,
1099+ 5374              ;               INT minimum, INT maximum, INT delta,
1100+ 5374              ;               INT direction =0 horizontal,
1101+ 5374              ;               INT ticks,
1102+ 5374              ;               BYTE sprite_group_count,
1103+ 5374              ;               INT[2][sprite_group_count] VARIABLE sprite_group,
1104+ 5374              ;               BYTE item_number,
1105+ 5374              ;               INT[] VARIABLE sprite_animations_negative_direction,
1106+ 5374              ;               INT[] VARIABLE sprite_animations_positive_direction
1107+ 5374              AUTOSGAMDEF:
1108+ 5374                  ; opening (
1109+ 5374 CD 88 67     	CALL CHKCHAR
1110+ 5377 28           	DB '('
1111+ 5378              	; get sprite animation id
1112+ 5378 DD 21 1C 52  	LD IX, GETBYT
1113+ 537C CD 59 01     	CALL CALBAS
1114+ 537F F5               PUSH AF
1115+ 5380 3C               INC A
1116+ 5381 4F               LD C,A
1117+ 5382 3A 6A 4F         LD A,(AUTOSGAMNUM)
1118+ 5385 B9               CP C
1119+ 5386 DA AC 67         JP C,SUBSCRIPT_OUT_OF_RANGE
1120+ 5389 F1               POP AF
1121+ 538A E5               PUSH HL
1122+ 538B CD 97 4F         CALL GETnthAUTOSGAM
1123+ 538E 22 4D 64         LD (BLIT_TMP),HL ; for later
1124+ 5391 E1               POP HL
1125+ 5392              	; comma
1126+ 5392 CD 88 67     	CALL CHKCHAR
1127+ 5395 2C           	DB ','
1128+ 5396              	; get address of the X coordinate variable
1129+ 5396 DD 21 A4 5E  	LD IX, PTRGET
1130+ 539A CD 59 01     	CALL CALBAS
1131+ 539D DD 2A 4D 64  	LD IX,(BLIT_TMP)
1132+ 53A1 DD 73 00         LD (IX+0),E
1133+ 53A4 DD 72 01         LD (IX+1),D
1134+ 53A7              	; comma
1135+ 53A7 CD 88 67     	CALL CHKCHAR
1136+ 53AA 2C           	DB ','
1137+ 53AB              	; get address of the Y coordinate variable
1138+ 53AB DD 21 A4 5E  	LD IX, PTRGET
1139+ 53AF CD 59 01     	CALL CALBAS
1140+ 53B2 DD 2A 4D 64  	LD IX,(BLIT_TMP)
1141+ 53B6 DD 73 02         LD (IX+2),E
1142+ 53B9 DD 72 03         LD (IX+3),D
1143+ 53BC              	; comma
1144+ 53BC CD 88 67     	CALL CHKCHAR
1145+ 53BF 2C           	DB ','
1146+ 53C0              	; get minimum value
1147+ 53C0 DD 21 2F 54  	LD IX, FRMQNT
1148+ 53C4 CD 59 01     	CALL CALBAS
1149+ 53C7 DD 2A 4D 64  	LD IX,(BLIT_TMP)
1150+ 53CB DD 73 04         LD (IX+4),E
1151+ 53CE DD 72 05         LD (IX+5),D
1152+ 53D1              	; comma
1153+ 53D1 CD 88 67     	CALL CHKCHAR
1154+ 53D4 2C           	DB ','
1155+ 53D5              	; get maximum value
1156+ 53D5 DD 21 2F 54  	LD IX, FRMQNT
1157+ 53D9 CD 59 01     	CALL CALBAS
1158+ 53DC DD 2A 4D 64  	LD IX,(BLIT_TMP)
1159+ 53E0 DD 73 06         LD (IX+6),E
1160+ 53E3 DD 72 07         LD (IX+7),D
1161+ 53E6              	; comma
1162+ 53E6 CD 88 67     	CALL CHKCHAR
1163+ 53E9 2C           	DB ','
1164+ 53EA              	; get delta value
1165+ 53EA DD 21 2F 54  	LD IX, FRMQNT
1166+ 53EE CD 59 01     	CALL CALBAS
1167+ 53F1 DD 2A 4D 64  	LD IX,(BLIT_TMP)
1168+ 53F5 DD 73 08         LD (IX+8),E
1169+ 53F8 DD 72 09         LD (IX+9),D
1170+ 53FB              	; comma
1171+ 53FB CD 88 67     	CALL CHKCHAR
1172+ 53FE 2C           	DB ','
1173+ 53FF              	; get direction value
1174+ 53FF DD 21 2F 54  	LD IX, FRMQNT
1175+ 5403 CD 59 01     	CALL CALBAS
1176+ 5406 DD 2A 4D 64  	LD IX,(BLIT_TMP)
1177+ 540A DD 73 0A         LD (IX+10),E
1178+ 540D              	; comma
1179+ 540D CD 88 67     	CALL CHKCHAR
1180+ 5410 2C           	DB ','
1181+ 5411              	; get ticks value
1182+ 5411 DD 21 2F 54  	LD IX, FRMQNT
1183+ 5415 CD 59 01     	CALL CALBAS
1184+ 5418 DD 2A 4D 64  	LD IX,(BLIT_TMP)
1185+ 541C DD 73 14         LD (IX+20),E
1186+ 541F DD 72 15         LD (IX+21),D
1187+ 5422              	; comma
1188+ 5422 CD 88 67     	CALL CHKCHAR
1189+ 5425 2C           	DB ','
1190+ 5426              	; get sprite group count
1191+ 5426 DD 21 1C 52  	LD IX, GETBYT
1192+ 542A CD 59 01     	CALL CALBAS
1193+ 542D B7               OR A
1194+ 542E CA AC 67         JP Z,SUBSCRIPT_OUT_OF_RANGE
1195+ 5431 DD 2A 4D 64  	LD IX,(BLIT_TMP)
1196+ 5435 DD 77 0B         LD (IX+11),A
1197+ 5438              	; comma
1198+ 5438 CD 88 67     	CALL CHKCHAR
1199+ 543B 2C           	DB ','
1200+ 543C              	; get sprite group definition array data pointer
1201+ 543C DD 2A 4D 64  	LD IX,(BLIT_TMP)
1202+ 5440 DD 5E 0B         LD E,(IX+11)
1203+ 5443 16 03        	LD D,3
1204+ 5445 3E 02        	LD A,2
1205+ 5447 47           	LD B,A
1206+ 5448 CD ED 67     	CALL GET_BASIC_ARRAY_DATA_POINTER
1207+ 544B DD 2A 4D 64  	LD IX,(BLIT_TMP)
1208+ 544F DD 71 0C     	LD (IX+12),C
1209+ 5452 DD 70 0D         LD (IX+13),B
1210+ 5455              	; comma
1211+ 5455 CD 88 67     	CALL CHKCHAR
1212+ 5458 2C           	DB ','
1213+ 5459              	; get sprite animation array size
1214+ 5459 DD 21 1C 52  	LD IX,GETBYT
1215+ 545D CD 59 01     	CALL CALBAS
1216+ 5460 DD 2A 4D 64  	LD IX,(BLIT_TMP)
1217+ 5464 DD 77 0E         LD (IX+14),A
1218+ 5467 B7               OR A
1219+ 5468 CA AC 67         JP Z,SUBSCRIPT_OUT_OF_RANGE
1220+ 546B              	; comma
1221+ 546B CD 88 67     	CALL CHKCHAR
1222+ 546E 2C           	DB ','
1223+ 546F                  ; get array pointer for negative direction
1224+ 546F DD 2A 4D 64  	LD IX,(BLIT_TMP)
1225+ 5473 DD 56 0E         LD D,(IX+14)
1226+ 5476 3E 02            LD A,2
1227+ 5478 06 01            LD B,1
1228+ 547A CD ED 67         CALL GET_BASIC_ARRAY_DATA_POINTER
1229+ 547D DD 2A 4D 64  	LD IX,(BLIT_TMP)
1230+ 5481 DD 71 0F         LD (IX+15),C
1231+ 5484 DD 70 10         LD (IX+16),B
1232+ 5487              	; comma
1233+ 5487 CD 88 67     	CALL CHKCHAR
1234+ 548A 2C           	DB ','
1235+ 548B                  ; get array pointer for positive direction
1236+ 548B DD 2A 4D 64  	LD IX,(BLIT_TMP)
1237+ 548F DD 56 0E         LD D,(IX+14)
1238+ 5492 3E 02            LD A,2
1239+ 5494 06 01            LD B,1
1240+ 5496 CD ED 67         CALL GET_BASIC_ARRAY_DATA_POINTER
1241+ 5499 DD 2A 4D 64  	LD IX,(BLIT_TMP)
1242+ 549D DD 71 11         LD (IX+17),C
1243+ 54A0 DD 70 12         LD (IX+18),B
1244+ 54A3              	; ending )
1245+ 54A3 CD 88 67     	CALL CHKCHAR
1246+ 54A6 29           	DB ')'
1247+ 54A7 C9               RET
1248+ 54A8              ; *******************************************************************************************************
1249+ 54A8               ENDIF
1250+ 54A8
1251+ 54A8               IF (0 == 1)
1252+ 54A8 ~            ; *******************************************************************************************************
1253+ 54A8 ~            ; same as AUTOSGAMDEF but for DEFUSR approach
1254+ 54A8 ~            ; input IX=pointer to input array, real data from +2
1255+ 54A8 ~            ; +02 = ID
1256+ 54A8 ~            ; +04 = pointer to X variable
1257+ 54A8 ~            ; +06 = pointer to Y variable
1258+ 54A8 ~            ; +08 = minimum
1259+ 54A8 ~            ; +10 = maximum
1260+ 54A8 ~            ; +12 = delta
1261+ 54A8 ~            ; +14 = direction
1262+ 54A8 ~            ; +16 = ticks
1263+ 54A8 ~            ; +18 = sprite group count
1264+ 54A8 ~            ; +20 = sprite group array pointer
1265+ 54A8 ~            ; +22 = item number
1266+ 54A8 ~            ; +24 = sprite animations negative direction array pointer
1267+ 54A8 ~            ; +26 = sprite animations positive direction array pointer
1268+ 54A8 ~            AUTOSGAMDEF_DEFUSR:
1269+ 54A8 ~                LD C,(IX+2)
1270+ 54A8 ~                INC C
1271+ 54A8 ~                LD A,(AUTOSGAMNUM)
1272+ 54A8 ~                CP C
1273+ 54A8 ~                JP C,.ERR ; invalid id
1274+ 54A8 ~                LD A,C
1275+ 54A8 ~                DEC A
1276+ 54A8 ~                CALL GETnthAUTOSGAM
1277+ 54A8 ~                PUSH HL
1278+ 54A8 ~                POP IY
1279+ 54A8 ~                ; X variable
1280+ 54A8 ~                LD A,(IX+4)
1281+ 54A8 ~                LD (IY+0),A
1282+ 54A8 ~                LD A,(IX+5)
1283+ 54A8 ~                LD (IY+1),A
1284+ 54A8 ~            	; Y variable
1285+ 54A8 ~                LD A,(IX+6)
1286+ 54A8 ~                LD (IY+2),A
1287+ 54A8 ~                LD A,(IX+7)
1288+ 54A8 ~                LD (IY+3),A
1289+ 54A8 ~            	; get minimum value
1290+ 54A8 ~                LD A,(IX+8)
1291+ 54A8 ~                LD (IY+4),A
1292+ 54A8 ~                LD A,(IX+9)
1293+ 54A8 ~                LD (IY+5),A
1294+ 54A8 ~            	; get maximum value
1295+ 54A8 ~                LD A,(IX+10)
1296+ 54A8 ~                LD (IY+6),A
1297+ 54A8 ~                LD A,(IX+11)
1298+ 54A8 ~                LD (IY+7),A
1299+ 54A8 ~            	; get delta value
1300+ 54A8 ~                LD A,(IX+12)
1301+ 54A8 ~                LD (IY+8),A
1302+ 54A8 ~                LD A,(IX+13)
1303+ 54A8 ~                LD (IY+9),A
1304+ 54A8 ~            	; get direction value
1305+ 54A8 ~                LD A,(IX+14)
1306+ 54A8 ~                LD (IY+10),A
1307+ 54A8 ~            	; get ticks value
1308+ 54A8 ~                LD A,(IX+16)
1309+ 54A8 ~                LD (IY+20),A
1310+ 54A8 ~                LD A,(IX+17)
1311+ 54A8 ~                LD (IY+21),A
1312+ 54A8 ~            	; get sprite group count
1313+ 54A8 ~                LD A,(IX+18)
1314+ 54A8 ~                LD (IY+11),A
1315+ 54A8 ~            	; get sprite group definition array data pointer
1316+ 54A8 ~                LD A,(IX+20)
1317+ 54A8 ~                LD (IY+12),A
1318+ 54A8 ~                LD A,(IX+21)
1319+ 54A8 ~                LD (IY+13),A
1320+ 54A8 ~            	; get sprite animation array size
1321+ 54A8 ~                LD A,(IX+22)
1322+ 54A8 ~                LD (IY+14),A
1323+ 54A8 ~                ; get array pointer for negative direction
1324+ 54A8 ~                LD A,(IX+24)
1325+ 54A8 ~                LD (IY+15),A
1326+ 54A8 ~                LD A,(IX+25)
1327+ 54A8 ~                LD (IY+16),A
1328+ 54A8 ~                ; get array pointer for positive direction
1329+ 54A8 ~                LD A,(IX+26)
1330+ 54A8 ~                LD (IY+17),A
1331+ 54A8 ~                LD A,(IX+27)
1332+ 54A8 ~                LD (IY+18),A
1333+ 54A8 ~                XOR A ; success
1334+ 54A8 ~                RET
1335+ 54A8 ~            .ERR:
1336+ 54A8 ~                LD A,1
1337+ 54A8 ~                RET
1338+ 54A8 ~            ; *******************************************************************************************************
1339+ 54A8               ENDIF
1340+ 54A8
1341+ 54A8               IF (1 == 1)
1342+ 54A8              ; *******************************************************************************************************
1343+ 54A8              ; function to handle CALL AUTOSGAMSTART basic extension
1344+ 54A8              ; AUTOSGAMSTART ( BYTE id )
1345+ 54A8              AUTOSGAMSTART:
1346+ 54A8 3E 01            LD A,1
1347+ 54AA              .COMMON:
1348+ 54AA 32 D6 54         LD (.SETVALUE+3),A
1349+ 54AD                  ; opening (
1350+ 54AD CD 88 67     	CALL CHKCHAR
1351+ 54B0 28           	DB '('
1352+ 54B1              	; get sprite animation id
1353+ 54B1 DD 21 1C 52  	LD IX, GETBYT
1354+ 54B5 CD 59 01     	CALL CALBAS
1355+ 54B8 F5               PUSH AF
1356+ 54B9 3C               INC A
1357+ 54BA 4F               LD C,A
1358+ 54BB 3A 6A 4F         LD A,(AUTOSGAMNUM)
1359+ 54BE B9               CP C
1360+ 54BF DA AC 67         JP C,SUBSCRIPT_OUT_OF_RANGE
1361+ 54C2 F1               POP AF
1362+ 54C3 E5               PUSH HL
1363+ 54C4 CD 97 4F         CALL GETnthAUTOSGAM
1364+ 54C7 E5               PUSH HL
1365+ 54C8 DD E1            POP IX
1366+ 54CA E1               POP HL
1367+ 54CB DD E5            PUSH IX
1368+ 54CD              	; ending )
1369+ 54CD CD 88 67     	CALL CHKCHAR
1370+ 54D0 29           	DB ')'
1371+ 54D1
1372+ 54D1                  ; so syntax is fine
1373+ 54D1 DD E1            POP IX
1374+ 54D3              .SETVALUE:
1375+ 54D3 DD 36 13 01      LD (IX+19),1 ; active flag
1376+ 54D7                  ; set initial timer
1377+ 54D7 DD 7E 14         LD A,(IX+20)
1378+ 54DA DD 77 16         LD (IX+22),A
1379+ 54DD DD 7E 15         LD A,(IX+21)
1380+ 54E0 DD 77 17         LD (IX+23),A
1381+ 54E3 C9               RET
1382+ 54E4              ; *******************************************************************************************************
1383+ 54E4
1384+ 54E4              ; *******************************************************************************************************
1385+ 54E4              ; function to handle CALL AUTOSGAMSTOP basic extension
1386+ 54E4              ; AUTOSGAMSTOP ( BYTE id )
1387+ 54E4              AUTOSGAMSTOP:
1388+ 54E4 AF               XOR A
1389+ 54E5 18 C3            JR AUTOSGAMSTART.COMMON
1390+ 54E7              ; *******************************************************************************************************
1391+ 54E7               ENDIF
1392+ 54E7
1393+ 54E7               IF (0 == 1)
1394+ 54E7 ~            ; *******************************************************************************************************
1395+ 54E7 ~            ; function to handle CALL AUTOSGAMSTART basic extension in DEFUSR mode
1396+ 54E7 ~            ; input IX=pointer to input array, real data from +2
1397+ 54E7 ~            ; +2 = source address
1398+ 54E7 ~            AUTOSGAMSTART_DEFUSR:
1399+ 54E7 ~                LD A,1
1400+ 54E7 ~            .COMMON:
1401+ 54E7 ~                LD (.SETVALUE+3),A
1402+ 54E7 ~                LD C,(IX+2)
1403+ 54E7 ~                INC C
1404+ 54E7 ~                LD A,(AUTOSGAMNUM)
1405+ 54E7 ~                CP C
1406+ 54E7 ~                JR C,.ERR ; invalid id
1407+ 54E7 ~                LD A,C
1408+ 54E7 ~                DEC A
1409+ 54E7 ~                CALL GETnthAUTOSGAM
1410+ 54E7 ~                PUSH HL
1411+ 54E7 ~                POP IX
1412+ 54E7 ~            .SETVALUE:
1413+ 54E7 ~                LD (IX+19),1 ; active flag
1414+ 54E7 ~                ; set initial timer
1415+ 54E7 ~                LD A,(IX+20)
1416+ 54E7 ~                LD (IX+22),A
1417+ 54E7 ~                LD A,(IX+21)
1418+ 54E7 ~                LD (IX+23),A
1419+ 54E7 ~                XOR A ; success
1420+ 54E7 ~                RET
1421+ 54E7 ~            .ERR:
1422+ 54E7 ~                LD A,1
1423+ 54E7 ~                RET
1424+ 54E7 ~            ; *******************************************************************************************************
1425+ 54E7 ~
1426+ 54E7 ~            ; *******************************************************************************************************
1427+ 54E7 ~            ; function to handle CALL AUTOSGAMSTOP basic extension in DEFUSR mode
1428+ 54E7 ~            ; input IX=pointer to input array, real data from +2
1429+ 54E7 ~            ; +2 = source address
1430+ 54E7 ~            AUTOSGAMSTOP_DEFUSR:
1431+ 54E7 ~                XOR A
1432+ 54E7 ~                JR AUTOSGAMSTART_DEFUSR.COMMON
1433+ 54E7 ~            ; *******************************************************************************************************
1434+ 54E7               ENDIF
1435+ 54E7
1436+ 54E7               IF (1 == 1)
1437+ 54E7              ; *******************************************************************************************************
1438+ 54E7              ; function to handle CALL ANIMSTEP basic extension
1439+ 54E7              ; two forms
1440+ 54E7              ; ANIMSTEP ( BYTE id )
1441+ 54E7              ; or
1442+ 54E7              ; ANIMSTEP ( BYTE item_number,
1443+ 54E7              ;            INT[] sprite_animations )
1444+ 54E7              ANIMSTEP:
1445+ 54E7 11 66 55         LD DE,ANIMSTARTSTOP_COMMON.STEP
1446+ 54EA 18 08            JR ANIMSTARTSTOP_COMMON
1447+ 54EC              ; *******************************************************************************************************
1448+ 54EC              ; *******************************************************************************************************
1449+ 54EC              ; function to handle CALL ANIMSTART basic extension
1450+ 54EC              ; two forms
1451+ 54EC              ; ANIMSTART ( BYTE id )
1452+ 54EC              ; or
1453+ 54EC              ; ANIMSTART ( BYTE item_number,
1454+ 54EC              ;             INT[] sprite_animations )
1455+ 54EC              ; sets active flag to 1
1456+ 54EC              ANIMSTART:
1457+ 54EC 11 54 55         LD DE,ANIMSTARTSTOP_COMMON.START
1458+ 54EF 18 03            JR ANIMSTARTSTOP_COMMON
1459+ 54F1              ; *******************************************************************************************************
1460+ 54F1              ; *******************************************************************************************************
1461+ 54F1              ; function to handle CALL ANIMSTOP basic extension
1462+ 54F1              ; two forms
1463+ 54F1              ; ANIMSTOP ( BYTE id )
1464+ 54F1              ; or
1465+ 54F1              ; ANIMSTOP ( BYTE item_number,
1466+ 54F1              ;            INT[] sprite_animations )
1467+ 54F1              ; sets active flag to 0
1468+ 54F1              ANIMSTOP:
1469+ 54F1 11 61 55         LD DE,ANIMSTARTSTOP_COMMON.STOP
1470+ 54F4              ; *******************************************************************************************************
1471+ 54F4              ANIMSTARTSTOP_COMMON:
1472+ 54F4 ED 53 52 55      LD (ANIMSTARTSTOP_COMMON.FN+1),DE
1473+ 54F8                  ; opening (
1474+ 54F8 CD 88 67     	CALL CHKCHAR
1475+ 54FB 28           	DB '('
1476+ 54FC              	; get sprite animation id or array size
1477+ 54FC DD 21 1C 52  	LD IX,GETBYT
1478+ 5500 CD 59 01     	CALL CALBAS
1479+ 5503 F5               PUSH AF
1480+ 5504                  ; check if comma present
1481+ 5504 CD 92 67         CALL GETPREVCHAR
1482+ 5507 23               INC HL
1483+ 5508 FE 2C            CP ','
1484+ 550A 28 0E            JR Z,.L1
1485+ 550C FE 29            CP ')'
1486+ 550E C2 B8 67         JP NZ,SYNTAX_ERROR
1487+ 5511                  ; ok so single argument variant
1488+ 5511 F1               POP AF
1489+ 5512 E5               PUSH HL
1490+ 5513 F3               DI
1491+ 5514 CD 40 55         CALL .SETVALUE
1492+ 5517 FB               EI
1493+ 5518 E1               POP HL
1494+ 5519 C9               RET
1495+ 551A              .L1:
1496+ 551A                  ; get array pointer
1497+ 551A D1               POP DE
1498+ 551B D5               PUSH DE
1499+ 551C 3E 02            LD A,2
1500+ 551E 06 01            LD B,1
1501+ 5520 CD ED 67         CALL GET_BASIC_ARRAY_DATA_POINTER
1502+ 5523 C5               PUSH BC
1503+ 5524              	; ending )
1504+ 5524 CD 88 67     	CALL CHKCHAR
1505+ 5527 29           	DB ')'
1506+ 5528 D1               POP DE ; array pointer
1507+ 5529 C1               POP BC ; number of items
1508+ 552A 78               LD A,B
1509+ 552B B7               OR A
1510+ 552C CA AC 67         JP Z,SUBSCRIPT_OUT_OF_RANGE
1511+ 552F E5               PUSH HL
1512+ 5530 F3               DI
1513+ 5531              .L2:
1514+ 5531 C5               PUSH BC
1515+ 5532 1A               LD A,(DE)
1516+ 5533 13          > INC DE
1516+ 5534 13          > INC DE
1517+ 5535 D5               PUSH DE
1518+ 5536 CD 40 55         CALL .SETVALUE
1519+ 5539 D1               POP DE
1520+ 553A C1               POP BC
1521+ 553B 10 F4            DJNZ .L2
1522+ 553D FB               EI
1523+ 553E E1               POP HL
1524+ 553F C9               RET
1525+ 5540
1526+ 5540              .SETVALUE:
1527+ 5540 47               LD B,A
1528+ 5541 3C               INC A
1529+ 5542 4F               LD C,A
1530+ 5543 3A 67 4F         LD A,(ANIMSPRNUM)
1531+ 5546 B9               CP C
1532+ 5547 DA AC 67         JP C,SUBSCRIPT_OUT_OF_RANGE
1533+ 554A 78               LD A,B
1534+ 554B CD 8B 4F         CALL GETnthSPRANIM
1535+ 554E E5               PUSH HL
1536+ 554F DD E1            POP IX
1537+ 5551              .FN:
1538+ 5551 C3 00 00         JP 0
1539+ 5554              .START:
1540+ 5554 DD 36 06 01      LD (IX+6),1 ; active flag
1541+ 5558 DD 36 03 00      LD (IX+3),0 ; current item
1542+ 555C 06 00            LD B,0 ; setup timer
1543+ 555E C3 F7 55         JP SETUP_ANIM_STEP
1544+ 5561              .STOP:
1545+ 5561 DD 36 06 00      LD (IX+6),0 ; active flag
1546+ 5565 C9               RET
1547+ 5566              .STEP:
1548+ 5566 06 00            LD B,0
1549+ 5568 C3 9B 55         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1550+ 556B              ; *******************************************************************************************************
1551+ 556B               ENDIF
1552+ 556B
1553+ 556B              ; *******************************************************************************************************
1554+ 556B              ; helper function to locate single animation and execute operation
1555+ 556B              ; needs to have jump set to a correct function
1556+ 556B              ; used by SGAM helper routines so always needed
1557+ 556B              ; input A=animation item
1558+ 556B              ANIM_SETVALUE:
1559+ 556B 47               LD B,A
1560+ 556C 3C               INC A
1561+ 556D 4F               LD C,A
1562+ 556E 3A 67 4F         LD A,(ANIMSPRNUM)
1563+ 5571 B9               CP C
1564+ 5572 D8               RET C ; out of range, so do nothing
1565+ 5573 78               LD A,B
1566+ 5574 CD 8B 4F         CALL GETnthSPRANIM
1567+ 5577 E5               PUSH HL
1568+ 5578 DD E1            POP IX
1569+ 557A              .FN:
1570+ 557A C3 00 00         JP 0
1571+ 557D              ; *******************************************************************************************************
1572+ 557D
1573+ 557D               IF (0 == 1)
1574+ 557D ~            ; *******************************************************************************************************
1575+ 557D ~            ; helper function to set values of multiple animations
1576+ 557D ~            ; needs to have jump set to a correct function
1577+ 557D ~            ; input B=number of animation item
1578+ 557D ~            ; input DE=animation item array
1579+ 557D ~            ANIM_LIST_SETVALUE:
1580+ 557D ~                DI
1581+ 557D ~                PUSH BC
1582+ 557D ~                LD A,(DE)
1583+ 557D ~                .2 INC DE
1584+ 557D ~                PUSH DE
1585+ 557D ~                CALL ANIM_SETVALUE
1586+ 557D ~                POP DE
1587+ 557D ~                POP BC
1588+ 557D ~                DJNZ ANIM_LIST_SETVALUE
1589+ 557D ~                EI
1590+ 557D ~                RET
1591+ 557D ~            ; *******************************************************************************************************
1592+ 557D ~
1593+ 557D ~            ; *******************************************************************************************************
1594+ 557D ~            ; function to handle single item ANIMSTEP in DEFUSR mode
1595+ 557D ~            ; input IX=pointer to input array, real data from +2
1596+ 557D ~            ; +2 = animation id
1597+ 557D ~            ANIMSTEP_SINGLE_DEFUSR:
1598+ 557D ~                LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1599+ 557D ~            .L1:
1600+ 557D ~                LD (ANIM_SETVALUE.FN+1),HL
1601+ 557D ~                LD A,(IX+2)
1602+ 557D ~                JR ANIM_SETVALUE
1603+ 557D ~            .STEP:
1604+ 557D ~                LD B,0
1605+ 557D ~                JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1606+ 557D ~            ; *******************************************************************************************************
1607+ 557D ~
1608+ 557D ~            ; *******************************************************************************************************
1609+ 557D ~            ; function to handle multi item ANIMSTEP in DEFUSR mode
1610+ 557D ~            ; input IX=pointer to input array, real data from +2
1611+ 557D ~            ; +2 = list size
1612+ 557D ~            ; +4 = array pointer holding items
1613+ 557D ~            ANIMSTEP_MULTI_DEFUSR:
1614+ 557D ~                LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1615+ 557D ~            .L1:
1616+ 557D ~                LD (ANIM_SETVALUE.FN+1),HL
1617+ 557D ~                LD B,(IX+2)
1618+ 557D ~                LD E,(IX+4)
1619+ 557D ~                LD D,(IX+5)
1620+ 557D ~                JR ANIM_LIST_SETVALUE
1621+ 557D ~            ; *******************************************************************************************************
1622+ 557D ~
1623+ 557D ~            ; *******************************************************************************************************
1624+ 557D ~            ; function to handle single item ANIMSTART in DEFUSR mode
1625+ 557D ~            ; input IX=pointer to input array, real data from +2
1626+ 557D ~            ; +2 = animation id
1627+ 557D ~            ANIMSTART_SINGLE_DEFUSR:
1628+ 557D ~                LD HL,ANIMSTART_SINGLE_DEFUSR.START
1629+ 557D ~                JR ANIMSTEP_SINGLE_DEFUSR.L1
1630+ 557D ~            .START:
1631+ 557D ~                LD (IX+6),1 ; active flag
1632+ 557D ~                LD (IX+3),0 ; current item
1633+ 557D ~                LD B,0 ; setup timer
1634+ 557D ~                JP SETUP_ANIM_STEP
1635+ 557D ~            ; *******************************************************************************************************
1636+ 557D ~
1637+ 557D ~            ; *******************************************************************************************************
1638+ 557D ~            ; function to handle multi item ANIMSTART in DEFUSR mode
1639+ 557D ~            ; input IX=pointer to input array, real data from +2
1640+ 557D ~            ; +2 = list size
1641+ 557D ~            ; +4 = array pointer holding items
1642+ 557D ~            ANIMSTART_MULTI_DEFUSR:
1643+ 557D ~                LD HL,ANIMSTART_SINGLE_DEFUSR.START
1644+ 557D ~                JR ANIMSTEP_MULTI_DEFUSR.L1
1645+ 557D ~            ; *******************************************************************************************************
1646+ 557D ~
1647+ 557D ~            ; *******************************************************************************************************
1648+ 557D ~            ; function to handle single item ANIMSTOP in DEFUSR mode
1649+ 557D ~            ; input IX=pointer to input array, real data from +2
1650+ 557D ~            ; +2 = animation id
1651+ 557D ~            ANIMSTOP_SINGLE_DEFUSR:
1652+ 557D ~                LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1653+ 557D ~                JR ANIMSTEP_SINGLE_DEFUSR.L1
1654+ 557D ~            .STOP:
1655+ 557D ~                LD (IX+6),0 ; active flag
1656+ 557D ~                RET
1657+ 557D ~            ; *******************************************************************************************************
1658+ 557D ~
1659+ 557D ~            ; *******************************************************************************************************
1660+ 557D ~            ; function to handle multi item ANIMSTOP in DEFUSR mode
1661+ 557D ~            ; input IX=pointer to input array, real data from +2
1662+ 557D ~            ; +2 = list size
1663+ 557D ~            ; +4 = array pointer holding items
1664+ 557D ~            ANIMSTOP_MULTI_DEFUSR:
1665+ 557D ~                LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1666+ 557D ~                JR ANIMSTEP_MULTI_DEFUSR.L1
1667+ 557D ~            ; *******************************************************************************************************
1668+ 557D               ENDIF
1669+ 557D
1670+ 557D              ; *******************************************************************************************************
1671+ 557D              ; function processes animations during vblank period
1672+ 557D              PROCESS_ANIMATIONS:
1673+ 557D 3A 67 4F         LD A,(ANIMSPRNUM)
1674+ 5580 B7               OR A
1675+ 5581 C8               RET Z; no animations defined
1676+ 5582 47               LD B,A
1677+ 5583 DD 2A 68 4F      LD IX,(ANIMSPRPTR)
1678+ 5587              .L1:
1679+ 5587 C5               PUSH BC
1680+ 5588 06 00            LD B,0 ; normal mode, change on timer expiry only
1681+ 558A CD 96 55         CALL PROCESS_SINGLE_ANIMATION
1682+ 558D 11 08 00         LD DE,8
1683+ 5590 DD 19            ADD IX,DE
1684+ 5592 C1               POP BC
1685+ 5593 10 F2            DJNZ .L1
1686+ 5595 C9               RET
1687+ 5596              ; *******************************************************************************************************
1688+ 5596
1689+ 5596              ; *******************************************************************************************************
1690+ 5596              ; processes single sprite animation
1691+ 5596              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
1692+ 5596              ; on timer expiry goes to next animation item
1693+ 5596              ; input IX=sprite animation pointer
1694+ 5596              ; input B=1 force mode, activate animation action regardless of expired timer
1695+ 5596              PROCESS_SINGLE_ANIMATION:
1696+ 5596 DD 7E 06         LD A,(IX+6); active
1697+ 5599 B7               OR A
1698+ 559A C8               RET Z ; inactive animation
1699+ 559B              .INACTIVE_TOO:
1700+ 559B DD 6E 01         LD L,(IX+1)
1701+ 559E DD 66 02         LD H,(IX+2) ; HL=end time
1702+ 55A1 2B               DEC HL
1703+ 55A2 DD 75 01         LD (IX+1),L
1704+ 55A5 DD 74 02         LD (IX+2),H
1705+ 55A8 7D               LD A,L
1706+ 55A9 B4               OR H
1707+ 55AA 28 06            JR Z,.STEP
1708+ 55AC 05               DEC B
1709+ 55AD 04               INC B
1710+ 55AE C8               RET Z ; not forced mode, return
1711+ 55AF C3 F7 55         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
1712+ 55B2              .STEP:
1713+ 55B2 06 00            LD B,0; setup timer
1714+ 55B4 DD 34 03         INC (IX+3) ; current animation item
1715+ 55B7 C3 F7 55         JP SETUP_ANIM_STEP
1716+ 55BA              ; *******************************************************************************************************
1717+ 55BA
1718+ 55BA              ; *******************************************************************************************************
1719+ 55BA              ; function will setup sprite animation after current item change
1720+ 55BA              ; input A=current animation definition
1721+ 55BA              ; input IX=pointer to sprite animation
1722+ 55BA              ; input B=1 skip timer setup
1723+ 55BA              ; output IY=pointer to animation item
1724+ 55BA              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
1725+ 55BA              ; basically sets new end time for current animation
1726+ 55BA              INIT_CURRENT_ANIMATION:
1727+ 55BA CD 7F 4F         CALL GETnthANIMDEF
1728+ 55BD DD 7E 03         LD A,(IX+3) ; current animation item
1729+ 55C0 BE               CP (HL) ; number of animation items in the animation definition
1730+ 55C1 38 0A            JR C,.L3 ; last item not reached
1731+ 55C3                  ; last item reached
1732+ 55C3 DD 7E 05         LD A,(IX+5) ; cyclic flag
1733+ 55C6 B7               OR A
1734+ 55C7 28 2C            JR Z,.ERROR ; non-cyclic animation
1735+ 55C9                  ; cyclic animation, restart
1736+ 55C9 DD 36 03 00      LD (IX+3),0; current item
1737+ 55CD              .L3:
1738+ 55CD                  ; HL = animation definition
1739+ 55CD 23               INC HL ; skip animation definition size field
1740+ 55CE 16 00            LD D,0
1741+ 55D0 DD 5E 03         LD E,(IX+3); current item
1742+ 55D3 19               ADD HL,DE
1743+ 55D4 4E               LD C,(HL) ; current animation item
1744+ 55D5 0C               INC C
1745+ 55D6 3A 61 4F         LD A,(ANIMITEMNUM)
1746+ 55D9 B9               CP C
1747+ 55DA 38 19            JR C,.ERROR ; invalid animation item, stop animation
1748+ 55DC 0D               DEC C
1749+ 55DD 79               LD A,C
1750+ 55DE CD 76 4F         CALL GETnthANIMITEM
1751+ 55E1 E5               PUSH HL
1752+ 55E2 FD E1            POP IY ; IY=animation item
1753+ 55E4 05               DEC B
1754+ 55E5 28 0C            JR Z,.EXIT
1755+ 55E7 FD 5E 01         LD E,(IY+1)
1756+ 55EA FD 56 02         LD D,(IY+2) ; duration
1757+ 55ED DD 73 01         LD (IX+1),E
1758+ 55F0 DD 72 02         LD (IX+2),D
1759+ 55F3              .EXIT:
1760+ 55F3 AF               XOR A
1761+ 55F4 C9               RET
1762+ 55F5              .ERROR:
1763+ 55F5 37               SCF
1764+ 55F6 C9               RET
1765+ 55F7              ; *******************************************************************************************************
1766+ 55F7
1767+ 55F7              ; *******************************************************************************************************
1768+ 55F7              ; function will display currect item and set up expiry time
1769+ 55F7              ; it will also stop the animation if expired
1770+ 55F7              ; sets sprite update flag if any changes in sprite data made
1771+ 55F7              ; input IX=current sprite animation
1772+ 55F7              ; input B=1 skip timer setup
1773+ 55F7              SETUP_ANIM_STEP:
1774+ 55F7 DD 4E 04         LD C,(IX+4) ; animation definition ID
1775+ 55FA 0C               INC C
1776+ 55FB 3A 64 4F         LD A,(ANIMDEFNUM)
1777+ 55FE B9               CP C
1778+ 55FF 30 05            JR NC,.L2
1779+ 5601                  ; given animation item is outside of bounds, deactivate animation
1780+ 5601              .STOPANIM:
1781+ 5601 DD 36 06 00      LD (IX+6),0
1782+ 5605 C9               RET
1783+ 5606              .L2:
1784+ 5606 0D               DEC C
1785+ 5607 79               LD A,C
1786+ 5608 CD BA 55         CALL INIT_CURRENT_ANIMATION
1787+ 560B 38 F4            JR C, .STOPANIM
1788+ 560D FD 7E 00         LD A,(IY) ; type of animation item
1789+ 5610 B7               OR A
1790+ 5611 28 44            JR Z,.L4 ; change pattern and/or color
1791+ 5613              .PAT:
1792+ 5613                  ; change pattern definition
1793+ 5613                  ; check if sprite or character
1794+ 5613 DD 7E 07         LD A,(IX+7)
1795+ 5616 B7               OR A
1796+ 5617 20 58            JR NZ,.CHAR
1797+ 5619 DD 7E 00         LD A,(IX) ; sprite number
1798+ 561C CD 90 4D         CALL GETnthSPRATTR
1799+ 561F 23          > INC HL ; skip y and x
1799+ 5620 23          > INC HL
1799+ 5621 23          > INC HL
1799+ 5622 23          > INC HL
1800+ 5623 7E               LD A,(HL); current pattern
1801+ 5624 26 00            LD H,0
1802+ 5626 6F               LD L,A
1803+ 5627 3A E0 F3         LD A,(REG1SAV)
1804+ 562A E6 02            AND 2
1805+ 562C 20 07            JR NZ,.L6
1806+ 562E                  ; 8x8 sprite
1807+ 562E CD 75 66         CALL HLx8
1808+ 5631 06 08            LD B,8
1809+ 5633 18 05            JR .L5
1810+ 5635              .L6:
1811+ 5635 CD 73 66         CALL HLx32
1812+ 5638 06 20            LD B,32
1813+ 563A              .L5:
1814+ 563A 3A AF FC         LD A,(SCRMOD)
1815+ 563D 3D               DEC A
1816+ 563E 20 06            JR NZ,.L10
1817+ 5640 ED 5B C5 F3      LD DE,(T32PAT)
1818+ 5644 18 04            JR .L7
1819+ 5646              .L10:
1820+ 5646 ED 5B CF F3      LD DE,(GRPPAT)
1821+ 564A              .L7:
1822+ 564A 19               ADD HL,DE
1823+ 564B CD 56 66         CALL SETWRT_LOCAL_WRITE
1824+ 564E FD 6E 03         LD L,(IY+3)
1825+ 5651 FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
1826+ 5654 C3 6B 66         JP BBYTECOPY
1827+ 5657              .L4:
1828+ 5657                  ; change pattern and color in sprite attributes table
1829+ 5657 DD 7E 00         LD A,(IX) ; sprite number
1830+ 565A CD 90 4D         CALL GETnthSPRATTR
1831+ 565D 23          > INC HL ; skip y and x
1831+ 565E 23          > INC HL
1831+ 565F 23          > INC HL
1831+ 5660 23          > INC HL
1832+ 5661 FD 7E 03         LD A,(IY+3) ; new pattern
1833+ 5664 77               LD (HL),A
1834+ 5665 23          > INC HL
1834+ 5666 23          > INC HL
1835+ 5667 FD 7E 04         LD A,(IY+4) ; new color
1836+ 566A 77               LD (HL),A
1837+ 566B 2A 87 4D         LD HL,(SPRATR_UPDATE_FLAG)
1838+ 566E 36 01            LD (HL),1
1839+ 5670 C9               RET
1840+ 5671              .CHAR:
1841+ 5671 DD 6E 00         LD L,(IX)
1842+ 5674 3D               DEC A
1843+ 5675 67               LD H,A
1844+ 5676 CD 75 66         CALL HLx8
1845+ 5679 3A AF FC         LD A,(SCRMOD)
1846+ 567C 3D               DEC A
1847+ 567D 20 06            JR NZ,.L8
1848+ 567F ED 5B C1 F3      LD DE,(T32CGP)
1849+ 5683 18 04            JR .L9
1850+ 5685              .L8:
1851+ 5685 ED 5B CB F3      LD DE,(GRPCGP)
1852+ 5689              .L9:
1853+ 5689 06 08            LD B,8
1854+ 568B 18 BD            JR .L7
1855+ 568D              ; *******************************************************************************************************
1856+ 568D
# file closed: asm\ANIMATION.asm
 139  568D               INCLUDE "SGAM.asm"
# file opened: asm\SGAM.asm
   1+ 568D              ; Sprite Group Animate and Move
   2+ 568D
   3+ 568D              ; *******************************************************************************************************
   4+ 568D              ; shared function to process a list of animations
   5+ 568D              ; input B=list size
   6+ 568D              ; input DE=list pointer
   7+ 568D              SGAM_PROCESS_ANIM_LIST:
   8+ 568D 21 A0 56         LD HL,.STEP
   9+ 5690 22 7B 55         LD (ANIM_SETVALUE.FN+1),HL
  10+ 5693              .L1:
  11+ 5693 C5               PUSH BC
  12+ 5694 1A               LD A,(DE)
  13+ 5695 13          > INC DE
  13+ 5696 13          > INC DE
  14+ 5697 D5               PUSH DE
  15+ 5698 CD 6B 55         CALL ANIM_SETVALUE
  16+ 569B D1               POP DE
  17+ 569C C1               POP BC
  18+ 569D 10 F4            DJNZ .L1
  19+ 569F C9           	RET
  20+ 56A0              .STEP:
  21+ 56A0 06 01            LD B,1
  22+ 56A2 C3 9B 55         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
  23+ 56A5              ; *******************************************************************************************************
  24+ 56A5
  25+ 56A5               IF (1 == 1)
  26+ 56A5              ; *******************************************************************************************************
  27+ 56A5              ; function to handle CALL SGAM basic extension
  28+ 56A5              ; sets position of a group of sprites as described in SPRGRPMOV
  29+ 56A5              ; and manually animate a list of animations
  30+ 56A5              ; _SGAM ( INT x,
  31+ 56A5              ;	      INT y,
  32+ 56A5              ;		  BYTE count,
  33+ 56A5              ;		  INT[2][count] data_ptr,
  34+ 56A5              ;         BYTE item_number,
  35+ 56A5              ;         INT[] sprite_animations )
  36+ 56A5              ; will put ram in page 0 also, page 1 is already there
  37+ 56A5              SGAM:
  38+ 56A5 3A 86 4D     	LD A, (SPRATR_INIT_STATUS)
  39+ 56A8 B7           	OR A
  40+ 56A9 CA B4 67     	JP Z,ILLEGAL_FUNCTION
  41+ 56AC              	; opening (
  42+ 56AC CD 88 67     	CALL CHKCHAR
  43+ 56AF 28           	DB '('
  44+ 56B0              	; get x
  45+ 56B0 DD 21 2F 54  	LD IX, FRMQNT
  46+ 56B4 CD 59 01     	CALL CALBAS
  47+ 56B7 ED 53 51 64  	LD (TMP_STRUCT),DE
  48+ 56BB              	; comma
  49+ 56BB CD 88 67     	CALL CHKCHAR
  50+ 56BE 2C           	DB ','
  51+ 56BF              	; get y
  52+ 56BF DD 21 2F 54  	LD IX, FRMQNT
  53+ 56C3 CD 59 01     	CALL CALBAS
  54+ 56C6 ED 53 53 64  	LD (TMP_STRUCT+2),DE
  55+ 56CA              	; comma
  56+ 56CA CD 88 67     	CALL CHKCHAR
  57+ 56CD 2C           	DB ','
  58+ 56CE              	; get count
  59+ 56CE DD 21 1C 52  	LD IX, GETBYT
  60+ 56D2 CD 59 01     	CALL CALBAS
  61+ 56D5 B7               OR A
  62+ 56D6 CA AC 67         JP Z,SUBSCRIPT_OUT_OF_RANGE
  63+ 56D9 32 55 64     	LD (TMP_STRUCT+4),A
  64+ 56DC              	; comma
  65+ 56DC CD 88 67     	CALL CHKCHAR
  66+ 56DF 2C           	DB ','
  67+ 56E0              	; get sprite group definition array data pointer
  68+ 56E0 3A 55 64         LD A,(TMP_STRUCT+4)
  69+ 56E3 5F           	LD E,A
  70+ 56E4 16 03        	LD D,3
  71+ 56E6 3E 02        	LD A,2
  72+ 56E8 47           	LD B,A
  73+ 56E9 CD ED 67     	CALL GET_BASIC_ARRAY_DATA_POINTER
  74+ 56EC ED 43 56 64  	LD (TMP_STRUCT+5),BC
  75+ 56F0              	; comma
  76+ 56F0 CD 88 67     	CALL CHKCHAR
  77+ 56F3 2C           	DB ','
  78+ 56F4              	; get sprite animation array size
  79+ 56F4 DD 21 1C 52  	LD IX,GETBYT
  80+ 56F8 CD 59 01     	CALL CALBAS
  81+ 56FB 32 58 64         LD (TMP_STRUCT+7),A
  82+ 56FE B7               OR A
  83+ 56FF CA AC 67         JP Z,SUBSCRIPT_OUT_OF_RANGE
  84+ 5702              	; comma
  85+ 5702 CD 88 67     	CALL CHKCHAR
  86+ 5705 2C           	DB ','
  87+ 5706                  ; get array pointer
  88+ 5706 3A 58 64         LD A,(TMP_STRUCT+7)
  89+ 5709 57               LD D,A
  90+ 570A 3E 02            LD A,2
  91+ 570C 06 01            LD B,1
  92+ 570E CD ED 67         CALL GET_BASIC_ARRAY_DATA_POINTER
  93+ 5711 ED 43 59 64      LD (TMP_STRUCT+8),BC
  94+ 5715              	; ending )
  95+ 5715 CD 88 67     	CALL CHKCHAR
  96+ 5718 29           	DB ')'
  97+ 5719              .ENTRY:
  98+ 5719 E5               PUSH HL
  99+ 571A
 100+ 571A              	; enable page 0
 101+ 571A FD 21 21 57  	LD IY, .RET
 102+ 571E C3 39 67     	JP ENABLE_PAGE0
 103+ 5721              .RET:
 104+ 5721 D9               EXX
 105+ 5722 ED 5B 51 64      LD DE,(TMP_STRUCT) ; initial x
 106+ 5726 ED 4B 53 64      LD BC,(TMP_STRUCT+2) ; initial y
 107+ 572A D9               EXX
 108+ 572B 2A 56 64         LD HL,(TMP_STRUCT+5) ; pointer to data
 109+ 572E 3A 55 64         LD A,(TMP_STRUCT+4) ; number of entries
 110+ 5731 47               LD B,A
 111+ 5732 CD E4 4E         CALL SPR_UPDATE_LOC
 112+ 5735
 113+ 5735 3A 58 64         LD A,(TMP_STRUCT+7) ; anim number
 114+ 5738 47               LD B,A
 115+ 5739 ED 5B 59 64      LD DE,(TMP_STRUCT+8) ; anim list
 116+ 573D CD 8D 56     	CALL SGAM_PROCESS_ANIM_LIST
 117+ 5740 D1               POP DE
 118+ 5741 C1               POP BC
 119+ 5742 CD B0 66         CALL RESTORE_PAGE_INFO
 120+ 5745 AF           	XOR A
 121+ 5746 E1           	POP HL
 122+ 5747 C9           	RET
 123+ 5748              ; *******************************************************************************************************
 124+ 5748               ENDIF
 125+ 5748
 126+ 5748               IF (0 == 1)
 127+ 5748 ~            ; *******************************************************************************************************
 128+ 5748 ~            ; same as SGAM but for DEFUSR approach
 129+ 5748 ~            ; input IX=pointer to input array, real data from +2
 130+ 5748 ~            ; +02 = X
 131+ 5748 ~            ; +04 = Y
 132+ 5748 ~            ; +06 = count
 133+ 5748 ~            ; +08 = data pointer
 134+ 5748 ~            ; +10 = anim number
 135+ 5748 ~            ; +12 = sprite animations
 136+ 5748 ~            SGAM_DEFUSR:
 137+ 5748 ~            	; enable page 0
 138+ 5748 ~            	LD IY, .RET
 139+ 5748 ~            	JP ENABLE_PAGE0
 140+ 5748 ~            .RET:
 141+ 5748 ~            	EI
 142+ 5748 ~                EXX
 143+ 5748 ~            	LD E,(IX+2)
 144+ 5748 ~            	LD D,(IX+3) ; initial x
 145+ 5748 ~            	LD C,(IX+4)
 146+ 5748 ~            	LD B,(IX+5) ; initial y
 147+ 5748 ~                EXX
 148+ 5748 ~            	LD L,(IX+8)
 149+ 5748 ~            	LD H,(IX+9) ; pointer to data
 150+ 5748 ~                LD B,(IX+6) ; count
 151+ 5748 ~            	PUSH IX
 152+ 5748 ~                CALL SPR_UPDATE_LOC
 153+ 5748 ~            	POP IX
 154+ 5748 ~                LD B,(IX+10) ; anim number
 155+ 5748 ~            	LD E,(IX+12)
 156+ 5748 ~            	LD D,(IX+13)
 157+ 5748 ~            	CALL SGAM_PROCESS_ANIM_LIST
 158+ 5748 ~            	JP COMMON_EXIT_CODE
 159+ 5748 ~            ; *******************************************************************************************************
 160+ 5748               ENDIF
 161+ 5748
 162+ 5748              ; *******************************************************************************************************
 163+ 5748              ; handles automatic move and animate sprite groups during interrupt
 164+ 5748              PROCESS_AUTOSGAMS:
 165+ 5748 3A 6A 4F     	LD A,(AUTOSGAMNUM)
 166+ 574B B7           	OR A
 167+ 574C C8           	RET Z
 168+ 574D 47           	LD B,A
 169+ 574E DD 2A 6B 4F  	LD IX,(AUTOSGAMPTR)
 170+ 5752              .L1:
 171+ 5752 C5           	PUSH BC
 172+ 5753 DD 7E 13     	LD A,(IX+19) ; active flag
 173+ 5756 B7           	OR A
 174+ 5757 28 28        	JR Z,.LOOPEND
 175+ 5759              	; active, check timer
 176+ 5759 DD 6E 16     	LD L,(IX+22)
 177+ 575C DD 66 17     	LD H,(IX+23) ; timer
 178+ 575F 2B           	DEC HL
 179+ 5760 7C           	LD A,H
 180+ 5761 B5           	OR L
 181+ 5762 28 08        	JR Z,.L2
 182+ 5764              	; not expired
 183+ 5764 DD 75 16     	LD (IX+22),L
 184+ 5767 DD 74 17     	LD (IX+23),H
 185+ 576A 18 15        	JR .LOOPEND
 186+ 576C              .L2:
 187+ 576C              	; expired, process
 188+ 576C
 189+ 576C                  ; set initial timer
 190+ 576C DD 7E 14         LD A,(IX+20)
 191+ 576F DD 77 16         LD (IX+22),A
 192+ 5772 DD 7E 15         LD A,(IX+21)
 193+ 5775 DD 77 17         LD (IX+23),A
 194+ 5778
 195+ 5778 CD 8A 57     	CALL .MOVE
 196+ 577B CD F5 57     	CALL .UPDATELOC
 197+ 577E CD 1A 58     	CALL .PROCESS_ANIM_LIST
 198+ 5781
 199+ 5781              .LOOPEND:
 200+ 5781 11 18 00     	LD DE,24
 201+ 5784 DD 19        	ADD IX,DE
 202+ 5786 C1           	POP BC
 203+ 5787 10 C9        	DJNZ .L1
 204+ 5789 C9           	RET
 205+ 578A
 206+ 578A              .MOVE:
 207+ 578A              	; process movement
 208+ 578A DD 7E 0A     	LD A,(IX+10) ; direction
 209+ 578D B7           	OR A
 210+ 578E 28 08        	JR Z, .MOVE_L1
 211+ 5790              	; vertical
 212+ 5790 DD 6E 02     	LD L,(IX+2)
 213+ 5793 DD 66 03     	LD H,(IX+3) ; vertical variable pointer
 214+ 5796 18 06        	JR .MOVE_L2
 215+ 5798              .MOVE_L1:
 216+ 5798              	; horizontal
 217+ 5798 DD 6E 00     	LD L,(IX+0)
 218+ 579B DD 66 01     	LD H,(IX+1) ; horizontal variable pointer
 219+ 579E              .MOVE_L2:
 220+ 579E E5           	PUSH HL
 221+ 579F FD E1        	POP IY
 222+ 57A1 FD 6E 00     	LD L,(IY+0)
 223+ 57A4 FD 66 01     	LD H,(IY+1)
 224+ 57A7 DD 5E 08     	LD E,(IX+8)
 225+ 57AA DD 56 09     	LD D,(IX+9) ; delta value
 226+ 57AD 19           	ADD HL,DE
 227+ 57AE E5           	PUSH HL
 228+ 57AF DD 5E 04     	LD E,(IX+4)
 229+ 57B2 DD 56 05     	LD D,(IX+5) ; minimum value
 230+ 57B5 A7           	AND A
 231+ 57B6 ED 52        	SBC HL,DE
 232+ 57B8 FA D2 57     	JP M,.MOVE_L3 ; below minimum
 233+ 57BB E1           	POP HL
 234+ 57BC E5           	PUSH HL
 235+ 57BD DD 5E 06     	LD E,(IX+6)
 236+ 57C0 DD 56 07     	LD D,(IX+7) ; maximum value
 237+ 57C3 EB           	EX DE,HL
 238+ 57C4 A7           	AND A
 239+ 57C5 ED 52        	SBC HL,DE
 240+ 57C7 FA DA 57     	JP M,.MOVE_L4 ; above maximum
 241+ 57CA E1           	POP HL
 242+ 57CB              	; within bounds
 243+ 57CB              .MOVE_L5:
 244+ 57CB FD 75 00     	LD (IY+0),L
 245+ 57CE FD 74 01     	LD (IY+1),H
 246+ 57D1 C9           	RET
 247+ 57D2              .MOVE_L3:
 248+ 57D2 E1           	POP HL
 249+ 57D3 CD E6 57     	CALL .INVERSE_DELTA
 250+ 57D6 6B           	LD L,E
 251+ 57D7 62           	LD H,D
 252+ 57D8 18 F1        	JR .MOVE_L5
 253+ 57DA              .MOVE_L4:
 254+ 57DA E1           	POP HL
 255+ 57DB CD E6 57     	CALL .INVERSE_DELTA
 256+ 57DE DD 6E 06     	LD L,(IX+6)
 257+ 57E1 DD 66 07     	LD H,(IX+7) ; maximum
 258+ 57E4 18 E5        	JR .MOVE_L5
 259+ 57E6              .INVERSE_DELTA:
 260+ 57E6 AF           	XOR A
 261+ 57E7 DD 96 08     	SUB (IX+8)
 262+ 57EA DD 77 08     	LD (IX+8),A
 263+ 57ED 9F           	SBC A,A
 264+ 57EE DD 96 09     	SUB (IX+9)
 265+ 57F1 DD 77 09     	LD (IX+9),A
 266+ 57F4 C9           	RET
 267+ 57F5
 268+ 57F5              .UPDATELOC:
 269+ 57F5 DD E5        	PUSH IX
 270+ 57F7 D9           	EXX
 271+ 57F8 DD 6E 00     	LD L,(IX+0)
 272+ 57FB DD 66 01     	LD H,(IX+1)
 273+ 57FE 5E           	LD E,(HL)
 274+ 57FF 23           	INC HL
 275+ 5800 56           	LD D,(HL)
 276+ 5801 DD 6E 02     	LD L,(IX+2)
 277+ 5804 DD 66 03     	LD H,(IX+3)
 278+ 5807 4E           	LD C,(HL)
 279+ 5808 23           	INC HL
 280+ 5809 46           	LD B,(HL)
 281+ 580A D9           	EXX
 282+ 580B DD 6E 0C     	LD L,(IX+12)
 283+ 580E DD 66 0D     	LD H,(IX+13) ; pointer to sprite group data
 284+ 5811 DD 46 0B     	LD B,(IX+11) ; sprite group size
 285+ 5814 CD E4 4E     	CALL SPR_UPDATE_LOC
 286+ 5817 DD E1        	POP IX
 287+ 5819 C9           	RET
 288+ 581A
 289+ 581A              .PROCESS_ANIM_LIST:
 290+ 581A DD E5        	PUSH IX
 291+ 581C DD 46 0E         LD B,(IX+14) ; anim list size
 292+ 581F DD CB 09 7E  	BIT 7,(IX+9)
 293+ 5823 28 08        	JR Z,.PROCESS_ANIM_LIST_L1
 294+ 5825              	; negative direction
 295+ 5825 DD 5E 0F     	LD E,(IX+15)
 296+ 5828 DD 56 10     	LD D,(IX+16)
 297+ 582B 18 06        	JR .PROCESS_ANIM_LIST_L2
 298+ 582D              .PROCESS_ANIM_LIST_L1:
 299+ 582D              	; positive direction
 300+ 582D DD 5E 11     	LD E,(IX+17)
 301+ 5830 DD 56 12     	LD D,(IX+18)
 302+ 5833              .PROCESS_ANIM_LIST_L2:
 303+ 5833 CD 8D 56     	CALL SGAM_PROCESS_ANIM_LIST
 304+ 5836 DD E1        	POP IX
 305+ 5838 C9           	RET
 306+ 5839              ; *******************************************************************************************************
 307+ 5839
# file closed: asm\SGAM.asm
 140  5839               ENDIF
 141  5839
 142  5839               IF (RAM_CMDS == 1)
 143  5839               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
   1+ 5839               IF (1 == 1)
   2+ 5839              ; *******************************************************************************************************
   3+ 5839              ; function to handle CALL MEMCPY basic extension
   4+ 5839              ; _MEMCPY ( INT source,
   5+ 5839              ;			INT destination,
   6+ 5839              ;			INT count,
   7+ 5839              ; will put ram in page 0 also, page 1 is already there
   8+ 5839              MEMCPY:
   9+ 5839              	; opening (
  10+ 5839 CD 88 67     	CALL CHKCHAR
  11+ 583C 28           	DB '('
  12+ 583D              	; get source address
  13+ 583D DD 21 2F 54  	LD IX, FRMQNT
  14+ 5841 CD 59 01     	CALL CALBAS
  15+ 5844 D5           	PUSH DE
  16+ 5845              	; comma
  17+ 5845 CD 88 67     	CALL CHKCHAR
  18+ 5848 2C           	DB ','
  19+ 5849              	; get destination address
  20+ 5849 DD 21 2F 54  	LD IX, FRMQNT
  21+ 584D CD 59 01     	CALL CALBAS
  22+ 5850 D5           	PUSH DE
  23+ 5851              	; comma
  24+ 5851 CD 88 67     	CALL CHKCHAR
  25+ 5854 2C           	DB ','
  26+ 5855              	; get length
  27+ 5855 DD 21 2F 54  	LD IX, FRMQNT
  28+ 5859 CD 59 01     	CALL CALBAS
  29+ 585C D5           	PUSH DE
  30+ 585D              	; ending )
  31+ 585D CD 88 67     	CALL CHKCHAR
  32+ 5860 29           	DB ')'
  33+ 5861
  34+ 5861              	; save position
  35+ 5861 E5           	PUSH HL
  36+ 5862 DD E1        	POP IX
  37+ 5864
  38+ 5864 C1           	POP BC ; count
  39+ 5865 D1           	POP DE ; destination
  40+ 5866 E1           	POP HL ; source
  41+ 5867 D9           	EXX
  42+ 5868              	; enable page 0
  43+ 5868 FD 21 6F 58  	LD IY, .RET
  44+ 586C C3 39 67     	JP ENABLE_PAGE0
  45+ 586F              .RET:
  46+ 586F FB           	EI
  47+ 5870 D9           	EXX
  48+ 5871 ED B0        	LDIR
  49+ 5873 C3 4C 66     	JP COMMON_EXIT_CODE_IX
  50+ 5876              ; *******************************************************************************************************
  51+ 5876               ENDIF
  52+ 5876
  53+ 5876               IF (0 == 1)
  54+ 5876 ~            ; *******************************************************************************************************
  55+ 5876 ~            ; same as MEMCPY but for DEFUSR approach
  56+ 5876 ~            ; input IX=pointer to input array, real data from +2
  57+ 5876 ~            ; +2 = source address
  58+ 5876 ~            ; +4 = destination address
  59+ 5876 ~            ; +6 = lenght
  60+ 5876 ~            MEMCPY_DEFUSR:
  61+ 5876 ~            	; enable page 0
  62+ 5876 ~            	LD IY, .RET
  63+ 5876 ~            	JP ENABLE_PAGE0
  64+ 5876 ~            .RET:
  65+ 5876 ~            	EI
  66+ 5876 ~            	LD L,(IX+2)
  67+ 5876 ~            	LD H,(IX+3)
  68+ 5876 ~            	LD E,(IX+4)
  69+ 5876 ~            	LD D,(IX+5)
  70+ 5876 ~            	LD C,(IX+6)
  71+ 5876 ~            	LD B,(IX+7)
  72+ 5876 ~            	LDIR
  73+ 5876 ~                JP COMMON_EXIT_CODE
  74+ 5876 ~            ; *******************************************************************************************************
  75+ 5876               ENDIF
  76+ 5876
  77+ 5876               IF (1 == 1)
  78+ 5876              ; *******************************************************************************************************
  79+ 5876              ; function to handle CALL FILRAM basic extension
  80+ 5876              ; FILRAM ( INT start address,
  81+ 5876              ;		   INT count,
  82+ 5876              ;		   BYTE value )
  83+ 5876              ; will put ram in page 0 also, page 1 is already there
  84+ 5876              FILRAM:
  85+ 5876              	; opening (
  86+ 5876 CD 88 67     	CALL CHKCHAR
  87+ 5879 28           	DB '('
  88+ 587A              	; get start address
  89+ 587A DD 21 2F 54  	LD IX, FRMQNT
  90+ 587E CD 59 01     	CALL CALBAS
  91+ 5881 D5           	PUSH DE
  92+ 5882              	; comma
  93+ 5882 CD 88 67     	CALL CHKCHAR
  94+ 5885 2C           	DB ','
  95+ 5886              	; get count
  96+ 5886 DD 21 2F 54  	LD IX, FRMQNT
  97+ 588A CD 59 01     	CALL CALBAS
  98+ 588D D5           	PUSH DE
  99+ 588E              	; comma
 100+ 588E CD 88 67     	CALL CHKCHAR
 101+ 5891 2C           	DB ','
 102+ 5892              	; get value
 103+ 5892 DD 21 1C 52  	LD IX, GETBYT
 104+ 5896 CD 59 01     	CALL CALBAS
 105+ 5899 F5           	PUSH AF
 106+ 589A              	; ending )
 107+ 589A CD 88 67     	CALL CHKCHAR
 108+ 589D 29           	DB ')'
 109+ 589E
 110+ 589E              	; save position
 111+ 589E E5           	PUSH HL
 112+ 589F DD E1        	POP IX
 113+ 58A1
 114+ 58A1 D1           	POP DE ; actually AF
 115+ 58A2 C1           	POP BC ; count
 116+ 58A3 E1           	POP HL ; start address
 117+ 58A4 D9           	EXX
 118+ 58A5              	; enable page 0
 119+ 58A5 FD 21 AC 58  	LD IY, .RET
 120+ 58A9 C3 39 67     	JP ENABLE_PAGE0
 121+ 58AC              .RET:
 122+ 58AC FB           	EI
 123+ 58AD D9           	EXX
 124+ 58AE CD B4 58     	CALL FILVRM_FILLVALUE
 125+ 58B1 C3 4C 66     	JP COMMON_EXIT_CODE_IX
 126+ 58B4              ; *******************************************************************************************************
 127+ 58B4               ENDIF
 128+ 58B4
 129+ 58B4               IF (0 == 1)
 130+ 58B4 ~            ; *******************************************************************************************************
 131+ 58B4 ~            ; same as FILVRM but for DEFUSR approach
 132+ 58B4 ~            ; input IX=pointer to input array, real data from +2
 133+ 58B4 ~            ; +2 = start address
 134+ 58B4 ~            ; +4 = count
 135+ 58B4 ~            ; +6 = value
 136+ 58B4 ~            FILRAM_DEFUSR:
 137+ 58B4 ~            	; enable page 0
 138+ 58B4 ~            	LD IY, .RET
 139+ 58B4 ~            	JP ENABLE_PAGE0
 140+ 58B4 ~            .RET:
 141+ 58B4 ~            	EI
 142+ 58B4 ~            	LD L,(IX+2)
 143+ 58B4 ~            	LD H,(IX+3)
 144+ 58B4 ~            	LD C,(IX+4)
 145+ 58B4 ~            	LD B,(IX+5)
 146+ 58B4 ~            	LD D,(IX+6)
 147+ 58B4 ~            	CALL FILVRM_FILLVALUE
 148+ 58B4 ~                JP COMMON_EXIT_CODE
 149+ 58B4 ~            ; *******************************************************************************************************
 150+ 58B4               ENDIF
 151+ 58B4
 152+ 58B4              ; *******************************************************************************************************
 153+ 58B4              ; common function to fill RAM
 154+ 58B4              FILVRM_FILLVALUE:
 155+ 58B4 78           	LD A,B
 156+ 58B5 B1           	OR C
 157+ 58B6 C8           	RET Z ; zero size
 158+ 58B7 72               LD (HL), D
 159+ 58B8 54               LD D, H
 160+ 58B9 5D               LD E, L
 161+ 58BA 13               INC DE
 162+ 58BB 0B               DEC BC
 163+ 58BC 78           	LD A,B
 164+ 58BD B1           	OR C
 165+ 58BE C8           	RET Z ; if count was 1
 166+ 58BF ED B0            LDIR
 167+ 58C1 C9               RET
 168+ 58C2              ; *******************************************************************************************************
# file closed: asm\MEMORY.asm
 144  58C2               ENDIF
 145  58C2
 146  58C2               IF (SOUND_CMDS == 1)
 147  58C2               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
   1+ 58C2              MUSIC_INIT_STATUS:
   2+ 58C2 00            DB 0
   3+ 58C3              SFX_INIT_STATUS:
   4+ 58C3 00            DB 0
   5+ 58C4              SOUND_ENABLED:
   6+ 58C4 00            DB 0
   7+ 58C5
   8+ 58C5               IF (1 == 1)
   9+ 58C5              ; *******************************************************************************************************
  10+ 58C5              ; function to handle CALL SNDPLYINIT basic extension
  11+ 58C5              ; initializes sound player
  12+ 58C5              ; _SNDPLYINIT ( INT music_offset,
  13+ 58C5              ;				INT sfx_offset, can be -1 if no SFX
  14+ 58C5              ; will put ram in page 0 also, page 1 is already there
  15+ 58C5              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
  16+ 58C5              SNDPLYINIT:
  17+ 58C5              	; opening (
  18+ 58C5 CD 88 67     	CALL CHKCHAR
  19+ 58C8 28           	DB '('
  20+ 58C9              	; get music address
  21+ 58C9 DD 21 2F 54  	LD IX, FRMQNT
  22+ 58CD CD 59 01     	CALL CALBAS
  23+ 58D0 D5           	PUSH DE
  24+ 58D1              	; comma
  25+ 58D1 CD 88 67     	CALL CHKCHAR
  26+ 58D4 2C           	DB ','
  27+ 58D5              	; get sfx address
  28+ 58D5 DD 21 2F 54  	LD IX, FRMQNT
  29+ 58D9 CD 59 01     	CALL CALBAS
  30+ 58DC D5           	PUSH DE
  31+ 58DD              	; ending )
  32+ 58DD CD 88 67     	CALL CHKCHAR
  33+ 58E0 29           	DB ')'
  34+ 58E1
  35+ 58E1                  ; save position in BASIC text
  36+ 58E1 44           	LD B, H
  37+ 58E2 4D           	LD C, L
  38+ 58E3
  39+ 58E3              	; pop LDIR parameters and store away for later
  40+ 58E3 D1           	POP DE ; sfx address
  41+ 58E4 E1           	POP HL ; music address
  42+ 58E5 C5           	PUSH BC ; basic text location
  43+ 58E6 D9           	EXX
  44+ 58E7 FD 21 EE 58  	LD IY, .RET
  45+ 58EB C3 39 67     	JP ENABLE_PAGE0
  46+ 58EE              .RET:
  47+ 58EE D9           	EXX
  48+ 58EF
  49+ 58EF D5           	PUSH DE
  50+ 58F0 AF           	XOR A
  51+ 58F1              	; HL = music location
  52+ 58F1 CD 65 41     	CALL PLY_AKG_INIT
  53+ 58F4 3E 01        	LD A, 1
  54+ 58F6 32 C2 58     	LD (MUSIC_INIT_STATUS), A
  55+ 58F9
  56+ 58F9 E1           	POP HL ; SFX
  57+ 58FA              	; check if SFX address -1
  58+ 58FA 23           	INC HL
  59+ 58FB 7D           	LD A, L
  60+ 58FC B4           	OR H
  61+ 58FD 28 09        	JR Z,.L1
  62+ 58FF 2B           	DEC HL
  63+ 5900 CD 20 40     	CALL PLY_AKG_INITSOUNDEFFECTS
  64+ 5903 3E 01        	LD A, 1
  65+ 5905 32 C3 58     	LD (SFX_INIT_STATUS), A
  66+ 5908              .L1:
  67+ 5908 D1               POP DE
  68+ 5909 C1               POP BC
  69+ 590A CD B0 66         CALL RESTORE_PAGE_INFO
  70+ 590D AF           	XOR A
  71+ 590E E1           	POP HL
  72+ 590F C9           	RET
  73+ 5910              ; *******************************************************************************************************
  74+ 5910               ENDIF
  75+ 5910
  76+ 5910               IF (0 == 1)
  77+ 5910 ~            ; *******************************************************************************************************
  78+ 5910 ~            ; same as SNDPLYINI but for DEFUSR approach
  79+ 5910 ~            ; input IX=pointer to input array, real data from +2
  80+ 5910 ~            ; +2 = music address
  81+ 5910 ~            ; +4 = sfx address
  82+ 5910 ~            SNDPLYINI_DEFUSR:
  83+ 5910 ~            	LD IY, .RET
  84+ 5910 ~            	JP ENABLE_PAGE0
  85+ 5910 ~            .RET:
  86+ 5910 ~            	XOR A
  87+ 5910 ~            	LD L,(IX+2)
  88+ 5910 ~            	LD H,(IX+3)
  89+ 5910 ~            	PUSH IX
  90+ 5910 ~            	CALL PLY_AKG_INIT
  91+ 5910 ~            	POP IX
  92+ 5910 ~            	LD A, 1
  93+ 5910 ~            	LD (MUSIC_INIT_STATUS), A
  94+ 5910 ~
  95+ 5910 ~            	LD L,(IX+4)
  96+ 5910 ~            	LD H,(IX+5)
  97+ 5910 ~            	; check if SFX address -1
  98+ 5910 ~            	INC HL
  99+ 5910 ~            	LD A, L
 100+ 5910 ~            	OR H
 101+ 5910 ~            	JR Z,.L1
 102+ 5910 ~            	DEC HL
 103+ 5910 ~            	CALL PLY_AKG_INITSOUNDEFFECTS
 104+ 5910 ~            	LD A, 1
 105+ 5910 ~            	LD (SFX_INIT_STATUS), A
 106+ 5910 ~            .L1:
 107+ 5910 ~            	JP COMMON_EXIT_CODE
 108+ 5910 ~            ; *******************************************************************************************************
 109+ 5910               ENDIF
 110+ 5910
 111+ 5910              ; *******************************************************************************************************
 112+ 5910              ; function to handle CALL SNDPLYON basic extension
 113+ 5910              ; enables sound player
 114+ 5910              ; _SNDPLYON
 115+ 5910              ; sets SOUND_ENABLED variable to 1 if init call was done
 116+ 5910              ; if not throws out of data error
 117+ 5910              SNDPLYON_DEFUSR:
 118+ 5910              SNDPLYON:
 119+ 5910 3A C2 58     	LD A, (MUSIC_INIT_STATUS)
 120+ 5913 B7           	OR A
 121+ 5914               IF (1 == 1)
 122+ 5914 CA A4 67     	JP Z, OUT_OF_DATA ; player not initialized, throw error
 123+ 5917               ENDIF
 124+ 5917               IF (0 == 1)
 125+ 5917 ~            	JR Z,.ERR
 126+ 5917               ENDIF
 127+ 5917              .L1:
 128+ 5917 32 C4 58     	LD (SOUND_ENABLED), A
 129+ 591A              	; disable key click
 130+ 591A AF           	XOR A
 131+ 591B 32 DB F3     	LD (CLIKSW), A
 132+ 591E C9           	RET
 133+ 591F              .ERR:
 134+ 591F 3E 01        	LD A,1
 135+ 5921 C9           	RET
 136+ 5922              ; *******************************************************************************************************
 137+ 5922
 138+ 5922              ; *******************************************************************************************************
 139+ 5922              ; function to handle CALL SNDPLYOFF basic extension
 140+ 5922              ; disables sound player
 141+ 5922              ; _SNDPLYOFF
 142+ 5922              ; sets SOUND_ENABLED variable to 0
 143+ 5922              ; calls AKG to stop music and SFX on all channels if initialized
 144+ 5922              SNDPLYOFF_DEFUSR:
 145+ 5922              SNDPLYOFF:
 146+ 5922 3A C4 58     	LD A, (SOUND_ENABLED)
 147+ 5925 B7           	OR A
 148+ 5926 C8           	RET Z ; already stopped
 149+ 5927 AF           	XOR A
 150+ 5928 32 C4 58     	LD (SOUND_ENABLED), A
 151+ 592B E5           	PUSH HL
 152+ 592C CD 24 42     	CALL PLY_AKG_STOP
 153+ 592F 3A C3 58     	LD A, (SFX_INIT_STATUS)
 154+ 5932 B7           	OR A
 155+ 5933 28 0E        	JR Z, .EXIT ; SFX not in use
 156+ 5935 AF           	XOR A
 157+ 5936 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 158+ 5939 3E 01        	LD A, 1
 159+ 593B CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 160+ 593E 3E 02        	LD A, 2
 161+ 5940 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 162+ 5943              .EXIT:
 163+ 5943 E1           	POP HL
 164+ 5944 AF           	XOR A ; success
 165+ 5945 C9           	RET
 166+ 5946              ; *******************************************************************************************************
 167+ 5946
 168+ 5946               IF (1 == 1)
 169+ 5946              ; *******************************************************************************************************
 170+ 5946              ; function to handle CALL SNDSFX basic extension
 171+ 5946              ; plays a sound effect
 172+ 5946              ; _SNDSFX ( BYTE sfx_number, >0
 173+ 5946              ;			BYTE channel, = 0,1 or 2
 174+ 5946              ;			BYTE inverted_volume = 0-16, 0 being full volume
 175+ 5946              ; will put ram in page 0 also, page 1 is already there
 176+ 5946              ; if sound off throws illegal function call
 177+ 5946              ; if sfx not initialized, throws out of data
 178+ 5946              SNDSFX:
 179+ 5946              	; opening (
 180+ 5946 CD 88 67     	CALL CHKCHAR
 181+ 5949 28           	DB '('
 182+ 594A              	; get sfx_number
 183+ 594A DD 21 1C 52  	LD IX, GETBYT
 184+ 594E CD 59 01     	CALL CALBAS
 185+ 5951 D5           	PUSH DE
 186+ 5952              	; comma
 187+ 5952 CD 88 67     	CALL CHKCHAR
 188+ 5955 2C           	DB ','
 189+ 5956              	; get sfx address
 190+ 5956 DD 21 1C 52  	LD IX, GETBYT
 191+ 595A CD 59 01     	CALL CALBAS
 192+ 595D D5           	PUSH DE
 193+ 595E              	; comma
 194+ 595E CD 88 67     	CALL CHKCHAR
 195+ 5961 2C           	DB ','
 196+ 5962              	; get inverted volume
 197+ 5962 DD 21 1C 52  	LD IX, GETBYT
 198+ 5966 CD 59 01     	CALL CALBAS
 199+ 5969 D5           	PUSH DE
 200+ 596A              	; ending )
 201+ 596A CD 88 67     	CALL CHKCHAR
 202+ 596D 29           	DB ')'
 203+ 596E
 204+ 596E 3A C4 58     	LD A, (SOUND_ENABLED)
 205+ 5971 B7           	OR A
 206+ 5972 20 05        	JR NZ, .L1
 207+ 5974              	; sound disabled, throw illegal function call
 208+ 5974 1E 05        	LD E, 5
 209+ 5976 C3 BA 67     	JP THROW_ERROR
 210+ 5979              .L1:
 211+ 5979 3A C3 58     	LD A, (SFX_INIT_STATUS)
 212+ 597C B7           	OR A
 213+ 597D 20 05        	JR NZ, .L2
 214+ 597F              	; sfx data not initialized, throw out of data
 215+ 597F 1E 04        	LD E, 4
 216+ 5981 C3 BA 67     	JP THROW_ERROR
 217+ 5984              .L2:
 218+ 5984              	; pop  parameters and store away for later
 219+ 5984 D1           	POP DE ; inverted volume
 220+ 5985 43           	LD B, E
 221+ 5986 D1           	POP DE ; channel
 222+ 5987 4B           	LD C, E
 223+ 5988 D1           	POP DE
 224+ 5989 7B           	LD A, E
 225+ 598A 08           	EX AF, AF'
 226+ 598B E5           	PUSH HL ; basic text location
 227+ 598C D9           	EXX
 228+ 598D FD 21 94 59  	LD IY, .RET
 229+ 5991 C3 39 67     	JP ENABLE_PAGE0
 230+ 5994              .RET:
 231+ 5994 D9           	EXX
 232+ 5995 08           	EX AF, AF'
 233+ 5996 CD 24 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
 234+ 5999
 235+ 5999 D1               POP DE
 236+ 599A C1               POP BC
 237+ 599B CD B0 66         CALL RESTORE_PAGE_INFO
 238+ 599E AF           	XOR A
 239+ 599F E1           	POP HL
 240+ 59A0 C9           	RET
 241+ 59A1              ; *******************************************************************************************************
 242+ 59A1               ENDIF
 243+ 59A1
 244+ 59A1               IF (0 == 1)
 245+ 59A1 ~            ; *******************************************************************************************************
 246+ 59A1 ~            ; same as SNDSFX but for DEFUSR approach
 247+ 59A1 ~            ; input IX=pointer to input array, real data from +2
 248+ 59A1 ~            ; +2 = SFX number
 249+ 59A1 ~            ; +4 = channel
 250+ 59A1 ~            ; +6 = volume
 251+ 59A1 ~            SNDSFX_DEFUSR:
 252+ 59A1 ~            	LD A, (SOUND_ENABLED)
 253+ 59A1 ~            	OR A
 254+ 59A1 ~            	RET Z ; sound disabled, just exit
 255+ 59A1 ~            	LD A, (SFX_INIT_STATUS)
 256+ 59A1 ~            	OR A
 257+ 59A1 ~            	RET Z ; sfx data not initialized, just exit
 258+ 59A1 ~            	LD IY, .RET
 259+ 59A1 ~            	JP ENABLE_PAGE0
 260+ 59A1 ~            .RET:
 261+ 59A1 ~            	EI
 262+ 59A1 ~            	LD A,(IX+2) ; SFX number
 263+ 59A1 ~            	LD C,(IX+4) ; channel
 264+ 59A1 ~            	LD B,(IX+6) ; volume
 265+ 59A1 ~            	CALL PLY_AKG_PLAYSOUNDEFFECT
 266+ 59A1 ~            	JP COMMON_EXIT_CODE
 267+ 59A1 ~            ; *******************************************************************************************************
 268+ 59A1               ENDIF
# file closed: asm\SOUND.asm
 148  59A1               ENDIF
 149  59A1
 150  59A1               IF (VRAM_CMDS == 1)
 151  59A1               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
   1+ 59A1               IF (1 == 1)
   2+ 59A1              ; *******************************************************************************************************
   3+ 59A1              ; function to handle CALL FILVRM basic extension
   4+ 59A1              ; FILVRM ( INT offset,
   5+ 59A1              ;		   INT count,
   6+ 59A1              ;		   BYTE value,
   7+ 59A1              ;		   BYTE wait_vsync) >0 = true
   8+ 59A1              ; wait_vsync will issue HALT before copying
   9+ 59A1              FILVRM:
  10+ 59A1              	; opening (
  11+ 59A1 CD 88 67     	CALL CHKCHAR
  12+ 59A4 28           	DB '('
  13+ 59A5              	; get offset address
  14+ 59A5 DD 21 2F 54  	LD IX, FRMQNT
  15+ 59A9 CD 59 01     	CALL CALBAS
  16+ 59AC D5           	PUSH DE
  17+ 59AD              	; comma
  18+ 59AD CD 88 67     	CALL CHKCHAR
  19+ 59B0 2C           	DB ','
  20+ 59B1              	; get count
  21+ 59B1 DD 21 2F 54  	LD IX, FRMQNT
  22+ 59B5 CD 59 01     	CALL CALBAS
  23+ 59B8 D5           	PUSH DE
  24+ 59B9              	; comma
  25+ 59B9 CD 88 67     	CALL CHKCHAR
  26+ 59BC 2C           	DB ','
  27+ 59BD              	; get value
  28+ 59BD DD 21 1C 52  	LD IX, GETBYT
  29+ 59C1 CD 59 01     	CALL CALBAS
  30+ 59C4 F5           	PUSH AF
  31+ 59C5              	; comma
  32+ 59C5 CD 88 67     	CALL CHKCHAR
  33+ 59C8 2C           	DB ','
  34+ 59C9              	; get vsync wait
  35+ 59C9 DD 21 1C 52  	LD IX, GETBYT
  36+ 59CD CD 59 01     	CALL CALBAS
  37+ 59D0 F5           	PUSH AF
  38+ 59D1              	; ending )
  39+ 59D1 CD 88 67     	CALL CHKCHAR
  40+ 59D4 29           	DB ')'
  41+ 59D5
  42+ 59D5              	; save position
  43+ 59D5 E5           	PUSH HL
  44+ 59D6 DD E1        	POP IX
  45+ 59D8
  46+ 59D8              	; syntax ok
  47+ 59D8              	; wait for vsync if needed
  48+ 59D8 F1           	POP AF
  49+ 59D9 B7           	OR A
  50+ 59DA 28 01        	JR Z, .L1
  51+ 59DC 76           	HALT
  52+ 59DD
  53+ 59DD              .L1:
  54+ 59DD 3E 01        	LD A,1
  55+ 59DF 32 62 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
  56+ 59E2 F1               POP AF ; value
  57+ 59E3 C1               POP BC ; count
  58+ 59E4 E1               POP HL ; offset
  59+ 59E5 CD 56 00         CALL BIOS_FILVRM
  60+ 59E8 AF           	XOR A
  61+ 59E9 32 62 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
  62+ 59EC
  63+ 59EC              .L3:
  64+ 59EC DD E5        	PUSH IX
  65+ 59EE E1           	POP HL
  66+ 59EF C9           	RET
  67+ 59F0              ; *******************************************************************************************************
  68+ 59F0               ENDIF
  69+ 59F0
  70+ 59F0               IF (0 == 1)
  71+ 59F0 ~            ; *******************************************************************************************************
  72+ 59F0 ~            ; same as FILVRM but for DEFUSR approach
  73+ 59F0 ~            ; input IX=pointer to input array, real data from +2
  74+ 59F0 ~            ; +2 = offset
  75+ 59F0 ~            ; +4 = count
  76+ 59F0 ~            ; +6 = value
  77+ 59F0 ~            ; +8 = halt flag
  78+ 59F0 ~            FILVRM_DEFUSR:
  79+ 59F0 ~            	LD A,(IX+8)
  80+ 59F0 ~            	OR A
  81+ 59F0 ~            	JR Z,.L0
  82+ 59F0 ~            	HALT
  83+ 59F0 ~            .L0:
  84+ 59F0 ~            	LD A,1
  85+ 59F0 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  86+ 59F0 ~            	LD L,(IX+2)
  87+ 59F0 ~            	LD H,(IX+3)
  88+ 59F0 ~            	LD C,(IX+4)
  89+ 59F0 ~            	LD B,(IX+5)
  90+ 59F0 ~            	LD A,(IX+6)
  91+ 59F0 ~            	CALL BIOS_FILVRM
  92+ 59F0 ~            	XOR A
  93+ 59F0 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  94+ 59F0 ~            	RET
  95+ 59F0 ~            ; *******************************************************************************************************
  96+ 59F0               ENDIF
  97+ 59F0
  98+ 59F0               IF (1 == 1)
  99+ 59F0              ; *******************************************************************************************************
 100+ 59F0              ; function to handle CALL MEMVRM basic extension
 101+ 59F0              ; copies from RAM to VRAM
 102+ 59F0              ; if flag != 0 it will issue HALT before copying
 103+ 59F0              ; if bit 1 of flag set and sprite system initialized it will set sprite update flag
 104+ 59F0              ; _MEMVRM ( INT source,
 105+ 59F0              ;			INT destination,
 106+ 59F0              ;			INT count,
 107+ 59F0              ;			BYTE flag)
 108+ 59F0              ; will put ram in page 0 also, page 1 is already there
 109+ 59F0              MEMVRM:
 110+ 59F0              	; opening (
 111+ 59F0 CD 88 67     	CALL CHKCHAR
 112+ 59F3 28           	DB '('
 113+ 59F4              	; get source address
 114+ 59F4 DD 21 2F 54  	LD IX, FRMQNT
 115+ 59F8 CD 59 01     	CALL CALBAS
 116+ 59FB D5           	PUSH DE
 117+ 59FC              	; comma
 118+ 59FC CD 88 67     	CALL CHKCHAR
 119+ 59FF 2C           	DB ','
 120+ 5A00              	; get destination address
 121+ 5A00 DD 21 2F 54  	LD IX, FRMQNT
 122+ 5A04 CD 59 01     	CALL CALBAS
 123+ 5A07 D5           	PUSH DE
 124+ 5A08              	; comma
 125+ 5A08 CD 88 67     	CALL CHKCHAR
 126+ 5A0B 2C           	DB ','
 127+ 5A0C              	; get length
 128+ 5A0C DD 21 2F 54  	LD IX, FRMQNT
 129+ 5A10 CD 59 01     	CALL CALBAS
 130+ 5A13 D5           	PUSH DE
 131+ 5A14              	; comma
 132+ 5A14 CD 88 67     	CALL CHKCHAR
 133+ 5A17 2C           	DB ','
 134+ 5A18              	; get vsync wait
 135+ 5A18 DD 21 1C 52  	LD IX, GETBYT
 136+ 5A1C CD 59 01     	CALL CALBAS
 137+ 5A1F F5           	PUSH AF
 138+ 5A20              	; ending )
 139+ 5A20 CD 88 67     	CALL CHKCHAR
 140+ 5A23 29           	DB ')'
 141+ 5A24
 142+ 5A24                  ; save position in BASIC text
 143+ 5A24 E5           	PUSH HL
 144+ 5A25 DD E1        	POP IX
 145+ 5A27
 146+ 5A27 F1           	POP AF ; wait vsync
 147+ 5A28 B7           	OR A
 148+ 5A29 28 0F        	JR Z, .L1
 149+ 5A2B              	; check for special case to set sprite update flag
 150+ 5A2B              	IF (SPRITE_CMDS == 1)
 151+ 5A2B E6 02        		AND 2
 152+ 5A2D 28 0A        		JR Z,.L2
 153+ 5A2F 3A 86 4D     		LD A, (SPRATR_INIT_STATUS)
 154+ 5A32 B7           		OR A
 155+ 5A33 28 04        		JR Z,.L2
 156+ 5A35 2A 87 4D     		LD HL,(SPRATR_UPDATE_FLAG)
 157+ 5A38 77           		LD (HL),A
 158+ 5A39              	ENDIF
 159+ 5A39              .L2:
 160+ 5A39 76           	HALT
 161+ 5A3A              .L1:
 162+ 5A3A              	; pop LDIR parameters and store away for later
 163+ 5A3A C1           	POP BC ; count
 164+ 5A3B D1           	POP DE ; vram destination
 165+ 5A3C E1           	POP HL ; ram source
 166+ 5A3D D9           	EXX
 167+ 5A3E FD 21 45 5A   	LD IY, .RET
 168+ 5A42 C3 39 67     	JP ENABLE_PAGE0
 169+ 5A45              .RET:
 170+ 5A45 FB           	EI
 171+ 5A46 D9           	EXX
 172+ 5A47 CD 4D 5A     	CALL VRAM_LDIRVM
 173+ 5A4A C3 4C 66     	JP COMMON_EXIT_CODE_IX
 174+ 5A4D              ; *******************************************************************************************************
 175+ 5A4D               ENDIF
 176+ 5A4D
 177+ 5A4D               IF (0 == 1)
 178+ 5A4D ~            ; *******************************************************************************************************
 179+ 5A4D ~            ; same as MEMVRM but for DEFUSR approach
 180+ 5A4D ~            ; input IX=pointer to input array, real data from +2
 181+ 5A4D ~            ; +2 = source address
 182+ 5A4D ~            ; +4 = destination address
 183+ 5A4D ~            ; +6 = lenght
 184+ 5A4D ~            ; +8 = flag
 185+ 5A4D ~            MEMVRM_DEFUSR:
 186+ 5A4D ~            	LD A,(IX+8)
 187+ 5A4D ~            	OR A
 188+ 5A4D ~            	JR Z,.L0
 189+ 5A4D ~            	IF (SPRITE_CMDS == 1)
 190+ 5A4D ~            		AND 2
 191+ 5A4D ~            		JR Z,.L2
 192+ 5A4D ~            		LD A, (SPRATR_INIT_STATUS)
 193+ 5A4D ~            		OR A
 194+ 5A4D ~            		JR Z,.L2
 195+ 5A4D ~            		LD HL,(SPRATR_UPDATE_FLAG)
 196+ 5A4D ~            		LD (HL),A
 197+ 5A4D ~            	ENDIF
 198+ 5A4D ~            .L2:
 199+ 5A4D ~            	HALT
 200+ 5A4D ~            .L0:
 201+ 5A4D ~            	; enable page 0
 202+ 5A4D ~            	LD IY, .RET
 203+ 5A4D ~            	JP ENABLE_PAGE0
 204+ 5A4D ~            .RET:
 205+ 5A4D ~            	EI
 206+ 5A4D ~            	LD L,(IX+2)
 207+ 5A4D ~            	LD H,(IX+3)
 208+ 5A4D ~            	LD E,(IX+4)
 209+ 5A4D ~            	LD D,(IX+5)
 210+ 5A4D ~            	LD C,(IX+6)
 211+ 5A4D ~            	LD B,(IX+7)
 212+ 5A4D ~            	CALL VRAM_LDIRVM
 213+ 5A4D ~                JP COMMON_EXIT_CODE
 214+ 5A4D ~            ; *******************************************************************************************************
 215+ 5A4D               ENDIF
 216+ 5A4D
 217+ 5A4D              ; *******************************************************************************************************
 218+ 5A4D              ; common code to copy from memory to VRAM
 219+ 5A4D              ; input HL=RAM source
 220+ 5A4D              ; input DE=VRAM destination
 221+ 5A4D              ; BC=count
 222+ 5A4D              VRAM_LDIRVM:
 223+ 5A4D 3E 01        	LD A,1
 224+ 5A4F 32 62 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 225+ 5A52 EB           	EX DE, HL
 226+ 5A53 F3           	DI
 227+ 5A54 CD 56 66     	CALL SETWRT_LOCAL_WRITE
 228+ 5A57 FB           	EI
 229+ 5A58 EB           	EX DE, HL
 230+ 5A59 78           	LD A, B
 231+ 5A5A B7           	OR A
 232+ 5A5B 28 0D        	JR Z, .L3
 233+ 5A5D C5           	PUSH BC
 234+ 5A5E 0E 98        	LD C, #98
 235+ 5A60              .L2:
 236+ 5A60 50           	LD D, B
 237+ 5A61 06 00        	LD B, 0
 238+ 5A63 CD 6D 66     	CALL BBYTECOPY_NO_C
 239+ 5A66 42           	LD B, D
 240+ 5A67 10 F7        	DJNZ .L2
 241+ 5A69 C1           	POP BC
 242+ 5A6A              .L3:
 243+ 5A6A 79           	LD A, C
 244+ 5A6B B7           	OR A
 245+ 5A6C 28 04        	JR Z,.L4
 246+ 5A6E 41           	LD B, C
 247+ 5A6F CD 6B 66     	CALL BBYTECOPY
 248+ 5A72              .L4:
 249+ 5A72 AF           	XOR A
 250+ 5A73 32 62 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 251+ 5A76 C9           	RET
 252+ 5A77              ; *******************************************************************************************************
 253+ 5A77
 254+ 5A77               IF (1 == 1)
 255+ 5A77              ; *******************************************************************************************************
 256+ 5A77              ; function to handle CALL VRMMEM basic extension
 257+ 5A77              ; copies from VRAM to RAM
 258+ 5A77              ; _VRMMEM ( INT source,
 259+ 5A77              ;			INT destination,
 260+ 5A77              ;			INT count
 261+ 5A77              ; will put ram in page 0 also, page 1 is already there
 262+ 5A77              VRMMEM:
 263+ 5A77              	; opening (
 264+ 5A77 CD 88 67     	CALL CHKCHAR
 265+ 5A7A 28           	DB '('
 266+ 5A7B              	; get source address
 267+ 5A7B DD 21 2F 54  	LD IX, FRMQNT
 268+ 5A7F CD 59 01     	CALL CALBAS
 269+ 5A82 D5           	PUSH DE
 270+ 5A83              	; comma
 271+ 5A83 CD 88 67     	CALL CHKCHAR
 272+ 5A86 2C           	DB ','
 273+ 5A87              	; get destination address
 274+ 5A87 DD 21 2F 54  	LD IX, FRMQNT
 275+ 5A8B CD 59 01     	CALL CALBAS
 276+ 5A8E D5           	PUSH DE
 277+ 5A8F              	; comma
 278+ 5A8F CD 88 67     	CALL CHKCHAR
 279+ 5A92 2C           	DB ','
 280+ 5A93              	; get length
 281+ 5A93 DD 21 2F 54  	LD IX, FRMQNT
 282+ 5A97 CD 59 01     	CALL CALBAS
 283+ 5A9A D5           	PUSH DE
 284+ 5A9B              	; ending )
 285+ 5A9B CD 88 67     	CALL CHKCHAR
 286+ 5A9E 29           	DB ')'
 287+ 5A9F
 288+ 5A9F                  ; save position in BASIC text
 289+ 5A9F E5           	PUSH HL
 290+ 5AA0 DD E1        	POP IX
 291+ 5AA2
 292+ 5AA2 C1           	POP BC ; count
 293+ 5AA3 D1           	POP DE ; destination
 294+ 5AA4 E1           	POP HL ; source
 295+ 5AA5 D9           	EXX
 296+ 5AA6 FD 21 AD 5A  	LD IY, .RET
 297+ 5AAA C3 39 67     	JP ENABLE_PAGE0
 298+ 5AAD              .RET:
 299+ 5AAD FB           	EI
 300+ 5AAE D9           	EXX
 301+ 5AAF CD B5 5A     	CALL VRAM_LDIRMV
 302+ 5AB2 C3 4C 66     	JP COMMON_EXIT_CODE_IX
 303+ 5AB5              ; *******************************************************************************************************
 304+ 5AB5               ENDIF
 305+ 5AB5
 306+ 5AB5               IF (0 == 1)
 307+ 5AB5 ~            ; *******************************************************************************************************
 308+ 5AB5 ~            ; same as VRMMEM but for DEFUSR approach
 309+ 5AB5 ~            ; input IX=pointer to input array, real data from +2
 310+ 5AB5 ~            ; +2 = source address
 311+ 5AB5 ~            ; +4 = destination address
 312+ 5AB5 ~            ; +6 = count
 313+ 5AB5 ~            VRMMEM_DEFUSR:
 314+ 5AB5 ~            	; enable page 0
 315+ 5AB5 ~            	LD IY, .RET
 316+ 5AB5 ~            	JP ENABLE_PAGE0
 317+ 5AB5 ~            .RET:
 318+ 5AB5 ~            	EI
 319+ 5AB5 ~            	LD L,(IX+2)
 320+ 5AB5 ~            	LD H,(IX+3)
 321+ 5AB5 ~            	LD E,(IX+4)
 322+ 5AB5 ~            	LD D,(IX+5)
 323+ 5AB5 ~            	LD C,(IX+6)
 324+ 5AB5 ~            	LD B,(IX+7)
 325+ 5AB5 ~            	CALL VRAM_LDIRMV
 326+ 5AB5 ~            	JP COMMON_EXIT_CODE
 327+ 5AB5 ~            ; *******************************************************************************************************
 328+ 5AB5               ENDIF
 329+ 5AB5
 330+ 5AB5              ; *******************************************************************************************************
 331+ 5AB5              ; common code to copy from VRAM to RAM
 332+ 5AB5              ; input HL=VRAM source
 333+ 5AB5              ; input DE=RAM destination
 334+ 5AB5              ; BC=count
 335+ 5AB5              VRAM_LDIRMV:
 336+ 5AB5 3E 01        	LD A,1
 337+ 5AB7 32 62 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 338+ 5ABA 7D           	LD	A, L
 339+ 5ABB F3           	DI
 340+ 5ABC CD 61 66     	CALL SETWRT_LOCAL_READ
 341+ 5ABF FB           	EI
 342+ 5AC0 00           	NOP
 343+ 5AC1 00           	NOP
 344+ 5AC2 00           	NOP ; too fast VDP access per openMSX
 345+ 5AC3              .L4:
 346+ 5AC3 DB 98            IN A, (#98)
 347+ 5AC5 12           	LD (DE), A
 348+ 5AC6 13               INC DE
 349+ 5AC7 0B               DEC BC
 350+ 5AC8 79               LD A, C
 351+ 5AC9 B0               OR B
 352+ 5ACA 20 F7            JR NZ, .L4
 353+ 5ACC AF           	XOR A
 354+ 5ACD 32 62 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 355+ 5AD0 C9               RET
 356+ 5AD1              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
 152  5AD1               ENDIF
 153  5AD1
 154  5AD1               IF (GENCAL_CMD == 1)
 155  5AD1               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
   1+ 5AD1               IF (0 == 1)
   2+ 5AD1 ~            ; *******************************************************************************************************
   3+ 5AD1 ~            ; same as GENCAL but for DEFUSR approach
   4+ 5AD1 ~            ; input IX=pointer to input array, real data from +2
   5+ 5AD1 ~            ; +2 = function address to call
   6+ 5AD1 ~            ; +4 = register list array pointer
   7+ 5AD1 ~            GENCAL_DEFUSR:
   8+ 5AD1 ~                LD L,(IX+2)
   9+ 5AD1 ~                LD H,(IX+3)
  10+ 5AD1 ~                PUSH HL
  11+ 5AD1 ~                LD L,(IX+4)
  12+ 5AD1 ~                LD H,(IX+5)
  13+ 5AD1 ~                PUSH HL
  14+ 5AD1 ~                JR GENCAL.COMMON
  15+ 5AD1 ~            ; *******************************************************************************************************
  16+ 5AD1               ENDIF
  17+ 5AD1
  18+ 5AD1              ; *******************************************************************************************************
  19+ 5AD1              ; function to handle CALL GENCAL basic extension
  20+ 5AD1              ; GENCAL ( INT fn_addr, = address of the function to call
  21+ 5AD1              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
  22+ 5AD1              ; output values of registers will also be stored at reg_list_ptr
  23+ 5AD1              GENCAL:
  24+ 5AD1               IF (1 == 1)
  25+ 5AD1              	; opening (
  26+ 5AD1 CD 88 67     	CALL CHKCHAR
  27+ 5AD4 28           	DB '('
  28+ 5AD5              	; get function address
  29+ 5AD5 DD 21 2F 54  	LD IX, FRMQNT
  30+ 5AD9 CD 59 01     	CALL CALBAS
  31+ 5ADC D5           	PUSH DE
  32+ 5ADD              	; comma
  33+ 5ADD CD 88 67     	CALL CHKCHAR
  34+ 5AE0 2C           	DB ','
  35+ 5AE1              	; get pointer to register list
  36+ 5AE1 3E 02            LD A,2
  37+ 5AE3 06 01            LD B,1
  38+ 5AE5 11 00 05         LD DE,#0500
  39+ 5AE8 CD ED 67         CALL GET_BASIC_ARRAY_DATA_POINTER
  40+ 5AEB C5           	PUSH BC
  41+ 5AEC              	; ending )
  42+ 5AEC CD 88 67     	CALL CHKCHAR
  43+ 5AEF 29           	DB ')'
  44+ 5AF0               ENDIF
  45+ 5AF0              .COMMON:
  46+ 5AF0              	; save BASIC token position
  47+ 5AF0 E5           	PUSH HL
  48+ 5AF1 D9               EXX
  49+ 5AF2 E1           	POP HL ; HL'=next basic token
  50+ 5AF3 D9               EXX
  51+ 5AF4
  52+ 5AF4 E1               POP HL ; get pointer to register values
  53+ 5AF5 F3           	DI
  54+ 5AF6 ED 73 51 64      LD (TMP_STRUCT), SP
  55+ 5AFA F9               LD SP, HL
  56+ 5AFB F1               POP AF
  57+ 5AFC C1               POP BC
  58+ 5AFD D1               POP DE
  59+ 5AFE E1               POP HL
  60+ 5AFF DD E1            POP IX
  61+ 5B01 FD E1            POP IY
  62+ 5B03 D9               EXX
  63+ 5B04 ED 73 53 64      LD (TMP_STRUCT+2), SP
  64+ 5B08 ED 7B 51 64      LD SP, (TMP_STRUCT)
  65+ 5B0C FB               EI
  66+ 5B0D D1               POP DE ; get function to call
  67+ 5B0E E5               PUSH HL
  68+ 5B0F CD 2B 5B         CALL .EXXDECALL
  69+ 5B12 F3               DI
  70+ 5B13 ED 73 51 64      LD (TMP_STRUCT), SP
  71+ 5B17 ED 7B 53 64      LD SP, (TMP_STRUCT+2)
  72+ 5B1B FD E5            PUSH IY
  73+ 5B1D DD E5            PUSH IX
  74+ 5B1F E5               PUSH HL
  75+ 5B20 D5               PUSH DE
  76+ 5B21 C5               PUSH BC
  77+ 5B22 F5               PUSH AF
  78+ 5B23 ED 7B 51 64      LD SP, (TMP_STRUCT)
  79+ 5B27 FB               EI
  80+ 5B28 E1               POP HL
  81+ 5B29 AF               XOR A ; success
  82+ 5B2A C9           	RET
  83+ 5B2B
  84+ 5B2B              .EXXDECALL:
  85+ 5B2B D5               PUSH DE
  86+ 5B2C D9               EXX
  87+ 5B2D C9               RET
  88+ 5B2E              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
 156  5B2E               ENDIF
 157  5B2E
 158  5B2E               IF (BOX_CMDS == 1)
 159  5B2E               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
   1+ 5B2E              ; *******************************************************************************************************
   2+ 5B2E              ; generic function to implement rectangle data copy
   3+ 5B2E              ; should be modified to call appropriate function for memory or vram
   4+ 5B2E              ; input IX=pointer to following structure
   5+ 5B2E              ; +00 source data pointer
   6+ 5B2E              ; +02 num bytes in a row
   7+ 5B2E              ; +04 number of rows
   8+ 5B2E              ; +06 source add-to value till next row
   9+ 5B2E              ; +08 destination address
  10+ 5B2E              ; +10 destination add-to value till next row
  11+ 5B2E              ; modifies AF, BC, DE, HL
  12+ 5B2E              RECTANGLE_COPY:
  13+ 5B2E DD 6E 00     	LD L, (IX+0)
  14+ 5B31 DD 66 01     	LD H, (IX+1) ; source address
  15+ 5B34 DD 5E 08     	LD E, (IX+8)
  16+ 5B37 DD 56 09     	LD D, (IX+9) ; destination
  17+ 5B3A DD 46 04     	LD B, (IX+4) ; row number
  18+ 5B3D              .L1:
  19+ 5B3D C5           	PUSH BC
  20+ 5B3E E5           		PUSH HL
  21+ 5B3F D5           			PUSH DE
  22+ 5B40 DD 4E 02     				LD C, (IX+2)
  23+ 5B43 DD 46 03     				LD B, (IX+3) ; num bytes in a row
  24+ 5B46              .CALL1:
  25+ 5B46 CD 00 00     				CALL 0 ; set destination address from DE
  26+ 5B49              .CALL2:
  27+ 5B49 CD 00 00     				CALL 0 ; copy data fn
  28+ 5B4C E1           			POP HL
  29+ 5B4D DD 4E 0A     			LD C, (IX+10)
  30+ 5B50 DD 46 0B     			LD B, (IX+11) ; destination add-to
  31+ 5B53 09           			ADD HL, BC
  32+ 5B54 EB           			EX DE, HL
  33+ 5B55 E1           		POP HL
  34+ 5B56 DD 4E 06     		LD C, (IX+6)
  35+ 5B59 DD 46 07     		LD B, (IX+7) ; src add-to
  36+ 5B5C 09           		ADD HL, BC
  37+ 5B5D C1           	POP BC
  38+ 5B5E 10 DD        	DJNZ .L1
  39+ 5B60 C9           	RET
  40+ 5B61              ; *******************************************************************************************************
  41+ 5B61
  42+ 5B61               IF (1 == 1)
  43+ 5B61              ; *******************************************************************************************************
  44+ 5B61              ; function to handle CALL BOXMEMCPY basic extension
  45+ 5B61              ; copies data with window like boundaries within ram
  46+ 5B61              ; BOXMEMCPY ( INT source data pointer,
  47+ 5B61              ;			  INT source number of bytes in a row,
  48+ 5B61              ;			  INT number of rows,
  49+ 5B61              ;			  INT source add-to value till next row,
  50+ 5B61              ; 			  INT destination pointer,
  51+ 5B61              ;			  INT destination add-to value till next row )
  52+ 5B61              ; request_data_ptr described in RECTANGLE_COPY
  53+ 5B61              ; will put ram in page 0 also, page 1 is already there
  54+ 5B61              BOXMEMCPY:
  55+ 5B61 11 6B 5B     	LD DE,BOXMEMCPY_COMMON
  56+ 5B64 ED 53 E3 5B  	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
  57+ 5B68 C3 7E 5B     	JP BOX_EXTENSION_PARAMS_COMMON
  58+ 5B6B               ENDIF
  59+ 5B6B
  60+ 5B6B               IF (0 == 1)
  61+ 5B6B ~            ; *******************************************************************************************************
  62+ 5B6B ~            ; same as BOXMEMCPY but for DEFUSR approach
  63+ 5B6B ~            ; input IX=pointer to input array, real data from +2
  64+ 5B6B ~            ; +02 = source data pointer
  65+ 5B6B ~            ; +04 = source number of bytes in a row
  66+ 5B6B ~            ; +06 = number of rows
  67+ 5B6B ~            ; +08 = source add-to value till next row
  68+ 5B6B ~            ; +10 = destination pointer
  69+ 5B6B ~            ; +12 = destination add-to value till next row
  70+ 5B6B ~            BOXMEMCPY_DEFUSR:
  71+ 5B6B ~            	LD HL,BOXMEMCPY_COMMON
  72+ 5B6B ~            	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
  73+ 5B6B ~            	INC IX
  74+ 5B6B ~            	INC IX
  75+ 5B6B ~            	JP BOXCOMMON_DEFUSR
  76+ 5B6B               ENDIF
  77+ 5B6B
  78+ 5B6B              BOXMEMCPY_COMMON:
  79+ 5B6B FB           	EI
  80+ 5B6C              	; set RAM functions to call
  81+ 5B6C 21 00 00     	LD HL, 0
  82+ 5B6F 22 46 5B     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
  83+ 5B72 22 48 5B     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
  84+ 5B75 21 ED B0     	LD HL, #B0ED ; LDIR
  85+ 5B78 22 4A 5B     	LD (RECTANGLE_COPY.CALL1+4), HL
  86+ 5B7B C3 E8 5B     	JP BOXCOMMON_DEFUSR.CALL
  87+ 5B7E              ; *******************************************************************************************************
  88+ 5B7E
  89+ 5B7E               IF (1 == 1)
  90+ 5B7E              ; *******************************************************************************************************
  91+ 5B7E              ; common parts of BOX commands to load parameters
  92+ 5B7E              BOX_EXTENSION_PARAMS_COMMON:
  93+ 5B7E              	; opening (
  94+ 5B7E CD 88 67     	CALL CHKCHAR
  95+ 5B81 28           	DB '('
  96+ 5B82              	; get source data pointer
  97+ 5B82 DD 21 2F 54  	LD IX, FRMQNT
  98+ 5B86 CD 59 01     	CALL CALBAS
  99+ 5B89 ED 53 51 64  	LD (TMP_STRUCT+0), DE
 100+ 5B8D              	; comma
 101+ 5B8D CD 88 67     	CALL CHKCHAR
 102+ 5B90 2C           	DB ','
 103+ 5B91              	; source number of bytes in a row
 104+ 5B91 DD 21 2F 54  	LD IX, FRMQNT
 105+ 5B95 CD 59 01     	CALL CALBAS
 106+ 5B98 ED 53 53 64  	LD (TMP_STRUCT+2), DE
 107+ 5B9C              	; comma
 108+ 5B9C CD 88 67     	CALL CHKCHAR
 109+ 5B9F 2C           	DB ','
 110+ 5BA0              	; number of rows
 111+ 5BA0 DD 21 2F 54  	LD IX, FRMQNT
 112+ 5BA4 CD 59 01     	CALL CALBAS
 113+ 5BA7 ED 53 55 64  	LD (TMP_STRUCT+4), DE
 114+ 5BAB              	; comma
 115+ 5BAB CD 88 67     	CALL CHKCHAR
 116+ 5BAE 2C           	DB ','
 117+ 5BAF              	; source add-to value till next row
 118+ 5BAF DD 21 2F 54  	LD IX, FRMQNT
 119+ 5BB3 CD 59 01     	CALL CALBAS
 120+ 5BB6 ED 53 57 64  	LD (TMP_STRUCT+6), DE
 121+ 5BBA              	; comma
 122+ 5BBA CD 88 67     	CALL CHKCHAR
 123+ 5BBD 2C           	DB ','
 124+ 5BBE              	; destination pointer
 125+ 5BBE DD 21 2F 54  	LD IX, FRMQNT
 126+ 5BC2 CD 59 01     	CALL CALBAS
 127+ 5BC5 ED 53 59 64  	LD (TMP_STRUCT+8), DE
 128+ 5BC9              	; comma
 129+ 5BC9 CD 88 67     	CALL CHKCHAR
 130+ 5BCC 2C           	DB ','
 131+ 5BCD              	; destination add-to value till next row
 132+ 5BCD DD 21 2F 54  	LD IX, FRMQNT
 133+ 5BD1 CD 59 01     	CALL CALBAS
 134+ 5BD4 ED 53 5B 64  	LD (TMP_STRUCT+10), DE
 135+ 5BD8              	; ending )
 136+ 5BD8 CD 88 67     	CALL CHKCHAR
 137+ 5BDB 29           	DB ')'
 138+ 5BDC DD 21 51 64  	LD IX,TMP_STRUCT
 139+ 5BE0               ENDIF
 140+ 5BE0              BOXCOMMON_DEFUSR:
 141+ 5BE0 E5           	PUSH HL ; save position in BASIC buffer
 142+ 5BE1              .ADDR:
 143+ 5BE1 FD 21 00 00  	LD IY, 0 ; modified by code
 144+ 5BE5 C3 39 67     	JP ENABLE_PAGE0
 145+ 5BE8              .CALL:
 146+ 5BE8 CD 2E 5B     	CALL RECTANGLE_COPY
 147+ 5BEB AF           	XOR A
 148+ 5BEC 32 62 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 149+ 5BEF C3 4F 66         JP COMMON_EXIT_CODE
 150+ 5BF2              ; *******************************************************************************************************
 151+ 5BF2
 152+ 5BF2               IF (1 == 1)
 153+ 5BF2              ; *******************************************************************************************************
 154+ 5BF2              ; function to handle CALL BOXMEMVRM basic extension
 155+ 5BF2              ; copies data with window like boundaries from ram to Vram
 156+ 5BF2              ; BOXMEMVRM ( INT source data pointer,
 157+ 5BF2              ;			  INT source number of bytes in a row,
 158+ 5BF2              ;			  INT number of rows,
 159+ 5BF2              ;			  INT source add-to value till next row,
 160+ 5BF2              ; 			  INT destination pointer,
 161+ 5BF2              ;			  INT destination add-to value till next row )
 162+ 5BF2              ; request_data_ptr described in RECTANGLE_COPY
 163+ 5BF2              ; will put ram in page 0 also, page 1 is already there
 164+ 5BF2              BOXMEMVRM:
 165+ 5BF2 11 FC 5B     	LD DE,BOXMEMVRM_COMMON
 166+ 5BF5 ED 53 E3 5B  	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
 167+ 5BF9 C3 7E 5B     	JP BOX_EXTENSION_PARAMS_COMMON
 168+ 5BFC               ENDIF
 169+ 5BFC
 170+ 5BFC               IF (0 == 1)
 171+ 5BFC ~            ; *******************************************************************************************************
 172+ 5BFC ~            ; same as BOXMEMVRM but for DEFUSR approach
 173+ 5BFC ~            ; input IX=pointer to input array, real data from +2
 174+ 5BFC ~            ; +02 = source data pointer
 175+ 5BFC ~            ; +04 = source number of bytes in a row
 176+ 5BFC ~            ; +06 = number of rows
 177+ 5BFC ~            ; +08 = source add-to value till next row
 178+ 5BFC ~            ; +10 = destination pointer
 179+ 5BFC ~            ; +12 = destination add-to value till next row
 180+ 5BFC ~            BOXMEMVRM_DEFUSR:
 181+ 5BFC ~            	LD HL,BOXMEMVRM_COMMON
 182+ 5BFC ~            	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
 183+ 5BFC ~            	INC IX
 184+ 5BFC ~            	INC IX
 185+ 5BFC ~            	JP BOXCOMMON_DEFUSR
 186+ 5BFC               ENDIF
 187+ 5BFC
 188+ 5BFC              BOXMEMVRM_COMMON:
 189+ 5BFC FB           	EI
 190+ 5BFD              	; set RAM functions to call
 191+ 5BFD 21 17 5C     	LD HL, .SETDEST
 192+ 5C00 22 47 5B     	LD (RECTANGLE_COPY.CALL1+1), HL
 193+ 5C03 21 1F 5C     	LD HL, .COPYDATA
 194+ 5C06 22 4A 5B     	LD (RECTANGLE_COPY.CALL2+1), HL
 195+ 5C09 3E CD        	LD A, #CD ; CALL
 196+ 5C0B 32 46 5B     	LD (RECTANGLE_COPY.CALL1), A
 197+ 5C0E 32 49 5B     	LD (RECTANGLE_COPY.CALL2), A
 198+ 5C11              	;LD A,1
 199+ 5C11 32 62 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 200+ 5C14 C3 E8 5B     	JP BOXCOMMON_DEFUSR.CALL
 201+ 5C17              .SETDEST:
 202+ 5C17 EB           	EX DE, HL
 203+ 5C18 F3           	DI
 204+ 5C19 CD 56 66     	CALL SETWRT_LOCAL_WRITE
 205+ 5C1C FB           	EI
 206+ 5C1D EB           	EX DE, HL
 207+ 5C1E C9           	RET
 208+ 5C1F              .COPYDATA:
 209+ 5C1F 41           	LD B, C
 210+ 5C20 C3 6B 66     	JP BBYTECOPY
 211+ 5C23              ; *******************************************************************************************************
# file closed: asm\BOX.asm
 160  5C23               ENDIF
 161  5C23
 162  5C23               IF (BLIT_CMDS == 1)
 163  5C23               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
   1+ 5C23              ; *******************************************************************************************************
   2+ 5C23              ; function rotates mask and data of several characters and applies to background data
   3+ 5C23              ; this handles x-shift from 0 to 4
   4+ 5C23              ; contains self-modifying code that is set-up from external function
   5+ 5C23              ; input HL=pointer to mask data
   6+ 5C23              ; input HL'=pointer to character data
   7+ 5C23              ; input DE=output buffer containing background data
   8+ 5C23              ; input BC=DE+8
   9+ 5C23              ; input A=number of characters to process
  10+ 5C23              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  11+ 5C23              SHIFT04:
  12+ 5C23 08           	EX AF, AF'
  13+ 5C24 7E           	LD A, (HL) ; get mask
  14+ 5C25 D9           	EXX
  15+ 5C26 57           	LD D, A
  16+ 5C27 1E FF        	LD E, #FF
  17+ 5C29 37           	SCF
  18+ 5C2A              .M1:
  19+ 5C2A 18 FE        	JR .M1 ; this is self-modifying part
  20+ 5C2C CB 1A        	RR D
  21+ 5C2E CB 1B        	RR E
  22+ 5C30 CB 1A        	RR D
  23+ 5C32 CB 1B        	RR E
  24+ 5C34 CB 1A        	RR D
  25+ 5C36 CB 1B        	RR E
  26+ 5C38 CB 1A        	RR D
  27+ 5C3A CB 1B        	RR E
  28+ 5C3C
  29+ 5C3C 46           	LD B, (HL) ; get data
  30+ 5C3D 0E 00        	LD C, 0
  31+ 5C3F              .M2:
  32+ 5C3F 18 FE        	JR .M2 ; also self-modifying part
  33+ 5C41 CB 38        	SRL B
  34+ 5C43 CB 19        	RR C
  35+ 5C45 CB 38        	SRL B
  36+ 5C47 CB 19        	RR C
  37+ 5C49 CB 38        	SRL B
  38+ 5C4B CB 19        	RR C
  39+ 5C4D CB 38        	SRL B
  40+ 5C4F CB 19        	RR C
  41+ 5C51
  42+ 5C51 D9           	EXX
  43+ 5C52 1A           	LD A, (DE) ; background
  44+ 5C53 D9           	EXX
  45+ 5C54 A2           	AND D
  46+ 5C55 B0           	OR B
  47+ 5C56 D9           	EXX
  48+ 5C57 12           	LD (DE), A
  49+ 5C58
  50+ 5C58 0A           	LD A, (BC)
  51+ 5C59 D9           	EXX
  52+ 5C5A A3           	AND E
  53+ 5C5B B1           	OR C
  54+ 5C5C 23           	INC HL
  55+ 5C5D D9           	EXX
  56+ 5C5E 02           	LD (BC), A
  57+ 5C5F
  58+ 5C5F 23           	INC HL
  59+ 5C60 13           	INC DE
  60+ 5C61 03           	INC BC
  61+ 5C62
  62+ 5C62 08           	EX AF, AF'
  63+ 5C63 3D           	DEC A
  64+ 5C64 C2 23 5C     	JP NZ, SHIFT04
  65+ 5C67 C9           	RET
  66+ 5C68              ; *******************************************************************************************************
  67+ 5C68
  68+ 5C68              ; *******************************************************************************************************
  69+ 5C68              ; function rotates mask and data of several characters and applies to background data
  70+ 5C68              ; this handles x-shift from 5 to 8
  71+ 5C68              ; contains self-modifying code that is set-up from external function
  72+ 5C68              ; input HL=pointer to mask data
  73+ 5C68              ; input HL'=pointer to character data
  74+ 5C68              ; input DE=output buffer containing background data
  75+ 5C68              ; input BC=DE+8
  76+ 5C68              ; input A=number of characters to process
  77+ 5C68              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  78+ 5C68              SHIFT58:
  79+ 5C68 08           	EX AF, AF'
  80+ 5C69 7E           	LD A, (HL) ; get mask
  81+ 5C6A D9           	EXX
  82+ 5C6B 57           	LD D, A
  83+ 5C6C 1E FF        	LD E, #FF
  84+ 5C6E 37           	SCF
  85+ 5C6F              .M1:
  86+ 5C6F 18 FE        	JR .M1 ; this is self-modifying part
  87+ 5C71 CB 12        	RL D
  88+ 5C73 CB 13        	RL E
  89+ 5C75 CB 12        	RL D
  90+ 5C77 CB 13        	RL E
  91+ 5C79 CB 12        	RL D
  92+ 5C7B CB 13        	RL E
  93+ 5C7D
  94+ 5C7D 46           	LD B, (HL)
  95+ 5C7E 0E 00        	LD C, 0
  96+ 5C80              .M2:
  97+ 5C80 18 FE        	JR .M2 ; also self-modifying part
  98+ 5C82 CB 20        	SLA B
  99+ 5C84 CB 11        	RL C
 100+ 5C86 CB 20        	SLA B
 101+ 5C88 CB 11        	RL C
 102+ 5C8A CB 20        	SLA B
 103+ 5C8C CB 11        	RL C
 104+ 5C8E
 105+ 5C8E D9           	EXX
 106+ 5C8F 1A           	LD A, (DE) ; background
 107+ 5C90 D9           	EXX
 108+ 5C91 A3           	AND E
 109+ 5C92 B1           	OR C
 110+ 5C93 D9           	EXX
 111+ 5C94 12           	LD (DE), A
 112+ 5C95
 113+ 5C95 0A           	LD A, (BC)
 114+ 5C96 D9           	EXX
 115+ 5C97 A2           	AND D
 116+ 5C98 B0           	OR B
 117+ 5C99 23           	INC HL
 118+ 5C9A D9           	EXX
 119+ 5C9B 02           	LD (BC), A
 120+ 5C9C
 121+ 5C9C 23           	INC HL
 122+ 5C9D 13           	INC DE
 123+ 5C9E 03           	INC BC
 124+ 5C9F
 125+ 5C9F 08           	EX AF, AF'
 126+ 5CA0 3D           	DEC A
 127+ 5CA1 C2 68 5C     	JP NZ, SHIFT58
 128+ 5CA4 C9           	RET
 129+ 5CA5              ; *******************************************************************************************************
 130+ 5CA5
 131+ 5CA5              ; *******************************************************************************************************
 132+ 5CA5              ; routine that shifts one row of characters
 133+ 5CA5              ; contains self-modifying code that is set-up from external function
 134+ 5CA5              ; input HL=pointer to mask data
 135+ 5CA5              ; input HL'=pointer to character data
 136+ 5CA5              ; input DE=output buffer containing background data
 137+ 5CA5              ; input A=number of characters to process
 138+ 5CA5              ; input IX=pointer to structure describing input data
 139+ 5CA5              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 140+ 5CA5              SHIFT_ROW:
 141+ 5CA5 F5           	PUSH AF
 142+ 5CA6 ED 53 4D 64  		LD (BLIT_TMP1), DE
 143+ 5CAA E5           		PUSH HL
 144+ 5CAB CD EE 5C     			CALL .ADDYSHIFT
 145+ 5CAE E1           		POP HL
 146+ 5CAF ED 53 4F 64  		LD (BLIT_TMP2), DE ; DE+vertical shift
 147+ 5CB3              .L1:
 148+ 5CB3 3E 08        		LD A, 8
 149+ 5CB5 DD 96 02     		SUB (IX+2) ; y shift
 150+ 5CB8              .CALL1:
 151+ 5CB8 CD 00 00     		CALL 0
 152+ 5CBB DD 7E 02     		LD A, (IX+2); y shift
 153+ 5CBE B7           		OR A
 154+ 5CBF 28 26        		JR Z, .DONE
 155+ 5CC1 ED 5B 4D 64  		LD DE, (BLIT_TMP1)
 156+ 5CC5 E5           		PUSH HL
 157+ 5CC6 CD FC 5C     			CALL .DETONEXTROW
 158+ 5CC9 E1           		POP HL
 159+ 5CCA              .CALL2:
 160+ 5CCA CD 00 00     		CALL 0
 161+ 5CCD ED 5B 4D 64  		LD DE, (BLIT_TMP1)
 162+ 5CD1 E5           		PUSH HL
 163+ 5CD2 CD F6 5C     			CALL .ADD8
 164+ 5CD5 E1           		POP HL
 165+ 5CD6 ED 53 4D 64  		LD (BLIT_TMP1), DE
 166+ 5CDA ED 5B 4F 64  		LD DE, (BLIT_TMP2)
 167+ 5CDE E5           		PUSH HL
 168+ 5CDF CD F6 5C     			CALL .ADD8
 169+ 5CE2 E1           		POP HL
 170+ 5CE3 ED 53 4F 64  		LD (BLIT_TMP2), DE ; DE+vertical shift
 171+ 5CE7              .DONE:
 172+ 5CE7 F1           	POP AF
 173+ 5CE8 3D           	DEC A
 174+ 5CE9 C8           	RET Z
 175+ 5CEA F5           	PUSH AF
 176+ 5CEB C3 B3 5C     	JP .L1
 177+ 5CEE              .ADDYSHIFT:
 178+ 5CEE EB           	EX DE, HL
 179+ 5CEF 16 00        	LD D, 0
 180+ 5CF1 DD 5E 02     	LD E, (IX+2); y shift
 181+ 5CF4 18 0C        	JR .MOVDEBC
 182+ 5CF6              .ADD8:
 183+ 5CF6 21 08 00     	LD HL, 8
 184+ 5CF9 C3 02 5D     	JP .MOVDEBC
 185+ 5CFC              .DETONEXTROW:
 186+ 5CFC DD 6E 06     	LD L, (IX+6)
 187+ 5CFF DD 66 07     	LD H, (IX+7) ; bkg add to value
 188+ 5D02              .MOVDEBC:
 189+ 5D02 19           	ADD HL, DE
 190+ 5D03 54           	LD D, H
 191+ 5D04 5D           	LD E, L
 192+ 5D05 01 08 00     	LD BC, 8
 193+ 5D08 09           	ADD HL, BC
 194+ 5D09 44           	LD B, H
 195+ 5D0A 4D           	LD C, L
 196+ 5D0B C9           	RET
 197+ 5D0C              ; *******************************************************************************************************
 198+ 5D0C
 199+ 5D0C              ; *******************************************************************************************************
 200+ 5D0C              ; function rotates mask and character data and applies it to background
 201+ 5D0C              ; input IX=pointer to structure describing input data
 202+ 5D0C              ; +0  DW horizontal shift count 0-7 (low byte used)
 203+ 5D0C              ; +2  DW vertical shift count 0-7 (low byte used)
 204+ 5D0C              ; +4  DW background data start;
 205+ 5D0C              ; +6  DW background add to value to next row of background data
 206+ 5D0C              ; +8  DW mask data start;
 207+ 5D0C              ; +10  DW character data start;
 208+ 5D0C              ; +12 DW character&mask add to value to next row of data
 209+ 5D0C              ; +14 DW columns (low byte used)
 210+ 5D0C              ; +16 DW rows (low byte used)
 211+ 5D0C              SHIFT_MERGE_CHARACTER:
 212+ 5D0C DD 7E 00     	LD A, (IX) ; shift
 213+ 5D0F FE 05        	CP 5
 214+ 5D11 38 25        	JR C, .RIGHT
 215+ 5D13              	; shifts 5-7, use rotate towards left 1-3
 216+ 5D13 21 68 5C     	LD HL, SHIFT58
 217+ 5D16 22 B9 5C     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 218+ 5D19 22 CB 5C     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 219+ 5D1C D6 05        	SUB 5
 220+ 5D1E 28 0D        	JR Z, .L1
 221+ 5D20 87           	ADD A, A
 222+ 5D21 87           	ADD A, A
 223+ 5D22 67           	LD H, A
 224+ 5D23 2E 18        	LD L, #18 ; JR opcode
 225+ 5D25 22 6F 5C     	LD (SHIFT58.M1), HL
 226+ 5D28 22 80 5C     	LD (SHIFT58.M2), HL
 227+ 5D2B 18 32        	JR .DO
 228+ 5D2D              .L1:
 229+ 5D2D 21 00 00     	LD HL, 0 ; 2xNOP opcode
 230+ 5D30 22 6F 5C     	LD (SHIFT58.M1), HL
 231+ 5D33 22 80 5C     	LD (SHIFT58.M2), HL
 232+ 5D36 18 27        	JR .DO
 233+ 5D38              .RIGHT:
 234+ 5D38              	; shifts 0-4, rotate towards right
 235+ 5D38 21 23 5C     	LD HL, SHIFT04
 236+ 5D3B 22 B9 5C     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 237+ 5D3E 22 CB 5C     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 238+ 5D41 FE 04        	CP 4
 239+ 5D43 28 11        	JR Z, .R1
 240+ 5D45 D6 04        	SUB 4
 241+ 5D47 ED 44        	NEG
 242+ 5D49 87           	ADD A, A
 243+ 5D4A 87           	ADD A, A
 244+ 5D4B 67           	LD H, A
 245+ 5D4C 2E 18        	LD L, #18 ; JR opcode
 246+ 5D4E 22 2A 5C     	LD (SHIFT04.M1), HL
 247+ 5D51 22 3F 5C     	LD (SHIFT04.M2), HL
 248+ 5D54 18 09        	JR .DO
 249+ 5D56              .R1:
 250+ 5D56 21 00 00     	LD HL, 0 ; 2xNOP opcode
 251+ 5D59 22 2A 5C     	LD (SHIFT04.M1), HL
 252+ 5D5C 22 3F 5C     	LD (SHIFT04.M2), HL
 253+ 5D5F              .DO:
 254+ 5D5F DD 46 10     	LD B, (IX+16) ; rows
 255+ 5D62 DD 6E 08     	LD L, (IX+8)
 256+ 5D65 DD 66 09     	LD H, (IX+9) ; mask data
 257+ 5D68 DD 5E 04     	LD E, (IX+4)
 258+ 5D6B DD 56 05     	LD D, (IX+5) ; background data
 259+ 5D6E D9           	EXX
 260+ 5D6F DD 6E 0A     	LD L, (IX+10)
 261+ 5D72 DD 66 0B     	LD H, (IX+11) ; character data
 262+ 5D75 D9           	EXX
 263+ 5D76              .LOOP:
 264+ 5D76 C5           	PUSH BC
 265+ 5D77 E5           		PUSH HL
 266+ 5D78 D5           			PUSH DE
 267+ 5D79 D9           				EXX
 268+ 5D7A E5           				PUSH HL
 269+ 5D7B D9           					EXX
 270+ 5D7C DD 7E 0E     					LD A, (IX+14) ; columns
 271+ 5D7F              .CALL:
 272+ 5D7F CD A5 5C     					CALL SHIFT_ROW
 273+ 5D82 E1           				POP HL
 274+ 5D83 DD 5E 0C     				LD E, (IX+12)
 275+ 5D86 DD 56 0D     				LD D, (IX+13) ; char data to next row
 276+ 5D89 19           				ADD HL, DE
 277+ 5D8A D9           				EXX
 278+ 5D8B E1           			POP HL
 279+ 5D8C DD 5E 06     			LD E, (IX+6)
 280+ 5D8F DD 56 07     			LD D, (IX+7) ; background to next row
 281+ 5D92 19           			ADD HL, DE
 282+ 5D93 EB           			EX DE, HL
 283+ 5D94 E1           		POP HL
 284+ 5D95 DD 4E 0C     		LD C, (IX+12)
 285+ 5D98 DD 46 0D     		LD B, (IX+13) ; char data to next row
 286+ 5D9B 09           		ADD HL, BC
 287+ 5D9C C1           	POP BC
 288+ 5D9D 10 D7        	DJNZ .LOOP
 289+ 5D9F C9           	RET
 290+ 5DA0              ; *******************************************************************************************************
 291+ 5DA0
 292+ 5DA0              ; *******************************************************************************************************
 293+ 5DA0              ; helper function DE \ 8
 294+ 5DA0              DEdiv8:
 295+ 5DA0 7B           	LD A,E
 296+ 5DA1 CB 2A        	SRA D
 297+ 5DA3 CB 1F            RR  A
 298+ 5DA5 CB 2A            SRA D
 299+ 5DA7 CB 1F            RR  A
 300+ 5DA9 CB 2A            SRA D
 301+ 5DAB CB 1F            RR  A
 302+ 5DAD C9           	RET
 303+ 5DAE              ; *******************************************************************************************************
 304+ 5DAE
 305+ 5DAE               IF (0 == 1)
 306+ 5DAE ~            ; *******************************************************************************************************
 307+ 5DAE ~            ; function to handle BLIT basic extension through DEFUSR call in RAW format
 308+ 5DAE ~            ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 309+ 5DAE ~            ; +2  DW horizontal shift count 0-7 (low byte used)
 310+ 5DAE ~            ; +4  DW vertical shift count 0-7 (low byte used)
 311+ 5DAE ~            ; +6  DW background data start;
 312+ 5DAE ~            ; +8  DW background add to value to next row of background data
 313+ 5DAE ~            ; +10  DW mask data start;
 314+ 5DAE ~            ; +12  DW character data start;
 315+ 5DAE ~            ; +14 DW character&mask add to value to next row of data
 316+ 5DAE ~            ; +16 DW columns (low byte used)
 317+ 5DAE ~            ; +18 DW rows (low byte used)
 318+ 5DAE ~            ; will put ram in page 0 also, page 1 is already there
 319+ 5DAE ~            ;BLIT_DEFUSR:
 320+ 5DAE ~            ;	DI
 321+ 5DAE ~            ;	LD IY, .RET
 322+ 5DAE ~            ;	JP ENABLE_PAGE0
 323+ 5DAE ~            ;.RET:
 324+ 5DAE ~            ;	EI
 325+ 5DAE ~            ;	INC IX
 326+ 5DAE ~            ;	INC IX
 327+ 5DAE ~            ;	CALL SHIFT_MERGE_CHARACTER
 328+ 5DAE ~            ;
 329+ 5DAE ~            ;   POP DE
 330+ 5DAE ~            ;    POP BC
 331+ 5DAE ~            ;    JP RESTORE_PAGE_INFO
 332+ 5DAE ~            ; *******************************************************************************************************
 333+ 5DAE ~
 334+ 5DAE ~            ; *******************************************************************************************************
 335+ 5DAE ~            ; function to handle CALL BLIT basic extension in DEFUSR form
 336+ 5DAE ~            ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 337+ 5DAE ~            ; +02 x
 338+ 5DAE ~            ; +04 y
 339+ 5DAE ~            ; +06 char_data_pointer
 340+ 5DAE ~            ; +08 mask_data_pointer
 341+ 5DAE ~            ; +10 width
 342+ 5DAE ~            ; +12 height
 343+ 5DAE ~            ; +14 background_pointer
 344+ 5DAE ~            ; +16 background_width
 345+ 5DAE ~            ; BLIT ( INT x,
 346+ 5DAE ~            ;		 INT y,
 347+ 5DAE ~            ;		 INT char_data_pointer,
 348+ 5DAE ~            ;		 INT mask_data_pointer,
 349+ 5DAE ~            ;		 INT width (in characters),
 350+ 5DAE ~            ;		 INT height (in characters),
 351+ 5DAE ~            ;		 INT background_pointer (top left),
 352+ 5DAE ~            ;		 INT background_width (in characters),
 353+ 5DAE ~            BLIT_DEFUSR:
 354+ 5DAE ~            	LD E,(IX+2)
 355+ 5DAE ~            	LD D,(IX+3)
 356+ 5DAE ~            	LD A,E
 357+ 5DAE ~            	AND 7
 358+ 5DAE ~            	LD (TMP_STRUCT+0),A
 359+ 5DAE ~            	CALL DEdiv8
 360+ 5DAE ~            	LD (BLIT_TMP+0),A
 361+ 5DAE ~            	LD E,(IX+4)
 362+ 5DAE ~            	LD D,(IX+5)
 363+ 5DAE ~            	LD A,E
 364+ 5DAE ~            	AND 7
 365+ 5DAE ~            	LD (TMP_STRUCT+2),A
 366+ 5DAE ~            	CALL DEdiv8
 367+ 5DAE ~            	LD (BLIT_TMP+1),A
 368+ 5DAE ~            	LD L,(IX+6)
 369+ 5DAE ~            	LD H,(IX+7)
 370+ 5DAE ~            	LD (TMP_STRUCT+10),HL
 371+ 5DAE ~            	LD L,(IX+8)
 372+ 5DAE ~            	LD H,(IX+9)
 373+ 5DAE ~            	LD (TMP_STRUCT+8),HL
 374+ 5DAE ~            	LD A,(IX+10)
 375+ 5DAE ~            	LD (TMP_STRUCT+14),A
 376+ 5DAE ~            	LD A,(IX+12)
 377+ 5DAE ~            	LD (TMP_STRUCT+16),A
 378+ 5DAE ~            	LD L,(IX+14)
 379+ 5DAE ~            	LD H,(IX+15)
 380+ 5DAE ~            	LD (TMP_STRUCT+4),HL
 381+ 5DAE ~            	;LD A,(IX+16)
 382+ 5DAE ~            	;LD (BLIT_TMP+2),A
 383+ 5DAE ~
 384+ 5DAE ~            	; calculate char&mask add to value
 385+ 5DAE ~            	LD H,0
 386+ 5DAE ~            	LD A,(TMP_STRUCT+14)
 387+ 5DAE ~            	LD L,A
 388+ 5DAE ~            	CALL HLx8
 389+ 5DAE ~            	LD (TMP_STRUCT+12),HL
 390+ 5DAE ~            	; calculate background add to value
 391+ 5DAE ~            	LD H,0
 392+ 5DAE ~            	LD L,(IX+16)
 393+ 5DAE ~            	CALL HLx8
 394+ 5DAE ~            	LD (TMP_STRUCT+6),HL
 395+ 5DAE ~            	; calculate pointer to background location
 396+ 5DAE ~            	LD HL,0
 397+ 5DAE ~            	LD A,(BLIT_TMP+1)
 398+ 5DAE ~            	OR A
 399+ 5DAE ~            	JR Z, .L1
 400+ 5DAE ~            	LD B,A
 401+ 5DAE ~            	LD DE,(TMP_STRUCT+6)
 402+ 5DAE ~            .L0:
 403+ 5DAE ~            	ADD HL, DE
 404+ 5DAE ~            	DJNZ .L0
 405+ 5DAE ~            .L1:
 406+ 5DAE ~            	EX DE,HL
 407+ 5DAE ~            	LD H,0
 408+ 5DAE ~            	LD A,(BLIT_TMP+0)
 409+ 5DAE ~            	LD L,A
 410+ 5DAE ~            	CALL HLx8
 411+ 5DAE ~            	ADD HL,DE
 412+ 5DAE ~            	LD DE,(TMP_STRUCT+4)
 413+ 5DAE ~            	ADD HL,DE
 414+ 5DAE ~            	LD (TMP_STRUCT+4),HL
 415+ 5DAE ~
 416+ 5DAE ~            	LD IY, .RET
 417+ 5DAE ~            	JP ENABLE_PAGE0
 418+ 5DAE ~            .RET:
 419+ 5DAE ~            	EI
 420+ 5DAE ~            	LD IX, TMP_STRUCT
 421+ 5DAE ~            	CALL SHIFT_MERGE_CHARACTER
 422+ 5DAE ~                JP COMMON_EXIT_CODE
 423+ 5DAE ~            ; *******************************************************************************************************
 424+ 5DAE               ENDIF
 425+ 5DAE
 426+ 5DAE               IF (1 == 1)
 427+ 5DAE              ; *******************************************************************************************************
 428+ 5DAE              ; function to handle CALL BLIT basic extension
 429+ 5DAE              ; rotates 1-bit character drawing horizontally with mask and character data and
 430+ 5DAE              ; fuses with background data and applies vertical shift too
 431+ 5DAE              ; in form without pointers
 432+ 5DAE              ; BLIT ( INT x,
 433+ 5DAE              ;		 INT y,
 434+ 5DAE              ;		 INT char_data_pointer,
 435+ 5DAE              ;		 INT mask_data_pointer,
 436+ 5DAE              ;		 INT width (in characters),
 437+ 5DAE              ;		 INT height (in characters),
 438+ 5DAE              ;		 INT background_pointer (top left),
 439+ 5DAE              ;		 INT background_width (in characters),
 440+ 5DAE              ; will put ram in page 0 also, page 1 is already there
 441+ 5DAE              BLIT:
 442+ 5DAE              	; opening (
 443+ 5DAE CD 88 67     	CALL CHKCHAR
 444+ 5DB1 28           	DB '('
 445+ 5DB2              	; get x coordinate
 446+ 5DB2 DD 21 2F 54  	LD IX, FRMQNT
 447+ 5DB6 CD 59 01     	CALL CALBAS
 448+ 5DB9 7B           	LD A, E
 449+ 5DBA E6 07        	AND 7
 450+ 5DBC 32 51 64     	LD (TMP_STRUCT+0), A
 451+ 5DBF CD A0 5D     	CALL DEdiv8
 452+ 5DC2 32 4D 64     	LD (BLIT_TMP+0),A
 453+ 5DC5              	; comma
 454+ 5DC5 CD 88 67     	CALL CHKCHAR
 455+ 5DC8 2C           	DB ','
 456+ 5DC9              	; get y coordinate
 457+ 5DC9 DD 21 2F 54  	LD IX, FRMQNT
 458+ 5DCD CD 59 01     	CALL CALBAS
 459+ 5DD0 7B           	LD A, E
 460+ 5DD1 E6 07        	AND 7
 461+ 5DD3 32 53 64     	LD (TMP_STRUCT+2), A
 462+ 5DD6 CD A0 5D     	CALL DEdiv8
 463+ 5DD9 32 4E 64     	LD (BLIT_TMP+1),A
 464+ 5DDC              	; comma
 465+ 5DDC CD 88 67     	CALL CHKCHAR
 466+ 5DDF 2C           	DB ','
 467+ 5DE0              	; get char data pointer
 468+ 5DE0 DD 21 2F 54  	LD IX, FRMQNT
 469+ 5DE4 CD 59 01     	CALL CALBAS
 470+ 5DE7 ED 53 5B 64  	LD (TMP_STRUCT+10), DE
 471+ 5DEB              	; comma
 472+ 5DEB CD 88 67     	CALL CHKCHAR
 473+ 5DEE 2C           	DB ','
 474+ 5DEF              	; get mask data pointer
 475+ 5DEF DD 21 2F 54  	LD IX, FRMQNT
 476+ 5DF3 CD 59 01     	CALL CALBAS
 477+ 5DF6 ED 53 59 64  	LD (TMP_STRUCT+8), DE
 478+ 5DFA              	; comma
 479+ 5DFA CD 88 67     	CALL CHKCHAR
 480+ 5DFD 2C           	DB ','
 481+ 5DFE              	; get width
 482+ 5DFE DD 21 2F 54  	LD IX, FRMQNT
 483+ 5E02 CD 59 01     	CALL CALBAS
 484+ 5E05 7B           	LD A, E
 485+ 5E06 32 5F 64     	LD (TMP_STRUCT+14), A
 486+ 5E09              	; comma
 487+ 5E09 CD 88 67     	CALL CHKCHAR
 488+ 5E0C 2C           	DB ','
 489+ 5E0D              	; get height
 490+ 5E0D DD 21 2F 54  	LD IX, FRMQNT
 491+ 5E11 CD 59 01     	CALL CALBAS
 492+ 5E14 7B           	LD A, E
 493+ 5E15 32 61 64     	LD (TMP_STRUCT+16), A
 494+ 5E18              	; comma
 495+ 5E18 CD 88 67     	CALL CHKCHAR
 496+ 5E1B 2C           	DB ','
 497+ 5E1C              	; get background pointer
 498+ 5E1C DD 21 2F 54  	LD IX, FRMQNT
 499+ 5E20 CD 59 01     	CALL CALBAS
 500+ 5E23 ED 53 55 64  	LD (TMP_STRUCT+4), DE
 501+ 5E27              	; comma
 502+ 5E27 CD 88 67     	CALL CHKCHAR
 503+ 5E2A 2C           	DB ','
 504+ 5E2B              	; get background width
 505+ 5E2B DD 21 2F 54  	LD IX, FRMQNT
 506+ 5E2F CD 59 01     	CALL CALBAS
 507+ 5E32 7B           	LD A, E
 508+ 5E33 32 4F 64     	LD (BLIT_TMP+2), A
 509+ 5E36              	; ending )
 510+ 5E36 CD 88 67     	CALL CHKCHAR
 511+ 5E39 29           	DB ')'
 512+ 5E3A
 513+ 5E3A E5           	PUSH HL ; save position in BASIC buffer
 514+ 5E3B
 515+ 5E3B              	; calculate char&mask add to value
 516+ 5E3B 26 00        	LD H, 0
 517+ 5E3D 3A 5F 64     	LD A, (TMP_STRUCT+14)
 518+ 5E40 6F           	LD L, A
 519+ 5E41 CD 75 66     	CALL HLx8
 520+ 5E44 22 5D 64     	LD (TMP_STRUCT+12), HL
 521+ 5E47              	; calculate background add to value
 522+ 5E47 26 00        	LD H, 0
 523+ 5E49 3A 4F 64     	LD A, (BLIT_TMP+2)
 524+ 5E4C 6F           	LD L, A
 525+ 5E4D CD 75 66     	CALL HLx8
 526+ 5E50 22 57 64     	LD (TMP_STRUCT+6), HL
 527+ 5E53              	; calculate pointer to background location
 528+ 5E53 21 00 00     	LD HL, 0
 529+ 5E56 3A 4E 64     	LD A,(BLIT_TMP+1)
 530+ 5E59 B7           	OR A
 531+ 5E5A 28 08        	JR Z, .L1
 532+ 5E5C 47           	LD B,A
 533+ 5E5D ED 5B 57 64  	LD DE,(TMP_STRUCT+6)
 534+ 5E61              .L0:
 535+ 5E61 19           	ADD HL, DE
 536+ 5E62 10 FD        	DJNZ .L0
 537+ 5E64              .L1:
 538+ 5E64 EB           	EX DE,HL
 539+ 5E65 26 00        	LD H,0
 540+ 5E67 3A 4D 64     	LD A,(BLIT_TMP+0)
 541+ 5E6A 6F           	LD L,A
 542+ 5E6B CD 75 66     	CALL HLx8
 543+ 5E6E 19           	ADD HL,DE
 544+ 5E6F ED 5B 55 64  	LD DE,(TMP_STRUCT+4)
 545+ 5E73 19           	ADD HL,DE
 546+ 5E74 22 55 64     	LD (TMP_STRUCT+4),HL
 547+ 5E77
 548+ 5E77 FD 21 7E 5E  	LD IY, .RET
 549+ 5E7B C3 39 67     	JP ENABLE_PAGE0
 550+ 5E7E              .RET:
 551+ 5E7E FB           	EI
 552+ 5E7F DD 21 51 64  	LD IX, TMP_STRUCT
 553+ 5E83 CD 0C 5D     	CALL SHIFT_MERGE_CHARACTER
 554+ 5E86
 555+ 5E86 D1               POP DE
 556+ 5E87 C1               POP BC
 557+ 5E88 CD B0 66         CALL RESTORE_PAGE_INFO
 558+ 5E8B AF           	XOR A
 559+ 5E8C E1           	POP HL
 560+ 5E8D C9           	RET
 561+ 5E8E              ; *******************************************************************************************************
 562+ 5E8E               ENDIF
# file closed: asm\BLIT.asm
 164  5E8E               ENDIF
 165  5E8E
 166  5E8E               IF (TILE_CMDS == 1)
 167  5E8E               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
   1+ 5E8E              ; *******************************************************************************************************
   2+ 5E8E              ; generic function to implement tiling
   3+ 5E8E              ; should be modified to call appropriate function for memory or vram
   4+ 5E8E              ; input IX=pointer to following structure
   5+ 5E8E              ; +00 tile_data_ptr
   6+ 5E8E              ; +02 tile_rows
   7+ 5E8E              ; +04 tile_columns
   8+ 5E8E              ; +06 destination_address
   9+ 5E8E              ; +08 dest_to_next_row_add_to_value
  10+ 5E8E              ; +10 num_horizontal_tiles
  11+ 5E8E              ; +12 num_vertical_tiles
  12+ 5E8E              ; modifies AF, BC, DE, HL
  13+ 5E8E              TILE:
  14+ 5E8E DD 6E 06     	LD L, (IX+6)
  15+ 5E91 DD 66 07     	LD H, (IX+7) ; destination address
  16+ 5E94 22 4D 64     	LD (TILETMP1), HL
  17+ 5E97 DD 46 0C     	LD B, (IX+12) ; vertical tile number
  18+ 5E9A              .L1:
  19+ 5E9A C5           	PUSH BC
  20+ 5E9B DD 6E 00     		LD L, (IX+0)
  21+ 5E9E DD 66 01     		LD H, (IX+1) ; tile address
  22+ 5EA1 22 4F 64     		LD (TILETMP2), HL
  23+ 5EA4 DD 46 02     		LD B, (IX+2) ; tile rows
  24+ 5EA7              .L2:
  25+ 5EA7 C5           		PUSH BC
  26+ 5EA8 CD 00 00     .CALL1:		CALL 0
  27+ 5EAB DD 46 0A     			LD B, (IX+10) ; horizontal tile num
  28+ 5EAE              .L3:
  29+ 5EAE C5           			PUSH BC
  30+ 5EAF 2A 4F 64     				LD HL, (TILETMP2)
  31+ 5EB2 DD 46 04     				LD B, (IX+4) ; tile columns
  32+ 5EB5              .L4:
  33+ 5EB5 C5           				PUSH BC
  34+ 5EB6              .CALL2:
  35+ 5EB6 CD 00 00     					CALL 0
  36+ 5EB9 C1           				POP BC
  37+ 5EBA 10 F9        				DJNZ .L4
  38+ 5EBC C1           			POP BC
  39+ 5EBD 10 EF        			DJNZ .L3
  40+ 5EBF 22 4F 64     			LD (TILETMP2), HL
  41+ 5EC2 2A 4D 64     			LD HL, (TILETMP1)
  42+ 5EC5 DD 5E 08     			LD E, (IX+8)
  43+ 5EC8 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
  44+ 5ECB 19           			ADD HL, DE
  45+ 5ECC 22 4D 64     			LD (TILETMP1), HL
  46+ 5ECF C1           		POP BC
  47+ 5ED0 10 D5        		DJNZ .L2
  48+ 5ED2 C1           	POP BC
  49+ 5ED3 10 C5        	DJNZ .L1
  50+ 5ED5 C9           	RET
  51+ 5ED6              ; *******************************************************************************************************
  52+ 5ED6
  53+ 5ED6               IF (0 == 1)
  54+ 5ED6 ~            ; *******************************************************************************************************
  55+ 5ED6 ~            ; same as TILERAM but for DEFUSR approach
  56+ 5ED6 ~            ; input IX=pointer to input array, real data from +2
  57+ 5ED6 ~            ; +02 = tile data pointer
  58+ 5ED6 ~            ; +04 = tile columns
  59+ 5ED6 ~            ; +06 = tile rows
  60+ 5ED6 ~            ; +08 = destination pointer
  61+ 5ED6 ~            ; +10 = destination columns
  62+ 5ED6 ~            ; +12 = destination rows
  63+ 5ED6 ~            ; +14 = destination begin column
  64+ 5ED6 ~            ; +16 = destination begin row
  65+ 5ED6 ~            ; +18 = number of tiles horizontally
  66+ 5ED6 ~            ; +20 = number of tiles vertically
  67+ 5ED6 ~            ; *******************************************************************************************************
  68+ 5ED6 ~            TILERAM_DEFUSR:
  69+ 5ED6 ~            	; tile data pointer
  70+ 5ED6 ~            	LD L,(IX+2)
  71+ 5ED6 ~            	LD H,(IX+3)
  72+ 5ED6 ~            	LD (TMP_STRUCT+0),HL
  73+ 5ED6 ~            	; tile columns
  74+ 5ED6 ~            	LD L,(IX+4)
  75+ 5ED6 ~            	LD H,(IX+5)
  76+ 5ED6 ~            	LD (TMP_STRUCT+4),HL
  77+ 5ED6 ~            	; tile rows
  78+ 5ED6 ~            	LD L,(IX+6)
  79+ 5ED6 ~            	LD H,(IX+7)
  80+ 5ED6 ~            	LD (TMP_STRUCT+2),HL
  81+ 5ED6 ~            	; destintion pointer
  82+ 5ED6 ~            	LD L,(IX+8)
  83+ 5ED6 ~            	LD H,(IX+9)
  84+ 5ED6 ~            	LD (TMP_STRUCT+6),HL
  85+ 5ED6 ~            	; destination columns
  86+ 5ED6 ~            	LD A,(IX+10)
  87+ 5ED6 ~            	LD (BLIT_TMP+0),A
  88+ 5ED6 ~            	; destination rows
  89+ 5ED6 ~            	LD A,(IX+12)
  90+ 5ED6 ~            	LD (BLIT_TMP+1),A
  91+ 5ED6 ~            	; destination begin column
  92+ 5ED6 ~            	LD A,(IX+14)
  93+ 5ED6 ~            	LD (BLIT_TMP+2),A
  94+ 5ED6 ~            	; destination begin row
  95+ 5ED6 ~            	LD A,(IX+16)
  96+ 5ED6 ~            	LD (BLIT_TMP+3),A
  97+ 5ED6 ~            	; number of tiles horizontally
  98+ 5ED6 ~            	LD L,(IX+18)
  99+ 5ED6 ~            	LD H,(IX+19)
 100+ 5ED6 ~            	LD (TMP_STRUCT+10),HL
 101+ 5ED6 ~            	; number of tiles vertically
 102+ 5ED6 ~            	LD L,(IX+20)
 103+ 5ED6 ~            	LD H,(IX+21)
 104+ 5ED6 ~            	LD (TMP_STRUCT+12),HL
 105+ 5ED6 ~             IF (BASIC_EXTENSION == 1) ; otherwise we just continue with code below
 106+ 5ED6 ~            	JP TILERAM.COMMON
 107+ 5ED6 ~             ENDIF
 108+ 5ED6               ENDIF
 109+ 5ED6
 110+ 5ED6              ; *******************************************************************************************************
 111+ 5ED6              ; function to handle CALL TILERAM basic extension
 112+ 5ED6              ; fills memory with tiles
 113+ 5ED6              ; TILERAM ( INT tile_data_pointer,
 114+ 5ED6              ;			INT tile_columns,
 115+ 5ED6              ;			INT tile_rows,
 116+ 5ED6              ;			INT destination_pointer,
 117+ 5ED6              ;			INT destination_columns,
 118+ 5ED6              ;			INT destination_rows,
 119+ 5ED6              ;			INT destination_begin_column,
 120+ 5ED6              ;			INT destination_begin_row,
 121+ 5ED6              ;			INT number_of_tiles_horizontally,
 122+ 5ED6              ;			INT	number_of_tiles_vertically )
 123+ 5ED6              ; will put ram in page 0 also, page 1 is already there
 124+ 5ED6              TILERAM:
 125+ 5ED6               IF (1 == 1)
 126+ 5ED6              	; opening (
 127+ 5ED6 CD 88 67     	CALL CHKCHAR
 128+ 5ED9 28           	DB '('
 129+ 5EDA              	; get tile data pointer coordinate
 130+ 5EDA DD 21 2F 54  	LD IX, FRMQNT
 131+ 5EDE CD 59 01     	CALL CALBAS
 132+ 5EE1 ED 53 51 64  	LD (TMP_STRUCT+0), DE
 133+ 5EE5              	; comma
 134+ 5EE5 CD 88 67     	CALL CHKCHAR
 135+ 5EE8 2C           	DB ','
 136+ 5EE9              	; get tile columns
 137+ 5EE9 DD 21 2F 54  	LD IX, FRMQNT
 138+ 5EED CD 59 01     	CALL CALBAS
 139+ 5EF0 ED 53 55 64  	LD (TMP_STRUCT+4), DE
 140+ 5EF4              	; comma
 141+ 5EF4 CD 88 67     	CALL CHKCHAR
 142+ 5EF7 2C           	DB ','
 143+ 5EF8              	; get tile columns
 144+ 5EF8 DD 21 2F 54  	LD IX, FRMQNT
 145+ 5EFC CD 59 01     	CALL CALBAS
 146+ 5EFF ED 53 53 64  	LD (TMP_STRUCT+2), DE
 147+ 5F03              	; comma
 148+ 5F03 CD 88 67     	CALL CHKCHAR
 149+ 5F06 2C           	DB ','
 150+ 5F07              	; get destintion pointer
 151+ 5F07 DD 21 2F 54  	LD IX, FRMQNT
 152+ 5F0B CD 59 01     	CALL CALBAS
 153+ 5F0E ED 53 57 64  	LD (TMP_STRUCT+6), DE
 154+ 5F12              	; comma
 155+ 5F12 CD 88 67     	CALL CHKCHAR
 156+ 5F15 2C           	DB ','
 157+ 5F16              	; get destination columns
 158+ 5F16 DD 21 2F 54  	LD IX, FRMQNT
 159+ 5F1A CD 59 01     	CALL CALBAS
 160+ 5F1D 7B           	LD A, E
 161+ 5F1E 32 4D 64     	LD (BLIT_TMP+0), A
 162+ 5F21              	; comma
 163+ 5F21 CD 88 67     	CALL CHKCHAR
 164+ 5F24 2C           	DB ','
 165+ 5F25              	; get destination rows
 166+ 5F25 DD 21 2F 54  	LD IX, FRMQNT
 167+ 5F29 CD 59 01     	CALL CALBAS
 168+ 5F2C 7B           	LD A, E
 169+ 5F2D 32 4E 64     	LD (BLIT_TMP+1), A
 170+ 5F30              	; comma
 171+ 5F30 CD 88 67     	CALL CHKCHAR
 172+ 5F33 2C           	DB ','
 173+ 5F34              	; get destination begin column
 174+ 5F34 DD 21 2F 54  	LD IX, FRMQNT
 175+ 5F38 CD 59 01     	CALL CALBAS
 176+ 5F3B 7B           	LD A, E
 177+ 5F3C 32 4F 64     	LD (BLIT_TMP+2), A
 178+ 5F3F              	; comma
 179+ 5F3F CD 88 67     	CALL CHKCHAR
 180+ 5F42 2C           	DB ','
 181+ 5F43              	; get destination begin row
 182+ 5F43 DD 21 2F 54  	LD IX, FRMQNT
 183+ 5F47 CD 59 01     	CALL CALBAS
 184+ 5F4A 7B           	LD A, E
 185+ 5F4B 32 50 64     	LD (BLIT_TMP+3), A
 186+ 5F4E              	; comma
 187+ 5F4E CD 88 67     	CALL CHKCHAR
 188+ 5F51 2C           	DB ','
 189+ 5F52              	; get number of tiles horizontally
 190+ 5F52 DD 21 2F 54  	LD IX, FRMQNT
 191+ 5F56 CD 59 01     	CALL CALBAS
 192+ 5F59 ED 53 5B 64  	LD (TMP_STRUCT+10), DE
 193+ 5F5D              	; comma
 194+ 5F5D CD 88 67     	CALL CHKCHAR
 195+ 5F60 2C           	DB ','
 196+ 5F61              	; get number of tiles vertically
 197+ 5F61 DD 21 2F 54  	LD IX, FRMQNT
 198+ 5F65 CD 59 01     	CALL CALBAS
 199+ 5F68 ED 53 5D 64  	LD (TMP_STRUCT+12), DE
 200+ 5F6C              	; ending )
 201+ 5F6C CD 88 67     	CALL CHKCHAR
 202+ 5F6F 29           	DB ')'
 203+ 5F70               ENDIF
 204+ 5F70              .COMMON:
 205+ 5F70 E5           	PUSH HL ; save position in BASIC buffer
 206+ 5F71
 207+ 5F71              	; calculate destination add to value
 208+ 5F71 26 00        	LD H, 0
 209+ 5F73 3A 4D 64     	LD A, (BLIT_TMP+0)
 210+ 5F76 6F           	LD L, A
 211+ 5F77 CD 75 66     	CALL HLx8
 212+ 5F7A 22 59 64     	LD (TMP_STRUCT+8), HL
 213+ 5F7D              	; calculate pointer to background location
 214+ 5F7D 21 00 00     	LD HL, 0
 215+ 5F80 3A 50 64     	LD A,(BLIT_TMP+3)
 216+ 5F83 B7           	OR A
 217+ 5F84 28 08        	JR Z, .L1
 218+ 5F86 47           	LD B,A
 219+ 5F87 ED 5B 59 64  	LD DE,(TMP_STRUCT+8)
 220+ 5F8B              .L0:
 221+ 5F8B 19           	ADD HL, DE
 222+ 5F8C 10 FD        	DJNZ .L0
 223+ 5F8E              .L1:
 224+ 5F8E EB           	EX DE,HL
 225+ 5F8F 26 00        	LD H,0
 226+ 5F91 3A 4F 64     	LD A,(BLIT_TMP+2)
 227+ 5F94 6F           	LD L,A
 228+ 5F95 CD 75 66     	CALL HLx8
 229+ 5F98 19           	ADD HL,DE
 230+ 5F99 ED 5B 57 64  	LD DE,(TMP_STRUCT+6)
 231+ 5F9D 19           	ADD HL,DE
 232+ 5F9E 22 57 64     	LD (TMP_STRUCT+6),HL
 233+ 5FA1 FD 21 A8 5F  	LD IY, .RET
 234+ 5FA5 C3 39 67     	JP ENABLE_PAGE0
 235+ 5FA8              .RET:
 236+ 5FA8 FB           	EI
 237+ 5FA9              	; set RAM functions to call
 238+ 5FA9 21 BF 5F     	LD HL, .TILECOPY
 239+ 5FAC 22 B7 5E     	LD (TILE.CALL2+1), HL
 240+ 5FAF 21 D0 5F     	LD HL, .SETDESTROW
 241+ 5FB2 22 A9 5E     	LD (TILE.CALL1+1), HL
 242+ 5FB5 DD 21 51 64  	LD IX,TMP_STRUCT
 243+ 5FB9 CD 8E 5E     	CALL TILE
 244+ 5FBC C3 4F 66     	JP COMMON_EXIT_CODE
 245+ 5FBF              .TILECOPY:
 246+ 5FBF ED A0       > LDI
 246+ 5FC1 ED A0       > LDI
 246+ 5FC3 ED A0       > LDI
 246+ 5FC5 ED A0       > LDI
 246+ 5FC7 ED A0       > LDI
 246+ 5FC9 ED A0       > LDI
 246+ 5FCB ED A0       > LDI
 246+ 5FCD ED A0       > LDI
 247+ 5FCF C9           	RET
 248+ 5FD0              .SETDESTROW:
 249+ 5FD0 ED 5B 4D 64  	LD DE, (TILETMP1)
 250+ 5FD4 C9           	RET
 251+ 5FD5              ; *******************************************************************************************************
 252+ 5FD5
 253+ 5FD5               IF (0 == 1)
 254+ 5FD5 ~            ; *******************************************************************************************************
 255+ 5FD5 ~            ; same as TILEVRM but for DEFUSR approach
 256+ 5FD5 ~            ; input IX=pointer to input array, real data from +2
 257+ 5FD5 ~            ; +02 = tile data pointer
 258+ 5FD5 ~            ; +04 = tile columns
 259+ 5FD5 ~            ; +06 = tile rows
 260+ 5FD5 ~            ; +08 = destination begin column
 261+ 5FD5 ~            ; +10 = destination begin row
 262+ 5FD5 ~            ; +12 = number of tiles horizontally
 263+ 5FD5 ~            ; +14 = number of tiles vertically
 264+ 5FD5 ~            ; *******************************************************************************************************
 265+ 5FD5 ~            TILEVRM_DEFUSR:
 266+ 5FD5 ~            	; tile data pointer
 267+ 5FD5 ~            	LD L,(IX+2)
 268+ 5FD5 ~            	LD H,(IX+3)
 269+ 5FD5 ~            	LD (TMP_STRUCT+0),HL
 270+ 5FD5 ~            	; tile columns
 271+ 5FD5 ~            	LD L,(IX+4)
 272+ 5FD5 ~            	LD H,(IX+5)
 273+ 5FD5 ~            	LD (TMP_STRUCT+4),HL
 274+ 5FD5 ~            	; tile rows
 275+ 5FD5 ~            	LD L,(IX+6)
 276+ 5FD5 ~            	LD H,(IX+7)
 277+ 5FD5 ~            	LD (TMP_STRUCT+2),HL
 278+ 5FD5 ~            	; destination begin column
 279+ 5FD5 ~            	LD A,(IX+8)
 280+ 5FD5 ~            	LD (BLIT_TMP+2),A
 281+ 5FD5 ~            	; destination begin row
 282+ 5FD5 ~            	LD A,(IX+10)
 283+ 5FD5 ~            	LD (BLIT_TMP+3),A
 284+ 5FD5 ~            	; number of tiles horizontally
 285+ 5FD5 ~            	LD L,(IX+12)
 286+ 5FD5 ~            	LD H,(IX+13)
 287+ 5FD5 ~            	LD (TMP_STRUCT+10),HL
 288+ 5FD5 ~            	; number of tiles vertically
 289+ 5FD5 ~            	LD L,(IX+14)
 290+ 5FD5 ~            	LD H,(IX+15)
 291+ 5FD5 ~            	LD (TMP_STRUCT+12),HL
 292+ 5FD5 ~             IF (BASIC_EXTENSION == 1) ; otherwise we just continue with code below
 293+ 5FD5 ~            	JP TILEVRM.COMMON
 294+ 5FD5 ~             ENDIF
 295+ 5FD5               ENDIF
 296+ 5FD5
 297+ 5FD5              ; *******************************************************************************************************
 298+ 5FD5              ; function to handle CALL TILEVRM basic extension
 299+ 5FD5              ; fills vram with tiles
 300+ 5FD5              ; TILEVRM ( INT tile_data_pointer,
 301+ 5FD5              ;			INT tile_columns,
 302+ 5FD5              ;			INT tile_rows,
 303+ 5FD5              ;			INT destination_begin_column,
 304+ 5FD5              ;			INT destination_begin_row,
 305+ 5FD5              ;			INT number_of_tiles_horizontally,
 306+ 5FD5              ;			INT	number_of_tiles_vertically )
 307+ 5FD5              ; will put ram in page 0 also, page 1 is already there
 308+ 5FD5              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
 309+ 5FD5              TILEVRM:
 310+ 5FD5               IF (1 == 1)
 311+ 5FD5              	; opening (
 312+ 5FD5 CD 88 67     	CALL CHKCHAR
 313+ 5FD8 28           	DB '('
 314+ 5FD9              	; get tile data pointer coordinate
 315+ 5FD9 DD 21 2F 54  	LD IX, FRMQNT
 316+ 5FDD CD 59 01     	CALL CALBAS
 317+ 5FE0 ED 53 51 64  	LD (TMP_STRUCT+0), DE
 318+ 5FE4              	; comma
 319+ 5FE4 CD 88 67     	CALL CHKCHAR
 320+ 5FE7 2C           	DB ','
 321+ 5FE8              	; get tile columns
 322+ 5FE8 DD 21 2F 54  	LD IX, FRMQNT
 323+ 5FEC CD 59 01     	CALL CALBAS
 324+ 5FEF ED 53 55 64  	LD (TMP_STRUCT+4), DE
 325+ 5FF3              	; comma
 326+ 5FF3 CD 88 67     	CALL CHKCHAR
 327+ 5FF6 2C           	DB ','
 328+ 5FF7              	; get tile columns
 329+ 5FF7 DD 21 2F 54  	LD IX, FRMQNT
 330+ 5FFB CD 59 01     	CALL CALBAS
 331+ 5FFE ED 53 53 64  	LD (TMP_STRUCT+2), DE
 332+ 6002              	; comma
 333+ 6002 CD 88 67     	CALL CHKCHAR
 334+ 6005 2C           	DB ','
 335+ 6006              	; get destination begin column
 336+ 6006 DD 21 2F 54  	LD IX, FRMQNT
 337+ 600A CD 59 01     	CALL CALBAS
 338+ 600D 7B           	LD A, E
 339+ 600E 32 4F 64     	LD (BLIT_TMP+2), A
 340+ 6011              	; comma
 341+ 6011 CD 88 67     	CALL CHKCHAR
 342+ 6014 2C           	DB ','
 343+ 6015              	; get destination begin row
 344+ 6015 DD 21 2F 54  	LD IX, FRMQNT
 345+ 6019 CD 59 01     	CALL CALBAS
 346+ 601C 7B           	LD A, E
 347+ 601D 32 50 64     	LD (BLIT_TMP+3), A
 348+ 6020              	; comma
 349+ 6020 CD 88 67     	CALL CHKCHAR
 350+ 6023 2C           	DB ','
 351+ 6024              	; get number of tiles horizontally
 352+ 6024 DD 21 2F 54  	LD IX, FRMQNT
 353+ 6028 CD 59 01     	CALL CALBAS
 354+ 602B ED 53 5B 64  	LD (TMP_STRUCT+10), DE
 355+ 602F              	; comma
 356+ 602F CD 88 67     	CALL CHKCHAR
 357+ 6032 2C           	DB ','
 358+ 6033              	; get number of tiles vertically
 359+ 6033 DD 21 2F 54  	LD IX, FRMQNT
 360+ 6037 CD 59 01     	CALL CALBAS
 361+ 603A ED 53 5D 64  	LD (TMP_STRUCT+12), DE
 362+ 603E              	; ending )
 363+ 603E CD 88 67     	CALL CHKCHAR
 364+ 6041 29           	DB ')'
 365+ 6042               ENDIF
 366+ 6042
 367+ 6042              .COMMON:
 368+ 6042 E5           	PUSH HL ; save position in BASIC buffer
 369+ 6043
 370+ 6043              	; calculate destination add to value
 371+ 6043 21 00 01     	LD HL, 256
 372+ 6046 22 59 64     	LD (TMP_STRUCT+8), HL
 373+ 6049              	; calculate pointer to background location
 374+ 6049 3A 50 64     	LD A,(BLIT_TMP+3)
 375+ 604C 67           	LD H,A
 376+ 604D 2E 00        	LD L,0
 377+ 604F EB           	EX DE,HL
 378+ 6050 26 00        	LD H,0
 379+ 6052 3A 4F 64     	LD A,(BLIT_TMP+2)
 380+ 6055 6F           	LD L,A
 381+ 6056 CD 75 66     	CALL HLx8
 382+ 6059 19           	ADD HL,DE
 383+ 605A ED 5B CB F3  	LD DE,(GRPCGP)
 384+ 605E 19           	ADD HL,DE
 385+ 605F 22 57 64     	LD (TMP_STRUCT+6),HL
 386+ 6062 FD 21 69 60  	LD IY, .RET
 387+ 6066 C3 39 67     	JP ENABLE_PAGE0
 388+ 6069              .RET:
 389+ 6069 FB           	EI
 390+ 606A              	; set RAM functions to call
 391+ 606A 21 80 60     	LD HL, .TILECOPY
 392+ 606D 22 B7 5E     	LD (TILE.CALL2+1), HL
 393+ 6070 21 86 60     	LD HL, .SETDESTROW
 394+ 6073 22 A9 5E     	LD (TILE.CALL1+1), HL
 395+ 6076 DD 21 51 64  	LD IX,TMP_STRUCT
 396+ 607A CD 8E 5E     	CALL TILE
 397+ 607D C3 4F 66     	JP COMMON_EXIT_CODE
 398+ 6080              .TILECOPY:
 399+ 6080 01 98 08     	LD BC, #0898
 400+ 6083 C3 6D 66     	JP BBYTECOPY_NO_C
 401+ 6086              .SETDESTROW:
 402+ 6086 2A 4D 64     	LD HL, (TILETMP1)
 403+ 6089 F3           	DI
 404+ 608A CD 56 66     	CALL SETWRT_LOCAL_WRITE
 405+ 608D FB           	EI
 406+ 608E C9           	RET
 407+ 608F              ; *******************************************************************************************************
 408+ 608F
# file closed: asm\TILE.asm
 168  608F               ENDIF
 169  608F
 170  608F               IF (COLL_CMD == 1)
 171  608F               INCLUDE "COLLISION.asm"
# file opened: asm\COLLISION.asm
   1+ 608F              ; generic collision checking routines
   2+ 608F              ; in BASIC we use rectangle structure array DIM R%(7,n) of the format
   3+ 608F              ; R%(0,n) is active flag, <>0 active / 0 skipped in checks
   4+ 608F              ; R%(1,n) is either upper left x coordinate or sprite id (0-31) depending on R(7,n)
   5+ 608F              ; R%(2,n) is either upper left y coordinate or unused depending on R(7,n)
   6+ 608F              ; R%(3,n) x offset where rectangle begins
   7+ 608F              ; R%(4,n) y offset where rectangle begins
   8+ 608F              ; R%(5,n) is width
   9+ 608F              ; R%(6,n) is height
  10+ 608F              ; R%(7,0) is type, 0=generic where R%(1,0) contains x coordinate
  11+ 608F              ;                  <>0 sprite where R%(1,0) contains sprite id
  12+ 608F              ; for type sprite, upper left coordinates are taken from sprite attribute array
  13+ 608F
  14+ 608F              ; ************************************************************************************************
  15+ 608F              ; quick test if HL<=DE<=HL+BC
  16+ 608F              ; input BC=width, DE=x, HL=min
  17+ 608F              ; if not true flag C set
  18+ 608F              ; modifies AF
  19+ 608F              GENERIC_INNER_CHECK:
  20+ 608F E5               PUSH HL
  21+ 6090 D5               PUSH DE
  22+ 6091 EB               EX DE,HL
  23+ 6092 A7               AND A
  24+ 6093 ED 52            SBC HL, DE
  25+ 6095 FA A3 60         JP M, .GENERIC_INNER_CHECK_NOT
  26+ 6098 A7               AND A
  27+ 6099 ED 42            SBC HL, BC
  28+ 609B 28 03            JR Z, .L2
  29+ 609D F2 A3 60         JP P, .GENERIC_INNER_CHECK_NOT
  30+ 60A0              .L2:
  31+ 60A0 A7               AND A
  32+ 60A1 18 01            JR .EXIT
  33+ 60A3              .GENERIC_INNER_CHECK_NOT:
  34+ 60A3 37               SCF
  35+ 60A4              .EXIT:
  36+ 60A4 D1               POP DE
  37+ 60A5 E1               POP HL
  38+ 60A6 C9               RET
  39+ 60A7              ; ************************************************************************************************
  40+ 60A7
  41+ 60A7              ; ************************************************************************************************
  42+ 60A7              ; function to check if rectangles are overlapping
  43+ 60A7              ; input IX=IY=pointer to struct
  44+ 60A7              ;  +00 active flag
  45+ 60A7              ;  +02 x coordinate
  46+ 60A7              ;  +04 y coordinate
  47+ 60A7              ;  +06 x offset where rectangle begins
  48+ 60A7              ;  +08 y offset where rectangle begins
  49+ 60A7              ;  +10 width
  50+ 60A7              ;  +12 height
  51+ 60A7              ; where IY is used to read +2 and +4, and IX to read +6, +8, +10 and +12
  52+ 60A7              ; this is a hack to allow location being taken from sprite attributes table
  53+ 60A7              ; input TMP_STRUCT data
  54+ 60A7              ;  +00 x coordinate
  55+ 60A7              ;  +02 y coordinate
  56+ 60A7              ;  +04 width
  57+ 60A7              ;  +06 height
  58+ 60A7              ; returns CF=1 if not overlapping, CF=0 if overlapping
  59+ 60A7              RECTANGLE_OVERLAP_CHECK:
  60+ 60A7                  ; first check which rectangle is higher
  61+ 60A7 DD 6E 0C         LD L,(IX+12)
  62+ 60AA DD 66 0D         LD H,(IX+13)
  63+ 60AD ED 5B 57 64      LD DE,(TMP_STRUCT+6)
  64+ 60B1 A7               AND A
  65+ 60B2 ED 52            SBC HL,DE
  66+ 60B4 FD 6E 04         LD L,(IY+4)
  67+ 60B7 FD 66 05         LD H,(IY+5)
  68+ 60BA DD 5E 08         LD E,(IX+8)
  69+ 60BD DD 56 09         LD D,(IX+9)
  70+ 60C0 FA E0 60         JP M,.L1
  71+ 60C3                  ; equally high or IX defined one higher
  72+ 60C3                  ; check upper boundary
  73+ 60C3 19               ADD HL,DE
  74+ 60C4 ED 5B 53 64      LD DE,(TMP_STRUCT+2)
  75+ 60C8 DD 4E 0C         LD C,(IX+12)
  76+ 60CB DD 46 0D         LD B,(IX+13)
  77+ 60CE CD 8F 60         CALL GENERIC_INNER_CHECK
  78+ 60D1 30 29            JR NC,.INSIDE
  79+ 60D3                  ; check lower boundary
  80+ 60D3 E5               PUSH HL
  81+ 60D4 2A 57 64         LD HL,(TMP_STRUCT+6)
  82+ 60D7 19               ADD HL,DE
  83+ 60D8 EB               EX DE,HL
  84+ 60D9 E1               POP HL
  85+ 60DA CD 8F 60         CALL GENERIC_INNER_CHECK
  86+ 60DD 30 1D            JR NC,.INSIDE
  87+ 60DF C9               RET ; not overlapping
  88+ 60E0              .L1:
  89+ 60E0                  ; rectangle defined in TMP_STRUCT is higher
  90+ 60E0 19               ADD HL,DE
  91+ 60E1 EB               EX DE,HL
  92+ 60E2 2A 53 64         LD HL,(TMP_STRUCT+2)
  93+ 60E5 ED 4B 57 64      LD BC,(TMP_STRUCT+6)
  94+ 60E9 CD 8F 60         CALL GENERIC_INNER_CHECK
  95+ 60EC 30 0E            JR NC,.INSIDE
  96+ 60EE E5               PUSH HL
  97+ 60EF DD 6E 0C         LD L,(IX+12)
  98+ 60F2 DD 66 0D         LD H,(IX+13)
  99+ 60F5 19               ADD HL,DE
 100+ 60F6 EB               EX DE,HL
 101+ 60F7 E1               POP HL
 102+ 60F8 CD 8F 60         CALL GENERIC_INNER_CHECK
 103+ 60FB D8               RET C
 104+ 60FC              .INSIDE:
 105+ 60FC                  ; check x coordinate
 106+ 60FC                  ; first check which rectangle is wider
 107+ 60FC DD 6E 0A         LD L,(IX+10)
 108+ 60FF DD 66 0B         LD H,(IX+11)
 109+ 6102 ED 5B 55 64      LD DE,(TMP_STRUCT+4)
 110+ 6106 A7               AND A
 111+ 6107 ED 52            SBC HL,DE
 112+ 6109 FD 6E 02         LD L,(IY+2)
 113+ 610C FD 66 03         LD H,(IY+3)
 114+ 610F DD 5E 06         LD E,(IX+6)
 115+ 6112 DD 56 07         LD D,(IX+7)
 116+ 6115 FA 31 61         JP M,.L2
 117+ 6118                  ; equally wide or IX defined one wider
 118+ 6118                  ; check left boundary
 119+ 6118 19               ADD HL,DE
 120+ 6119 ED 5B 51 64      LD DE,(TMP_STRUCT+0)
 121+ 611D DD 4E 0A         LD C,(IX+10)
 122+ 6120 DD 46 0B         LD B,(IX+11)
 123+ 6123 CD 8F 60         CALL GENERIC_INNER_CHECK
 124+ 6126 D0               RET NC ; overlap
 125+ 6127                  ; check right boundary
 126+ 6127 E5               PUSH HL
 127+ 6128 2A 55 64         LD HL,(TMP_STRUCT+4)
 128+ 612B 19               ADD HL,DE
 129+ 612C EB               EX DE,HL
 130+ 612D E1               POP HL
 131+ 612E C3 8F 60         JP GENERIC_INNER_CHECK ; CF and result set by fn call
 132+ 6131              .L2:
 133+ 6131                  ; rectangle defined in TMP_STRUCT is higher
 134+ 6131 19               ADD HL,DE
 135+ 6132 EB               EX DE,HL
 136+ 6133 2A 51 64         LD HL,(TMP_STRUCT+0)
 137+ 6136 ED 4B 55 64      LD BC,(TMP_STRUCT+4)
 138+ 613A CD 8F 60         CALL GENERIC_INNER_CHECK
 139+ 613D D0               RET NC ; overlap
 140+ 613E E5               PUSH HL
 141+ 613F DD 6E 0A         LD L,(IX+10)
 142+ 6142 DD 66 0B         LD H,(IX+11)
 143+ 6145 19               ADD HL,DE
 144+ 6146 EB               EX DE,HL
 145+ 6147 E1               POP HL
 146+ 6148 C3 8F 60         JP GENERIC_INNER_CHECK
 147+ 614B              ; ************************************************************************************************
 148+ 614B
 149+ 614B              ; ************************************************************************************************
 150+ 614B              ; function tries to find rectangle overlap and returns an index if found
 151+ 614B              ; input TMP_STRUCT data
 152+ 614B              ;  +00 x coordinate
 153+ 614B              ;  +02 y coordinate
 154+ 614B              ;  +04 width
 155+ 614B              ;  +06 height
 156+ 614B              ;  +08 number of items in a list, described under RECTANGLE_OVERLAP_CHECK
 157+ 614B              ;  +09 pointer to first element of R%(7,n)
 158+ 614B              ;  +11 pointer to INT result variable
 159+ 614B              ; returns CF=1 if not overlapping
 160+ 614B              ; returns A=list index and CF=0 if overlapping
 161+ 614B              FIND_OVERLAP:
 162+ 614B 3A 59 64         LD A,(TMP_STRUCT+8)
 163+ 614E 47               LD B,A
 164+ 614F DD 2A 5A 64      LD IX,(TMP_STRUCT+9)
 165+ 6153              .L1:
 166+ 6153 C5               PUSH BC
 167+ 6154                  ; check active flag
 168+ 6154 DD 7E 00         LD A,(IX)
 169+ 6157 DD B6 01         OR (IX+1)
 170+ 615A 28 18            JR Z,.NEXT
 171+ 615C                  ; check type
 172+ 615C DD 7E 0E         LD A,(IX+14)
 173+ 615F DD B6 0F         OR (IX+15)
 174+ 6162 20 1A            JR NZ,.L2
 175+ 6164 DD E5            PUSH IX
 176+ 6166 FD E1            POP IY
 177+ 6168              .L3:
 178+ 6168 CD A7 60         CALL RECTANGLE_OVERLAP_CHECK
 179+ 616B 38 07            JR C,.NEXT
 180+ 616D                  ; found
 181+ 616D C1               POP BC
 182+ 616E 3A 59 64         LD A,(TMP_STRUCT+8)
 183+ 6171 90               SUB B
 184+ 6172 A7               AND A
 185+ 6173 C9               RET
 186+ 6174              .NEXT:
 187+ 6174 11 10 00         LD DE,16
 188+ 6177 DD 19            ADD IX,DE
 189+ 6179 C1               POP BC
 190+ 617A 10 D7            DJNZ .L1
 191+ 617C 37               SCF
 192+ 617D C9               RET
 193+ 617E              .L2:
 194+ 617E                  ; sprite, need to build a temporary data struct since x and y values are inversed
 195+ 617E                  ; at TMP_STRUCT+13
 196+ 617E DD 7E 02         LD A,(IX+2) ; sprite ID
 197+ 6181 CD 90 4D         CALL GETnthSPRATTR
 198+ 6184 FD 21 5C 64      LD IY,TMP_STRUCT+11
 199+ 6188 7E               LD A,(HL)
 200+ 6189 FD 77 04         LD (IY+4),A
 201+ 618C 23               INC HL
 202+ 618D 7E               LD A,(HL)
 203+ 618E FD 77 05         LD (IY+5),A
 204+ 6191 23               INC HL
 205+ 6192 7E               LD A,(HL)
 206+ 6193 FD 77 02         LD (IY+2),A
 207+ 6196 23               INC HL
 208+ 6197 7E               LD A,(HL)
 209+ 6198 FD 77 03         LD (IY+3),A
 210+ 619B 18 CB            JR .L3
 211+ 619D              ; ************************************************************************************************
 212+ 619D
 213+ 619D               IF (1 == 1)
 214+ 619D              ; ************************************************************************************************
 215+ 619D              ; function to handle CALL COLL basic extension
 216+ 619D              ; checks for collision between player and other rectangles
 217+ 619D              ; COLL ( INT result variable,
 218+ 619D              ;	     INT player x value,
 219+ 619D              ;	     INT player y value,
 220+ 619D              ;	     INT player width,
 221+ 619D              ;	     INT player height,
 222+ 619D              ;	     INT number of items in a list,
 223+ 619D              ;		 INT[6][n] rectangle struct )
 224+ 619D              ; will fill result variable with index or -1 if no collision
 225+ 619D              ; rectangle struct described under RECTANGLE_OVERLAP_CHECK
 226+ 619D              COLL:
 227+ 619D              	; opening (
 228+ 619D CD 88 67     	CALL CHKCHAR
 229+ 61A0 28           	DB '('
 230+ 61A1              	; get address of result variable
 231+ 61A1 DD 21 A4 5E  	LD IX, PTRGET
 232+ 61A5 CD 59 01     	CALL CALBAS
 233+ 61A8 ED 53 5C 64  	LD (TMP_STRUCT+11),DE
 234+ 61AC              	; comma
 235+ 61AC CD 88 67     	CALL CHKCHAR
 236+ 61AF 2C           	DB ','
 237+ 61B0              	; get x
 238+ 61B0 DD 21 2F 54  	LD IX, FRMQNT
 239+ 61B4 CD 59 01     	CALL CALBAS
 240+ 61B7 ED 53 51 64  	LD (TMP_STRUCT+0),DE
 241+ 61BB              	; comma
 242+ 61BB CD 88 67     	CALL CHKCHAR
 243+ 61BE 2C           	DB ','
 244+ 61BF              	; get y
 245+ 61BF DD 21 2F 54  	LD IX, FRMQNT
 246+ 61C3 CD 59 01     	CALL CALBAS
 247+ 61C6 ED 53 53 64  	LD (TMP_STRUCT+2),DE
 248+ 61CA              	; comma
 249+ 61CA CD 88 67     	CALL CHKCHAR
 250+ 61CD 2C           	DB ','
 251+ 61CE              	; get width
 252+ 61CE DD 21 2F 54  	LD IX, FRMQNT
 253+ 61D2 CD 59 01     	CALL CALBAS
 254+ 61D5 ED 53 55 64  	LD (TMP_STRUCT+4),DE
 255+ 61D9              	; comma
 256+ 61D9 CD 88 67     	CALL CHKCHAR
 257+ 61DC 2C           	DB ','
 258+ 61DD              	; get height
 259+ 61DD DD 21 2F 54  	LD IX, FRMQNT
 260+ 61E1 CD 59 01     	CALL CALBAS
 261+ 61E4 ED 53 57 64  	LD (TMP_STRUCT+6),DE
 262+ 61E8              	; comma
 263+ 61E8 CD 88 67     	CALL CHKCHAR
 264+ 61EB 2C           	DB ','
 265+ 61EC              	; get number of items in a list
 266+ 61EC DD 21 1C 52  	LD IX, GETBYT
 267+ 61F0 CD 59 01     	CALL CALBAS
 268+ 61F3 32 59 64     	LD (TMP_STRUCT+8),A
 269+ 61F6              	; comma
 270+ 61F6 CD 88 67     	CALL CHKCHAR
 271+ 61F9 2C           	DB ','
 272+ 61FA              	; get address of rectangle structure array DIM R%(7,n)
 273+ 61FA 3A 59 64     	LD A,(TMP_STRUCT+8)
 274+ 61FD 5F               LD E,A
 275+ 61FE 3E 02            LD A,2
 276+ 6200 47           	LD B,A
 277+ 6201 16 07        	LD D,7
 278+ 6203 CD ED 67     	CALL GET_BASIC_ARRAY_DATA_POINTER
 279+ 6206 ED 43 5A 64  	LD (TMP_STRUCT+9),BC
 280+ 620A              	; ending )
 281+ 620A CD 88 67     	CALL CHKCHAR
 282+ 620D 29           	DB ')'
 283+ 620E
 284+ 620E E5               PUSH HL
 285+ 620F CD 4B 61         CALL FIND_OVERLAP
 286+ 6212 2A 5C 64         LD HL,(TMP_STRUCT+11)
 287+ 6215 38 06            JR C,.NOTFOUND
 288+ 6217 77               LD (HL),A
 289+ 6218 23               INC HL
 290+ 6219 36 00            LD (HL),0
 291+ 621B E1               POP HL
 292+ 621C C9               RET
 293+ 621D              .NOTFOUND:
 294+ 621D 36 FF            LD (HL),#FF
 295+ 621F 23               INC HL
 296+ 6220 36 FF            LD (HL),#FF
 297+ 6222 E1               POP HL
 298+ 6223 C9               RET
 299+ 6224              ; ************************************************************************************************
 300+ 6224               ENDIF
 301+ 6224
 302+ 6224               IF (0 == 1)
 303+ 6224 ~            ; *******************************************************************************************************
 304+ 6224 ~            ; same as COLL but for DEFUSR approach
 305+ 6224 ~            ; input IX=pointer to input array, real data from +2
 306+ 6224 ~            ; +02 = pointer to result variable
 307+ 6224 ~            ; +04 = player X
 308+ 6224 ~            ; +06 = player Y
 309+ 6224 ~            ; +08 = player width
 310+ 6224 ~            ; +10 = player height
 311+ 6224 ~            ; +12 = number of list items
 312+ 6224 ~            ; +14 = pointer to list of collidable objects
 313+ 6224 ~            COLL_DEFUSR:
 314+ 6224 ~                PUSH IX
 315+ 6224 ~                POP HL
 316+ 6224 ~                .4 INC HL ; skip over to player x
 317+ 6224 ~                LD DE,TMP_STRUCT
 318+ 6224 ~                LD BC,9
 319+ 6224 ~                LDIR ; copy over x,y,w,h,list item number
 320+ 6224 ~                LD A,(IX+14)
 321+ 6224 ~                LD (TMP_STRUCT+9),A
 322+ 6224 ~                LD A,(IX+15)
 323+ 6224 ~                LD (TMP_STRUCT+10),A ; address to collidable objects array
 324+ 6224 ~                LD A,(IX+2)
 325+ 6224 ~                LD (TMP_STRUCT+11),A
 326+ 6224 ~                LD A,(IX+3)
 327+ 6224 ~                LD (TMP_STRUCT+12),A ; address to results variable
 328+ 6224 ~                PUSH IX
 329+ 6224 ~                CALL FIND_OVERLAP
 330+ 6224 ~                POP IX
 331+ 6224 ~                LD L,(IX+2)
 332+ 6224 ~                LD H,(IX+3)
 333+ 6224 ~                JR C,.NOTFOUND
 334+ 6224 ~                LD (HL),A
 335+ 6224 ~                INC HL
 336+ 6224 ~                LD (HL),0
 337+ 6224 ~            .EXIT:
 338+ 6224 ~                XOR A ; success
 339+ 6224 ~                RET
 340+ 6224 ~            .NOTFOUND:
 341+ 6224 ~                LD (HL),#FF
 342+ 6224 ~                INC HL
 343+ 6224 ~                LD (HL),#FF
 344+ 6224 ~                JR .EXIT
 345+ 6224 ~            ; *******************************************************************************************************
 346+ 6224               ENDIF
 347+ 6224
# file closed: asm\COLLISION.asm
 172  6224               ENDIF
 173  6224
 174  6224               IF (DECOMP_CMDS == 1)
 175  6224               INCLUDE "decomp.asm"
# file opened: asm\decomp.asm
   1+ 6224              ; -----------------------------------------------------------------------------
   2+ 6224              ; ZX0 decoder by Einar Saukas & Urusergi
   3+ 6224              ; "Standard" version (68 bytes only)
   4+ 6224              ; -----------------------------------------------------------------------------
   5+ 6224              ; Parameters:
   6+ 6224              ;   HL: source address (compressed data)
   7+ 6224              ;   DE: destination address (decompressing)
   8+ 6224              ; -----------------------------------------------------------------------------
   9+ 6224
  10+ 6224              dzx0_standard:
  11+ 6224 01 FF FF             ld      bc, $ffff               ; preserve default offset 1
  12+ 6227 C5                   push    bc
  13+ 6228 03                   inc     bc
  14+ 6229 3E 80                ld      a, $80
  15+ 622B              dzx0s_literals:
  16+ 622B CD 5B 62             call    dzx0s_elias             ; obtain length
  17+ 622E              dzx0_ldir_1:
  18+ 622E ED B0                ldir                            ; copy literals
  19+ 6230 00                   nop                             ; placeholder for call
  20+ 6231 87                   add     a, a                    ; copy from last offset or new offset?
  21+ 6232 38 0E                jr      c, dzx0s_new_offset
  22+ 6234 CD 5B 62             call    dzx0s_elias             ; obtain length
  23+ 6237              dzx0s_copy:
  24+ 6237 E3                   ex      (sp), hl                ; preserve source, restore offset
  25+ 6238 E5                   push    hl                      ; preserve offset
  26+ 6239 19                   add     hl, de                  ; calculate destination - offset
  27+ 623A              dzx0_ldir_2:
  28+ 623A ED B0                ldir                            ; copy from offset
  29+ 623C 00                   nop                             ; placeholder for call
  30+ 623D E1                   pop     hl                      ; restore offset
  31+ 623E E3                   ex      (sp), hl                ; preserve offset, restore source
  32+ 623F 87                   add     a, a                    ; copy from literals or new offset?
  33+ 6240 30 E9                jr      nc, dzx0s_literals
  34+ 6242              dzx0s_new_offset:
  35+ 6242 C1                   pop     bc                      ; discard last offset
  36+ 6243 0E FE                ld      c, $fe                  ; prepare negative offset
  37+ 6245 CD 5C 62             call    dzx0s_elias_loop        ; obtain offset MSB
  38+ 6248 0C                   inc     c
  39+ 6249 C8                   ret     z                       ; check end marker
  40+ 624A 41                   ld      b, c
  41+ 624B 4E                   ld      c, (hl)                 ; obtain offset LSB
  42+ 624C 23                   inc     hl
  43+ 624D CB 18                rr      b                       ; last offset bit becomes first length bit
  44+ 624F CB 19                rr      c
  45+ 6251 C5                   push    bc                      ; preserve new offset
  46+ 6252 01 01 00             ld      bc, 1                   ; obtain length
  47+ 6255 D4 63 62             call    nc, dzx0s_elias_backtrack
  48+ 6258 03                   inc     bc
  49+ 6259 18 DC                jr      dzx0s_copy
  50+ 625B              dzx0s_elias:
  51+ 625B 0C                   inc     c                       ; interlaced Elias gamma coding
  52+ 625C              dzx0s_elias_loop:
  53+ 625C 87                   add     a, a
  54+ 625D 20 03                jr      nz, dzx0s_elias_skip
  55+ 625F 7E                   ld      a, (hl)                 ; load another group of 8 bits
  56+ 6260 23                   inc     hl
  57+ 6261 17                   rla
  58+ 6262              dzx0s_elias_skip:
  59+ 6262 D8                   ret     c
  60+ 6263              dzx0s_elias_backtrack:
  61+ 6263 87                   add     a, a
  62+ 6264 CB 11                rl      c
  63+ 6266 CB 10                rl      b
  64+ 6268 18 F2                jr      dzx0s_elias_loop
  65+ 626A              ; -----------------------------------------------------------------------------
  66+ 626A
  67+ 626A              ; *******************************************************************************************************
  68+ 626A              ; helper function for VRAM unpack to save AF prior to calling copy to VRAM fn
  69+ 626A              ; also simulates register states as if LDIR was called
  70+ 626A              LDIR_TO_VRAM:
  71+ 626A F5                   PUSH AF ; save AF used by algorithm
  72+ 626B D5                   PUSH DE
  73+ 626C C5                   PUSH BC
  74+ 626D CD 4D 5A             CALL VRAM_LDIRVM
  75+ 6270 C1                   POP BC
  76+ 6271 EB                   EX DE,HL
  77+ 6272 E1                   POP HL
  78+ 6273 09                   ADD HL,BC
  79+ 6274 EB                   EX DE,HL
  80+ 6275 01 00 00             LD BC,0
  81+ 6278 F1                   POP AF
  82+ 6279 C9                   RET
  83+ 627A              ; *******************************************************************************************************
  84+ 627A
  85+ 627A              ; *******************************************************************************************************
  86+ 627A              ; helper function to get a byte from VRAM address at HL and place it at DE also in VRAM
  87+ 627A              VPOKE_VPEEK:
  88+ 627A F3                   DI
  89+ 627B CD 61 66             CALL SETWRT_LOCAL_READ
  90+ 627E E3                   EX (SP),HL
  91+ 627F E3                   EX (SP),HL
  92+ 6280 DB 98                IN A,(#98)
  93+ 6282                      ;IN A,(#98) ; WHY IS THIS NEEDED ?
  94+ 6282 F5                   PUSH AF
  95+ 6283 EB                   EX DE,HL
  96+ 6284 CD 56 66             CALL SETWRT_LOCAL_WRITE
  97+ 6287 E3                   EX (SP),HL
  98+ 6288 E3                   EX (SP),HL
  99+ 6289 EB                   EX DE,HL
 100+ 628A F1                   POP AF
 101+ 628B D3 98                OUT (#98),A
 102+ 628D FB                   EI
 103+ 628E C9                   RET
 104+ 628F              ; *******************************************************************************************************
 105+ 628F
 106+ 628F              ; *******************************************************************************************************
 107+ 628F              ; helper fn VRAM variant of LDIR
 108+ 628F              ; input HL = source, DE = destination, BC = count
 109+ 628F              VRAM_LDIR:
 110+ 628F F5                   PUSH AF
 111+ 6290              _L0:
 112+ 6290 CD 7A 62             CALL VPOKE_VPEEK
 113+ 6293 23                   INC HL
 114+ 6294 13                   INC DE
 115+ 6295 0B                   DEC BC
 116+ 6296 78                   LD A, B
 117+ 6297 B1                   OR C
 118+ 6298 20 F6                JR NZ, _L0
 119+ 629A F1                   POP AF
 120+ 629B C9                   RET
 121+ 629C              ; *******************************************************************************************************
 122+ 629C
 123+ 629C               IF (1 == 1)
 124+ 629C              ; *******************************************************************************************************
 125+ 629C              ; function to handle CALL VUNPACK basic extension
 126+ 629C              ; _VUNPACK ( INT source,
 127+ 629C              ;			 INT destination )
 128+ 629C              ; will put ram in page 0 also, page 1 is already there
 129+ 629C              ; *******************************************************************************************************
 130+ 629C              VUNPACK:
 131+ 629C 3E CD            LD A, #CD ; CALL
 132+ 629E 32 2E 62         LD (dzx0_ldir_1), A
 133+ 62A1 32 3A 62         LD (dzx0_ldir_2), A
 134+ 62A4 11 6A 62         LD DE, LDIR_TO_VRAM
 135+ 62A7 ED 53 2F 62      LD (dzx0_ldir_1 + 1), DE
 136+ 62AB 11 8F 62         LD DE, VRAM_LDIR
 137+ 62AE ED 53 3B 62      LD (dzx0_ldir_2 + 1), DE
 138+ 62B2 18 12            JR UNPACK_COMMON
 139+ 62B4              ; function to handle CALL UNPACK basic extension
 140+ 62B4              ; _UNPACK ( INT source,
 141+ 62B4              ;			INT destination )
 142+ 62B4              ; will put ram in page 0 also, page 1 is already there
 143+ 62B4              UNPACK:
 144+ 62B4 11 ED B0         LD DE, #B0ED ; LDIR
 145+ 62B7 ED 53 2E 62      LD (dzx0_ldir_1), DE
 146+ 62BB ED 53 3A 62      LD (dzx0_ldir_2), DE
 147+ 62BF AF               XOR A ; NOP
 148+ 62C0 32 30 62         LD (dzx0_ldir_1 + 2), A
 149+ 62C3 32 3C 62         LD (dzx0_ldir_2 + 2), A
 150+ 62C6              UNPACK_COMMON:
 151+ 62C6              	; opening (
 152+ 62C6 CD 88 67     	CALL CHKCHAR
 153+ 62C9 28           	DB '('
 154+ 62CA              	; get source address
 155+ 62CA DD 21 2F 54  	LD IX, FRMQNT
 156+ 62CE CD 59 01     	CALL CALBAS
 157+ 62D1 D5           	PUSH DE
 158+ 62D2              	; comma
 159+ 62D2 CD 88 67     	CALL CHKCHAR
 160+ 62D5 2C           	DB ','
 161+ 62D6              	; get destination address
 162+ 62D6 DD 21 2F 54  	LD IX, FRMQNT
 163+ 62DA CD 59 01     	CALL CALBAS
 164+ 62DD D5           	PUSH DE
 165+ 62DE              	; ending )
 166+ 62DE CD 88 67     	CALL CHKCHAR
 167+ 62E1 29           	DB ')'
 168+ 62E2
 169+ 62E2              	; save position
 170+ 62E2 E5           	PUSH HL
 171+ 62E3 DD E1        	POP IX
 172+ 62E5
 173+ 62E5 D1           	POP DE ; destination
 174+ 62E6 E1           	POP HL ; source
 175+ 62E7 D9           	EXX
 176+ 62E8              	; enable page 0
 177+ 62E8 FD 21 EF 62  	LD IY, .RET
 178+ 62EC C3 39 67     	JP ENABLE_PAGE0
 179+ 62EF              .RET:
 180+ 62EF FB           	EI
 181+ 62F0 D9           	EXX
 182+ 62F1 CD 24 62     	CALL dzx0_standard
 183+ 62F4 C3 4C 66             JP COMMON_EXIT_CODE_IX
 184+ 62F7              ; *******************************************************************************************************
 185+ 62F7               ENDIF
 186+ 62F7
 187+ 62F7               IF (0 == 1)
 188+ 62F7 ~            ; *******************************************************************************************************
 189+ 62F7 ~            ; same as VUNPACK but for DEFUSR approach
 190+ 62F7 ~            ; input IX=pointer to input array, real data from +2
 191+ 62F7 ~            ; +2 = source address
 192+ 62F7 ~            ; +4 = destination address
 193+ 62F7 ~            ; *******************************************************************************************************
 194+ 62F7 ~            VUNPACK_DEFUSR:
 195+ 62F7 ~                LD A, #CD ; CALL
 196+ 62F7 ~                LD (dzx0_ldir_1), A
 197+ 62F7 ~                LD (dzx0_ldir_2), A
 198+ 62F7 ~                LD HL, LDIR_TO_VRAM
 199+ 62F7 ~                LD (dzx0_ldir_1 + 1), HL
 200+ 62F7 ~                LD HL, VRAM_LDIR
 201+ 62F7 ~                LD (dzx0_ldir_2 + 1), HL
 202+ 62F7 ~                JR UNPACK_DEFUSR_COMMON
 203+ 62F7 ~            ; same as UNPACK but for DEFUSR approach
 204+ 62F7 ~            ; input IX=pointer to input array, real data from +2
 205+ 62F7 ~            ; +2 = source address
 206+ 62F7 ~            ; +4 = destination address
 207+ 62F7 ~            UNPACK_DEFUSR:
 208+ 62F7 ~                LD HL, #B0ED ; LDIR
 209+ 62F7 ~                LD (dzx0_ldir_1), HL
 210+ 62F7 ~                LD (dzx0_ldir_2), HL
 211+ 62F7 ~                XOR A ; NOP
 212+ 62F7 ~                LD (dzx0_ldir_1 + 2), A
 213+ 62F7 ~                LD (dzx0_ldir_2 + 2), A
 214+ 62F7 ~            UNPACK_DEFUSR_COMMON:
 215+ 62F7 ~                ; enable page 0
 216+ 62F7 ~                LD IY, .RET
 217+ 62F7 ~                JP ENABLE_PAGE0
 218+ 62F7 ~            .RET:
 219+ 62F7 ~                EI
 220+ 62F7 ~                LD L,(IX+2)
 221+ 62F7 ~                LD H,(IX+3)
 222+ 62F7 ~                LD E,(IX+4)
 223+ 62F7 ~                LD D,(IX+5)
 224+ 62F7 ~                CALL dzx0_standard
 225+ 62F7 ~                JP COMMON_EXIT_CODE
 226+ 62F7 ~            ; *******************************************************************************************************
 227+ 62F7               ENDIF
# file closed: asm\decomp.asm
 176  62F7               ENDIF
 177  62F7
 178  62F7               IF (DLOAD_CMD == 1)
 179  62F7               INCLUDE "DLOAD.asm"
# file opened: asm\DLOAD.asm
   1+ 62F7              BDOS_SETDTA     EQU #1A
   2+ 62F7              BDOS_OPEN       EQU #0F
   3+ 62F7              BDOS_CLOSE      EQU #10
   4+ 62F7              BDOS_RDBLK      EQU #27
   5+ 62F7
   6+ 62F7              ; *******************************************************************************************************
   7+ 62F7              ; function processes file name
   8+ 62F7              ; filenames supported are D:FILENAME.EXT, FILENAME.EXT, D:FILENAME, FILENAME
   9+ 62F7              ; FCB 0 will be zeroed out
  10+ 62F7              ; FCB 0 will be populated with drive info 0=default or 1-8 for drives A-H
  11+ 62F7              ; FCB 0 will be populated with file name
  12+ 62F7              ; input HL=pointer to expression
  13+ 62F7              ; input B=length
  14+ 62F7              ; returns CF=1 if bad filename
  15+ 62F7              DLOAD_PROCESS_FILENAME:
  16+ 62F7                  ; check for zero size
  17+ 62F7 78               LD A,B
  18+ 62F8 B7               OR A
  19+ 62F9 28 6B            JR Z, .BADFILENAME
  20+ 62FB                  ; check for more than 2+8+1+3=14
  21+ 62FB FE 0F            CP 15
  22+ 62FD 30 67            JR NC, .BADFILENAME
  23+ 62FF                  ; check if more than 2 letters
  24+ 62FF FE 03            CP 3
  25+ 6301 38 1C            JR C, .L7 ; no drive
  26+ 6303                  ; check for : at proper place
  27+ 6303 5E               LD E, (HL)
  28+ 6304 23               INC HL
  29+ 6305 7E               LD A, (HL)
  30+ 6306 FE 3A            CP ':'
  31+ 6308 20 14            JR NZ, .L1
  32+ 630A                  ; so we have : , check for letters A-H
  33+ 630A 7B               LD A,E
  34+ 630B CD C1 67         CALL UPPER
  35+ 630E D6 41            SUB 'A'
  36+ 6310 FE 09            CP 9
  37+ 6312 30 52            JR NC, .BADFILENAME
  38+ 6314 23               INC HL
  39+ 6315 05               DEC B ; consume two characters
  40+ 6316 05               DEC B
  41+ 6317              .L2:
  42+ 6317 ED 5B 53 F3      LD DE, (FCB0)
  43+ 631B 12               LD (DE), A
  44+ 631C 18 04            JR .PROCESS_FILENAME
  45+ 631E              .L1:
  46+ 631E                  ; no drive specified
  47+ 631E 2B               DEC HL
  48+ 631F              .L7:
  49+ 631F AF               XOR A
  50+ 6320 18 F5            JR .L2
  51+ 6322              .PROCESS_FILENAME:
  52+ 6322                  ; HL is pointing to rest of the name
  53+ 6322 13               INC DE ; 8-character filename location, needs to be padded with blanks
  54+ 6323 0E 08            LD C,8 ; filename length
  55+ 6325              .L4:
  56+ 6325 CD 68 63         CALL .GETCHAR
  57+ 6328 FE 2E            CP '.'
  58+ 632A 28 31            JR Z, .L6 ; if dot, fill rest with blanks
  59+ 632C 12               LD (DE),A
  60+ 632D 13               INC DE
  61+ 632E 0D               DEC C
  62+ 632F 20 F4            JR NZ, .L4
  63+ 6331                  ; so we cleared filename part
  64+ 6331 78               LD A,B ; no more letters. just fill extension with blanks
  65+ 6332 B7               OR A
  66+ 6333 28 07            JR Z, .L8
  67+ 6335 CD 68 63         CALL .GETCHAR ; here we must have . for a valid name
  68+ 6338 FE 2E            CP '.'
  69+ 633A 20 2A            JR NZ, .BADFILENAME
  70+ 633C              .L8:
  71+ 633C 0E 03            LD C,3
  72+ 633E              .L5:
  73+ 633E CD 68 63         CALL .GETCHAR
  74+ 6341 12               LD (DE),A
  75+ 6342 13               INC DE
  76+ 6343 0D               DEC C
  77+ 6344 20 F8            JR NZ, .L5
  78+ 6346 78               LD A,B ; nothing must be left in buffer
  79+ 6347 B7               OR A
  80+ 6348 20 1C            JR NZ, .BADFILENAME
  81+ 634A                  ; file name correct, now zero out the rest of FCB 0
  82+ 634A 2A 53 F3         LD HL,(FCB0)
  83+ 634D 11 0C 00         LD DE,12
  84+ 6350 19               ADD HL,DE
  85+ 6351 36 00            LD (HL),0
  86+ 6353 54               LD D,H
  87+ 6354 5D               LD E,L
  88+ 6355 13               INC DE
  89+ 6356 01 18 00         LD BC,37-12-1
  90+ 6359 ED B0            LDIR
  91+ 635B AF               XOR A ; clear carry flag
  92+ 635C C9               RET
  93+ 635D              .L6:
  94+ 635D 3E 20            LD A,' '
  95+ 635F              .L9:
  96+ 635F 12               LD (DE),A
  97+ 6360 13               INC DE
  98+ 6361 0D               DEC C
  99+ 6362 20 FB            JR NZ, .L9
 100+ 6364 18 D6            JR .L8
 101+ 6366              .BADFILENAME:
 102+ 6366 37               SCF
 103+ 6367 C9               RET
 104+ 6368              .GETCHAR: ; gets a character, returns blank if we read past input
 105+ 6368 78               LD A,B
 106+ 6369 B7               OR A
 107+ 636A 28 07            JR Z, .BLANK
 108+ 636C 7E               LD A,(HL)
 109+ 636D CD C1 67         CALL UPPER
 110+ 6370 23               INC HL
 111+ 6371 05               DEC B
 112+ 6372 C9               RET
 113+ 6373              .BLANK:
 114+ 6373 3E 20            LD A,' '
 115+ 6375 C9               RET
 116+ 6376              ; *******************************************************************************************************
 117+ 6376
 118+ 6376              ; *******************************************************************************************************
 119+ 6376              ; function sets disk buffer from NULBUF
 120+ 6376              ; input none
 121+ 6376              ; returns ZF!=1 on error
 122+ 6376              DLOAD_SETDTA:
 123+ 6376 ED 5B 62 F8      LD DE,(NULBUF)
 124+ 637A 0E 1A            LD C, BDOS_SETDTA
 125+ 637C 18 24            JR BDOS_CALL
 126+ 637E              ; *******************************************************************************************************
 127+ 637E
 128+ 637E              ; *******************************************************************************************************
 129+ 637E              ; function opens a file using FCB 0
 130+ 637E              ; input none
 131+ 637E              ; returns ZF!=1 on error
 132+ 637E              DLOAD_OPENFILE:
 133+ 637E ED 5B 53 F3      LD DE,(FCB0)
 134+ 6382 0E 0F            LD C, BDOS_OPEN
 135+ 6384 18 1C            JR BDOS_CALL
 136+ 6386              ; *******************************************************************************************************
 137+ 6386
 138+ 6386              ; *******************************************************************************************************
 139+ 6386              ; function makes a file seek and sets record size to 1 byte
 140+ 6386              ; input none
 141+ 6386              ; output node
 142+ 6386              DLOAD_SEEK:
 143+ 6386 2A 51 64         LD HL,(TMP_STRUCT)
 144+ 6389 DD 2A 53 F3      LD IX,(FCB0)
 145+ 638D DD 75 21         LD (IX+33),L
 146+ 6390 DD 74 22         LD (IX+34),H
 147+ 6393 DD 36 0E 01      LD (IX+14),1
 148+ 6397 DD 36 0F 00      LD (IX+15),0
 149+ 639B C9               RET
 150+ 639C              ; *******************************************************************************************************
 151+ 639C
 152+ 639C              ; *******************************************************************************************************
 153+ 639C              ; function reads a number of bytes from a file using FCB 0 to (NULBUF) buffer
 154+ 639C              ; input HL=number of bytes to read
 155+ 639C              ; returns HL=number of bytes read
 156+ 639C              ; returns ZF!=1 on error
 157+ 639C              DLOAD_READ:
 158+ 639C ED 5B 53 F3      LD DE,(FCB0)
 159+ 63A0 0E 27            LD C,BDOS_RDBLK
 160+ 63A2              BDOS_CALL:
 161+ 63A2 CD 7D F3         CALL BDOS
 162+ 63A5 B7               OR A
 163+ 63A6 C9               RET
 164+ 63A7              ; *******************************************************************************************************
 165+ 63A7
 166+ 63A7              ; *******************************************************************************************************
 167+ 63A7              ; function closes a file FCB 0
 168+ 63A7              ; input none
 169+ 63A7              ; returns ZF!=1 on error
 170+ 63A7              DLOAD_CLOSE:
 171+ 63A7 AF               XOR A
 172+ 63A8 ED 5B 53 F3      LD DE,(FCB0)
 173+ 63AC 0E 10            LD C,BDOS_CLOSE
 174+ 63AE 18 F2            JR BDOS_CALL
 175+ 63B0              ; *******************************************************************************************************
 176+ 63B0
 177+ 63B0              ; *******************************************************************************************************
 178+ 63B0              ; function copies data from (NULBUF) to destination, enables RAM in page 0
 179+ 63B0              ; input BC=number of bytes to copy
 180+ 63B0              ; output none
 181+ 63B0              DLOAD_TRANSFERBLOCK:
 182+ 63B0 D9               EXX ; save BC
 183+ 63B1              	; enable page 0
 184+ 63B1 FD 21 B8 63  	LD IY, .RET
 185+ 63B5 C3 39 67     	JP ENABLE_PAGE0
 186+ 63B8              .RET:
 187+ 63B8 FB           	EI
 188+ 63B9 D9               EXX
 189+ 63BA ED 5B 53 64      LD DE,(TMP_STRUCT+2)
 190+ 63BE 2A 62 F8         LD HL,(NULBUF)
 191+ 63C1 ED B0        	LDIR
 192+ 63C3 ED 53 53 64      LD (TMP_STRUCT+2),DE
 193+ 63C7 D1               POP DE
 194+ 63C8 C1               POP BC
 195+ 63C9 C3 B0 66         JP RESTORE_PAGE_INFO
 196+ 63CC              ; *******************************************************************************************************
 197+ 63CC
 198+ 63CC              ; *******************************************************************************************************
 199+ 63CC              ; function opens and loads a file in FCB 0
 200+ 63CC              ; file name needs to be already set in FCB 0
 201+ 63CC              ; input none
 202+ 63CC              ; returns ZF!=1 on error
 203+ 63CC              DLOAD_LOADFILE:
 204+ 63CC CD 76 63         CALL DLOAD_SETDTA
 205+ 63CF CD 7E 63         CALL DLOAD_OPENFILE
 206+ 63D2 C0               RET NZ
 207+ 63D3 CD 86 63         CALL DLOAD_SEEK
 208+ 63D6 ED 4B 55 64      LD BC,(TMP_STRUCT+4)
 209+ 63DA              .L1:
 210+ 63DA 78               LD A,B
 211+ 63DB B7               OR A
 212+ 63DC 28 12            JR Z,.REST
 213+ 63DE 05               DEC B
 214+ 63DF 21 00 01         LD HL,256
 215+ 63E2              .L2:
 216+ 63E2 C5               PUSH BC
 217+ 63E3 E5               PUSH HL
 218+ 63E4 CD 9C 63         CALL DLOAD_READ
 219+ 63E7 C1               POP BC
 220+ 63E8 20 10            JR NZ,.ERRREAD
 221+ 63EA CD B0 63         CALL DLOAD_TRANSFERBLOCK
 222+ 63ED C1               POP BC
 223+ 63EE 18 EA            JR .L1
 224+ 63F0              .REST:
 225+ 63F0 79               LD A,C
 226+ 63F1 B7               OR A
 227+ 63F2 28 07            JR Z,.EXIT
 228+ 63F4 26 00            LD H,0
 229+ 63F6 69               LD L,C
 230+ 63F7 4C               LD C,H
 231+ 63F8 18 E8            JR .L2
 232+ 63FA              .ERRREAD:
 233+ 63FA C1               POP BC
 234+ 63FB              .EXIT:
 235+ 63FB F5               PUSH AF
 236+ 63FC CD A7 63         CALL DLOAD_CLOSE
 237+ 63FF F1               POP AF
 238+ 6400 C9               RET
 239+ 6401              ; *******************************************************************************************************
 240+ 6401
 241+ 6401               IF (1 == 1)
 242+ 6401
 243+ 6401              ; *******************************************************************************************************
 244+ 6401              ; function to handle CALL DLOAD basic extension
 245+ 6401              ; _DLOAD ( STRING filename,
 246+ 6401              ;		   INT offset,
 247+ 6401              ;		   INT destination,
 248+ 6401              ;          INT size )
 249+ 6401              ; will put ram in page 0 also, page 1 is already there
 250+ 6401              DLOAD:
 251+ 6401              	; opening (
 252+ 6401 CD 88 67     	CALL CHKCHAR
 253+ 6404 28           	DB '('
 254+ 6405 CD D4 67         CALL EVALTXTPARAM
 255+ 6408 E5               PUSH HL
 256+ 6409 CD CA 67         CALL GETSTRPNT
 257+ 640C CD F7 62         CALL DLOAD_PROCESS_FILENAME
 258+ 640F DA 9C 67         JP C, BAD_FILENAME
 259+ 6412 E1               POP HL
 260+ 6413              	; comma
 261+ 6413 CD 88 67     	CALL CHKCHAR
 262+ 6416 2C           	DB ','
 263+ 6417              	; get offset
 264+ 6417 DD 21 2F 54  	LD IX, FRMQNT
 265+ 641B CD 59 01     	CALL CALBAS
 266+ 641E ED 53 51 64  	LD (TMP_STRUCT), DE
 267+ 6422              	; comma
 268+ 6422 CD 88 67     	CALL CHKCHAR
 269+ 6425 2C           	DB ','
 270+ 6426              	; get destination
 271+ 6426 DD 21 2F 54  	LD IX, FRMQNT
 272+ 642A CD 59 01     	CALL CALBAS
 273+ 642D ED 53 53 64  	LD (TMP_STRUCT+2), DE
 274+ 6431              	; comma
 275+ 6431 CD 88 67     	CALL CHKCHAR
 276+ 6434 2C           	DB ','
 277+ 6435              	; get size
 278+ 6435 DD 21 2F 54  	LD IX, FRMQNT
 279+ 6439 CD 59 01     	CALL CALBAS
 280+ 643C ED 53 55 64  	LD (TMP_STRUCT+4), DE
 281+ 6440              	; ending )
 282+ 6440 CD 88 67     	CALL CHKCHAR
 283+ 6443 29           	DB ')'
 284+ 6444
 285+ 6444 E5               PUSH HL
 286+ 6445 CD CC 63         CALL DLOAD_LOADFILE
 287+ 6448 C2 A0 67         JP NZ, DISKIOERR
 288+ 644B E1               POP HL
 289+ 644C C9               RET
 290+ 644D              ; *******************************************************************************************************
 291+ 644D
 292+ 644D               ENDIF
 293+ 644D
 294+ 644D               IF (0 == 1)
 295+ 644D ~            ; *******************************************************************************************************
 296+ 644D ~            ; same as DLOAD but for DEFUSR approach
 297+ 644D ~            ; input IX=pointer to input array, real data from +2
 298+ 644D ~            ; +2 = string pointer
 299+ 644D ~            ; +4 = offset
 300+ 644D ~            ; +6 = destination
 301+ 644D ~            ; +8 = size
 302+ 644D ~            ; output A=0 on success
 303+ 644D ~            ; *******************************************************************************************************
 304+ 644D ~            DLOAD_DEFUSR:
 305+ 644D ~                LD L,(IX+2)
 306+ 644D ~                LD H,(IX+3)
 307+ 644D ~                LD B,(HL) ; string length
 308+ 644D ~                INC HL
 309+ 644D ~                LD E,(HL)
 310+ 644D ~                INC HL
 311+ 644D ~                LD D,(HL)
 312+ 644D ~                EX DE,HL ; pointer to ASCIIZ text
 313+ 644D ~                CALL DLOAD_PROCESS_FILENAME
 314+ 644D ~                JR C,.ERR ; exit on error
 315+ 644D ~                LD L,(IX+4)
 316+ 644D ~                LD H,(IX+5)
 317+ 644D ~                LD (TMP_STRUCT),HL ; offset
 318+ 644D ~                LD L,(IX+6)
 319+ 644D ~                LD H,(IX+7)
 320+ 644D ~                LD (TMP_STRUCT+2),HL ; destination
 321+ 644D ~                LD L,(IX+8)
 322+ 644D ~                LD H,(IX+9)
 323+ 644D ~                LD (TMP_STRUCT+4),HL ; size
 324+ 644D ~                CALL DLOAD_LOADFILE
 325+ 644D ~                JR NZ,.ERR
 326+ 644D ~                XOR A
 327+ 644D ~                RET
 328+ 644D ~            .ERR:
 329+ 644D ~                LD A,1
 330+ 644D ~                RET
 331+ 644D ~            ; *******************************************************************************************************
 332+ 644D ~
 333+ 644D               ENDIF
 334+ 644D
# file closed: asm\DLOAD.asm
 180  644D               ENDIF
 181  644D
 182  644D               IF (0 == 1)
 183  644D ~             INCLUDE "DEFUSR.asm"
 184  644D               ENDIF
 185  644D
 186  644D              ; temp variables for various fuctions
 187  644D              ; name historically from usage by BLIT, but since then
 188  644D              BLIT_TMP:
 189  644D              TILETMP1:
 190  644D              BLIT_TMP1:
 191  644D 00 00         DW 0
 192  644F              TILETMP2:
 193  644F              BLIT_TMP2:
 194  644F 00 00         DW 0
 195  6451              TMP_STRUCT:
 196  6451 00 00 00...   DS 17
 197  6462
 198  6462               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 199  6462              VRAM_UPDATE_IN_PROGRESS:
 200  6462 00            DB 0
 201  6463               ENDIF
 202  6463
 203  6463              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 204  6463              ; per starting letter, if no commands with this letter, NULL value
 205  6463              CMDS:
 206  6463 B4 65        	DW CMDS_A ; always present due to ARTINFO
 207  6465               IF (BLIT_CMDS + BOX_CMDS > 0) && (1 == 1)
 208  6465 69 65            DW CMDS_B ; B
 209  6467               ELSE
 210  6467 ~            	DW 0
 211  6467               ENDIF
 212  6467               IF (COLL_CMD == 1) && (1 == 1)
 213  6467 9C 65        	DW CMDS_C ;
 214  6469               ELSE
 215  6469 ~                DW 0 ; C
 216  6469               ENDIF
 217  6469               IF (DLOAD_CMD > 0) && (1 == 1)
 218  6469 AC 65            DW CMDS_D ; D
 219  646B               ELSE
 220  646B ~            	DW 0
 221  646B               ENDIF
 222  646B 00 00            DW 0 ; E
 223  646D               IF (VRAM_CMDS + RAM_CMDS > 0) && (1 == 1)
 224  646D E3 64            DW CMDS_F; F
 225  646F               ELSE
 226  646F ~            	DW 0
 227  646F               ENDIF
 228  646F               IF (GENCAL_CMD > 0) && (1 == 1)
 229  646F F5 64            DW CMDS_G; G
 230  6471               ELSE
 231  6471 ~            	DW 0
 232  6471               ENDIF
 233  6471 00 00            DW 0 ; H
 234  6473 00 00            DW 0 ; I
 235  6475 00 00            DW 0 ; J
 236  6477 00 00            DW 0 ; K
 237  6479 00 00            DW 0 ; L
 238  647B               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0) && (1 == 1)
 239  647B 97 64            DW CMDS_M ; M
 240  647D               ELSE
 241  647D ~            	DW 0
 242  647D               ENDIF
 243  647D 00 00            DW 0 ; N
 244  647F 00 00            DW 0 ; O
 245  6481 00 00            DW 0 ; P
 246  6483 00 00            DW 0 ; Q
 247  6485 00 00            DW 0 ; R
 248  6487               IF (SOUND_CMDS + SPRITE_CMDS > 0) && (1 == 1)
 249  6487 11 65            DW CMDS_S ; S
 250  6489               ELSE
 251  6489 ~            	DW 0
 252  6489               ENDIF
 253  6489               IF (TILE_CMDS > 0) && (1 == 1)
 254  6489 88 65            DW CMDS_T ; T
 255  648B               ELSE
 256  648B ~            	DW 0
 257  648B               ENDIF
 258  648B               IF (DECOMP_CMDS > 0) && (1 == 1)
 259  648B A3 65            DW CMDS_U ; U
 260  648D               ELSE
 261  648D ~            	DW 0
 262  648D               ENDIF
 263  648D               IF ((VRAM_CMDS > 0) || (VRAM_CMDS + DECOMP_CMDS > 1)) && (1 == 1)
 264  648D FE 64            DW CMDS_V ; V
 265  648F               ELSE
 266  648F ~            	DW 0
 267  648F               ENDIF
 268  648F 00 00            DW 0 ; W
 269  6491 00 00            DW 0 ; X
 270  6493 00 00            DW 0 ; Y
 271  6495 00 00            DW 0 ; Z
 272  6497
 273  6497               IF (1 == 1)
 274  6497               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 275  6497              CMDS_M:
 276  6497               IF (VRAM_CMDS == 1)
 277  6497 4D 45 4D 56      DB "MEMVRM", 0
 277  649B 52 4D 00
 278  649E F0 59            DW MEMVRM
 279  64A0               ENDIF
 280  64A0               IF (RAM_CMDS == 1)
 281  64A0 4D 45 4D 43  	DB "MEMCPY", 0
 281  64A4 50 59 00
 282  64A7 39 58        	DW MEMCPY
 283  64A9               ENDIF
 284  64A9               IF (ANIM_CMDS == 1)
 285  64A9 4D 41 58 41  	DB "MAXANIMITEMS",0
 285  64AD 4E 49 4D 49
 285  64B1 54 45 4D 53
 285  64B5 00
 286  64B6 A7 4F        	DW MAXANIMITEMS
 287  64B8 4D 41 58 41  	DB "MAXANIMDEFS",0
 287  64BC 4E 49 4D 44
 287  64C0 45 46 53 00
 288  64C4 37 51        	DW MAXANIMDEFS
 289  64C6 4D 41 58 41  	DB "MAXANIMSPRS",0
 289  64CA 4E 49 4D 53
 289  64CE 50 52 53 00
 290  64D2 CD 51        	DW MAXANIMSPRS
 291  64D4 4D 41 58 41     DB "MAXAUTOSGAMS",0
 291  64D8 55 54 4F 53
 291  64DC 47 41 4D 53
 291  64E0 00
 292  64E1 17 53           DW MAXAUTOSGAMS
 293  64E3               ENDIF
 294  64E3               ENDIF
 295  64E3
 296  64E3               IF (VRAM_CMDS + RAM_CMDS > 0)
 297  64E3              CMDS_F:
 298  64E3               IF (VRAM_CMDS == 1)
 299  64E3 46 49 4C 56      DB "FILVRM", 0
 299  64E7 52 4D 00
 300  64EA A1 59            DW FILVRM
 301  64EC               ENDIF
 302  64EC               IF (RAM_CMDS == 1)
 303  64EC 46 49 4C 52      DB "FILRAM", 0
 303  64F0 41 4D 00
 304  64F3 76 58            DW FILRAM
 305  64F5               ENDIF
 306  64F5               ENDIF
 307  64F5
 308  64F5               IF (GENCAL_CMD > 0)
 309  64F5              CMDS_G:
 310  64F5               IF (GENCAL_CMD == 1)
 311  64F5 47 45 4E 43      DB "GENCAL", 0
 311  64F9 41 4C 00
 312  64FC D1 5A            DW GENCAL
 313  64FE               ENDIF
 314  64FE               ENDIF
 315  64FE
 316  64FE               IF (VRAM_CMDS > 0)
 317  64FE              CMDS_V:
 318  64FE               IF (VRAM_CMDS == 1)
 319  64FE 56 52 4D 4D  	DB "VRMMEM", 0
 319  6502 45 4D 00
 320  6505 77 5A        	DW VRMMEM
 321  6507               ENDIF
 322  6507               IF (DECOMP_CMDS == 1)
 323  6507 56 55 4E 50  	DB "VUNPACK", 0
 323  650B 41 43 4B 00
 324  650F 9C 62        	DW VUNPACK
 325  6511               ENDIF
 326  6511               ENDIF
 327  6511
 328  6511               IF (SOUND_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 329  6511              CMDS_S:
 330  6511               IF (SPRITE_CMDS + ANIM_CMDS > 0)
 331  6511 53 47 41 4D      DB "SGAM",0
 331  6515 00
 332  6516 A5 56            DW SGAM
 333  6518               ENDIF
 334  6518               IF (SPRITE_CMDS == 1)
 335  6518 53 50 52 47  	DB "SPRGRPMOV", 0
 335  651C 52 50 4D 4F
 335  6520 56 00
 336  6522 FF 4E        	DW SPRGRPMOV
 337  6524               ENDIF
 338  6524               IF (SOUND_CMDS == 1)
 339  6524 53 4E 44 53  	DB "SNDSFX", 0
 339  6528 46 58 00
 340  652B 46 59        	DW SNDSFX
 341  652D 53 4E 44 50  	DB "SNDPLYON", 0
 341  6531 4C 59 4F 4E
 341  6535 00
 342  6536 10 59        	DW SNDPLYON
 343  6538 53 4E 44 50  	DB "SNDPLYOFF", 0
 343  653C 4C 59 4F 46
 343  6540 46 00
 344  6542 22 59        	DW SNDPLYOFF
 345  6544 53 4E 44 50  	DB "SNDPLYINI", 0
 345  6548 4C 59 49 4E
 345  654C 49 00
 346  654E C5 58        	DW SNDPLYINIT
 347  6550               ENDIF
 348  6550               IF (SPRITE_CMDS == 1)
 349  6550 53 50 52 45  	DB "SPRENABLE", 0
 349  6554 4E 41 42 4C
 349  6558 45 00
 350  655A 75 4E        	DW SPRENABLE
 351  655C 53 50 52 44  	DB "SPRDISABLE", 0
 351  6560 49 53 41 42
 351  6564 4C 45 00
 352  6567 BC 4E        	DW SPRDISABLE
 353  6569               ENDIF
 354  6569               ENDIF
 355  6569
 356  6569               IF (BLIT_CMDS + BOX_CMDS > 0)
 357  6569              CMDS_B:
 358  6569               IF (BLIT_CMDS == 1)
 359  6569 42 4C 49 54  	DB "BLIT", 0
 359  656D 00
 360  656E AE 5D        	DW BLIT
 361  6570               ENDIF
 362  6570               IF (BOX_CMDS == 1)
 363  6570 42 4F 58 4D  	DB "BOXMEMCPY", 0
 363  6574 45 4D 43 50
 363  6578 59 00
 364  657A 61 5B        	DW BOXMEMCPY
 365  657C 42 4F 58 4D  	DB "BOXMEMVRM", 0
 365  6580 45 4D 56 52
 365  6584 4D 00
 366  6586 F2 5B        	DW BOXMEMVRM
 367  6588               ENDIF
 368  6588               ENDIF
 369  6588
 370  6588               IF (TILE_CMDS > 0)
 371  6588              CMDS_T:
 372  6588               IF (TILE_CMDS == 1)
 373  6588 54 49 4C 45  	DB "TILERAM", 0
 373  658C 52 41 4D 00
 374  6590 D6 5E        	DW TILERAM
 375  6592 54 49 4C 45  	DB "TILEVRM", 0
 375  6596 56 52 4D 00
 376  659A D5 5F        	DW TILEVRM
 377  659C               ENDIF
 378  659C               ENDIF
 379  659C
 380  659C               IF (COLL_CMD > 0)
 381  659C              CMDS_C:
 382  659C               IF (COLL_CMD == 1)
 383  659C 43 4F 4C 4C      DB "COLL", 0
 383  65A0 00
 384  65A1 9D 61            DW COLL
 385  65A3               ENDIF
 386  65A3               ENDIF
 387  65A3
 388  65A3               IF (DECOMP_CMDS > 0)
 389  65A3              CMDS_U:
 390  65A3               IF (DECOMP_CMDS == 1)
 391  65A3 55 4E 50 41      DB "UNPACK", 0
 391  65A7 43 4B 00
 392  65AA B4 62            DW UNPACK
 393  65AC               ENDIF
 394  65AC               ENDIF
 395  65AC
 396  65AC               IF (DLOAD_CMD > 0)
 397  65AC              CMDS_D:
 398  65AC               IF (DLOAD_CMD == 1)
 399  65AC 44 4C 4F 41      DB "DLOAD", 0
 399  65B0 44 00
 400  65B2 01 64            DW DLOAD
 401  65B4               ENDIF
 402  65B4               ENDIF
 403  65B4
 404  65B4              CMDS_A:
 405  65B4               IF (ANIM_CMDS == 1)
 406  65B4 41 4E 49 4D     DB "ANIMSTEP",0
 406  65B8 53 54 45 50
 406  65BC 00
 407  65BD E7 54           DW ANIMSTEP
 408  65BF 41 4E 49 4D  	DB "ANIMSTART",0
 408  65C3 53 54 41 52
 408  65C7 54 00
 409  65C9 EC 54        	DW ANIMSTART
 410  65CB 41 4E 49 4D  	DB "ANIMSTOP",0
 410  65CF 53 54 4F 50
 410  65D3 00
 411  65D4 F1 54        	DW ANIMSTOP
 412  65D6 41 4E 49 4D  	DB "ANIMITEMPAT",0
 412  65DA 49 54 45 4D
 412  65DE 50 41 54 00
 413  65E2 78 50        	DW ANIMITEMPAT
 414  65E4 41 4E 49 4D  	DB "ANIMITEMPTR",0
 414  65E8 49 54 45 4D
 414  65EC 50 54 52 00
 415  65F0 DE 50        	DW ANIMITEMPTR_CMD
 416  65F2 41 4E 49 4D  	DB "ANIMDEF",0
 416  65F6 44 45 46 00
 417  65FA 7A 51        	DW ANIMDEF
 418  65FC 41 4E 49 4D  	DB "ANIMSPRITE",0
 418  6600 53 50 52 49
 418  6604 54 45 00
 419  6607 26 52        	DW ANIMSPRITE
 420  6609 41 4E 49 4D     DB "ANIMCHAR",0
 420  660D 43 48 41 52
 420  6611 00
 421  6612 9E 52           DW ANIMCHAR
 422  6614 41 55 54 4F     DB "AUTOSGAMDEF",0
 422  6618 53 47 41 4D
 422  661C 44 45 46 00
 423  6620 74 53           DW AUTOSGAMDEF
 424  6622 41 55 54 4F     DB "AUTOSGAMSTART",0
 424  6626 53 47 41 4D
 424  662A 53 54 41 52
 424  662E 54 00
 425  6630 A8 54           DW AUTOSGAMSTART
 426  6632 41 55 54 4F     DB "AUTOSGAMSTOP",0
 426  6636 53 47 41 4D
 426  663A 53 54 4F 50
 426  663E 00
 427  663F E4 54           DW AUTOSGAMSTOP
 428  6641               ENDIF
 429  6641 41 52 54 49     DB "ARTINFO",0
 429  6645 4E 46 4F 00
 430  6649 22 68           DW ARTINFO
 431  664B 00           	DB 0
 432  664C               ELSE // if not BASIC extension
 433  664C ~            CMDS_A:
 434  664C ~               DB "ARTINFO",0
 435  664C ~               DW ARTINFO
 436  664C ~            	DB 0
 437  664C               ENDIF
 438  664C
 439  664C              ; ****************************************************************************************************
 440  664C              ; some common exit code
 441  664C              ; returns ROM in page 0
 442  664C              ; sets exit status to 0 in A
 443  664C              COMMON_EXIT_CODE_IX:
 444  664C DD E5           PUSH IX
 445  664E E1              POP HL
 446  664F              COMMON_EXIT_CODE:
 447  664F D1              POP DE
 448  6650 C1              POP BC
 449  6651 CD B0 66        CALL RESTORE_PAGE_INFO
 450  6654 AF           	XOR A ; success
 451  6655 C9           	RET
 452  6656              ; ****************************************************************************************************
 453  6656
 454  6656               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 455  6656              ; ****************************************************************************************************
 456  6656              ; function sets VRAM address for writing
 457  6656              ; input HL=address
 458  6656              ; modifies AF
 459  6656              SETWRT_LOCAL_WRITE:
 460  6656 7D           	LD	A,L
 461  6657 D3 99        	OUT (#99),A
 462  6659 7C           	LD	A,H
 463  665A E6 3F        	AND #3F
 464  665C F6 40        	OR	#40
 465  665E D3 99        	OUT (#99),A
 466  6660 C9           	RET
 467  6661              ; ****************************************************************************************************
 468  6661
 469  6661              ; ****************************************************************************************************
 470  6661              ; function sets VRAM address for reading
 471  6661              ; input HL=address
 472  6661              ; modifies AF
 473  6661              SETWRT_LOCAL_READ:
 474  6661 7D           	LD	A,L
 475  6662 D3 99        	OUT (#99),A
 476  6664 7C           	LD	A,H
 477  6665 E6 3F        	AND #3F
 478  6667 00              NOP
 479  6668 D3 99        	OUT (#99),A
 480  666A C9           	RET
 481  666B              ; ****************************************************************************************************
 482  666B               ENDIF
 483  666B
 484  666B               IF (VRAM_CMDS + TILE_CMDS > 0)
 485  666B              ; ****************************************************************************************************
 486  666B              ; function copies data from RAM to VRAM
 487  666B              ; input HL=address in RAM
 488  666B              ; input B=count
 489  666B              ; modifies AF, BC, HL
 490  666B              BBYTECOPY:
 491  666B 0E 98        	LD C,#98
 492  666D              BBYTECOPY_NO_C:
 493  666D ED A3        	OUTI
 494  666F C2 6D 66     	JP	NZ, BBYTECOPY_NO_C
 495  6672 C9           	RET
 496  6673              ; ****************************************************************************************************
 497  6673               ENDIF
 498  6673
 499  6673              ; ****************************************************************************************************
 500  6673              ; function multiplies HL by 32
 501  6673              HLx32:
 502  6673 29           	ADD HL,HL
 503  6674              ; ****************************************************************************************************
 504  6674              ; function multiplies HL by 16
 505  6674              HLx16:
 506  6674 29           	ADD HL,HL
 507  6675              ; ****************************************************************************************************
 508  6675              ; function multiplies HL by 8
 509  6675              HLx8:
 510  6675 29          > ADD HL, HL
 510  6676 29          > ADD HL, HL
 510  6677 29          > ADD HL, HL
 511  6678 C9           	RET
 512  6679              ; ****************************************************************************************************
 513  6679
 514  6679              ; ****************************************************************************************************
 515  6679              ; function gets slot and subslot data for specific page
 516  6679              ; input A=page (0, 1 or 2)
 517  6679              ; output B = 0A8H register value
 518  6679              ; output D = 0 is no subslots, 1 if yes
 519  6679              ; output C = 0A8H value when page 3 slot equals to requested page slot
 520  6679              ; output E = subslot value if present
 521  6679              ; modifies AF, BC, DE, HL
 522  6679              GET_PAGE_INFO:
 523  6679 6F               LD L, A
 524  667A C6 C1            ADD A, low (EXPTBL)
 525  667C 32 86 66         LD (GET_PAGE_INFO_L1+1), A
 526  667F DB A8            IN A, (0A8H)
 527  6681 47               LD B, A
 528  6682 E6 3F            AND 03FH
 529  6684 4F               LD C, A
 530  6685              GET_PAGE_INFO_L1:
 531  6685 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 532  6688 E6 80            AND 080H
 533  668A 28 1B            JR Z, GET_PAGE_INFO_L2
 534  668C                  ; expanded
 535  668C 2D               DEC L
 536  668D FA AC 66         JP M, GET_PAGE_INFO_L3
 537  6690 2D               DEC L
 538  6691 FA AA 66         JP M, GET_PAGE_INFO_L4
 539  6694                  ; page 2
 540  6694 07               RLCA
 541  6695 07               RLCA
 542  6696              GET_PAGE_INFO_L5:
 543  6696 E6 C0            AND 0C0H
 544  6698 B1               OR C
 545  6699 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 546  669B 4F               LD C, A
 547  669C 3A FF FF         LD A, (0FFFFH)
 548  669F 2F               CPL
 549  66A0 5F               LD E, A
 550  66A1 16 01            LD D, 1
 551  66A3 78               LD A, B ; return stack
 552  66A4 D3 A8            OUT (0A8H), A
 553  66A6 C9               RET
 554  66A7              GET_PAGE_INFO_L2:
 555  66A7                  ; not expanded
 556  66A7 16 00            LD D, 0
 557  66A9 C9               RET
 558  66AA              GET_PAGE_INFO_L4:
 559  66AA                  ; page 1
 560  66AA 0F               RRCA
 561  66AB 0F               RRCA
 562  66AC              GET_PAGE_INFO_L3:
 563  66AC                  ; page 0
 564  66AC 0F               RRCA
 565  66AD 0F               RRCA
 566  66AE 18 E6            JR GET_PAGE_INFO_L5
 567  66B0              ; ****************************************************************************************************
 568  66B0
 569  66B0              ; ****************************************************************************************************
 570  66B0              ; function returns original slot and subslot info
 571  66B0              ; input B = 0A8H register value
 572  66B0              ; input D = 0 is no subslots, 1 if yes
 573  66B0              ; input C = 0A8H value when page 3 slot equals to requested page slot
 574  66B0              ; input E = subslot value if present
 575  66B0              ; modifies AF, disables interrupts
 576  66B0              RESTORE_PAGE_INFO:
 577  66B0 F3              DI
 578  66B1 7A              LD A, D
 579  66B2 B7              OR A
 580  66B3 28 07           JR Z, RESTORE_PAGE_INFO_L1
 581  66B5 79              LD A, C
 582  66B6 D3 A8           OUT (0A8H), A
 583  66B8 7B              LD A, E
 584  66B9 32 FF FF        LD (0FFFFH), A
 585  66BC              RESTORE_PAGE_INFO_L1:
 586  66BC 78              LD A, B
 587  66BD D3 A8           OUT (0A8H), A
 588  66BF              NOACTION_DEFUSR: ; just a safe RET for use when DEFUSR table has an empty entry
 589  66BF C9              RET
 590  66C0              ; ****************************************************************************************************
 591  66C0
 592  66C0              ; *******************************************************************************************************
 593  66C0              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 594  66C0              ; INPUT:  A = SLOT ID: EXXXSSPP
 595  66C0              ; E = EXPANDED FLAG
 596  66C0              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 597  66C0              ; PP = PRIMARY SLOT NUMBER
 598  66C0              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 599  66C0              ; CHANGES: AF, BC, DE
 600  66C0
 601  66C0              LOCAL_ENASLT:
 602  66C0 CD E0 66         CALL L0353
 603  66C3 FA CD 66         JP M, L0340
 604  66C6 DB A8            IN A, (0A8H)
 605  66C8 A1               AND C
 606  66C9 B0               OR B
 607  66CA D3 A8            OUT (0A8H), A
 608  66CC C9               RET
 609  66CD              L0340:
 610  66CD E5               PUSH HL
 611  66CE CD 05 67         CALL L0378
 612  66D1 4F               LD C, A
 613  66D2 06 00            LD B, 0
 614  66D4 7D               LD A, L
 615  66D5 A4               AND H
 616  66D6 B2               OR D
 617  66D7 21 C5 FC         LD HL, 0FCC5H
 618  66DA 09               ADD HL, BC
 619  66DB 77               LD (HL), A
 620  66DC E1               POP HL
 621  66DD 79               LD A, C
 622  66DE 18 E0            JR LOCAL_ENASLT
 623  66E0              L0353:
 624  66E0 F3               DI
 625  66E1 F5               PUSH AF
 626  66E2 7C               LD A, H
 627  66E3 07               RLCA
 628  66E4 07               RLCA
 629  66E5 E6 03            AND 3
 630  66E7 5F               LD E, A
 631  66E8 3E C0            LD A, 0C0H
 632  66EA              L035D:
 633  66EA 07               RLCA
 634  66EB 07               RLCA
 635  66EC 1D               DEC E
 636  66ED F2 EA 66         JP P, L035D
 637  66F0 5F               LD E, A
 638  66F1 2F               CPL
 639  66F2 4F               LD C, A
 640  66F3 F1               POP AF
 641  66F4 F5               PUSH AF
 642  66F5 E6 03            AND 3
 643  66F7 3C               INC A
 644  66F8 47               LD B, A
 645  66F9 3E AB            LD A, 0ABH
 646  66FB              L036E:
 647  66FB C6 55            ADD A, 055H
 648  66FD 10 FC            DJNZ L036E
 649  66FF 57               LD D, A
 650  6700 A3               AND E
 651  6701 47               LD B, A
 652  6702 F1               POP AF
 653  6703 A7               AND A
 654  6704 C9               RET
 655  6705              L0378:
 656  6705 F5               PUSH AF
 657  6706 7A               LD A, D
 658  6707 E6 C0            AND 0C0H
 659  6709 4F               LD C, A
 660  670A F1               POP AF
 661  670B F5               PUSH AF
 662  670C 57               LD D, A
 663  670D DB A8            IN A, (0A8H)
 664  670F 47               LD B, A
 665  6710 E6 3F            AND 03FH
 666  6712 B1               OR C
 667  6713 D3 A8            OUT (0A8H), A
 668  6715 7A               LD A, D
 669  6716 0F               RRCA
 670  6717 0F               RRCA
 671  6718 E6 03            AND 3
 672  671A 57               LD D, A
 673  671B 3E AB            LD A, 0ABH
 674  671D              L0390:
 675  671D C6 55            ADD A, 055H
 676  671F 15               DEC D
 677  6720 F2 1D 67         JP P, L0390
 678  6723 A3               AND E
 679  6724 57               LD D, A
 680  6725 7B               LD A, E
 681  6726 2F               CPL
 682  6727 67               LD H, A
 683  6728 3A FF FF         LD A, (0FFFFH)
 684  672B 2F               CPL
 685  672C 6F               LD L, A
 686  672D A4               AND H
 687  672E B2               OR D
 688  672F 32 FF FF         LD (0FFFFH), A
 689  6732 78               LD A, B
 690  6733 D3 A8            OUT (0A8H), A
 691  6735 F1               POP AF
 692  6736 E6 03            AND 3
 693  6738 C9               RET
 694  6739              ; *******************************************************************************************************
 695  6739
 696  6739              ; *******************************************************************************************************
 697  6739              ; some common code to activate page 0 and place values needed to restore original page on stack
 698  6739              ; input IY=return address
 699  6739              ENABLE_PAGE0:
 700  6739 F3              DI
 701  673A AF              XOR A
 702  673B CD 79 66        CALL GET_PAGE_INFO
 703  673E C5              PUSH BC
 704  673F D5              PUSH DE
 705  6740 3A 41 F3        LD A, (RAMAD0)
 706  6743 26 00           LD H, 0
 707  6745 CD C0 66        CALL LOCAL_ENASLT
 708  6748 FD E9        	JP (IY)
 709  674A              ; *******************************************************************************************************
 710  674A
 711  674A              ; General BASIC CALL-instruction handler
 712  674A              CALLHAND:
 713  674A FB              EI
 714  674B E5           	PUSH HL
 715  674C 21 63 64     	LD	HL, CMDS ; pointer table based on starting letter
 716  674F 3A 89 FD        LD A, (PROCNM)
 717  6752 D6 41           SUB 'A'
 718  6754 87              ADD A, A
 719  6755 16 00           LD D, 0
 720  6757 5F              LD E, A
 721  6758 19              ADD HL, DE
 722  6759 5E              LD E, (HL)
 723  675A 23              INC HL
 724  675B 56              LD D, (HL)
 725  675C 7A              LD A, D
 726  675D B3              OR E
 727  675E 28 23           JR Z, .CMDNOTRECOGNIZED
 728  6760 EB              EX DE, HL
 729  6761              .CHKCMD:
 730  6761 11 89 FD     	LD	DE, PROCNM
 731  6764              .LOOP:
 732  6764 1A              LD	A,(DE)
 733  6765 BE           	CP	(HL)
 734  6766 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 735  6768 13           	INC	DE
 736  6769 23           	INC	HL
 737  676A A7           	AND	A
 738  676B 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 739  676D 5E           	LD	E,(HL)
 740  676E 23           	INC	HL
 741  676F 56           	LD	D,(HL)
 742  6770 E1           	POP	HL		; routine address
 743  6771 CD 92 67     	CALL	GETPREVCHAR
 744  6774 CD 86 67     	CALL	.CALLDE		; Call routine
 745  6777 A7           	AND	A
 746  6778 C9           	RET
 747  6779
 748  6779              .TONEXTCMD:
 749  6779 0E FF        	LD	C,0FFH
 750  677B AF           	XOR	A
 751  677C ED B1        	CPIR			; Skip to end of instruction name
 752  677E 23           	INC	HL
 753  677F 23           	INC	HL		; Skip address
 754  6780 BE           	CP	(HL)
 755  6781 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 756  6783              .CMDNOTRECOGNIZED:
 757  6783 E1           	POP	HL
 758  6784 37              SCF
 759  6785 C9           	RET
 760  6786
 761  6786              .CALLDE:
 762  6786 D5           	PUSH	DE
 763  6787 C9           	RET
 764  6788
 765  6788              ;---------------------------
 766  6788
 767  6788              CHKCHAR:
 768  6788 CD 92 67     	CALL	GETPREVCHAR	; Get previous basic char
 769  678B E3           	EX	(SP),HL
 770  678C BE           	CP	(HL) 	        ; Check if good char
 771  678D 20 29        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 772  678F 23           	INC	HL
 773  6790 E3           	EX	(SP),HL
 774  6791 23           	INC	HL		; Get next basic char
 775  6792
 776  6792              GETPREVCHAR:
 777  6792 2B           	DEC HL
 778  6793 DD 21 66 46  	LD	IX,CHRGTR
 779  6797 CD 59 01     	CALL CALBAS
 780  679A FB              EI
 781  679B C9              RET
 782  679C
 783  679C               IF (1 == 1)
 784  679C               IF (DLOAD_CMD == 1)
 785  679C              BAD_FILENAME:
 786  679C 1E 38           LD E,56
 787  679E 18 1A           JR THROW_ERROR
 788  67A0              DISKIOERR:
 789  67A0 1E 45           LD E,69
 790  67A2 18 16           JR THROW_ERROR
 791  67A4               ENDIF
 792  67A4              OUT_OF_DATA:
 793  67A4 1E 04           LD E, 4
 794  67A6 18 12           JR THROW_ERROR
 795  67A8              TYPE_MISMATCH:
 796  67A8 1E 0D           LD E, 13 ; Type mismatch
 797  67AA 18 0E           JR THROW_ERROR
 798  67AC              SUBSCRIPT_OUT_OF_RANGE:
 799  67AC 1E 09           LD E,9 ; subscript out of range
 800  67AE 18 0A        	JR THROW_ERROR
 801  67B0              OVERFLOW:
 802  67B0 1E 06        	LD E,6
 803  67B2 18 06        	JR THROW_ERROR
 804  67B4              ILLEGAL_FUNCTION:
 805  67B4 1E 05           LD E, 5 ; illegal function call
 806  67B6 18 02           JR THROW_ERROR
 807  67B8               ENDIF
 808  67B8              SYNTAX_ERROR:
 809  67B8 1E 02           LD E, 2 ; Syntax error
 810  67BA              THROW_ERROR:
 811  67BA DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 812  67BE C3 59 01     	JP	CALBAS
 813  67C1
 814  67C1
 815  67C1              ;---------------------------
 816  67C1
 817  67C1               IF (DLOAD_CMD == 1)
 818  67C1              ; *******************************************************************************************************
 819  67C1              ; helper function to make an uppercase letter
 820  67C1              ; input A=character
 821  67C1              ; output A=uppercase version of input
 822  67C1              UPPER:
 823  67C1 FE 61           CP "a"
 824  67C3 D8              RET C
 825  67C4 FE 7B           CP "z"+1
 826  67C6 D0              RET NC
 827  67C7 E6 5F           AND 5FH
 828  67C9 C9              RET
 829  67CA              ; *******************************************************************************************************
 830  67CA               ENDIF
 831  67CA
 832  67CA               IF (1 == 1)
 833  67CA
 834  67CA               IF (DLOAD_CMD == 1)
 835  67CA              ; *******************************************************************************************************
 836  67CA              ; helper function to return string pointer and length
 837  67CA              ; returns HL = String Address
 838  67CA              ; returns B  = Lenght
 839  67CA              ; modifies BC, DE, HL
 840  67CA              GETSTRPNT:
 841  67CA 2A F8 F7        LD      HL,(USR)
 842  67CD 46              LD      B,(HL)
 843  67CE 23              INC     HL
 844  67CF 5E              LD      E,(HL)
 845  67D0 23              INC     HL
 846  67D1 56              LD      D,(HL)
 847  67D2 EB              EX      DE,HL
 848  67D3 C9              RET
 849  67D4              ; *******************************************************************************************************
 850  67D4
 851  67D4              ; *******************************************************************************************************
 852  67D4              ; helper function to get string parameter
 853  67D4              ; throws error if incorrect type
 854  67D4              ; input HL=basic text
 855  67D4              EVALTXTPARAM:
 856  67D4 DD 21 64 4C  	LD	IX,FRMEVL
 857  67D8 CD 59 01     	CALL CALBAS		; Evaluate expression
 858  67DB 3A 63 F6        LD A,(VALTYP)
 859  67DE FE 03           CP 3               ; Text type?
 860  67E0 C2 A8 67        JP NZ,TYPE_MISMATCH
 861  67E3 E5              PUSH HL
 862  67E4 DD 21 D0 67     LD	IX,FRESTR         ; Free the temporary string
 863  67E8 CD 59 01        CALL CALBAS
 864  67EB E1              POP HL
 865  67EC C9              RET
 866  67ED              ; *******************************************************************************************************
 867  67ED
 868  67ED               ENDIF
 869  67ED
 870  67ED              ; *******************************************************************************************************
 871  67ED              ; helper function to get pointer to BASIC array data
 872  67ED              ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
 873  67ED              ; input B=dimensions (1 or 2)
 874  67ED              ; input D=minimal first dimension
 875  67ED              ; input E=minimal second dimension, if applicable
 876  67ED              ; returns BC=pointer to first data element
 877  67ED              ; throws BASIC error if invalid type
 878  67ED              GET_BASIC_ARRAY_DATA_POINTER:
 879  67ED D5           	PUSH DE
 880  67EE C5           	PUSH BC
 881  67EF F5           	PUSH AF
 882  67F0 3E 01           LD A,1
 883  67F2 32 A5 F6        LD (SUBFLG),A ; search for arrays only
 884  67F5 DD 21 A4 5E  	LD IX, PTRGET
 885  67F9 CD 59 01     	CALL CALBAS
 886  67FC AF              XOR A
 887  67FD 32 A5 F6        LD (SUBFLG),A ; if not reset will cause syntax errors
 888  6800 3A 63 F6     	LD A,(VALTYP)
 889  6803 D1           	POP DE ; required type
 890  6804 BA           	CP D
 891  6805 C2 A8 67     	JP NZ,TYPE_MISMATCH
 892  6808 0A           	LD A,(BC)
 893  6809 03           	INC BC
 894  680A D1           	POP DE ; required number of dimensions
 895  680B BA           	CP D
 896  680C C2 A8 67     	JP NZ,TYPE_MISMATCH
 897  680F D1           	POP DE ; required minimal array dimensions
 898  6810 3D           	DEC A
 899  6811 28 07        	JR Z,.ONE_DIMENSION
 900  6813              	; 2-dimension array
 901  6813 0A           	LD A,(BC)
 902  6814 03          > INC BC
 902  6815 03          > INC BC
 903  6816 BB           	CP E
 904  6817 DA AC 67     	JP C,SUBSCRIPT_OUT_OF_RANGE
 905  681A              .ONE_DIMENSION:
 906  681A 0A           	LD A,(BC)
 907  681B 03          > INC BC
 907  681C 03          > INC BC
 908  681D BA           	CP D
 909  681E DA AC 67     	JP C,SUBSCRIPT_OUT_OF_RANGE
 910  6821 C9           	RET
 911  6822              ; *******************************************************************************************************
 912  6822               ENDIF
 913  6822
 914  6822              ; *******************************************************************************************************
 915  6822              ; function to handle CALL ARTINFO basic extension
 916  6822              ; returns info about the extension
 917  6822              ; _ARTINFO ( INT variable version,
 918  6822              ;			    INT variable build_flags,
 919  6822              ;			    INT variable free_memory_ptr )
 920  6822              ; this function is always available and can be used to test if the extension is active
 921  6822              ARTINFO:
 922  6822              	; opening (
 923  6822 CD 88 67     	CALL CHKCHAR
 924  6825 28           	DB '('
 925  6826              	; get address of version variable
 926  6826 DD 21 A4 5E  	LD IX, PTRGET
 927  682A CD 59 01     	CALL CALBAS
 928  682D 3A 12 40     	LD A,(VERSION)
 929  6830 12              LD (DE),A
 930  6831 13              INC DE
 931  6832 3A 13 40        LD A,(VERSION+1)
 932  6835 12              LD (DE),A
 933  6836              	; comma
 934  6836 CD 88 67     	CALL CHKCHAR
 935  6839 2C           	DB ','
 936  683A              	; get address of build flags variable
 937  683A DD 21 A4 5E  	LD IX, PTRGET
 938  683E CD 59 01     	CALL CALBAS
 939  6841 E5              PUSH HL
 940  6842 21 FF 37        LD HL,SOUND_CMDS+2*RAM_CMDS+4*VRAM_CMDS+8*BLIT_CMDS+16*SPRITE_CMDS+32*GENCAL_CMD+64*TILE_CMDS+128*BOX_CMDS+256*ANIM_CMDS+512*COLL_CMD+1024*1+2048*0+4096*DECOMP_CMDS+8192*DLOAD_CMD
 941  6845 EB              EX DE,HL
 942  6846 73              LD (HL),E
 943  6847 23              INC HL
 944  6848 72              LD (HL),D
 945  6849 E1              POP HL
 946  684A              	; comma
 947  684A CD 88 67     	CALL CHKCHAR
 948  684D 2C           	DB ','
 949  684E              	; get address of free memory variable
 950  684E DD 21 A4 5E  	LD IX, PTRGET
 951  6852 CD 59 01     	CALL CALBAS
 952  6855 3A 10 40     	LD A,(FREEMEMPTR)
 953  6858 12              LD (DE),A
 954  6859 13              INC DE
 955  685A 3A 11 40        LD A,(FREEMEMPTR+1)
 956  685D 12              LD (DE),A
 957  685E              	; ending )
 958  685E CD 88 67     	CALL CHKCHAR
 959  6861 29           	DB ')'
 960  6862 C9           	RET
 961  6863              ; *******************************************************************************************************
 962  6863
 963  6863              EXT_END:
 964  6863
# file closed: asm\main.asm
