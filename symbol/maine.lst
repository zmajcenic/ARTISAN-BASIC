# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		   EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000              COLL_CMD       EQU 1
  14  4000              DECOMP_CMDS    EQU 1
  15  4000              DLOAD_CMD      EQU 1
  16  4000
  17  4000              ; what to compile, provided in sjasmplus command line
  18  4000              ;BASIC_EXTENSION   EQU 1
  19  4000              ;DEFUSR_EXTENSION  EQU 0
  20  4000
  21  4000              CHPUT   EQU    #A2
  22  4000              CALBAS  EQU		#159
  23  4000              ERRHAND EQU    #406F
  24  4000              FRMEVL  EQU    #4C64
  25  4000              FRESTR  EQU		#67D0
  26  4000              ; FRMQNT = formula quantificator
  27  4000              ; input HL=pointer to current program expression
  28  4000              ; output HL=next address
  29  4000              ; output DE=integer datum
  30  4000              FRMQNT	EQU		#542F
  31  4000              ; GETBYT = get byte parameter
  32  4000              ; input HL=pointer to current program expression
  33  4000              ; output HL=next address
  34  4000              ; output A=E=byte read
  35  4000              GETBYT		EQU	#521C
  36  4000              CHRGTR  	   EQU   #4666
  37  4000              PTRGET		EQU 	#5EA4
  38  4000              SUBFLG		EQU	#F6A5
  39  4000              SYNCHR		EQU	#558C
  40  4000              VALTYP  	   EQU   #F663
  41  4000              DAC         EQU   #F7F6
  42  4000              USR     	   EQU   #F7F8
  43  4000              PROCNM		EQU	#FD89
  44  4000              BIOS_FILVRM EQU   #0056
  45  4000              CLIKSW		EQU	#F3DB
  46  4000
  47  4000              RAMAD0	   EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  48  4000              RAMAD1	   EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  49  4000              RAMAD2	   EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  50  4000              RAMAD3	   EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  51  4000              EXPTBL	   EQU   #FCC1
  52  4000              SCRMOD	   EQU   #FCAF ; current screen mode
  53  4000              REG1SAV     EQU   #F3E0 ; VDP(1)
  54  4000              JIFFY	      EQU   #FC9E
  55  4000              GRPPAT	   EQU   #F3CF ; SCREEN 2 sprite generator table address
  56  4000              GRPCGP		EQU	#F3CB ; SCREEN 2 pattern generator table address
  57  4000              GRPATR      EQU   #F3CD ; SCREEN 2 sprite attribute table address
  58  4000              T32PAT	   EQU   #F3C5 ; SCREEN 1 sprite generator table address
  59  4000              T32CGP      EQU   #F3C1 ; SCREEN 1 pattern ganarator table address
  60  4000              T32ATR      EQU   #F3C3 ; SCREEN 1 sprite attribute table address
  61  4000
  62  4000              FCB0        EQU   #F353 ; location of FCB 0
  63  4000              BDOS        EQU   #F37D ; disk functions
  64  4000              NULBUF      EQU   #F862 ; disk buffer of 256 bytes address
  65  4000
  66  4000              ; BASIC error codes
  67  4000              ;01 NEXT without FOR
  68  4000              ;02 Syntax error
  69  4000              ;03 RETURN without GOSUB
  70  4000              ;04 Out of DATA
  71  4000              ;05 Illegal function call
  72  4000              ;06 Overflow
  73  4000              ;07 Out of memory
  74  4000              ;08 Undefined line number
  75  4000              ;09 Subscript out of range
  76  4000              ;10 Redimensioned array
  77  4000              ;11 Division by zero
  78  4000              ;12 Illegal direct
  79  4000              ;13 Type mismatch
  80  4000              ;14 Out of string space
  81  4000              ;15 String too long
  82  4000              ;16 String formula too complex
  83  4000              ;17 Can't CONTINUE
  84  4000              ;18 Undefined user function
  85  4000              ;19 Device I/O error
  86  4000              ;20 Verify error
  87  4000              ;21 No RESUME
  88  4000              ;22 RESUME without error
  89  4000              ;23 Unprintable error
  90  4000              ;24 Missing operand
  91  4000              ;25 Line buffer overflow
  92  4000              ;50 FIELD overflow
  93  4000              ;51 Internal error
  94  4000              ;52 Bad file number
  95  4000              ;53 File not found
  96  4000              ;54 File already open
  97  4000              ;55 Input past end
  98  4000              ;56 Bad file name
  99  4000              ;57 Direct statement in file
 100  4000              ;58 Sequential I/O only
 101  4000              ;59 File not OPEN
 102  4000
 103  4000
 104  4000               ; simulate cartridge with BASIC extension
 105  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
 105  4004 6B 67 00 00
 105  4008 00 00 00 00
 105  400C 00 00 00 00
 106  4010
 107  4010              ; this location #4010 stores last location used by basic extension
 108  4010              ; free memory after that point
 109  4010              FREEMEMPTR:
 110  4010 84 68         DW EXT_END
 111  4012
 112  4012              ; this location #4012 stores extension version in DAA format
 113  4012              ; first byte is major version and second minor
 114  4012              VERSION:
 115  4012 00 93         DB #00, #93
 116  4014
 117  4014              ; this location #4014 contains a jump to entry point for DEFUSR approach
 118  4014              ; if excluded it contains 3xRET so that sound player can be at aspecific spot
 119  4014               IF (0 == 1)
 120  4014 ~               JP DEFUSR_ENTRY
 121  4014               ELSE
 122  4014 C9          > RET
 122  4015 C9          > RET
 122  4016 C9          > RET
 123  4017               ENDIF
 124  4017
 125  4017              ; binary included AKG player compiled at #4017
 126  4017               IF (SOUND_CMDS == 1)
 127  4017              	INCBIN "bin/AKG.bin"
 128  4CF3              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF3              MAIN_PLAYER_START EQU 04017H
   2+ 4CF3              PLY_AKG_START EQU 04017H
   3+ 4CF3              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 04020H
   4+ 4CF3              PLY_AKG_INITSOUNDEFFECTS EQU 04020H
   5+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04024H
   6+ 4CF3              PLY_AKG_PLAYSOUNDEFFECT EQU 04024H
   7+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04025H
   8+ 4CF3              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04025H
   9+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 0404CH
  10+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 0404CH
  11+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 0405AH
  12+ 4CF3              PLY_AKG_PSES_PLAY EQU 04093H
  13+ 4CF3              PLY_AKG_PSES_READFIRSTBYTE EQU 0409CH
  14+ 4CF3              PLY_AKG_PSES_S_ENDORLOOP EQU 040B4H
  15+ 4CF3              PLY_AKG_PSES_S_LOOP EQU 040BFH
  16+ 4CF3              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C5H
  17+ 4CF3              PLY_AKG_PSES_NOTREACHED EQU 040D8H
  18+ 4CF3              PLY_AKG_PSES_HARDWAREONLY EQU 040DCH
  19+ 4CF3              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E3H
  20+ 4CF3              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F5H
  21+ 4CF3              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FFH
  22+ 4CF3              PLY_AKG_PSES_H_AFTERRETRIG EQU 04109H
  23+ 4CF3              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411DH
  24+ 4CF3              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 04122H
  25+ 4CF3              PLY_AKG_PSES_READHARDWAREPERIOD EQU 0412AH
  26+ 4CF3              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04135H
  27+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 04141H
  28+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04143H
  29+ 4CF3              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04149H
  30+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414DH
  31+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414DH
  32+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414FH
  33+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414FH
  34+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414FH
  35+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 04150H
  36+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 04151H
  37+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04155H
  38+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04155H
  39+ 4CF3              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04155H
  40+ 4CF3              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415DH
  41+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04165H
  42+ 4CF3              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04165H
  43+ 4CF3              PLY_AKG_INIT EQU 04165H
  44+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04165H
  45+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04193H
  46+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A7H
  47+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B9H
  48+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D8H
  49+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E5H
  50+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL EQU 041EBH
  51+ 4CF3              PLY_AKG_INITTABLE0 EQU 041EEH
  52+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EEH
  53+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04208H
  54+ 4CF3              PLY_AKG_INITTABLE0_END EQU 04208H
  55+ 4CF3              PLY_AKG_INITTABLE1 EQU 04208H
  56+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04208H
  57+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 0420CH
  58+ 4CF3              PLY_AKG_INITTABLE1_END EQU 0420CH
  59+ 4CF3              PLY_AKG_INITTABLEORA EQU 0420CH
  60+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 0420CH
  61+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04224H
  62+ 4CF3              PLY_AKG_INITTABLEORA_END EQU 04224H
  63+ 4CF3              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04224H
  64+ 4CF3              PLY_AKG_STOP EQU 04224H
  65+ 4CF3              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04236H
  66+ 4CF3              PLY_AKG_PLAY EQU 04236H
  67+ 4CF3              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423EH
  68+ 4CF3              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04244H
  69+ 4CF3              PLY_AKG_READLINKER EQU 04249H
  70+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04249H
  71+ 4CF3              PLY_AKG_READLINKER_PTLINKER EQU 04249H
  72+ 4CF3              PLY_AKG_READLINKER_NOLOOP EQU 04254H
  73+ 4CF3              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428DH
  74+ 4CF3              PLY_AKG_READLINE EQU 04290H
  75+ 4CF3              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 04290H
  76+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04296H
  77+ 4CF3              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04296H
  78+ 4CF3              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A3H
  79+ 4CF3              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A7H
  80+ 4CF3              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042AAH
  81+ 4CF3              PLY_AKG_SPEEDTRACK_END EQU 042ADH
  82+ 4CF3              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042ADH
  83+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B3H
  84+ 4CF3              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B3H
  85+ 4CF3              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042C0H
  86+ 4CF3              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C4H
  87+ 4CF3              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C7H
  88+ 4CF3              PLY_AKG_EVENTTRACK_END EQU 042CAH
  89+ 4CF3              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042CAH
  90+ 4CF3              PLY_AKG_CHANNEL1_READTRACK EQU 042D6H
  91+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D6H
  92+ 4CF3              PLY_AKG_CHANNEL1_PTTRACK EQU 042D6H
  93+ 4CF3              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042F1H
  94+ 4CF3              PLY_AKG_CHANNEL1_WAIT EQU 042FCH
  95+ 4CF3              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04303H
  96+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04303H
  97+ 4CF3              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04303H
  98+ 4CF3              PLY_AKG_CHANNEL1_NOTE EQU 0430CH
  99+ 4CF3              PLY_AKG_BASENOTEINDEX EQU 0430CH
 100+ 4CF3              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430EH
 101+ 4CF3              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430EH
 102+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431EH
 103+ 4CF3              PLY_AKG_INSTRUMENTSTABLE EQU 0431EH
 104+ 4CF3              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 04330H
 105+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 04340H
 106+ 4CF3              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04368H
 107+ 4CF3              PLY_AKG_CHANNEL1_READCELLEND EQU 0436BH
 108+ 4CF3              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 0436BH
 109+ 4CF3              PLY_AKG_CHANNEL2_READTRACK EQU 04377H
 110+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04377H
 111+ 4CF3              PLY_AKG_CHANNEL2_PTTRACK EQU 04377H
 112+ 4CF3              PLY_AKG_CHANNEL2_SMALLWAIT EQU 04392H
 113+ 4CF3              PLY_AKG_CHANNEL2_WAIT EQU 0439DH
 114+ 4CF3              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A4H
 115+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A4H
 116+ 4CF3              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A4H
 117+ 4CF3              PLY_AKG_CHANNEL2_NOTE EQU 043ADH
 118+ 4CF3              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043B2H
 119+ 4CF3              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043B2H
 120+ 4CF3              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D4H
 121+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E4H
 122+ 4CF3              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 0440CH
 123+ 4CF3              PLY_AKG_CHANNEL2_READCELLEND EQU 0440FH
 124+ 4CF3              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440FH
 125+ 4CF3              PLY_AKG_CHANNEL3_READTRACK EQU 0441BH
 126+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 0441BH
 127+ 4CF3              PLY_AKG_CHANNEL3_PTTRACK EQU 0441BH
 128+ 4CF3              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04436H
 129+ 4CF3              PLY_AKG_CHANNEL3_WAIT EQU 04441H
 130+ 4CF3              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04448H
 131+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04448H
 132+ 4CF3              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04448H
 133+ 4CF3              PLY_AKG_CHANNEL3_NOTE EQU 04451H
 134+ 4CF3              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04456H
 135+ 4CF3              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04456H
 136+ 4CF3              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04478H
 137+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04488H
 138+ 4CF3              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044B0H
 139+ 4CF3              PLY_AKG_CHANNEL3_READCELLEND EQU 044B3H
 140+ 4CF3              PLY_AKG_CURRENTSPEED EQU 044B3H
 141+ 4CF3              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B5H
 142+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B8H
 143+ 4CF3              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B8H
 144+ 4CF3              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044BBH
 145+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BEH
 146+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BEH
 147+ 4CF3              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044CAH
 148+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044D1H
 149+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D4H
 150+ 4CF3              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044DAH
 151+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DDH
 152+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DDH
 153+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044EBH
 154+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044F0H
 155+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044FBH
 156+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FEH
 157+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FEH
 158+ 4CF3              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 04501H
 159+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04504H
 160+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04504H
 161+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450DH
 162+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04517H
 163+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 0451AH
 164+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 0451AH
 165+ 4CF3              PLY_AKG_CHANNEL1_PITCH EQU 0451AH
 166+ 4CF3              PLY_AKG_CHANNEL1_ISPITCH EQU 0451DH
 167+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 04522H
 168+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACK EQU 04522H
 169+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04526H
 170+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04528H
 171+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 0452AH
 172+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 04531H
 173+ 4CF3              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 04532H
 174+ 4CF3              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04535H
 175+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04535H
 176+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 04551H
 177+ 4CF3              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 04551H
 178+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455EH
 179+ 4CF3              PLY_AKG_CHANNEL1_GLIDEOVER EQU 04562H
 180+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 04572H
 181+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 04572H
 182+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04573H
 183+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04574H
 184+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04576H
 185+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04576H
 186+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04576H
 187+ 4CF3              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04577H
 188+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04578H
 189+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 0457AH
 190+ 4CF3              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 0457AH
 191+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 0457AH
 192+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 0457AH
 193+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 0457AH
 194+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457DH
 195+ 4CF3              PLY_AKG_CHANNEL1_PITCH_END EQU 0457FH
 196+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04587H
 197+ 4CF3              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04587H
 198+ 4CF3              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 0458AH
 199+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458DH
 200+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458DH
 201+ 4CF3              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04599H
 202+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 045A0H
 203+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A3H
 204+ 4CF3              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A9H
 205+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045ACH
 206+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045ACH
 207+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045BAH
 208+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BFH
 209+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045CAH
 210+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CDH
 211+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CDH
 212+ 4CF3              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045D0H
 213+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D3H
 214+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D3H
 215+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045DCH
 216+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E6H
 217+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E9H
 218+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E9H
 219+ 4CF3              PLY_AKG_CHANNEL2_PITCH EQU 045E9H
 220+ 4CF3              PLY_AKG_CHANNEL2_ISPITCH EQU 045ECH
 221+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045F1H
 222+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045F1H
 223+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F5H
 224+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F7H
 225+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F9H
 226+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 04600H
 227+ 4CF3              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 04601H
 228+ 4CF3              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04604H
 229+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04604H
 230+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 04620H
 231+ 4CF3              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 04620H
 232+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462DH
 233+ 4CF3              PLY_AKG_CHANNEL2_GLIDEOVER EQU 04631H
 234+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 04641H
 235+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 04641H
 236+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 04642H
 237+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04643H
 238+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04645H
 239+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04645H
 240+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04645H
 241+ 4CF3              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04646H
 242+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04647H
 243+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04649H
 244+ 4CF3              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04649H
 245+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04649H
 246+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04649H
 247+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04649H
 248+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_END EQU 0464CH
 249+ 4CF3              PLY_AKG_CHANNEL2_PITCH_END EQU 0464EH
 250+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04656H
 251+ 4CF3              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04656H
 252+ 4CF3              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04659H
 253+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 0465CH
 254+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 0465CH
 255+ 4CF3              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04668H
 256+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466FH
 257+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 04672H
 258+ 4CF3              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04678H
 259+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 0467BH
 260+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 0467BH
 261+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04689H
 262+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468EH
 263+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04699H
 264+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 0469CH
 265+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 0469CH
 266+ 4CF3              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469FH
 267+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 046A2H
 268+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE EQU 046A2H
 269+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046ABH
 270+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B5H
 271+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B8H
 272+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B8H
 273+ 4CF3              PLY_AKG_CHANNEL3_PITCH EQU 046B8H
 274+ 4CF3              PLY_AKG_CHANNEL3_ISPITCH EQU 046BBH
 275+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046C0H
 276+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046C0H
 277+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C4H
 278+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C6H
 279+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C8H
 280+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CFH
 281+ 4CF3              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046D0H
 282+ 4CF3              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D3H
 283+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D3H
 284+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046EFH
 285+ 4CF3              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046EFH
 286+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046FCH
 287+ 4CF3              PLY_AKG_CHANNEL3_GLIDEOVER EQU 04700H
 288+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 04710H
 289+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 04710H
 290+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 04711H
 291+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 04712H
 292+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04714H
 293+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04714H
 294+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04714H
 295+ 4CF3              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04715H
 296+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04716H
 297+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04718H
 298+ 4CF3              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04718H
 299+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04718H
 300+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04718H
 301+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04718H
 302+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_END EQU 0471BH
 303+ 4CF3              PLY_AKG_CHANNEL3_PITCH_END EQU 0471DH
 304+ 4CF3              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04729H
 305+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04729H
 306+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04729H
 307+ 4CF3              PLY_AKG_CHANNEL1_TRACKNOTE EQU 0472CH
 308+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472EH
 309+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04734H
 310+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04737H
 311+ 4CF3              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04737H
 312+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 0473AH
 313+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04743H
 314+ 4CF3              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 0474BH
 315+ 4CF3              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04758H
 316+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04758H
 317+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04758H
 318+ 4CF3              PLY_AKG_CHANNEL2_TRACKNOTE EQU 0475BH
 319+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475DH
 320+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04763H
 321+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04766H
 322+ 4CF3              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04766H
 323+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04769H
 324+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 04772H
 325+ 4CF3              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 0477AH
 326+ 4CF3              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04788H
 327+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04788H
 328+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04788H
 329+ 4CF3              PLY_AKG_CHANNEL3_TRACKNOTE EQU 0478BH
 330+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478DH
 331+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04793H
 332+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04796H
 333+ 4CF3              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04796H
 334+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04799H
 335+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 047A2H
 336+ 4CF3              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047AAH
 337+ 4CF3              PLY_AKG_SENDPSGREGISTERS EQU 047B9H
 338+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047C1H
 339+ 4CF3              PLY_AKG_PSGREG01_INSTR EQU 047C1H
 340+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047D1H
 341+ 4CF3              PLY_AKG_PSGREG23_INSTR EQU 047D1H
 342+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047E2H
 343+ 4CF3              PLY_AKG_PSGREG45_INSTR EQU 047E2H
 344+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F3H
 345+ 4CF3              PLY_AKG_PSGREG6_8_INSTR EQU 047F3H
 346+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04804H
 347+ 4CF3              PLY_AKG_PSGREG9_10_INSTR EQU 04804H
 348+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04815H
 349+ 4CF3              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04815H
 350+ 4CF3              PLY_AKG_PSGREG13_OLDVALUE EQU 0482AH
 351+ 4CF3              PLY_AKG_RETRIG EQU 0482CH
 352+ 4CF3              PLY_AKG_PSGREG13_INSTR EQU 0482EH
 353+ 4CF3              PLY_AKG_PSGREG13_END EQU 0483DH
 354+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483DH
 355+ 4CF3              PLY_AKG_SAVESP EQU 0483DH
 356+ 4CF3              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 04841H
 357+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTS EQU 04849H
 358+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04856H
 359+ 4CF3              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04856H
 360+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485EH
 361+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 0486BH
 362+ 4CF3              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 0486BH
 363+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTS EQU 04873H
 364+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487EH
 365+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS EQU 0487EH
 366+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488DH
 367+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488DH
 368+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04894H
 369+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A4H
 370+ 4CF3              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A4H
 371+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048ABH
 372+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048ABH
 373+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048AEH
 374+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B7H
 375+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B7H
 376+ 4CF3              PLY_AKG_READINSTRUMENTCELL EQU 048BDH
 377+ 4CF3              PLY_AKG_NOSOFTNOHARD EQU 048CAH
 378+ 4CF3              PLY_AKG_NSNH_NONOISE EQU 048DFH
 379+ 4CF3              PLY_AKG_SOFT EQU 048E2H
 380+ 4CF3              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E9H
 381+ 4CF3              PLY_AKG_S_NOTSIMPLE EQU 048F1H
 382+ 4CF3              PLY_AKG_S_AFTERSIMPLETEST EQU 048F4H
 383+ 4CF3              PLY_AKG_HARDTOSOFT EQU 04901H
 384+ 4CF3              PLY_AKG_HS_JUMPRATIO EQU 0490CH
 385+ 4CF3              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04939H
 386+ 4CF3              PLY_AKG_ENDWITHOUTLOOP EQU 0493BH
 387+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 0493BH
 388+ 4CF3              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 0493BH
 389+ 4CF3              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04943H
 390+ 4CF3              PLY_AKG_SH_JUMPRATIO EQU 04950H
 391+ 4CF3              PLY_AKG_SH_JUMPRATIOEND EQU 04971H
 392+ 4CF3              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 04980H
 393+ 4CF3              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04986H
 394+ 4CF3              PLY_AKG_H_OR_ENDWITHLOOP EQU 049A0H
 395+ 4CF3              PLY_AKG_H_RETRIGEND EQU 049B2H
 396+ 4CF3              PLY_AKG_H_AFTERRETRIG EQU 049B3H
 397+ 4CF3              PLY_AKG_ENDWITHLOOP EQU 049C5H
 398+ 4CF3              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049CCH
 399+ 4CF3              PLY_AKG_S_OR_H_NEXTBYTE EQU 049E2H
 400+ 4CF3              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049F0H
 401+ 4CF3              PLY_AKG_S_OR_H_AFTERPITCH EQU 04A00H
 402+ 4CF3              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0EH
 403+ 4CF3              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1DH
 404+ 4CF3              PLY_AKG_SHOHS_RETRIGEND EQU 04A2CH
 405+ 4CF3              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2DH
 406+ 4CF3              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3FH
 407+ 4CF3              PLY_AKG_EFFECTTABLE EQU 04A4DH
 408+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4DH
 409+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A71H
 410+ 4CF3              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A71H
 411+ 4CF3              PLY_AKG_EFFECT_RESET EQU 04A74H
 412+ 4CF3              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A76H
 413+ 4CF3              PLY_AKG_EFFECT_VOLUME EQU 04A91H
 414+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9DH
 415+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA3H
 416+ 4CF3              PLY_AKG_ARPEGGIOSTABLE EQU 04AA3H
 417+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04ACAH
 418+ 4CF3              PLY_AKG_EFFECT_PITCHTABLE EQU 04AD1H
 419+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD7H
 420+ 4CF3              PLY_AKG_PITCHESTABLE EQU 04AD7H
 421+ 4CF3              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFEH
 422+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B05H
 423+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B16H
 424+ 4CF3              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1DH
 425+ 4CF3              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2DH
 426+ 4CF3              PLY_AKG_EFFECT_PITCHUP EQU 04B42H
 427+ 4CF3              PLY_AKG_EFFECT_PITCHSTOP EQU 04B54H
 428+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B5BH
 429+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B85H
 430+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B85H
 431+ 4CF3              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9EH
 432+ 4CF3              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9EH
 433+ 4CF3              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BB0H
 434+ 4CF3              PLY_AKG_EFFECT_LEGATO EQU 04BC6H
 435+ 4CF3              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BDAH
 436+ 4CF3              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BE2H
 437+ 4CF3              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BEAH
 438+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BF2H
 439+ 4CF3              PLY_AKG_EVENT EQU 04BF2H
 440+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF3H
 441+ 4CF3              PLY_AKG_PERIODTABLE EQU 04BF3H
 442+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF3H
 443+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF3H
 444+ 4CF3              PLY_AKG_PERIODTABLE_END EQU 04CF3H
 445+ 4CF3              PLY_AKG_END EQU 04CF3H
 446+ 4CF3              MAIN_PLAYER_END EQU 04CF3H
 447+ 4CF3              TESTEREND EQU 04CF3H
 448+ 4CF3
# file closed: ./symbol/AKG.sym
 129  4CF3               ENDIF
 130  4CF3
 131  4CF3               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
   1+ 4CF3              ORIG.HTIMI:
   2+ 4CF3 00 00 00 00  	DB 0, 0, 0, 0, 0
   2+ 4CF7 00
   3+ 4CF8               EXPORT ORIG.HTIMI
   4+ 4CF8
   5+ 4CF8              ; *******************************************************************************************************
   6+ 4CF8              ; interrupt handler when page 0 enabled
   7+ 4CF8              ; we are here only if one of the extended basic commands have paged in page 0
   8+ 4CF8              ; which means we arrived from BASIC so page 2 is already good
   9+ 4CF8              VBLANK:
  10+ 4CF8              	EXPORT VBLANK
  11+ 4CF8
  12+ 4CF8 F5               PUSH AF
  13+ 4CF9              	; is VDP originator ?
  14+ 4CF9 DB 99        	IN	A, (099H)
  15+ 4CFB A7           	AND	A
  16+ 4CFC F2 2A 4D     	JP P, .EXIT
  17+ 4CFF
  18+ 4CFF               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  19+ 4CFF C5               PUSH BC
  20+ 4D00 D5               PUSH DE
  21+ 4D01 E5               PUSH HL
  22+ 4D02 08               EX AF, AF'
  23+ 4D03 D9               EXX
  24+ 4D04 F5               PUSH AF
  25+ 4D05 C5               PUSH BC
  26+ 4D06 D5               PUSH DE
  27+ 4D07 E5               PUSH HL
  28+ 4D08 DD E5            PUSH IX
  29+ 4D0A FD E5            PUSH IY
  30+ 4D0C
  31+ 4D0C               IF (SPRITE_CMDS == 1)
  32+ 4D0C CD 64 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  33+ 4D0F               ENDIF
  34+ 4D0F
  35+ 4D0F               IF (SOUND_CMDS == 1)
  36+ 4D0F 3A D1 58     	LD A, (SOUND_ENABLED)
  37+ 4D12 B7           	OR A
  38+ 4D13 C4 36 42     	CALL NZ,PLY_AKG_PLAY
  39+ 4D16               ENDIF
  40+ 4D16
  41+ 4D16                  ; increase JIFFY
  42+ 4D16 2A 9E FC         LD HL,(JIFFY)
  43+ 4D19 23               INC HL
  44+ 4D1A 22 9E FC         LD (JIFFY),HL
  45+ 4D1D
  46+ 4D1D FD E1            POP IY
  47+ 4D1F DD E1            POP IX
  48+ 4D21 E1               POP HL
  49+ 4D22 D1               POP DE
  50+ 4D23 C1               POP BC
  51+ 4D24 F1               POP AF
  52+ 4D25 08               EX AF, AF'
  53+ 4D26 D9               EXX
  54+ 4D27 E1               POP HL
  55+ 4D28 D1               POP DE
  56+ 4D29 C1               POP BC
  57+ 4D2A               ENDIF
  58+ 4D2A
  59+ 4D2A              .EXIT:
  60+ 4D2A F1           	POP AF
  61+ 4D2B FB           	EI
  62+ 4D2C ED 4D        	RETI
  63+ 4D2E              ; *******************************************************************************************************
  64+ 4D2E
  65+ 4D2E              ; *******************************************************************************************************
  66+ 4D2E              ; H.TIMI function
  67+ 4D2E              ; we can end up here from anywhere so page in both page 0 and 2
  68+ 4D2E              MBGE_HTIMI:
  69+ 4D2E               EXPORT MBGE_HTIMI
  70+ 4D2E
  71+ 4D2E               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  72+ 4D2E
  73+ 4D2E F5           	PUSH AF
  74+ 4D2F
  75+ 4D2F              	; enable page 2
  76+ 4D2F 3E 02            LD A, 2
  77+ 4D31 CD 9A 66         CALL GET_PAGE_INFO
  78+ 4D34 C5               PUSH BC
  79+ 4D35 D5               PUSH DE
  80+ 4D36 3A 43 F3         LD A, (RAMAD2)
  81+ 4D39 26 80            LD H, 080H
  82+ 4D3B CD E1 66         CALL LOCAL_ENASLT
  83+ 4D3E              	; enable page 0
  84+ 4D3E AF               XOR A
  85+ 4D3F CD 9A 66         CALL GET_PAGE_INFO
  86+ 4D42 C5               PUSH BC
  87+ 4D43 D5               PUSH DE
  88+ 4D44 3A 41 F3         LD A, (RAMAD0)
  89+ 4D47 26 00            LD H, 0
  90+ 4D49 CD E1 66         CALL LOCAL_ENASLT
  91+ 4D4C
  92+ 4D4C               IF (SPRITE_CMDS == 1)
  93+ 4D4C CD 64 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  94+ 4D4F               ENDIF
  95+ 4D4F
  96+ 4D4F               IF (SOUND_CMDS == 1)
  97+ 4D4F 3A D1 58     	LD A, (SOUND_ENABLED)
  98+ 4D52 B7           	OR A
  99+ 4D53 C4 36 42     	CALL NZ,PLY_AKG_PLAY
 100+ 4D56               ENDIF
 101+ 4D56
 102+ 4D56              	; restore page 0
 103+ 4D56 D1               POP DE
 104+ 4D57 C1               POP BC
 105+ 4D58 CD D1 66         CALL RESTORE_PAGE_INFO
 106+ 4D5B              	; restore page 2
 107+ 4D5B D1               POP DE
 108+ 4D5C C1               POP BC
 109+ 4D5D CD D1 66         CALL RESTORE_PAGE_INFO
 110+ 4D60
 111+ 4D60 F1           	POP AF
 112+ 4D61               ENDIF
 113+ 4D61 C3 F3 4C     	JP ORIG.HTIMI
 114+ 4D64              ; *******************************************************************************************************
 115+ 4D64
 116+ 4D64              ; *******************************************************************************************************
 117+ 4D64              ; function checks if the sprite system is initialized and what screen mode we are running
 118+ 4D64              ; also checks if some VRAM modifying command is running
 119+ 4D64              ; when that checks out calls sprite updates and animation processing
 120+ 4D64              ; if in an unsupported mode disables sprite handling
 121+ 4D64              PROCESS_SPRITES_AND_ANIMATIONS:
 122+ 4D64              	; check if initialized
 123+ 4D64 3A 86 4D     	LD A, (SPRATR_INIT_STATUS)
 124+ 4D67 B7           	OR A
 125+ 4D68 C8           	RET Z
 126+ 4D69              	; check screen mode
 127+ 4D69 3A AF FC     	LD A, (SCRMOD)
 128+ 4D6C 3D           	DEC A
 129+ 4D6D 28 08        	JR Z, .L0 ; screen 1
 130+ 4D6F 3D           	DEC A
 131+ 4D70 28 05            JR Z, .L0 ; screen 2
 132+ 4D72              	; unsupported screen mode, disable
 133+ 4D72 AF               XOR A
 134+ 4D73 32 86 4D         LD (SPRATR_INIT_STATUS),A
 135+ 4D76 C9               RET
 136+ 4D77              .L0:
 137+ 4D77                  ; check if anyone else is working with VRAM
 138+ 4D77 3A 8D 64         LD A,(VRAM_UPDATE_IN_PROGRESS)
 139+ 4D7A B7               OR A
 140+ 4D7B C0               RET NZ
 141+ 4D7C
 142+ 4D7C CD 9C 4D         CALL SPRATR_UPDATE
 143+ 4D7F
 144+ 4D7F               IF (ANIM_CMDS == 1)
 145+ 4D7F CD 7D 55         CALL PROCESS_ANIMATIONS
 146+ 4D82 CD 48 57         CALL PROCESS_AUTOSGAMS
 147+ 4D85               ENDIF
 148+ 4D85 C9               RET
 149+ 4D86              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
 132  4D86
 133  4D86               IF (SPRITE_CMDS == 1)
 134  4D86               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4D86              ; commands and variables related to sprites
   2+ 4D86
   3+ 4D86              SPRATR_INIT_STATUS:
   4+ 4D86 00            DB 0
   5+ 4D87              SPRATR_UPDATE_FLAG:
   6+ 4D87 00 00         DW 0
   7+ 4D89              SPRATR_DATA:
   8+ 4D89 00 00         DW 0
   9+ 4D8B              SPRFLICKER_ENABLED:
  10+ 4D8B 00            DB 0
  11+ 4D8C              ; to support sprite flicker
  12+ 4D8C              FLICKER:
  13+ 4D8C 00            DB 0
  14+ 4D8D              NUM_SPRITES_HANDLED:
  15+ 4D8D 20            DB 32
  16+ 4D8E
  17+ 4D8E              ; to temporarily store stack pointer
  18+ 4D8E              TMPSP:
  19+ 4D8E 00 00         DW 0
  20+ 4D90
  21+ 4D90              ; *******************************************************************************************************
  22+ 4D90              ; helper function gets pointer to n-th entry in sprite attributes
  23+ 4D90              ; changes HL,DE
  24+ 4D90              GETnthSPRATTR:
  25+ 4D90 26 00            LD H,0
  26+ 4D92 6F               LD L,A
  27+ 4D93 CD 96 66         CALL HLx8
  28+ 4D96 ED 5B 89 4D      LD DE,(SPRATR_DATA)
  29+ 4D9A 19               ADD HL,DE
  30+ 4D9B C9               RET
  31+ 4D9C              ; *******************************************************************************************************
  32+ 4D9C
  33+ 4D9C              ; *******************************************************************************************************
  34+ 4D9C              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  35+ 4D9C              ; struct {
  36+ 4D9C              ; DW y
  37+ 4D9C              ; DW x
  38+ 4D9C              ; DW pattern (0-63)
  39+ 4D9C              ; DW color
  40+ 4D9C              ; } [32]
  41+ 4D9C              ; will hide sprites whose location is outside of visible area
  42+ 4D9C              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  43+ 4D9C              ; modifies AF, AF', BC, DE, HL, IX
  44+ 4D9C              SPRATR_UPDATE:
  45+ 4D9C              	; check if update requested
  46+ 4D9C 2A 87 4D     	LD HL, (SPRATR_UPDATE_FLAG)
  47+ 4D9F 7E           	LD A, (HL)
  48+ 4DA0 B7           	OR A
  49+ 4DA1 C8           	RET Z
  50+ 4DA2
  51+ 4DA2 DD 21 8D 4D  	LD IX,NUM_SPRITES_HANDLED
  52+ 4DA6 DD 46 00     	LD B, (IX) ; sprite number
  53+ 4DA9 0E 98        	LD C, #98 ; register for vdp data output
  54+ 4DAB              	; set VDP address
  55+ 4DAB 3A AF FC         LD A,(SCRMOD)
  56+ 4DAE 3D               DEC A
  57+ 4DAF 20 05            JR NZ,.L4
  58+ 4DB1 2A C3 F3         LD HL, (T32ATR)
  59+ 4DB4 18 03            JR .L5
  60+ 4DB6              .L4:
  61+ 4DB6 2A CD F3         LD HL, (GRPATR)
  62+ 4DB9              .L5:
  63+ 4DB9 3A 8B 4D     	LD A, (SPRFLICKER_ENABLED)
  64+ 4DBC B7           	OR A
  65+ 4DBD 28 03        	JR Z, .L3
  66+ 4DBF 3A 8C 4D     	LD A, (FLICKER)
  67+ 4DC2              .L3:
  68+ 4DC2 5F           	LD E, A
  69+ 4DC3 08           	EX AF, AF'
  70+ 4DC4 7B           	LD A, E
  71+ 4DC5 87           	ADD A, A
  72+ 4DC6 87           	ADD A, A
  73+ 4DC7 16 00        	LD D, 0
  74+ 4DC9 5F           	LD E, A
  75+ 4DCA 19           	ADD HL, DE
  76+ 4DCB CD 77 66     	CALL SETWRT_LOCAL_WRITE
  77+ 4DCE ED 73 8E 4D  	LD (TMPSP), SP
  78+ 4DD2 ED 7B 89 4D  	LD SP, (SPRATR_DATA)
  79+ 4DD6
  80+ 4DD6              .LOOP:
  81+ 4DD6 E1           	POP HL
  82+ 4DD7 24           	INC H
  83+ 4DD8 28 0D        	JR Z, .L1 ; negative number between -256 and -1
  84+ 4DDA 25           	DEC H
  85+ 4DDB 20 15        	JR NZ, .OUT3 ; sprite vertically can't be visible
  86+ 4DDD 7D           	LD A, L
  87+ 4DDE FE C0        	CP 192
  88+ 4DE0 30 10        	JR NC, .OUT3
  89+ 4DE2 3D           	DEC A ; due to VDP rule that top of screen is -1
  90+ 4DE3 57           	LD D, A
  91+ 4DE4 C3 0B 4E     	JP .X
  92+ 4DE7              .L1:
  93+ 4DE7 7D           	LD A, L
  94+ 4DE8 C6 10        	ADD 16
  95+ 4DEA FA F2 4D     	JP M, .OUT3 ; below -16
  96+ 4DED 2D           	DEC L ; due to VDP rule that top of screen is -1
  97+ 4DEE 55           	LD D, L
  98+ 4DEF C3 0B 4E     	JP .X
  99+ 4DF2              .OUT3:
 100+ 4DF2 E1           	POP HL ; skip x value
 101+ 4DF3              .OUT2:
 102+ 4DF3 E1           	POP HL ; skip pattern
 103+ 4DF4 E1           	POP HL ; skip color
 104+ 4DF5 3E D1        	LD A, #D1
 105+ 4DF7 ED 79        	OUT (C), A ; sprite hidden
 106+ 4DF9 00          > NOP
 106+ 4DFA 00          > NOP
 106+ 4DFB 00          > NOP
 107+ 4DFC ED 79        	OUT (C), A ; value unimportant
 108+ 4DFE 00          > NOP
 108+ 4DFF 00          > NOP
 108+ 4E00 00          > NOP
 109+ 4E01 ED 79        	OUT (C), A ; value unimportant
 110+ 4E03 00          > NOP
 110+ 4E04 00          > NOP
 110+ 4E05 00          > NOP
 111+ 4E06 ED 79        	OUT (C), A ; value unimportant
 112+ 4E08 C3 36 4E     	JP .NEXT
 113+ 4E0B              .X:
 114+ 4E0B E1           	POP HL
 115+ 4E0C 24           	INC H
 116+ 4E0D 28 08        	JR Z, .L2
 117+ 4E0F 25           	DEC H
 118+ 4E10 20 E1        	JR NZ, .OUT2
 119+ 4E12 1E 00        	LD E, 0 ; EC bit
 120+ 4E14 C3 20 4E     	JP .XY
 121+ 4E17              .L2:
 122+ 4E17 7D           	LD A, L
 123+ 4E18 C6 20        	ADD 32
 124+ 4E1A FA F3 4D     	JP M, .OUT2
 125+ 4E1D 6F           	LD L, A
 126+ 4E1E 1E 80        	LD E, #80
 127+ 4E20              .XY:
 128+ 4E20 ED 51        	OUT (C), D
 129+ 4E22 3A E0 F3     	LD A, (REG1SAV)
 130+ 4E25 E6 02        	AND 2
 131+ 4E27 ED 69        	OUT (C), L
 132+ 4E29 E1           	POP HL ; pattern
 133+ 4E2A 7D           	LD A, L
 134+ 4E2B 28 02        	JR Z, .SMALLSPRITES
 135+ 4E2D 87           	ADD A, A
 136+ 4E2E 87           	ADD A, A ; needs to go at 4x
 137+ 4E2F              .SMALLSPRITES:
 138+ 4E2F D3 98        	OUT (#98), A
 139+ 4E31 E1           	POP HL ; color
 140+ 4E32 7D           	LD A, L
 141+ 4E33 B3           	OR E
 142+ 4E34 D3 98        	OUT (#98), A
 143+ 4E36              .NEXT:
 144+ 4E36 08           	EX AF, AF'
 145+ 4E37 3C           	INC A ; increase current sprite
 146+ 4E38 DD BE 00     	CP (IX) ; compare to maximum handled
 147+ 4E3B C2 5B 4E     	JP NZ, .NEXT2 ; continue if not over
 148+ 4E3E AF           	XOR A ; back to zero
 149+ 4E3F 08           	EX AF, AF'
 150+ 4E40 3A AF FC         LD A,(SCRMOD)
 151+ 4E43 3D               DEC A
 152+ 4E44 20 05            JR NZ,.L6
 153+ 4E46 2A C3 F3         LD HL, (T32ATR)
 154+ 4E49 18 03            JR .L7
 155+ 4E4B              .L6:
 156+ 4E4B 2A CD F3         LD HL, (GRPATR)
 157+ 4E4E              .L7:
 158+ 4E4E              	; CALL SETWRT_LOCAL not allowed as SP modified
 159+ 4E4E 7D           	LD	A, L
 160+ 4E4F D3 99        	OUT	(099H), A
 161+ 4E51 7C           	LD	A, H
 162+ 4E52 E6 3F        	AND	03FH
 163+ 4E54 F6 40        	OR	040H
 164+ 4E56 D3 99        	OUT	(099H), A
 165+ 4E58 C3 5C 4E     	JP .NEXT3
 166+ 4E5B              .NEXT2:
 167+ 4E5B 08           	EX AF, AF'
 168+ 4E5C              .NEXT3:
 169+ 4E5C 05           	DEC B
 170+ 4E5D C2 D6 4D     	JP NZ, .LOOP
 171+ 4E60 08           	EX AF, AF'
 172+ 4E61 3C           	INC A ; increase flicker to start at the next one on next vblank
 173+ 4E62 DD BE 00     	CP (IX)
 174+ 4E65 20 01        	JR NZ,.L8
 175+ 4E67 AF           	XOR A
 176+ 4E68              .L8:
 177+ 4E68 32 8C 4D     	LD (FLICKER), A
 178+ 4E6B
 179+ 4E6B ED 7B 8E 4D  	LD SP, (TMPSP)
 180+ 4E6F 2A 87 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 181+ 4E72 36 00        	LD (HL), 0 ; zero out update flag
 182+ 4E74 C9           	RET
 183+ 4E75              ; *******************************************************************************************************
 184+ 4E75
 185+ 4E75               IF (1 == 1)
 186+ 4E75              ; *******************************************************************************************************
 187+ 4E75              ; function to handle CALL SPRENABLE basic extension
 188+ 4E75              ; initializes sprites handler
 189+ 4E75              ; _SPRENABLE ( INT[3][31] variable sprites_attributes,
 190+ 4E75              ;			   INT variable update_variable,
 191+ 4E75              ;			   BYTE sprite_flicker_enabled,
 192+ 4E75              ;			   BYTE num_sprites_handled )
 193+ 4E75              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA, SPRFLICKER_ENABLED and NUM_SPRITES_HANDLED
 194+ 4E75              SPRENABLE:
 195+ 4E75              	; opening (
 196+ 4E75 CD A9 67     	CALL CHKCHAR
 197+ 4E78 28           	DB '('
 198+ 4E79              	; get address of sprite attribute table DIM SA%(3,31)
 199+ 4E79 3E 02        	LD A,2
 200+ 4E7B 06 02        	LD B,2
 201+ 4E7D 11 20 04     	LD DE,#0420
 202+ 4E80 CD 0E 68     	CALL GET_BASIC_ARRAY_DATA_POINTER
 203+ 4E83 ED 43 89 4D  	LD (SPRATR_DATA), BC
 204+ 4E87              	; comma
 205+ 4E87 CD A9 67     	CALL CHKCHAR
 206+ 4E8A 2C           	DB ','
 207+ 4E8B              	; get address of sprite update flag
 208+ 4E8B DD 21 A4 5E  	LD IX, PTRGET
 209+ 4E8F CD 59 01     	CALL CALBAS
 210+ 4E92 ED 53 87 4D  	LD (SPRATR_UPDATE_FLAG), DE
 211+ 4E96              	; comma
 212+ 4E96 CD A9 67     	CALL CHKCHAR
 213+ 4E99 2C           	DB ','
 214+ 4E9A              	; get flicker enabled flag
 215+ 4E9A DD 21 1C 52  	LD IX, GETBYT
 216+ 4E9E CD 59 01     	CALL CALBAS
 217+ 4EA1 32 8B 4D     	LD (SPRFLICKER_ENABLED), A
 218+ 4EA4              	; comma
 219+ 4EA4 CD A9 67     	CALL CHKCHAR
 220+ 4EA7 2C           	DB ','
 221+ 4EA8              	; get number of handled sprites
 222+ 4EA8 DD 21 1C 52  	LD IX, GETBYT
 223+ 4EAC CD 59 01     	CALL CALBAS
 224+ 4EAF 32 8D 4D     	LD (NUM_SPRITES_HANDLED),A
 225+ 4EB2              	; ending )
 226+ 4EB2 CD A9 67     	CALL CHKCHAR
 227+ 4EB5 29           	DB ')'
 228+ 4EB6              .L0:
 229+ 4EB6 3E 01        	LD A, 1
 230+ 4EB8 32 86 4D     	LD (SPRATR_INIT_STATUS), A
 231+ 4EBB C9           	RET
 232+ 4EBC              ; *******************************************************************************************************
 233+ 4EBC               ENDIF
 234+ 4EBC
 235+ 4EBC               IF (0 == 1)
 236+ 4EBC ~            ; same as SPRENABLE but for DEFUSR approach
 237+ 4EBC ~            ; input IX=pointer to input array, real data from +2
 238+ 4EBC ~            ; +2 = pointer to sprite attributes array data
 239+ 4EBC ~            ; +4 = pointer to sprite update variable
 240+ 4EBC ~            ; +6 = flicker flag
 241+ 4EBC ~            ; +8 = number of sprites to handle
 242+ 4EBC ~            SPRENABLE_DEFUSR:
 243+ 4EBC ~            	LD L,(IX+2)
 244+ 4EBC ~            	LD H,(IX+3)
 245+ 4EBC ~            	LD (SPRATR_DATA),HL
 246+ 4EBC ~            	LD L,(IX+4)
 247+ 4EBC ~            	LD H,(IX+5)
 248+ 4EBC ~            	LD (SPRATR_UPDATE_FLAG),HL
 249+ 4EBC ~            	LD A,(IX+6)
 250+ 4EBC ~            	LD (SPRFLICKER_ENABLED),A
 251+ 4EBC ~            	LD A,(IX+8)
 252+ 4EBC ~            	LD (NUM_SPRITES_HANDLED),A
 253+ 4EBC ~            	LD A, 1
 254+ 4EBC ~            	LD (SPRATR_INIT_STATUS), A
 255+ 4EBC ~            	XOR A ; success
 256+ 4EBC ~            	RET
 257+ 4EBC               ENDIF
 258+ 4EBC
 259+ 4EBC               IF (0 + 1 > 0)
 260+ 4EBC              ; *******************************************************************************************************
 261+ 4EBC              ; function to handle CALL SPRDISABLE basic extension
 262+ 4EBC              ; disables sprites handling
 263+ 4EBC              ; _SPRDISABLE
 264+ 4EBC              ; resets variable SPRATR_INIT_STATUS
 265+ 4EBC              SPRDISABLE:
 266+ 4EBC              SPRDISABLE_DEFUSR:
 267+ 4EBC AF           	XOR A
 268+ 4EBD 32 86 4D     	LD (SPRATR_INIT_STATUS), A
 269+ 4EC0 C9           	RET
 270+ 4EC1              ; *******************************************************************************************************
 271+ 4EC1               ENDIF
 272+ 4EC1
 273+ 4EC1              ; *******************************************************************************************************
 274+ 4EC1              ; function to handle CALL SPRSET basic extension
 275+ 4EC1              ; sets position, and optionally pattern and color of sprite
 276+ 4EC1              ; _SPRSET ( BYTE sprite_num , valid 0-31
 277+ 4EC1              ;			INT x,
 278+ 4EC1              ;			INT y,
 279+ 4EC1              ;			INT pattern, valid 0-63, otherwise ignored
 280+ 4EC1              ;			INT color, valid 0-15, otherwise ignored
 281+ 4EC1              ;SPRSET:
 282+ 4EC1              ;	LD A, (SPRATR_INIT_STATUS)
 283+ 4EC1              ;	OR A
 284+ 4EC1              ;	JR NZ, .L1
 285+ 4EC1              ;	LD E, 5 ; illegal function call
 286+ 4EC1              ;	JP THROW_ERROR
 287+ 4EC1              ;.L1:
 288+ 4EC1              ;	; opening (
 289+ 4EC1              ;	CALL CHKCHAR
 290+ 4EC1              ;	DB '('
 291+ 4EC1              ;	; get sprite number
 292+ 4EC1              ;	LD IX, GETBYT
 293+ 4EC1              ;	CALL CALBAS
 294+ 4EC1              ;	PUSH AF
 295+ 4EC1              ;	; comma
 296+ 4EC1              ;	CALL CHKCHAR
 297+ 4EC1              ;	DB ','
 298+ 4EC1              ;	; get x
 299+ 4EC1              ;	LD IX, FRMQNT
 300+ 4EC1              ;	CALL CALBAS
 301+ 4EC1              ;	PUSH DE
 302+ 4EC1              ;	; comma
 303+ 4EC1              ;	CALL CHKCHAR
 304+ 4EC1              ;	DB ','
 305+ 4EC1              ;	; get y
 306+ 4EC1              ;	LD IX, FRMQNT
 307+ 4EC1              ;	CALL CALBAS
 308+ 4EC1              ;	PUSH DE
 309+ 4EC1              ;	; comma
 310+ 4EC1              ;	CALL CHKCHAR
 311+ 4EC1              ;	DB ','
 312+ 4EC1              ;	; get pattern
 313+ 4EC1              ;	LD IX, FRMQNT
 314+ 4EC1              ;	CALL CALBAS
 315+ 4EC1              ;	PUSH DE
 316+ 4EC1              ;	; comma
 317+ 4EC1              ;	CALL CHKCHAR
 318+ 4EC1              ;	DB ','
 319+ 4EC1              ;	; get color
 320+ 4EC1              ;	LD IX, FRMQNT
 321+ 4EC1              ;	CALL CALBAS
 322+ 4EC1              ;	PUSH DE
 323+ 4EC1              ;	; ending )
 324+ 4EC1              ;	CALL CHKCHAR
 325+ 4EC1              ;	DB ')'
 326+ 4EC1              ;
 327+ 4EC1              ;   ; save position in BASIC text
 328+ 4EC1              ;	PUSH HL
 329+ 4EC1              ;	POP IX
 330+ 4EC1              ;
 331+ 4EC1              ;	POP BC ; color
 332+ 4EC1              ;	POP DE ; pattern
 333+ 4EC1              ;	EXX
 334+ 4EC1              ;	POP BC ; y
 335+ 4EC1              ;	POP DE ; x
 336+ 4EC1              ;	POP AF ; sprite number
 337+ 4EC1              ;	CP 32
 338+ 4EC1              ;	JR C, .L2
 339+ 4EC1              ;	LD E, 5 ; illegal function call
 340+ 4EC1              ;	JP THROW_ERROR
 341+ 4EC1              ;.L2:
 342+ 4EC1              ;	; find location in sprite attributes table
 343+ 4EC1              ;	PUSH DE
 344+ 4EC1              ;	CALL GETnthSPRATTR
 345+ 4EC1              ;	POP DE
 346+ 4EC1              ;	DI
 347+ 4EC1              ;	; set y
 348+ 4EC1              ;	LD (HL), C
 349+ 4EC1              ;	INC HL
 350+ 4EC1              ;	LD (HL), B
 351+ 4EC1              ;	INC HL
 352+ 4EC1              ;	; set x
 353+ 4EC1              ;	LD (HL), E
 354+ 4EC1              ;	INC HL
 355+ 4EC1              ;	LD (HL), D
 356+ 4EC1              ;	INC HL
 357+ 4EC1              ;	PUSH HL
 358+ 4EC1              ;	EXX
 359+ 4EC1              ;	POP HL
 360+ 4EC1              ;	; check if 0<=pattern<64
 361+ 4EC1              ;	LD A, D
 362+ 4EC1              ;	OR A
 363+ 4EC1              ;	JR NZ, .L3
 364+ 4EC1              ;	LD A, E
 365+ 4EC1              ;	CP 64
 366+ 4EC1              ;	JR NC, .L3
 367+ 4EC1              ;	; set pattern
 368+ 4EC1              ;	;ADD A, A
 369+ 4EC1              ;	;ADD A, A
 370+ 4EC1              ;	;ADD A, A
 371+ 4EC1              ;	LD (HL), A
 372+ 4EC1              ;	INC HL
 373+ 4EC1              ;	LD (HL), D
 374+ 4EC1              ;	INC HL
 375+ 4EC1              ;	JR .L4
 376+ 4EC1              ;.L3:
 377+ 4EC1              ;	; skip pattern
 378+ 4EC1              ;	.2 INC HL
 379+ 4EC1              ;.L4:
 380+ 4EC1              ;	; check if 0<=color<16
 381+ 4EC1              ;	LD A, B
 382+ 4EC1              ;	OR A
 383+ 4EC1              ;	JR NZ, .L5
 384+ 4EC1              ;	LD A, C
 385+ 4EC1              ;	CP 16
 386+ 4EC1              ;	JR NC, .L5
 387+ 4EC1              ;	; set color
 388+ 4EC1              ;	LD (HL), C
 389+ 4EC1              ;	INC HL
 390+ 4EC1              ;	LD (HL), B
 391+ 4EC1              ;
 392+ 4EC1              ;.L5:
 393+ 4EC1              ;	EI
 394+ 4EC1              ;	PUSH IX
 395+ 4EC1              ;	POP HL
 396+ 4EC1              ;	RET
 397+ 4EC1              ; *******************************************************************************************************
 398+ 4EC1
 399+ 4EC1              ; *******************************************************************************************************
 400+ 4EC1              ; function sets sprite location based on initial coordinates and offset provided
 401+ 4EC1              ; input A=sprite number in SPRATR_DATA , 0-31
 402+ 4EC1              ; input DE=initial x
 403+ 4EC1              ; input BC=initial y
 404+ 4EC1              ; input IY=location where delta y,x are located
 405+ 4EC1              ; modifies AF, HL, IX
 406+ 4EC1              SPRSET_DELTA_POS:
 407+ 4EC1 D5           	PUSH DE
 408+ 4EC2 CD 90 4D     	CALL GETnthSPRATTR
 409+ 4EC5 E5           	PUSH HL
 410+ 4EC6 DD E1        	POP IX
 411+ 4EC8 D1           	POP DE
 412+ 4EC9              	; IX=sprite's y location
 413+ 4EC9 FD 6E 00     	LD L, (IY)
 414+ 4ECC FD 66 01     	LD H, (IY+1)
 415+ 4ECF 09           	ADD HL, BC
 416+ 4ED0 DD 75 00     	LD (IX), L
 417+ 4ED3 DD 74 01     	LD (IX+1), H
 418+ 4ED6 FD 6E 02     	LD L, (IY+2)
 419+ 4ED9 FD 66 03     	LD H, (IY+3)
 420+ 4EDC 19           	ADD HL, DE
 421+ 4EDD DD 75 02     	LD (IX+2), L
 422+ 4EE0 DD 74 03     	LD (IX+3), H
 423+ 4EE3 C9           	RET
 424+ 4EE4              ; *******************************************************************************************************
 425+ 4EE4
 426+ 4EE4              ; *******************************************************************************************************
 427+ 4EE4              ; helper function to set new locations for a set of sprites
 428+ 4EE4              ; input B=number of sprites
 429+ 4EE4              ; HL=pointer to list of sprites and offsets
 430+ 4EE4              SPR_UPDATE_LOC:
 431+ 4EE4 3E 01        	LD A,1
 432+ 4EE6 32 8D 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 433+ 4EE9 7E           	LD A, (HL)
 434+ 4EEA 23           	INC HL
 435+ 4EEB 23           	INC HL
 436+ 4EEC E5           	PUSH HL
 437+ 4EED FD E1        	POP IY
 438+ 4EEF D9           	EXX
 439+ 4EF0 CD C1 4E     	CALL SPRSET_DELTA_POS
 440+ 4EF3 D9           	EXX
 441+ 4EF4 23          > INC HL
 441+ 4EF5 23          > INC HL
 441+ 4EF6 23          > INC HL
 441+ 4EF7 23          > INC HL
 442+ 4EF8 10 EA        	DJNZ SPR_UPDATE_LOC
 443+ 4EFA AF           	XOR A
 444+ 4EFB 32 8D 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 445+ 4EFE C9           	RET
 446+ 4EFF              ; *******************************************************************************************************
 447+ 4EFF
 448+ 4EFF               IF (1 == 1)
 449+ 4EFF              ; *******************************************************************************************************
 450+ 4EFF              ; function to handle CALL SPRGRPMOV basic extension
 451+ 4EFF              ; sets position of a group of sprites described with
 452+ 4EFF              ; { int sprite_num, int delta_y, int delta_x } [count]
 453+ 4EFF              ; _SPRGRPMOV ( INT x,
 454+ 4EFF              ;			   INT y,
 455+ 4EFF              ;			   BYTE count,
 456+ 4EFF              ;			   INT[2][count] data_ptr
 457+ 4EFF              SPRGRPMOV:
 458+ 4EFF 3A 86 4D     	LD A, (SPRATR_INIT_STATUS)
 459+ 4F02 B7           	OR A
 460+ 4F03 CA D5 67     	JP Z,ILLEGAL_FUNCTION
 461+ 4F06              	; opening (
 462+ 4F06 CD A9 67     	CALL CHKCHAR
 463+ 4F09 28           	DB '('
 464+ 4F0A              	; get x
 465+ 4F0A DD 21 2F 54  	LD IX, FRMQNT
 466+ 4F0E CD 59 01     	CALL CALBAS
 467+ 4F11 ED 53 7C 64  	LD (BLIT_STRUCT),DE
 468+ 4F15              	; comma
 469+ 4F15 CD A9 67     	CALL CHKCHAR
 470+ 4F18 2C           	DB ','
 471+ 4F19              	; get y
 472+ 4F19 DD 21 2F 54  	LD IX, FRMQNT
 473+ 4F1D CD 59 01     	CALL CALBAS
 474+ 4F20 ED 53 7E 64  	LD (BLIT_STRUCT+2),DE
 475+ 4F24              	; comma
 476+ 4F24 CD A9 67     	CALL CHKCHAR
 477+ 4F27 2C           	DB ','
 478+ 4F28              	; get count
 479+ 4F28 DD 21 1C 52  	LD IX, GETBYT
 480+ 4F2C CD 59 01     	CALL CALBAS
 481+ 4F2F 32 80 64     	LD (BLIT_STRUCT+4),A
 482+ 4F32              	; comma
 483+ 4F32 CD A9 67     	CALL CHKCHAR
 484+ 4F35 2C           	DB ','
 485+ 4F36              	; get sprite group definition array data pointer
 486+ 4F36 3A 80 64     	LD A,(BLIT_STRUCT+4)
 487+ 4F39 5F           	LD E,A
 488+ 4F3A 16 03        	LD D,3
 489+ 4F3C 3E 02        	LD A,2
 490+ 4F3E 47           	LD B,A
 491+ 4F3F CD 0E 68     	CALL GET_BASIC_ARRAY_DATA_POINTER
 492+ 4F42 ED 43 81 64  	LD (BLIT_STRUCT+5),BC
 493+ 4F46              	; ending )
 494+ 4F46 CD A9 67     	CALL CHKCHAR
 495+ 4F49 29           	DB ')'
 496+ 4F4A
 497+ 4F4A E5           	PUSH HL
 498+ 4F4B
 499+ 4F4B D9               EXX
 500+ 4F4C ED 5B 7C 64      LD DE,(BLIT_STRUCT) ; initial x
 501+ 4F50 ED 4B 7E 64      LD BC,(BLIT_STRUCT+2) ; initial y
 502+ 4F54 D9               EXX
 503+ 4F55 2A 81 64         LD HL,(BLIT_STRUCT+5) ; pointer to data
 504+ 4F58 3A 80 64         LD A,(BLIT_STRUCT+4) ; number of entries
 505+ 4F5B 47               LD B,A
 506+ 4F5C CD E4 4E     	CALL SPR_UPDATE_LOC
 507+ 4F5F
 508+ 4F5F E1           	POP HL
 509+ 4F60 C9           	RET
 510+ 4F61              ; *******************************************************************************************************
 511+ 4F61               ENDIF
 512+ 4F61
 513+ 4F61               IF (0 == 1)
 514+ 4F61 ~            ; *******************************************************************************************************
 515+ 4F61 ~            ; same as SPRGRPMOV but for DEFUSR approach
 516+ 4F61 ~            ; input IX=pointer to input array, real data from +2
 517+ 4F61 ~            ; +2 = X
 518+ 4F61 ~            ; +4 = Y
 519+ 4F61 ~            ; +6 = count
 520+ 4F61 ~            ; +8 = data pointer
 521+ 4F61 ~            SPRGRPMOV_DEFUSR:
 522+ 4F61 ~                EXX
 523+ 4F61 ~            	LD E,(IX+2)
 524+ 4F61 ~            	LD D,(IX+3) ; initial x
 525+ 4F61 ~            	LD C,(IX+4)
 526+ 4F61 ~            	LD B,(IX+5) ; initial y
 527+ 4F61 ~                EXX
 528+ 4F61 ~            	LD L,(IX+8)
 529+ 4F61 ~            	LD H,(IX+9) ; pointer to data
 530+ 4F61 ~                LD B,(IX+6) ; count
 531+ 4F61 ~                JP SPR_UPDATE_LOC
 532+ 4F61 ~            ; *******************************************************************************************************
 533+ 4F61               ENDIF
# file closed: asm\SPRITES.asm
 135  4F61               ENDIF
 136  4F61
 137  4F61               IF (ANIM_CMDS == 1)
 138  4F61               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4F61              ; sprite animation routines
   2+ 4F61
   3+ 4F61              ; number of animation items and pointer
   4+ 4F61              ANIMITEMNUM:
   5+ 4F61 00            DB 0
   6+ 4F62              ANIMITEMPTR:
   7+ 4F62 84 68         DW EXT_END
   8+ 4F64              ; number of animation definitions and pointer
   9+ 4F64              ANIMDEFNUM:
  10+ 4F64 00            DB 0
  11+ 4F65              ANIMDEFPTR:
  12+ 4F65 84 68         DW EXT_END
  13+ 4F67              ; number of links between sprite and animation definitions
  14+ 4F67              ANIMSPRNUM:
  15+ 4F67 00            DB 0
  16+ 4F68              ANIMSPRPTR:
  17+ 4F68 84 68         DW EXT_END
  18+ 4F6A              ; number of automatic sprite group move and animate structures
  19+ 4F6A              AUTOSGAMNUM:
  20+ 4F6A 00            DB 0
  21+ 4F6B              AUTOSGAMPTR:
  22+ 4F6B 84 68         DW EXT_END
  23+ 4F6D
  24+ 4F6D              ; ANIMATION ITEM
  25+ 4F6D              ; byte type = [0 - pattern and color change
  26+ 4F6D              ;              1 - pattern definition change ]
  27+ 4F6D              ; word ticks - number of ticks to hold this state
  28+ 4F6D              ; for type = 0
  29+ 4F6D              ;   byte pattern;
  30+ 4F6D              ;   byte color;
  31+ 4F6D              ; for type = 1
  32+ 4F6D              ;   work data_pointer;
  33+ 4F6D              ; total size = 5b
  34+ 4F6D
  35+ 4F6D              ; ANIMATION DEFINITION
  36+ 4F6D              ; byte number of items 1-15
  37+ 4F6D              ; byte[15] anim_item;
  38+ 4F6D              ; total size = 16b
  39+ 4F6D
  40+ 4F6D              ; SPRITE/CHAR ANIMATION
  41+ 4F6D              ; +00 byte sprite/char number;
  42+ 4F6D              ; +01 word time;
  43+ 4F6D              ; +03 byte current item;
  44+ 4F6D              ; +04 byte animation definition;
  45+ 4F6D              ; +05 byte cyclic;
  46+ 4F6D              ; +06 byte active;
  47+ 4F6D              ; +07 byte 0=sprite, 1-3 character bank
  48+ 4F6D              ; total size = 8b
  49+ 4F6D
  50+ 4F6D              ; AUTOMATIC SPRITE GROUP MOVE AND ANIMATE structure
  51+ 4F6D              ; +00 pointer to X variable
  52+ 4F6D              ; +02 pointer to Y variable
  53+ 4F6D              ; +04 minimum value
  54+ 4F6D              ; +06 maximal value
  55+ 4F6D              ; +08 delta value
  56+ 4F6D              ; +10 direction 0=horizontal, <>0 = vertical
  57+ 4F6D              ; +11 sprite group size
  58+ 4F6D              ; +12 sprite group pointer
  59+ 4F6D              ; +14 animation list size
  60+ 4F6D              ; +15 animation list pointer for negative delta values
  61+ 4F6D              ; +17 animation list pointer for positive delta values
  62+ 4F6D              ; +19 active flag
  63+ 4F6D              ; +20 ticks for movement
  64+ 4F6D              ; +22 timer
  65+ 4F6D              ; total = 24b
  66+ 4F6D
  67+ 4F6D              ; *******************************************************************************************************
  68+ 4F6D              ; helper function HL=A*5
  69+ 4F6D              ; changes HL,DE
  70+ 4F6D              Ax5:
  71+ 4F6D 26 00            LD H,0
  72+ 4F6F 6F               LD L,A
  73+ 4F70 54               LD D,H
  74+ 4F71 5D               LD E,L
  75+ 4F72 29               ADD HL,HL
  76+ 4F73 29               ADD HL,HL
  77+ 4F74 19               ADD HL,DE
  78+ 4F75 C9               RET
  79+ 4F76              ; *******************************************************************************************************
  80+ 4F76
  81+ 4F76              ; *******************************************************************************************************
  82+ 4F76              ; helper function gets pointer to n-th animation item
  83+ 4F76              ; changes HL,DE
  84+ 4F76              GETnthANIMITEM:
  85+ 4F76 CD 6D 4F         CALL Ax5
  86+ 4F79 ED 5B 62 4F      LD DE,(ANIMITEMPTR)
  87+ 4F7D 19               ADD HL,DE
  88+ 4F7E C9               RET
  89+ 4F7F              ; *******************************************************************************************************
  90+ 4F7F
  91+ 4F7F              ; *******************************************************************************************************
  92+ 4F7F              ; helper function gets pointer to n-th entry in animation definition
  93+ 4F7F              ; changes HL,DE
  94+ 4F7F              GETnthANIMDEF:
  95+ 4F7F 26 00            LD H,0
  96+ 4F81 6F               LD L,A
  97+ 4F82 CD 95 66         CALL HLx16
  98+ 4F85 ED 5B 65 4F      LD DE,(ANIMDEFPTR)
  99+ 4F89 19               ADD HL,DE
 100+ 4F8A C9               RET
 101+ 4F8B              ; *******************************************************************************************************
 102+ 4F8B
 103+ 4F8B              ; *******************************************************************************************************
 104+ 4F8B              ; helper function gets pointer to n-th entry in sprite animation
 105+ 4F8B              ; changes HL,DE
 106+ 4F8B              GETnthSPRANIM:
 107+ 4F8B 26 00            LD H,0
 108+ 4F8D 6F               LD L,A
 109+ 4F8E CD 96 66         CALL HLx8
 110+ 4F91 ED 5B 68 4F      LD DE,(ANIMSPRPTR)
 111+ 4F95 19               ADD HL,DE
 112+ 4F96 C9               RET
 113+ 4F97              ; *******************************************************************************************************
 114+ 4F97
 115+ 4F97              ; *******************************************************************************************************
 116+ 4F97              ; helper function gets pointer to n-th entry in autosgam table
 117+ 4F97              ; changes HL,DE
 118+ 4F97              GETnthAUTOSGAM:
 119+ 4F97 26 00            LD H,0
 120+ 4F99 6F               LD L,A
 121+ 4F9A CD 96 66         CALL HLx8
 122+ 4F9D 54               LD D,H
 123+ 4F9E 5D               LD E,L
 124+ 4F9F 29               ADD HL,HL
 125+ 4FA0 19               ADD HL,DE
 126+ 4FA1 ED 5B 6B 4F      LD DE,(AUTOSGAMPTR)
 127+ 4FA5 19               ADD HL,DE
 128+ 4FA6 C9               RET
 129+ 4FA7              ; *******************************************************************************************************
 130+ 4FA7
 131+ 4FA7               IF (0 == 1)
 132+ 4FA7 ~            ; *******************************************************************************************************
 133+ 4FA7 ~            ; same as MAXIANIMITEMS but for DEFUSR approach
 134+ 4FA7 ~            ; input IX=pointer to input array, real data from +2
 135+ 4FA7 ~            ; +2 = number
 136+ 4FA7 ~            MAXANIMITEMS_DEFUSR:
 137+ 4FA7 ~                LD A,(IX+2)
 138+ 4FA7 ~                CALL MAXANIMITEMS.COMMON
 139+ 4FA7 ~                XOR A ; success
 140+ 4FA7 ~                RET
 141+ 4FA7 ~            ; *******************************************************************************************************
 142+ 4FA7               ENDIF
 143+ 4FA7
 144+ 4FA7              ; *******************************************************************************************************
 145+ 4FA7              ; function to handle CALL MAXANIMITEMS basic extension
 146+ 4FA7              ; MAXANIMITEMS (BYTE number)
 147+ 4FA7              ; sets new number and moves memory buffers as needed
 148+ 4FA7              MAXANIMITEMS:
 149+ 4FA7               IF (1 == 1)
 150+ 4FA7              	; opening (
 151+ 4FA7 CD A9 67     	CALL CHKCHAR
 152+ 4FAA 28           	DB '('
 153+ 4FAB              	; get value
 154+ 4FAB DD 21 1C 52  	LD IX, GETBYT
 155+ 4FAF CD 59 01     	CALL CALBAS
 156+ 4FB2 F5               PUSH AF
 157+ 4FB3              	; ending )
 158+ 4FB3 CD A9 67     	CALL CHKCHAR
 159+ 4FB6 29           	DB ')'
 160+ 4FB7 F1               POP AF
 161+ 4FB8               ENDIF
 162+ 4FB8              .COMMON: ; entry for DEFUSR part, A=number
 163+ 4FB8 F3               DI
 164+ 4FB9              	; save position
 165+ 4FB9 E5           	PUSH HL
 166+ 4FBA              .ENTRY:
 167+ 4FBA 47               LD B,A
 168+ 4FBB 3A 61 4F         LD A,(ANIMITEMNUM)
 169+ 4FBE 90               SUB B
 170+ 4FBF 28 28            JR Z, .EXIT; same value as before
 171+ 4FC1 FD 21 65 4F      LD IY,ANIMDEFPTR
 172+ 4FC5 FA EC 4F         JP M, .INCREASE
 173+ 4FC8                  ; new value is lower than previous one
 174+ 4FC8 CD 0B 50         CALL .SIZEDIFF
 175+ 4FCB CD 26 50         CALL .DECREASE_COMMON
 176+ 4FCE 2A 68 4F         LD HL,(ANIMSPRPTR)
 177+ 4FD1 AF               XOR A
 178+ 4FD2 ED 42            SBC HL,BC
 179+ 4FD4 22 68 4F         LD (ANIMSPRPTR),HL
 180+ 4FD7              .E1:
 181+ 4FD7 2A 6B 4F         LD HL,(AUTOSGAMPTR)
 182+ 4FDA AF               XOR A
 183+ 4FDB ED 42            SBC HL,BC
 184+ 4FDD 22 6B 4F         LD (AUTOSGAMPTR),HL
 185+ 4FE0              .E3:
 186+ 4FE0 2A 10 40         LD HL,(FREEMEMPTR)
 187+ 4FE3 AF               XOR A
 188+ 4FE4 ED 42            SBC HL,BC
 189+ 4FE6 22 10 40         LD (FREEMEMPTR),HL
 190+ 4FE9              .EXIT:
 191+ 4FE9 FB               EI
 192+ 4FEA E1           	POP HL
 193+ 4FEB C9           	RET
 194+ 4FEC              .INCREASE:
 195+ 4FEC ED 44            NEG
 196+ 4FEE CD 0B 50         CALL .SIZEDIFF
 197+ 4FF1 CD 52 50         CALL .INCREASE_COMMON
 198+ 4FF4 2A 68 4F         LD HL,(ANIMSPRPTR)
 199+ 4FF7 09               ADD HL,BC
 200+ 4FF8 22 68 4F         LD (ANIMSPRPTR),HL
 201+ 4FFB              .E2:
 202+ 4FFB 2A 6B 4F         LD HL,(AUTOSGAMPTR)
 203+ 4FFE 09               ADD HL,BC
 204+ 4FFF 22 6B 4F         LD (AUTOSGAMPTR),HL
 205+ 5002              .E4:
 206+ 5002 2A 10 40         LD HL,(FREEMEMPTR)
 207+ 5005 09               ADD HL,BC
 208+ 5006 22 10 40         LD (FREEMEMPTR),HL
 209+ 5009 18 DE            JR .EXIT
 210+ 500B              .SIZEDIFF:
 211+ 500B CD 6D 4F         CALL Ax5
 212+ 500E 78               LD A,B
 213+ 500F 32 61 4F         LD (ANIMITEMNUM),A
 214+ 5012 44               LD B,H
 215+ 5013 4D               LD C,L
 216+ 5014 C9               RET ; BC=size difference in bytes
 217+ 5015              .SIZETOMOVE:
 218+ 5015 D5               PUSH DE
 219+ 5016 2A 10 40         LD HL,(FREEMEMPTR)
 220+ 5019 FD 5E 00         LD E,(IY)
 221+ 501C FD 56 01         LD D,(IY+1)
 222+ 501F AF               XOR A
 223+ 5020 ED 52            SBC HL,DE
 224+ 5022 44               LD B,H
 225+ 5023 4D               LD C,L
 226+ 5024 D1               POP DE
 227+ 5025 C9               RET
 228+ 5026              .DECREASE_COMMON:
 229+ 5026 FD 6E 00         LD L,(IY)
 230+ 5029 FD 66 01         LD H,(IY+1)
 231+ 502C AF               XOR A
 232+ 502D ED 42            SBC HL,BC
 233+ 502F EB               EX DE,HL
 234+ 5030 C5               PUSH BC
 235+ 5031 CD 15 50         CALL .SIZETOMOVE
 236+ 5034 F3               DI
 237+ 5035 78               LD A,B
 238+ 5036 B1               OR C
 239+ 5037 28 08            JR Z,.L1
 240+ 5039 FD 6E 00         LD L,(IY)
 241+ 503C FD 66 01         LD H,(IY+1)
 242+ 503F ED B0            LDIR
 243+ 5041              .L1:
 244+ 5041 C1               POP BC
 245+ 5042 FD 6E 00         LD L,(IY)
 246+ 5045 FD 66 01         LD H,(IY+1)
 247+ 5048 AF               XOR A
 248+ 5049 ED 42            SBC HL,BC
 249+ 504B FD 75 00         LD (IY),L
 250+ 504E FD 74 01         LD (IY+1),H
 251+ 5051 C9               RET
 252+ 5052              .INCREASE_COMMON:
 253+ 5052 2A 10 40         LD HL,(FREEMEMPTR)
 254+ 5055 2B               DEC HL
 255+ 5056 AF               XOR A
 256+ 5057 ED 42            SBC HL,BC
 257+ 5059 EB               EX DE,HL
 258+ 505A C5               PUSH BC
 259+ 505B CD 15 50         CALL .SIZETOMOVE
 260+ 505E F3               DI
 261+ 505F 78               LD A,B
 262+ 5060 B1               OR C
 263+ 5061 28 06            JR Z,.L2
 264+ 5063 2A 10 40         LD HL,(FREEMEMPTR)
 265+ 5066 2B               DEC HL
 266+ 5067 ED B8            LDDR
 267+ 5069              .L2:
 268+ 5069 C1               POP BC
 269+ 506A FD 6E 00         LD L,(IY)
 270+ 506D FD 66 01         LD H,(IY+1)
 271+ 5070 09               ADD HL,BC
 272+ 5071 FD 75 00         LD (IY),L
 273+ 5074 FD 74 01         LD (IY+1),H
 274+ 5077 C9               RET
 275+ 5078              ; *******************************************************************************************************
 276+ 5078
 277+ 5078               IF (1 == 1)
 278+ 5078              ; *******************************************************************************************************
 279+ 5078              ; function to handle CALL ANIMITEMPAT basic extension
 280+ 5078              ; ANIMITEMPAT ( BYTE id,
 281+ 5078              ;               INT ticks >0,
 282+ 5078              ;               BYTE pattern,
 283+ 5078              ;               BYTE color )
 284+ 5078              ; fills animation item data, returns an error if ID out of bounds
 285+ 5078              ANIMITEMPAT:
 286+ 5078                  ; opening (
 287+ 5078 CD A9 67     	CALL CHKCHAR
 288+ 507B 28           	DB '('
 289+ 507C              	; get id
 290+ 507C DD 21 1C 52  	LD IX, GETBYT
 291+ 5080 CD 59 01     	CALL CALBAS
 292+ 5083 F5               PUSH AF
 293+ 5084                  ; check if out of bounds
 294+ 5084 3C               INC A
 295+ 5085 4F               LD C,A
 296+ 5086 3A 61 4F         LD A,(ANIMITEMNUM)
 297+ 5089 B9               CP C
 298+ 508A DA CD 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 299+ 508D              	; comma
 300+ 508D CD A9 67     	CALL CHKCHAR
 301+ 5090 2C           	DB ','
 302+ 5091              	; get ticks
 303+ 5091 DD 21 2F 54  	LD IX, FRMQNT
 304+ 5095 CD 59 01     	CALL CALBAS
 305+ 5098 7A               LD A,D
 306+ 5099 B3               OR E
 307+ 509A CA D1 67         JP Z, OVERFLOW
 308+ 509D D5           	PUSH DE
 309+ 509E              	; comma
 310+ 509E CD A9 67     	CALL CHKCHAR
 311+ 50A1 2C           	DB ','
 312+ 50A2              	; get pattern
 313+ 50A2 DD 21 1C 52  	LD IX, GETBYT
 314+ 50A6 CD 59 01     	CALL CALBAS
 315+ 50A9 F5               PUSH AF
 316+ 50AA              	; comma
 317+ 50AA CD A9 67     	CALL CHKCHAR
 318+ 50AD 2C           	DB ','
 319+ 50AE              	; get color
 320+ 50AE DD 21 1C 52  	LD IX, GETBYT
 321+ 50B2 CD 59 01     	CALL CALBAS
 322+ 50B5 F5               PUSH AF
 323+ 50B6              	; ending )
 324+ 50B6 CD A9 67     	CALL CHKCHAR
 325+ 50B9 29           	DB ')'
 326+ 50BA              .ENTRY:
 327+ 50BA E5               PUSH HL
 328+ 50BB DD E1            POP IX
 329+ 50BD D9               EXX
 330+ 50BE C1               POP BC ; color
 331+ 50BF D1               POP DE ; pattern
 332+ 50C0 E1               POP HL ; ticks
 333+ 50C1 D9               EXX
 334+ 50C2 F1               POP AF
 335+ 50C3 CD 76 4F         CALL GETnthANIMITEM
 336+ 50C6 E5               PUSH HL
 337+ 50C7 FD E1            POP IY
 338+ 50C9 D9               EXX
 339+ 50CA FD 36 00 00      LD (IY),0 ; type=0
 340+ 50CE FD 75 01         LD (IY+1),L
 341+ 50D1 FD 74 02         LD (IY+2),H
 342+ 50D4 FD 72 03         LD (IY+3),D
 343+ 50D7 FD 70 04         LD (IY+4),B
 344+ 50DA
 345+ 50DA DD E5            PUSH IX
 346+ 50DC E1               POP HL
 347+ 50DD C9               RET
 348+ 50DE              ; *******************************************************************************************************
 349+ 50DE               ENDIF
 350+ 50DE
 351+ 50DE               IF (0 == 1)
 352+ 50DE ~            ; *******************************************************************************************************
 353+ 50DE ~            ; same as ANIMITEMPAT but for DEFUSR approach
 354+ 50DE ~            ; input IX=pointer to input array, real data from +2
 355+ 50DE ~            ; +02 = ID
 356+ 50DE ~            ; +04 = ticks
 357+ 50DE ~            ; +06 = pattern
 358+ 50DE ~            ; +08 = color
 359+ 50DE ~            ANIMITEMPAT_DEFUSR:
 360+ 50DE ~                ; check if out of bounds
 361+ 50DE ~                LD C,(IX+2)
 362+ 50DE ~                INC C
 363+ 50DE ~                LD A,(ANIMITEMNUM)
 364+ 50DE ~                CP C
 365+ 50DE ~                JR C,.ERR ; out of bounds, prevent memory corruption
 366+ 50DE ~                LD A,C
 367+ 50DE ~                DEC A
 368+ 50DE ~                CALL GETnthANIMITEM
 369+ 50DE ~                LD (HL),0 ; type=0
 370+ 50DE ~                INC HL
 371+ 50DE ~                LD A,(IX+4) ; ticks low
 372+ 50DE ~                LD (HL),A
 373+ 50DE ~                INC HL
 374+ 50DE ~                LD A,(IX+5) ; ticks high
 375+ 50DE ~                LD (HL),A
 376+ 50DE ~                INC HL
 377+ 50DE ~                LD A,(IX+6) ; pattern
 378+ 50DE ~                LD (HL),A
 379+ 50DE ~                INC HL
 380+ 50DE ~                LD A,(IX+8) ; color
 381+ 50DE ~                LD (HL),A
 382+ 50DE ~                XOR A ; success
 383+ 50DE ~                RET
 384+ 50DE ~            .ERR:
 385+ 50DE ~                LD A,1
 386+ 50DE ~                RET
 387+ 50DE ~            ; *******************************************************************************************************
 388+ 50DE               ENDIF
 389+ 50DE
 390+ 50DE               IF (1 == 1)
 391+ 50DE              ; *******************************************************************************************************
 392+ 50DE              ; function to handle CALL ANIMITEMPTR basic extension
 393+ 50DE              ; ANIMITEMPTR ( BYTE id,
 394+ 50DE              ;               INT ticks,
 395+ 50DE              ;               INT pointer,
 396+ 50DE              ; fills animation item data, returns an error if ID out of bounds
 397+ 50DE              ANIMITEMPTR_CMD:
 398+ 50DE                  ; opening (
 399+ 50DE CD A9 67     	CALL CHKCHAR
 400+ 50E1 28           	DB '('
 401+ 50E2              	; get id
 402+ 50E2 DD 21 1C 52  	LD IX, GETBYT
 403+ 50E6 CD 59 01     	CALL CALBAS
 404+ 50E9 F5               PUSH AF
 405+ 50EA                  ; check if out of bounds
 406+ 50EA 3C               INC A
 407+ 50EB 4F               LD C,A
 408+ 50EC 3A 61 4F         LD A,(ANIMITEMNUM)
 409+ 50EF B9               CP C
 410+ 50F0 DA CD 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 411+ 50F3              	; comma
 412+ 50F3 CD A9 67     	CALL CHKCHAR
 413+ 50F6 2C           	DB ','
 414+ 50F7              	; get ticks
 415+ 50F7 DD 21 2F 54  	LD IX, FRMQNT
 416+ 50FB CD 59 01     	CALL CALBAS
 417+ 50FE 7A               LD A,D
 418+ 50FF B3               OR E
 419+ 5100 CA D1 67         JP Z,OVERFLOW
 420+ 5103 D5           	PUSH DE
 421+ 5104              	; comma
 422+ 5104 CD A9 67     	CALL CHKCHAR
 423+ 5107 2C           	DB ','
 424+ 5108              	; get pointer
 425+ 5108 DD 21 2F 54  	LD IX, FRMQNT
 426+ 510C CD 59 01     	CALL CALBAS
 427+ 510F D5           	PUSH DE
 428+ 5110              	; ending )
 429+ 5110 CD A9 67     	CALL CHKCHAR
 430+ 5113 29           	DB ')'
 431+ 5114              .ENTRY:
 432+ 5114 E5               PUSH HL
 433+ 5115 DD E1            POP IX
 434+ 5117 D9               EXX
 435+ 5118 D1               POP DE ; pointer
 436+ 5119 E1               POP HL ; ticks
 437+ 511A D9               EXX
 438+ 511B F1               POP AF
 439+ 511C CD 76 4F         CALL GETnthANIMITEM
 440+ 511F E5               PUSH HL
 441+ 5120 FD E1            POP IY
 442+ 5122 D9               EXX
 443+ 5123 FD 36 00 01      LD (IY),1 ; type=1
 444+ 5127 FD 75 01         LD (IY+1),L
 445+ 512A FD 74 02         LD (IY+2),H
 446+ 512D FD 73 03         LD (IY+3),E
 447+ 5130 FD 72 04         LD (IY+4),D
 448+ 5133
 449+ 5133 DD E5            PUSH IX
 450+ 5135 E1               POP HL
 451+ 5136 C9               RET
 452+ 5137              ; *******************************************************************************************************
 453+ 5137               ENDIF
 454+ 5137
 455+ 5137               IF (0 == 1)
 456+ 5137 ~            ; *******************************************************************************************************
 457+ 5137 ~            ; same as ANIMITEMPTR but for DEFUSR approach
 458+ 5137 ~            ; input IX=pointer to input array, real data from +2
 459+ 5137 ~            ; +02 = ID
 460+ 5137 ~            ; +04 = ticks
 461+ 5137 ~            ; +06 = pointer
 462+ 5137 ~            ANIMITEMPTR_DEFUSR:
 463+ 5137 ~                ; check if out of bounds
 464+ 5137 ~                LD C,(IX+2)
 465+ 5137 ~                INC C
 466+ 5137 ~                LD A,(ANIMITEMNUM)
 467+ 5137 ~                CP C
 468+ 5137 ~                JR C,.ERR ; out of bounds, prevent memory corruption
 469+ 5137 ~                LD A,C
 470+ 5137 ~                DEC A
 471+ 5137 ~                CALL GETnthANIMITEM
 472+ 5137 ~                LD (HL),1 ; type=1
 473+ 5137 ~                INC HL
 474+ 5137 ~                LD A,(IX+4) ; ticks low
 475+ 5137 ~                LD (HL),A
 476+ 5137 ~                INC HL
 477+ 5137 ~                LD A,(IX+5) ; ticks high
 478+ 5137 ~                LD (HL),A
 479+ 5137 ~                INC HL
 480+ 5137 ~                LD A,(IX+6) ; pointer low
 481+ 5137 ~                LD (HL),A
 482+ 5137 ~                INC HL
 483+ 5137 ~                LD A,(IX+7) ; pointer high
 484+ 5137 ~                LD (HL),A
 485+ 5137 ~                XOR A ; success
 486+ 5137 ~                RET
 487+ 5137 ~            .ERR:
 488+ 5137 ~                LD A,1
 489+ 5137 ~                RET
 490+ 5137 ~            ; *******************************************************************************************************
 491+ 5137               ENDIF
 492+ 5137
 493+ 5137               IF (0 == 1)
 494+ 5137 ~            ; *******************************************************************************************************
 495+ 5137 ~            ; same as MAXANIMDEFS but for DEFUSR approach
 496+ 5137 ~            ; input IX=pointer to input array, real data from +2
 497+ 5137 ~            ; +2 = number
 498+ 5137 ~            MAXANIMDEFS_DEFUSR:
 499+ 5137 ~                LD A,(IX+2)
 500+ 5137 ~                CALL MAXANIMDEFS.COMMON
 501+ 5137 ~                XOR A ; success
 502+ 5137 ~                RET
 503+ 5137 ~            ; *******************************************************************************************************
 504+ 5137               ENDIF
 505+ 5137
 506+ 5137              ; *******************************************************************************************************
 507+ 5137              ; function to handle CALL MAXANIMDEFS basic extension
 508+ 5137              ; MAXANIMDEFS (BYTE number)
 509+ 5137              ; sets new number and moves memory buffers as needed
 510+ 5137              MAXANIMDEFS:
 511+ 5137               IF (1 == 1)
 512+ 5137              	; opening (
 513+ 5137 CD A9 67     	CALL CHKCHAR
 514+ 513A 28           	DB '('
 515+ 513B              	; get value
 516+ 513B DD 21 1C 52  	LD IX, GETBYT
 517+ 513F CD 59 01     	CALL CALBAS
 518+ 5142 F5               PUSH AF
 519+ 5143              	; ending )
 520+ 5143 CD A9 67     	CALL CHKCHAR
 521+ 5146 29           	DB ')'
 522+ 5147 F1               POP AF
 523+ 5148               ENDIF
 524+ 5148              .COMMON:
 525+ 5148 F3               DI
 526+ 5149              	; save position
 527+ 5149 E5           	PUSH HL
 528+ 514A              .ENTRY:
 529+ 514A 47               LD B,A
 530+ 514B 3A 64 4F         LD A,(ANIMDEFNUM)
 531+ 514E 90               SUB B
 532+ 514F CA E9 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 533+ 5152 FD 21 68 4F      LD IY,ANIMSPRPTR
 534+ 5156 FA 62 51         JP M, .INCREASE
 535+ 5159                  ; new value is lower than previous one
 536+ 5159 CD 6D 51         CALL .SIZEDIFF
 537+ 515C CD 26 50         CALL MAXANIMITEMS.DECREASE_COMMON
 538+ 515F C3 D7 4F         JP MAXANIMITEMS.E1
 539+ 5162              .INCREASE:
 540+ 5162 ED 44            NEG
 541+ 5164 CD 6D 51         CALL .SIZEDIFF
 542+ 5167 CD 52 50         CALL MAXANIMITEMS.INCREASE_COMMON
 543+ 516A C3 FB 4F         JP MAXANIMITEMS.E2
 544+ 516D              .SIZEDIFF:
 545+ 516D 26 00            LD H,0
 546+ 516F 6F               LD L,A
 547+ 5170 CD 95 66         CALL HLx16
 548+ 5173 78               LD A,B
 549+ 5174 32 64 4F         LD (ANIMDEFNUM),A
 550+ 5177 44               LD B,H
 551+ 5178 4D               LD C,L
 552+ 5179 C9               RET ; BC=size difference in bytes
 553+ 517A              ; *******************************************************************************************************
 554+ 517A
 555+ 517A               IF (1 == 1)
 556+ 517A              ; *******************************************************************************************************
 557+ 517A              ; function to handle CALL ANIMDEF basic extension
 558+ 517A              ; ANIMITEMPAT ( BYTE id,
 559+ 517A              ;               BYTE size,
 560+ 517A              ;               INT[] list )
 561+ 517A              ; fills animation definition data, returns an error if out of bounds, or invalid type
 562+ 517A              ANIMDEF:
 563+ 517A                  ; opening (
 564+ 517A CD A9 67     	CALL CHKCHAR
 565+ 517D 28           	DB '('
 566+ 517E              	; get id
 567+ 517E DD 21 1C 52  	LD IX, GETBYT
 568+ 5182 CD 59 01     	CALL CALBAS
 569+ 5185 F5               PUSH AF
 570+ 5186                  ; check if out of bounds
 571+ 5186 3C               INC A
 572+ 5187 4F               LD C,A
 573+ 5188 3A 64 4F         LD A,(ANIMDEFNUM)
 574+ 518B B9               CP C
 575+ 518C DA CD 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 576+ 518F              	; comma
 577+ 518F CD A9 67     	CALL CHKCHAR
 578+ 5192 2C           	DB ','
 579+ 5193              	; get size
 580+ 5193 DD 21 1C 52  	LD IX, GETBYT
 581+ 5197 CD 59 01     	CALL CALBAS
 582+ 519A FE 10            CP 16
 583+ 519C D2 D1 67         JP NC, OVERFLOW
 584+ 519F B7               OR A
 585+ 51A0 CA D1 67         JP Z, OVERFLOW
 586+ 51A3 F5           	PUSH AF
 587+ 51A4              	; comma
 588+ 51A4 CD A9 67     	CALL CHKCHAR
 589+ 51A7 2C           	DB ','
 590+ 51A8              	; get pointer to a list of animation items in integer array format
 591+ 51A8                  ; get array pointer
 592+ 51A8 D1               POP DE
 593+ 51A9 D5               PUSH DE
 594+ 51AA 3E 02            LD A,2
 595+ 51AC 06 01            LD B,1
 596+ 51AE CD 0E 68         CALL GET_BASIC_ARRAY_DATA_POINTER
 597+ 51B1 C5               PUSH BC
 598+ 51B2              	; ending )
 599+ 51B2 CD A9 67     	CALL CHKCHAR
 600+ 51B5 29           	DB ')'
 601+ 51B6              .ENTRY:
 602+ 51B6 E5               PUSH HL
 603+ 51B7 DD E1            POP IX
 604+ 51B9 D1               POP DE ; pointer to INT array
 605+ 51BA C1               POP BC ; B=item number
 606+ 51BB F1               POP AF ; id
 607+ 51BC D5               PUSH DE
 608+ 51BD CD 7F 4F         CALL GETnthANIMDEF
 609+ 51C0 D1               POP DE
 610+ 51C1 70               LD (HL),B
 611+ 51C2              .L1:
 612+ 51C2 23               INC HL
 613+ 51C3 1A               LD A,(DE)
 614+ 51C4 13          > INC DE
 614+ 51C5 13          > INC DE
 615+ 51C6 77               LD (HL),A
 616+ 51C7 10 F9            DJNZ .L1
 617+ 51C9 DD E5            PUSH IX
 618+ 51CB E1               POP HL
 619+ 51CC C9               RET
 620+ 51CD              ; *******************************************************************************************************
 621+ 51CD               ENDIF
 622+ 51CD
 623+ 51CD               IF (0 == 1)
 624+ 51CD ~            ; *******************************************************************************************************
 625+ 51CD ~            ; same as ANIMDEF but for DEFUSR approach
 626+ 51CD ~            ; input IX=pointer to input array, real data from +2
 627+ 51CD ~            ; +02 = ID
 628+ 51CD ~            ; +04 = list size
 629+ 51CD ~            ; +06 = list pointer
 630+ 51CD ~            ANIMDEF_DEFUSR:
 631+ 51CD ~                ; check if out of bounds
 632+ 51CD ~                LD C,(IX+2)
 633+ 51CD ~                INC C
 634+ 51CD ~                LD A,(ANIMDEFNUM)
 635+ 51CD ~                CP C
 636+ 51CD ~                JR C,.ERR ; invalid id
 637+ 51CD ~            	; get size
 638+ 51CD ~                LD A,(IX+4)
 639+ 51CD ~                CP 16
 640+ 51CD ~                RET NC ; overflow
 641+ 51CD ~                OR A
 642+ 51CD ~                RET Z ; ID=0, invalid
 643+ 51CD ~                LD B,A
 644+ 51CD ~                LD A,C
 645+ 51CD ~                DEC A
 646+ 51CD ~                CALL GETnthANIMDEF
 647+ 51CD ~                LD (HL),B
 648+ 51CD ~                LD E,(IX+6)
 649+ 51CD ~                LD D,(IX+7)
 650+ 51CD ~            .L1:
 651+ 51CD ~                INC HL
 652+ 51CD ~                LD A,(DE)
 653+ 51CD ~                .2 INC DE
 654+ 51CD ~                LD (HL),A
 655+ 51CD ~                DJNZ .L1
 656+ 51CD ~                XOR A ; success
 657+ 51CD ~                RET
 658+ 51CD ~            .ERR:
 659+ 51CD ~                LD A,1
 660+ 51CD ~                RET
 661+ 51CD ~            ; *******************************************************************************************************
 662+ 51CD               ENDIF
 663+ 51CD
 664+ 51CD               IF (0 == 1)
 665+ 51CD ~            ; *******************************************************************************************************
 666+ 51CD ~            ; same as MAXANIMSPRS but for DEFUSR approach
 667+ 51CD ~            ; input IX=pointer to input array, real data from +2
 668+ 51CD ~            ; +2 = number
 669+ 51CD ~            MAXANIMSPRS_DEFUSR:
 670+ 51CD ~                LD A,(IX+2)
 671+ 51CD ~                CALL MAXANIMSPRS.COMMON
 672+ 51CD ~                XOR A ; success
 673+ 51CD ~                RET
 674+ 51CD ~            ; *******************************************************************************************************
 675+ 51CD               ENDIF
 676+ 51CD
 677+ 51CD              ; *******************************************************************************************************
 678+ 51CD              ; function to handle CALL MAXANIMSPRS basic extension
 679+ 51CD              ; MAXANIMSPRS (BYTE number)
 680+ 51CD              ; sets new number and moves memory buffers as needed
 681+ 51CD              MAXANIMSPRS:
 682+ 51CD               IF (1 == 1)
 683+ 51CD              	; opening (
 684+ 51CD CD A9 67     	CALL CHKCHAR
 685+ 51D0 28           	DB '('
 686+ 51D1              	; get value
 687+ 51D1 DD 21 1C 52  	LD IX, GETBYT
 688+ 51D5 CD 59 01     	CALL CALBAS
 689+ 51D8 F5               PUSH AF
 690+ 51D9              	; ending )
 691+ 51D9 CD A9 67     	CALL CHKCHAR
 692+ 51DC 29           	DB ')'
 693+ 51DD F1               POP AF
 694+ 51DE               ENDIF
 695+ 51DE              .COMMON:
 696+ 51DE F3               DI
 697+ 51DF              	; save position
 698+ 51DF E5           	PUSH HL
 699+ 51E0              .ENTRY:
 700+ 51E0 47               LD B,A
 701+ 51E1 3A 67 4F         LD A,(ANIMSPRNUM)
 702+ 51E4 90               SUB B
 703+ 51E5 CA E9 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 704+ 51E8 FD 21 6B 4F      LD IY,AUTOSGAMPTR
 705+ 51EC FA F8 51         JP M, .INCREASE
 706+ 51EF                  ; new value is lower than previous one
 707+ 51EF CD 19 52         CALL .SIZEDIFF
 708+ 51F2 CD 26 50         CALL MAXANIMITEMS.DECREASE_COMMON
 709+ 51F5 C3 E0 4F         JP MAXANIMITEMS.E3
 710+ 51F8              .INCREASE:
 711+ 51F8 ED 44            NEG
 712+ 51FA F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 713+ 51FB CD 19 52         CALL .SIZEDIFF
 714+ 51FE CD 52 50         CALL MAXANIMITEMS.INCREASE_COMMON
 715+ 5201 AF               XOR A
 716+ 5202 ED 42            SBC HL,BC ; location of new stuff
 717+ 5204 F1               POP AF
 718+ 5205 C5               PUSH BC
 719+ 5206 47               LD B,A
 720+ 5207 11 08 00         LD DE,8
 721+ 520A E5               PUSH HL
 722+ 520B DD E1            POP IX
 723+ 520D              .L1:
 724+ 520D DD 36 06 00      LD (IX+6),0 ; active flag
 725+ 5211 DD 19            ADD IX,DE
 726+ 5213 10 F8            DJNZ .L1
 727+ 5215 C1               POP BC
 728+ 5216 C3 02 50         JP MAXANIMITEMS.E4
 729+ 5219              .SIZEDIFF:
 730+ 5219 26 00            LD H,0
 731+ 521B 6F               LD L,A
 732+ 521C CD 96 66         CALL HLx8
 733+ 521F 78               LD A,B
 734+ 5220 32 67 4F         LD (ANIMSPRNUM),A
 735+ 5223 44               LD B,H
 736+ 5224 4D               LD C,L
 737+ 5225 C9               RET ; BC=size difference in bytes
 738+ 5226              ; *******************************************************************************************************
 739+ 5226
 740+ 5226               IF (1 == 1)
 741+ 5226              ; *******************************************************************************************************
 742+ 5226              ; function to handle CALL ANIMSPRITE basic extension
 743+ 5226              ; ANIMSPRITE ( BYTE id,
 744+ 5226              ;              BYTE sprite_number,
 745+ 5226              ;              BYTE animation_definition_id,
 746+ 5226              ;              BYTE cyclic_flag )
 747+ 5226              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 748+ 5226              ANIMSPRITE:
 749+ 5226                  ; opening (
 750+ 5226 CD A9 67     	CALL CHKCHAR
 751+ 5229 28           	DB '('
 752+ 522A              	; get sprite animation id
 753+ 522A DD 21 1C 52  	LD IX, GETBYT
 754+ 522E CD 59 01     	CALL CALBAS
 755+ 5231 F5               PUSH AF
 756+ 5232 3C               INC A
 757+ 5233 4F               LD C,A
 758+ 5234 3A 67 4F         LD A,(ANIMSPRNUM)
 759+ 5237 B9               CP C
 760+ 5238 DA CD 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 761+ 523B              	; comma
 762+ 523B CD A9 67     	CALL CHKCHAR
 763+ 523E 2C           	DB ','
 764+ 523F              	; get sprite number
 765+ 523F DD 21 1C 52  	LD IX, GETBYT
 766+ 5243 CD 59 01     	CALL CALBAS
 767+ 5246 F5               PUSH AF
 768+ 5247                  ; check if out of bounds
 769+ 5247 FE 20            CP 32
 770+ 5249 D2 CD 67         JP NC, SUBSCRIPT_OUT_OF_RANGE
 771+ 524C              	; comma
 772+ 524C CD A9 67     	CALL CHKCHAR
 773+ 524F 2C           	DB ','
 774+ 5250              	; get animation definition id
 775+ 5250 DD 21 1C 52  	LD IX, GETBYT
 776+ 5254 CD 59 01     	CALL CALBAS
 777+ 5257 F5               PUSH AF
 778+ 5258 3C               INC A
 779+ 5259 4F               LD C,A
 780+ 525A 3A 64 4F         LD A,(ANIMDEFNUM)
 781+ 525D B9               CP C
 782+ 525E DA CD 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 783+ 5261              	; comma
 784+ 5261 CD A9 67     	CALL CHKCHAR
 785+ 5264 2C           	DB ','
 786+ 5265              	; get cyclic flag
 787+ 5265 DD 21 1C 52  	LD IX, GETBYT
 788+ 5269 CD 59 01         CALL CALBAS
 789+ 526C F5           	PUSH AF
 790+ 526D              	; ending )
 791+ 526D CD A9 67     	CALL CHKCHAR
 792+ 5270 29           	DB ')'
 793+ 5271              .ENTRY:
 794+ 5271 E5               PUSH HL
 795+ 5272 DD E1            POP IX
 796+ 5274 D9               EXX
 797+ 5275 D1               POP DE ; cyclic
 798+ 5276 C1               POP BC ; animation definition id
 799+ 5277 E1               POP HL ; sprite number
 800+ 5278 D9               EXX
 801+ 5279 F1               POP AF ; sprite animation id
 802+ 527A CD 8B 4F         CALL GETnthSPRANIM
 803+ 527D E5               PUSH HL
 804+ 527E FD E1            POP IY
 805+ 5280 D9               EXX
 806+ 5281 FD 74 00         LD (IY),H
 807+ 5284 FD 70 04         LD (IY+4),B
 808+ 5287 FD 72 05         LD (IY+5),D
 809+ 528A                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 810+ 528A                  ; following will do preparation for ANIMSTEP situation
 811+ 528A                  ; current item set to above limit and timer to 1
 812+ 528A                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 813+ 528A FD 36 03 FF      LD (IY+3),255
 814+ 528E FD 36 01 01      LD (IY+1),1
 815+ 5292 FD 36 02 00      LD (IY+2),0
 816+ 5296                  ; mark as sprite animation
 817+ 5296 FD 36 07 00      LD (IY+7),0
 818+ 529A DD E5            PUSH IX
 819+ 529C E1               POP HL
 820+ 529D C9               RET
 821+ 529E              ; *******************************************************************************************************
 822+ 529E               ENDIF
 823+ 529E
 824+ 529E               IF (0 == 1)
 825+ 529E ~            ; *******************************************************************************************************
 826+ 529E ~            ; same as ANIMSPRITE but for DEFUSR approach
 827+ 529E ~            ; input IX=pointer to input array, real data from +2
 828+ 529E ~            ; +02 = ID
 829+ 529E ~            ; +04 = sprite number
 830+ 529E ~            ; +06 = animation definition id
 831+ 529E ~            ; +08 = cyclic flag
 832+ 529E ~            ANIMSPRITE_DEFUSR:
 833+ 529E ~                LD C,(IX+2)
 834+ 529E ~                INC C
 835+ 529E ~                LD A,(ANIMSPRNUM)
 836+ 529E ~                CP C
 837+ 529E ~                JR C,.ERR ; invalid id
 838+ 529E ~            	; get sprite number
 839+ 529E ~                LD A,(IX+4)
 840+ 529E ~                CP 32
 841+ 529E ~                JR NC,.ERR ; invalid sprite id
 842+ 529E ~                LD B,(IX+6)
 843+ 529E ~                INC B
 844+ 529E ~                LD A,(ANIMDEFNUM)
 845+ 529E ~                CP B
 846+ 529E ~                JR C,.ERR ; invalid animation definition id
 847+ 529E ~                LD A,C
 848+ 529E ~                DEC A
 849+ 529E ~                CALL GETnthSPRANIM
 850+ 529E ~                LD A,(IX+4)
 851+ 529E ~                LD (HL),A ; +0
 852+ 529E ~                INC HL
 853+ 529E ~                LD (HL),1 ; +1
 854+ 529E ~                INC HL
 855+ 529E ~                LD (HL),0 ; +2
 856+ 529E ~                INC HL
 857+ 529E ~                LD (HL),255 ; +3
 858+ 529E ~                INC HL
 859+ 529E ~                DEC B
 860+ 529E ~                LD (HL),B ; +4
 861+ 529E ~                INC HL
 862+ 529E ~                LD A,(IX+8) ; +5
 863+ 529E ~                LD (HL),A
 864+ 529E ~                INC HL
 865+ 529E ~                INC HL
 866+ 529E ~                LD (HL),0 ; +7
 867+ 529E ~                XOR A ; success
 868+ 529E ~                RET
 869+ 529E ~            .ERR:
 870+ 529E ~                LD A,1
 871+ 529E ~                RET
 872+ 529E ~            ; *******************************************************************************************************
 873+ 529E               ENDIF
 874+ 529E
 875+ 529E
 876+ 529E               IF (1 == 1)
 877+ 529E              ; *******************************************************************************************************
 878+ 529E              ; function to handle CALL ANIMCHAR basic extension
 879+ 529E              ; ANIMCHAR ( BYTE id,
 880+ 529E              ;            INT character number 0-767,
 881+ 529E              ;            BYTE animation_definition_id,
 882+ 529E              ;            BYTE cyclic_flag )
 883+ 529E              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 884+ 529E              ANIMCHAR:
 885+ 529E                  ; opening (
 886+ 529E CD A9 67     	CALL CHKCHAR
 887+ 52A1 28           	DB '('
 888+ 52A2              	; get sprite animation id
 889+ 52A2 DD 21 1C 52  	LD IX, GETBYT
 890+ 52A6 CD 59 01     	CALL CALBAS
 891+ 52A9 F5               PUSH AF
 892+ 52AA 3C               INC A
 893+ 52AB 4F               LD C,A
 894+ 52AC 3A 67 4F         LD A,(ANIMSPRNUM)
 895+ 52AF B9               CP C
 896+ 52B0 DA CD 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 897+ 52B3              	; comma
 898+ 52B3 CD A9 67     	CALL CHKCHAR
 899+ 52B6 2C           	DB ','
 900+ 52B7              	; get character number
 901+ 52B7 DD 21 2F 54  	LD IX, FRMQNT
 902+ 52BB CD 59 01     	CALL CALBAS
 903+ 52BE D5               PUSH DE
 904+ 52BF                  ; check if out of bounds
 905+ 52BF 7A               LD A,D
 906+ 52C0 FE 03            CP 3
 907+ 52C2 D2 CD 67         JP NC, SUBSCRIPT_OUT_OF_RANGE
 908+ 52C5              	; comma
 909+ 52C5 CD A9 67     	CALL CHKCHAR
 910+ 52C8 2C           	DB ','
 911+ 52C9              	; get animation definition id
 912+ 52C9 DD 21 1C 52  	LD IX, GETBYT
 913+ 52CD CD 59 01     	CALL CALBAS
 914+ 52D0 F5               PUSH AF
 915+ 52D1 3C               INC A
 916+ 52D2 4F               LD C,A
 917+ 52D3 3A 64 4F         LD A,(ANIMDEFNUM)
 918+ 52D6 B9               CP C
 919+ 52D7 DA CD 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 920+ 52DA              	; comma
 921+ 52DA CD A9 67     	CALL CHKCHAR
 922+ 52DD 2C           	DB ','
 923+ 52DE              	; get cyclic flag
 924+ 52DE DD 21 1C 52  	LD IX, GETBYT
 925+ 52E2 CD 59 01         CALL CALBAS
 926+ 52E5 F5           	PUSH AF
 927+ 52E6              	; ending )
 928+ 52E6 CD A9 67     	CALL CHKCHAR
 929+ 52E9 29           	DB ')'
 930+ 52EA              .ENTRY:
 931+ 52EA E5               PUSH HL
 932+ 52EB DD E1            POP IX
 933+ 52ED D9               EXX
 934+ 52EE D1               POP DE ; cyclic
 935+ 52EF C1               POP BC ; animation definition id
 936+ 52F0 E1               POP HL ; character number
 937+ 52F1 D9               EXX
 938+ 52F2 F1               POP AF ; sprite animation id
 939+ 52F3 CD 8B 4F         CALL GETnthSPRANIM
 940+ 52F6 E5               PUSH HL
 941+ 52F7 FD E1            POP IY
 942+ 52F9 D9               EXX
 943+ 52FA FD 75 00         LD (IY),L
 944+ 52FD 24               INC H ; save character bank+1
 945+ 52FE FD 74 07         LD (IY+7),H
 946+ 5301 FD 70 04         LD (IY+4),B
 947+ 5304 FD 72 05         LD (IY+5),D
 948+ 5307                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 949+ 5307                  ; following will do preparation for ANIMSTEP situation
 950+ 5307                  ; current item set to above limit and timer to 1
 951+ 5307                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 952+ 5307 FD 36 03 FF      LD (IY+3),255
 953+ 530B FD 36 01 01      LD (IY+1),1
 954+ 530F FD 36 02 00      LD (IY+2),0
 955+ 5313 DD E5            PUSH IX
 956+ 5315 E1               POP HL
 957+ 5316 C9               RET
 958+ 5317              ; *******************************************************************************************************
 959+ 5317               ENDIF
 960+ 5317
 961+ 5317               IF (0 == 1)
 962+ 5317 ~            ; *******************************************************************************************************
 963+ 5317 ~            ; same as ANIMCHAR but for DEFUSR approach
 964+ 5317 ~            ; input IX=pointer to input array, real data from +2
 965+ 5317 ~            ; +02 = ID
 966+ 5317 ~            ; +04 = character number
 967+ 5317 ~            ; +06 = animation definition id
 968+ 5317 ~            ; +08 = cyclic flag
 969+ 5317 ~            ANIMCHAR_DEFUSR:
 970+ 5317 ~                LD C,(IX+2)
 971+ 5317 ~                INC C
 972+ 5317 ~                LD A,(ANIMSPRNUM)
 973+ 5317 ~                CP C
 974+ 5317 ~                JR C,.ERR ; invalid id
 975+ 5317 ~            	; get sprite number
 976+ 5317 ~                LD A,(IX+5)
 977+ 5317 ~                CP 3
 978+ 5317 ~                JR NC,.ERR ; invalid character (>767)
 979+ 5317 ~                LD B,(IX+6)
 980+ 5317 ~                INC B
 981+ 5317 ~                LD A,(ANIMDEFNUM)
 982+ 5317 ~                CP B
 983+ 5317 ~                JR C,.ERR ; invalid animation definition id
 984+ 5317 ~                LD A,C
 985+ 5317 ~                DEC A
 986+ 5317 ~                CALL GETnthSPRANIM
 987+ 5317 ~                LD A,(IX+4)
 988+ 5317 ~                LD (HL),A ; +0
 989+ 5317 ~                INC HL
 990+ 5317 ~                LD (HL),1 ; +1
 991+ 5317 ~                INC HL
 992+ 5317 ~                LD (HL),0 ; +2
 993+ 5317 ~                INC HL
 994+ 5317 ~                LD (HL),255 ; +3
 995+ 5317 ~                INC HL
 996+ 5317 ~                DEC B
 997+ 5317 ~                LD (HL),B ; +4
 998+ 5317 ~                INC HL
 999+ 5317 ~                LD A,(IX+8) ; +5
1000+ 5317 ~                LD (HL),A
1001+ 5317 ~                INC HL
1002+ 5317 ~                INC HL
1003+ 5317 ~                LD A,(IX+5)
1004+ 5317 ~                INC A
1005+ 5317 ~                LD (HL),A ; +7
1006+ 5317 ~                XOR A ; success
1007+ 5317 ~                RET
1008+ 5317 ~            .ERR:
1009+ 5317 ~                LD A,1
1010+ 5317 ~                RET
1011+ 5317 ~            ; *******************************************************************************************************
1012+ 5317               ENDIF
1013+ 5317
1014+ 5317               IF (0 == 1)
1015+ 5317 ~            ; *******************************************************************************************************
1016+ 5317 ~            ; same as MAXAUTOSGAMS but for DEFUSR approach
1017+ 5317 ~            ; input IX=pointer to input array, real data from +2
1018+ 5317 ~            ; +2 = number
1019+ 5317 ~            MAXAUTOSGAMS_DEFUSR:
1020+ 5317 ~                LD A,(IX+2)
1021+ 5317 ~                CALL MAXAUTOSGAMS.COMMON
1022+ 5317 ~                XOR A ; success
1023+ 5317 ~                RET
1024+ 5317 ~            ; *******************************************************************************************************
1025+ 5317               ENDIF
1026+ 5317
1027+ 5317              ; *******************************************************************************************************
1028+ 5317              ; function to handle CALL MAXAUTOSGAMS basic extension
1029+ 5317              ; MAXAUTOSGAMS (BYTE number)
1030+ 5317              ; sets new number and moves memory buffers as needed
1031+ 5317              MAXAUTOSGAMS:
1032+ 5317               IF (1 == 1)
1033+ 5317              	; opening (
1034+ 5317 CD A9 67     	CALL CHKCHAR
1035+ 531A 28           	DB '('
1036+ 531B              	; get value
1037+ 531B DD 21 1C 52  	LD IX, GETBYT
1038+ 531F CD 59 01     	CALL CALBAS
1039+ 5322 F5               PUSH AF
1040+ 5323              	; ending )
1041+ 5323 CD A9 67     	CALL CHKCHAR
1042+ 5326 29           	DB ')'
1043+ 5327 F1               POP AF
1044+ 5328               ENDIF
1045+ 5328              .COMMON:
1046+ 5328 F3               DI
1047+ 5329              	; save position
1048+ 5329 E5           	PUSH HL
1049+ 532A              .ENTRY:
1050+ 532A 47               LD B,A
1051+ 532B 3A 6A 4F         LD A,(AUTOSGAMNUM)
1052+ 532E 90               SUB B
1053+ 532F CA E9 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
1054+ 5332 FD 21 10 40      LD IY,FREEMEMPTR
1055+ 5336 FA 42 53         JP M, .INCREASE
1056+ 5339                  ; new value is lower than previous one
1057+ 5339 CD 63 53         CALL .SIZEDIFF
1058+ 533C CD 26 50         CALL MAXANIMITEMS.DECREASE_COMMON
1059+ 533F C3 E9 4F         JP MAXANIMITEMS.EXIT
1060+ 5342              .INCREASE:
1061+ 5342 ED 44            NEG
1062+ 5344 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
1063+ 5345 CD 63 53         CALL .SIZEDIFF
1064+ 5348 CD 52 50         CALL MAXANIMITEMS.INCREASE_COMMON
1065+ 534B AF               XOR A
1066+ 534C ED 42            SBC HL,BC ; location of new stuff
1067+ 534E F1               POP AF
1068+ 534F C5               PUSH BC
1069+ 5350 47               LD B,A
1070+ 5351 11 18 00         LD DE,24
1071+ 5354 E5               PUSH HL
1072+ 5355 DD E1            POP IX
1073+ 5357              .L1:
1074+ 5357 DD 36 13 00      LD (IX+19),0 ; active flag
1075+ 535B DD 19            ADD IX,DE
1076+ 535D 10 F8            DJNZ .L1
1077+ 535F C1               POP BC
1078+ 5360 C3 E9 4F         JP MAXANIMITEMS.EXIT
1079+ 5363              .SIZEDIFF:
1080+ 5363 26 00            LD H,0
1081+ 5365 6F               LD L,A
1082+ 5366 CD 96 66         CALL HLx8
1083+ 5369 54               LD D,H
1084+ 536A 5D               LD E,L
1085+ 536B 29               ADD HL,HL
1086+ 536C 19               ADD HL,DE
1087+ 536D 78               LD A,B
1088+ 536E 32 6A 4F         LD (AUTOSGAMNUM),A
1089+ 5371 44               LD B,H
1090+ 5372 4D               LD C,L
1091+ 5373 C9               RET ; BC=size difference in bytes
1092+ 5374              ; *******************************************************************************************************
1093+ 5374
1094+ 5374               IF (1 == 1)
1095+ 5374              ; *******************************************************************************************************
1096+ 5374              ; function to handle CALL AUTOSGAMDEF basic extension
1097+ 5374              ; AUTOSGAMDEF ( BYTE id,
1098+ 5374              ;               INT VARIABLE x, INT VARIABLE y,
1099+ 5374              ;               INT minimum, INT maximum, INT delta,
1100+ 5374              ;               INT direction =0 horizontal,
1101+ 5374              ;               INT ticks,
1102+ 5374              ;               BYTE sprite_group_count,
1103+ 5374              ;               INT[2][sprite_group_count] VARIABLE sprite_group,
1104+ 5374              ;               BYTE item_number,
1105+ 5374              ;               INT[] VARIABLE sprite_animations_negative_direction,
1106+ 5374              ;               INT[] VARIABLE sprite_animations_positive_direction
1107+ 5374              AUTOSGAMDEF:
1108+ 5374                  ; opening (
1109+ 5374 CD A9 67     	CALL CHKCHAR
1110+ 5377 28           	DB '('
1111+ 5378              	; get sprite animation id
1112+ 5378 DD 21 1C 52  	LD IX, GETBYT
1113+ 537C CD 59 01     	CALL CALBAS
1114+ 537F F5               PUSH AF
1115+ 5380 3C               INC A
1116+ 5381 4F               LD C,A
1117+ 5382 3A 6A 4F         LD A,(AUTOSGAMNUM)
1118+ 5385 B9               CP C
1119+ 5386 DA CD 67         JP C,SUBSCRIPT_OUT_OF_RANGE
1120+ 5389 F1               POP AF
1121+ 538A E5               PUSH HL
1122+ 538B CD 97 4F         CALL GETnthAUTOSGAM
1123+ 538E 22 78 64         LD (BLIT_TMP),HL ; for later
1124+ 5391 E1               POP HL
1125+ 5392              	; comma
1126+ 5392 CD A9 67     	CALL CHKCHAR
1127+ 5395 2C           	DB ','
1128+ 5396              	; get address of the X coordinate variable
1129+ 5396 DD 21 A4 5E  	LD IX, PTRGET
1130+ 539A CD 59 01     	CALL CALBAS
1131+ 539D DD 2A 78 64  	LD IX,(BLIT_TMP)
1132+ 53A1 DD 73 00         LD (IX+0),E
1133+ 53A4 DD 72 01         LD (IX+1),D
1134+ 53A7              	; comma
1135+ 53A7 CD A9 67     	CALL CHKCHAR
1136+ 53AA 2C           	DB ','
1137+ 53AB              	; get address of the Y coordinate variable
1138+ 53AB DD 21 A4 5E  	LD IX, PTRGET
1139+ 53AF CD 59 01     	CALL CALBAS
1140+ 53B2 DD 2A 78 64  	LD IX,(BLIT_TMP)
1141+ 53B6 DD 73 02         LD (IX+2),E
1142+ 53B9 DD 72 03         LD (IX+3),D
1143+ 53BC              	; comma
1144+ 53BC CD A9 67     	CALL CHKCHAR
1145+ 53BF 2C           	DB ','
1146+ 53C0              	; get minimum value
1147+ 53C0 DD 21 2F 54  	LD IX, FRMQNT
1148+ 53C4 CD 59 01     	CALL CALBAS
1149+ 53C7 DD 2A 78 64  	LD IX,(BLIT_TMP)
1150+ 53CB DD 73 04         LD (IX+4),E
1151+ 53CE DD 72 05         LD (IX+5),D
1152+ 53D1              	; comma
1153+ 53D1 CD A9 67     	CALL CHKCHAR
1154+ 53D4 2C           	DB ','
1155+ 53D5              	; get maximum value
1156+ 53D5 DD 21 2F 54  	LD IX, FRMQNT
1157+ 53D9 CD 59 01     	CALL CALBAS
1158+ 53DC DD 2A 78 64  	LD IX,(BLIT_TMP)
1159+ 53E0 DD 73 06         LD (IX+6),E
1160+ 53E3 DD 72 07         LD (IX+7),D
1161+ 53E6              	; comma
1162+ 53E6 CD A9 67     	CALL CHKCHAR
1163+ 53E9 2C           	DB ','
1164+ 53EA              	; get delta value
1165+ 53EA DD 21 2F 54  	LD IX, FRMQNT
1166+ 53EE CD 59 01     	CALL CALBAS
1167+ 53F1 DD 2A 78 64  	LD IX,(BLIT_TMP)
1168+ 53F5 DD 73 08         LD (IX+8),E
1169+ 53F8 DD 72 09         LD (IX+9),D
1170+ 53FB              	; comma
1171+ 53FB CD A9 67     	CALL CHKCHAR
1172+ 53FE 2C           	DB ','
1173+ 53FF              	; get direction value
1174+ 53FF DD 21 2F 54  	LD IX, FRMQNT
1175+ 5403 CD 59 01     	CALL CALBAS
1176+ 5406 DD 2A 78 64  	LD IX,(BLIT_TMP)
1177+ 540A DD 73 0A         LD (IX+10),E
1178+ 540D              	; comma
1179+ 540D CD A9 67     	CALL CHKCHAR
1180+ 5410 2C           	DB ','
1181+ 5411              	; get ticks value
1182+ 5411 DD 21 2F 54  	LD IX, FRMQNT
1183+ 5415 CD 59 01     	CALL CALBAS
1184+ 5418 DD 2A 78 64  	LD IX,(BLIT_TMP)
1185+ 541C DD 73 14         LD (IX+20),E
1186+ 541F DD 72 15         LD (IX+21),D
1187+ 5422              	; comma
1188+ 5422 CD A9 67     	CALL CHKCHAR
1189+ 5425 2C           	DB ','
1190+ 5426              	; get sprite group count
1191+ 5426 DD 21 1C 52  	LD IX, GETBYT
1192+ 542A CD 59 01     	CALL CALBAS
1193+ 542D B7               OR A
1194+ 542E CA CD 67         JP Z,SUBSCRIPT_OUT_OF_RANGE
1195+ 5431 DD 2A 78 64  	LD IX,(BLIT_TMP)
1196+ 5435 DD 77 0B         LD (IX+11),A
1197+ 5438              	; comma
1198+ 5438 CD A9 67     	CALL CHKCHAR
1199+ 543B 2C           	DB ','
1200+ 543C              	; get sprite group definition array data pointer
1201+ 543C DD 2A 78 64  	LD IX,(BLIT_TMP)
1202+ 5440 DD 5E 0B         LD E,(IX+11)
1203+ 5443 16 03        	LD D,3
1204+ 5445 3E 02        	LD A,2
1205+ 5447 47           	LD B,A
1206+ 5448 CD 0E 68     	CALL GET_BASIC_ARRAY_DATA_POINTER
1207+ 544B DD 2A 78 64  	LD IX,(BLIT_TMP)
1208+ 544F DD 71 0C     	LD (IX+12),C
1209+ 5452 DD 70 0D         LD (IX+13),B
1210+ 5455              	; comma
1211+ 5455 CD A9 67     	CALL CHKCHAR
1212+ 5458 2C           	DB ','
1213+ 5459              	; get sprite animation array size
1214+ 5459 DD 21 1C 52  	LD IX,GETBYT
1215+ 545D CD 59 01     	CALL CALBAS
1216+ 5460 DD 2A 78 64  	LD IX,(BLIT_TMP)
1217+ 5464 DD 77 0E         LD (IX+14),A
1218+ 5467 B7               OR A
1219+ 5468 CA CD 67         JP Z,SUBSCRIPT_OUT_OF_RANGE
1220+ 546B              	; comma
1221+ 546B CD A9 67     	CALL CHKCHAR
1222+ 546E 2C           	DB ','
1223+ 546F                  ; get array pointer for negative direction
1224+ 546F DD 2A 78 64  	LD IX,(BLIT_TMP)
1225+ 5473 DD 56 0E         LD D,(IX+14)
1226+ 5476 3E 02            LD A,2
1227+ 5478 06 01            LD B,1
1228+ 547A CD 0E 68         CALL GET_BASIC_ARRAY_DATA_POINTER
1229+ 547D DD 2A 78 64  	LD IX,(BLIT_TMP)
1230+ 5481 DD 71 0F         LD (IX+15),C
1231+ 5484 DD 70 10         LD (IX+16),B
1232+ 5487              	; comma
1233+ 5487 CD A9 67     	CALL CHKCHAR
1234+ 548A 2C           	DB ','
1235+ 548B                  ; get array pointer for positive direction
1236+ 548B DD 2A 78 64  	LD IX,(BLIT_TMP)
1237+ 548F DD 56 0E         LD D,(IX+14)
1238+ 5492 3E 02            LD A,2
1239+ 5494 06 01            LD B,1
1240+ 5496 CD 0E 68         CALL GET_BASIC_ARRAY_DATA_POINTER
1241+ 5499 DD 2A 78 64  	LD IX,(BLIT_TMP)
1242+ 549D DD 71 11         LD (IX+17),C
1243+ 54A0 DD 70 12         LD (IX+18),B
1244+ 54A3              	; ending )
1245+ 54A3 CD A9 67     	CALL CHKCHAR
1246+ 54A6 29           	DB ')'
1247+ 54A7 C9               RET
1248+ 54A8              ; *******************************************************************************************************
1249+ 54A8               ENDIF
1250+ 54A8
1251+ 54A8               IF (0 == 1)
1252+ 54A8 ~            ; *******************************************************************************************************
1253+ 54A8 ~            ; same as AUTOSGAMDEF but for DEFUSR approach
1254+ 54A8 ~            ; input IX=pointer to input array, real data from +2
1255+ 54A8 ~            ; +02 = ID
1256+ 54A8 ~            ; +04 = pointer to X variable
1257+ 54A8 ~            ; +06 = pointer to Y variable
1258+ 54A8 ~            ; +08 = minimum
1259+ 54A8 ~            ; +10 = maximum
1260+ 54A8 ~            ; +12 = delta
1261+ 54A8 ~            ; +14 = direction
1262+ 54A8 ~            ; +16 = ticks
1263+ 54A8 ~            ; +18 = sprite group count
1264+ 54A8 ~            ; +20 = sprite group array pointer
1265+ 54A8 ~            ; +22 = item number
1266+ 54A8 ~            ; +24 = sprite animations negative direction array pointer
1267+ 54A8 ~            ; +26 = sprite animations positive direction array pointer
1268+ 54A8 ~            AUTOSGAMDEF_DEFUSR:
1269+ 54A8 ~                LD C,(IX+2)
1270+ 54A8 ~                INC C
1271+ 54A8 ~                LD A,(AUTOSGAMNUM)
1272+ 54A8 ~                CP C
1273+ 54A8 ~                JP C,.ERR ; invalid id
1274+ 54A8 ~                LD A,C
1275+ 54A8 ~                DEC A
1276+ 54A8 ~                CALL GETnthAUTOSGAM
1277+ 54A8 ~                PUSH HL
1278+ 54A8 ~                POP IY
1279+ 54A8 ~                ; X variable
1280+ 54A8 ~                LD A,(IX+4)
1281+ 54A8 ~                LD (IY+0),A
1282+ 54A8 ~                LD A,(IX+5)
1283+ 54A8 ~                LD (IY+1),A
1284+ 54A8 ~            	; Y variable
1285+ 54A8 ~                LD A,(IX+6)
1286+ 54A8 ~                LD (IY+2),A
1287+ 54A8 ~                LD A,(IX+7)
1288+ 54A8 ~                LD (IY+3),A
1289+ 54A8 ~            	; get minimum value
1290+ 54A8 ~                LD A,(IX+8)
1291+ 54A8 ~                LD (IY+4),A
1292+ 54A8 ~                LD A,(IX+9)
1293+ 54A8 ~                LD (IY+5),A
1294+ 54A8 ~            	; get maximum value
1295+ 54A8 ~                LD A,(IX+10)
1296+ 54A8 ~                LD (IY+6),A
1297+ 54A8 ~                LD A,(IX+11)
1298+ 54A8 ~                LD (IY+7),A
1299+ 54A8 ~            	; get delta value
1300+ 54A8 ~                LD A,(IX+12)
1301+ 54A8 ~                LD (IY+8),A
1302+ 54A8 ~                LD A,(IX+13)
1303+ 54A8 ~                LD (IY+9),A
1304+ 54A8 ~            	; get direction value
1305+ 54A8 ~                LD A,(IX+14)
1306+ 54A8 ~                LD (IY+10),A
1307+ 54A8 ~            	; get ticks value
1308+ 54A8 ~                LD A,(IX+16)
1309+ 54A8 ~                LD (IY+20),A
1310+ 54A8 ~                LD A,(IX+17)
1311+ 54A8 ~                LD (IY+21),A
1312+ 54A8 ~            	; get sprite group count
1313+ 54A8 ~                LD A,(IX+18)
1314+ 54A8 ~                LD (IY+11),A
1315+ 54A8 ~            	; get sprite group definition array data pointer
1316+ 54A8 ~                LD A,(IX+20)
1317+ 54A8 ~                LD (IY+12),A
1318+ 54A8 ~                LD A,(IX+21)
1319+ 54A8 ~                LD (IY+13),A
1320+ 54A8 ~            	; get sprite animation array size
1321+ 54A8 ~                LD A,(IX+22)
1322+ 54A8 ~                LD (IY+14),A
1323+ 54A8 ~                ; get array pointer for negative direction
1324+ 54A8 ~                LD A,(IX+24)
1325+ 54A8 ~                LD (IY+15),A
1326+ 54A8 ~                LD A,(IX+25)
1327+ 54A8 ~                LD (IY+16),A
1328+ 54A8 ~                ; get array pointer for positive direction
1329+ 54A8 ~                LD A,(IX+26)
1330+ 54A8 ~                LD (IY+17),A
1331+ 54A8 ~                LD A,(IX+27)
1332+ 54A8 ~                LD (IY+18),A
1333+ 54A8 ~                XOR A ; success
1334+ 54A8 ~                RET
1335+ 54A8 ~            .ERR:
1336+ 54A8 ~                LD A,1
1337+ 54A8 ~                RET
1338+ 54A8 ~            ; *******************************************************************************************************
1339+ 54A8               ENDIF
1340+ 54A8
1341+ 54A8               IF (1 == 1)
1342+ 54A8              ; *******************************************************************************************************
1343+ 54A8              ; function to handle CALL AUTOSGAMSTART basic extension
1344+ 54A8              ; AUTOSGAMSTART ( BYTE id )
1345+ 54A8              AUTOSGAMSTART:
1346+ 54A8 3E 01            LD A,1
1347+ 54AA              .COMMON:
1348+ 54AA 32 D6 54         LD (.SETVALUE+3),A
1349+ 54AD                  ; opening (
1350+ 54AD CD A9 67     	CALL CHKCHAR
1351+ 54B0 28           	DB '('
1352+ 54B1              	; get sprite animation id
1353+ 54B1 DD 21 1C 52  	LD IX, GETBYT
1354+ 54B5 CD 59 01     	CALL CALBAS
1355+ 54B8 F5               PUSH AF
1356+ 54B9 3C               INC A
1357+ 54BA 4F               LD C,A
1358+ 54BB 3A 6A 4F         LD A,(AUTOSGAMNUM)
1359+ 54BE B9               CP C
1360+ 54BF DA CD 67         JP C,SUBSCRIPT_OUT_OF_RANGE
1361+ 54C2 F1               POP AF
1362+ 54C3 E5               PUSH HL
1363+ 54C4 CD 97 4F         CALL GETnthAUTOSGAM
1364+ 54C7 E5               PUSH HL
1365+ 54C8 DD E1            POP IX
1366+ 54CA E1               POP HL
1367+ 54CB DD E5            PUSH IX
1368+ 54CD              	; ending )
1369+ 54CD CD A9 67     	CALL CHKCHAR
1370+ 54D0 29           	DB ')'
1371+ 54D1
1372+ 54D1                  ; so syntax is fine
1373+ 54D1 DD E1            POP IX
1374+ 54D3              .SETVALUE:
1375+ 54D3 DD 36 13 01      LD (IX+19),1 ; active flag
1376+ 54D7                  ; set initial timer
1377+ 54D7 DD 7E 14         LD A,(IX+20)
1378+ 54DA DD 77 16         LD (IX+22),A
1379+ 54DD DD 7E 15         LD A,(IX+21)
1380+ 54E0 DD 77 17         LD (IX+23),A
1381+ 54E3 C9               RET
1382+ 54E4              ; *******************************************************************************************************
1383+ 54E4
1384+ 54E4              ; *******************************************************************************************************
1385+ 54E4              ; function to handle CALL AUTOSGAMSTOP basic extension
1386+ 54E4              ; AUTOSGAMSTOP ( BYTE id )
1387+ 54E4              AUTOSGAMSTOP:
1388+ 54E4 AF               XOR A
1389+ 54E5 18 C3            JR AUTOSGAMSTART.COMMON
1390+ 54E7              ; *******************************************************************************************************
1391+ 54E7               ENDIF
1392+ 54E7
1393+ 54E7               IF (0 == 1)
1394+ 54E7 ~            ; *******************************************************************************************************
1395+ 54E7 ~            ; function to handle CALL AUTOSGAMSTART basic extension in DEFUSR mode
1396+ 54E7 ~            ; input IX=pointer to input array, real data from +2
1397+ 54E7 ~            ; +2 = source address
1398+ 54E7 ~            AUTOSGAMSTART_DEFUSR:
1399+ 54E7 ~                LD A,1
1400+ 54E7 ~            .COMMON:
1401+ 54E7 ~                LD (.SETVALUE+3),A
1402+ 54E7 ~                LD C,(IX+2)
1403+ 54E7 ~                INC C
1404+ 54E7 ~                LD A,(AUTOSGAMNUM)
1405+ 54E7 ~                CP C
1406+ 54E7 ~                JR C,.ERR ; invalid id
1407+ 54E7 ~                LD A,C
1408+ 54E7 ~                DEC A
1409+ 54E7 ~                CALL GETnthAUTOSGAM
1410+ 54E7 ~                PUSH HL
1411+ 54E7 ~                POP IX
1412+ 54E7 ~            .SETVALUE:
1413+ 54E7 ~                LD (IX+19),1 ; active flag
1414+ 54E7 ~                ; set initial timer
1415+ 54E7 ~                LD A,(IX+20)
1416+ 54E7 ~                LD (IX+22),A
1417+ 54E7 ~                LD A,(IX+21)
1418+ 54E7 ~                LD (IX+23),A
1419+ 54E7 ~                XOR A ; success
1420+ 54E7 ~                RET
1421+ 54E7 ~            .ERR:
1422+ 54E7 ~                LD A,1
1423+ 54E7 ~                RET
1424+ 54E7 ~            ; *******************************************************************************************************
1425+ 54E7 ~
1426+ 54E7 ~            ; *******************************************************************************************************
1427+ 54E7 ~            ; function to handle CALL AUTOSGAMSTOP basic extension in DEFUSR mode
1428+ 54E7 ~            ; input IX=pointer to input array, real data from +2
1429+ 54E7 ~            ; +2 = source address
1430+ 54E7 ~            AUTOSGAMSTOP_DEFUSR:
1431+ 54E7 ~                XOR A
1432+ 54E7 ~                JR AUTOSGAMSTART_DEFUSR.COMMON
1433+ 54E7 ~            ; *******************************************************************************************************
1434+ 54E7               ENDIF
1435+ 54E7
1436+ 54E7               IF (1 == 1)
1437+ 54E7              ; *******************************************************************************************************
1438+ 54E7              ; function to handle CALL ANIMSTEP basic extension
1439+ 54E7              ; two forms
1440+ 54E7              ; ANIMSTEP ( BYTE id )
1441+ 54E7              ; or
1442+ 54E7              ; ANIMSTEP ( BYTE item_number,
1443+ 54E7              ;            INT[] sprite_animations )
1444+ 54E7              ANIMSTEP:
1445+ 54E7 11 66 55         LD DE,ANIMSTARTSTOP_COMMON.STEP
1446+ 54EA 18 08            JR ANIMSTARTSTOP_COMMON
1447+ 54EC              ; *******************************************************************************************************
1448+ 54EC              ; *******************************************************************************************************
1449+ 54EC              ; function to handle CALL ANIMSTART basic extension
1450+ 54EC              ; two forms
1451+ 54EC              ; ANIMSTART ( BYTE id )
1452+ 54EC              ; or
1453+ 54EC              ; ANIMSTART ( BYTE item_number,
1454+ 54EC              ;             INT[] sprite_animations )
1455+ 54EC              ; sets active flag to 1
1456+ 54EC              ANIMSTART:
1457+ 54EC 11 54 55         LD DE,ANIMSTARTSTOP_COMMON.START
1458+ 54EF 18 03            JR ANIMSTARTSTOP_COMMON
1459+ 54F1              ; *******************************************************************************************************
1460+ 54F1              ; *******************************************************************************************************
1461+ 54F1              ; function to handle CALL ANIMSTOP basic extension
1462+ 54F1              ; two forms
1463+ 54F1              ; ANIMSTOP ( BYTE id )
1464+ 54F1              ; or
1465+ 54F1              ; ANIMSTOP ( BYTE item_number,
1466+ 54F1              ;            INT[] sprite_animations )
1467+ 54F1              ; sets active flag to 0
1468+ 54F1              ANIMSTOP:
1469+ 54F1 11 61 55         LD DE,ANIMSTARTSTOP_COMMON.STOP
1470+ 54F4              ; *******************************************************************************************************
1471+ 54F4              ANIMSTARTSTOP_COMMON:
1472+ 54F4 ED 53 52 55      LD (ANIMSTARTSTOP_COMMON.FN+1),DE
1473+ 54F8                  ; opening (
1474+ 54F8 CD A9 67     	CALL CHKCHAR
1475+ 54FB 28           	DB '('
1476+ 54FC              	; get sprite animation id or array size
1477+ 54FC DD 21 1C 52  	LD IX,GETBYT
1478+ 5500 CD 59 01     	CALL CALBAS
1479+ 5503 F5               PUSH AF
1480+ 5504                  ; check if comma present
1481+ 5504 CD B3 67         CALL GETPREVCHAR
1482+ 5507 23               INC HL
1483+ 5508 FE 2C            CP ','
1484+ 550A 28 0E            JR Z,.L1
1485+ 550C FE 29            CP ')'
1486+ 550E C2 D9 67         JP NZ,SYNTAX_ERROR
1487+ 5511                  ; ok so single argument variant
1488+ 5511 F1               POP AF
1489+ 5512 E5               PUSH HL
1490+ 5513 F3               DI
1491+ 5514 CD 40 55         CALL .SETVALUE
1492+ 5517 FB               EI
1493+ 5518 E1               POP HL
1494+ 5519 C9               RET
1495+ 551A              .L1:
1496+ 551A                  ; get array pointer
1497+ 551A D1               POP DE
1498+ 551B D5               PUSH DE
1499+ 551C 3E 02            LD A,2
1500+ 551E 06 01            LD B,1
1501+ 5520 CD 0E 68         CALL GET_BASIC_ARRAY_DATA_POINTER
1502+ 5523 C5               PUSH BC
1503+ 5524              	; ending )
1504+ 5524 CD A9 67     	CALL CHKCHAR
1505+ 5527 29           	DB ')'
1506+ 5528 D1               POP DE ; array pointer
1507+ 5529 C1               POP BC ; number of items
1508+ 552A 78               LD A,B
1509+ 552B B7               OR A
1510+ 552C CA CD 67         JP Z,SUBSCRIPT_OUT_OF_RANGE
1511+ 552F E5               PUSH HL
1512+ 5530 F3               DI
1513+ 5531              .L2:
1514+ 5531 C5               PUSH BC
1515+ 5532 1A               LD A,(DE)
1516+ 5533 13          > INC DE
1516+ 5534 13          > INC DE
1517+ 5535 D5               PUSH DE
1518+ 5536 CD 40 55         CALL .SETVALUE
1519+ 5539 D1               POP DE
1520+ 553A C1               POP BC
1521+ 553B 10 F4            DJNZ .L2
1522+ 553D FB               EI
1523+ 553E E1               POP HL
1524+ 553F C9               RET
1525+ 5540
1526+ 5540              .SETVALUE:
1527+ 5540 47               LD B,A
1528+ 5541 3C               INC A
1529+ 5542 4F               LD C,A
1530+ 5543 3A 67 4F         LD A,(ANIMSPRNUM)
1531+ 5546 B9               CP C
1532+ 5547 DA CD 67         JP C,SUBSCRIPT_OUT_OF_RANGE
1533+ 554A 78               LD A,B
1534+ 554B CD 8B 4F         CALL GETnthSPRANIM
1535+ 554E E5               PUSH HL
1536+ 554F DD E1            POP IX
1537+ 5551              .FN:
1538+ 5551 C3 00 00         JP 0
1539+ 5554              .START:
1540+ 5554 DD 36 06 01      LD (IX+6),1 ; active flag
1541+ 5558 DD 36 03 00      LD (IX+3),0 ; current item
1542+ 555C 06 00            LD B,0 ; setup timer
1543+ 555E C3 F7 55         JP SETUP_ANIM_STEP
1544+ 5561              .STOP:
1545+ 5561 DD 36 06 00      LD (IX+6),0 ; active flag
1546+ 5565 C9               RET
1547+ 5566              .STEP:
1548+ 5566 06 00            LD B,0
1549+ 5568 C3 9B 55         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1550+ 556B              ; *******************************************************************************************************
1551+ 556B               ENDIF
1552+ 556B
1553+ 556B              ; *******************************************************************************************************
1554+ 556B              ; helper function to locate single animation and execute operation
1555+ 556B              ; needs to have jump set to a correct function
1556+ 556B              ; used by SGAM helper routines so always needed
1557+ 556B              ; input A=animation item
1558+ 556B              ANIM_SETVALUE:
1559+ 556B 47               LD B,A
1560+ 556C 3C               INC A
1561+ 556D 4F               LD C,A
1562+ 556E 3A 67 4F         LD A,(ANIMSPRNUM)
1563+ 5571 B9               CP C
1564+ 5572 D8               RET C ; out of range, so do nothing
1565+ 5573 78               LD A,B
1566+ 5574 CD 8B 4F         CALL GETnthSPRANIM
1567+ 5577 E5               PUSH HL
1568+ 5578 DD E1            POP IX
1569+ 557A              .FN:
1570+ 557A C3 00 00         JP 0
1571+ 557D              ; *******************************************************************************************************
1572+ 557D
1573+ 557D               IF (0 == 1)
1574+ 557D ~            ; *******************************************************************************************************
1575+ 557D ~            ; helper function to set values of multiple animations
1576+ 557D ~            ; needs to have jump set to a correct function
1577+ 557D ~            ; input B=number of animation item
1578+ 557D ~            ; input DE=animation item array
1579+ 557D ~            ANIM_LIST_SETVALUE:
1580+ 557D ~                DI
1581+ 557D ~                PUSH BC
1582+ 557D ~                LD A,(DE)
1583+ 557D ~                .2 INC DE
1584+ 557D ~                PUSH DE
1585+ 557D ~                CALL ANIM_SETVALUE
1586+ 557D ~                POP DE
1587+ 557D ~                POP BC
1588+ 557D ~                DJNZ ANIM_LIST_SETVALUE
1589+ 557D ~                EI
1590+ 557D ~                RET
1591+ 557D ~            ; *******************************************************************************************************
1592+ 557D ~
1593+ 557D ~            ; *******************************************************************************************************
1594+ 557D ~            ; function to handle single item ANIMSTEP in DEFUSR mode
1595+ 557D ~            ; input IX=pointer to input array, real data from +2
1596+ 557D ~            ; +2 = animation id
1597+ 557D ~            ANIMSTEP_SINGLE_DEFUSR:
1598+ 557D ~                LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1599+ 557D ~            .L1:
1600+ 557D ~                LD (ANIM_SETVALUE.FN+1),HL
1601+ 557D ~                LD A,(IX+2)
1602+ 557D ~                JR ANIM_SETVALUE
1603+ 557D ~            .STEP:
1604+ 557D ~                LD B,0
1605+ 557D ~                JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1606+ 557D ~            ; *******************************************************************************************************
1607+ 557D ~
1608+ 557D ~            ; *******************************************************************************************************
1609+ 557D ~            ; function to handle multi item ANIMSTEP in DEFUSR mode
1610+ 557D ~            ; input IX=pointer to input array, real data from +2
1611+ 557D ~            ; +2 = list size
1612+ 557D ~            ; +4 = array pointer holding items
1613+ 557D ~            ANIMSTEP_MULTI_DEFUSR:
1614+ 557D ~                LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1615+ 557D ~            .L1:
1616+ 557D ~                LD (ANIM_SETVALUE.FN+1),HL
1617+ 557D ~                LD B,(IX+2)
1618+ 557D ~                LD E,(IX+4)
1619+ 557D ~                LD D,(IX+5)
1620+ 557D ~                JR ANIM_LIST_SETVALUE
1621+ 557D ~            ; *******************************************************************************************************
1622+ 557D ~
1623+ 557D ~            ; *******************************************************************************************************
1624+ 557D ~            ; function to handle single item ANIMSTART in DEFUSR mode
1625+ 557D ~            ; input IX=pointer to input array, real data from +2
1626+ 557D ~            ; +2 = animation id
1627+ 557D ~            ANIMSTART_SINGLE_DEFUSR:
1628+ 557D ~                LD HL,ANIMSTART_SINGLE_DEFUSR.START
1629+ 557D ~                JR ANIMSTEP_SINGLE_DEFUSR.L1
1630+ 557D ~            .START:
1631+ 557D ~                LD (IX+6),1 ; active flag
1632+ 557D ~                LD (IX+3),0 ; current item
1633+ 557D ~                LD B,0 ; setup timer
1634+ 557D ~                JP SETUP_ANIM_STEP
1635+ 557D ~            ; *******************************************************************************************************
1636+ 557D ~
1637+ 557D ~            ; *******************************************************************************************************
1638+ 557D ~            ; function to handle multi item ANIMSTART in DEFUSR mode
1639+ 557D ~            ; input IX=pointer to input array, real data from +2
1640+ 557D ~            ; +2 = list size
1641+ 557D ~            ; +4 = array pointer holding items
1642+ 557D ~            ANIMSTART_MULTI_DEFUSR:
1643+ 557D ~                LD HL,ANIMSTART_SINGLE_DEFUSR.START
1644+ 557D ~                JR ANIMSTEP_MULTI_DEFUSR.L1
1645+ 557D ~            ; *******************************************************************************************************
1646+ 557D ~
1647+ 557D ~            ; *******************************************************************************************************
1648+ 557D ~            ; function to handle single item ANIMSTOP in DEFUSR mode
1649+ 557D ~            ; input IX=pointer to input array, real data from +2
1650+ 557D ~            ; +2 = animation id
1651+ 557D ~            ANIMSTOP_SINGLE_DEFUSR:
1652+ 557D ~                LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1653+ 557D ~                JR ANIMSTEP_SINGLE_DEFUSR.L1
1654+ 557D ~            .STOP:
1655+ 557D ~                LD (IX+6),0 ; active flag
1656+ 557D ~                RET
1657+ 557D ~            ; *******************************************************************************************************
1658+ 557D ~
1659+ 557D ~            ; *******************************************************************************************************
1660+ 557D ~            ; function to handle multi item ANIMSTOP in DEFUSR mode
1661+ 557D ~            ; input IX=pointer to input array, real data from +2
1662+ 557D ~            ; +2 = list size
1663+ 557D ~            ; +4 = array pointer holding items
1664+ 557D ~            ANIMSTOP_MULTI_DEFUSR:
1665+ 557D ~                LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1666+ 557D ~                JR ANIMSTEP_MULTI_DEFUSR.L1
1667+ 557D ~            ; *******************************************************************************************************
1668+ 557D               ENDIF
1669+ 557D
1670+ 557D              ; *******************************************************************************************************
1671+ 557D              ; function processes animations during vblank period
1672+ 557D              PROCESS_ANIMATIONS:
1673+ 557D 3A 67 4F         LD A,(ANIMSPRNUM)
1674+ 5580 B7               OR A
1675+ 5581 C8               RET Z; no animations defined
1676+ 5582 47               LD B,A
1677+ 5583 DD 2A 68 4F      LD IX,(ANIMSPRPTR)
1678+ 5587              .L1:
1679+ 5587 C5               PUSH BC
1680+ 5588 06 00            LD B,0 ; normal mode, change on timer expiry only
1681+ 558A CD 96 55         CALL PROCESS_SINGLE_ANIMATION
1682+ 558D 11 08 00         LD DE,8
1683+ 5590 DD 19            ADD IX,DE
1684+ 5592 C1               POP BC
1685+ 5593 10 F2            DJNZ .L1
1686+ 5595 C9               RET
1687+ 5596              ; *******************************************************************************************************
1688+ 5596
1689+ 5596              ; *******************************************************************************************************
1690+ 5596              ; processes single sprite animation
1691+ 5596              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
1692+ 5596              ; on timer expiry goes to next animation item
1693+ 5596              ; input IX=sprite animation pointer
1694+ 5596              ; input B=1 force mode, activate animation action regardless of expired timer
1695+ 5596              PROCESS_SINGLE_ANIMATION:
1696+ 5596 DD 7E 06         LD A,(IX+6); active
1697+ 5599 B7               OR A
1698+ 559A C8               RET Z ; inactive animation
1699+ 559B              .INACTIVE_TOO:
1700+ 559B DD 6E 01         LD L,(IX+1)
1701+ 559E DD 66 02         LD H,(IX+2) ; HL=end time
1702+ 55A1 2B               DEC HL
1703+ 55A2 DD 75 01         LD (IX+1),L
1704+ 55A5 DD 74 02         LD (IX+2),H
1705+ 55A8 7D               LD A,L
1706+ 55A9 B4               OR H
1707+ 55AA 28 06            JR Z,.STEP
1708+ 55AC 05               DEC B
1709+ 55AD 04               INC B
1710+ 55AE C8               RET Z ; not forced mode, return
1711+ 55AF C3 F7 55         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
1712+ 55B2              .STEP:
1713+ 55B2 06 00            LD B,0; setup timer
1714+ 55B4 DD 34 03         INC (IX+3) ; current animation item
1715+ 55B7 C3 F7 55         JP SETUP_ANIM_STEP
1716+ 55BA              ; *******************************************************************************************************
1717+ 55BA
1718+ 55BA              ; *******************************************************************************************************
1719+ 55BA              ; function will setup sprite animation after current item change
1720+ 55BA              ; input A=current animation definition
1721+ 55BA              ; input IX=pointer to sprite animation
1722+ 55BA              ; input B=1 skip timer setup
1723+ 55BA              ; output IY=pointer to animation item
1724+ 55BA              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
1725+ 55BA              ; basically sets new end time for current animation
1726+ 55BA              INIT_CURRENT_ANIMATION:
1727+ 55BA CD 7F 4F         CALL GETnthANIMDEF
1728+ 55BD DD 7E 03         LD A,(IX+3) ; current animation item
1729+ 55C0 BE               CP (HL) ; number of animation items in the animation definition
1730+ 55C1 38 0A            JR C,.L3 ; last item not reached
1731+ 55C3                  ; last item reached
1732+ 55C3 DD 7E 05         LD A,(IX+5) ; cyclic flag
1733+ 55C6 B7               OR A
1734+ 55C7 28 2C            JR Z,.ERROR ; non-cyclic animation
1735+ 55C9                  ; cyclic animation, restart
1736+ 55C9 DD 36 03 00      LD (IX+3),0; current item
1737+ 55CD              .L3:
1738+ 55CD                  ; HL = animation definition
1739+ 55CD 23               INC HL ; skip animation definition size field
1740+ 55CE 16 00            LD D,0
1741+ 55D0 DD 5E 03         LD E,(IX+3); current item
1742+ 55D3 19               ADD HL,DE
1743+ 55D4 4E               LD C,(HL) ; current animation item
1744+ 55D5 0C               INC C
1745+ 55D6 3A 61 4F         LD A,(ANIMITEMNUM)
1746+ 55D9 B9               CP C
1747+ 55DA 38 19            JR C,.ERROR ; invalid animation item, stop animation
1748+ 55DC 0D               DEC C
1749+ 55DD 79               LD A,C
1750+ 55DE CD 76 4F         CALL GETnthANIMITEM
1751+ 55E1 E5               PUSH HL
1752+ 55E2 FD E1            POP IY ; IY=animation item
1753+ 55E4 05               DEC B
1754+ 55E5 28 0C            JR Z,.EXIT
1755+ 55E7 FD 5E 01         LD E,(IY+1)
1756+ 55EA FD 56 02         LD D,(IY+2) ; duration
1757+ 55ED DD 73 01         LD (IX+1),E
1758+ 55F0 DD 72 02         LD (IX+2),D
1759+ 55F3              .EXIT:
1760+ 55F3 AF               XOR A
1761+ 55F4 C9               RET
1762+ 55F5              .ERROR:
1763+ 55F5 37               SCF
1764+ 55F6 C9               RET
1765+ 55F7              ; *******************************************************************************************************
1766+ 55F7
1767+ 55F7              ; *******************************************************************************************************
1768+ 55F7              ; function will display currect item and set up expiry time
1769+ 55F7              ; it will also stop the animation if expired
1770+ 55F7              ; sets sprite update flag if any changes in sprite data made
1771+ 55F7              ; input IX=current sprite animation
1772+ 55F7              ; input B=1 skip timer setup
1773+ 55F7              SETUP_ANIM_STEP:
1774+ 55F7 DD 4E 04         LD C,(IX+4) ; animation definition ID
1775+ 55FA 0C               INC C
1776+ 55FB 3A 64 4F         LD A,(ANIMDEFNUM)
1777+ 55FE B9               CP C
1778+ 55FF 30 05            JR NC,.L2
1779+ 5601                  ; given animation item is outside of bounds, deactivate animation
1780+ 5601              .STOPANIM:
1781+ 5601 DD 36 06 00      LD (IX+6),0
1782+ 5605 C9               RET
1783+ 5606              .L2:
1784+ 5606 0D               DEC C
1785+ 5607 79               LD A,C
1786+ 5608 CD BA 55         CALL INIT_CURRENT_ANIMATION
1787+ 560B 38 F4            JR C, .STOPANIM
1788+ 560D FD 7E 00         LD A,(IY) ; type of animation item
1789+ 5610 B7               OR A
1790+ 5611 28 44            JR Z,.L4 ; change pattern and/or color
1791+ 5613              .PAT:
1792+ 5613                  ; change pattern definition
1793+ 5613                  ; check if sprite or character
1794+ 5613 DD 7E 07         LD A,(IX+7)
1795+ 5616 B7               OR A
1796+ 5617 20 58            JR NZ,.CHAR
1797+ 5619 DD 7E 00         LD A,(IX) ; sprite number
1798+ 561C CD 90 4D         CALL GETnthSPRATTR
1799+ 561F 23          > INC HL ; skip y and x
1799+ 5620 23          > INC HL
1799+ 5621 23          > INC HL
1799+ 5622 23          > INC HL
1800+ 5623 7E               LD A,(HL); current pattern
1801+ 5624 26 00            LD H,0
1802+ 5626 6F               LD L,A
1803+ 5627 3A E0 F3         LD A,(REG1SAV)
1804+ 562A E6 02            AND 2
1805+ 562C 20 07            JR NZ,.L6
1806+ 562E                  ; 8x8 sprite
1807+ 562E CD 96 66         CALL HLx8
1808+ 5631 06 08            LD B,8
1809+ 5633 18 05            JR .L5
1810+ 5635              .L6:
1811+ 5635 CD 94 66         CALL HLx32
1812+ 5638 06 20            LD B,32
1813+ 563A              .L5:
1814+ 563A 3A AF FC         LD A,(SCRMOD)
1815+ 563D 3D               DEC A
1816+ 563E 20 06            JR NZ,.L10
1817+ 5640 ED 5B C5 F3      LD DE,(T32PAT)
1818+ 5644 18 04            JR .L7
1819+ 5646              .L10:
1820+ 5646 ED 5B CF F3      LD DE,(GRPPAT)
1821+ 564A              .L7:
1822+ 564A 19               ADD HL,DE
1823+ 564B CD 77 66         CALL SETWRT_LOCAL_WRITE
1824+ 564E FD 6E 03         LD L,(IY+3)
1825+ 5651 FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
1826+ 5654 C3 8C 66         JP BBYTECOPY
1827+ 5657              .L4:
1828+ 5657                  ; change pattern and color in sprite attributes table
1829+ 5657 DD 7E 00         LD A,(IX) ; sprite number
1830+ 565A CD 90 4D         CALL GETnthSPRATTR
1831+ 565D 23          > INC HL ; skip y and x
1831+ 565E 23          > INC HL
1831+ 565F 23          > INC HL
1831+ 5660 23          > INC HL
1832+ 5661 FD 7E 03         LD A,(IY+3) ; new pattern
1833+ 5664 77               LD (HL),A
1834+ 5665 23          > INC HL
1834+ 5666 23          > INC HL
1835+ 5667 FD 7E 04         LD A,(IY+4) ; new color
1836+ 566A 77               LD (HL),A
1837+ 566B 2A 87 4D         LD HL,(SPRATR_UPDATE_FLAG)
1838+ 566E 36 01            LD (HL),1
1839+ 5670 C9               RET
1840+ 5671              .CHAR:
1841+ 5671 DD 6E 00         LD L,(IX)
1842+ 5674 3D               DEC A
1843+ 5675 67               LD H,A
1844+ 5676 CD 96 66         CALL HLx8
1845+ 5679 3A AF FC         LD A,(SCRMOD)
1846+ 567C 3D               DEC A
1847+ 567D 20 06            JR NZ,.L8
1848+ 567F ED 5B C1 F3      LD DE,(T32CGP)
1849+ 5683 18 04            JR .L9
1850+ 5685              .L8:
1851+ 5685 ED 5B CB F3      LD DE,(GRPCGP)
1852+ 5689              .L9:
1853+ 5689 06 08            LD B,8
1854+ 568B 18 BD            JR .L7
1855+ 568D              ; *******************************************************************************************************
1856+ 568D
# file closed: asm\ANIMATION.asm
 139  568D               INCLUDE "SGAM.asm"
# file opened: asm\SGAM.asm
   1+ 568D              ; Sprite Group Animate and Move
   2+ 568D
   3+ 568D              ; *******************************************************************************************************
   4+ 568D              ; shared function to process a list of animations
   5+ 568D              ; input B=list size
   6+ 568D              ; input DE=list pointer
   7+ 568D              SGAM_PROCESS_ANIM_LIST:
   8+ 568D 21 A0 56         LD HL,.STEP
   9+ 5690 22 7B 55         LD (ANIM_SETVALUE.FN+1),HL
  10+ 5693              .L1:
  11+ 5693 C5               PUSH BC
  12+ 5694 1A               LD A,(DE)
  13+ 5695 13          > INC DE
  13+ 5696 13          > INC DE
  14+ 5697 D5               PUSH DE
  15+ 5698 CD 6B 55         CALL ANIM_SETVALUE
  16+ 569B D1               POP DE
  17+ 569C C1               POP BC
  18+ 569D 10 F4            DJNZ .L1
  19+ 569F C9           	RET
  20+ 56A0              .STEP:
  21+ 56A0 06 01            LD B,1
  22+ 56A2 C3 9B 55         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
  23+ 56A5              ; *******************************************************************************************************
  24+ 56A5
  25+ 56A5               IF (1 == 1)
  26+ 56A5              ; *******************************************************************************************************
  27+ 56A5              ; function to handle CALL SGAM basic extension
  28+ 56A5              ; sets position of a group of sprites as described in SPRGRPMOV
  29+ 56A5              ; and manually animate a list of animations
  30+ 56A5              ; _SGAM ( INT x,
  31+ 56A5              ;	      INT y,
  32+ 56A5              ;		  BYTE count,
  33+ 56A5              ;		  INT[2][count] data_ptr,
  34+ 56A5              ;         BYTE item_number,
  35+ 56A5              ;         INT[] sprite_animations )
  36+ 56A5              ; will put ram in page 0 also, page 1 is already there
  37+ 56A5              SGAM:
  38+ 56A5 3A 86 4D     	LD A, (SPRATR_INIT_STATUS)
  39+ 56A8 B7           	OR A
  40+ 56A9 CA D5 67     	JP Z,ILLEGAL_FUNCTION
  41+ 56AC              	; opening (
  42+ 56AC CD A9 67     	CALL CHKCHAR
  43+ 56AF 28           	DB '('
  44+ 56B0              	; get x
  45+ 56B0 DD 21 2F 54  	LD IX, FRMQNT
  46+ 56B4 CD 59 01     	CALL CALBAS
  47+ 56B7 ED 53 7C 64  	LD (BLIT_STRUCT),DE
  48+ 56BB              	; comma
  49+ 56BB CD A9 67     	CALL CHKCHAR
  50+ 56BE 2C           	DB ','
  51+ 56BF              	; get y
  52+ 56BF DD 21 2F 54  	LD IX, FRMQNT
  53+ 56C3 CD 59 01     	CALL CALBAS
  54+ 56C6 ED 53 7E 64  	LD (BLIT_STRUCT+2),DE
  55+ 56CA              	; comma
  56+ 56CA CD A9 67     	CALL CHKCHAR
  57+ 56CD 2C           	DB ','
  58+ 56CE              	; get count
  59+ 56CE DD 21 1C 52  	LD IX, GETBYT
  60+ 56D2 CD 59 01     	CALL CALBAS
  61+ 56D5 B7               OR A
  62+ 56D6 CA CD 67         JP Z,SUBSCRIPT_OUT_OF_RANGE
  63+ 56D9 32 80 64     	LD (BLIT_STRUCT+4),A
  64+ 56DC              	; comma
  65+ 56DC CD A9 67     	CALL CHKCHAR
  66+ 56DF 2C           	DB ','
  67+ 56E0              	; get sprite group definition array data pointer
  68+ 56E0 3A 80 64         LD A,(BLIT_STRUCT+4)
  69+ 56E3 5F           	LD E,A
  70+ 56E4 16 03        	LD D,3
  71+ 56E6 3E 02        	LD A,2
  72+ 56E8 47           	LD B,A
  73+ 56E9 CD 0E 68     	CALL GET_BASIC_ARRAY_DATA_POINTER
  74+ 56EC ED 43 81 64  	LD (BLIT_STRUCT+5),BC
  75+ 56F0              	; comma
  76+ 56F0 CD A9 67     	CALL CHKCHAR
  77+ 56F3 2C           	DB ','
  78+ 56F4              	; get sprite animation array size
  79+ 56F4 DD 21 1C 52  	LD IX,GETBYT
  80+ 56F8 CD 59 01     	CALL CALBAS
  81+ 56FB 32 83 64         LD (BLIT_STRUCT+7),A
  82+ 56FE B7               OR A
  83+ 56FF CA CD 67         JP Z,SUBSCRIPT_OUT_OF_RANGE
  84+ 5702              	; comma
  85+ 5702 CD A9 67     	CALL CHKCHAR
  86+ 5705 2C           	DB ','
  87+ 5706                  ; get array pointer
  88+ 5706 3A 83 64         LD A,(BLIT_STRUCT+7)
  89+ 5709 57               LD D,A
  90+ 570A 3E 02            LD A,2
  91+ 570C 06 01            LD B,1
  92+ 570E CD 0E 68         CALL GET_BASIC_ARRAY_DATA_POINTER
  93+ 5711 ED 43 84 64      LD (BLIT_STRUCT+8),BC
  94+ 5715              	; ending )
  95+ 5715 CD A9 67     	CALL CHKCHAR
  96+ 5718 29           	DB ')'
  97+ 5719              .ENTRY:
  98+ 5719 E5               PUSH HL
  99+ 571A
 100+ 571A              	; enable page 0
 101+ 571A FD 21 21 57  	LD IY, .RET
 102+ 571E C3 5A 67     	JP ENABLE_PAGE0
 103+ 5721              .RET:
 104+ 5721 D9               EXX
 105+ 5722 ED 5B 7C 64      LD DE,(BLIT_STRUCT) ; initial x
 106+ 5726 ED 4B 7E 64      LD BC,(BLIT_STRUCT+2) ; initial y
 107+ 572A D9               EXX
 108+ 572B 2A 81 64         LD HL,(BLIT_STRUCT+5) ; pointer to data
 109+ 572E 3A 80 64         LD A,(BLIT_STRUCT+4) ; number of entries
 110+ 5731 47               LD B,A
 111+ 5732 CD E4 4E         CALL SPR_UPDATE_LOC
 112+ 5735
 113+ 5735 3A 83 64         LD A,(BLIT_STRUCT+7) ; anim number
 114+ 5738 47               LD B,A
 115+ 5739 ED 5B 84 64      LD DE,(BLIT_STRUCT+8) ; anim list
 116+ 573D CD 8D 56     	CALL SGAM_PROCESS_ANIM_LIST
 117+ 5740
 118+ 5740 D1               POP DE
 119+ 5741 C1               POP BC
 120+ 5742 CD D1 66         CALL RESTORE_PAGE_INFO
 121+ 5745 FB               EI
 122+ 5746 E1               POP HL
 123+ 5747 C9               RET
 124+ 5748              ; *******************************************************************************************************
 125+ 5748               ENDIF
 126+ 5748
 127+ 5748               IF (0 == 1)
 128+ 5748 ~            ; *******************************************************************************************************
 129+ 5748 ~            ; same as SGAM but for DEFUSR approach
 130+ 5748 ~            ; input IX=pointer to input array, real data from +2
 131+ 5748 ~            ; +02 = X
 132+ 5748 ~            ; +04 = Y
 133+ 5748 ~            ; +06 = count
 134+ 5748 ~            ; +08 = data pointer
 135+ 5748 ~            ; +10 = anim number
 136+ 5748 ~            ; +12 = sprite animations
 137+ 5748 ~            SGAM_DEFUSR:
 138+ 5748 ~            	; enable page 0
 139+ 5748 ~            	LD IY, .RET
 140+ 5748 ~            	JP ENABLE_PAGE0
 141+ 5748 ~            .RET:
 142+ 5748 ~            	EI
 143+ 5748 ~                EXX
 144+ 5748 ~            	LD E,(IX+2)
 145+ 5748 ~            	LD D,(IX+3) ; initial x
 146+ 5748 ~            	LD C,(IX+4)
 147+ 5748 ~            	LD B,(IX+5) ; initial y
 148+ 5748 ~                EXX
 149+ 5748 ~            	LD L,(IX+8)
 150+ 5748 ~            	LD H,(IX+9) ; pointer to data
 151+ 5748 ~                LD B,(IX+6) ; count
 152+ 5748 ~            	PUSH IX
 153+ 5748 ~                CALL SPR_UPDATE_LOC
 154+ 5748 ~            	POP IX
 155+ 5748 ~                LD B,(IX+10) ; anim number
 156+ 5748 ~            	LD E,(IX+12)
 157+ 5748 ~            	LD D,(IX+13)
 158+ 5748 ~            	CALL SGAM_PROCESS_ANIM_LIST
 159+ 5748 ~
 160+ 5748 ~                POP DE
 161+ 5748 ~                POP BC
 162+ 5748 ~                CALL RESTORE_PAGE_INFO
 163+ 5748 ~            	XOR A ; success
 164+ 5748 ~            	RET
 165+ 5748 ~            ; *******************************************************************************************************
 166+ 5748               ENDIF
 167+ 5748
 168+ 5748              ; *******************************************************************************************************
 169+ 5748              ; handles automatic move and animate sprite groups during interrupt
 170+ 5748              PROCESS_AUTOSGAMS:
 171+ 5748 3A 6A 4F     	LD A,(AUTOSGAMNUM)
 172+ 574B B7           	OR A
 173+ 574C C8           	RET Z
 174+ 574D 47           	LD B,A
 175+ 574E DD 2A 6B 4F  	LD IX,(AUTOSGAMPTR)
 176+ 5752              .L1:
 177+ 5752 C5           	PUSH BC
 178+ 5753 DD 7E 13     	LD A,(IX+19) ; active flag
 179+ 5756 B7           	OR A
 180+ 5757 28 28        	JR Z,.LOOPEND
 181+ 5759              	; active, check timer
 182+ 5759 DD 6E 16     	LD L,(IX+22)
 183+ 575C DD 66 17     	LD H,(IX+23) ; timer
 184+ 575F 2B           	DEC HL
 185+ 5760 7C           	LD A,H
 186+ 5761 B5           	OR L
 187+ 5762 28 08        	JR Z,.L2
 188+ 5764              	; not expired
 189+ 5764 DD 75 16     	LD (IX+22),L
 190+ 5767 DD 74 17     	LD (IX+23),H
 191+ 576A 18 15        	JR .LOOPEND
 192+ 576C              .L2:
 193+ 576C              	; expired, process
 194+ 576C
 195+ 576C                  ; set initial timer
 196+ 576C DD 7E 14         LD A,(IX+20)
 197+ 576F DD 77 16         LD (IX+22),A
 198+ 5772 DD 7E 15         LD A,(IX+21)
 199+ 5775 DD 77 17         LD (IX+23),A
 200+ 5778
 201+ 5778 CD 8A 57     	CALL .MOVE
 202+ 577B CD F5 57     	CALL .UPDATELOC
 203+ 577E CD 1A 58     	CALL .PROCESS_ANIM_LIST
 204+ 5781
 205+ 5781              .LOOPEND:
 206+ 5781 11 18 00     	LD DE,24
 207+ 5784 DD 19        	ADD IX,DE
 208+ 5786 C1           	POP BC
 209+ 5787 10 C9        	DJNZ .L1
 210+ 5789 C9           	RET
 211+ 578A
 212+ 578A              .MOVE:
 213+ 578A              	; process movement
 214+ 578A DD 7E 0A     	LD A,(IX+10) ; direction
 215+ 578D B7           	OR A
 216+ 578E 28 08        	JR Z, .MOVE_L1
 217+ 5790              	; vertical
 218+ 5790 DD 6E 02     	LD L,(IX+2)
 219+ 5793 DD 66 03     	LD H,(IX+3) ; vertical variable pointer
 220+ 5796 18 06        	JR .MOVE_L2
 221+ 5798              .MOVE_L1:
 222+ 5798              	; horizontal
 223+ 5798 DD 6E 00     	LD L,(IX+0)
 224+ 579B DD 66 01     	LD H,(IX+1) ; horizontal variable pointer
 225+ 579E              .MOVE_L2:
 226+ 579E E5           	PUSH HL
 227+ 579F FD E1        	POP IY
 228+ 57A1 FD 6E 00     	LD L,(IY+0)
 229+ 57A4 FD 66 01     	LD H,(IY+1)
 230+ 57A7 DD 5E 08     	LD E,(IX+8)
 231+ 57AA DD 56 09     	LD D,(IX+9) ; delta value
 232+ 57AD 19           	ADD HL,DE
 233+ 57AE E5           	PUSH HL
 234+ 57AF DD 5E 04     	LD E,(IX+4)
 235+ 57B2 DD 56 05     	LD D,(IX+5) ; minimum value
 236+ 57B5 A7           	AND A
 237+ 57B6 ED 52        	SBC HL,DE
 238+ 57B8 FA D2 57     	JP M,.MOVE_L3 ; below minimum
 239+ 57BB E1           	POP HL
 240+ 57BC E5           	PUSH HL
 241+ 57BD DD 5E 06     	LD E,(IX+6)
 242+ 57C0 DD 56 07     	LD D,(IX+7) ; maximum value
 243+ 57C3 EB           	EX DE,HL
 244+ 57C4 A7           	AND A
 245+ 57C5 ED 52        	SBC HL,DE
 246+ 57C7 FA DA 57     	JP M,.MOVE_L4 ; above maximum
 247+ 57CA E1           	POP HL
 248+ 57CB              	; within bounds
 249+ 57CB              .MOVE_L5:
 250+ 57CB FD 75 00     	LD (IY+0),L
 251+ 57CE FD 74 01     	LD (IY+1),H
 252+ 57D1 C9           	RET
 253+ 57D2              .MOVE_L3:
 254+ 57D2 E1           	POP HL
 255+ 57D3 CD E6 57     	CALL .INVERSE_DELTA
 256+ 57D6 6B           	LD L,E
 257+ 57D7 62           	LD H,D
 258+ 57D8 18 F1        	JR .MOVE_L5
 259+ 57DA              .MOVE_L4:
 260+ 57DA E1           	POP HL
 261+ 57DB CD E6 57     	CALL .INVERSE_DELTA
 262+ 57DE DD 6E 06     	LD L,(IX+6)
 263+ 57E1 DD 66 07     	LD H,(IX+7) ; maximum
 264+ 57E4 18 E5        	JR .MOVE_L5
 265+ 57E6              .INVERSE_DELTA:
 266+ 57E6 AF           	XOR A
 267+ 57E7 DD 96 08     	SUB (IX+8)
 268+ 57EA DD 77 08     	LD (IX+8),A
 269+ 57ED 9F           	SBC A,A
 270+ 57EE DD 96 09     	SUB (IX+9)
 271+ 57F1 DD 77 09     	LD (IX+9),A
 272+ 57F4 C9           	RET
 273+ 57F5
 274+ 57F5              .UPDATELOC:
 275+ 57F5 DD E5        	PUSH IX
 276+ 57F7 D9           	EXX
 277+ 57F8 DD 6E 00     	LD L,(IX+0)
 278+ 57FB DD 66 01     	LD H,(IX+1)
 279+ 57FE 5E           	LD E,(HL)
 280+ 57FF 23           	INC HL
 281+ 5800 56           	LD D,(HL)
 282+ 5801 DD 6E 02     	LD L,(IX+2)
 283+ 5804 DD 66 03     	LD H,(IX+3)
 284+ 5807 4E           	LD C,(HL)
 285+ 5808 23           	INC HL
 286+ 5809 46           	LD B,(HL)
 287+ 580A D9           	EXX
 288+ 580B DD 6E 0C     	LD L,(IX+12)
 289+ 580E DD 66 0D     	LD H,(IX+13) ; pointer to sprite group data
 290+ 5811 DD 46 0B     	LD B,(IX+11) ; sprite group size
 291+ 5814 CD E4 4E     	CALL SPR_UPDATE_LOC
 292+ 5817 DD E1        	POP IX
 293+ 5819 C9           	RET
 294+ 581A
 295+ 581A              .PROCESS_ANIM_LIST:
 296+ 581A DD E5        	PUSH IX
 297+ 581C DD 46 0E         LD B,(IX+14) ; anim list size
 298+ 581F DD CB 09 7E  	BIT 7,(IX+9)
 299+ 5823 28 08        	JR Z,.PROCESS_ANIM_LIST_L1
 300+ 5825              	; negative direction
 301+ 5825 DD 5E 0F     	LD E,(IX+15)
 302+ 5828 DD 56 10     	LD D,(IX+16)
 303+ 582B 18 06        	JR .PROCESS_ANIM_LIST_L2
 304+ 582D              .PROCESS_ANIM_LIST_L1:
 305+ 582D              	; positive direction
 306+ 582D DD 5E 11     	LD E,(IX+17)
 307+ 5830 DD 56 12     	LD D,(IX+18)
 308+ 5833              .PROCESS_ANIM_LIST_L2:
 309+ 5833 CD 8D 56     	CALL SGAM_PROCESS_ANIM_LIST
 310+ 5836 DD E1        	POP IX
 311+ 5838 C9           	RET
 312+ 5839              ; *******************************************************************************************************
 313+ 5839
# file closed: asm\SGAM.asm
 140  5839               ENDIF
 141  5839
 142  5839               IF (RAM_CMDS == 1)
 143  5839               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
   1+ 5839               IF (1 == 1)
   2+ 5839              ; *******************************************************************************************************
   3+ 5839              ; function to handle CALL MEMCPY basic extension
   4+ 5839              ; _MEMCPY ( INT source,
   5+ 5839              ;			INT destination,
   6+ 5839              ;			INT count,
   7+ 5839              ; will put ram in page 0 also, page 1 is already there
   8+ 5839              MEMCPY:
   9+ 5839              	; opening (
  10+ 5839 CD A9 67     	CALL CHKCHAR
  11+ 583C 28           	DB '('
  12+ 583D              	; get source address
  13+ 583D DD 21 2F 54  	LD IX, FRMQNT
  14+ 5841 CD 59 01     	CALL CALBAS
  15+ 5844 D5           	PUSH DE
  16+ 5845              	; comma
  17+ 5845 CD A9 67     	CALL CHKCHAR
  18+ 5848 2C           	DB ','
  19+ 5849              	; get destination address
  20+ 5849 DD 21 2F 54  	LD IX, FRMQNT
  21+ 584D CD 59 01     	CALL CALBAS
  22+ 5850 D5           	PUSH DE
  23+ 5851              	; comma
  24+ 5851 CD A9 67     	CALL CHKCHAR
  25+ 5854 2C           	DB ','
  26+ 5855              	; get length
  27+ 5855 DD 21 2F 54  	LD IX, FRMQNT
  28+ 5859 CD 59 01     	CALL CALBAS
  29+ 585C D5           	PUSH DE
  30+ 585D              	; ending )
  31+ 585D CD A9 67     	CALL CHKCHAR
  32+ 5860 29           	DB ')'
  33+ 5861
  34+ 5861              	; save position
  35+ 5861 E5           	PUSH HL
  36+ 5862 DD E1        	POP IX
  37+ 5864
  38+ 5864 C1           	POP BC ; count
  39+ 5865 D1           	POP DE ; destination
  40+ 5866 E1           	POP HL ; source
  41+ 5867 D9           	EXX
  42+ 5868              	; enable page 0
  43+ 5868 FD 21 6F 58  	LD IY, .RET
  44+ 586C C3 5A 67     	JP ENABLE_PAGE0
  45+ 586F              .RET:
  46+ 586F FB           	EI
  47+ 5870 D9           	EXX
  48+ 5871 ED B0        	LDIR
  49+ 5873 D1               POP DE
  50+ 5874 C1               POP BC
  51+ 5875 CD D1 66         CALL RESTORE_PAGE_INFO
  52+ 5878 DD E5        	PUSH IX
  53+ 587A E1           	POP HL
  54+ 587B C9           	RET
  55+ 587C              ; *******************************************************************************************************
  56+ 587C               ENDIF
  57+ 587C
  58+ 587C               IF (0 == 1)
  59+ 587C ~            ; *******************************************************************************************************
  60+ 587C ~            ; same as MEMCPY but for DEFUSR approach
  61+ 587C ~            ; input IX=pointer to input array, real data from +2
  62+ 587C ~            ; +2 = source address
  63+ 587C ~            ; +4 = destination address
  64+ 587C ~            ; +6 = lenght
  65+ 587C ~            MEMCPY_DEFUSR:
  66+ 587C ~            	; enable page 0
  67+ 587C ~            	LD IY, .RET
  68+ 587C ~            	JP ENABLE_PAGE0
  69+ 587C ~            .RET:
  70+ 587C ~            	EI
  71+ 587C ~            	LD L,(IX+2)
  72+ 587C ~            	LD H,(IX+3)
  73+ 587C ~            	LD E,(IX+4)
  74+ 587C ~            	LD D,(IX+5)
  75+ 587C ~            	LD C,(IX+6)
  76+ 587C ~            	LD B,(IX+7)
  77+ 587C ~            	LDIR
  78+ 587C ~                POP DE
  79+ 587C ~                POP BC
  80+ 587C ~                CALL RESTORE_PAGE_INFO
  81+ 587C ~            	XOR A ; success
  82+ 587C ~            	RET
  83+ 587C ~            ; *******************************************************************************************************
  84+ 587C               ENDIF
  85+ 587C
  86+ 587C               IF (1 == 1)
  87+ 587C              ; *******************************************************************************************************
  88+ 587C              ; function to handle CALL FILRAM basic extension
  89+ 587C              ; FILRAM ( INT start address,
  90+ 587C              ;		   INT count,
  91+ 587C              ;		   BYTE value )
  92+ 587C              ; will put ram in page 0 also, page 1 is already there
  93+ 587C              FILRAM:
  94+ 587C              	; opening (
  95+ 587C CD A9 67     	CALL CHKCHAR
  96+ 587F 28           	DB '('
  97+ 5880              	; get start address
  98+ 5880 DD 21 2F 54  	LD IX, FRMQNT
  99+ 5884 CD 59 01     	CALL CALBAS
 100+ 5887 D5           	PUSH DE
 101+ 5888              	; comma
 102+ 5888 CD A9 67     	CALL CHKCHAR
 103+ 588B 2C           	DB ','
 104+ 588C              	; get count
 105+ 588C DD 21 2F 54  	LD IX, FRMQNT
 106+ 5890 CD 59 01     	CALL CALBAS
 107+ 5893 D5           	PUSH DE
 108+ 5894              	; comma
 109+ 5894 CD A9 67     	CALL CHKCHAR
 110+ 5897 2C           	DB ','
 111+ 5898              	; get value
 112+ 5898 DD 21 1C 52  	LD IX, GETBYT
 113+ 589C CD 59 01     	CALL CALBAS
 114+ 589F F5           	PUSH AF
 115+ 58A0              	; ending )
 116+ 58A0 CD A9 67     	CALL CHKCHAR
 117+ 58A3 29           	DB ')'
 118+ 58A4
 119+ 58A4              	; save position
 120+ 58A4 E5           	PUSH HL
 121+ 58A5 DD E1        	POP IX
 122+ 58A7
 123+ 58A7 D1           	POP DE ; actually AF
 124+ 58A8 C1           	POP BC ; count
 125+ 58A9 E1           	POP HL ; start address
 126+ 58AA 78           	LD A, B
 127+ 58AB B1           	OR C
 128+ 58AC 28 12        	JR Z, .EXIT ; 0 bytes to fill, skip
 129+ 58AE D9           	EXX
 130+ 58AF              	; enable page 0
 131+ 58AF FD 21 B6 58  	LD IY, .RET
 132+ 58B3 C3 5A 67     	JP ENABLE_PAGE0
 133+ 58B6              .RET:
 134+ 58B6 FB           	EI
 135+ 58B7 D9           	EXX
 136+ 58B8 CD C4 58     	CALL FILVRM_FILLVALUE
 137+ 58BB D1               POP DE
 138+ 58BC C1               POP BC
 139+ 58BD CD D1 66         CALL RESTORE_PAGE_INFO
 140+ 58C0              .EXIT:
 141+ 58C0 DD E5        	PUSH IX
 142+ 58C2 E1           	POP HL
 143+ 58C3 C9           	RET
 144+ 58C4              ; *******************************************************************************************************
 145+ 58C4               ENDIF
 146+ 58C4
 147+ 58C4               IF (0 == 1)
 148+ 58C4 ~            ; *******************************************************************************************************
 149+ 58C4 ~            ; same as FILVRM but for DEFUSR approach
 150+ 58C4 ~            ; input IX=pointer to input array, real data from +2
 151+ 58C4 ~            ; +2 = start address
 152+ 58C4 ~            ; +4 = count
 153+ 58C4 ~            ; +6 = value
 154+ 58C4 ~            FILRAM_DEFUSR:
 155+ 58C4 ~            	; enable page 0
 156+ 58C4 ~            	LD IY, .RET
 157+ 58C4 ~            	JP ENABLE_PAGE0
 158+ 58C4 ~            .RET:
 159+ 58C4 ~            	EI
 160+ 58C4 ~            	LD L,(IX+2)
 161+ 58C4 ~            	LD H,(IX+3)
 162+ 58C4 ~            	LD C,(IX+4)
 163+ 58C4 ~            	LD B,(IX+5)
 164+ 58C4 ~            	LD A,B
 165+ 58C4 ~            	OR C
 166+ 58C4 ~            	JR Z,.EXIT
 167+ 58C4 ~            	LD D,(IX+6)
 168+ 58C4 ~            	CALL FILVRM_FILLVALUE
 169+ 58C4 ~            .EXIT:
 170+ 58C4 ~                POP DE
 171+ 58C4 ~                POP BC
 172+ 58C4 ~                CALL RESTORE_PAGE_INFO
 173+ 58C4 ~            	XOR A ; success
 174+ 58C4 ~            	RET
 175+ 58C4 ~            ; *******************************************************************************************************
 176+ 58C4               ENDIF
 177+ 58C4
 178+ 58C4              ; *******************************************************************************************************
 179+ 58C4              ; common function to fill RAM
 180+ 58C4              FILVRM_FILLVALUE:
 181+ 58C4 72               LD (HL), D
 182+ 58C5 54               LD D, H
 183+ 58C6 5D               LD E, L
 184+ 58C7 13               INC DE
 185+ 58C8 0B               DEC BC
 186+ 58C9 78           	LD A,B
 187+ 58CA B1           	OR C
 188+ 58CB C8           	RET Z ; if count was 1
 189+ 58CC ED B0            LDIR
 190+ 58CE C9               RET
 191+ 58CF              ; *******************************************************************************************************
# file closed: asm\MEMORY.asm
 144  58CF               ENDIF
 145  58CF
 146  58CF               IF (SOUND_CMDS == 1)
 147  58CF               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
   1+ 58CF              MUSIC_INIT_STATUS:
   2+ 58CF 00            DB 0
   3+ 58D0              SFX_INIT_STATUS:
   4+ 58D0 00            DB 0
   5+ 58D1              SOUND_ENABLED:
   6+ 58D1 00            DB 0
   7+ 58D2
   8+ 58D2               IF (1 == 1)
   9+ 58D2              ; *******************************************************************************************************
  10+ 58D2              ; function to handle CALL SNDPLYINIT basic extension
  11+ 58D2              ; initializes sound player
  12+ 58D2              ; _SNDPLYINIT ( INT music_offset,
  13+ 58D2              ;				INT sfx_offset, can be -1 if no SFX
  14+ 58D2              ; will put ram in page 0 also, page 1 is already there
  15+ 58D2              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
  16+ 58D2              SNDPLYINIT:
  17+ 58D2              	; opening (
  18+ 58D2 CD A9 67     	CALL CHKCHAR
  19+ 58D5 28           	DB '('
  20+ 58D6              	; get music address
  21+ 58D6 DD 21 2F 54  	LD IX, FRMQNT
  22+ 58DA CD 59 01     	CALL CALBAS
  23+ 58DD D5           	PUSH DE
  24+ 58DE              	; comma
  25+ 58DE CD A9 67     	CALL CHKCHAR
  26+ 58E1 2C           	DB ','
  27+ 58E2              	; get sfx address
  28+ 58E2 DD 21 2F 54  	LD IX, FRMQNT
  29+ 58E6 CD 59 01     	CALL CALBAS
  30+ 58E9 D5           	PUSH DE
  31+ 58EA              	; ending )
  32+ 58EA CD A9 67     	CALL CHKCHAR
  33+ 58ED 29           	DB ')'
  34+ 58EE
  35+ 58EE                  ; save position in BASIC text
  36+ 58EE 44           	LD B, H
  37+ 58EF 4D           	LD C, L
  38+ 58F0
  39+ 58F0              	; pop LDIR parameters and store away for later
  40+ 58F0 D1           	POP DE ; sfx address
  41+ 58F1 E1           	POP HL ; music address
  42+ 58F2 C5           	PUSH BC ; basic text location
  43+ 58F3 D9           	EXX
  44+ 58F4 FD 21 FB 58  	LD IY, .RET
  45+ 58F8 C3 5A 67     	JP ENABLE_PAGE0
  46+ 58FB              .RET:
  47+ 58FB D9           	EXX
  48+ 58FC
  49+ 58FC D5           	PUSH DE
  50+ 58FD AF           	XOR A
  51+ 58FE              	; HL = music location
  52+ 58FE CD 65 41     	CALL PLY_AKG_INIT
  53+ 5901 3E 01        	LD A, 1
  54+ 5903 32 CF 58     	LD (MUSIC_INIT_STATUS), A
  55+ 5906
  56+ 5906 E1           	POP HL ; SFX
  57+ 5907              	; check if SFX address -1
  58+ 5907 23           	INC HL
  59+ 5908 7D           	LD A, L
  60+ 5909 B4           	OR H
  61+ 590A 28 09        	JR Z,.L1
  62+ 590C 2B           	DEC HL
  63+ 590D CD 20 40     	CALL PLY_AKG_INITSOUNDEFFECTS
  64+ 5910 3E 01        	LD A, 1
  65+ 5912 32 D0 58     	LD (SFX_INIT_STATUS), A
  66+ 5915              .L1:
  67+ 5915 D1               POP DE
  68+ 5916 C1               POP BC
  69+ 5917 CD D1 66         CALL RESTORE_PAGE_INFO
  70+ 591A
  71+ 591A E1           	POP HL
  72+ 591B C9           	RET
  73+ 591C              ; *******************************************************************************************************
  74+ 591C               ENDIF
  75+ 591C
  76+ 591C               IF (0 == 1)
  77+ 591C ~            ; *******************************************************************************************************
  78+ 591C ~            ; same as SNDPLYINI but for DEFUSR approach
  79+ 591C ~            ; input IX=pointer to input array, real data from +2
  80+ 591C ~            ; +2 = music address
  81+ 591C ~            ; +4 = sfx address
  82+ 591C ~            SNDPLYINI_DEFUSR:
  83+ 591C ~            	LD IY, .RET
  84+ 591C ~            	JP ENABLE_PAGE0
  85+ 591C ~            .RET:
  86+ 591C ~            	XOR A
  87+ 591C ~            	LD L,(IX+2)
  88+ 591C ~            	LD H,(IX+3)
  89+ 591C ~            	PUSH IX
  90+ 591C ~            	CALL PLY_AKG_INIT
  91+ 591C ~            	POP IX
  92+ 591C ~            	LD A, 1
  93+ 591C ~            	LD (MUSIC_INIT_STATUS), A
  94+ 591C ~
  95+ 591C ~            	LD L,(IX+4)
  96+ 591C ~            	LD H,(IX+5)
  97+ 591C ~            	; check if SFX address -1
  98+ 591C ~            	INC HL
  99+ 591C ~            	LD A, L
 100+ 591C ~            	OR H
 101+ 591C ~            	JR Z,.L1
 102+ 591C ~            	DEC HL
 103+ 591C ~            	CALL PLY_AKG_INITSOUNDEFFECTS
 104+ 591C ~            	LD A, 1
 105+ 591C ~            	LD (SFX_INIT_STATUS), A
 106+ 591C ~            .L1:
 107+ 591C ~                POP DE
 108+ 591C ~                POP BC
 109+ 591C ~                CALL RESTORE_PAGE_INFO
 110+ 591C ~            	XOR A ; success
 111+ 591C ~            	RET
 112+ 591C ~            ; *******************************************************************************************************
 113+ 591C               ENDIF
 114+ 591C
 115+ 591C              ; *******************************************************************************************************
 116+ 591C              ; function to handle CALL SNDPLYON basic extension
 117+ 591C              ; enables sound player
 118+ 591C              ; _SNDPLYON
 119+ 591C              ; sets SOUND_ENABLED variable to 1 if init call was done
 120+ 591C              ; if not throws out of data error
 121+ 591C              SNDPLYON_DEFUSR:
 122+ 591C              SNDPLYON:
 123+ 591C 3A CF 58     	LD A, (MUSIC_INIT_STATUS)
 124+ 591F B7           	OR A
 125+ 5920               IF (1 == 1)
 126+ 5920 CA C5 67     	JP Z, OUT_OF_DATA ; player not initialized, throw error
 127+ 5923               ENDIF
 128+ 5923               IF (0 == 1)
 129+ 5923 ~            	JR Z,.ERR
 130+ 5923               ENDIF
 131+ 5923              .L1:
 132+ 5923 32 D1 58     	LD (SOUND_ENABLED), A
 133+ 5926              	; disable key click
 134+ 5926 AF           	XOR A
 135+ 5927 32 DB F3     	LD (CLIKSW), A
 136+ 592A C9           	RET
 137+ 592B              .ERR:
 138+ 592B 3E 01        	LD A,1
 139+ 592D C9           	RET
 140+ 592E              ; *******************************************************************************************************
 141+ 592E
 142+ 592E              ; *******************************************************************************************************
 143+ 592E              ; function to handle CALL SNDPLYOFF basic extension
 144+ 592E              ; disables sound player
 145+ 592E              ; _SNDPLYOFF
 146+ 592E              ; sets SOUND_ENABLED variable to 0
 147+ 592E              ; calls AKG to stop music and SFX on all channels if initialized
 148+ 592E              SNDPLYOFF_DEFUSR:
 149+ 592E              SNDPLYOFF:
 150+ 592E 3A D1 58     	LD A, (SOUND_ENABLED)
 151+ 5931 B7           	OR A
 152+ 5932 C8           	RET Z ; already stopped
 153+ 5933 AF           	XOR A
 154+ 5934 32 D1 58     	LD (SOUND_ENABLED), A
 155+ 5937 E5           	PUSH HL
 156+ 5938 CD 24 42     	CALL PLY_AKG_STOP
 157+ 593B 3A D0 58     	LD A, (SFX_INIT_STATUS)
 158+ 593E B7           	OR A
 159+ 593F 28 0E        	JR Z, .EXIT ; SFX not in use
 160+ 5941 AF           	XOR A
 161+ 5942 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 162+ 5945 3E 01        	LD A, 1
 163+ 5947 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 164+ 594A 3E 02        	LD A, 2
 165+ 594C CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 166+ 594F              .EXIT:
 167+ 594F E1           	POP HL
 168+ 5950 AF           	XOR A ; success
 169+ 5951 C9           	RET
 170+ 5952              ; *******************************************************************************************************
 171+ 5952
 172+ 5952               IF (1 == 1)
 173+ 5952              ; *******************************************************************************************************
 174+ 5952              ; function to handle CALL SNDSFX basic extension
 175+ 5952              ; plays a sound effect
 176+ 5952              ; _SNDSFX ( BYTE sfx_number, >0
 177+ 5952              ;			BYTE channel, = 0,1 or 2
 178+ 5952              ;			BYTE inverted_volume = 0-16, 0 being full volume
 179+ 5952              ; will put ram in page 0 also, page 1 is already there
 180+ 5952              ; if sound off throws illegal function call
 181+ 5952              ; if sfx not initialized, throws out of data
 182+ 5952              SNDSFX:
 183+ 5952              	; opening (
 184+ 5952 CD A9 67     	CALL CHKCHAR
 185+ 5955 28           	DB '('
 186+ 5956              	; get sfx_number
 187+ 5956 DD 21 1C 52  	LD IX, GETBYT
 188+ 595A CD 59 01     	CALL CALBAS
 189+ 595D D5           	PUSH DE
 190+ 595E              	; comma
 191+ 595E CD A9 67     	CALL CHKCHAR
 192+ 5961 2C           	DB ','
 193+ 5962              	; get sfx address
 194+ 5962 DD 21 1C 52  	LD IX, GETBYT
 195+ 5966 CD 59 01     	CALL CALBAS
 196+ 5969 D5           	PUSH DE
 197+ 596A              	; comma
 198+ 596A CD A9 67     	CALL CHKCHAR
 199+ 596D 2C           	DB ','
 200+ 596E              	; get inverted volume
 201+ 596E DD 21 1C 52  	LD IX, GETBYT
 202+ 5972 CD 59 01     	CALL CALBAS
 203+ 5975 D5           	PUSH DE
 204+ 5976              	; ending )
 205+ 5976 CD A9 67     	CALL CHKCHAR
 206+ 5979 29           	DB ')'
 207+ 597A
 208+ 597A 3A D1 58     	LD A, (SOUND_ENABLED)
 209+ 597D B7           	OR A
 210+ 597E 20 05        	JR NZ, .L1
 211+ 5980              	; sound disabled, throw illegal function call
 212+ 5980 1E 05        	LD E, 5
 213+ 5982 C3 DB 67     	JP THROW_ERROR
 214+ 5985              .L1:
 215+ 5985 3A D0 58     	LD A, (SFX_INIT_STATUS)
 216+ 5988 B7           	OR A
 217+ 5989 20 05        	JR NZ, .L2
 218+ 598B              	; sfx data not initialized, throw out of data
 219+ 598B 1E 04        	LD E, 4
 220+ 598D C3 DB 67     	JP THROW_ERROR
 221+ 5990              .L2:
 222+ 5990              	; pop  parameters and store away for later
 223+ 5990 D1           	POP DE ; inverted volume
 224+ 5991 43           	LD B, E
 225+ 5992 D1           	POP DE ; channel
 226+ 5993 4B           	LD C, E
 227+ 5994 D1           	POP DE
 228+ 5995 7B           	LD A, E
 229+ 5996 08           	EX AF, AF'
 230+ 5997 E5           	PUSH HL ; basic text location
 231+ 5998 D9           	EXX
 232+ 5999 FD 21 A0 59  	LD IY, .RET
 233+ 599D C3 5A 67     	JP ENABLE_PAGE0
 234+ 59A0              .RET:
 235+ 59A0 D9           	EXX
 236+ 59A1 08           	EX AF, AF'
 237+ 59A2 CD 24 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
 238+ 59A5
 239+ 59A5 D1               POP DE
 240+ 59A6 C1               POP BC
 241+ 59A7 CD D1 66         CALL RESTORE_PAGE_INFO
 242+ 59AA
 243+ 59AA E1           	POP HL
 244+ 59AB C9           	RET
 245+ 59AC              ; *******************************************************************************************************
 246+ 59AC               ENDIF
 247+ 59AC
 248+ 59AC               IF (0 == 1)
 249+ 59AC ~            ; *******************************************************************************************************
 250+ 59AC ~            ; same as SNDSFX but for DEFUSR approach
 251+ 59AC ~            ; input IX=pointer to input array, real data from +2
 252+ 59AC ~            ; +2 = SFX number
 253+ 59AC ~            ; +4 = channel
 254+ 59AC ~            ; +6 = volume
 255+ 59AC ~            SNDSFX_DEFUSR:
 256+ 59AC ~            	LD A, (SOUND_ENABLED)
 257+ 59AC ~            	OR A
 258+ 59AC ~            	RET Z ; sound disabled, just exit
 259+ 59AC ~            	LD A, (SFX_INIT_STATUS)
 260+ 59AC ~            	OR A
 261+ 59AC ~            	RET Z ; sfx data not initialized, just exit
 262+ 59AC ~            	LD IY, .RET
 263+ 59AC ~            	JP ENABLE_PAGE0
 264+ 59AC ~            .RET:
 265+ 59AC ~            	EI
 266+ 59AC ~            	LD A,(IX+2) ; SFX number
 267+ 59AC ~            	LD C,(IX+4) ; channel
 268+ 59AC ~            	LD B,(IX+6) ; volume
 269+ 59AC ~            	CALL PLY_AKG_PLAYSOUNDEFFECT
 270+ 59AC ~                POP DE
 271+ 59AC ~                POP BC
 272+ 59AC ~                CALL RESTORE_PAGE_INFO
 273+ 59AC ~            	XOR A ; success
 274+ 59AC ~            	RET
 275+ 59AC ~            ; *******************************************************************************************************
 276+ 59AC               ENDIF
# file closed: asm\SOUND.asm
 148  59AC               ENDIF
 149  59AC
 150  59AC               IF (VRAM_CMDS == 1)
 151  59AC               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
   1+ 59AC               IF (1 == 1)
   2+ 59AC              ; *******************************************************************************************************
   3+ 59AC              ; function to handle CALL FILVRM basic extension
   4+ 59AC              ; FILVRM ( INT offset,
   5+ 59AC              ;		   INT count,
   6+ 59AC              ;		   BYTE value,
   7+ 59AC              ;		   BYTE wait_vsync) >0 = true
   8+ 59AC              ; wait_vsync will issue HALT before copying
   9+ 59AC              FILVRM:
  10+ 59AC              	; opening (
  11+ 59AC CD A9 67     	CALL CHKCHAR
  12+ 59AF 28           	DB '('
  13+ 59B0              	; get offset address
  14+ 59B0 DD 21 2F 54  	LD IX, FRMQNT
  15+ 59B4 CD 59 01     	CALL CALBAS
  16+ 59B7 D5           	PUSH DE
  17+ 59B8              	; comma
  18+ 59B8 CD A9 67     	CALL CHKCHAR
  19+ 59BB 2C           	DB ','
  20+ 59BC              	; get count
  21+ 59BC DD 21 2F 54  	LD IX, FRMQNT
  22+ 59C0 CD 59 01     	CALL CALBAS
  23+ 59C3 D5           	PUSH DE
  24+ 59C4              	; comma
  25+ 59C4 CD A9 67     	CALL CHKCHAR
  26+ 59C7 2C           	DB ','
  27+ 59C8              	; get value
  28+ 59C8 DD 21 1C 52  	LD IX, GETBYT
  29+ 59CC CD 59 01     	CALL CALBAS
  30+ 59CF F5           	PUSH AF
  31+ 59D0              	; comma
  32+ 59D0 CD A9 67     	CALL CHKCHAR
  33+ 59D3 2C           	DB ','
  34+ 59D4              	; get vsync wait
  35+ 59D4 DD 21 1C 52  	LD IX, GETBYT
  36+ 59D8 CD 59 01     	CALL CALBAS
  37+ 59DB F5           	PUSH AF
  38+ 59DC              	; ending )
  39+ 59DC CD A9 67     	CALL CHKCHAR
  40+ 59DF 29           	DB ')'
  41+ 59E0
  42+ 59E0              	; save position
  43+ 59E0 E5           	PUSH HL
  44+ 59E1 DD E1        	POP IX
  45+ 59E3
  46+ 59E3              	; syntax ok
  47+ 59E3              	; wait for vsync if needed
  48+ 59E3 F1           	POP AF
  49+ 59E4 B7           	OR A
  50+ 59E5 28 01        	JR Z, .L1
  51+ 59E7 76           	HALT
  52+ 59E8
  53+ 59E8              .L1:
  54+ 59E8 3E 01        	LD A,1
  55+ 59EA 32 8D 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
  56+ 59ED F1               POP AF ; value
  57+ 59EE C1               POP BC ; count
  58+ 59EF E1               POP HL ; offset
  59+ 59F0 CD 56 00         CALL BIOS_FILVRM
  60+ 59F3 AF           	XOR A
  61+ 59F4 32 8D 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
  62+ 59F7
  63+ 59F7              .L3:
  64+ 59F7 DD E5        	PUSH IX
  65+ 59F9 E1           	POP HL
  66+ 59FA C9           	RET
  67+ 59FB              ; *******************************************************************************************************
  68+ 59FB               ENDIF
  69+ 59FB
  70+ 59FB               IF (0 == 1)
  71+ 59FB ~            ; *******************************************************************************************************
  72+ 59FB ~            ; same as FILVRM but for DEFUSR approach
  73+ 59FB ~            ; input IX=pointer to input array, real data from +2
  74+ 59FB ~            ; +2 = offset
  75+ 59FB ~            ; +4 = count
  76+ 59FB ~            ; +6 = value
  77+ 59FB ~            ; +8 = halt flag
  78+ 59FB ~            FILVRM_DEFUSR:
  79+ 59FB ~            	LD A,(IX+8)
  80+ 59FB ~            	OR A
  81+ 59FB ~            	JR Z,.L0
  82+ 59FB ~            	HALT
  83+ 59FB ~            .L0:
  84+ 59FB ~            	LD A,1
  85+ 59FB ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  86+ 59FB ~            	LD L,(IX+2)
  87+ 59FB ~            	LD H,(IX+3)
  88+ 59FB ~            	LD C,(IX+4)
  89+ 59FB ~            	LD B,(IX+5)
  90+ 59FB ~            	LD A,(IX+6)
  91+ 59FB ~            	CALL BIOS_FILVRM
  92+ 59FB ~            	XOR A
  93+ 59FB ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  94+ 59FB ~            	RET
  95+ 59FB ~            ; *******************************************************************************************************
  96+ 59FB               ENDIF
  97+ 59FB
  98+ 59FB               IF (1 == 1)
  99+ 59FB              ; *******************************************************************************************************
 100+ 59FB              ; function to handle CALL MEMVRM basic extension
 101+ 59FB              ; copies from RAM to VRAM
 102+ 59FB              ; if flag != 0 it will issue HALT before copying
 103+ 59FB              ; if bit 1 of flag set and sprite system initialized it will set sprite update flag
 104+ 59FB              ; _MEMVRM ( INT source,
 105+ 59FB              ;			INT destination,
 106+ 59FB              ;			INT count,
 107+ 59FB              ;			BYTE flag)
 108+ 59FB              ; will put ram in page 0 also, page 1 is already there
 109+ 59FB              MEMVRM:
 110+ 59FB              	; opening (
 111+ 59FB CD A9 67     	CALL CHKCHAR
 112+ 59FE 28           	DB '('
 113+ 59FF              	; get source address
 114+ 59FF DD 21 2F 54  	LD IX, FRMQNT
 115+ 5A03 CD 59 01     	CALL CALBAS
 116+ 5A06 D5           	PUSH DE
 117+ 5A07              	; comma
 118+ 5A07 CD A9 67     	CALL CHKCHAR
 119+ 5A0A 2C           	DB ','
 120+ 5A0B              	; get destination address
 121+ 5A0B DD 21 2F 54  	LD IX, FRMQNT
 122+ 5A0F CD 59 01     	CALL CALBAS
 123+ 5A12 D5           	PUSH DE
 124+ 5A13              	; comma
 125+ 5A13 CD A9 67     	CALL CHKCHAR
 126+ 5A16 2C           	DB ','
 127+ 5A17              	; get length
 128+ 5A17 DD 21 2F 54  	LD IX, FRMQNT
 129+ 5A1B CD 59 01     	CALL CALBAS
 130+ 5A1E D5           	PUSH DE
 131+ 5A1F              	; comma
 132+ 5A1F CD A9 67     	CALL CHKCHAR
 133+ 5A22 2C           	DB ','
 134+ 5A23              	; get vsync wait
 135+ 5A23 DD 21 1C 52  	LD IX, GETBYT
 136+ 5A27 CD 59 01     	CALL CALBAS
 137+ 5A2A F5           	PUSH AF
 138+ 5A2B              	; ending )
 139+ 5A2B CD A9 67     	CALL CHKCHAR
 140+ 5A2E 29           	DB ')'
 141+ 5A2F
 142+ 5A2F                  ; save position in BASIC text
 143+ 5A2F E5           	PUSH HL
 144+ 5A30 DD E1        	POP IX
 145+ 5A32
 146+ 5A32 F1           	POP AF ; wait vsync
 147+ 5A33 B7           	OR A
 148+ 5A34 28 0F        	JR Z, .L1
 149+ 5A36              	; check for special case to set sprite update flag
 150+ 5A36              	IF (SPRITE_CMDS == 1)
 151+ 5A36 E6 02        		AND 2
 152+ 5A38 28 0A        		JR Z,.L2
 153+ 5A3A 3A 86 4D     		LD A, (SPRATR_INIT_STATUS)
 154+ 5A3D B7           		OR A
 155+ 5A3E 28 04        		JR Z,.L2
 156+ 5A40 2A 87 4D     		LD HL,(SPRATR_UPDATE_FLAG)
 157+ 5A43 77           		LD (HL),A
 158+ 5A44              	ENDIF
 159+ 5A44              .L2:
 160+ 5A44 76           	HALT
 161+ 5A45              .L1:
 162+ 5A45              	; pop LDIR parameters and store away for later
 163+ 5A45 C1           	POP BC ; count
 164+ 5A46 D1           	POP DE ; vram destination
 165+ 5A47 E1           	POP HL ; ram source
 166+ 5A48 D9           	EXX
 167+ 5A49 FD 21 50 5A   	LD IY, .RET
 168+ 5A4D C3 5A 67     	JP ENABLE_PAGE0
 169+ 5A50              .RET:
 170+ 5A50 FB           	EI
 171+ 5A51 D9           	EXX
 172+ 5A52 CD 5E 5A     	CALL VRAM_LDIRVM
 173+ 5A55 D1               POP DE
 174+ 5A56 C1               POP BC
 175+ 5A57 CD D1 66         CALL RESTORE_PAGE_INFO
 176+ 5A5A DD E5        	PUSH IX
 177+ 5A5C E1           	POP HL
 178+ 5A5D C9           	RET
 179+ 5A5E              ; *******************************************************************************************************
 180+ 5A5E               ENDIF
 181+ 5A5E
 182+ 5A5E               IF (0 == 1)
 183+ 5A5E ~            ; *******************************************************************************************************
 184+ 5A5E ~            ; same as MEMVRM but for DEFUSR approach
 185+ 5A5E ~            ; input IX=pointer to input array, real data from +2
 186+ 5A5E ~            ; +2 = source address
 187+ 5A5E ~            ; +4 = destination address
 188+ 5A5E ~            ; +6 = lenght
 189+ 5A5E ~            ; +8 = flag
 190+ 5A5E ~            MEMVRM_DEFUSR:
 191+ 5A5E ~            	LD A,(IX+8)
 192+ 5A5E ~            	OR A
 193+ 5A5E ~            	JR Z,.L0
 194+ 5A5E ~            	IF (SPRITE_CMDS == 1)
 195+ 5A5E ~            		AND 2
 196+ 5A5E ~            		JR Z,.L2
 197+ 5A5E ~            		LD A, (SPRATR_INIT_STATUS)
 198+ 5A5E ~            		OR A
 199+ 5A5E ~            		JR Z,.L2
 200+ 5A5E ~            		LD HL,(SPRATR_UPDATE_FLAG)
 201+ 5A5E ~            		LD (HL),A
 202+ 5A5E ~            	ENDIF
 203+ 5A5E ~            .L2:
 204+ 5A5E ~            	HALT
 205+ 5A5E ~            .L0:
 206+ 5A5E ~            	; enable page 0
 207+ 5A5E ~            	LD IY, .RET
 208+ 5A5E ~            	JP ENABLE_PAGE0
 209+ 5A5E ~            .RET:
 210+ 5A5E ~            	EI
 211+ 5A5E ~            	LD L,(IX+2)
 212+ 5A5E ~            	LD H,(IX+3)
 213+ 5A5E ~            	LD E,(IX+4)
 214+ 5A5E ~            	LD D,(IX+5)
 215+ 5A5E ~            	LD C,(IX+6)
 216+ 5A5E ~            	LD B,(IX+7)
 217+ 5A5E ~            	CALL VRAM_LDIRVM
 218+ 5A5E ~            .COMMON:
 219+ 5A5E ~                POP DE
 220+ 5A5E ~                POP BC
 221+ 5A5E ~                CALL RESTORE_PAGE_INFO
 222+ 5A5E ~            	XOR A ; success
 223+ 5A5E ~            	RET
 224+ 5A5E ~            ; *******************************************************************************************************
 225+ 5A5E               ENDIF
 226+ 5A5E
 227+ 5A5E              ; *******************************************************************************************************
 228+ 5A5E              ; common code to copy from memory to VRAM
 229+ 5A5E              ; input HL=RAM source
 230+ 5A5E              ; input DE=VRAM destination
 231+ 5A5E              ; BC=count
 232+ 5A5E              VRAM_LDIRVM:
 233+ 5A5E 3E 01        	LD A,1
 234+ 5A60 32 8D 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 235+ 5A63 EB           	EX DE, HL
 236+ 5A64 F3           	DI
 237+ 5A65 CD 77 66     	CALL SETWRT_LOCAL_WRITE
 238+ 5A68 FB           	EI
 239+ 5A69 EB           	EX DE, HL
 240+ 5A6A 78           	LD A, B
 241+ 5A6B B7           	OR A
 242+ 5A6C 28 0D        	JR Z, .L3
 243+ 5A6E C5           	PUSH BC
 244+ 5A6F 0E 98        	LD C, #98
 245+ 5A71              .L2:
 246+ 5A71 50           	LD D, B
 247+ 5A72 06 00        	LD B, 0
 248+ 5A74 CD 8E 66     	CALL BBYTECOPY_NO_C
 249+ 5A77 42           	LD B, D
 250+ 5A78 10 F7        	DJNZ .L2
 251+ 5A7A C1           	POP BC
 252+ 5A7B              .L3:
 253+ 5A7B 79           	LD A, C
 254+ 5A7C B7           	OR A
 255+ 5A7D 28 04        	JR Z,.L4
 256+ 5A7F 41           	LD B, C
 257+ 5A80 CD 8C 66     	CALL BBYTECOPY
 258+ 5A83              .L4:
 259+ 5A83 AF           	XOR A
 260+ 5A84 32 8D 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 261+ 5A87 C9           	RET
 262+ 5A88              ; *******************************************************************************************************
 263+ 5A88
 264+ 5A88               IF (1 == 1)
 265+ 5A88              ; *******************************************************************************************************
 266+ 5A88              ; function to handle CALL VRMMEM basic extension
 267+ 5A88              ; copies from VRAM to RAM
 268+ 5A88              ; _VRMMEM ( INT source,
 269+ 5A88              ;			INT destination,
 270+ 5A88              ;			INT count
 271+ 5A88              ; will put ram in page 0 also, page 1 is already there
 272+ 5A88              VRMMEM:
 273+ 5A88              	; opening (
 274+ 5A88 CD A9 67     	CALL CHKCHAR
 275+ 5A8B 28           	DB '('
 276+ 5A8C              	; get source address
 277+ 5A8C DD 21 2F 54  	LD IX, FRMQNT
 278+ 5A90 CD 59 01     	CALL CALBAS
 279+ 5A93 D5           	PUSH DE
 280+ 5A94              	; comma
 281+ 5A94 CD A9 67     	CALL CHKCHAR
 282+ 5A97 2C           	DB ','
 283+ 5A98              	; get destination address
 284+ 5A98 DD 21 2F 54  	LD IX, FRMQNT
 285+ 5A9C CD 59 01     	CALL CALBAS
 286+ 5A9F D5           	PUSH DE
 287+ 5AA0              	; comma
 288+ 5AA0 CD A9 67     	CALL CHKCHAR
 289+ 5AA3 2C           	DB ','
 290+ 5AA4              	; get length
 291+ 5AA4 DD 21 2F 54  	LD IX, FRMQNT
 292+ 5AA8 CD 59 01     	CALL CALBAS
 293+ 5AAB D5           	PUSH DE
 294+ 5AAC              	; ending )
 295+ 5AAC CD A9 67     	CALL CHKCHAR
 296+ 5AAF 29           	DB ')'
 297+ 5AB0
 298+ 5AB0                  ; save position in BASIC text
 299+ 5AB0 E5           	PUSH HL
 300+ 5AB1 DD E1        	POP IX
 301+ 5AB3
 302+ 5AB3 C1           	POP BC ; count
 303+ 5AB4 D1           	POP DE ; destination
 304+ 5AB5 E1           	POP HL ; source
 305+ 5AB6 D9           	EXX
 306+ 5AB7 FD 21 BE 5A  	LD IY, .RET
 307+ 5ABB C3 5A 67     	JP ENABLE_PAGE0
 308+ 5ABE              .RET:
 309+ 5ABE FB           	EI
 310+ 5ABF D9           	EXX
 311+ 5AC0 CD CC 5A     	CALL VRAM_LDIRMV
 312+ 5AC3 D1               POP DE
 313+ 5AC4 C1               POP BC
 314+ 5AC5 CD D1 66         CALL RESTORE_PAGE_INFO
 315+ 5AC8 DD E5        	PUSH IX
 316+ 5ACA E1           	POP HL
 317+ 5ACB C9           	RET
 318+ 5ACC              ; *******************************************************************************************************
 319+ 5ACC               ENDIF
 320+ 5ACC
 321+ 5ACC               IF (0 == 1)
 322+ 5ACC ~            ; *******************************************************************************************************
 323+ 5ACC ~            ; same as VRMMEM but for DEFUSR approach
 324+ 5ACC ~            ; input IX=pointer to input array, real data from +2
 325+ 5ACC ~            ; +2 = source address
 326+ 5ACC ~            ; +4 = destination address
 327+ 5ACC ~            ; +6 = count
 328+ 5ACC ~            VRMMEM_DEFUSR:
 329+ 5ACC ~            	; enable page 0
 330+ 5ACC ~            	LD IY, .RET
 331+ 5ACC ~            	JP ENABLE_PAGE0
 332+ 5ACC ~            .RET:
 333+ 5ACC ~            	EI
 334+ 5ACC ~            	LD L,(IX+2)
 335+ 5ACC ~            	LD H,(IX+3)
 336+ 5ACC ~            	LD E,(IX+4)
 337+ 5ACC ~            	LD D,(IX+5)
 338+ 5ACC ~            	LD C,(IX+6)
 339+ 5ACC ~            	LD B,(IX+7)
 340+ 5ACC ~            	CALL VRAM_LDIRMV
 341+ 5ACC ~            	JR MEMVRM_DEFUSR.COMMON
 342+ 5ACC ~            ; *******************************************************************************************************
 343+ 5ACC               ENDIF
 344+ 5ACC
 345+ 5ACC              ; *******************************************************************************************************
 346+ 5ACC              ; common code to copy from VRAM to RAM
 347+ 5ACC              ; input HL=VRAM source
 348+ 5ACC              ; input DE=RAM destination
 349+ 5ACC              ; BC=count
 350+ 5ACC              VRAM_LDIRMV:
 351+ 5ACC 3E 01        	LD A,1
 352+ 5ACE 32 8D 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 353+ 5AD1 7D           	LD	A, L
 354+ 5AD2 F3           	DI
 355+ 5AD3 CD 82 66     	CALL SETWRT_LOCAL_READ
 356+ 5AD6 FB           	EI
 357+ 5AD7 00           	NOP
 358+ 5AD8 00           	NOP
 359+ 5AD9 00           	NOP ; too fast VDP access per openMSX
 360+ 5ADA              .L4:
 361+ 5ADA DB 98            IN A, (#98)
 362+ 5ADC 12           	LD (DE), A
 363+ 5ADD 13               INC DE
 364+ 5ADE 0B               DEC BC
 365+ 5ADF 79               LD A, C
 366+ 5AE0 B0               OR B
 367+ 5AE1 20 F7            JR NZ, .L4
 368+ 5AE3 AF           	XOR A
 369+ 5AE4 32 8D 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 370+ 5AE7 C9               RET
 371+ 5AE8              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
 152  5AE8               ENDIF
 153  5AE8
 154  5AE8               IF (GENCAL_CMD == 1)
 155  5AE8               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
   1+ 5AE8               IF (0 == 1)
   2+ 5AE8 ~            ; *******************************************************************************************************
   3+ 5AE8 ~            ; same as GENCAL but for DEFUSR approach
   4+ 5AE8 ~            ; input IX=pointer to input array, real data from +2
   5+ 5AE8 ~            ; +2 = function address to call
   6+ 5AE8 ~            ; +4 = register list array pointer
   7+ 5AE8 ~            GENCAL_DEFUSR:
   8+ 5AE8 ~                LD L,(IX+2)
   9+ 5AE8 ~                LD H,(IX+3)
  10+ 5AE8 ~                PUSH HL
  11+ 5AE8 ~                LD L,(IX+4)
  12+ 5AE8 ~                LD H,(IX+5)
  13+ 5AE8 ~                PUSH HL
  14+ 5AE8 ~                JR GENCAL.COMMON
  15+ 5AE8 ~            ; *******************************************************************************************************
  16+ 5AE8               ENDIF
  17+ 5AE8
  18+ 5AE8              ; *******************************************************************************************************
  19+ 5AE8              ; function to handle CALL GENCAL basic extension
  20+ 5AE8              ; GENCAL ( INT fn_addr, = address of the function to call
  21+ 5AE8              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
  22+ 5AE8              ; output values of registers will also be stored at reg_list_ptr
  23+ 5AE8              GENCAL:
  24+ 5AE8               IF (1 == 1)
  25+ 5AE8              	; opening (
  26+ 5AE8 CD A9 67     	CALL CHKCHAR
  27+ 5AEB 28           	DB '('
  28+ 5AEC              	; get function address
  29+ 5AEC DD 21 2F 54  	LD IX, FRMQNT
  30+ 5AF0 CD 59 01     	CALL CALBAS
  31+ 5AF3 D5           	PUSH DE
  32+ 5AF4              	; comma
  33+ 5AF4 CD A9 67     	CALL CHKCHAR
  34+ 5AF7 2C           	DB ','
  35+ 5AF8              	; get pointer to register list
  36+ 5AF8 3E 02            LD A,2
  37+ 5AFA 06 01            LD B,1
  38+ 5AFC 11 00 05         LD DE,#0500
  39+ 5AFF CD 0E 68         CALL GET_BASIC_ARRAY_DATA_POINTER
  40+ 5B02 C5           	PUSH BC
  41+ 5B03              	; ending )
  42+ 5B03 CD A9 67     	CALL CHKCHAR
  43+ 5B06 29           	DB ')'
  44+ 5B07               ENDIF
  45+ 5B07              .COMMON:
  46+ 5B07              	; save BASIC token position
  47+ 5B07 E5           	PUSH HL
  48+ 5B08 D9               EXX
  49+ 5B09 E1           	POP HL ; HL'=next basic token
  50+ 5B0A D9               EXX
  51+ 5B0B
  52+ 5B0B E1               POP HL ; get pointer to register values
  53+ 5B0C F3           	DI
  54+ 5B0D ED 73 7C 64      LD (BLIT_STRUCT), SP
  55+ 5B11 F9               LD SP, HL
  56+ 5B12 F1               POP AF
  57+ 5B13 C1               POP BC
  58+ 5B14 D1               POP DE
  59+ 5B15 E1               POP HL
  60+ 5B16 DD E1            POP IX
  61+ 5B18 FD E1            POP IY
  62+ 5B1A D9               EXX
  63+ 5B1B ED 73 7E 64      LD (BLIT_STRUCT+2), SP
  64+ 5B1F ED 7B 7C 64      LD SP, (BLIT_STRUCT)
  65+ 5B23 FB               EI
  66+ 5B24 D1               POP DE ; get function to call
  67+ 5B25 E5               PUSH HL
  68+ 5B26 CD 42 5B         CALL .EXXDECALL
  69+ 5B29 F3               DI
  70+ 5B2A ED 73 7C 64      LD (BLIT_STRUCT), SP
  71+ 5B2E ED 7B 7E 64      LD SP, (BLIT_STRUCT+2)
  72+ 5B32 FD E5            PUSH IY
  73+ 5B34 DD E5            PUSH IX
  74+ 5B36 E5               PUSH HL
  75+ 5B37 D5               PUSH DE
  76+ 5B38 C5               PUSH BC
  77+ 5B39 F5               PUSH AF
  78+ 5B3A ED 7B 7C 64      LD SP, (BLIT_STRUCT)
  79+ 5B3E FB               EI
  80+ 5B3F E1               POP HL
  81+ 5B40 AF               XOR A ; success
  82+ 5B41 C9           	RET
  83+ 5B42
  84+ 5B42              .EXXDECALL:
  85+ 5B42 D5               PUSH DE
  86+ 5B43 D9               EXX
  87+ 5B44 C9               RET
  88+ 5B45              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
 156  5B45               ENDIF
 157  5B45
 158  5B45               IF (BOX_CMDS == 1)
 159  5B45               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
   1+ 5B45              ; *******************************************************************************************************
   2+ 5B45              ; generic function to implement rectangle data copy
   3+ 5B45              ; should be modified to call appropriate function for memory or vram
   4+ 5B45              ; input IX=pointer to following structure
   5+ 5B45              ; +00 source data pointer
   6+ 5B45              ; +02 num bytes in a row
   7+ 5B45              ; +04 number of rows
   8+ 5B45              ; +06 source add-to value till next row
   9+ 5B45              ; +08 destination address
  10+ 5B45              ; +10 destination add-to value till next row
  11+ 5B45              ; modifies AF, BC, DE, HL
  12+ 5B45              RECTANGLE_COPY:
  13+ 5B45 DD 6E 00     	LD L, (IX+0)
  14+ 5B48 DD 66 01     	LD H, (IX+1) ; source address
  15+ 5B4B DD 5E 08     	LD E, (IX+8)
  16+ 5B4E DD 56 09     	LD D, (IX+9) ; destination
  17+ 5B51 DD 46 04     	LD B, (IX+4) ; row number
  18+ 5B54              .L1:
  19+ 5B54 C5           	PUSH BC
  20+ 5B55 E5           		PUSH HL
  21+ 5B56 D5           			PUSH DE
  22+ 5B57 DD 4E 02     				LD C, (IX+2)
  23+ 5B5A DD 46 03     				LD B, (IX+3) ; num bytes in a row
  24+ 5B5D              .CALL1:
  25+ 5B5D CD 00 00     				CALL 0 ; set destination address from DE
  26+ 5B60              .CALL2:
  27+ 5B60 CD 00 00     				CALL 0 ; copy data fn
  28+ 5B63 E1           			POP HL
  29+ 5B64 DD 4E 0A     			LD C, (IX+10)
  30+ 5B67 DD 46 0B     			LD B, (IX+11) ; destination add-to
  31+ 5B6A 09           			ADD HL, BC
  32+ 5B6B EB           			EX DE, HL
  33+ 5B6C E1           		POP HL
  34+ 5B6D DD 4E 06     		LD C, (IX+6)
  35+ 5B70 DD 46 07     		LD B, (IX+7) ; src add-to
  36+ 5B73 09           		ADD HL, BC
  37+ 5B74 C1           	POP BC
  38+ 5B75 10 DD        	DJNZ .L1
  39+ 5B77 C9           	RET
  40+ 5B78              ; *******************************************************************************************************
  41+ 5B78
  42+ 5B78               IF (1 == 1)
  43+ 5B78              ; *******************************************************************************************************
  44+ 5B78              ; function to handle CALL BOXMEMCPY basic extension
  45+ 5B78              ; copies data with window like boundaries within ram
  46+ 5B78              ; BOXMEMCPY ( INT source data pointer,
  47+ 5B78              ;			  INT source number of bytes in a row,
  48+ 5B78              ;			  INT number of rows,
  49+ 5B78              ;			  INT source add-to value till next row,
  50+ 5B78              ; 			  INT destination pointer,
  51+ 5B78              ;			  INT destination add-to value till next row )
  52+ 5B78              ; request_data_ptr described in RECTANGLE_COPY
  53+ 5B78              ; will put ram in page 0 also, page 1 is already there
  54+ 5B78              BOXMEMCPY:
  55+ 5B78 11 82 5B     	LD DE,BOXMEMCPY_COMMON
  56+ 5B7B ED 53 FA 5B  	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
  57+ 5B7F C3 95 5B     	JP BOX_EXTENSION_PARAMS_COMMON
  58+ 5B82               ENDIF
  59+ 5B82
  60+ 5B82               IF (0 == 1)
  61+ 5B82 ~            ; *******************************************************************************************************
  62+ 5B82 ~            ; same as BOXMEMCPY but for DEFUSR approach
  63+ 5B82 ~            ; input IX=pointer to input array, real data from +2
  64+ 5B82 ~            ; +02 = source data pointer
  65+ 5B82 ~            ; +04 = source number of bytes in a row
  66+ 5B82 ~            ; +06 = number of rows
  67+ 5B82 ~            ; +08 = source add-to value till next row
  68+ 5B82 ~            ; +10 = destination pointer
  69+ 5B82 ~            ; +12 = destination add-to value till next row
  70+ 5B82 ~            BOXMEMCPY_DEFUSR:
  71+ 5B82 ~            	LD HL,BOXMEMCPY_COMMON
  72+ 5B82 ~            	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
  73+ 5B82 ~            	INC IX
  74+ 5B82 ~            	INC IX
  75+ 5B82 ~            	JP BOXCOMMON_DEFUSR
  76+ 5B82               ENDIF
  77+ 5B82
  78+ 5B82              BOXMEMCPY_COMMON:
  79+ 5B82 FB           	EI
  80+ 5B83              	; set RAM functions to call
  81+ 5B83 21 00 00     	LD HL, 0
  82+ 5B86 22 5D 5B     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
  83+ 5B89 22 5F 5B     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
  84+ 5B8C 21 ED B0     	LD HL, #B0ED ; LDIR
  85+ 5B8F 22 61 5B     	LD (RECTANGLE_COPY.CALL1+4), HL
  86+ 5B92 C3 FF 5B     	JP BOXCOMMON_DEFUSR.CALL
  87+ 5B95              ; *******************************************************************************************************
  88+ 5B95
  89+ 5B95               IF (1 == 1)
  90+ 5B95              ; *******************************************************************************************************
  91+ 5B95              ; common parts of BOX commands to load parameters
  92+ 5B95              BOX_EXTENSION_PARAMS_COMMON:
  93+ 5B95              	; opening (
  94+ 5B95 CD A9 67     	CALL CHKCHAR
  95+ 5B98 28           	DB '('
  96+ 5B99              	; get source data pointer
  97+ 5B99 DD 21 2F 54  	LD IX, FRMQNT
  98+ 5B9D CD 59 01     	CALL CALBAS
  99+ 5BA0 ED 53 7C 64  	LD (BLIT_STRUCT+0), DE
 100+ 5BA4              	; comma
 101+ 5BA4 CD A9 67     	CALL CHKCHAR
 102+ 5BA7 2C           	DB ','
 103+ 5BA8              	; source number of bytes in a row
 104+ 5BA8 DD 21 2F 54  	LD IX, FRMQNT
 105+ 5BAC CD 59 01     	CALL CALBAS
 106+ 5BAF ED 53 7E 64  	LD (BLIT_STRUCT+2), DE
 107+ 5BB3              	; comma
 108+ 5BB3 CD A9 67     	CALL CHKCHAR
 109+ 5BB6 2C           	DB ','
 110+ 5BB7              	; number of rows
 111+ 5BB7 DD 21 2F 54  	LD IX, FRMQNT
 112+ 5BBB CD 59 01     	CALL CALBAS
 113+ 5BBE ED 53 80 64  	LD (BLIT_STRUCT+4), DE
 114+ 5BC2              	; comma
 115+ 5BC2 CD A9 67     	CALL CHKCHAR
 116+ 5BC5 2C           	DB ','
 117+ 5BC6              	; source add-to value till next row
 118+ 5BC6 DD 21 2F 54  	LD IX, FRMQNT
 119+ 5BCA CD 59 01     	CALL CALBAS
 120+ 5BCD ED 53 82 64  	LD (BLIT_STRUCT+6), DE
 121+ 5BD1              	; comma
 122+ 5BD1 CD A9 67     	CALL CHKCHAR
 123+ 5BD4 2C           	DB ','
 124+ 5BD5              	; destination pointer
 125+ 5BD5 DD 21 2F 54  	LD IX, FRMQNT
 126+ 5BD9 CD 59 01     	CALL CALBAS
 127+ 5BDC ED 53 84 64  	LD (BLIT_STRUCT+8), DE
 128+ 5BE0              	; comma
 129+ 5BE0 CD A9 67     	CALL CHKCHAR
 130+ 5BE3 2C           	DB ','
 131+ 5BE4              	; destination add-to value till next row
 132+ 5BE4 DD 21 2F 54  	LD IX, FRMQNT
 133+ 5BE8 CD 59 01     	CALL CALBAS
 134+ 5BEB ED 53 86 64  	LD (BLIT_STRUCT+10), DE
 135+ 5BEF              	; ending )
 136+ 5BEF CD A9 67     	CALL CHKCHAR
 137+ 5BF2 29           	DB ')'
 138+ 5BF3 DD 21 7C 64  	LD IX,BLIT_STRUCT
 139+ 5BF7               ENDIF
 140+ 5BF7              BOXCOMMON_DEFUSR:
 141+ 5BF7 E5           	PUSH HL ; save position in BASIC buffer
 142+ 5BF8              .ADDR:
 143+ 5BF8 FD 21 00 00  	LD IY, 0 ; modified by code
 144+ 5BFC C3 5A 67     	JP ENABLE_PAGE0
 145+ 5BFF              .CALL:
 146+ 5BFF CD 45 5B     	CALL RECTANGLE_COPY
 147+ 5C02 AF           	XOR A
 148+ 5C03 32 8D 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 149+ 5C06
 150+ 5C06 D1               POP DE
 151+ 5C07 C1               POP BC
 152+ 5C08 CD D1 66         CALL RESTORE_PAGE_INFO
 153+ 5C0B
 154+ 5C0B E1           	POP HL
 155+ 5C0C AF           	XOR A ; success
 156+ 5C0D C9           	RET
 157+ 5C0E              ; *******************************************************************************************************
 158+ 5C0E
 159+ 5C0E               IF (1 == 1)
 160+ 5C0E              ; *******************************************************************************************************
 161+ 5C0E              ; function to handle CALL BOXMEMVRM basic extension
 162+ 5C0E              ; copies data with window like boundaries from ram to Vram
 163+ 5C0E              ; BOXMEMVRM ( INT source data pointer,
 164+ 5C0E              ;			  INT source number of bytes in a row,
 165+ 5C0E              ;			  INT number of rows,
 166+ 5C0E              ;			  INT source add-to value till next row,
 167+ 5C0E              ; 			  INT destination pointer,
 168+ 5C0E              ;			  INT destination add-to value till next row )
 169+ 5C0E              ; request_data_ptr described in RECTANGLE_COPY
 170+ 5C0E              ; will put ram in page 0 also, page 1 is already there
 171+ 5C0E              BOXMEMVRM:
 172+ 5C0E 11 18 5C     	LD DE,BOXMEMVRM_COMMON
 173+ 5C11 ED 53 FA 5B  	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
 174+ 5C15 C3 95 5B     	JP BOX_EXTENSION_PARAMS_COMMON
 175+ 5C18               ENDIF
 176+ 5C18
 177+ 5C18               IF (0 == 1)
 178+ 5C18 ~            ; *******************************************************************************************************
 179+ 5C18 ~            ; same as BOXMEMVRM but for DEFUSR approach
 180+ 5C18 ~            ; input IX=pointer to input array, real data from +2
 181+ 5C18 ~            ; +02 = source data pointer
 182+ 5C18 ~            ; +04 = source number of bytes in a row
 183+ 5C18 ~            ; +06 = number of rows
 184+ 5C18 ~            ; +08 = source add-to value till next row
 185+ 5C18 ~            ; +10 = destination pointer
 186+ 5C18 ~            ; +12 = destination add-to value till next row
 187+ 5C18 ~            BOXMEMVRM_DEFUSR:
 188+ 5C18 ~            	LD HL,BOXMEMVRM_COMMON
 189+ 5C18 ~            	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
 190+ 5C18 ~            	INC IX
 191+ 5C18 ~            	INC IX
 192+ 5C18 ~            	JP BOXCOMMON_DEFUSR
 193+ 5C18               ENDIF
 194+ 5C18
 195+ 5C18              BOXMEMVRM_COMMON:
 196+ 5C18 FB           	EI
 197+ 5C19              	; set RAM functions to call
 198+ 5C19 21 33 5C     	LD HL, .SETDEST
 199+ 5C1C 22 5E 5B     	LD (RECTANGLE_COPY.CALL1+1), HL
 200+ 5C1F 21 3B 5C     	LD HL, .COPYDATA
 201+ 5C22 22 61 5B     	LD (RECTANGLE_COPY.CALL2+1), HL
 202+ 5C25 3E CD        	LD A, #CD ; CALL
 203+ 5C27 32 5D 5B     	LD (RECTANGLE_COPY.CALL1), A
 204+ 5C2A 32 60 5B     	LD (RECTANGLE_COPY.CALL2), A
 205+ 5C2D              	;LD A,1
 206+ 5C2D 32 8D 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 207+ 5C30 C3 FF 5B     	JP BOXCOMMON_DEFUSR.CALL
 208+ 5C33              .SETDEST:
 209+ 5C33 EB           	EX DE, HL
 210+ 5C34 F3           	DI
 211+ 5C35 CD 77 66     	CALL SETWRT_LOCAL_WRITE
 212+ 5C38 FB           	EI
 213+ 5C39 EB           	EX DE, HL
 214+ 5C3A C9           	RET
 215+ 5C3B              .COPYDATA:
 216+ 5C3B 41           	LD B, C
 217+ 5C3C C3 8C 66     	JP BBYTECOPY
 218+ 5C3F              ; *******************************************************************************************************
# file closed: asm\BOX.asm
 160  5C3F               ENDIF
 161  5C3F
 162  5C3F               IF (BLIT_CMDS == 1)
 163  5C3F               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
   1+ 5C3F              ; *******************************************************************************************************
   2+ 5C3F              ; function rotates mask and data of several characters and applies to background data
   3+ 5C3F              ; this handles x-shift from 0 to 4
   4+ 5C3F              ; contains self-modifying code that is set-up from external function
   5+ 5C3F              ; input HL=pointer to mask data
   6+ 5C3F              ; input HL'=pointer to character data
   7+ 5C3F              ; input DE=output buffer containing background data
   8+ 5C3F              ; input BC=DE+8
   9+ 5C3F              ; input A=number of characters to process
  10+ 5C3F              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  11+ 5C3F              SHIFT04:
  12+ 5C3F 08           	EX AF, AF'
  13+ 5C40 7E           	LD A, (HL) ; get mask
  14+ 5C41 D9           	EXX
  15+ 5C42 57           	LD D, A
  16+ 5C43 1E FF        	LD E, #FF
  17+ 5C45 37           	SCF
  18+ 5C46              .M1:
  19+ 5C46 18 FE        	JR .M1 ; this is self-modifying part
  20+ 5C48 CB 1A        	RR D
  21+ 5C4A CB 1B        	RR E
  22+ 5C4C CB 1A        	RR D
  23+ 5C4E CB 1B        	RR E
  24+ 5C50 CB 1A        	RR D
  25+ 5C52 CB 1B        	RR E
  26+ 5C54 CB 1A        	RR D
  27+ 5C56 CB 1B        	RR E
  28+ 5C58
  29+ 5C58 46           	LD B, (HL) ; get data
  30+ 5C59 0E 00        	LD C, 0
  31+ 5C5B              .M2:
  32+ 5C5B 18 FE        	JR .M2 ; also self-modifying part
  33+ 5C5D CB 38        	SRL B
  34+ 5C5F CB 19        	RR C
  35+ 5C61 CB 38        	SRL B
  36+ 5C63 CB 19        	RR C
  37+ 5C65 CB 38        	SRL B
  38+ 5C67 CB 19        	RR C
  39+ 5C69 CB 38        	SRL B
  40+ 5C6B CB 19        	RR C
  41+ 5C6D
  42+ 5C6D D9           	EXX
  43+ 5C6E 1A           	LD A, (DE) ; background
  44+ 5C6F D9           	EXX
  45+ 5C70 A2           	AND D
  46+ 5C71 B0           	OR B
  47+ 5C72 D9           	EXX
  48+ 5C73 12           	LD (DE), A
  49+ 5C74
  50+ 5C74 0A           	LD A, (BC)
  51+ 5C75 D9           	EXX
  52+ 5C76 A3           	AND E
  53+ 5C77 B1           	OR C
  54+ 5C78 23           	INC HL
  55+ 5C79 D9           	EXX
  56+ 5C7A 02           	LD (BC), A
  57+ 5C7B
  58+ 5C7B 23           	INC HL
  59+ 5C7C 13           	INC DE
  60+ 5C7D 03           	INC BC
  61+ 5C7E
  62+ 5C7E 08           	EX AF, AF'
  63+ 5C7F 3D           	DEC A
  64+ 5C80 C2 3F 5C     	JP NZ, SHIFT04
  65+ 5C83 C9           	RET
  66+ 5C84              ; *******************************************************************************************************
  67+ 5C84
  68+ 5C84              ; *******************************************************************************************************
  69+ 5C84              ; function rotates mask and data of several characters and applies to background data
  70+ 5C84              ; this handles x-shift from 5 to 8
  71+ 5C84              ; contains self-modifying code that is set-up from external function
  72+ 5C84              ; input HL=pointer to mask data
  73+ 5C84              ; input HL'=pointer to character data
  74+ 5C84              ; input DE=output buffer containing background data
  75+ 5C84              ; input BC=DE+8
  76+ 5C84              ; input A=number of characters to process
  77+ 5C84              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  78+ 5C84              SHIFT58:
  79+ 5C84 08           	EX AF, AF'
  80+ 5C85 7E           	LD A, (HL) ; get mask
  81+ 5C86 D9           	EXX
  82+ 5C87 57           	LD D, A
  83+ 5C88 1E FF        	LD E, #FF
  84+ 5C8A 37           	SCF
  85+ 5C8B              .M1:
  86+ 5C8B 18 FE        	JR .M1 ; this is self-modifying part
  87+ 5C8D CB 12        	RL D
  88+ 5C8F CB 13        	RL E
  89+ 5C91 CB 12        	RL D
  90+ 5C93 CB 13        	RL E
  91+ 5C95 CB 12        	RL D
  92+ 5C97 CB 13        	RL E
  93+ 5C99
  94+ 5C99 46           	LD B, (HL)
  95+ 5C9A 0E 00        	LD C, 0
  96+ 5C9C              .M2:
  97+ 5C9C 18 FE        	JR .M2 ; also self-modifying part
  98+ 5C9E CB 20        	SLA B
  99+ 5CA0 CB 11        	RL C
 100+ 5CA2 CB 20        	SLA B
 101+ 5CA4 CB 11        	RL C
 102+ 5CA6 CB 20        	SLA B
 103+ 5CA8 CB 11        	RL C
 104+ 5CAA
 105+ 5CAA D9           	EXX
 106+ 5CAB 1A           	LD A, (DE) ; background
 107+ 5CAC D9           	EXX
 108+ 5CAD A3           	AND E
 109+ 5CAE B1           	OR C
 110+ 5CAF D9           	EXX
 111+ 5CB0 12           	LD (DE), A
 112+ 5CB1
 113+ 5CB1 0A           	LD A, (BC)
 114+ 5CB2 D9           	EXX
 115+ 5CB3 A2           	AND D
 116+ 5CB4 B0           	OR B
 117+ 5CB5 23           	INC HL
 118+ 5CB6 D9           	EXX
 119+ 5CB7 02           	LD (BC), A
 120+ 5CB8
 121+ 5CB8 23           	INC HL
 122+ 5CB9 13           	INC DE
 123+ 5CBA 03           	INC BC
 124+ 5CBB
 125+ 5CBB 08           	EX AF, AF'
 126+ 5CBC 3D           	DEC A
 127+ 5CBD C2 84 5C     	JP NZ, SHIFT58
 128+ 5CC0 C9           	RET
 129+ 5CC1              ; *******************************************************************************************************
 130+ 5CC1
 131+ 5CC1              ; *******************************************************************************************************
 132+ 5CC1              ; routine that shifts one row of characters
 133+ 5CC1              ; contains self-modifying code that is set-up from external function
 134+ 5CC1              ; input HL=pointer to mask data
 135+ 5CC1              ; input HL'=pointer to character data
 136+ 5CC1              ; input DE=output buffer containing background data
 137+ 5CC1              ; input A=number of characters to process
 138+ 5CC1              ; input IX=pointer to structure describing input data
 139+ 5CC1              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 140+ 5CC1              SHIFT_ROW:
 141+ 5CC1 F5           	PUSH AF
 142+ 5CC2 ED 53 78 64  		LD (BLIT_TMP1), DE
 143+ 5CC6 E5           		PUSH HL
 144+ 5CC7 CD 0A 5D     			CALL .ADDYSHIFT
 145+ 5CCA E1           		POP HL
 146+ 5CCB ED 53 7A 64  		LD (BLIT_TMP2), DE ; DE+vertical shift
 147+ 5CCF              .L1:
 148+ 5CCF 3E 08        		LD A, 8
 149+ 5CD1 DD 96 02     		SUB (IX+2) ; y shift
 150+ 5CD4              .CALL1:
 151+ 5CD4 CD 00 00     		CALL 0
 152+ 5CD7 DD 7E 02     		LD A, (IX+2); y shift
 153+ 5CDA B7           		OR A
 154+ 5CDB 28 26        		JR Z, .DONE
 155+ 5CDD ED 5B 78 64  		LD DE, (BLIT_TMP1)
 156+ 5CE1 E5           		PUSH HL
 157+ 5CE2 CD 18 5D     			CALL .DETONEXTROW
 158+ 5CE5 E1           		POP HL
 159+ 5CE6              .CALL2:
 160+ 5CE6 CD 00 00     		CALL 0
 161+ 5CE9 ED 5B 78 64  		LD DE, (BLIT_TMP1)
 162+ 5CED E5           		PUSH HL
 163+ 5CEE CD 12 5D     			CALL .ADD8
 164+ 5CF1 E1           		POP HL
 165+ 5CF2 ED 53 78 64  		LD (BLIT_TMP1), DE
 166+ 5CF6 ED 5B 7A 64  		LD DE, (BLIT_TMP2)
 167+ 5CFA E5           		PUSH HL
 168+ 5CFB CD 12 5D     			CALL .ADD8
 169+ 5CFE E1           		POP HL
 170+ 5CFF ED 53 7A 64  		LD (BLIT_TMP2), DE ; DE+vertical shift
 171+ 5D03              .DONE:
 172+ 5D03 F1           	POP AF
 173+ 5D04 3D           	DEC A
 174+ 5D05 C8           	RET Z
 175+ 5D06 F5           	PUSH AF
 176+ 5D07 C3 CF 5C     	JP .L1
 177+ 5D0A              .ADDYSHIFT:
 178+ 5D0A EB           	EX DE, HL
 179+ 5D0B 16 00        	LD D, 0
 180+ 5D0D DD 5E 02     	LD E, (IX+2); y shift
 181+ 5D10 18 0C        	JR .MOVDEBC
 182+ 5D12              .ADD8:
 183+ 5D12 21 08 00     	LD HL, 8
 184+ 5D15 C3 1E 5D     	JP .MOVDEBC
 185+ 5D18              .DETONEXTROW:
 186+ 5D18 DD 6E 06     	LD L, (IX+6)
 187+ 5D1B DD 66 07     	LD H, (IX+7) ; bkg add to value
 188+ 5D1E              .MOVDEBC:
 189+ 5D1E 19           	ADD HL, DE
 190+ 5D1F 54           	LD D, H
 191+ 5D20 5D           	LD E, L
 192+ 5D21 01 08 00     	LD BC, 8
 193+ 5D24 09           	ADD HL, BC
 194+ 5D25 44           	LD B, H
 195+ 5D26 4D           	LD C, L
 196+ 5D27 C9           	RET
 197+ 5D28              ; *******************************************************************************************************
 198+ 5D28
 199+ 5D28              ; *******************************************************************************************************
 200+ 5D28              ; function rotates mask and character data and applies it to background
 201+ 5D28              ; input IX=pointer to structure describing input data
 202+ 5D28              ; +0  DW horizontal shift count 0-7 (low byte used)
 203+ 5D28              ; +2  DW vertical shift count 0-7 (low byte used)
 204+ 5D28              ; +4  DW background data start;
 205+ 5D28              ; +6  DW background add to value to next row of background data
 206+ 5D28              ; +8  DW mask data start;
 207+ 5D28              ; +10  DW character data start;
 208+ 5D28              ; +12 DW character&mask add to value to next row of data
 209+ 5D28              ; +14 DW columns (low byte used)
 210+ 5D28              ; +16 DW rows (low byte used)
 211+ 5D28              SHIFT_MERGE_CHARACTER:
 212+ 5D28 DD 7E 00     	LD A, (IX) ; shift
 213+ 5D2B FE 05        	CP 5
 214+ 5D2D 38 25        	JR C, .RIGHT
 215+ 5D2F              	; shifts 5-7, use rotate towards left 1-3
 216+ 5D2F 21 84 5C     	LD HL, SHIFT58
 217+ 5D32 22 D5 5C     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 218+ 5D35 22 E7 5C     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 219+ 5D38 D6 05        	SUB 5
 220+ 5D3A 28 0D        	JR Z, .L1
 221+ 5D3C 87           	ADD A, A
 222+ 5D3D 87           	ADD A, A
 223+ 5D3E 67           	LD H, A
 224+ 5D3F 2E 18        	LD L, #18 ; JR opcode
 225+ 5D41 22 8B 5C     	LD (SHIFT58.M1), HL
 226+ 5D44 22 9C 5C     	LD (SHIFT58.M2), HL
 227+ 5D47 18 32        	JR .DO
 228+ 5D49              .L1:
 229+ 5D49 21 00 00     	LD HL, 0 ; 2xNOP opcode
 230+ 5D4C 22 8B 5C     	LD (SHIFT58.M1), HL
 231+ 5D4F 22 9C 5C     	LD (SHIFT58.M2), HL
 232+ 5D52 18 27        	JR .DO
 233+ 5D54              .RIGHT:
 234+ 5D54              	; shifts 0-4, rotate towards right
 235+ 5D54 21 3F 5C     	LD HL, SHIFT04
 236+ 5D57 22 D5 5C     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 237+ 5D5A 22 E7 5C     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 238+ 5D5D FE 04        	CP 4
 239+ 5D5F 28 11        	JR Z, .R1
 240+ 5D61 D6 04        	SUB 4
 241+ 5D63 ED 44        	NEG
 242+ 5D65 87           	ADD A, A
 243+ 5D66 87           	ADD A, A
 244+ 5D67 67           	LD H, A
 245+ 5D68 2E 18        	LD L, #18 ; JR opcode
 246+ 5D6A 22 46 5C     	LD (SHIFT04.M1), HL
 247+ 5D6D 22 5B 5C     	LD (SHIFT04.M2), HL
 248+ 5D70 18 09        	JR .DO
 249+ 5D72              .R1:
 250+ 5D72 21 00 00     	LD HL, 0 ; 2xNOP opcode
 251+ 5D75 22 46 5C     	LD (SHIFT04.M1), HL
 252+ 5D78 22 5B 5C     	LD (SHIFT04.M2), HL
 253+ 5D7B              .DO:
 254+ 5D7B DD 46 10     	LD B, (IX+16) ; rows
 255+ 5D7E DD 6E 08     	LD L, (IX+8)
 256+ 5D81 DD 66 09     	LD H, (IX+9) ; mask data
 257+ 5D84 DD 5E 04     	LD E, (IX+4)
 258+ 5D87 DD 56 05     	LD D, (IX+5) ; background data
 259+ 5D8A D9           	EXX
 260+ 5D8B DD 6E 0A     	LD L, (IX+10)
 261+ 5D8E DD 66 0B     	LD H, (IX+11) ; character data
 262+ 5D91 D9           	EXX
 263+ 5D92              .LOOP:
 264+ 5D92 C5           	PUSH BC
 265+ 5D93 E5           		PUSH HL
 266+ 5D94 D5           			PUSH DE
 267+ 5D95 D9           				EXX
 268+ 5D96 E5           				PUSH HL
 269+ 5D97 D9           					EXX
 270+ 5D98 DD 7E 0E     					LD A, (IX+14) ; columns
 271+ 5D9B              .CALL:
 272+ 5D9B CD C1 5C     					CALL SHIFT_ROW
 273+ 5D9E E1           				POP HL
 274+ 5D9F DD 5E 0C     				LD E, (IX+12)
 275+ 5DA2 DD 56 0D     				LD D, (IX+13) ; char data to next row
 276+ 5DA5 19           				ADD HL, DE
 277+ 5DA6 D9           				EXX
 278+ 5DA7 E1           			POP HL
 279+ 5DA8 DD 5E 06     			LD E, (IX+6)
 280+ 5DAB DD 56 07     			LD D, (IX+7) ; background to next row
 281+ 5DAE 19           			ADD HL, DE
 282+ 5DAF EB           			EX DE, HL
 283+ 5DB0 E1           		POP HL
 284+ 5DB1 DD 4E 0C     		LD C, (IX+12)
 285+ 5DB4 DD 46 0D     		LD B, (IX+13) ; char data to next row
 286+ 5DB7 09           		ADD HL, BC
 287+ 5DB8 C1           	POP BC
 288+ 5DB9 10 D7        	DJNZ .LOOP
 289+ 5DBB C9           	RET
 290+ 5DBC              ; *******************************************************************************************************
 291+ 5DBC
 292+ 5DBC              ; *******************************************************************************************************
 293+ 5DBC              ; helper function DE \ 8
 294+ 5DBC              DEdiv8:
 295+ 5DBC 7B           	LD A,E
 296+ 5DBD CB 2A        	SRA D
 297+ 5DBF CB 1F            RR  A
 298+ 5DC1 CB 2A            SRA D
 299+ 5DC3 CB 1F            RR  A
 300+ 5DC5 CB 2A            SRA D
 301+ 5DC7 CB 1F            RR  A
 302+ 5DC9 C9           	RET
 303+ 5DCA              ; *******************************************************************************************************
 304+ 5DCA
 305+ 5DCA               IF (0 == 1)
 306+ 5DCA ~            ; *******************************************************************************************************
 307+ 5DCA ~            ; function to handle BLIT basic extension through DEFUSR call in RAW format
 308+ 5DCA ~            ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 309+ 5DCA ~            ; +2  DW horizontal shift count 0-7 (low byte used)
 310+ 5DCA ~            ; +4  DW vertical shift count 0-7 (low byte used)
 311+ 5DCA ~            ; +6  DW background data start;
 312+ 5DCA ~            ; +8  DW background add to value to next row of background data
 313+ 5DCA ~            ; +10  DW mask data start;
 314+ 5DCA ~            ; +12  DW character data start;
 315+ 5DCA ~            ; +14 DW character&mask add to value to next row of data
 316+ 5DCA ~            ; +16 DW columns (low byte used)
 317+ 5DCA ~            ; +18 DW rows (low byte used)
 318+ 5DCA ~            ; will put ram in page 0 also, page 1 is already there
 319+ 5DCA ~            ;BLIT_DEFUSR:
 320+ 5DCA ~            ;	DI
 321+ 5DCA ~            ;	LD IY, .RET
 322+ 5DCA ~            ;	JP ENABLE_PAGE0
 323+ 5DCA ~            ;.RET:
 324+ 5DCA ~            ;	EI
 325+ 5DCA ~            ;	INC IX
 326+ 5DCA ~            ;	INC IX
 327+ 5DCA ~            ;	CALL SHIFT_MERGE_CHARACTER
 328+ 5DCA ~            ;
 329+ 5DCA ~            ;   POP DE
 330+ 5DCA ~            ;    POP BC
 331+ 5DCA ~            ;    JP RESTORE_PAGE_INFO
 332+ 5DCA ~            ; *******************************************************************************************************
 333+ 5DCA ~
 334+ 5DCA ~            ; *******************************************************************************************************
 335+ 5DCA ~            ; function to handle CALL BLIT basic extension in DEFUSR form
 336+ 5DCA ~            ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 337+ 5DCA ~            ; +02 x
 338+ 5DCA ~            ; +04 y
 339+ 5DCA ~            ; +06 char_data_pointer
 340+ 5DCA ~            ; +08 mask_data_pointer
 341+ 5DCA ~            ; +10 width
 342+ 5DCA ~            ; +12 height
 343+ 5DCA ~            ; +14 background_pointer
 344+ 5DCA ~            ; +16 background_width
 345+ 5DCA ~            ; BLIT ( INT x,
 346+ 5DCA ~            ;		 INT y,
 347+ 5DCA ~            ;		 INT char_data_pointer,
 348+ 5DCA ~            ;		 INT mask_data_pointer,
 349+ 5DCA ~            ;		 INT width (in characters),
 350+ 5DCA ~            ;		 INT height (in characters),
 351+ 5DCA ~            ;		 INT background_pointer (top left),
 352+ 5DCA ~            ;		 INT background_width (in characters),
 353+ 5DCA ~            BLIT_DEFUSR:
 354+ 5DCA ~            	LD E,(IX+2)
 355+ 5DCA ~            	LD D,(IX+3)
 356+ 5DCA ~            	LD A,E
 357+ 5DCA ~            	AND 7
 358+ 5DCA ~            	LD (BLIT_STRUCT+0),A
 359+ 5DCA ~            	CALL DEdiv8
 360+ 5DCA ~            	LD (BLIT_TMP+0),A
 361+ 5DCA ~            	LD E,(IX+4)
 362+ 5DCA ~            	LD D,(IX+5)
 363+ 5DCA ~            	LD A,E
 364+ 5DCA ~            	AND 7
 365+ 5DCA ~            	LD (BLIT_STRUCT+2),A
 366+ 5DCA ~            	CALL DEdiv8
 367+ 5DCA ~            	LD (BLIT_TMP+1),A
 368+ 5DCA ~            	LD L,(IX+6)
 369+ 5DCA ~            	LD H,(IX+7)
 370+ 5DCA ~            	LD (BLIT_STRUCT+10),HL
 371+ 5DCA ~            	LD L,(IX+8)
 372+ 5DCA ~            	LD H,(IX+9)
 373+ 5DCA ~            	LD (BLIT_STRUCT+8),HL
 374+ 5DCA ~            	LD A,(IX+10)
 375+ 5DCA ~            	LD (BLIT_STRUCT+14),A
 376+ 5DCA ~            	LD A,(IX+12)
 377+ 5DCA ~            	LD (BLIT_STRUCT+16),A
 378+ 5DCA ~            	LD L,(IX+14)
 379+ 5DCA ~            	LD H,(IX+15)
 380+ 5DCA ~            	LD (BLIT_STRUCT+4),HL
 381+ 5DCA ~            	;LD A,(IX+16)
 382+ 5DCA ~            	;LD (BLIT_TMP+2),A
 383+ 5DCA ~
 384+ 5DCA ~            	; calculate char&mask add to value
 385+ 5DCA ~            	LD H,0
 386+ 5DCA ~            	LD A,(BLIT_STRUCT+14)
 387+ 5DCA ~            	LD L,A
 388+ 5DCA ~            	CALL HLx8
 389+ 5DCA ~            	LD (BLIT_STRUCT+12),HL
 390+ 5DCA ~            	; calculate background add to value
 391+ 5DCA ~            	LD H,0
 392+ 5DCA ~            	LD L,(IX+16)
 393+ 5DCA ~            	CALL HLx8
 394+ 5DCA ~            	LD (BLIT_STRUCT+6),HL
 395+ 5DCA ~            	; calculate pointer to background location
 396+ 5DCA ~            	LD HL,0
 397+ 5DCA ~            	LD A,(BLIT_TMP+1)
 398+ 5DCA ~            	OR A
 399+ 5DCA ~            	JR Z, .L1
 400+ 5DCA ~            	LD B,A
 401+ 5DCA ~            	LD DE,(BLIT_STRUCT+6)
 402+ 5DCA ~            .L0:
 403+ 5DCA ~            	ADD HL, DE
 404+ 5DCA ~            	DJNZ .L0
 405+ 5DCA ~            .L1:
 406+ 5DCA ~            	EX DE,HL
 407+ 5DCA ~            	LD H,0
 408+ 5DCA ~            	LD A,(BLIT_TMP+0)
 409+ 5DCA ~            	LD L,A
 410+ 5DCA ~            	CALL HLx8
 411+ 5DCA ~            	ADD HL,DE
 412+ 5DCA ~            	LD DE,(BLIT_STRUCT+4)
 413+ 5DCA ~            	ADD HL,DE
 414+ 5DCA ~            	LD (BLIT_STRUCT+4),HL
 415+ 5DCA ~
 416+ 5DCA ~            	LD IY, .RET
 417+ 5DCA ~            	JP ENABLE_PAGE0
 418+ 5DCA ~            .RET:
 419+ 5DCA ~            	EI
 420+ 5DCA ~            	LD IX, BLIT_STRUCT
 421+ 5DCA ~            	CALL SHIFT_MERGE_CHARACTER
 422+ 5DCA ~
 423+ 5DCA ~                POP DE
 424+ 5DCA ~                POP BC
 425+ 5DCA ~                CALL RESTORE_PAGE_INFO
 426+ 5DCA ~            	XOR A ; success
 427+ 5DCA ~            	RET
 428+ 5DCA ~            ; *******************************************************************************************************
 429+ 5DCA               ENDIF
 430+ 5DCA
 431+ 5DCA               IF (1 == 1)
 432+ 5DCA              ; *******************************************************************************************************
 433+ 5DCA              ; function to handle CALL BLIT basic extension
 434+ 5DCA              ; rotates 1-bit character drawing horizontally with mask and character data and
 435+ 5DCA              ; fuses with background data and applies vertical shift too
 436+ 5DCA              ; in form without pointers
 437+ 5DCA              ; BLIT ( INT x,
 438+ 5DCA              ;		 INT y,
 439+ 5DCA              ;		 INT char_data_pointer,
 440+ 5DCA              ;		 INT mask_data_pointer,
 441+ 5DCA              ;		 INT width (in characters),
 442+ 5DCA              ;		 INT height (in characters),
 443+ 5DCA              ;		 INT background_pointer (top left),
 444+ 5DCA              ;		 INT background_width (in characters),
 445+ 5DCA              ; will put ram in page 0 also, page 1 is already there
 446+ 5DCA              BLIT:
 447+ 5DCA              	; opening (
 448+ 5DCA CD A9 67     	CALL CHKCHAR
 449+ 5DCD 28           	DB '('
 450+ 5DCE              	; get x coordinate
 451+ 5DCE DD 21 2F 54  	LD IX, FRMQNT
 452+ 5DD2 CD 59 01     	CALL CALBAS
 453+ 5DD5 7B           	LD A, E
 454+ 5DD6 E6 07        	AND 7
 455+ 5DD8 32 7C 64     	LD (BLIT_STRUCT+0), A
 456+ 5DDB CD BC 5D     	CALL DEdiv8
 457+ 5DDE 32 78 64     	LD (BLIT_TMP+0),A
 458+ 5DE1              	; comma
 459+ 5DE1 CD A9 67     	CALL CHKCHAR
 460+ 5DE4 2C           	DB ','
 461+ 5DE5              	; get y coordinate
 462+ 5DE5 DD 21 2F 54  	LD IX, FRMQNT
 463+ 5DE9 CD 59 01     	CALL CALBAS
 464+ 5DEC 7B           	LD A, E
 465+ 5DED E6 07        	AND 7
 466+ 5DEF 32 7E 64     	LD (BLIT_STRUCT+2), A
 467+ 5DF2 CD BC 5D     	CALL DEdiv8
 468+ 5DF5 32 79 64     	LD (BLIT_TMP+1),A
 469+ 5DF8              	; comma
 470+ 5DF8 CD A9 67     	CALL CHKCHAR
 471+ 5DFB 2C           	DB ','
 472+ 5DFC              	; get char data pointer
 473+ 5DFC DD 21 2F 54  	LD IX, FRMQNT
 474+ 5E00 CD 59 01     	CALL CALBAS
 475+ 5E03 ED 53 86 64  	LD (BLIT_STRUCT+10), DE
 476+ 5E07              	; comma
 477+ 5E07 CD A9 67     	CALL CHKCHAR
 478+ 5E0A 2C           	DB ','
 479+ 5E0B              	; get mask data pointer
 480+ 5E0B DD 21 2F 54  	LD IX, FRMQNT
 481+ 5E0F CD 59 01     	CALL CALBAS
 482+ 5E12 ED 53 84 64  	LD (BLIT_STRUCT+8), DE
 483+ 5E16              	; comma
 484+ 5E16 CD A9 67     	CALL CHKCHAR
 485+ 5E19 2C           	DB ','
 486+ 5E1A              	; get width
 487+ 5E1A DD 21 2F 54  	LD IX, FRMQNT
 488+ 5E1E CD 59 01     	CALL CALBAS
 489+ 5E21 7B           	LD A, E
 490+ 5E22 32 8A 64     	LD (BLIT_STRUCT+14), A
 491+ 5E25              	; comma
 492+ 5E25 CD A9 67     	CALL CHKCHAR
 493+ 5E28 2C           	DB ','
 494+ 5E29              	; get height
 495+ 5E29 DD 21 2F 54  	LD IX, FRMQNT
 496+ 5E2D CD 59 01     	CALL CALBAS
 497+ 5E30 7B           	LD A, E
 498+ 5E31 32 8C 64     	LD (BLIT_STRUCT+16), A
 499+ 5E34              	; comma
 500+ 5E34 CD A9 67     	CALL CHKCHAR
 501+ 5E37 2C           	DB ','
 502+ 5E38              	; get background pointer
 503+ 5E38 DD 21 2F 54  	LD IX, FRMQNT
 504+ 5E3C CD 59 01     	CALL CALBAS
 505+ 5E3F ED 53 80 64  	LD (BLIT_STRUCT+4), DE
 506+ 5E43              	; comma
 507+ 5E43 CD A9 67     	CALL CHKCHAR
 508+ 5E46 2C           	DB ','
 509+ 5E47              	; get background width
 510+ 5E47 DD 21 2F 54  	LD IX, FRMQNT
 511+ 5E4B CD 59 01     	CALL CALBAS
 512+ 5E4E 7B           	LD A, E
 513+ 5E4F 32 7A 64     	LD (BLIT_TMP+2), A
 514+ 5E52              	; ending )
 515+ 5E52 CD A9 67     	CALL CHKCHAR
 516+ 5E55 29           	DB ')'
 517+ 5E56
 518+ 5E56 E5           	PUSH HL ; save position in BASIC buffer
 519+ 5E57
 520+ 5E57              	; calculate char&mask add to value
 521+ 5E57 26 00        	LD H, 0
 522+ 5E59 3A 8A 64     	LD A, (BLIT_STRUCT+14)
 523+ 5E5C 6F           	LD L, A
 524+ 5E5D CD 96 66     	CALL HLx8
 525+ 5E60 22 88 64     	LD (BLIT_STRUCT+12), HL
 526+ 5E63              	; calculate background add to value
 527+ 5E63 26 00        	LD H, 0
 528+ 5E65 3A 7A 64     	LD A, (BLIT_TMP+2)
 529+ 5E68 6F           	LD L, A
 530+ 5E69 CD 96 66     	CALL HLx8
 531+ 5E6C 22 82 64     	LD (BLIT_STRUCT+6), HL
 532+ 5E6F              	; calculate pointer to background location
 533+ 5E6F 21 00 00     	LD HL, 0
 534+ 5E72 3A 79 64     	LD A,(BLIT_TMP+1)
 535+ 5E75 B7           	OR A
 536+ 5E76 28 08        	JR Z, .L1
 537+ 5E78 47           	LD B,A
 538+ 5E79 ED 5B 82 64  	LD DE,(BLIT_STRUCT+6)
 539+ 5E7D              .L0:
 540+ 5E7D 19           	ADD HL, DE
 541+ 5E7E 10 FD        	DJNZ .L0
 542+ 5E80              .L1:
 543+ 5E80 EB           	EX DE,HL
 544+ 5E81 26 00        	LD H,0
 545+ 5E83 3A 78 64     	LD A,(BLIT_TMP+0)
 546+ 5E86 6F           	LD L,A
 547+ 5E87 CD 96 66     	CALL HLx8
 548+ 5E8A 19           	ADD HL,DE
 549+ 5E8B ED 5B 80 64  	LD DE,(BLIT_STRUCT+4)
 550+ 5E8F 19           	ADD HL,DE
 551+ 5E90 22 80 64     	LD (BLIT_STRUCT+4),HL
 552+ 5E93
 553+ 5E93 FD 21 9A 5E  	LD IY, .RET
 554+ 5E97 C3 5A 67     	JP ENABLE_PAGE0
 555+ 5E9A              .RET:
 556+ 5E9A FB           	EI
 557+ 5E9B DD 21 7C 64  	LD IX, BLIT_STRUCT
 558+ 5E9F CD 28 5D     	CALL SHIFT_MERGE_CHARACTER
 559+ 5EA2
 560+ 5EA2 D1               POP DE
 561+ 5EA3 C1               POP BC
 562+ 5EA4 CD D1 66         CALL RESTORE_PAGE_INFO
 563+ 5EA7
 564+ 5EA7 E1           	POP HL
 565+ 5EA8 C9           	RET
 566+ 5EA9              ; *******************************************************************************************************
 567+ 5EA9               ENDIF
# file closed: asm\BLIT.asm
 164  5EA9               ENDIF
 165  5EA9
 166  5EA9               IF (TILE_CMDS == 1)
 167  5EA9               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
   1+ 5EA9              ; *******************************************************************************************************
   2+ 5EA9              ; generic function to implement tiling
   3+ 5EA9              ; should be modified to call appropriate function for memory or vram
   4+ 5EA9              ; input IX=pointer to following structure
   5+ 5EA9              ; +00 tile_data_ptr
   6+ 5EA9              ; +02 tile_rows
   7+ 5EA9              ; +04 tile_columns
   8+ 5EA9              ; +06 destination_address
   9+ 5EA9              ; +08 dest_to_next_row_add_to_value
  10+ 5EA9              ; +10 num_horizontal_tiles
  11+ 5EA9              ; +12 num_vertical_tiles
  12+ 5EA9              ; modifies AF, BC, DE, HL
  13+ 5EA9              TILE:
  14+ 5EA9 DD 6E 06     	LD L, (IX+6)
  15+ 5EAC DD 66 07     	LD H, (IX+7) ; destination address
  16+ 5EAF 22 78 64     	LD (TILETMP1), HL
  17+ 5EB2 DD 46 0C     	LD B, (IX+12) ; vertical tile number
  18+ 5EB5              .L1:
  19+ 5EB5 C5           	PUSH BC
  20+ 5EB6 DD 6E 00     		LD L, (IX+0)
  21+ 5EB9 DD 66 01     		LD H, (IX+1) ; tile address
  22+ 5EBC 22 7A 64     		LD (TILETMP2), HL
  23+ 5EBF DD 46 02     		LD B, (IX+2) ; tile rows
  24+ 5EC2              .L2:
  25+ 5EC2 C5           		PUSH BC
  26+ 5EC3 CD 00 00     .CALL1:		CALL 0
  27+ 5EC6 DD 46 0A     			LD B, (IX+10) ; horizontal tile num
  28+ 5EC9              .L3:
  29+ 5EC9 C5           			PUSH BC
  30+ 5ECA 2A 7A 64     				LD HL, (TILETMP2)
  31+ 5ECD DD 46 04     				LD B, (IX+4) ; tile columns
  32+ 5ED0              .L4:
  33+ 5ED0 C5           				PUSH BC
  34+ 5ED1              .CALL2:
  35+ 5ED1 CD 00 00     					CALL 0
  36+ 5ED4 C1           				POP BC
  37+ 5ED5 10 F9        				DJNZ .L4
  38+ 5ED7 C1           			POP BC
  39+ 5ED8 10 EF        			DJNZ .L3
  40+ 5EDA 22 7A 64     			LD (TILETMP2), HL
  41+ 5EDD 2A 78 64     			LD HL, (TILETMP1)
  42+ 5EE0 DD 5E 08     			LD E, (IX+8)
  43+ 5EE3 DD 56 09     			LD D, (IX+9) ; add to value for dest next row
  44+ 5EE6 19           			ADD HL, DE
  45+ 5EE7 22 78 64     			LD (TILETMP1), HL
  46+ 5EEA C1           		POP BC
  47+ 5EEB 10 D5        		DJNZ .L2
  48+ 5EED C1           	POP BC
  49+ 5EEE 10 C5        	DJNZ .L1
  50+ 5EF0 C9           	RET
  51+ 5EF1              ; *******************************************************************************************************
  52+ 5EF1
  53+ 5EF1               IF (0 == 1)
  54+ 5EF1 ~            ; *******************************************************************************************************
  55+ 5EF1 ~            ; same as TILERAM but for DEFUSR approach
  56+ 5EF1 ~            ; input IX=pointer to input array, real data from +2
  57+ 5EF1 ~            ; +02 = tile data pointer
  58+ 5EF1 ~            ; +04 = tile columns
  59+ 5EF1 ~            ; +06 = tile rows
  60+ 5EF1 ~            ; +08 = destination pointer
  61+ 5EF1 ~            ; +10 = destination columns
  62+ 5EF1 ~            ; +12 = destination rows
  63+ 5EF1 ~            ; +14 = destination begin column
  64+ 5EF1 ~            ; +16 = destination begin row
  65+ 5EF1 ~            ; +18 = number of tiles horizontally
  66+ 5EF1 ~            ; +20 = number of tiles vertically
  67+ 5EF1 ~            ; *******************************************************************************************************
  68+ 5EF1 ~            TILERAM_DEFUSR:
  69+ 5EF1 ~            	; tile data pointer
  70+ 5EF1 ~            	LD L,(IX+2)
  71+ 5EF1 ~            	LD H,(IX+3)
  72+ 5EF1 ~            	LD (BLIT_STRUCT+0),HL
  73+ 5EF1 ~            	; tile columns
  74+ 5EF1 ~            	LD L,(IX+4)
  75+ 5EF1 ~            	LD H,(IX+5)
  76+ 5EF1 ~            	LD (BLIT_STRUCT+4),HL
  77+ 5EF1 ~            	; tile rows
  78+ 5EF1 ~            	LD L,(IX+6)
  79+ 5EF1 ~            	LD H,(IX+7)
  80+ 5EF1 ~            	LD (BLIT_STRUCT+2),HL
  81+ 5EF1 ~            	; destintion pointer
  82+ 5EF1 ~            	LD L,(IX+8)
  83+ 5EF1 ~            	LD H,(IX+9)
  84+ 5EF1 ~            	LD (BLIT_STRUCT+6),HL
  85+ 5EF1 ~            	; destination columns
  86+ 5EF1 ~            	LD A,(IX+10)
  87+ 5EF1 ~            	LD (BLIT_TMP+0),A
  88+ 5EF1 ~            	; destination rows
  89+ 5EF1 ~            	LD A,(IX+12)
  90+ 5EF1 ~            	LD (BLIT_TMP+1),A
  91+ 5EF1 ~            	; destination begin column
  92+ 5EF1 ~            	LD A,(IX+14)
  93+ 5EF1 ~            	LD (BLIT_TMP+2),A
  94+ 5EF1 ~            	; destination begin row
  95+ 5EF1 ~            	LD A,(IX+16)
  96+ 5EF1 ~            	LD (BLIT_TMP+3),A
  97+ 5EF1 ~            	; number of tiles horizontally
  98+ 5EF1 ~            	LD L,(IX+18)
  99+ 5EF1 ~            	LD H,(IX+19)
 100+ 5EF1 ~            	LD (BLIT_STRUCT+10),HL
 101+ 5EF1 ~            	; number of tiles vertically
 102+ 5EF1 ~            	LD L,(IX+20)
 103+ 5EF1 ~            	LD H,(IX+21)
 104+ 5EF1 ~            	LD (BLIT_STRUCT+12),HL
 105+ 5EF1 ~             IF (BASIC_EXTENSION == 1) ; otherwise we just continue with code below
 106+ 5EF1 ~            	JP TILERAM.COMMON
 107+ 5EF1 ~             ENDIF
 108+ 5EF1               ENDIF
 109+ 5EF1
 110+ 5EF1              ; *******************************************************************************************************
 111+ 5EF1              ; function to handle CALL TILERAM basic extension
 112+ 5EF1              ; fills memory with tiles
 113+ 5EF1              ; TILERAM ( INT tile_data_pointer,
 114+ 5EF1              ;			INT tile_columns,
 115+ 5EF1              ;			INT tile_rows,
 116+ 5EF1              ;			INT destination_pointer,
 117+ 5EF1              ;			INT destination_columns,
 118+ 5EF1              ;			INT destination_rows,
 119+ 5EF1              ;			INT destination_begin_column,
 120+ 5EF1              ;			INT destination_begin_row,
 121+ 5EF1              ;			INT number_of_tiles_horizontally,
 122+ 5EF1              ;			INT	number_of_tiles_vertically )
 123+ 5EF1              ; will put ram in page 0 also, page 1 is already there
 124+ 5EF1              TILERAM:
 125+ 5EF1               IF (1 == 1)
 126+ 5EF1              	; opening (
 127+ 5EF1 CD A9 67     	CALL CHKCHAR
 128+ 5EF4 28           	DB '('
 129+ 5EF5              	; get tile data pointer coordinate
 130+ 5EF5 DD 21 2F 54  	LD IX, FRMQNT
 131+ 5EF9 CD 59 01     	CALL CALBAS
 132+ 5EFC ED 53 7C 64  	LD (BLIT_STRUCT+0), DE
 133+ 5F00              	; comma
 134+ 5F00 CD A9 67     	CALL CHKCHAR
 135+ 5F03 2C           	DB ','
 136+ 5F04              	; get tile columns
 137+ 5F04 DD 21 2F 54  	LD IX, FRMQNT
 138+ 5F08 CD 59 01     	CALL CALBAS
 139+ 5F0B ED 53 80 64  	LD (BLIT_STRUCT+4), DE
 140+ 5F0F              	; comma
 141+ 5F0F CD A9 67     	CALL CHKCHAR
 142+ 5F12 2C           	DB ','
 143+ 5F13              	; get tile columns
 144+ 5F13 DD 21 2F 54  	LD IX, FRMQNT
 145+ 5F17 CD 59 01     	CALL CALBAS
 146+ 5F1A ED 53 7E 64  	LD (BLIT_STRUCT+2), DE
 147+ 5F1E              	; comma
 148+ 5F1E CD A9 67     	CALL CHKCHAR
 149+ 5F21 2C           	DB ','
 150+ 5F22              	; get destintion pointer
 151+ 5F22 DD 21 2F 54  	LD IX, FRMQNT
 152+ 5F26 CD 59 01     	CALL CALBAS
 153+ 5F29 ED 53 82 64  	LD (BLIT_STRUCT+6), DE
 154+ 5F2D              	; comma
 155+ 5F2D CD A9 67     	CALL CHKCHAR
 156+ 5F30 2C           	DB ','
 157+ 5F31              	; get destination columns
 158+ 5F31 DD 21 2F 54  	LD IX, FRMQNT
 159+ 5F35 CD 59 01     	CALL CALBAS
 160+ 5F38 7B           	LD A, E
 161+ 5F39 32 78 64     	LD (BLIT_TMP+0), A
 162+ 5F3C              	; comma
 163+ 5F3C CD A9 67     	CALL CHKCHAR
 164+ 5F3F 2C           	DB ','
 165+ 5F40              	; get destination rows
 166+ 5F40 DD 21 2F 54  	LD IX, FRMQNT
 167+ 5F44 CD 59 01     	CALL CALBAS
 168+ 5F47 7B           	LD A, E
 169+ 5F48 32 79 64     	LD (BLIT_TMP+1), A
 170+ 5F4B              	; comma
 171+ 5F4B CD A9 67     	CALL CHKCHAR
 172+ 5F4E 2C           	DB ','
 173+ 5F4F              	; get destination begin column
 174+ 5F4F DD 21 2F 54  	LD IX, FRMQNT
 175+ 5F53 CD 59 01     	CALL CALBAS
 176+ 5F56 7B           	LD A, E
 177+ 5F57 32 7A 64     	LD (BLIT_TMP+2), A
 178+ 5F5A              	; comma
 179+ 5F5A CD A9 67     	CALL CHKCHAR
 180+ 5F5D 2C           	DB ','
 181+ 5F5E              	; get destination begin row
 182+ 5F5E DD 21 2F 54  	LD IX, FRMQNT
 183+ 5F62 CD 59 01     	CALL CALBAS
 184+ 5F65 7B           	LD A, E
 185+ 5F66 32 7B 64     	LD (BLIT_TMP+3), A
 186+ 5F69              	; comma
 187+ 5F69 CD A9 67     	CALL CHKCHAR
 188+ 5F6C 2C           	DB ','
 189+ 5F6D              	; get number of tiles horizontally
 190+ 5F6D DD 21 2F 54  	LD IX, FRMQNT
 191+ 5F71 CD 59 01     	CALL CALBAS
 192+ 5F74 ED 53 86 64  	LD (BLIT_STRUCT+10), DE
 193+ 5F78              	; comma
 194+ 5F78 CD A9 67     	CALL CHKCHAR
 195+ 5F7B 2C           	DB ','
 196+ 5F7C              	; get number of tiles vertically
 197+ 5F7C DD 21 2F 54  	LD IX, FRMQNT
 198+ 5F80 CD 59 01     	CALL CALBAS
 199+ 5F83 ED 53 88 64  	LD (BLIT_STRUCT+12), DE
 200+ 5F87              	; ending )
 201+ 5F87 CD A9 67     	CALL CHKCHAR
 202+ 5F8A 29           	DB ')'
 203+ 5F8B               ENDIF
 204+ 5F8B              .COMMON:
 205+ 5F8B E5           	PUSH HL ; save position in BASIC buffer
 206+ 5F8C
 207+ 5F8C              	; calculate destination add to value
 208+ 5F8C 26 00        	LD H, 0
 209+ 5F8E 3A 78 64     	LD A, (BLIT_TMP+0)
 210+ 5F91 6F           	LD L, A
 211+ 5F92 CD 96 66     	CALL HLx8
 212+ 5F95 22 84 64     	LD (BLIT_STRUCT+8), HL
 213+ 5F98              	; calculate pointer to background location
 214+ 5F98 21 00 00     	LD HL, 0
 215+ 5F9B 3A 7B 64     	LD A,(BLIT_TMP+3)
 216+ 5F9E B7           	OR A
 217+ 5F9F 28 08        	JR Z, .L1
 218+ 5FA1 47           	LD B,A
 219+ 5FA2 ED 5B 84 64  	LD DE,(BLIT_STRUCT+8)
 220+ 5FA6              .L0:
 221+ 5FA6 19           	ADD HL, DE
 222+ 5FA7 10 FD        	DJNZ .L0
 223+ 5FA9              .L1:
 224+ 5FA9 EB           	EX DE,HL
 225+ 5FAA 26 00        	LD H,0
 226+ 5FAC 3A 7A 64     	LD A,(BLIT_TMP+2)
 227+ 5FAF 6F           	LD L,A
 228+ 5FB0 CD 96 66     	CALL HLx8
 229+ 5FB3 19           	ADD HL,DE
 230+ 5FB4 ED 5B 82 64  	LD DE,(BLIT_STRUCT+6)
 231+ 5FB8 19           	ADD HL,DE
 232+ 5FB9 22 82 64     	LD (BLIT_STRUCT+6),HL
 233+ 5FBC FD 21 C3 5F  	LD IY, .RET
 234+ 5FC0 C3 5A 67     	JP ENABLE_PAGE0
 235+ 5FC3              .RET:
 236+ 5FC3 FB           	EI
 237+ 5FC4              	; set RAM functions to call
 238+ 5FC4 21 DF 5F     	LD HL, .TILECOPY
 239+ 5FC7 22 D2 5E     	LD (TILE.CALL2+1), HL
 240+ 5FCA 21 F0 5F     	LD HL, .SETDESTROW
 241+ 5FCD 22 C4 5E     	LD (TILE.CALL1+1), HL
 242+ 5FD0 DD 21 7C 64  	LD IX,BLIT_STRUCT
 243+ 5FD4 CD A9 5E     	CALL TILE
 244+ 5FD7
 245+ 5FD7 D1               POP DE
 246+ 5FD8 C1               POP BC
 247+ 5FD9 CD D1 66         CALL RESTORE_PAGE_INFO
 248+ 5FDC
 249+ 5FDC E1           	POP HL
 250+ 5FDD AF           	XOR A ; success
 251+ 5FDE C9           	RET
 252+ 5FDF              .TILECOPY:
 253+ 5FDF ED A0       > LDI
 253+ 5FE1 ED A0       > LDI
 253+ 5FE3 ED A0       > LDI
 253+ 5FE5 ED A0       > LDI
 253+ 5FE7 ED A0       > LDI
 253+ 5FE9 ED A0       > LDI
 253+ 5FEB ED A0       > LDI
 253+ 5FED ED A0       > LDI
 254+ 5FEF C9           	RET
 255+ 5FF0              .SETDESTROW:
 256+ 5FF0 ED 5B 78 64  	LD DE, (TILETMP1)
 257+ 5FF4 C9           	RET
 258+ 5FF5              ; *******************************************************************************************************
 259+ 5FF5
 260+ 5FF5               IF (0 == 1)
 261+ 5FF5 ~            ; *******************************************************************************************************
 262+ 5FF5 ~            ; same as TILEVRM but for DEFUSR approach
 263+ 5FF5 ~            ; input IX=pointer to input array, real data from +2
 264+ 5FF5 ~            ; +02 = tile data pointer
 265+ 5FF5 ~            ; +04 = tile columns
 266+ 5FF5 ~            ; +06 = tile rows
 267+ 5FF5 ~            ; +08 = destination begin column
 268+ 5FF5 ~            ; +10 = destination begin row
 269+ 5FF5 ~            ; +12 = number of tiles horizontally
 270+ 5FF5 ~            ; +14 = number of tiles vertically
 271+ 5FF5 ~            ; *******************************************************************************************************
 272+ 5FF5 ~            TILEVRM_DEFUSR:
 273+ 5FF5 ~            	; tile data pointer
 274+ 5FF5 ~            	LD L,(IX+2)
 275+ 5FF5 ~            	LD H,(IX+3)
 276+ 5FF5 ~            	LD (BLIT_STRUCT+0),HL
 277+ 5FF5 ~            	; tile columns
 278+ 5FF5 ~            	LD L,(IX+4)
 279+ 5FF5 ~            	LD H,(IX+5)
 280+ 5FF5 ~            	LD (BLIT_STRUCT+4),HL
 281+ 5FF5 ~            	; tile rows
 282+ 5FF5 ~            	LD L,(IX+6)
 283+ 5FF5 ~            	LD H,(IX+7)
 284+ 5FF5 ~            	LD (BLIT_STRUCT+2),HL
 285+ 5FF5 ~            	; destination begin column
 286+ 5FF5 ~            	LD A,(IX+8)
 287+ 5FF5 ~            	LD (BLIT_TMP+2),A
 288+ 5FF5 ~            	; destination begin row
 289+ 5FF5 ~            	LD A,(IX+10)
 290+ 5FF5 ~            	LD (BLIT_TMP+3),A
 291+ 5FF5 ~            	; number of tiles horizontally
 292+ 5FF5 ~            	LD L,(IX+12)
 293+ 5FF5 ~            	LD H,(IX+13)
 294+ 5FF5 ~            	LD (BLIT_STRUCT+10),HL
 295+ 5FF5 ~            	; number of tiles vertically
 296+ 5FF5 ~            	LD L,(IX+14)
 297+ 5FF5 ~            	LD H,(IX+15)
 298+ 5FF5 ~            	LD (BLIT_STRUCT+12),HL
 299+ 5FF5 ~             IF (BASIC_EXTENSION == 1) ; otherwise we just continue with code below
 300+ 5FF5 ~            	JP TILEVRM.COMMON
 301+ 5FF5 ~             ENDIF
 302+ 5FF5               ENDIF
 303+ 5FF5
 304+ 5FF5              ; *******************************************************************************************************
 305+ 5FF5              ; function to handle CALL TILEVRM basic extension
 306+ 5FF5              ; fills vram with tiles
 307+ 5FF5              ; TILEVRM ( INT tile_data_pointer,
 308+ 5FF5              ;			INT tile_columns,
 309+ 5FF5              ;			INT tile_rows,
 310+ 5FF5              ;			INT destination_begin_column,
 311+ 5FF5              ;			INT destination_begin_row,
 312+ 5FF5              ;			INT number_of_tiles_horizontally,
 313+ 5FF5              ;			INT	number_of_tiles_vertically )
 314+ 5FF5              ; will put ram in page 0 also, page 1 is already there
 315+ 5FF5              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
 316+ 5FF5              TILEVRM:
 317+ 5FF5               IF (1 == 1)
 318+ 5FF5              	; opening (
 319+ 5FF5 CD A9 67     	CALL CHKCHAR
 320+ 5FF8 28           	DB '('
 321+ 5FF9              	; get tile data pointer coordinate
 322+ 5FF9 DD 21 2F 54  	LD IX, FRMQNT
 323+ 5FFD CD 59 01     	CALL CALBAS
 324+ 6000 ED 53 7C 64  	LD (BLIT_STRUCT+0), DE
 325+ 6004              	; comma
 326+ 6004 CD A9 67     	CALL CHKCHAR
 327+ 6007 2C           	DB ','
 328+ 6008              	; get tile columns
 329+ 6008 DD 21 2F 54  	LD IX, FRMQNT
 330+ 600C CD 59 01     	CALL CALBAS
 331+ 600F ED 53 80 64  	LD (BLIT_STRUCT+4), DE
 332+ 6013              	; comma
 333+ 6013 CD A9 67     	CALL CHKCHAR
 334+ 6016 2C           	DB ','
 335+ 6017              	; get tile columns
 336+ 6017 DD 21 2F 54  	LD IX, FRMQNT
 337+ 601B CD 59 01     	CALL CALBAS
 338+ 601E ED 53 7E 64  	LD (BLIT_STRUCT+2), DE
 339+ 6022              	; comma
 340+ 6022 CD A9 67     	CALL CHKCHAR
 341+ 6025 2C           	DB ','
 342+ 6026              	; get destination begin column
 343+ 6026 DD 21 2F 54  	LD IX, FRMQNT
 344+ 602A CD 59 01     	CALL CALBAS
 345+ 602D 7B           	LD A, E
 346+ 602E 32 7A 64     	LD (BLIT_TMP+2), A
 347+ 6031              	; comma
 348+ 6031 CD A9 67     	CALL CHKCHAR
 349+ 6034 2C           	DB ','
 350+ 6035              	; get destination begin row
 351+ 6035 DD 21 2F 54  	LD IX, FRMQNT
 352+ 6039 CD 59 01     	CALL CALBAS
 353+ 603C 7B           	LD A, E
 354+ 603D 32 7B 64     	LD (BLIT_TMP+3), A
 355+ 6040              	; comma
 356+ 6040 CD A9 67     	CALL CHKCHAR
 357+ 6043 2C           	DB ','
 358+ 6044              	; get number of tiles horizontally
 359+ 6044 DD 21 2F 54  	LD IX, FRMQNT
 360+ 6048 CD 59 01     	CALL CALBAS
 361+ 604B ED 53 86 64  	LD (BLIT_STRUCT+10), DE
 362+ 604F              	; comma
 363+ 604F CD A9 67     	CALL CHKCHAR
 364+ 6052 2C           	DB ','
 365+ 6053              	; get number of tiles vertically
 366+ 6053 DD 21 2F 54  	LD IX, FRMQNT
 367+ 6057 CD 59 01     	CALL CALBAS
 368+ 605A ED 53 88 64  	LD (BLIT_STRUCT+12), DE
 369+ 605E              	; ending )
 370+ 605E CD A9 67     	CALL CHKCHAR
 371+ 6061 29           	DB ')'
 372+ 6062               ENDIF
 373+ 6062
 374+ 6062              .COMMON:
 375+ 6062 E5           	PUSH HL ; save position in BASIC buffer
 376+ 6063
 377+ 6063              	; calculate destination add to value
 378+ 6063 21 00 01     	LD HL, 256
 379+ 6066 22 84 64     	LD (BLIT_STRUCT+8), HL
 380+ 6069              	; calculate pointer to background location
 381+ 6069 3A 7B 64     	LD A,(BLIT_TMP+3)
 382+ 606C 67           	LD H,A
 383+ 606D 2E 00        	LD L,0
 384+ 606F EB           	EX DE,HL
 385+ 6070 26 00        	LD H,0
 386+ 6072 3A 7A 64     	LD A,(BLIT_TMP+2)
 387+ 6075 6F           	LD L,A
 388+ 6076 CD 96 66     	CALL HLx8
 389+ 6079 19           	ADD HL,DE
 390+ 607A ED 5B CB F3  	LD DE,(GRPCGP)
 391+ 607E 19           	ADD HL,DE
 392+ 607F 22 82 64     	LD (BLIT_STRUCT+6),HL
 393+ 6082 FD 21 89 60  	LD IY, .RET
 394+ 6086 C3 5A 67     	JP ENABLE_PAGE0
 395+ 6089              .RET:
 396+ 6089 FB           	EI
 397+ 608A              	; set RAM functions to call
 398+ 608A 21 A5 60     	LD HL, .TILECOPY
 399+ 608D 22 D2 5E     	LD (TILE.CALL2+1), HL
 400+ 6090 21 AB 60     	LD HL, .SETDESTROW
 401+ 6093 22 C4 5E     	LD (TILE.CALL1+1), HL
 402+ 6096 DD 21 7C 64  	LD IX,BLIT_STRUCT
 403+ 609A CD A9 5E     	CALL TILE
 404+ 609D
 405+ 609D D1               POP DE
 406+ 609E C1               POP BC
 407+ 609F CD D1 66         CALL RESTORE_PAGE_INFO
 408+ 60A2
 409+ 60A2 E1           	POP HL
 410+ 60A3 AF           	XOR A ; success
 411+ 60A4 C9           	RET
 412+ 60A5              .TILECOPY:
 413+ 60A5 01 98 08     	LD BC, #0898
 414+ 60A8 C3 8E 66     	JP BBYTECOPY_NO_C
 415+ 60AB              .SETDESTROW:
 416+ 60AB 2A 78 64     	LD HL, (TILETMP1)
 417+ 60AE F3           	DI
 418+ 60AF CD 77 66     	CALL SETWRT_LOCAL_WRITE
 419+ 60B2 FB           	EI
 420+ 60B3 C9           	RET
 421+ 60B4              ; *******************************************************************************************************
 422+ 60B4
# file closed: asm\TILE.asm
 168  60B4               ENDIF
 169  60B4
 170  60B4               IF (COLL_CMD == 1)
 171  60B4               INCLUDE "COLLISION.asm"
# file opened: asm\COLLISION.asm
   1+ 60B4              ; generic collision checking routines
   2+ 60B4              ; in BASIC we use rectangle structure array DIM R%(7,n) of the format
   3+ 60B4              ; R%(0,n) is active flag, <>0 active / 0 skipped in checks
   4+ 60B4              ; R%(1,n) is either upper left x coordinate or sprite id (0-31) depending on R(7,n)
   5+ 60B4              ; R%(2,n) is either upper left y coordinate or unused depending on R(7,n)
   6+ 60B4              ; R%(3,n) x offset where rectangle begins
   7+ 60B4              ; R%(4,n) y offset where rectangle begins
   8+ 60B4              ; R%(5,n) is width
   9+ 60B4              ; R%(6,n) is height
  10+ 60B4              ; R%(7,0) is type, 0=generic where R%(1,0) contains x coordinate
  11+ 60B4              ;                  <>0 sprite where R%(1,0) contains sprite id
  12+ 60B4              ; for type sprite, upper left coordinates are taken from sprite attribute array
  13+ 60B4
  14+ 60B4              ; ************************************************************************************************
  15+ 60B4              ; quick test if HL<=DE<=HL+BC
  16+ 60B4              ; input BC=width, DE=x, HL=min
  17+ 60B4              ; if not true flag C set
  18+ 60B4              ; modifies AF
  19+ 60B4              GENERIC_INNER_CHECK:
  20+ 60B4 E5               PUSH HL
  21+ 60B5 D5               PUSH DE
  22+ 60B6 EB               EX DE,HL
  23+ 60B7 A7               AND A
  24+ 60B8 ED 52            SBC HL, DE
  25+ 60BA FA C8 60         JP M, .GENERIC_INNER_CHECK_NOT
  26+ 60BD A7               AND A
  27+ 60BE ED 42            SBC HL, BC
  28+ 60C0 28 03            JR Z, .L2
  29+ 60C2 F2 C8 60         JP P, .GENERIC_INNER_CHECK_NOT
  30+ 60C5              .L2:
  31+ 60C5 A7               AND A
  32+ 60C6 18 01            JR .EXIT
  33+ 60C8              .GENERIC_INNER_CHECK_NOT:
  34+ 60C8 37               SCF
  35+ 60C9              .EXIT:
  36+ 60C9 D1               POP DE
  37+ 60CA E1               POP HL
  38+ 60CB C9               RET
  39+ 60CC              ; ************************************************************************************************
  40+ 60CC
  41+ 60CC              ; ************************************************************************************************
  42+ 60CC              ; function to check if rectangles are overlapping
  43+ 60CC              ; input IX=IY=pointer to struct
  44+ 60CC              ;  +00 active flag
  45+ 60CC              ;  +02 x coordinate
  46+ 60CC              ;  +04 y coordinate
  47+ 60CC              ;  +06 x offset where rectangle begins
  48+ 60CC              ;  +08 y offset where rectangle begins
  49+ 60CC              ;  +10 width
  50+ 60CC              ;  +12 height
  51+ 60CC              ; where IY is used to read +2 and +4, and IX to read +6, +8, +10 and +12
  52+ 60CC              ; this is a hack to allow location being taken from sprite attributes table
  53+ 60CC              ; input BLIT_STRUCT data
  54+ 60CC              ;  +00 x coordinate
  55+ 60CC              ;  +02 y coordinate
  56+ 60CC              ;  +04 width
  57+ 60CC              ;  +06 height
  58+ 60CC              ; returns CF=1 if not overlapping, CF=0 if overlapping
  59+ 60CC              RECTANGLE_OVERLAP_CHECK:
  60+ 60CC                  ; first check which rectangle is higher
  61+ 60CC DD 6E 0C         LD L,(IX+12)
  62+ 60CF DD 66 0D         LD H,(IX+13)
  63+ 60D2 ED 5B 82 64      LD DE,(BLIT_STRUCT+6)
  64+ 60D6 A7               AND A
  65+ 60D7 ED 52            SBC HL,DE
  66+ 60D9 FD 6E 04         LD L,(IY+4)
  67+ 60DC FD 66 05         LD H,(IY+5)
  68+ 60DF DD 5E 08         LD E,(IX+8)
  69+ 60E2 DD 56 09         LD D,(IX+9)
  70+ 60E5 FA 05 61         JP M,.L1
  71+ 60E8                  ; equally high or IX defined one higher
  72+ 60E8                  ; check upper boundary
  73+ 60E8 19               ADD HL,DE
  74+ 60E9 ED 5B 7E 64      LD DE,(BLIT_STRUCT+2)
  75+ 60ED DD 4E 0C         LD C,(IX+12)
  76+ 60F0 DD 46 0D         LD B,(IX+13)
  77+ 60F3 CD B4 60         CALL GENERIC_INNER_CHECK
  78+ 60F6 30 29            JR NC,.INSIDE
  79+ 60F8                  ; check lower boundary
  80+ 60F8 E5               PUSH HL
  81+ 60F9 2A 82 64         LD HL,(BLIT_STRUCT+6)
  82+ 60FC 19               ADD HL,DE
  83+ 60FD EB               EX DE,HL
  84+ 60FE E1               POP HL
  85+ 60FF CD B4 60         CALL GENERIC_INNER_CHECK
  86+ 6102 30 1D            JR NC,.INSIDE
  87+ 6104 C9               RET ; not overlapping
  88+ 6105              .L1:
  89+ 6105                  ; rectangle defined in BLIT_STRUCT is higher
  90+ 6105 19               ADD HL,DE
  91+ 6106 EB               EX DE,HL
  92+ 6107 2A 7E 64         LD HL,(BLIT_STRUCT+2)
  93+ 610A ED 4B 82 64      LD BC,(BLIT_STRUCT+6)
  94+ 610E CD B4 60         CALL GENERIC_INNER_CHECK
  95+ 6111 30 0E            JR NC,.INSIDE
  96+ 6113 E5               PUSH HL
  97+ 6114 DD 6E 0C         LD L,(IX+12)
  98+ 6117 DD 66 0D         LD H,(IX+13)
  99+ 611A 19               ADD HL,DE
 100+ 611B EB               EX DE,HL
 101+ 611C E1               POP HL
 102+ 611D CD B4 60         CALL GENERIC_INNER_CHECK
 103+ 6120 D8               RET C
 104+ 6121              .INSIDE:
 105+ 6121                  ; check x coordinate
 106+ 6121                  ; first check which rectangle is wider
 107+ 6121 DD 6E 0A         LD L,(IX+10)
 108+ 6124 DD 66 0B         LD H,(IX+11)
 109+ 6127 ED 5B 80 64      LD DE,(BLIT_STRUCT+4)
 110+ 612B A7               AND A
 111+ 612C ED 52            SBC HL,DE
 112+ 612E FD 6E 02         LD L,(IY+2)
 113+ 6131 FD 66 03         LD H,(IY+3)
 114+ 6134 DD 5E 06         LD E,(IX+6)
 115+ 6137 DD 56 07         LD D,(IX+7)
 116+ 613A FA 56 61         JP M,.L2
 117+ 613D                  ; equally wide or IX defined one wider
 118+ 613D                  ; check left boundary
 119+ 613D 19               ADD HL,DE
 120+ 613E ED 5B 7C 64      LD DE,(BLIT_STRUCT+0)
 121+ 6142 DD 4E 0A         LD C,(IX+10)
 122+ 6145 DD 46 0B         LD B,(IX+11)
 123+ 6148 CD B4 60         CALL GENERIC_INNER_CHECK
 124+ 614B D0               RET NC ; overlap
 125+ 614C                  ; check right boundary
 126+ 614C E5               PUSH HL
 127+ 614D 2A 80 64         LD HL,(BLIT_STRUCT+4)
 128+ 6150 19               ADD HL,DE
 129+ 6151 EB               EX DE,HL
 130+ 6152 E1               POP HL
 131+ 6153 C3 B4 60         JP GENERIC_INNER_CHECK ; CF and result set by fn call
 132+ 6156              .L2:
 133+ 6156                  ; rectangle defined in BLIT_STRUCT is higher
 134+ 6156 19               ADD HL,DE
 135+ 6157 EB               EX DE,HL
 136+ 6158 2A 7C 64         LD HL,(BLIT_STRUCT+0)
 137+ 615B ED 4B 80 64      LD BC,(BLIT_STRUCT+4)
 138+ 615F CD B4 60         CALL GENERIC_INNER_CHECK
 139+ 6162 D0               RET NC ; overlap
 140+ 6163 E5               PUSH HL
 141+ 6164 DD 6E 0A         LD L,(IX+10)
 142+ 6167 DD 66 0B         LD H,(IX+11)
 143+ 616A 19               ADD HL,DE
 144+ 616B EB               EX DE,HL
 145+ 616C E1               POP HL
 146+ 616D C3 B4 60         JP GENERIC_INNER_CHECK
 147+ 6170              ; ************************************************************************************************
 148+ 6170
 149+ 6170              ; ************************************************************************************************
 150+ 6170              ; function tries to find rectangle overlap and returns an index if found
 151+ 6170              ; input BLIT_STRUCT data
 152+ 6170              ;  +00 x coordinate
 153+ 6170              ;  +02 y coordinate
 154+ 6170              ;  +04 width
 155+ 6170              ;  +06 height
 156+ 6170              ;  +08 number of items in a list, described under RECTANGLE_OVERLAP_CHECK
 157+ 6170              ;  +09 pointer to first element of R%(7,n)
 158+ 6170              ;  +11 pointer to INT result variable
 159+ 6170              ; returns CF=1 if not overlapping
 160+ 6170              ; returns A=list index and CF=0 if overlapping
 161+ 6170              FIND_OVERLAP:
 162+ 6170 3A 84 64         LD A,(BLIT_STRUCT+8)
 163+ 6173 47               LD B,A
 164+ 6174 DD 2A 85 64      LD IX,(BLIT_STRUCT+9)
 165+ 6178              .L1:
 166+ 6178 C5               PUSH BC
 167+ 6179                  ; check active flag
 168+ 6179 DD 7E 00         LD A,(IX)
 169+ 617C DD B6 01         OR (IX+1)
 170+ 617F 28 18            JR Z,.NEXT
 171+ 6181                  ; check type
 172+ 6181 DD 7E 0E         LD A,(IX+14)
 173+ 6184 DD B6 0F         OR (IX+15)
 174+ 6187 20 1A            JR NZ,.L2
 175+ 6189 DD E5            PUSH IX
 176+ 618B FD E1            POP IY
 177+ 618D              .L3:
 178+ 618D CD CC 60         CALL RECTANGLE_OVERLAP_CHECK
 179+ 6190 38 07            JR C,.NEXT
 180+ 6192                  ; found
 181+ 6192 C1               POP BC
 182+ 6193 3A 84 64         LD A,(BLIT_STRUCT+8)
 183+ 6196 90               SUB B
 184+ 6197 A7               AND A
 185+ 6198 C9               RET
 186+ 6199              .NEXT:
 187+ 6199 11 10 00         LD DE,16
 188+ 619C DD 19            ADD IX,DE
 189+ 619E C1               POP BC
 190+ 619F 10 D7            DJNZ .L1
 191+ 61A1 37               SCF
 192+ 61A2 C9               RET
 193+ 61A3              .L2:
 194+ 61A3                  ; sprite, need to build a temporary data struct since x and y values are inversed
 195+ 61A3                  ; at BLIT_STRUCT+13
 196+ 61A3 DD 7E 02         LD A,(IX+2) ; sprite ID
 197+ 61A6 CD 90 4D         CALL GETnthSPRATTR
 198+ 61A9 FD 21 87 64      LD IY,BLIT_STRUCT+11
 199+ 61AD 7E               LD A,(HL)
 200+ 61AE FD 77 04         LD (IY+4),A
 201+ 61B1 23               INC HL
 202+ 61B2 7E               LD A,(HL)
 203+ 61B3 FD 77 05         LD (IY+5),A
 204+ 61B6 23               INC HL
 205+ 61B7 7E               LD A,(HL)
 206+ 61B8 FD 77 02         LD (IY+2),A
 207+ 61BB 23               INC HL
 208+ 61BC 7E               LD A,(HL)
 209+ 61BD FD 77 03         LD (IY+3),A
 210+ 61C0 18 CB            JR .L3
 211+ 61C2              ; ************************************************************************************************
 212+ 61C2
 213+ 61C2               IF (1 == 1)
 214+ 61C2              ; ************************************************************************************************
 215+ 61C2              ; function to handle CALL COLL basic extension
 216+ 61C2              ; checks for collision between player and other rectangles
 217+ 61C2              ; COLL ( INT result variable,
 218+ 61C2              ;	     INT player x value,
 219+ 61C2              ;	     INT player y value,
 220+ 61C2              ;	     INT player width,
 221+ 61C2              ;	     INT player height,
 222+ 61C2              ;	     INT number of items in a list,
 223+ 61C2              ;		 INT[6][n] rectangle struct )
 224+ 61C2              ; will fill result variable with index or -1 if no collision
 225+ 61C2              ; rectangle struct described under RECTANGLE_OVERLAP_CHECK
 226+ 61C2              COLL:
 227+ 61C2              	; opening (
 228+ 61C2 CD A9 67     	CALL CHKCHAR
 229+ 61C5 28           	DB '('
 230+ 61C6              	; get address of result variable
 231+ 61C6 DD 21 A4 5E  	LD IX, PTRGET
 232+ 61CA CD 59 01     	CALL CALBAS
 233+ 61CD ED 53 87 64  	LD (BLIT_STRUCT+11),DE
 234+ 61D1              	; comma
 235+ 61D1 CD A9 67     	CALL CHKCHAR
 236+ 61D4 2C           	DB ','
 237+ 61D5              	; get x
 238+ 61D5 DD 21 2F 54  	LD IX, FRMQNT
 239+ 61D9 CD 59 01     	CALL CALBAS
 240+ 61DC ED 53 7C 64  	LD (BLIT_STRUCT+0),DE
 241+ 61E0              	; comma
 242+ 61E0 CD A9 67     	CALL CHKCHAR
 243+ 61E3 2C           	DB ','
 244+ 61E4              	; get y
 245+ 61E4 DD 21 2F 54  	LD IX, FRMQNT
 246+ 61E8 CD 59 01     	CALL CALBAS
 247+ 61EB ED 53 7E 64  	LD (BLIT_STRUCT+2),DE
 248+ 61EF              	; comma
 249+ 61EF CD A9 67     	CALL CHKCHAR
 250+ 61F2 2C           	DB ','
 251+ 61F3              	; get width
 252+ 61F3 DD 21 2F 54  	LD IX, FRMQNT
 253+ 61F7 CD 59 01     	CALL CALBAS
 254+ 61FA ED 53 80 64  	LD (BLIT_STRUCT+4),DE
 255+ 61FE              	; comma
 256+ 61FE CD A9 67     	CALL CHKCHAR
 257+ 6201 2C           	DB ','
 258+ 6202              	; get height
 259+ 6202 DD 21 2F 54  	LD IX, FRMQNT
 260+ 6206 CD 59 01     	CALL CALBAS
 261+ 6209 ED 53 82 64  	LD (BLIT_STRUCT+6),DE
 262+ 620D              	; comma
 263+ 620D CD A9 67     	CALL CHKCHAR
 264+ 6210 2C           	DB ','
 265+ 6211              	; get number of items in a list
 266+ 6211 DD 21 1C 52  	LD IX, GETBYT
 267+ 6215 CD 59 01     	CALL CALBAS
 268+ 6218 32 84 64     	LD (BLIT_STRUCT+8),A
 269+ 621B              	; comma
 270+ 621B CD A9 67     	CALL CHKCHAR
 271+ 621E 2C           	DB ','
 272+ 621F              	; get address of rectangle structure array DIM R%(7,n)
 273+ 621F 3A 84 64     	LD A,(BLIT_STRUCT+8)
 274+ 6222 5F               LD E,A
 275+ 6223 3E 02            LD A,2
 276+ 6225 47           	LD B,A
 277+ 6226 16 07        	LD D,7
 278+ 6228 CD 0E 68     	CALL GET_BASIC_ARRAY_DATA_POINTER
 279+ 622B ED 43 85 64  	LD (BLIT_STRUCT+9),BC
 280+ 622F              	; ending )
 281+ 622F CD A9 67     	CALL CHKCHAR
 282+ 6232 29           	DB ')'
 283+ 6233
 284+ 6233 E5               PUSH HL
 285+ 6234 CD 70 61         CALL FIND_OVERLAP
 286+ 6237 2A 87 64         LD HL,(BLIT_STRUCT+11)
 287+ 623A 38 06            JR C,.NOTFOUND
 288+ 623C 77               LD (HL),A
 289+ 623D 23               INC HL
 290+ 623E 36 00            LD (HL),0
 291+ 6240 E1               POP HL
 292+ 6241 C9               RET
 293+ 6242              .NOTFOUND:
 294+ 6242 36 FF            LD (HL),#FF
 295+ 6244 23               INC HL
 296+ 6245 36 FF            LD (HL),#FF
 297+ 6247 E1               POP HL
 298+ 6248 C9               RET
 299+ 6249              ; ************************************************************************************************
 300+ 6249               ENDIF
 301+ 6249
 302+ 6249               IF (0 == 1)
 303+ 6249 ~            ; *******************************************************************************************************
 304+ 6249 ~            ; same as COLL but for DEFUSR approach
 305+ 6249 ~            ; input IX=pointer to input array, real data from +2
 306+ 6249 ~            ; +02 = pointer to result variable
 307+ 6249 ~            ; +04 = player X
 308+ 6249 ~            ; +06 = player Y
 309+ 6249 ~            ; +08 = player width
 310+ 6249 ~            ; +10 = player height
 311+ 6249 ~            ; +12 = number of list items
 312+ 6249 ~            ; +14 = pointer to list of collidable objects
 313+ 6249 ~            COLL_DEFUSR:
 314+ 6249 ~                PUSH IX
 315+ 6249 ~                POP HL
 316+ 6249 ~                .4 INC HL ; skip over to player x
 317+ 6249 ~                LD DE,BLIT_STRUCT
 318+ 6249 ~                LD BC,9
 319+ 6249 ~                LDIR ; copy over x,y,w,h,list item number
 320+ 6249 ~                LD A,(IX+14)
 321+ 6249 ~                LD (BLIT_STRUCT+9),A
 322+ 6249 ~                LD A,(IX+15)
 323+ 6249 ~                LD (BLIT_STRUCT+10),A ; address to collidable objects array
 324+ 6249 ~                LD A,(IX+2)
 325+ 6249 ~                LD (BLIT_STRUCT+11),A
 326+ 6249 ~                LD A,(IX+3)
 327+ 6249 ~                LD (BLIT_STRUCT+12),A ; address to results variable
 328+ 6249 ~                PUSH IX
 329+ 6249 ~                CALL FIND_OVERLAP
 330+ 6249 ~                POP IX
 331+ 6249 ~                LD L,(IX+2)
 332+ 6249 ~                LD H,(IX+3)
 333+ 6249 ~                JR C,.NOTFOUND
 334+ 6249 ~                LD (HL),A
 335+ 6249 ~                INC HL
 336+ 6249 ~                LD (HL),0
 337+ 6249 ~            .EXIT:
 338+ 6249 ~                XOR A ; success
 339+ 6249 ~                RET
 340+ 6249 ~            .NOTFOUND:
 341+ 6249 ~                LD (HL),#FF
 342+ 6249 ~                INC HL
 343+ 6249 ~                LD (HL),#FF
 344+ 6249 ~                JR .EXIT
 345+ 6249 ~            ; *******************************************************************************************************
 346+ 6249               ENDIF
 347+ 6249
# file closed: asm\COLLISION.asm
 172  6249               ENDIF
 173  6249
 174  6249               IF (DECOMP_CMDS == 1)
 175  6249               INCLUDE "decomp.asm"
# file opened: asm\decomp.asm
   1+ 6249              ; -----------------------------------------------------------------------------
   2+ 6249              ; ZX0 decoder by Einar Saukas & Urusergi
   3+ 6249              ; "Standard" version (68 bytes only)
   4+ 6249              ; -----------------------------------------------------------------------------
   5+ 6249              ; Parameters:
   6+ 6249              ;   HL: source address (compressed data)
   7+ 6249              ;   DE: destination address (decompressing)
   8+ 6249              ; -----------------------------------------------------------------------------
   9+ 6249
  10+ 6249              dzx0_standard:
  11+ 6249 01 FF FF             ld      bc, $ffff               ; preserve default offset 1
  12+ 624C C5                   push    bc
  13+ 624D 03                   inc     bc
  14+ 624E 3E 80                ld      a, $80
  15+ 6250              dzx0s_literals:
  16+ 6250 CD 80 62             call    dzx0s_elias             ; obtain length
  17+ 6253              dzx0_ldir_1:
  18+ 6253 ED B0                ldir                            ; copy literals
  19+ 6255 00                   nop                             ; placeholder for call
  20+ 6256 87                   add     a, a                    ; copy from last offset or new offset?
  21+ 6257 38 0E                jr      c, dzx0s_new_offset
  22+ 6259 CD 80 62             call    dzx0s_elias             ; obtain length
  23+ 625C              dzx0s_copy:
  24+ 625C E3                   ex      (sp), hl                ; preserve source, restore offset
  25+ 625D E5                   push    hl                      ; preserve offset
  26+ 625E 19                   add     hl, de                  ; calculate destination - offset
  27+ 625F              dzx0_ldir_2:
  28+ 625F ED B0                ldir                            ; copy from offset
  29+ 6261 00                   nop                             ; placeholder for call
  30+ 6262 E1                   pop     hl                      ; restore offset
  31+ 6263 E3                   ex      (sp), hl                ; preserve offset, restore source
  32+ 6264 87                   add     a, a                    ; copy from literals or new offset?
  33+ 6265 30 E9                jr      nc, dzx0s_literals
  34+ 6267              dzx0s_new_offset:
  35+ 6267 C1                   pop     bc                      ; discard last offset
  36+ 6268 0E FE                ld      c, $fe                  ; prepare negative offset
  37+ 626A CD 81 62             call    dzx0s_elias_loop        ; obtain offset MSB
  38+ 626D 0C                   inc     c
  39+ 626E C8                   ret     z                       ; check end marker
  40+ 626F 41                   ld      b, c
  41+ 6270 4E                   ld      c, (hl)                 ; obtain offset LSB
  42+ 6271 23                   inc     hl
  43+ 6272 CB 18                rr      b                       ; last offset bit becomes first length bit
  44+ 6274 CB 19                rr      c
  45+ 6276 C5                   push    bc                      ; preserve new offset
  46+ 6277 01 01 00             ld      bc, 1                   ; obtain length
  47+ 627A D4 88 62             call    nc, dzx0s_elias_backtrack
  48+ 627D 03                   inc     bc
  49+ 627E 18 DC                jr      dzx0s_copy
  50+ 6280              dzx0s_elias:
  51+ 6280 0C                   inc     c                       ; interlaced Elias gamma coding
  52+ 6281              dzx0s_elias_loop:
  53+ 6281 87                   add     a, a
  54+ 6282 20 03                jr      nz, dzx0s_elias_skip
  55+ 6284 7E                   ld      a, (hl)                 ; load another group of 8 bits
  56+ 6285 23                   inc     hl
  57+ 6286 17                   rla
  58+ 6287              dzx0s_elias_skip:
  59+ 6287 D8                   ret     c
  60+ 6288              dzx0s_elias_backtrack:
  61+ 6288 87                   add     a, a
  62+ 6289 CB 11                rl      c
  63+ 628B CB 10                rl      b
  64+ 628D 18 F2                jr      dzx0s_elias_loop
  65+ 628F              ; -----------------------------------------------------------------------------
  66+ 628F
  67+ 628F              ; *******************************************************************************************************
  68+ 628F              ; helper function for VRAM unpack to save AF prior to calling copy to VRAM fn
  69+ 628F              ; also simulates register states as if LDIR was called
  70+ 628F              LDIR_TO_VRAM:
  71+ 628F F5                   PUSH AF ; save AF used by algorithm
  72+ 6290 D5                   PUSH DE
  73+ 6291 C5                   PUSH BC
  74+ 6292 CD 5E 5A             CALL VRAM_LDIRVM
  75+ 6295 C1                   POP BC
  76+ 6296 EB                   EX DE,HL
  77+ 6297 E1                   POP HL
  78+ 6298 09                   ADD HL,BC
  79+ 6299 EB                   EX DE,HL
  80+ 629A 01 00 00             LD BC,0
  81+ 629D F1                   POP AF
  82+ 629E C9                   RET
  83+ 629F              ; *******************************************************************************************************
  84+ 629F
  85+ 629F              ; *******************************************************************************************************
  86+ 629F              ; helper function to get a byte from VRAM address at HL and place it at DE also in VRAM
  87+ 629F              VPOKE_VPEEK:
  88+ 629F F3                   DI
  89+ 62A0 CD 82 66             CALL SETWRT_LOCAL_READ
  90+ 62A3 E3                   EX (SP),HL
  91+ 62A4 E3                   EX (SP),HL
  92+ 62A5 DB 98                IN A,(#98)
  93+ 62A7                      ;IN A,(#98) ; WHY IS THIS NEEDED ?
  94+ 62A7 F5                   PUSH AF
  95+ 62A8 EB                   EX DE,HL
  96+ 62A9 CD 77 66             CALL SETWRT_LOCAL_WRITE
  97+ 62AC E3                   EX (SP),HL
  98+ 62AD E3                   EX (SP),HL
  99+ 62AE EB                   EX DE,HL
 100+ 62AF F1                   POP AF
 101+ 62B0 D3 98                OUT (#98),A
 102+ 62B2 FB                   EI
 103+ 62B3 C9                   RET
 104+ 62B4              ; *******************************************************************************************************
 105+ 62B4
 106+ 62B4              ; *******************************************************************************************************
 107+ 62B4              ; helper fn VRAM variant of LDIR
 108+ 62B4              ; input HL = source, DE = destination, BC = count
 109+ 62B4              VRAM_LDIR:
 110+ 62B4 F5                   PUSH AF
 111+ 62B5              _L0:
 112+ 62B5 CD 9F 62             CALL VPOKE_VPEEK
 113+ 62B8 23                   INC HL
 114+ 62B9 13                   INC DE
 115+ 62BA 0B                   DEC BC
 116+ 62BB 78                   LD A, B
 117+ 62BC B1                   OR C
 118+ 62BD 20 F6                JR NZ, _L0
 119+ 62BF F1                   POP AF
 120+ 62C0 C9                   RET
 121+ 62C1              ; *******************************************************************************************************
 122+ 62C1
 123+ 62C1               IF (1 == 1)
 124+ 62C1              ; *******************************************************************************************************
 125+ 62C1              ; function to handle CALL VUNPACK basic extension
 126+ 62C1              ; _VUNPACK ( INT source,
 127+ 62C1              ;			 INT destination )
 128+ 62C1              ; will put ram in page 0 also, page 1 is already there
 129+ 62C1              ; *******************************************************************************************************
 130+ 62C1              VUNPACK:
 131+ 62C1 3E CD            LD A, #CD ; CALL
 132+ 62C3 32 53 62         LD (dzx0_ldir_1), A
 133+ 62C6 32 5F 62         LD (dzx0_ldir_2), A
 134+ 62C9 11 8F 62         LD DE, LDIR_TO_VRAM
 135+ 62CC ED 53 54 62      LD (dzx0_ldir_1 + 1), DE
 136+ 62D0 11 B4 62         LD DE, VRAM_LDIR
 137+ 62D3 ED 53 60 62      LD (dzx0_ldir_2 + 1), DE
 138+ 62D7 18 12            JR UNPACK_COMMON
 139+ 62D9              ; function to handle CALL UNPACK basic extension
 140+ 62D9              ; _UNPACK ( INT source,
 141+ 62D9              ;			INT destination )
 142+ 62D9              ; will put ram in page 0 also, page 1 is already there
 143+ 62D9              UNPACK:
 144+ 62D9 11 ED B0         LD DE, #B0ED ; LDIR
 145+ 62DC ED 53 53 62      LD (dzx0_ldir_1), DE
 146+ 62E0 ED 53 5F 62      LD (dzx0_ldir_2), DE
 147+ 62E4 AF               XOR A ; NOP
 148+ 62E5 32 55 62         LD (dzx0_ldir_1 + 2), A
 149+ 62E8 32 61 62         LD (dzx0_ldir_2 + 2), A
 150+ 62EB              UNPACK_COMMON:
 151+ 62EB              	; opening (
 152+ 62EB CD A9 67     	CALL CHKCHAR
 153+ 62EE 28           	DB '('
 154+ 62EF              	; get source address
 155+ 62EF DD 21 2F 54  	LD IX, FRMQNT
 156+ 62F3 CD 59 01     	CALL CALBAS
 157+ 62F6 D5           	PUSH DE
 158+ 62F7              	; comma
 159+ 62F7 CD A9 67     	CALL CHKCHAR
 160+ 62FA 2C           	DB ','
 161+ 62FB              	; get destination address
 162+ 62FB DD 21 2F 54  	LD IX, FRMQNT
 163+ 62FF CD 59 01     	CALL CALBAS
 164+ 6302 D5           	PUSH DE
 165+ 6303              	; ending )
 166+ 6303 CD A9 67     	CALL CHKCHAR
 167+ 6306 29           	DB ')'
 168+ 6307
 169+ 6307              	; save position
 170+ 6307 E5           	PUSH HL
 171+ 6308 DD E1        	POP IX
 172+ 630A
 173+ 630A D1           	POP DE ; destination
 174+ 630B E1           	POP HL ; source
 175+ 630C D9           	EXX
 176+ 630D              	; enable page 0
 177+ 630D FD 21 14 63  	LD IY, .RET
 178+ 6311 C3 5A 67     	JP ENABLE_PAGE0
 179+ 6314              .RET:
 180+ 6314 FB           	EI
 181+ 6315 D9           	EXX
 182+ 6316 CD 49 62     	CALL dzx0_standard
 183+ 6319 D1                   POP DE
 184+ 631A C1                   POP BC
 185+ 631B CD D1 66             CALL RESTORE_PAGE_INFO
 186+ 631E DD E5        	PUSH IX
 187+ 6320 E1           	POP HL
 188+ 6321 C9           	RET
 189+ 6322              ; *******************************************************************************************************
 190+ 6322               ENDIF
 191+ 6322
 192+ 6322               IF (0 == 1)
 193+ 6322 ~            ; *******************************************************************************************************
 194+ 6322 ~            ; same as VUNPACK but for DEFUSR approach
 195+ 6322 ~            ; input IX=pointer to input array, real data from +2
 196+ 6322 ~            ; +2 = source address
 197+ 6322 ~            ; +4 = destination address
 198+ 6322 ~            ; *******************************************************************************************************
 199+ 6322 ~            VUNPACK_DEFUSR:
 200+ 6322 ~                LD A, #CD ; CALL
 201+ 6322 ~                LD (dzx0_ldir_1), A
 202+ 6322 ~                LD (dzx0_ldir_2), A
 203+ 6322 ~                LD HL, LDIR_TO_VRAM
 204+ 6322 ~                LD (dzx0_ldir_1 + 1), HL
 205+ 6322 ~                LD HL, VRAM_LDIR
 206+ 6322 ~                LD (dzx0_ldir_2 + 1), HL
 207+ 6322 ~                JR UNPACK_DEFUSR_COMMON
 208+ 6322 ~            ; same as UNPACK but for DEFUSR approach
 209+ 6322 ~            ; input IX=pointer to input array, real data from +2
 210+ 6322 ~            ; +2 = source address
 211+ 6322 ~            ; +4 = destination address
 212+ 6322 ~            UNPACK_DEFUSR:
 213+ 6322 ~                LD HL, #B0ED ; LDIR
 214+ 6322 ~                LD (dzx0_ldir_1), HL
 215+ 6322 ~                LD (dzx0_ldir_2), HL
 216+ 6322 ~                XOR A ; NOP
 217+ 6322 ~                LD (dzx0_ldir_1 + 2), A
 218+ 6322 ~                LD (dzx0_ldir_2 + 2), A
 219+ 6322 ~            UNPACK_DEFUSR_COMMON:
 220+ 6322 ~            	; enable page 0
 221+ 6322 ~            	LD IY, .RET
 222+ 6322 ~            	JP ENABLE_PAGE0
 223+ 6322 ~            .RET:
 224+ 6322 ~            	EI
 225+ 6322 ~            	LD L,(IX+2)
 226+ 6322 ~            	LD H,(IX+3)
 227+ 6322 ~            	LD E,(IX+4)
 228+ 6322 ~            	LD D,(IX+5)
 229+ 6322 ~            	CALL dzx0_standard
 230+ 6322 ~                POP DE
 231+ 6322 ~                POP BC
 232+ 6322 ~                CALL RESTORE_PAGE_INFO
 233+ 6322 ~                XOR A ; success
 234+ 6322 ~                RET
 235+ 6322 ~            ; *******************************************************************************************************
 236+ 6322               ENDIF
# file closed: asm\decomp.asm
 176  6322               ENDIF
 177  6322
 178  6322               IF (DLOAD_CMD == 1)
 179  6322               INCLUDE "DLOAD.asm"
# file opened: asm\DLOAD.asm
   1+ 6322              BDOS_SETDTA     EQU #1A
   2+ 6322              BDOS_OPEN       EQU #0F
   3+ 6322              BDOS_CLOSE      EQU #10
   4+ 6322              BDOS_RDBLK      EQU #27
   5+ 6322
   6+ 6322              ; *******************************************************************************************************
   7+ 6322              ; function processes file name
   8+ 6322              ; filenames supported are D:FILENAME.EXT, FILENAME.EXT, D:FILENAME, FILENAME
   9+ 6322              ; FCB 0 will be zeroed out
  10+ 6322              ; FCB 0 will be populated with drive info 0=default or 1-8 for drives A-H
  11+ 6322              ; FCB 0 will be populated with file name
  12+ 6322              ; input HL=pointer to expression
  13+ 6322              ; input B=length
  14+ 6322              ; returns CF=1 if bad filename
  15+ 6322              DLOAD_PROCESS_FILENAME:
  16+ 6322                  ; check for zero size
  17+ 6322 78               LD A,B
  18+ 6323 B7               OR A
  19+ 6324 28 6B            JR Z, .BADFILENAME
  20+ 6326                  ; check for more than 2+8+1+3=14
  21+ 6326 FE 0F            CP 15
  22+ 6328 30 67            JR NC, .BADFILENAME
  23+ 632A                  ; check if more than 2 letters
  24+ 632A FE 03            CP 3
  25+ 632C 38 1C            JR C, .L7 ; no drive
  26+ 632E                  ; check for : at proper place
  27+ 632E 5E               LD E, (HL)
  28+ 632F 23               INC HL
  29+ 6330 7E               LD A, (HL)
  30+ 6331 FE 3A            CP ':'
  31+ 6333 20 14            JR NZ, .L1
  32+ 6335                  ; so we have : , check for letters A-H
  33+ 6335 7B               LD A,E
  34+ 6336 CD E2 67         CALL UPPER
  35+ 6339 D6 41            SUB 'A'
  36+ 633B FE 09            CP 9
  37+ 633D 30 52            JR NC, .BADFILENAME
  38+ 633F 23               INC HL
  39+ 6340 05               DEC B ; consume two characters
  40+ 6341 05               DEC B
  41+ 6342              .L2:
  42+ 6342 ED 5B 53 F3      LD DE, (FCB0)
  43+ 6346 12               LD (DE), A
  44+ 6347 18 04            JR .PROCESS_FILENAME
  45+ 6349              .L1:
  46+ 6349                  ; no drive specified
  47+ 6349 2B               DEC HL
  48+ 634A              .L7:
  49+ 634A AF               XOR A
  50+ 634B 18 F5            JR .L2
  51+ 634D              .PROCESS_FILENAME:
  52+ 634D                  ; HL is pointing to rest of the name
  53+ 634D 13               INC DE ; 8-character filename location, needs to be padded with blanks
  54+ 634E 0E 08            LD C,8 ; filename length
  55+ 6350              .L4:
  56+ 6350 CD 93 63         CALL .GETCHAR
  57+ 6353 FE 2E            CP '.'
  58+ 6355 28 31            JR Z, .L6 ; if dot, fill rest with blanks
  59+ 6357 12               LD (DE),A
  60+ 6358 13               INC DE
  61+ 6359 0D               DEC C
  62+ 635A 20 F4            JR NZ, .L4
  63+ 635C                  ; so we cleared filename part
  64+ 635C 78               LD A,B ; no more letters. just fill extension with blanks
  65+ 635D B7               OR A
  66+ 635E 28 07            JR Z, .L8
  67+ 6360 CD 93 63         CALL .GETCHAR ; here we must have . for a valid name
  68+ 6363 FE 2E            CP '.'
  69+ 6365 20 2A            JR NZ, .BADFILENAME
  70+ 6367              .L8:
  71+ 6367 0E 03            LD C,3
  72+ 6369              .L5:
  73+ 6369 CD 93 63         CALL .GETCHAR
  74+ 636C 12               LD (DE),A
  75+ 636D 13               INC DE
  76+ 636E 0D               DEC C
  77+ 636F 20 F8            JR NZ, .L5
  78+ 6371 78               LD A,B ; nothing must be left in buffer
  79+ 6372 B7               OR A
  80+ 6373 20 1C            JR NZ, .BADFILENAME
  81+ 6375                  ; file name correct, now zero out the rest of FCB 0
  82+ 6375 2A 53 F3         LD HL,(FCB0)
  83+ 6378 11 0C 00         LD DE,12
  84+ 637B 19               ADD HL,DE
  85+ 637C 36 00            LD (HL),0
  86+ 637E 54               LD D,H
  87+ 637F 5D               LD E,L
  88+ 6380 13               INC DE
  89+ 6381 01 18 00         LD BC,37-12-1
  90+ 6384 ED B0            LDIR
  91+ 6386 AF               XOR A ; clear carry flag
  92+ 6387 C9               RET
  93+ 6388              .L6:
  94+ 6388 3E 20            LD A,' '
  95+ 638A              .L9:
  96+ 638A 12               LD (DE),A
  97+ 638B 13               INC DE
  98+ 638C 0D               DEC C
  99+ 638D 20 FB            JR NZ, .L9
 100+ 638F 18 D6            JR .L8
 101+ 6391              .BADFILENAME:
 102+ 6391 37               SCF
 103+ 6392 C9               RET
 104+ 6393              .GETCHAR: ; gets a character, returns blank if we read past input
 105+ 6393 78               LD A,B
 106+ 6394 B7               OR A
 107+ 6395 28 07            JR Z, .BLANK
 108+ 6397 7E               LD A,(HL)
 109+ 6398 CD E2 67         CALL UPPER
 110+ 639B 23               INC HL
 111+ 639C 05               DEC B
 112+ 639D C9               RET
 113+ 639E              .BLANK:
 114+ 639E 3E 20            LD A,' '
 115+ 63A0 C9               RET
 116+ 63A1              ; *******************************************************************************************************
 117+ 63A1
 118+ 63A1              ; *******************************************************************************************************
 119+ 63A1              ; function sets disk buffer from NULBUF
 120+ 63A1              ; input none
 121+ 63A1              ; returns ZF!=1 on error
 122+ 63A1              DLOAD_SETDTA:
 123+ 63A1 ED 5B 62 F8      LD DE,(NULBUF)
 124+ 63A5 0E 1A            LD C, BDOS_SETDTA
 125+ 63A7 18 24            JR BDOS_CALL
 126+ 63A9              ; *******************************************************************************************************
 127+ 63A9
 128+ 63A9              ; *******************************************************************************************************
 129+ 63A9              ; function opens a file using FCB 0
 130+ 63A9              ; input none
 131+ 63A9              ; returns ZF!=1 on error
 132+ 63A9              DLOAD_OPENFILE:
 133+ 63A9 ED 5B 53 F3      LD DE,(FCB0)
 134+ 63AD 0E 0F            LD C, BDOS_OPEN
 135+ 63AF 18 1C            JR BDOS_CALL
 136+ 63B1              ; *******************************************************************************************************
 137+ 63B1
 138+ 63B1              ; *******************************************************************************************************
 139+ 63B1              ; function makes a file seek and sets record size to 1 byte
 140+ 63B1              ; input none
 141+ 63B1              ; output node
 142+ 63B1              DLOAD_SEEK:
 143+ 63B1 2A 7C 64         LD HL,(BLIT_STRUCT)
 144+ 63B4 DD 2A 53 F3      LD IX,(FCB0)
 145+ 63B8 DD 75 21         LD (IX+33),L
 146+ 63BB DD 74 22         LD (IX+34),H
 147+ 63BE DD 36 0E 01      LD (IX+14),1
 148+ 63C2 DD 36 0F 00      LD (IX+15),0
 149+ 63C6 C9               RET
 150+ 63C7              ; *******************************************************************************************************
 151+ 63C7
 152+ 63C7              ; *******************************************************************************************************
 153+ 63C7              ; function reads a number of bytes from a file using FCB 0 to (NULBUF) buffer
 154+ 63C7              ; input HL=number of bytes to read
 155+ 63C7              ; returns HL=number of bytes read
 156+ 63C7              ; returns ZF!=1 on error
 157+ 63C7              DLOAD_READ:
 158+ 63C7 ED 5B 53 F3      LD DE,(FCB0)
 159+ 63CB 0E 27            LD C,BDOS_RDBLK
 160+ 63CD              BDOS_CALL:
 161+ 63CD CD 7D F3         CALL BDOS
 162+ 63D0 B7               OR A
 163+ 63D1 C9               RET
 164+ 63D2              ; *******************************************************************************************************
 165+ 63D2
 166+ 63D2              ; *******************************************************************************************************
 167+ 63D2              ; function closes a file FCB 0
 168+ 63D2              ; input none
 169+ 63D2              ; returns ZF!=1 on error
 170+ 63D2              DLOAD_CLOSE:
 171+ 63D2 AF               XOR A
 172+ 63D3 ED 5B 53 F3      LD DE,(FCB0)
 173+ 63D7 0E 10            LD C,BDOS_CLOSE
 174+ 63D9 18 F2            JR BDOS_CALL
 175+ 63DB              ; *******************************************************************************************************
 176+ 63DB
 177+ 63DB              ; *******************************************************************************************************
 178+ 63DB              ; function copies data from (NULBUF) to destination, enables RAM in page 0
 179+ 63DB              ; input BC=number of bytes to copy
 180+ 63DB              ; output none
 181+ 63DB              DLOAD_TRANSFERBLOCK:
 182+ 63DB D9               EXX ; save BC
 183+ 63DC              	; enable page 0
 184+ 63DC FD 21 E3 63  	LD IY, .RET
 185+ 63E0 C3 5A 67     	JP ENABLE_PAGE0
 186+ 63E3              .RET:
 187+ 63E3 FB           	EI
 188+ 63E4 D9               EXX
 189+ 63E5 ED 5B 7E 64      LD DE,(BLIT_STRUCT+2)
 190+ 63E9 2A 62 F8         LD HL,(NULBUF)
 191+ 63EC ED B0        	LDIR
 192+ 63EE ED 53 7E 64      LD (BLIT_STRUCT+2),DE
 193+ 63F2 D1               POP DE
 194+ 63F3 C1               POP BC
 195+ 63F4 C3 D1 66         JP RESTORE_PAGE_INFO
 196+ 63F7              ; *******************************************************************************************************
 197+ 63F7
 198+ 63F7              ; *******************************************************************************************************
 199+ 63F7              ; function opens and loads a file in FCB 0
 200+ 63F7              ; file name needs to be already set in FCB 0
 201+ 63F7              ; input none
 202+ 63F7              ; returns ZF!=1 on error
 203+ 63F7              DLOAD_LOADFILE:
 204+ 63F7 CD A1 63         CALL DLOAD_SETDTA
 205+ 63FA CD A9 63         CALL DLOAD_OPENFILE
 206+ 63FD C0               RET NZ
 207+ 63FE CD B1 63         CALL DLOAD_SEEK
 208+ 6401 ED 4B 80 64      LD BC,(BLIT_STRUCT+4)
 209+ 6405              .L1:
 210+ 6405 78               LD A,B
 211+ 6406 B7               OR A
 212+ 6407 28 12            JR Z,.REST
 213+ 6409 05               DEC B
 214+ 640A 21 00 01         LD HL,256
 215+ 640D              .L2:
 216+ 640D C5               PUSH BC
 217+ 640E E5               PUSH HL
 218+ 640F CD C7 63         CALL DLOAD_READ
 219+ 6412 C1               POP BC
 220+ 6413 20 10            JR NZ,.ERRREAD
 221+ 6415 CD DB 63         CALL DLOAD_TRANSFERBLOCK
 222+ 6418 C1               POP BC
 223+ 6419 18 EA            JR .L1
 224+ 641B              .REST:
 225+ 641B 79               LD A,C
 226+ 641C B7               OR A
 227+ 641D 28 07            JR Z,.EXIT
 228+ 641F 26 00            LD H,0
 229+ 6421 69               LD L,C
 230+ 6422 4C               LD C,H
 231+ 6423 18 E8            JR .L2
 232+ 6425              .ERRREAD:
 233+ 6425 C1               POP BC
 234+ 6426              .EXIT:
 235+ 6426 F5               PUSH AF
 236+ 6427 CD D2 63         CALL DLOAD_CLOSE
 237+ 642A F1               POP AF
 238+ 642B C9               RET
 239+ 642C              ; *******************************************************************************************************
 240+ 642C
 241+ 642C               IF (1 == 1)
 242+ 642C
 243+ 642C              ; *******************************************************************************************************
 244+ 642C              ; function to handle CALL DLOAD basic extension
 245+ 642C              ; _DLOAD ( STRING filename,
 246+ 642C              ;		   INT offset,
 247+ 642C              ;		   INT destination,
 248+ 642C              ;          INT size )
 249+ 642C              ; will put ram in page 0 also, page 1 is already there
 250+ 642C              DLOAD:
 251+ 642C              	; opening (
 252+ 642C CD A9 67     	CALL CHKCHAR
 253+ 642F 28           	DB '('
 254+ 6430 CD F5 67         CALL EVALTXTPARAM
 255+ 6433 E5               PUSH HL
 256+ 6434 CD EB 67         CALL GETSTRPNT
 257+ 6437 CD 22 63         CALL DLOAD_PROCESS_FILENAME
 258+ 643A DA BD 67         JP C, BAD_FILENAME
 259+ 643D E1               POP HL
 260+ 643E              	; comma
 261+ 643E CD A9 67     	CALL CHKCHAR
 262+ 6441 2C           	DB ','
 263+ 6442              	; get offset
 264+ 6442 DD 21 2F 54  	LD IX, FRMQNT
 265+ 6446 CD 59 01     	CALL CALBAS
 266+ 6449 ED 53 7C 64  	LD (BLIT_STRUCT), DE
 267+ 644D              	; comma
 268+ 644D CD A9 67     	CALL CHKCHAR
 269+ 6450 2C           	DB ','
 270+ 6451              	; get destination
 271+ 6451 DD 21 2F 54  	LD IX, FRMQNT
 272+ 6455 CD 59 01     	CALL CALBAS
 273+ 6458 ED 53 7E 64  	LD (BLIT_STRUCT+2), DE
 274+ 645C              	; comma
 275+ 645C CD A9 67     	CALL CHKCHAR
 276+ 645F 2C           	DB ','
 277+ 6460              	; get size
 278+ 6460 DD 21 2F 54  	LD IX, FRMQNT
 279+ 6464 CD 59 01     	CALL CALBAS
 280+ 6467 ED 53 80 64  	LD (BLIT_STRUCT+4), DE
 281+ 646B              	; ending )
 282+ 646B CD A9 67     	CALL CHKCHAR
 283+ 646E 29           	DB ')'
 284+ 646F
 285+ 646F E5               PUSH HL
 286+ 6470 CD F7 63         CALL DLOAD_LOADFILE
 287+ 6473 C2 C1 67         JP NZ, DISKIOERR
 288+ 6476 E1               POP HL
 289+ 6477 C9               RET
 290+ 6478              ; *******************************************************************************************************
 291+ 6478
 292+ 6478               ENDIF
 293+ 6478
 294+ 6478               IF (0 == 1)
 295+ 6478 ~            ; *******************************************************************************************************
 296+ 6478 ~            ; same as DLOAD but for DEFUSR approach
 297+ 6478 ~            ; input IX=pointer to input array, real data from +2
 298+ 6478 ~            ; +2 = string pointer
 299+ 6478 ~            ; +4 = offset
 300+ 6478 ~            ; +6 = destination
 301+ 6478 ~            ; +8 = size
 302+ 6478 ~            ; output A=0 on success
 303+ 6478 ~            ; *******************************************************************************************************
 304+ 6478 ~            DLOAD_DEFUSR:
 305+ 6478 ~                LD L,(IX+2)
 306+ 6478 ~                LD H,(IX+3)
 307+ 6478 ~                LD B,(HL) ; string length
 308+ 6478 ~                INC HL
 309+ 6478 ~                LD E,(HL)
 310+ 6478 ~                INC HL
 311+ 6478 ~                LD D,(HL)
 312+ 6478 ~                EX DE,HL ; pointer to ASCIIZ text
 313+ 6478 ~                CALL DLOAD_PROCESS_FILENAME
 314+ 6478 ~                JR C,.ERR ; exit on error
 315+ 6478 ~                LD L,(IX+4)
 316+ 6478 ~                LD H,(IX+5)
 317+ 6478 ~                LD (BLIT_STRUCT),HL ; offset
 318+ 6478 ~                LD L,(IX+6)
 319+ 6478 ~                LD H,(IX+7)
 320+ 6478 ~                LD (BLIT_STRUCT+2),HL ; destination
 321+ 6478 ~                LD L,(IX+8)
 322+ 6478 ~                LD H,(IX+9)
 323+ 6478 ~                LD (BLIT_STRUCT+4),HL ; size
 324+ 6478 ~                CALL DLOAD_LOADFILE
 325+ 6478 ~                JR NZ,.ERR
 326+ 6478 ~                XOR A
 327+ 6478 ~                RET
 328+ 6478 ~            .ERR:
 329+ 6478 ~                LD A,1
 330+ 6478 ~                RET
 331+ 6478 ~            ; *******************************************************************************************************
 332+ 6478 ~
 333+ 6478               ENDIF
 334+ 6478
# file closed: asm\DLOAD.asm
 180  6478               ENDIF
 181  6478
 182  6478               IF (0 == 1)
 183  6478 ~             INCLUDE "DEFUSR.asm"
 184  6478               ENDIF
 185  6478
 186  6478              ; temp variables for BLIT, TILE functions
 187  6478               IF (BLIT_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS + COLL_CMD + DLOAD_CMD > 0)
 188  6478              BLIT_TMP:
 189  6478              TILETMP1:
 190  6478              BLIT_TMP1:
 191  6478 00 00         DW 0
 192  647A              TILETMP2:
 193  647A              BLIT_TMP2:
 194  647A 00 00         DW 0
 195  647C              BLIT_STRUCT:
 196  647C 00 00 00...   DS 17
 197  6480               ENDIF
 198  648D
 199  648D               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 200  648D              VRAM_UPDATE_IN_PROGRESS:
 201  648D 00            DB 0
 202  648E               ENDIF
 203  648E
 204  648E              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 205  648E              ; per starting letter, if no commands with this letter, NULL value
 206  648E              CMDS:
 207  648E DF 65        	DW CMDS_A ; always present due to ARTINFO
 208  6490               IF (BLIT_CMDS + BOX_CMDS > 0) && (1 == 1)
 209  6490 94 65            DW CMDS_B ; B
 210  6492               ELSE
 211  6492 ~            	DW 0
 212  6492               ENDIF
 213  6492               IF (COLL_CMD == 1) && (1 == 1)
 214  6492 C7 65        	DW CMDS_C ;
 215  6494               ELSE
 216  6494 ~                DW 0 ; C
 217  6494               ENDIF
 218  6494               IF (DLOAD_CMD > 0) && (1 == 1)
 219  6494 D7 65            DW CMDS_D ; D
 220  6496               ELSE
 221  6496 ~            	DW 0
 222  6496               ENDIF
 223  6496 00 00            DW 0 ; E
 224  6498               IF (VRAM_CMDS + RAM_CMDS > 0) && (1 == 1)
 225  6498 0E 65            DW CMDS_F; F
 226  649A               ELSE
 227  649A ~            	DW 0
 228  649A               ENDIF
 229  649A               IF (GENCAL_CMD > 0) && (1 == 1)
 230  649A 20 65            DW CMDS_G; G
 231  649C               ELSE
 232  649C ~            	DW 0
 233  649C               ENDIF
 234  649C 00 00            DW 0 ; H
 235  649E 00 00            DW 0 ; I
 236  64A0 00 00            DW 0 ; J
 237  64A2 00 00            DW 0 ; K
 238  64A4 00 00            DW 0 ; L
 239  64A6               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0) && (1 == 1)
 240  64A6 C2 64            DW CMDS_M ; M
 241  64A8               ELSE
 242  64A8 ~            	DW 0
 243  64A8               ENDIF
 244  64A8 00 00            DW 0 ; N
 245  64AA 00 00            DW 0 ; O
 246  64AC 00 00            DW 0 ; P
 247  64AE 00 00            DW 0 ; Q
 248  64B0 00 00            DW 0 ; R
 249  64B2               IF (SOUND_CMDS + SPRITE_CMDS > 0) && (1 == 1)
 250  64B2 3C 65            DW CMDS_S ; S
 251  64B4               ELSE
 252  64B4 ~            	DW 0
 253  64B4               ENDIF
 254  64B4               IF (TILE_CMDS > 0) && (1 == 1)
 255  64B4 B3 65            DW CMDS_T ; T
 256  64B6               ELSE
 257  64B6 ~            	DW 0
 258  64B6               ENDIF
 259  64B6               IF (DECOMP_CMDS > 0) && (1 == 1)
 260  64B6 CE 65            DW CMDS_U ; U
 261  64B8               ELSE
 262  64B8 ~            	DW 0
 263  64B8               ENDIF
 264  64B8               IF ((VRAM_CMDS > 0) || (VRAM_CMDS + DECOMP_CMDS > 1)) && (1 == 1)
 265  64B8 29 65            DW CMDS_V ; V
 266  64BA               ELSE
 267  64BA ~            	DW 0
 268  64BA               ENDIF
 269  64BA 00 00            DW 0 ; W
 270  64BC 00 00            DW 0 ; X
 271  64BE 00 00            DW 0 ; Y
 272  64C0 00 00            DW 0 ; Z
 273  64C2
 274  64C2               IF (1 == 1)
 275  64C2               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 276  64C2              CMDS_M:
 277  64C2               IF (VRAM_CMDS == 1)
 278  64C2 4D 45 4D 56      DB "MEMVRM", 0
 278  64C6 52 4D 00
 279  64C9 FB 59            DW MEMVRM
 280  64CB               ENDIF
 281  64CB               IF (RAM_CMDS == 1)
 282  64CB 4D 45 4D 43  	DB "MEMCPY", 0
 282  64CF 50 59 00
 283  64D2 39 58        	DW MEMCPY
 284  64D4               ENDIF
 285  64D4               IF (ANIM_CMDS == 1)
 286  64D4 4D 41 58 41  	DB "MAXANIMITEMS",0
 286  64D8 4E 49 4D 49
 286  64DC 54 45 4D 53
 286  64E0 00
 287  64E1 A7 4F        	DW MAXANIMITEMS
 288  64E3 4D 41 58 41  	DB "MAXANIMDEFS",0
 288  64E7 4E 49 4D 44
 288  64EB 45 46 53 00
 289  64EF 37 51        	DW MAXANIMDEFS
 290  64F1 4D 41 58 41  	DB "MAXANIMSPRS",0
 290  64F5 4E 49 4D 53
 290  64F9 50 52 53 00
 291  64FD CD 51        	DW MAXANIMSPRS
 292  64FF 4D 41 58 41     DB "MAXAUTOSGAMS",0
 292  6503 55 54 4F 53
 292  6507 47 41 4D 53
 292  650B 00
 293  650C 17 53           DW MAXAUTOSGAMS
 294  650E               ENDIF
 295  650E               ENDIF
 296  650E
 297  650E               IF (VRAM_CMDS + RAM_CMDS > 0)
 298  650E              CMDS_F:
 299  650E               IF (VRAM_CMDS == 1)
 300  650E 46 49 4C 56      DB "FILVRM", 0
 300  6512 52 4D 00
 301  6515 AC 59            DW FILVRM
 302  6517               ENDIF
 303  6517               IF (RAM_CMDS == 1)
 304  6517 46 49 4C 52      DB "FILRAM", 0
 304  651B 41 4D 00
 305  651E 7C 58            DW FILRAM
 306  6520               ENDIF
 307  6520               ENDIF
 308  6520
 309  6520               IF (GENCAL_CMD > 0)
 310  6520              CMDS_G:
 311  6520               IF (GENCAL_CMD == 1)
 312  6520 47 45 4E 43      DB "GENCAL", 0
 312  6524 41 4C 00
 313  6527 E8 5A            DW GENCAL
 314  6529               ENDIF
 315  6529               ENDIF
 316  6529
 317  6529               IF (VRAM_CMDS > 0)
 318  6529              CMDS_V:
 319  6529               IF (VRAM_CMDS == 1)
 320  6529 56 52 4D 4D  	DB "VRMMEM", 0
 320  652D 45 4D 00
 321  6530 88 5A        	DW VRMMEM
 322  6532               ENDIF
 323  6532               IF (DECOMP_CMDS == 1)
 324  6532 56 55 4E 50  	DB "VUNPACK", 0
 324  6536 41 43 4B 00
 325  653A C1 62        	DW VUNPACK
 326  653C               ENDIF
 327  653C               ENDIF
 328  653C
 329  653C               IF (SOUND_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 330  653C              CMDS_S:
 331  653C               IF (SPRITE_CMDS + ANIM_CMDS > 0)
 332  653C 53 47 41 4D      DB "SGAM",0
 332  6540 00
 333  6541 A5 56            DW SGAM
 334  6543               ENDIF
 335  6543               IF (SPRITE_CMDS == 1)
 336  6543 53 50 52 47  	DB "SPRGRPMOV", 0
 336  6547 52 50 4D 4F
 336  654B 56 00
 337  654D FF 4E        	DW SPRGRPMOV
 338  654F               ENDIF
 339  654F               IF (SOUND_CMDS == 1)
 340  654F 53 4E 44 53  	DB "SNDSFX", 0
 340  6553 46 58 00
 341  6556 52 59        	DW SNDSFX
 342  6558 53 4E 44 50  	DB "SNDPLYON", 0
 342  655C 4C 59 4F 4E
 342  6560 00
 343  6561 1C 59        	DW SNDPLYON
 344  6563 53 4E 44 50  	DB "SNDPLYOFF", 0
 344  6567 4C 59 4F 46
 344  656B 46 00
 345  656D 2E 59        	DW SNDPLYOFF
 346  656F 53 4E 44 50  	DB "SNDPLYINI", 0
 346  6573 4C 59 49 4E
 346  6577 49 00
 347  6579 D2 58        	DW SNDPLYINIT
 348  657B               ENDIF
 349  657B               IF (SPRITE_CMDS == 1)
 350  657B 53 50 52 45  	DB "SPRENABLE", 0
 350  657F 4E 41 42 4C
 350  6583 45 00
 351  6585 75 4E        	DW SPRENABLE
 352  6587 53 50 52 44  	DB "SPRDISABLE", 0
 352  658B 49 53 41 42
 352  658F 4C 45 00
 353  6592 BC 4E        	DW SPRDISABLE
 354  6594               ENDIF
 355  6594               ENDIF
 356  6594
 357  6594               IF (BLIT_CMDS + BOX_CMDS > 0)
 358  6594              CMDS_B:
 359  6594               IF (BLIT_CMDS == 1)
 360  6594 42 4C 49 54  	DB "BLIT", 0
 360  6598 00
 361  6599 CA 5D        	DW BLIT
 362  659B               ENDIF
 363  659B               IF (BOX_CMDS == 1)
 364  659B 42 4F 58 4D  	DB "BOXMEMCPY", 0
 364  659F 45 4D 43 50
 364  65A3 59 00
 365  65A5 78 5B        	DW BOXMEMCPY
 366  65A7 42 4F 58 4D  	DB "BOXMEMVRM", 0
 366  65AB 45 4D 56 52
 366  65AF 4D 00
 367  65B1 0E 5C        	DW BOXMEMVRM
 368  65B3               ENDIF
 369  65B3               ENDIF
 370  65B3
 371  65B3               IF (TILE_CMDS > 0)
 372  65B3              CMDS_T:
 373  65B3               IF (TILE_CMDS == 1)
 374  65B3 54 49 4C 45  	DB "TILERAM", 0
 374  65B7 52 41 4D 00
 375  65BB F1 5E        	DW TILERAM
 376  65BD 54 49 4C 45  	DB "TILEVRM", 0
 376  65C1 56 52 4D 00
 377  65C5 F5 5F        	DW TILEVRM
 378  65C7               ENDIF
 379  65C7               ENDIF
 380  65C7
 381  65C7               IF (COLL_CMD > 0)
 382  65C7              CMDS_C:
 383  65C7               IF (COLL_CMD == 1)
 384  65C7 43 4F 4C 4C      DB "COLL", 0
 384  65CB 00
 385  65CC C2 61            DW COLL
 386  65CE               ENDIF
 387  65CE               ENDIF
 388  65CE
 389  65CE               IF (DECOMP_CMDS > 0)
 390  65CE              CMDS_U:
 391  65CE               IF (DECOMP_CMDS == 1)
 392  65CE 55 4E 50 41      DB "UNPACK", 0
 392  65D2 43 4B 00
 393  65D5 D9 62            DW UNPACK
 394  65D7               ENDIF
 395  65D7               ENDIF
 396  65D7
 397  65D7               IF (DLOAD_CMD > 0)
 398  65D7              CMDS_D:
 399  65D7               IF (DLOAD_CMD == 1)
 400  65D7 44 4C 4F 41      DB "DLOAD", 0
 400  65DB 44 00
 401  65DD 2C 64            DW DLOAD
 402  65DF               ENDIF
 403  65DF               ENDIF
 404  65DF
 405  65DF              CMDS_A:
 406  65DF               IF (ANIM_CMDS == 1)
 407  65DF 41 4E 49 4D     DB "ANIMSTEP",0
 407  65E3 53 54 45 50
 407  65E7 00
 408  65E8 E7 54           DW ANIMSTEP
 409  65EA 41 4E 49 4D  	DB "ANIMSTART",0
 409  65EE 53 54 41 52
 409  65F2 54 00
 410  65F4 EC 54        	DW ANIMSTART
 411  65F6 41 4E 49 4D  	DB "ANIMSTOP",0
 411  65FA 53 54 4F 50
 411  65FE 00
 412  65FF F1 54        	DW ANIMSTOP
 413  6601 41 4E 49 4D  	DB "ANIMITEMPAT",0
 413  6605 49 54 45 4D
 413  6609 50 41 54 00
 414  660D 78 50        	DW ANIMITEMPAT
 415  660F 41 4E 49 4D  	DB "ANIMITEMPTR",0
 415  6613 49 54 45 4D
 415  6617 50 54 52 00
 416  661B DE 50        	DW ANIMITEMPTR_CMD
 417  661D 41 4E 49 4D  	DB "ANIMDEF",0
 417  6621 44 45 46 00
 418  6625 7A 51        	DW ANIMDEF
 419  6627 41 4E 49 4D  	DB "ANIMSPRITE",0
 419  662B 53 50 52 49
 419  662F 54 45 00
 420  6632 26 52        	DW ANIMSPRITE
 421  6634 41 4E 49 4D     DB "ANIMCHAR",0
 421  6638 43 48 41 52
 421  663C 00
 422  663D 9E 52           DW ANIMCHAR
 423  663F 41 55 54 4F     DB "AUTOSGAMDEF",0
 423  6643 53 47 41 4D
 423  6647 44 45 46 00
 424  664B 74 53           DW AUTOSGAMDEF
 425  664D 41 55 54 4F     DB "AUTOSGAMSTART",0
 425  6651 53 47 41 4D
 425  6655 53 54 41 52
 425  6659 54 00
 426  665B A8 54           DW AUTOSGAMSTART
 427  665D 41 55 54 4F     DB "AUTOSGAMSTOP",0
 427  6661 53 47 41 4D
 427  6665 53 54 4F 50
 427  6669 00
 428  666A E4 54           DW AUTOSGAMSTOP
 429  666C               ENDIF
 430  666C 41 52 54 49     DB "ARTINFO",0
 430  6670 4E 46 4F 00
 431  6674 43 68           DW ARTINFO
 432  6676 00           	DB 0
 433  6677               ELSE // if not BASIC extension
 434  6677 ~            CMDS_A:
 435  6677 ~               DB "ARTINFO",0
 436  6677 ~               DW ARTINFO
 437  6677 ~            	DB 0
 438  6677               ENDIF
 439  6677
 440  6677               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 441  6677              ; ****************************************************************************************************
 442  6677              ; function sets VRAM address for writing
 443  6677              ; input HL=address
 444  6677              ; modifies AF
 445  6677              SETWRT_LOCAL_WRITE:
 446  6677 7D           	LD	A,L
 447  6678 D3 99        	OUT (#99),A
 448  667A 7C           	LD	A,H
 449  667B E6 3F        	AND #3F
 450  667D F6 40        	OR	#40
 451  667F D3 99        	OUT (#99),A
 452  6681 C9           	RET
 453  6682              ; ****************************************************************************************************
 454  6682
 455  6682              ; ****************************************************************************************************
 456  6682              ; function sets VRAM address for reading
 457  6682              ; input HL=address
 458  6682              ; modifies AF
 459  6682              SETWRT_LOCAL_READ:
 460  6682 7D           	LD	A,L
 461  6683 D3 99        	OUT (#99),A
 462  6685 7C           	LD	A,H
 463  6686 E6 3F        	AND #3F
 464  6688 00              NOP
 465  6689 D3 99        	OUT (#99),A
 466  668B C9           	RET
 467  668C              ; ****************************************************************************************************
 468  668C               ENDIF
 469  668C
 470  668C               IF (VRAM_CMDS + TILE_CMDS > 0)
 471  668C              ; ****************************************************************************************************
 472  668C              ; function copies data from RAM to VRAM
 473  668C              ; input HL=address in RAM
 474  668C              ; input B=count
 475  668C              ; modifies AF, BC, HL
 476  668C              BBYTECOPY:
 477  668C 0E 98        	LD C,#98
 478  668E              BBYTECOPY_NO_C:
 479  668E ED A3        	OUTI
 480  6690 C2 8E 66     	JP	NZ, BBYTECOPY_NO_C
 481  6693 C9           	RET
 482  6694              ; ****************************************************************************************************
 483  6694               ENDIF
 484  6694
 485  6694              ; ****************************************************************************************************
 486  6694              ; function multiplies HL by 32
 487  6694              HLx32:
 488  6694 29           	ADD HL,HL
 489  6695              ; ****************************************************************************************************
 490  6695              ; function multiplies HL by 16
 491  6695              HLx16:
 492  6695 29           	ADD HL,HL
 493  6696              ; ****************************************************************************************************
 494  6696              ; function multiplies HL by 8
 495  6696              HLx8:
 496  6696 29          > ADD HL, HL
 496  6697 29          > ADD HL, HL
 496  6698 29          > ADD HL, HL
 497  6699 C9           	RET
 498  669A              ; ****************************************************************************************************
 499  669A
 500  669A              ; ****************************************************************************************************
 501  669A              ; function gets slot and subslot data for specific page
 502  669A              ; input A=page (0, 1 or 2)
 503  669A              ; output B = 0A8H register value
 504  669A              ; output D = 0 is no subslots, 1 if yes
 505  669A              ; output C = 0A8H value when page 3 slot equals to requested page slot
 506  669A              ; output E = subslot value if present
 507  669A              ; modifies AF, BC, DE, HL
 508  669A              GET_PAGE_INFO:
 509  669A 6F               LD L, A
 510  669B C6 C1            ADD A, low (EXPTBL)
 511  669D 32 A7 66         LD (GET_PAGE_INFO_L1+1), A
 512  66A0 DB A8            IN A, (0A8H)
 513  66A2 47               LD B, A
 514  66A3 E6 3F            AND 03FH
 515  66A5 4F               LD C, A
 516  66A6              GET_PAGE_INFO_L1:
 517  66A6 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 518  66A9 E6 80            AND 080H
 519  66AB 28 1B            JR Z, GET_PAGE_INFO_L2
 520  66AD                  ; expanded
 521  66AD 2D               DEC L
 522  66AE FA CD 66         JP M, GET_PAGE_INFO_L3
 523  66B1 2D               DEC L
 524  66B2 FA CB 66         JP M, GET_PAGE_INFO_L4
 525  66B5                  ; page 2
 526  66B5 07               RLCA
 527  66B6 07               RLCA
 528  66B7              GET_PAGE_INFO_L5:
 529  66B7 E6 C0            AND 0C0H
 530  66B9 B1               OR C
 531  66BA D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 532  66BC 4F               LD C, A
 533  66BD 3A FF FF         LD A, (0FFFFH)
 534  66C0 2F               CPL
 535  66C1 5F               LD E, A
 536  66C2 16 01            LD D, 1
 537  66C4 78               LD A, B ; return stack
 538  66C5 D3 A8            OUT (0A8H), A
 539  66C7 C9               RET
 540  66C8              GET_PAGE_INFO_L2:
 541  66C8                  ; not expanded
 542  66C8 16 00            LD D, 0
 543  66CA C9               RET
 544  66CB              GET_PAGE_INFO_L4:
 545  66CB                  ; page 1
 546  66CB 0F               RRCA
 547  66CC 0F               RRCA
 548  66CD              GET_PAGE_INFO_L3:
 549  66CD                  ; page 0
 550  66CD 0F               RRCA
 551  66CE 0F               RRCA
 552  66CF 18 E6            JR GET_PAGE_INFO_L5
 553  66D1              ; ****************************************************************************************************
 554  66D1
 555  66D1              ; ****************************************************************************************************
 556  66D1              ; function returns original slot and subslot info
 557  66D1              ; input B = 0A8H register value
 558  66D1              ; input D = 0 is no subslots, 1 if yes
 559  66D1              ; input C = 0A8H value when page 3 slot equals to requested page slot
 560  66D1              ; input E = subslot value if present
 561  66D1              ; modifies AF, disables interrupts
 562  66D1              RESTORE_PAGE_INFO:
 563  66D1 F3              DI
 564  66D2 7A              LD A, D
 565  66D3 B7              OR A
 566  66D4 28 07           JR Z, RESTORE_PAGE_INFO_L1
 567  66D6 79              LD A, C
 568  66D7 D3 A8           OUT (0A8H), A
 569  66D9 7B              LD A, E
 570  66DA 32 FF FF        LD (0FFFFH), A
 571  66DD              RESTORE_PAGE_INFO_L1:
 572  66DD 78              LD A, B
 573  66DE D3 A8           OUT (0A8H), A
 574  66E0              NOACTION_DEFUSR: ; just a safe RET for use when DEFUSR table has an empty entry
 575  66E0 C9              RET
 576  66E1              ; ****************************************************************************************************
 577  66E1
 578  66E1              ; *******************************************************************************************************
 579  66E1              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 580  66E1              ; INPUT:  A = SLOT ID: EXXXSSPP
 581  66E1              ; E = EXPANDED FLAG
 582  66E1              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 583  66E1              ; PP = PRIMARY SLOT NUMBER
 584  66E1              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 585  66E1              ; CHANGES: AF, BC, DE
 586  66E1
 587  66E1              LOCAL_ENASLT:
 588  66E1 CD 01 67         CALL L0353
 589  66E4 FA EE 66         JP M, L0340
 590  66E7 DB A8            IN A, (0A8H)
 591  66E9 A1               AND C
 592  66EA B0               OR B
 593  66EB D3 A8            OUT (0A8H), A
 594  66ED C9               RET
 595  66EE              L0340:
 596  66EE E5               PUSH HL
 597  66EF CD 26 67         CALL L0378
 598  66F2 4F               LD C, A
 599  66F3 06 00            LD B, 0
 600  66F5 7D               LD A, L
 601  66F6 A4               AND H
 602  66F7 B2               OR D
 603  66F8 21 C5 FC         LD HL, 0FCC5H
 604  66FB 09               ADD HL, BC
 605  66FC 77               LD (HL), A
 606  66FD E1               POP HL
 607  66FE 79               LD A, C
 608  66FF 18 E0            JR LOCAL_ENASLT
 609  6701              L0353:
 610  6701 F3               DI
 611  6702 F5               PUSH AF
 612  6703 7C               LD A, H
 613  6704 07               RLCA
 614  6705 07               RLCA
 615  6706 E6 03            AND 3
 616  6708 5F               LD E, A
 617  6709 3E C0            LD A, 0C0H
 618  670B              L035D:
 619  670B 07               RLCA
 620  670C 07               RLCA
 621  670D 1D               DEC E
 622  670E F2 0B 67         JP P, L035D
 623  6711 5F               LD E, A
 624  6712 2F               CPL
 625  6713 4F               LD C, A
 626  6714 F1               POP AF
 627  6715 F5               PUSH AF
 628  6716 E6 03            AND 3
 629  6718 3C               INC A
 630  6719 47               LD B, A
 631  671A 3E AB            LD A, 0ABH
 632  671C              L036E:
 633  671C C6 55            ADD A, 055H
 634  671E 10 FC            DJNZ L036E
 635  6720 57               LD D, A
 636  6721 A3               AND E
 637  6722 47               LD B, A
 638  6723 F1               POP AF
 639  6724 A7               AND A
 640  6725 C9               RET
 641  6726              L0378:
 642  6726 F5               PUSH AF
 643  6727 7A               LD A, D
 644  6728 E6 C0            AND 0C0H
 645  672A 4F               LD C, A
 646  672B F1               POP AF
 647  672C F5               PUSH AF
 648  672D 57               LD D, A
 649  672E DB A8            IN A, (0A8H)
 650  6730 47               LD B, A
 651  6731 E6 3F            AND 03FH
 652  6733 B1               OR C
 653  6734 D3 A8            OUT (0A8H), A
 654  6736 7A               LD A, D
 655  6737 0F               RRCA
 656  6738 0F               RRCA
 657  6739 E6 03            AND 3
 658  673B 57               LD D, A
 659  673C 3E AB            LD A, 0ABH
 660  673E              L0390:
 661  673E C6 55            ADD A, 055H
 662  6740 15               DEC D
 663  6741 F2 3E 67         JP P, L0390
 664  6744 A3               AND E
 665  6745 57               LD D, A
 666  6746 7B               LD A, E
 667  6747 2F               CPL
 668  6748 67               LD H, A
 669  6749 3A FF FF         LD A, (0FFFFH)
 670  674C 2F               CPL
 671  674D 6F               LD L, A
 672  674E A4               AND H
 673  674F B2               OR D
 674  6750 32 FF FF         LD (0FFFFH), A
 675  6753 78               LD A, B
 676  6754 D3 A8            OUT (0A8H), A
 677  6756 F1               POP AF
 678  6757 E6 03            AND 3
 679  6759 C9               RET
 680  675A              ; *******************************************************************************************************
 681  675A
 682  675A              ; *******************************************************************************************************
 683  675A              ; some common code to activate page 0 and place values needed to restore original page on stack
 684  675A              ; input IY=return address
 685  675A              ENABLE_PAGE0:
 686  675A F3              DI
 687  675B AF              XOR A
 688  675C CD 9A 66        CALL GET_PAGE_INFO
 689  675F C5              PUSH BC
 690  6760 D5              PUSH DE
 691  6761 3A 41 F3        LD A, (RAMAD0)
 692  6764 26 00           LD H, 0
 693  6766 CD E1 66        CALL LOCAL_ENASLT
 694  6769 FD E9        	JP (IY)
 695  676B              ; *******************************************************************************************************
 696  676B
 697  676B              ; General BASIC CALL-instruction handler
 698  676B              CALLHAND:
 699  676B FB              EI
 700  676C E5           	PUSH HL
 701  676D 21 8E 64     	LD	HL, CMDS ; pointer table based on starting letter
 702  6770 3A 89 FD        LD A, (PROCNM)
 703  6773 D6 41           SUB 'A'
 704  6775 87              ADD A, A
 705  6776 16 00           LD D, 0
 706  6778 5F              LD E, A
 707  6779 19              ADD HL, DE
 708  677A 5E              LD E, (HL)
 709  677B 23              INC HL
 710  677C 56              LD D, (HL)
 711  677D 7A              LD A, D
 712  677E B3              OR E
 713  677F 28 23           JR Z, .CMDNOTRECOGNIZED
 714  6781 EB              EX DE, HL
 715  6782              .CHKCMD:
 716  6782 11 89 FD     	LD	DE, PROCNM
 717  6785              .LOOP:
 718  6785 1A              LD	A,(DE)
 719  6786 BE           	CP	(HL)
 720  6787 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 721  6789 13           	INC	DE
 722  678A 23           	INC	HL
 723  678B A7           	AND	A
 724  678C 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 725  678E 5E           	LD	E,(HL)
 726  678F 23           	INC	HL
 727  6790 56           	LD	D,(HL)
 728  6791 E1           	POP	HL		; routine address
 729  6792 CD B3 67     	CALL	GETPREVCHAR
 730  6795 CD A7 67     	CALL	.CALLDE		; Call routine
 731  6798 A7           	AND	A
 732  6799 C9           	RET
 733  679A
 734  679A              .TONEXTCMD:
 735  679A 0E FF        	LD	C,0FFH
 736  679C AF           	XOR	A
 737  679D ED B1        	CPIR			; Skip to end of instruction name
 738  679F 23           	INC	HL
 739  67A0 23           	INC	HL		; Skip address
 740  67A1 BE           	CP	(HL)
 741  67A2 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 742  67A4              .CMDNOTRECOGNIZED:
 743  67A4 E1           	POP	HL
 744  67A5 37              SCF
 745  67A6 C9           	RET
 746  67A7
 747  67A7              .CALLDE:
 748  67A7 D5           	PUSH	DE
 749  67A8 C9           	RET
 750  67A9
 751  67A9              ;---------------------------
 752  67A9
 753  67A9              CHKCHAR:
 754  67A9 CD B3 67     	CALL	GETPREVCHAR	; Get previous basic char
 755  67AC E3           	EX	(SP),HL
 756  67AD BE           	CP	(HL) 	        ; Check if good char
 757  67AE 20 29        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 758  67B0 23           	INC	HL
 759  67B1 E3           	EX	(SP),HL
 760  67B2 23           	INC	HL		; Get next basic char
 761  67B3
 762  67B3              GETPREVCHAR:
 763  67B3 2B           	DEC HL
 764  67B4 DD 21 66 46  	LD	IX,CHRGTR
 765  67B8 CD 59 01     	CALL CALBAS
 766  67BB FB              EI
 767  67BC C9              RET
 768  67BD
 769  67BD               IF (1 == 1)
 770  67BD               IF (DLOAD_CMD == 1)
 771  67BD              BAD_FILENAME:
 772  67BD 1E 38           LD E,56
 773  67BF 18 1A           JR THROW_ERROR
 774  67C1              DISKIOERR:
 775  67C1 1E 45           LD E,69
 776  67C3 18 16           JR THROW_ERROR
 777  67C5               ENDIF
 778  67C5              OUT_OF_DATA:
 779  67C5 1E 04           LD E, 4
 780  67C7 18 12           JR THROW_ERROR
 781  67C9              TYPE_MISMATCH:
 782  67C9 1E 0D           LD E, 13 ; Type mismatch
 783  67CB 18 0E           JR THROW_ERROR
 784  67CD              SUBSCRIPT_OUT_OF_RANGE:
 785  67CD 1E 09           LD E,9 ; subscript out of range
 786  67CF 18 0A        	JR THROW_ERROR
 787  67D1              OVERFLOW:
 788  67D1 1E 06        	LD E,6
 789  67D3 18 06        	JR THROW_ERROR
 790  67D5              ILLEGAL_FUNCTION:
 791  67D5 1E 05           LD E, 5 ; illegal function call
 792  67D7 18 02           JR THROW_ERROR
 793  67D9               ENDIF
 794  67D9              SYNTAX_ERROR:
 795  67D9 1E 02           LD E, 2 ; Syntax error
 796  67DB              THROW_ERROR:
 797  67DB DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 798  67DF C3 59 01     	JP	CALBAS
 799  67E2
 800  67E2
 801  67E2              ;---------------------------
 802  67E2
 803  67E2               IF (DLOAD_CMD == 1)
 804  67E2              ; *******************************************************************************************************
 805  67E2              ; helper function to make an uppercase letter
 806  67E2              ; input A=character
 807  67E2              ; output A=uppercase version of input
 808  67E2              UPPER:
 809  67E2 FE 61           CP "a"
 810  67E4 D8              RET C
 811  67E5 FE 7B           CP "z"+1
 812  67E7 D0              RET NC
 813  67E8 E6 5F           AND 5FH
 814  67EA C9              RET
 815  67EB              ; *******************************************************************************************************
 816  67EB               ENDIF
 817  67EB
 818  67EB               IF (1 == 1)
 819  67EB
 820  67EB               IF (DLOAD_CMD == 1)
 821  67EB              ; *******************************************************************************************************
 822  67EB              ; helper function to return string pointer and length
 823  67EB              ; returns HL = String Address
 824  67EB              ; returns B  = Lenght
 825  67EB              ; modifies BC, DE, HL
 826  67EB              GETSTRPNT:
 827  67EB 2A F8 F7        LD      HL,(USR)
 828  67EE 46              LD      B,(HL)
 829  67EF 23              INC     HL
 830  67F0 5E              LD      E,(HL)
 831  67F1 23              INC     HL
 832  67F2 56              LD      D,(HL)
 833  67F3 EB              EX      DE,HL
 834  67F4 C9              RET
 835  67F5              ; *******************************************************************************************************
 836  67F5
 837  67F5              ; *******************************************************************************************************
 838  67F5              ; helper function to get string parameter
 839  67F5              ; throws error if incorrect type
 840  67F5              ; input HL=basic text
 841  67F5              EVALTXTPARAM:
 842  67F5 DD 21 64 4C  	LD	IX,FRMEVL
 843  67F9 CD 59 01     	CALL CALBAS		; Evaluate expression
 844  67FC 3A 63 F6        LD A,(VALTYP)
 845  67FF FE 03           CP 3               ; Text type?
 846  6801 C2 C9 67        JP NZ,TYPE_MISMATCH
 847  6804 E5              PUSH HL
 848  6805 DD 21 D0 67     LD	IX,FRESTR         ; Free the temporary string
 849  6809 CD 59 01        CALL CALBAS
 850  680C E1              POP HL
 851  680D C9              RET
 852  680E              ; *******************************************************************************************************
 853  680E
 854  680E               ENDIF
 855  680E
 856  680E              ; *******************************************************************************************************
 857  680E              ; helper function to get pointer to BASIC array data
 858  680E              ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
 859  680E              ; input B=dimensions (1 or 2)
 860  680E              ; input D=minimal first dimension
 861  680E              ; input E=minimal second dimension, if applicable
 862  680E              ; returns BC=pointer to first data element
 863  680E              ; throws BASIC error if invalid type
 864  680E              GET_BASIC_ARRAY_DATA_POINTER:
 865  680E D5           	PUSH DE
 866  680F C5           	PUSH BC
 867  6810 F5           	PUSH AF
 868  6811 3E 01           LD A,1
 869  6813 32 A5 F6        LD (SUBFLG),A ; search for arrays only
 870  6816 DD 21 A4 5E  	LD IX, PTRGET
 871  681A CD 59 01     	CALL CALBAS
 872  681D AF              XOR A
 873  681E 32 A5 F6        LD (SUBFLG),A ; if not reset will cause syntax errors
 874  6821 3A 63 F6     	LD A,(VALTYP)
 875  6824 D1           	POP DE ; required type
 876  6825 BA           	CP D
 877  6826 C2 C9 67     	JP NZ,TYPE_MISMATCH
 878  6829 0A           	LD A,(BC)
 879  682A 03           	INC BC
 880  682B D1           	POP DE ; required number of dimensions
 881  682C BA           	CP D
 882  682D C2 C9 67     	JP NZ,TYPE_MISMATCH
 883  6830 D1           	POP DE ; required minimal array dimensions
 884  6831 3D           	DEC A
 885  6832 28 07        	JR Z,.ONE_DIMENSION
 886  6834              	; 2-dimension array
 887  6834 0A           	LD A,(BC)
 888  6835 03          > INC BC
 888  6836 03          > INC BC
 889  6837 BB           	CP E
 890  6838 DA CD 67     	JP C,SUBSCRIPT_OUT_OF_RANGE
 891  683B              .ONE_DIMENSION:
 892  683B 0A           	LD A,(BC)
 893  683C 03          > INC BC
 893  683D 03          > INC BC
 894  683E BA           	CP D
 895  683F DA CD 67     	JP C,SUBSCRIPT_OUT_OF_RANGE
 896  6842 C9           	RET
 897  6843              ; *******************************************************************************************************
 898  6843               ENDIF
 899  6843
 900  6843              ; *******************************************************************************************************
 901  6843              ; function to handle CALL ARTINFO basic extension
 902  6843              ; returns info about the extension
 903  6843              ; _ARTINFO ( INT variable version,
 904  6843              ;			    INT variable build_flags,
 905  6843              ;			    INT variable free_memory_ptr )
 906  6843              ; this function is always available and can be used to test if the extension is active
 907  6843              ARTINFO:
 908  6843              	; opening (
 909  6843 CD A9 67     	CALL CHKCHAR
 910  6846 28           	DB '('
 911  6847              	; get address of version variable
 912  6847 DD 21 A4 5E  	LD IX, PTRGET
 913  684B CD 59 01     	CALL CALBAS
 914  684E 3A 12 40     	LD A,(VERSION)
 915  6851 12              LD (DE),A
 916  6852 13              INC DE
 917  6853 3A 13 40        LD A,(VERSION+1)
 918  6856 12              LD (DE),A
 919  6857              	; comma
 920  6857 CD A9 67     	CALL CHKCHAR
 921  685A 2C           	DB ','
 922  685B              	; get address of build flags variable
 923  685B DD 21 A4 5E  	LD IX, PTRGET
 924  685F CD 59 01     	CALL CALBAS
 925  6862 E5              PUSH HL
 926  6863 21 FF 37        LD HL,SOUND_CMDS+2*RAM_CMDS+4*VRAM_CMDS+8*BLIT_CMDS+16*SPRITE_CMDS+32*GENCAL_CMD+64*TILE_CMDS+128*BOX_CMDS+256*ANIM_CMDS+512*COLL_CMD+1024*1+2048*0+4096*DECOMP_CMDS+8192*DLOAD_CMD
 927  6866 EB              EX DE,HL
 928  6867 73              LD (HL),E
 929  6868 23              INC HL
 930  6869 72              LD (HL),D
 931  686A E1              POP HL
 932  686B              	; comma
 933  686B CD A9 67     	CALL CHKCHAR
 934  686E 2C           	DB ','
 935  686F              	; get address of free memory variable
 936  686F DD 21 A4 5E  	LD IX, PTRGET
 937  6873 CD 59 01     	CALL CALBAS
 938  6876 3A 10 40     	LD A,(FREEMEMPTR)
 939  6879 12              LD (DE),A
 940  687A 13              INC DE
 941  687B 3A 11 40        LD A,(FREEMEMPTR+1)
 942  687E 12              LD (DE),A
 943  687F              	; ending )
 944  687F CD A9 67     	CALL CHKCHAR
 945  6882 29           	DB ')'
 946  6883 C9           	RET
 947  6884              ; *******************************************************************************************************
 948  6884
 949  6884              EXT_END:
 950  6884
# file closed: asm\main.asm
