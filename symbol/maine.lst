# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		   EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000              COLL_CMD       EQU 1
  14  4000              DECOMP_CMDS    EQU 1
  15  4000              DLOAD_CMD      EQU 1
  16  4000
  17  4000              ; what to compile, provided in sjasmplus command line
  18  4000              ;BASIC_EXTENSION   EQU 1
  19  4000              ;DEFUSR_EXTENSION  EQU 0
  20  4000
  21  4000              CHPUT   EQU    #A2
  22  4000              CALBAS  EQU		#159
  23  4000              ERRHAND EQU    #406F
  24  4000              FRMEVL  EQU    #4C64
  25  4000              FRESTR  EQU		#67D0
  26  4000              ; FRMQNT = formula quantificator
  27  4000              ; input HL=pointer to current program expression
  28  4000              ; output HL=next address
  29  4000              ; output DE=integer datum
  30  4000              FRMQNT	EQU		#542F
  31  4000              ; GETBYT = get byte parameter
  32  4000              ; input HL=pointer to current program expression
  33  4000              ; output HL=next address
  34  4000              ; output A=E=byte read
  35  4000              GETBYT		EQU	#521C
  36  4000              CHRGTR  	   EQU   #4666
  37  4000              PTRGET		EQU 	#5EA4
  38  4000              SUBFLG		EQU	#F6A5
  39  4000              SYNCHR		EQU	#558C
  40  4000              VALTYP  	   EQU   #F663
  41  4000              DAC         EQU   #F7F6
  42  4000              USR     	   EQU   #F7F8
  43  4000              PROCNM		EQU	#FD89
  44  4000              BIOS_FILVRM EQU   #0056
  45  4000              CLIKSW		EQU	#F3DB
  46  4000
  47  4000              RAMAD0	   EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  48  4000              RAMAD1	   EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  49  4000              RAMAD2	   EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  50  4000              RAMAD3	   EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  51  4000              EXPTBL	   EQU   #FCC1
  52  4000              SCRMOD	   EQU   #FCAF ; current screen mode
  53  4000              REG1SAV     EQU   #F3E0 ; VDP(1)
  54  4000              JIFFY	      EQU   #FC9E
  55  4000              GRPPAT	   EQU   #F3CF ; SCREEN 2 sprite generator table address
  56  4000              GRPCGP		EQU	#F3CB ; SCREEN 2 pattern generator table address
  57  4000              GRPATR      EQU   #F3CD ; SCREEN 2 sprite attribute table address
  58  4000              T32PAT	   EQU   #F3C5 ; SCREEN 1 sprite generator table address
  59  4000              T32CGP      EQU   #F3C1 ; SCREEN 1 pattern ganarator table address
  60  4000              T32ATR      EQU   #F3C3 ; SCREEN 1 sprite attribute table address
  61  4000
  62  4000              FCB0        EQU   #F23D ; location of FCB 0
  63  4000
  64  4000              ; BASIC error codes
  65  4000              ;01 NEXT without FOR
  66  4000              ;02 Syntax error
  67  4000              ;03 RETURN without GOSUB
  68  4000              ;04 Out of DATA
  69  4000              ;05 Illegal function call
  70  4000              ;06 Overflow
  71  4000              ;07 Out of memory
  72  4000              ;08 Undefined line number
  73  4000              ;09 Subscript out of range
  74  4000              ;10 Redimensioned array
  75  4000              ;11 Division by zero
  76  4000              ;12 Illegal direct
  77  4000              ;13 Type mismatch
  78  4000              ;14 Out of string space
  79  4000              ;15 String too long
  80  4000              ;16 String formula too complex
  81  4000              ;17 Can't CONTINUE
  82  4000              ;18 Undefined user function
  83  4000              ;19 Device I/O error
  84  4000              ;20 Verify error
  85  4000              ;21 No RESUME
  86  4000              ;22 RESUME without error
  87  4000              ;23 Unprintable error
  88  4000              ;24 Missing operand
  89  4000              ;25 Line buffer overflow
  90  4000              ;50 FIELD overflow
  91  4000              ;51 Internal error
  92  4000              ;52 Bad file number
  93  4000              ;53 File not found
  94  4000              ;54 File already open
  95  4000              ;55 Input past end
  96  4000              ;56 Bad file name
  97  4000              ;57 Direct statement in file
  98  4000              ;58 Sequential I/O only
  99  4000              ;59 File not OPEN
 100  4000
 101  4000
 102  4000               ; simulate cartridge with BASIC extension
 103  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
 103  4004 29 66 00 00
 103  4008 00 00 00 00
 103  400C 00 00 00 00
 104  4010
 105  4010              ; this location #4010 stores last location used by basic extension
 106  4010              ; free memory after that point
 107  4010              FREEMEMPTR:
 108  4010 36 67         DW EXT_END
 109  4012
 110  4012              ; this location #4012 stores extension version in DAA format
 111  4012              ; first byte is major version and second minor
 112  4012              VERSION:
 113  4012 00 92         DB #00, #92
 114  4014
 115  4014              ; this location #4014 contains a jump to entry point for DEFUSR approach
 116  4014              ; if excluded it contains 3xRET so that sound player can be at aspecific spot
 117  4014               IF (0 == 1)
 118  4014 ~               JP DEFUSR_ENTRY
 119  4014               ELSE
 120  4014 C9          > RET
 120  4015 C9          > RET
 120  4016 C9          > RET
 121  4017               ENDIF
 122  4017
 123  4017              ; binary included AKG player compiled at #4017
 124  4017               IF (SOUND_CMDS == 1)
 125  4017              	INCBIN "bin/AKG.bin"
 126  4CF3              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF3              MAIN_PLAYER_START EQU 04017H
   2+ 4CF3              PLY_AKG_START EQU 04017H
   3+ 4CF3              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 04020H
   4+ 4CF3              PLY_AKG_INITSOUNDEFFECTS EQU 04020H
   5+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04024H
   6+ 4CF3              PLY_AKG_PLAYSOUNDEFFECT EQU 04024H
   7+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04025H
   8+ 4CF3              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04025H
   9+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 0404CH
  10+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 0404CH
  11+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 0405AH
  12+ 4CF3              PLY_AKG_PSES_PLAY EQU 04093H
  13+ 4CF3              PLY_AKG_PSES_READFIRSTBYTE EQU 0409CH
  14+ 4CF3              PLY_AKG_PSES_S_ENDORLOOP EQU 040B4H
  15+ 4CF3              PLY_AKG_PSES_S_LOOP EQU 040BFH
  16+ 4CF3              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C5H
  17+ 4CF3              PLY_AKG_PSES_NOTREACHED EQU 040D8H
  18+ 4CF3              PLY_AKG_PSES_HARDWAREONLY EQU 040DCH
  19+ 4CF3              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E3H
  20+ 4CF3              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F5H
  21+ 4CF3              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FFH
  22+ 4CF3              PLY_AKG_PSES_H_AFTERRETRIG EQU 04109H
  23+ 4CF3              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411DH
  24+ 4CF3              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 04122H
  25+ 4CF3              PLY_AKG_PSES_READHARDWAREPERIOD EQU 0412AH
  26+ 4CF3              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04135H
  27+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 04141H
  28+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04143H
  29+ 4CF3              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04149H
  30+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414DH
  31+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414DH
  32+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414FH
  33+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414FH
  34+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414FH
  35+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 04150H
  36+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 04151H
  37+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04155H
  38+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04155H
  39+ 4CF3              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04155H
  40+ 4CF3              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415DH
  41+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04165H
  42+ 4CF3              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04165H
  43+ 4CF3              PLY_AKG_INIT EQU 04165H
  44+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04165H
  45+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04193H
  46+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A7H
  47+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B9H
  48+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D8H
  49+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E5H
  50+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL EQU 041EBH
  51+ 4CF3              PLY_AKG_INITTABLE0 EQU 041EEH
  52+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EEH
  53+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04208H
  54+ 4CF3              PLY_AKG_INITTABLE0_END EQU 04208H
  55+ 4CF3              PLY_AKG_INITTABLE1 EQU 04208H
  56+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04208H
  57+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 0420CH
  58+ 4CF3              PLY_AKG_INITTABLE1_END EQU 0420CH
  59+ 4CF3              PLY_AKG_INITTABLEORA EQU 0420CH
  60+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 0420CH
  61+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04224H
  62+ 4CF3              PLY_AKG_INITTABLEORA_END EQU 04224H
  63+ 4CF3              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04224H
  64+ 4CF3              PLY_AKG_STOP EQU 04224H
  65+ 4CF3              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04236H
  66+ 4CF3              PLY_AKG_PLAY EQU 04236H
  67+ 4CF3              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423EH
  68+ 4CF3              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04244H
  69+ 4CF3              PLY_AKG_READLINKER EQU 04249H
  70+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04249H
  71+ 4CF3              PLY_AKG_READLINKER_PTLINKER EQU 04249H
  72+ 4CF3              PLY_AKG_READLINKER_NOLOOP EQU 04254H
  73+ 4CF3              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428DH
  74+ 4CF3              PLY_AKG_READLINE EQU 04290H
  75+ 4CF3              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 04290H
  76+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04296H
  77+ 4CF3              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04296H
  78+ 4CF3              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A3H
  79+ 4CF3              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A7H
  80+ 4CF3              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042AAH
  81+ 4CF3              PLY_AKG_SPEEDTRACK_END EQU 042ADH
  82+ 4CF3              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042ADH
  83+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B3H
  84+ 4CF3              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B3H
  85+ 4CF3              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042C0H
  86+ 4CF3              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C4H
  87+ 4CF3              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C7H
  88+ 4CF3              PLY_AKG_EVENTTRACK_END EQU 042CAH
  89+ 4CF3              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042CAH
  90+ 4CF3              PLY_AKG_CHANNEL1_READTRACK EQU 042D6H
  91+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D6H
  92+ 4CF3              PLY_AKG_CHANNEL1_PTTRACK EQU 042D6H
  93+ 4CF3              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042F1H
  94+ 4CF3              PLY_AKG_CHANNEL1_WAIT EQU 042FCH
  95+ 4CF3              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04303H
  96+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04303H
  97+ 4CF3              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04303H
  98+ 4CF3              PLY_AKG_CHANNEL1_NOTE EQU 0430CH
  99+ 4CF3              PLY_AKG_BASENOTEINDEX EQU 0430CH
 100+ 4CF3              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430EH
 101+ 4CF3              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430EH
 102+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431EH
 103+ 4CF3              PLY_AKG_INSTRUMENTSTABLE EQU 0431EH
 104+ 4CF3              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 04330H
 105+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 04340H
 106+ 4CF3              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04368H
 107+ 4CF3              PLY_AKG_CHANNEL1_READCELLEND EQU 0436BH
 108+ 4CF3              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 0436BH
 109+ 4CF3              PLY_AKG_CHANNEL2_READTRACK EQU 04377H
 110+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04377H
 111+ 4CF3              PLY_AKG_CHANNEL2_PTTRACK EQU 04377H
 112+ 4CF3              PLY_AKG_CHANNEL2_SMALLWAIT EQU 04392H
 113+ 4CF3              PLY_AKG_CHANNEL2_WAIT EQU 0439DH
 114+ 4CF3              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A4H
 115+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A4H
 116+ 4CF3              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A4H
 117+ 4CF3              PLY_AKG_CHANNEL2_NOTE EQU 043ADH
 118+ 4CF3              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043B2H
 119+ 4CF3              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043B2H
 120+ 4CF3              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D4H
 121+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E4H
 122+ 4CF3              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 0440CH
 123+ 4CF3              PLY_AKG_CHANNEL2_READCELLEND EQU 0440FH
 124+ 4CF3              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440FH
 125+ 4CF3              PLY_AKG_CHANNEL3_READTRACK EQU 0441BH
 126+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 0441BH
 127+ 4CF3              PLY_AKG_CHANNEL3_PTTRACK EQU 0441BH
 128+ 4CF3              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04436H
 129+ 4CF3              PLY_AKG_CHANNEL3_WAIT EQU 04441H
 130+ 4CF3              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04448H
 131+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04448H
 132+ 4CF3              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04448H
 133+ 4CF3              PLY_AKG_CHANNEL3_NOTE EQU 04451H
 134+ 4CF3              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04456H
 135+ 4CF3              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04456H
 136+ 4CF3              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04478H
 137+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04488H
 138+ 4CF3              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044B0H
 139+ 4CF3              PLY_AKG_CHANNEL3_READCELLEND EQU 044B3H
 140+ 4CF3              PLY_AKG_CURRENTSPEED EQU 044B3H
 141+ 4CF3              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B5H
 142+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B8H
 143+ 4CF3              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B8H
 144+ 4CF3              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044BBH
 145+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BEH
 146+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BEH
 147+ 4CF3              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044CAH
 148+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044D1H
 149+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D4H
 150+ 4CF3              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044DAH
 151+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DDH
 152+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DDH
 153+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044EBH
 154+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044F0H
 155+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044FBH
 156+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FEH
 157+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FEH
 158+ 4CF3              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 04501H
 159+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04504H
 160+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04504H
 161+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450DH
 162+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04517H
 163+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 0451AH
 164+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 0451AH
 165+ 4CF3              PLY_AKG_CHANNEL1_PITCH EQU 0451AH
 166+ 4CF3              PLY_AKG_CHANNEL1_ISPITCH EQU 0451DH
 167+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 04522H
 168+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACK EQU 04522H
 169+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04526H
 170+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04528H
 171+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 0452AH
 172+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 04531H
 173+ 4CF3              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 04532H
 174+ 4CF3              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04535H
 175+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04535H
 176+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 04551H
 177+ 4CF3              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 04551H
 178+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455EH
 179+ 4CF3              PLY_AKG_CHANNEL1_GLIDEOVER EQU 04562H
 180+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 04572H
 181+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 04572H
 182+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04573H
 183+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04574H
 184+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04576H
 185+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04576H
 186+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04576H
 187+ 4CF3              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04577H
 188+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04578H
 189+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 0457AH
 190+ 4CF3              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 0457AH
 191+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 0457AH
 192+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 0457AH
 193+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 0457AH
 194+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457DH
 195+ 4CF3              PLY_AKG_CHANNEL1_PITCH_END EQU 0457FH
 196+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04587H
 197+ 4CF3              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04587H
 198+ 4CF3              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 0458AH
 199+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458DH
 200+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458DH
 201+ 4CF3              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04599H
 202+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 045A0H
 203+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A3H
 204+ 4CF3              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A9H
 205+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045ACH
 206+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045ACH
 207+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045BAH
 208+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BFH
 209+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045CAH
 210+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CDH
 211+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CDH
 212+ 4CF3              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045D0H
 213+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D3H
 214+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D3H
 215+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045DCH
 216+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E6H
 217+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E9H
 218+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E9H
 219+ 4CF3              PLY_AKG_CHANNEL2_PITCH EQU 045E9H
 220+ 4CF3              PLY_AKG_CHANNEL2_ISPITCH EQU 045ECH
 221+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045F1H
 222+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045F1H
 223+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F5H
 224+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F7H
 225+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F9H
 226+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 04600H
 227+ 4CF3              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 04601H
 228+ 4CF3              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04604H
 229+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04604H
 230+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 04620H
 231+ 4CF3              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 04620H
 232+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462DH
 233+ 4CF3              PLY_AKG_CHANNEL2_GLIDEOVER EQU 04631H
 234+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 04641H
 235+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 04641H
 236+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 04642H
 237+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04643H
 238+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04645H
 239+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04645H
 240+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04645H
 241+ 4CF3              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04646H
 242+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04647H
 243+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04649H
 244+ 4CF3              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04649H
 245+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04649H
 246+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04649H
 247+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04649H
 248+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_END EQU 0464CH
 249+ 4CF3              PLY_AKG_CHANNEL2_PITCH_END EQU 0464EH
 250+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04656H
 251+ 4CF3              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04656H
 252+ 4CF3              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04659H
 253+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 0465CH
 254+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 0465CH
 255+ 4CF3              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04668H
 256+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466FH
 257+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 04672H
 258+ 4CF3              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04678H
 259+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 0467BH
 260+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 0467BH
 261+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04689H
 262+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468EH
 263+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04699H
 264+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 0469CH
 265+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 0469CH
 266+ 4CF3              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469FH
 267+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 046A2H
 268+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE EQU 046A2H
 269+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046ABH
 270+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B5H
 271+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B8H
 272+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B8H
 273+ 4CF3              PLY_AKG_CHANNEL3_PITCH EQU 046B8H
 274+ 4CF3              PLY_AKG_CHANNEL3_ISPITCH EQU 046BBH
 275+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046C0H
 276+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046C0H
 277+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C4H
 278+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C6H
 279+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C8H
 280+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CFH
 281+ 4CF3              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046D0H
 282+ 4CF3              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D3H
 283+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D3H
 284+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046EFH
 285+ 4CF3              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046EFH
 286+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046FCH
 287+ 4CF3              PLY_AKG_CHANNEL3_GLIDEOVER EQU 04700H
 288+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 04710H
 289+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 04710H
 290+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 04711H
 291+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 04712H
 292+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04714H
 293+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04714H
 294+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04714H
 295+ 4CF3              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04715H
 296+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04716H
 297+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04718H
 298+ 4CF3              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04718H
 299+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04718H
 300+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04718H
 301+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04718H
 302+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_END EQU 0471BH
 303+ 4CF3              PLY_AKG_CHANNEL3_PITCH_END EQU 0471DH
 304+ 4CF3              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04729H
 305+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04729H
 306+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04729H
 307+ 4CF3              PLY_AKG_CHANNEL1_TRACKNOTE EQU 0472CH
 308+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472EH
 309+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04734H
 310+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04737H
 311+ 4CF3              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04737H
 312+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 0473AH
 313+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04743H
 314+ 4CF3              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 0474BH
 315+ 4CF3              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04758H
 316+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04758H
 317+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04758H
 318+ 4CF3              PLY_AKG_CHANNEL2_TRACKNOTE EQU 0475BH
 319+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475DH
 320+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04763H
 321+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04766H
 322+ 4CF3              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04766H
 323+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04769H
 324+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 04772H
 325+ 4CF3              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 0477AH
 326+ 4CF3              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04788H
 327+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04788H
 328+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04788H
 329+ 4CF3              PLY_AKG_CHANNEL3_TRACKNOTE EQU 0478BH
 330+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478DH
 331+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04793H
 332+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04796H
 333+ 4CF3              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04796H
 334+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04799H
 335+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 047A2H
 336+ 4CF3              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047AAH
 337+ 4CF3              PLY_AKG_SENDPSGREGISTERS EQU 047B9H
 338+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047C1H
 339+ 4CF3              PLY_AKG_PSGREG01_INSTR EQU 047C1H
 340+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047D1H
 341+ 4CF3              PLY_AKG_PSGREG23_INSTR EQU 047D1H
 342+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047E2H
 343+ 4CF3              PLY_AKG_PSGREG45_INSTR EQU 047E2H
 344+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F3H
 345+ 4CF3              PLY_AKG_PSGREG6_8_INSTR EQU 047F3H
 346+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04804H
 347+ 4CF3              PLY_AKG_PSGREG9_10_INSTR EQU 04804H
 348+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04815H
 349+ 4CF3              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04815H
 350+ 4CF3              PLY_AKG_PSGREG13_OLDVALUE EQU 0482AH
 351+ 4CF3              PLY_AKG_RETRIG EQU 0482CH
 352+ 4CF3              PLY_AKG_PSGREG13_INSTR EQU 0482EH
 353+ 4CF3              PLY_AKG_PSGREG13_END EQU 0483DH
 354+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483DH
 355+ 4CF3              PLY_AKG_SAVESP EQU 0483DH
 356+ 4CF3              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 04841H
 357+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTS EQU 04849H
 358+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04856H
 359+ 4CF3              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04856H
 360+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485EH
 361+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 0486BH
 362+ 4CF3              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 0486BH
 363+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTS EQU 04873H
 364+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487EH
 365+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS EQU 0487EH
 366+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488DH
 367+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488DH
 368+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04894H
 369+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A4H
 370+ 4CF3              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A4H
 371+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048ABH
 372+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048ABH
 373+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048AEH
 374+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B7H
 375+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B7H
 376+ 4CF3              PLY_AKG_READINSTRUMENTCELL EQU 048BDH
 377+ 4CF3              PLY_AKG_NOSOFTNOHARD EQU 048CAH
 378+ 4CF3              PLY_AKG_NSNH_NONOISE EQU 048DFH
 379+ 4CF3              PLY_AKG_SOFT EQU 048E2H
 380+ 4CF3              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E9H
 381+ 4CF3              PLY_AKG_S_NOTSIMPLE EQU 048F1H
 382+ 4CF3              PLY_AKG_S_AFTERSIMPLETEST EQU 048F4H
 383+ 4CF3              PLY_AKG_HARDTOSOFT EQU 04901H
 384+ 4CF3              PLY_AKG_HS_JUMPRATIO EQU 0490CH
 385+ 4CF3              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04939H
 386+ 4CF3              PLY_AKG_ENDWITHOUTLOOP EQU 0493BH
 387+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 0493BH
 388+ 4CF3              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 0493BH
 389+ 4CF3              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04943H
 390+ 4CF3              PLY_AKG_SH_JUMPRATIO EQU 04950H
 391+ 4CF3              PLY_AKG_SH_JUMPRATIOEND EQU 04971H
 392+ 4CF3              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 04980H
 393+ 4CF3              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04986H
 394+ 4CF3              PLY_AKG_H_OR_ENDWITHLOOP EQU 049A0H
 395+ 4CF3              PLY_AKG_H_RETRIGEND EQU 049B2H
 396+ 4CF3              PLY_AKG_H_AFTERRETRIG EQU 049B3H
 397+ 4CF3              PLY_AKG_ENDWITHLOOP EQU 049C5H
 398+ 4CF3              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049CCH
 399+ 4CF3              PLY_AKG_S_OR_H_NEXTBYTE EQU 049E2H
 400+ 4CF3              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049F0H
 401+ 4CF3              PLY_AKG_S_OR_H_AFTERPITCH EQU 04A00H
 402+ 4CF3              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0EH
 403+ 4CF3              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1DH
 404+ 4CF3              PLY_AKG_SHOHS_RETRIGEND EQU 04A2CH
 405+ 4CF3              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2DH
 406+ 4CF3              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3FH
 407+ 4CF3              PLY_AKG_EFFECTTABLE EQU 04A4DH
 408+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4DH
 409+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A71H
 410+ 4CF3              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A71H
 411+ 4CF3              PLY_AKG_EFFECT_RESET EQU 04A74H
 412+ 4CF3              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A76H
 413+ 4CF3              PLY_AKG_EFFECT_VOLUME EQU 04A91H
 414+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9DH
 415+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA3H
 416+ 4CF3              PLY_AKG_ARPEGGIOSTABLE EQU 04AA3H
 417+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04ACAH
 418+ 4CF3              PLY_AKG_EFFECT_PITCHTABLE EQU 04AD1H
 419+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD7H
 420+ 4CF3              PLY_AKG_PITCHESTABLE EQU 04AD7H
 421+ 4CF3              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFEH
 422+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B05H
 423+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B16H
 424+ 4CF3              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1DH
 425+ 4CF3              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2DH
 426+ 4CF3              PLY_AKG_EFFECT_PITCHUP EQU 04B42H
 427+ 4CF3              PLY_AKG_EFFECT_PITCHSTOP EQU 04B54H
 428+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B5BH
 429+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B85H
 430+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B85H
 431+ 4CF3              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9EH
 432+ 4CF3              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9EH
 433+ 4CF3              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BB0H
 434+ 4CF3              PLY_AKG_EFFECT_LEGATO EQU 04BC6H
 435+ 4CF3              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BDAH
 436+ 4CF3              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BE2H
 437+ 4CF3              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BEAH
 438+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BF2H
 439+ 4CF3              PLY_AKG_EVENT EQU 04BF2H
 440+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF3H
 441+ 4CF3              PLY_AKG_PERIODTABLE EQU 04BF3H
 442+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF3H
 443+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF3H
 444+ 4CF3              PLY_AKG_PERIODTABLE_END EQU 04CF3H
 445+ 4CF3              PLY_AKG_END EQU 04CF3H
 446+ 4CF3              MAIN_PLAYER_END EQU 04CF3H
 447+ 4CF3              TESTEREND EQU 04CF3H
 448+ 4CF3
# file closed: ./symbol/AKG.sym
 127  4CF3               ENDIF
 128  4CF3
 129  4CF3               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
   1+ 4CF3              ORIG.HTIMI:
   2+ 4CF3 00 00 00 00  	DB 0, 0, 0, 0, 0
   2+ 4CF7 00
   3+ 4CF8               EXPORT ORIG.HTIMI
   4+ 4CF8
   5+ 4CF8              ; *******************************************************************************************************
   6+ 4CF8              ; interrupt handler when page 0 enabled
   7+ 4CF8              ; we are here only if one of the extended basic commands have paged in page 0
   8+ 4CF8              ; which means we arrived from BASIC so page 2 is already good
   9+ 4CF8              VBLANK:
  10+ 4CF8              	EXPORT VBLANK
  11+ 4CF8
  12+ 4CF8 F5               PUSH AF
  13+ 4CF9              	; is VDP originator ?
  14+ 4CF9 DB 99        	IN	A, (099H)
  15+ 4CFB A7           	AND	A
  16+ 4CFC F2 23 4D     	JP P, .EXIT
  17+ 4CFF
  18+ 4CFF               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  19+ 4CFF C5               PUSH BC
  20+ 4D00 D5               PUSH DE
  21+ 4D01 E5               PUSH HL
  22+ 4D02 08               EX AF, AF'
  23+ 4D03 D9               EXX
  24+ 4D04 F5               PUSH AF
  25+ 4D05 C5               PUSH BC
  26+ 4D06 D5               PUSH DE
  27+ 4D07 E5               PUSH HL
  28+ 4D08 DD E5            PUSH IX
  29+ 4D0A FD E5            PUSH IY
  30+ 4D0C
  31+ 4D0C               IF (SPRITE_CMDS == 1)
  32+ 4D0C CD 5D 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  33+ 4D0F               ENDIF
  34+ 4D0F
  35+ 4D0F               IF (SOUND_CMDS == 1)
  36+ 4D0F 3A CA 58     	LD A, (SOUND_ENABLED)
  37+ 4D12 B7           	OR A
  38+ 4D13 C4 36 42     	CALL NZ,PLY_AKG_PLAY
  39+ 4D16               ENDIF
  40+ 4D16
  41+ 4D16                  ; increase JIFFY
  42+ 4D16                  ;LD HL,(JIFFY)
  43+ 4D16                  ;INC HL
  44+ 4D16                  ;LD (JIFFY),HL
  45+ 4D16
  46+ 4D16 FD E1            POP IY
  47+ 4D18 DD E1            POP IX
  48+ 4D1A E1               POP HL
  49+ 4D1B D1               POP DE
  50+ 4D1C C1               POP BC
  51+ 4D1D F1               POP AF
  52+ 4D1E 08               EX AF, AF'
  53+ 4D1F D9               EXX
  54+ 4D20 E1               POP HL
  55+ 4D21 D1               POP DE
  56+ 4D22 C1               POP BC
  57+ 4D23               ENDIF
  58+ 4D23
  59+ 4D23              .EXIT:
  60+ 4D23 F1           	POP AF
  61+ 4D24 FB           	EI
  62+ 4D25 ED 4D        	RETI
  63+ 4D27              ; *******************************************************************************************************
  64+ 4D27
  65+ 4D27              ; *******************************************************************************************************
  66+ 4D27              ; H.TIMI function
  67+ 4D27              ; we can end up here from anywhere so page in both page 0 and 2
  68+ 4D27              MBGE_HTIMI:
  69+ 4D27               EXPORT MBGE_HTIMI
  70+ 4D27
  71+ 4D27               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  72+ 4D27
  73+ 4D27 F5           	PUSH AF
  74+ 4D28
  75+ 4D28              	; enable page 2
  76+ 4D28 3E 02            LD A, 2
  77+ 4D2A CD 58 65         CALL GET_PAGE_INFO
  78+ 4D2D C5               PUSH BC
  79+ 4D2E D5               PUSH DE
  80+ 4D2F 3A 43 F3         LD A, (RAMAD2)
  81+ 4D32 26 80            LD H, 080H
  82+ 4D34 CD 9F 65         CALL LOCAL_ENASLT
  83+ 4D37              	; enable page 0
  84+ 4D37 AF               XOR A
  85+ 4D38 CD 58 65         CALL GET_PAGE_INFO
  86+ 4D3B C5               PUSH BC
  87+ 4D3C D5               PUSH DE
  88+ 4D3D 3A 41 F3         LD A, (RAMAD0)
  89+ 4D40 26 00            LD H, 0
  90+ 4D42 CD 9F 65         CALL LOCAL_ENASLT
  91+ 4D45
  92+ 4D45               IF (SPRITE_CMDS == 1)
  93+ 4D45 CD 5D 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  94+ 4D48               ENDIF
  95+ 4D48
  96+ 4D48               IF (SOUND_CMDS == 1)
  97+ 4D48 3A CA 58     	LD A, (SOUND_ENABLED)
  98+ 4D4B B7           	OR A
  99+ 4D4C C4 36 42     	CALL NZ,PLY_AKG_PLAY
 100+ 4D4F               ENDIF
 101+ 4D4F
 102+ 4D4F              	; restore page 0
 103+ 4D4F D1               POP DE
 104+ 4D50 C1               POP BC
 105+ 4D51 CD 8F 65         CALL RESTORE_PAGE_INFO
 106+ 4D54              	; restore page 2
 107+ 4D54 D1               POP DE
 108+ 4D55 C1               POP BC
 109+ 4D56 CD 8F 65         CALL RESTORE_PAGE_INFO
 110+ 4D59
 111+ 4D59 F1           	POP AF
 112+ 4D5A               ENDIF
 113+ 4D5A C3 F3 4C     	JP ORIG.HTIMI
 114+ 4D5D              ; *******************************************************************************************************
 115+ 4D5D
 116+ 4D5D              ; *******************************************************************************************************
 117+ 4D5D              ; function checks if the sprite system is initialized and what screen mode we are running
 118+ 4D5D              ; also checks if some VRAM modifying command is running
 119+ 4D5D              ; when that checks out calls sprite updates and animation processing
 120+ 4D5D              ; if in an unsupported mode disables sprite handling
 121+ 4D5D              PROCESS_SPRITES_AND_ANIMATIONS:
 122+ 4D5D              	; check if initialized
 123+ 4D5D 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
 124+ 4D60 B7           	OR A
 125+ 4D61 C8           	RET Z
 126+ 4D62              	; check screen mode
 127+ 4D62 3A AF FC     	LD A, (SCRMOD)
 128+ 4D65 3D           	DEC A
 129+ 4D66 28 08        	JR Z, .L0 ; screen 1
 130+ 4D68 3D           	DEC A
 131+ 4D69 28 05            JR Z, .L0 ; screen 2
 132+ 4D6B              	; unsupported screen mode, disable
 133+ 4D6B AF               XOR A
 134+ 4D6C 32 7F 4D         LD (SPRATR_INIT_STATUS),A
 135+ 4D6F C9               RET
 136+ 4D70              .L0:
 137+ 4D70                  ; check if anyone else is working with VRAM
 138+ 4D70 3A 53 63         LD A,(VRAM_UPDATE_IN_PROGRESS)
 139+ 4D73 B7               OR A
 140+ 4D74 C0               RET NZ
 141+ 4D75
 142+ 4D75 CD 95 4D         CALL SPRATR_UPDATE
 143+ 4D78
 144+ 4D78               IF (ANIM_CMDS == 1)
 145+ 4D78 CD 76 55         CALL PROCESS_ANIMATIONS
 146+ 4D7B CD 41 57         CALL PROCESS_AUTOSGAMS
 147+ 4D7E               ENDIF
 148+ 4D7E C9               RET
 149+ 4D7F              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
 130  4D7F
 131  4D7F               IF (SPRITE_CMDS == 1)
 132  4D7F               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4D7F              ; commands and variables related to sprites
   2+ 4D7F
   3+ 4D7F              SPRATR_INIT_STATUS:
   4+ 4D7F 00            DB 0
   5+ 4D80              SPRATR_UPDATE_FLAG:
   6+ 4D80 00 00         DW 0
   7+ 4D82              SPRATR_DATA:
   8+ 4D82 00 00         DW 0
   9+ 4D84              SPRFLICKER_ENABLED:
  10+ 4D84 00            DB 0
  11+ 4D85              ; to support sprite flicker
  12+ 4D85              FLICKER:
  13+ 4D85 00            DB 0
  14+ 4D86              NUM_SPRITES_HANDLED:
  15+ 4D86 20            DB 32
  16+ 4D87
  17+ 4D87              ; to temporarily store stack pointer
  18+ 4D87              TMPSP:
  19+ 4D87 00 00         DW 0
  20+ 4D89
  21+ 4D89              ; *******************************************************************************************************
  22+ 4D89              ; helper function gets pointer to n-th entry in sprite attributes
  23+ 4D89              ; changes HL,DE
  24+ 4D89              GETnthSPRATTR:
  25+ 4D89 26 00            LD H,0
  26+ 4D8B 6F               LD L,A
  27+ 4D8C CD 54 65         CALL HLx8
  28+ 4D8F ED 5B 82 4D      LD DE,(SPRATR_DATA)
  29+ 4D93 19               ADD HL,DE
  30+ 4D94 C9               RET
  31+ 4D95              ; *******************************************************************************************************
  32+ 4D95
  33+ 4D95              ; *******************************************************************************************************
  34+ 4D95              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  35+ 4D95              ; struct {
  36+ 4D95              ; DW y
  37+ 4D95              ; DW x
  38+ 4D95              ; DW pattern (0-63)
  39+ 4D95              ; DW color
  40+ 4D95              ; } [32]
  41+ 4D95              ; will hide sprites whose location is outside of visible area
  42+ 4D95              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  43+ 4D95              ; modifies AF, AF', BC, DE, HL, IX
  44+ 4D95              SPRATR_UPDATE:
  45+ 4D95              	; check if update requested
  46+ 4D95 2A 80 4D     	LD HL, (SPRATR_UPDATE_FLAG)
  47+ 4D98 7E           	LD A, (HL)
  48+ 4D99 B7           	OR A
  49+ 4D9A C8           	RET Z
  50+ 4D9B
  51+ 4D9B DD 21 86 4D  	LD IX,NUM_SPRITES_HANDLED
  52+ 4D9F DD 46 00     	LD B, (IX) ; sprite number
  53+ 4DA2 0E 98        	LD C, #98 ; register for vdp data output
  54+ 4DA4              	; set VDP address
  55+ 4DA4 3A AF FC         LD A,(SCRMOD)
  56+ 4DA7 3D               DEC A
  57+ 4DA8 20 05            JR NZ,.L4
  58+ 4DAA 2A C3 F3         LD HL, (T32ATR)
  59+ 4DAD 18 03            JR .L5
  60+ 4DAF              .L4:
  61+ 4DAF 2A CD F3         LD HL, (GRPATR)
  62+ 4DB2              .L5:
  63+ 4DB2 3A 84 4D     	LD A, (SPRFLICKER_ENABLED)
  64+ 4DB5 B7           	OR A
  65+ 4DB6 28 03        	JR Z, .L3
  66+ 4DB8 3A 85 4D     	LD A, (FLICKER)
  67+ 4DBB              .L3:
  68+ 4DBB 5F           	LD E, A
  69+ 4DBC 08           	EX AF, AF'
  70+ 4DBD 7B           	LD A, E
  71+ 4DBE 87           	ADD A, A
  72+ 4DBF 87           	ADD A, A
  73+ 4DC0 16 00        	LD D, 0
  74+ 4DC2 5F           	LD E, A
  75+ 4DC3 19           	ADD HL, DE
  76+ 4DC4 CD 35 65     	CALL SETWRT_LOCAL_WRITE
  77+ 4DC7 ED 73 87 4D  	LD (TMPSP), SP
  78+ 4DCB ED 7B 82 4D  	LD SP, (SPRATR_DATA)
  79+ 4DCF
  80+ 4DCF              .LOOP:
  81+ 4DCF E1           	POP HL
  82+ 4DD0 24           	INC H
  83+ 4DD1 28 0D        	JR Z, .L1 ; negative number between -256 and -1
  84+ 4DD3 25           	DEC H
  85+ 4DD4 20 15        	JR NZ, .OUT3 ; sprite vertically can't be visible
  86+ 4DD6 7D           	LD A, L
  87+ 4DD7 FE C0        	CP 192
  88+ 4DD9 30 10        	JR NC, .OUT3
  89+ 4DDB 3D           	DEC A ; due to VDP rule that top of screen is -1
  90+ 4DDC 57           	LD D, A
  91+ 4DDD C3 04 4E     	JP .X
  92+ 4DE0              .L1:
  93+ 4DE0 7D           	LD A, L
  94+ 4DE1 C6 10        	ADD 16
  95+ 4DE3 FA EB 4D     	JP M, .OUT3 ; below -16
  96+ 4DE6 2D           	DEC L ; due to VDP rule that top of screen is -1
  97+ 4DE7 55           	LD D, L
  98+ 4DE8 C3 04 4E     	JP .X
  99+ 4DEB              .OUT3:
 100+ 4DEB E1           	POP HL ; skip x value
 101+ 4DEC              .OUT2:
 102+ 4DEC E1           	POP HL ; skip pattern
 103+ 4DED E1           	POP HL ; skip color
 104+ 4DEE 3E D1        	LD A, #D1
 105+ 4DF0 ED 79        	OUT (C), A ; sprite hidden
 106+ 4DF2 00          > NOP
 106+ 4DF3 00          > NOP
 106+ 4DF4 00          > NOP
 107+ 4DF5 ED 79        	OUT (C), A ; value unimportant
 108+ 4DF7 00          > NOP
 108+ 4DF8 00          > NOP
 108+ 4DF9 00          > NOP
 109+ 4DFA ED 79        	OUT (C), A ; value unimportant
 110+ 4DFC 00          > NOP
 110+ 4DFD 00          > NOP
 110+ 4DFE 00          > NOP
 111+ 4DFF ED 79        	OUT (C), A ; value unimportant
 112+ 4E01 C3 2F 4E     	JP .NEXT
 113+ 4E04              .X:
 114+ 4E04 E1           	POP HL
 115+ 4E05 24           	INC H
 116+ 4E06 28 08        	JR Z, .L2
 117+ 4E08 25           	DEC H
 118+ 4E09 20 E1        	JR NZ, .OUT2
 119+ 4E0B 1E 00        	LD E, 0 ; EC bit
 120+ 4E0D C3 19 4E     	JP .XY
 121+ 4E10              .L2:
 122+ 4E10 7D           	LD A, L
 123+ 4E11 C6 20        	ADD 32
 124+ 4E13 FA EC 4D     	JP M, .OUT2
 125+ 4E16 6F           	LD L, A
 126+ 4E17 1E 80        	LD E, #80
 127+ 4E19              .XY:
 128+ 4E19 ED 51        	OUT (C), D
 129+ 4E1B 3A E0 F3     	LD A, (REG1SAV)
 130+ 4E1E E6 02        	AND 2
 131+ 4E20 ED 69        	OUT (C), L
 132+ 4E22 E1           	POP HL ; pattern
 133+ 4E23 7D           	LD A, L
 134+ 4E24 28 02        	JR Z, .SMALLSPRITES
 135+ 4E26 87           	ADD A, A
 136+ 4E27 87           	ADD A, A ; needs to go at 4x
 137+ 4E28              .SMALLSPRITES:
 138+ 4E28 D3 98        	OUT (#98), A
 139+ 4E2A E1           	POP HL ; color
 140+ 4E2B 7D           	LD A, L
 141+ 4E2C B3           	OR E
 142+ 4E2D D3 98        	OUT (#98), A
 143+ 4E2F              .NEXT:
 144+ 4E2F 08           	EX AF, AF'
 145+ 4E30 3C           	INC A ; increase current sprite
 146+ 4E31 DD BE 00     	CP (IX) ; compare to maximum handled
 147+ 4E34 C2 54 4E     	JP NZ, .NEXT2 ; continue if not over
 148+ 4E37 AF           	XOR A ; back to zero
 149+ 4E38 08           	EX AF, AF'
 150+ 4E39 3A AF FC         LD A,(SCRMOD)
 151+ 4E3C 3D               DEC A
 152+ 4E3D 20 05            JR NZ,.L6
 153+ 4E3F 2A C3 F3         LD HL, (T32ATR)
 154+ 4E42 18 03            JR .L7
 155+ 4E44              .L6:
 156+ 4E44 2A CD F3         LD HL, (GRPATR)
 157+ 4E47              .L7:
 158+ 4E47              	; CALL SETWRT_LOCAL not allowed as SP modified
 159+ 4E47 7D           	LD	A, L
 160+ 4E48 D3 99        	OUT	(099H), A
 161+ 4E4A 7C           	LD	A, H
 162+ 4E4B E6 3F        	AND	03FH
 163+ 4E4D F6 40        	OR	040H
 164+ 4E4F D3 99        	OUT	(099H), A
 165+ 4E51 C3 55 4E     	JP .NEXT3
 166+ 4E54              .NEXT2:
 167+ 4E54 08           	EX AF, AF'
 168+ 4E55              .NEXT3:
 169+ 4E55 05           	DEC B
 170+ 4E56 C2 CF 4D     	JP NZ, .LOOP
 171+ 4E59 08           	EX AF, AF'
 172+ 4E5A 3C           	INC A ; increase flicker to start at the next one on next vblank
 173+ 4E5B DD BE 00     	CP (IX)
 174+ 4E5E 20 01        	JR NZ,.L8
 175+ 4E60 AF           	XOR A
 176+ 4E61              .L8:
 177+ 4E61 32 85 4D     	LD (FLICKER), A
 178+ 4E64
 179+ 4E64 ED 7B 87 4D  	LD SP, (TMPSP)
 180+ 4E68 2A 80 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 181+ 4E6B 36 00        	LD (HL), 0 ; zero out update flag
 182+ 4E6D C9           	RET
 183+ 4E6E              ; *******************************************************************************************************
 184+ 4E6E
 185+ 4E6E               IF (1 == 1)
 186+ 4E6E              ; *******************************************************************************************************
 187+ 4E6E              ; function to handle CALL SPRENABLE basic extension
 188+ 4E6E              ; initializes sprites handler
 189+ 4E6E              ; _SPRENABLE ( INT[3][31] variable sprites_attributes,
 190+ 4E6E              ;			   INT variable update_variable,
 191+ 4E6E              ;			   BYTE sprite_flicker_enabled,
 192+ 4E6E              ;			   BYTE num_sprites_handled )
 193+ 4E6E              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA, SPRFLICKER_ENABLED and NUM_SPRITES_HANDLED
 194+ 4E6E              SPRENABLE:
 195+ 4E6E              	; opening (
 196+ 4E6E CD 67 66     	CALL CHKCHAR
 197+ 4E71 28           	DB '('
 198+ 4E72              	; get address of sprite attribute table DIM SA%(3,31)
 199+ 4E72 3E 02        	LD A,2
 200+ 4E74 06 02        	LD B,2
 201+ 4E76 11 20 04     	LD DE,#0420
 202+ 4E79 CD C0 66     	CALL GET_BASIC_ARRAY_DATA_POINTER
 203+ 4E7C ED 43 82 4D  	LD (SPRATR_DATA), BC
 204+ 4E80              	; comma
 205+ 4E80 CD 67 66     	CALL CHKCHAR
 206+ 4E83 2C           	DB ','
 207+ 4E84              	; get address of sprite update flag
 208+ 4E84 DD 21 A4 5E  	LD IX, PTRGET
 209+ 4E88 CD 59 01     	CALL CALBAS
 210+ 4E8B ED 53 80 4D  	LD (SPRATR_UPDATE_FLAG), DE
 211+ 4E8F              	; comma
 212+ 4E8F CD 67 66     	CALL CHKCHAR
 213+ 4E92 2C           	DB ','
 214+ 4E93              	; get flicker enabled flag
 215+ 4E93 DD 21 1C 52  	LD IX, GETBYT
 216+ 4E97 CD 59 01     	CALL CALBAS
 217+ 4E9A 32 84 4D     	LD (SPRFLICKER_ENABLED), A
 218+ 4E9D              	; comma
 219+ 4E9D CD 67 66     	CALL CHKCHAR
 220+ 4EA0 2C           	DB ','
 221+ 4EA1              	; get number of handled sprites
 222+ 4EA1 DD 21 1C 52  	LD IX, GETBYT
 223+ 4EA5 CD 59 01     	CALL CALBAS
 224+ 4EA8 32 86 4D     	LD (NUM_SPRITES_HANDLED),A
 225+ 4EAB              	; ending )
 226+ 4EAB CD 67 66     	CALL CHKCHAR
 227+ 4EAE 29           	DB ')'
 228+ 4EAF              .L0:
 229+ 4EAF 3E 01        	LD A, 1
 230+ 4EB1 32 7F 4D     	LD (SPRATR_INIT_STATUS), A
 231+ 4EB4 C9           	RET
 232+ 4EB5              ; *******************************************************************************************************
 233+ 4EB5               ENDIF
 234+ 4EB5
 235+ 4EB5               IF (0 == 1)
 236+ 4EB5 ~            ; same as SPRENABLE but for DEFUSR approach
 237+ 4EB5 ~            ; input IX=pointer to input array, real data from +2
 238+ 4EB5 ~            ; +2 = pointer to sprite attributes array data
 239+ 4EB5 ~            ; +4 = pointer to sprite update variable
 240+ 4EB5 ~            ; +6 = flicker flag
 241+ 4EB5 ~            ; +8 = number of sprites to handle
 242+ 4EB5 ~            SPRENABLE_DEFUSR:
 243+ 4EB5 ~            	LD L,(IX+2)
 244+ 4EB5 ~            	LD H,(IX+3)
 245+ 4EB5 ~            	LD (SPRATR_DATA),HL
 246+ 4EB5 ~            	LD L,(IX+4)
 247+ 4EB5 ~            	LD H,(IX+5)
 248+ 4EB5 ~            	LD (SPRATR_UPDATE_FLAG),HL
 249+ 4EB5 ~            	LD A,(IX+6)
 250+ 4EB5 ~            	LD (SPRFLICKER_ENABLED),A
 251+ 4EB5 ~            	LD A,(IX+8)
 252+ 4EB5 ~            	LD (NUM_SPRITES_HANDLED),A
 253+ 4EB5 ~             IF (BASIC_EXTENSION == 1)
 254+ 4EB5 ~            	JR SPRENABLE.L0
 255+ 4EB5 ~             ELSE
 256+ 4EB5 ~            	LD A, 1
 257+ 4EB5 ~            	LD (SPRATR_INIT_STATUS), A
 258+ 4EB5 ~            	RET
 259+ 4EB5 ~             ENDIF
 260+ 4EB5               ENDIF
 261+ 4EB5
 262+ 4EB5               IF (0 + 1 > 0)
 263+ 4EB5              ; *******************************************************************************************************
 264+ 4EB5              ; function to handle CALL SPRDISABLE basic extension
 265+ 4EB5              ; disables sprites handling
 266+ 4EB5              ; _SPRDISABLE
 267+ 4EB5              ; resets variable SPRATR_INIT_STATUS
 268+ 4EB5              SPRDISABLE:
 269+ 4EB5              SPRDISABLE_DEFUSR:
 270+ 4EB5 AF           	XOR A
 271+ 4EB6 32 7F 4D     	LD (SPRATR_INIT_STATUS), A
 272+ 4EB9 C9           	RET
 273+ 4EBA              ; *******************************************************************************************************
 274+ 4EBA               ENDIF
 275+ 4EBA
 276+ 4EBA              ; *******************************************************************************************************
 277+ 4EBA              ; function to handle CALL SPRSET basic extension
 278+ 4EBA              ; sets position, and optionally pattern and color of sprite
 279+ 4EBA              ; _SPRSET ( BYTE sprite_num , valid 0-31
 280+ 4EBA              ;			INT x,
 281+ 4EBA              ;			INT y,
 282+ 4EBA              ;			INT pattern, valid 0-63, otherwise ignored
 283+ 4EBA              ;			INT color, valid 0-15, otherwise ignored
 284+ 4EBA              ;SPRSET:
 285+ 4EBA              ;	LD A, (SPRATR_INIT_STATUS)
 286+ 4EBA              ;	OR A
 287+ 4EBA              ;	JR NZ, .L1
 288+ 4EBA              ;	LD E, 5 ; illegal function call
 289+ 4EBA              ;	JP THROW_ERROR
 290+ 4EBA              ;.L1:
 291+ 4EBA              ;	; opening (
 292+ 4EBA              ;	CALL CHKCHAR
 293+ 4EBA              ;	DB '('
 294+ 4EBA              ;	; get sprite number
 295+ 4EBA              ;	LD IX, GETBYT
 296+ 4EBA              ;	CALL CALBAS
 297+ 4EBA              ;	PUSH AF
 298+ 4EBA              ;	; comma
 299+ 4EBA              ;	CALL CHKCHAR
 300+ 4EBA              ;	DB ','
 301+ 4EBA              ;	; get x
 302+ 4EBA              ;	LD IX, FRMQNT
 303+ 4EBA              ;	CALL CALBAS
 304+ 4EBA              ;	PUSH DE
 305+ 4EBA              ;	; comma
 306+ 4EBA              ;	CALL CHKCHAR
 307+ 4EBA              ;	DB ','
 308+ 4EBA              ;	; get y
 309+ 4EBA              ;	LD IX, FRMQNT
 310+ 4EBA              ;	CALL CALBAS
 311+ 4EBA              ;	PUSH DE
 312+ 4EBA              ;	; comma
 313+ 4EBA              ;	CALL CHKCHAR
 314+ 4EBA              ;	DB ','
 315+ 4EBA              ;	; get pattern
 316+ 4EBA              ;	LD IX, FRMQNT
 317+ 4EBA              ;	CALL CALBAS
 318+ 4EBA              ;	PUSH DE
 319+ 4EBA              ;	; comma
 320+ 4EBA              ;	CALL CHKCHAR
 321+ 4EBA              ;	DB ','
 322+ 4EBA              ;	; get color
 323+ 4EBA              ;	LD IX, FRMQNT
 324+ 4EBA              ;	CALL CALBAS
 325+ 4EBA              ;	PUSH DE
 326+ 4EBA              ;	; ending )
 327+ 4EBA              ;	CALL CHKCHAR
 328+ 4EBA              ;	DB ')'
 329+ 4EBA              ;
 330+ 4EBA              ;   ; save position in BASIC text
 331+ 4EBA              ;	PUSH HL
 332+ 4EBA              ;	POP IX
 333+ 4EBA              ;
 334+ 4EBA              ;	POP BC ; color
 335+ 4EBA              ;	POP DE ; pattern
 336+ 4EBA              ;	EXX
 337+ 4EBA              ;	POP BC ; y
 338+ 4EBA              ;	POP DE ; x
 339+ 4EBA              ;	POP AF ; sprite number
 340+ 4EBA              ;	CP 32
 341+ 4EBA              ;	JR C, .L2
 342+ 4EBA              ;	LD E, 5 ; illegal function call
 343+ 4EBA              ;	JP THROW_ERROR
 344+ 4EBA              ;.L2:
 345+ 4EBA              ;	; find location in sprite attributes table
 346+ 4EBA              ;	PUSH DE
 347+ 4EBA              ;	CALL GETnthSPRATTR
 348+ 4EBA              ;	POP DE
 349+ 4EBA              ;	DI
 350+ 4EBA              ;	; set y
 351+ 4EBA              ;	LD (HL), C
 352+ 4EBA              ;	INC HL
 353+ 4EBA              ;	LD (HL), B
 354+ 4EBA              ;	INC HL
 355+ 4EBA              ;	; set x
 356+ 4EBA              ;	LD (HL), E
 357+ 4EBA              ;	INC HL
 358+ 4EBA              ;	LD (HL), D
 359+ 4EBA              ;	INC HL
 360+ 4EBA              ;	PUSH HL
 361+ 4EBA              ;	EXX
 362+ 4EBA              ;	POP HL
 363+ 4EBA              ;	; check if 0<=pattern<64
 364+ 4EBA              ;	LD A, D
 365+ 4EBA              ;	OR A
 366+ 4EBA              ;	JR NZ, .L3
 367+ 4EBA              ;	LD A, E
 368+ 4EBA              ;	CP 64
 369+ 4EBA              ;	JR NC, .L3
 370+ 4EBA              ;	; set pattern
 371+ 4EBA              ;	;ADD A, A
 372+ 4EBA              ;	;ADD A, A
 373+ 4EBA              ;	;ADD A, A
 374+ 4EBA              ;	LD (HL), A
 375+ 4EBA              ;	INC HL
 376+ 4EBA              ;	LD (HL), D
 377+ 4EBA              ;	INC HL
 378+ 4EBA              ;	JR .L4
 379+ 4EBA              ;.L3:
 380+ 4EBA              ;	; skip pattern
 381+ 4EBA              ;	.2 INC HL
 382+ 4EBA              ;.L4:
 383+ 4EBA              ;	; check if 0<=color<16
 384+ 4EBA              ;	LD A, B
 385+ 4EBA              ;	OR A
 386+ 4EBA              ;	JR NZ, .L5
 387+ 4EBA              ;	LD A, C
 388+ 4EBA              ;	CP 16
 389+ 4EBA              ;	JR NC, .L5
 390+ 4EBA              ;	; set color
 391+ 4EBA              ;	LD (HL), C
 392+ 4EBA              ;	INC HL
 393+ 4EBA              ;	LD (HL), B
 394+ 4EBA              ;
 395+ 4EBA              ;.L5:
 396+ 4EBA              ;	EI
 397+ 4EBA              ;	PUSH IX
 398+ 4EBA              ;	POP HL
 399+ 4EBA              ;	RET
 400+ 4EBA              ; *******************************************************************************************************
 401+ 4EBA
 402+ 4EBA              ; *******************************************************************************************************
 403+ 4EBA              ; function sets sprite location based on initial coordinates and offset provided
 404+ 4EBA              ; input A=sprite number in SPRATR_DATA , 0-31
 405+ 4EBA              ; input DE=initial x
 406+ 4EBA              ; input BC=initial y
 407+ 4EBA              ; input IY=location where delta y,x are located
 408+ 4EBA              ; modifies AF, HL, IX
 409+ 4EBA              SPRSET_DELTA_POS:
 410+ 4EBA D5           	PUSH DE
 411+ 4EBB CD 89 4D     	CALL GETnthSPRATTR
 412+ 4EBE E5           	PUSH HL
 413+ 4EBF DD E1        	POP IX
 414+ 4EC1 D1           	POP DE
 415+ 4EC2              	; IX=sprite's y location
 416+ 4EC2 FD 6E 00     	LD L, (IY)
 417+ 4EC5 FD 66 01     	LD H, (IY+1)
 418+ 4EC8 09           	ADD HL, BC
 419+ 4EC9 DD 75 00     	LD (IX), L
 420+ 4ECC DD 74 01     	LD (IX+1), H
 421+ 4ECF FD 6E 02     	LD L, (IY+2)
 422+ 4ED2 FD 66 03     	LD H, (IY+3)
 423+ 4ED5 19           	ADD HL, DE
 424+ 4ED6 DD 75 02     	LD (IX+2), L
 425+ 4ED9 DD 74 03     	LD (IX+3), H
 426+ 4EDC C9           	RET
 427+ 4EDD              ; *******************************************************************************************************
 428+ 4EDD
 429+ 4EDD              ; *******************************************************************************************************
 430+ 4EDD              ; helper function to set new locations for a set of sprites
 431+ 4EDD              ; input B=number of sprites
 432+ 4EDD              ; HL=pointer to list of sprites and offsets
 433+ 4EDD              SPR_UPDATE_LOC:
 434+ 4EDD 3E 01        	LD A,1
 435+ 4EDF 32 53 63     	LD (VRAM_UPDATE_IN_PROGRESS),A
 436+ 4EE2 7E           	LD A, (HL)
 437+ 4EE3 23           	INC HL
 438+ 4EE4 23           	INC HL
 439+ 4EE5 E5           	PUSH HL
 440+ 4EE6 FD E1        	POP IY
 441+ 4EE8 D9           	EXX
 442+ 4EE9 CD BA 4E     	CALL SPRSET_DELTA_POS
 443+ 4EEC D9           	EXX
 444+ 4EED 23          > INC HL
 444+ 4EEE 23          > INC HL
 444+ 4EEF 23          > INC HL
 444+ 4EF0 23          > INC HL
 445+ 4EF1 10 EA        	DJNZ SPR_UPDATE_LOC
 446+ 4EF3 AF           	XOR A
 447+ 4EF4 32 53 63     	LD (VRAM_UPDATE_IN_PROGRESS),A
 448+ 4EF7 C9           	RET
 449+ 4EF8              ; *******************************************************************************************************
 450+ 4EF8
 451+ 4EF8               IF (1 == 1)
 452+ 4EF8              ; *******************************************************************************************************
 453+ 4EF8              ; function to handle CALL SPRGRPMOV basic extension
 454+ 4EF8              ; sets position of a group of sprites described with
 455+ 4EF8              ; { int sprite_num, int delta_y, int delta_x } [count]
 456+ 4EF8              ; _SPRGRPMOV ( INT x,
 457+ 4EF8              ;			   INT y,
 458+ 4EF8              ;			   BYTE count,
 459+ 4EF8              ;			   INT[2][count] data_ptr
 460+ 4EF8              SPRGRPMOV:
 461+ 4EF8 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
 462+ 4EFB B7           	OR A
 463+ 4EFC CA 87 66     	JP Z,ILLEGAL_FUNCTION
 464+ 4EFF              	; opening (
 465+ 4EFF CD 67 66     	CALL CHKCHAR
 466+ 4F02 28           	DB '('
 467+ 4F03              	; get x
 468+ 4F03 DD 21 2F 54  	LD IX, FRMQNT
 469+ 4F07 CD 59 01     	CALL CALBAS
 470+ 4F0A ED 53 42 63  	LD (BLIT_STRUCT),DE
 471+ 4F0E              	; comma
 472+ 4F0E CD 67 66     	CALL CHKCHAR
 473+ 4F11 2C           	DB ','
 474+ 4F12              	; get y
 475+ 4F12 DD 21 2F 54  	LD IX, FRMQNT
 476+ 4F16 CD 59 01     	CALL CALBAS
 477+ 4F19 ED 53 44 63  	LD (BLIT_STRUCT+2),DE
 478+ 4F1D              	; comma
 479+ 4F1D CD 67 66     	CALL CHKCHAR
 480+ 4F20 2C           	DB ','
 481+ 4F21              	; get count
 482+ 4F21 DD 21 1C 52  	LD IX, GETBYT
 483+ 4F25 CD 59 01     	CALL CALBAS
 484+ 4F28 32 46 63     	LD (BLIT_STRUCT+4),A
 485+ 4F2B              	; comma
 486+ 4F2B CD 67 66     	CALL CHKCHAR
 487+ 4F2E 2C           	DB ','
 488+ 4F2F              	; get sprite group definition array data pointer
 489+ 4F2F 3A 46 63     	LD A,(BLIT_STRUCT+4)
 490+ 4F32 5F           	LD E,A
 491+ 4F33 16 03        	LD D,3
 492+ 4F35 3E 02        	LD A,2
 493+ 4F37 47           	LD B,A
 494+ 4F38 CD C0 66     	CALL GET_BASIC_ARRAY_DATA_POINTER
 495+ 4F3B ED 43 47 63  	LD (BLIT_STRUCT+5),BC
 496+ 4F3F              	; ending )
 497+ 4F3F CD 67 66     	CALL CHKCHAR
 498+ 4F42 29           	DB ')'
 499+ 4F43
 500+ 4F43 E5           	PUSH HL
 501+ 4F44
 502+ 4F44 D9               EXX
 503+ 4F45 ED 5B 42 63      LD DE,(BLIT_STRUCT) ; initial x
 504+ 4F49 ED 4B 44 63      LD BC,(BLIT_STRUCT+2) ; initial y
 505+ 4F4D D9               EXX
 506+ 4F4E 2A 47 63         LD HL,(BLIT_STRUCT+5) ; pointer to data
 507+ 4F51 3A 46 63         LD A,(BLIT_STRUCT+4) ; number of entries
 508+ 4F54 47               LD B,A
 509+ 4F55 CD DD 4E     	CALL SPR_UPDATE_LOC
 510+ 4F58
 511+ 4F58 E1           	POP HL
 512+ 4F59 C9           	RET
 513+ 4F5A              ; *******************************************************************************************************
 514+ 4F5A               ENDIF
 515+ 4F5A
 516+ 4F5A               IF (0 == 1)
 517+ 4F5A ~            ; *******************************************************************************************************
 518+ 4F5A ~            ; same as SPRGRPMOV but for DEFUSR approach
 519+ 4F5A ~            ; input IX=pointer to input array, real data from +2
 520+ 4F5A ~            ; +2 = X
 521+ 4F5A ~            ; +4 = Y
 522+ 4F5A ~            ; +6 = count
 523+ 4F5A ~            ; +8 = data pointer
 524+ 4F5A ~            SPRGRPMOV_DEFUSR:
 525+ 4F5A ~                EXX
 526+ 4F5A ~            	LD E,(IX+2)
 527+ 4F5A ~            	LD D,(IX+3) ; initial x
 528+ 4F5A ~            	LD C,(IX+4)
 529+ 4F5A ~            	LD B,(IX+5) ; initial y
 530+ 4F5A ~                EXX
 531+ 4F5A ~            	LD L,(IX+8)
 532+ 4F5A ~            	LD H,(IX+9) ; pointer to data
 533+ 4F5A ~                LD B,(IX+6) ; count
 534+ 4F5A ~                JP SPR_UPDATE_LOC
 535+ 4F5A ~            ; *******************************************************************************************************
 536+ 4F5A               ENDIF
# file closed: asm\SPRITES.asm
 133  4F5A               ENDIF
 134  4F5A
 135  4F5A               IF (ANIM_CMDS == 1)
 136  4F5A               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4F5A              ; sprite animation routines
   2+ 4F5A
   3+ 4F5A              ; number of animation items and pointer
   4+ 4F5A              ANIMITEMNUM:
   5+ 4F5A 00            DB 0
   6+ 4F5B              ANIMITEMPTR:
   7+ 4F5B 36 67         DW EXT_END
   8+ 4F5D              ; number of animation definitions and pointer
   9+ 4F5D              ANIMDEFNUM:
  10+ 4F5D 00            DB 0
  11+ 4F5E              ANIMDEFPTR:
  12+ 4F5E 36 67         DW EXT_END
  13+ 4F60              ; number of links between sprite and animation definitions
  14+ 4F60              ANIMSPRNUM:
  15+ 4F60 00            DB 0
  16+ 4F61              ANIMSPRPTR:
  17+ 4F61 36 67         DW EXT_END
  18+ 4F63              ; number of automatic sprite group move and animate structures
  19+ 4F63              AUTOSGAMNUM:
  20+ 4F63 00            DB 0
  21+ 4F64              AUTOSGAMPTR:
  22+ 4F64 36 67         DW EXT_END
  23+ 4F66
  24+ 4F66              ; ANIMATION ITEM
  25+ 4F66              ; byte type = [0 - pattern and color change
  26+ 4F66              ;              1 - pattern definition change ]
  27+ 4F66              ; word ticks - number of ticks to hold this state
  28+ 4F66              ; for type = 0
  29+ 4F66              ;   byte pattern;
  30+ 4F66              ;   byte color;
  31+ 4F66              ; for type = 1
  32+ 4F66              ;   work data_pointer;
  33+ 4F66              ; total size = 5b
  34+ 4F66
  35+ 4F66              ; ANIMATION DEFINITION
  36+ 4F66              ; byte number of items 1-15
  37+ 4F66              ; byte[15] anim_item;
  38+ 4F66              ; total size = 16b
  39+ 4F66
  40+ 4F66              ; SPRITE/CHAR ANIMATION
  41+ 4F66              ; +00 byte sprite/char number;
  42+ 4F66              ; +01 word time;
  43+ 4F66              ; +03 byte current item;
  44+ 4F66              ; +04 byte animation definition;
  45+ 4F66              ; +05 byte cyclic;
  46+ 4F66              ; +06 byte active;
  47+ 4F66              ; +07 byte 0=sprite, 1-3 character bank
  48+ 4F66              ; total size = 8b
  49+ 4F66
  50+ 4F66              ; AUTOMATIC SPRITE GROUP MOVE AND ANIMATE structure
  51+ 4F66              ; +00 pointer to X variable
  52+ 4F66              ; +02 pointer to Y variable
  53+ 4F66              ; +04 minimum value
  54+ 4F66              ; +06 maximal value
  55+ 4F66              ; +08 delta value
  56+ 4F66              ; +10 direction 0=horizontal, <>0 = vertical
  57+ 4F66              ; +11 sprite group size
  58+ 4F66              ; +12 sprite group pointer
  59+ 4F66              ; +14 animation list size
  60+ 4F66              ; +15 animation list pointer for negative delta values
  61+ 4F66              ; +17 animation list pointer for positive delta values
  62+ 4F66              ; +19 active flag
  63+ 4F66              ; +20 ticks for movement
  64+ 4F66              ; +22 timer
  65+ 4F66              ; total = 24b
  66+ 4F66
  67+ 4F66              ; *******************************************************************************************************
  68+ 4F66              ; helper function HL=A*5
  69+ 4F66              ; changes HL,DE
  70+ 4F66              Ax5:
  71+ 4F66 26 00            LD H,0
  72+ 4F68 6F               LD L,A
  73+ 4F69 54               LD D,H
  74+ 4F6A 5D               LD E,L
  75+ 4F6B 29               ADD HL,HL
  76+ 4F6C 29               ADD HL,HL
  77+ 4F6D 19               ADD HL,DE
  78+ 4F6E C9               RET
  79+ 4F6F              ; *******************************************************************************************************
  80+ 4F6F
  81+ 4F6F              ; *******************************************************************************************************
  82+ 4F6F              ; helper function gets pointer to n-th animation item
  83+ 4F6F              ; changes HL,DE
  84+ 4F6F              GETnthANIMITEM:
  85+ 4F6F CD 66 4F         CALL Ax5
  86+ 4F72 ED 5B 5B 4F      LD DE,(ANIMITEMPTR)
  87+ 4F76 19               ADD HL,DE
  88+ 4F77 C9               RET
  89+ 4F78              ; *******************************************************************************************************
  90+ 4F78
  91+ 4F78              ; *******************************************************************************************************
  92+ 4F78              ; helper function gets pointer to n-th entry in animation definition
  93+ 4F78              ; changes HL,DE
  94+ 4F78              GETnthANIMDEF:
  95+ 4F78 26 00            LD H,0
  96+ 4F7A 6F               LD L,A
  97+ 4F7B CD 53 65         CALL HLx16
  98+ 4F7E ED 5B 5E 4F      LD DE,(ANIMDEFPTR)
  99+ 4F82 19               ADD HL,DE
 100+ 4F83 C9               RET
 101+ 4F84              ; *******************************************************************************************************
 102+ 4F84
 103+ 4F84              ; *******************************************************************************************************
 104+ 4F84              ; helper function gets pointer to n-th entry in sprite animation
 105+ 4F84              ; changes HL,DE
 106+ 4F84              GETnthSPRANIM:
 107+ 4F84 26 00            LD H,0
 108+ 4F86 6F               LD L,A
 109+ 4F87 CD 54 65         CALL HLx8
 110+ 4F8A ED 5B 61 4F      LD DE,(ANIMSPRPTR)
 111+ 4F8E 19               ADD HL,DE
 112+ 4F8F C9               RET
 113+ 4F90              ; *******************************************************************************************************
 114+ 4F90
 115+ 4F90              ; *******************************************************************************************************
 116+ 4F90              ; helper function gets pointer to n-th entry in autosgam table
 117+ 4F90              ; changes HL,DE
 118+ 4F90              GETnthAUTOSGAM:
 119+ 4F90 26 00            LD H,0
 120+ 4F92 6F               LD L,A
 121+ 4F93 CD 54 65         CALL HLx8
 122+ 4F96 54               LD D,H
 123+ 4F97 5D               LD E,L
 124+ 4F98 29               ADD HL,HL
 125+ 4F99 19               ADD HL,DE
 126+ 4F9A ED 5B 64 4F      LD DE,(AUTOSGAMPTR)
 127+ 4F9E 19               ADD HL,DE
 128+ 4F9F C9               RET
 129+ 4FA0              ; *******************************************************************************************************
 130+ 4FA0
 131+ 4FA0               IF (0 == 1)
 132+ 4FA0 ~            ; *******************************************************************************************************
 133+ 4FA0 ~            ; same as MAXIANIMITEMS but for DEFUSR approach
 134+ 4FA0 ~            ; input IX=pointer to input array, real data from +2
 135+ 4FA0 ~            ; +2 = number
 136+ 4FA0 ~            MAXANIMITEMS_DEFUSR:
 137+ 4FA0 ~                LD A,(IX+2)
 138+ 4FA0 ~                JR MAXANIMITEMS.COMMON
 139+ 4FA0 ~            ; *******************************************************************************************************
 140+ 4FA0               ENDIF
 141+ 4FA0
 142+ 4FA0              ; *******************************************************************************************************
 143+ 4FA0              ; function to handle CALL MAXANIMITEMS basic extension
 144+ 4FA0              ; MAXANIMITEMS (BYTE number)
 145+ 4FA0              ; sets new number and moves memory buffers as needed
 146+ 4FA0              MAXANIMITEMS:
 147+ 4FA0               IF (1 == 1)
 148+ 4FA0              	; opening (
 149+ 4FA0 CD 67 66     	CALL CHKCHAR
 150+ 4FA3 28           	DB '('
 151+ 4FA4              	; get value
 152+ 4FA4 DD 21 1C 52  	LD IX, GETBYT
 153+ 4FA8 CD 59 01     	CALL CALBAS
 154+ 4FAB F5               PUSH AF
 155+ 4FAC              	; ending )
 156+ 4FAC CD 67 66     	CALL CHKCHAR
 157+ 4FAF 29           	DB ')'
 158+ 4FB0 F1               POP AF
 159+ 4FB1               ENDIF
 160+ 4FB1              .COMMON: ; entry for DEFUSR part, A=number
 161+ 4FB1 F3               DI
 162+ 4FB2              	; save position
 163+ 4FB2 E5           	PUSH HL
 164+ 4FB3              .ENTRY:
 165+ 4FB3 47               LD B,A
 166+ 4FB4 3A 5A 4F         LD A,(ANIMITEMNUM)
 167+ 4FB7 90               SUB B
 168+ 4FB8 28 28            JR Z, .EXIT; same value as before
 169+ 4FBA FD 21 5E 4F      LD IY,ANIMDEFPTR
 170+ 4FBE FA E5 4F         JP M, .INCREASE
 171+ 4FC1                  ; new value is lower than previous one
 172+ 4FC1 CD 04 50         CALL .SIZEDIFF
 173+ 4FC4 CD 1F 50         CALL .DECREASE_COMMON
 174+ 4FC7 2A 61 4F         LD HL,(ANIMSPRPTR)
 175+ 4FCA AF               XOR A
 176+ 4FCB ED 42            SBC HL,BC
 177+ 4FCD 22 61 4F         LD (ANIMSPRPTR),HL
 178+ 4FD0              .E1:
 179+ 4FD0 2A 64 4F         LD HL,(AUTOSGAMPTR)
 180+ 4FD3 AF               XOR A
 181+ 4FD4 ED 42            SBC HL,BC
 182+ 4FD6 22 64 4F         LD (AUTOSGAMPTR),HL
 183+ 4FD9              .E3:
 184+ 4FD9 2A 10 40         LD HL,(FREEMEMPTR)
 185+ 4FDC AF               XOR A
 186+ 4FDD ED 42            SBC HL,BC
 187+ 4FDF 22 10 40         LD (FREEMEMPTR),HL
 188+ 4FE2              .EXIT:
 189+ 4FE2 FB               EI
 190+ 4FE3 E1           	POP HL
 191+ 4FE4 C9           	RET
 192+ 4FE5              .INCREASE:
 193+ 4FE5 ED 44            NEG
 194+ 4FE7 CD 04 50         CALL .SIZEDIFF
 195+ 4FEA CD 4B 50         CALL .INCREASE_COMMON
 196+ 4FED 2A 61 4F         LD HL,(ANIMSPRPTR)
 197+ 4FF0 09               ADD HL,BC
 198+ 4FF1 22 61 4F         LD (ANIMSPRPTR),HL
 199+ 4FF4              .E2:
 200+ 4FF4 2A 64 4F         LD HL,(AUTOSGAMPTR)
 201+ 4FF7 09               ADD HL,BC
 202+ 4FF8 22 64 4F         LD (AUTOSGAMPTR),HL
 203+ 4FFB              .E4:
 204+ 4FFB 2A 10 40         LD HL,(FREEMEMPTR)
 205+ 4FFE 09               ADD HL,BC
 206+ 4FFF 22 10 40         LD (FREEMEMPTR),HL
 207+ 5002 18 DE            JR .EXIT
 208+ 5004              .SIZEDIFF:
 209+ 5004 CD 66 4F         CALL Ax5
 210+ 5007 78               LD A,B
 211+ 5008 32 5A 4F         LD (ANIMITEMNUM),A
 212+ 500B 44               LD B,H
 213+ 500C 4D               LD C,L
 214+ 500D C9               RET ; BC=size difference in bytes
 215+ 500E              .SIZETOMOVE:
 216+ 500E D5               PUSH DE
 217+ 500F 2A 10 40         LD HL,(FREEMEMPTR)
 218+ 5012 FD 5E 00         LD E,(IY)
 219+ 5015 FD 56 01         LD D,(IY+1)
 220+ 5018 AF               XOR A
 221+ 5019 ED 52            SBC HL,DE
 222+ 501B 44               LD B,H
 223+ 501C 4D               LD C,L
 224+ 501D D1               POP DE
 225+ 501E C9               RET
 226+ 501F              .DECREASE_COMMON:
 227+ 501F FD 6E 00         LD L,(IY)
 228+ 5022 FD 66 01         LD H,(IY+1)
 229+ 5025 AF               XOR A
 230+ 5026 ED 42            SBC HL,BC
 231+ 5028 EB               EX DE,HL
 232+ 5029 C5               PUSH BC
 233+ 502A CD 0E 50         CALL .SIZETOMOVE
 234+ 502D F3               DI
 235+ 502E 78               LD A,B
 236+ 502F B1               OR C
 237+ 5030 28 08            JR Z,.L1
 238+ 5032 FD 6E 00         LD L,(IY)
 239+ 5035 FD 66 01         LD H,(IY+1)
 240+ 5038 ED B0            LDIR
 241+ 503A              .L1:
 242+ 503A C1               POP BC
 243+ 503B FD 6E 00         LD L,(IY)
 244+ 503E FD 66 01         LD H,(IY+1)
 245+ 5041 AF               XOR A
 246+ 5042 ED 42            SBC HL,BC
 247+ 5044 FD 75 00         LD (IY),L
 248+ 5047 FD 74 01         LD (IY+1),H
 249+ 504A C9               RET
 250+ 504B              .INCREASE_COMMON:
 251+ 504B 2A 10 40         LD HL,(FREEMEMPTR)
 252+ 504E 2B               DEC HL
 253+ 504F AF               XOR A
 254+ 5050 ED 42            SBC HL,BC
 255+ 5052 EB               EX DE,HL
 256+ 5053 C5               PUSH BC
 257+ 5054 CD 0E 50         CALL .SIZETOMOVE
 258+ 5057 F3               DI
 259+ 5058 78               LD A,B
 260+ 5059 B1               OR C
 261+ 505A 28 06            JR Z,.L2
 262+ 505C 2A 10 40         LD HL,(FREEMEMPTR)
 263+ 505F 2B               DEC HL
 264+ 5060 ED B8            LDDR
 265+ 5062              .L2:
 266+ 5062 C1               POP BC
 267+ 5063 FD 6E 00         LD L,(IY)
 268+ 5066 FD 66 01         LD H,(IY+1)
 269+ 5069 09               ADD HL,BC
 270+ 506A FD 75 00         LD (IY),L
 271+ 506D FD 74 01         LD (IY+1),H
 272+ 5070 C9               RET
 273+ 5071              ; *******************************************************************************************************
 274+ 5071
 275+ 5071               IF (1 == 1)
 276+ 5071              ; *******************************************************************************************************
 277+ 5071              ; function to handle CALL ANIMITEMPAT basic extension
 278+ 5071              ; ANIMITEMPAT ( BYTE id,
 279+ 5071              ;               INT ticks >0,
 280+ 5071              ;               BYTE pattern,
 281+ 5071              ;               BYTE color )
 282+ 5071              ; fills animation item data, returns an error if ID out of bounds
 283+ 5071              ANIMITEMPAT:
 284+ 5071                  ; opening (
 285+ 5071 CD 67 66     	CALL CHKCHAR
 286+ 5074 28           	DB '('
 287+ 5075              	; get id
 288+ 5075 DD 21 1C 52  	LD IX, GETBYT
 289+ 5079 CD 59 01     	CALL CALBAS
 290+ 507C F5               PUSH AF
 291+ 507D                  ; check if out of bounds
 292+ 507D 3C               INC A
 293+ 507E 4F               LD C,A
 294+ 507F 3A 5A 4F         LD A,(ANIMITEMNUM)
 295+ 5082 B9               CP C
 296+ 5083 DA 7F 66         JP C,SUBSCRIPT_OUT_OF_RANGE
 297+ 5086              	; comma
 298+ 5086 CD 67 66     	CALL CHKCHAR
 299+ 5089 2C           	DB ','
 300+ 508A              	; get ticks
 301+ 508A DD 21 2F 54  	LD IX, FRMQNT
 302+ 508E CD 59 01     	CALL CALBAS
 303+ 5091 7A               LD A,D
 304+ 5092 B3               OR E
 305+ 5093 CA 83 66         JP Z, OVERFLOW
 306+ 5096 D5           	PUSH DE
 307+ 5097              	; comma
 308+ 5097 CD 67 66     	CALL CHKCHAR
 309+ 509A 2C           	DB ','
 310+ 509B              	; get pattern
 311+ 509B DD 21 1C 52  	LD IX, GETBYT
 312+ 509F CD 59 01     	CALL CALBAS
 313+ 50A2 F5               PUSH AF
 314+ 50A3              	; comma
 315+ 50A3 CD 67 66     	CALL CHKCHAR
 316+ 50A6 2C           	DB ','
 317+ 50A7              	; get color
 318+ 50A7 DD 21 1C 52  	LD IX, GETBYT
 319+ 50AB CD 59 01     	CALL CALBAS
 320+ 50AE F5               PUSH AF
 321+ 50AF              	; ending )
 322+ 50AF CD 67 66     	CALL CHKCHAR
 323+ 50B2 29           	DB ')'
 324+ 50B3              .ENTRY:
 325+ 50B3 E5               PUSH HL
 326+ 50B4 DD E1            POP IX
 327+ 50B6 D9               EXX
 328+ 50B7 C1               POP BC ; color
 329+ 50B8 D1               POP DE ; pattern
 330+ 50B9 E1               POP HL ; ticks
 331+ 50BA D9               EXX
 332+ 50BB F1               POP AF
 333+ 50BC CD 6F 4F         CALL GETnthANIMITEM
 334+ 50BF E5               PUSH HL
 335+ 50C0 FD E1            POP IY
 336+ 50C2 D9               EXX
 337+ 50C3 FD 36 00 00      LD (IY),0 ; type=0
 338+ 50C7 FD 75 01         LD (IY+1),L
 339+ 50CA FD 74 02         LD (IY+2),H
 340+ 50CD FD 72 03         LD (IY+3),D
 341+ 50D0 FD 70 04         LD (IY+4),B
 342+ 50D3
 343+ 50D3 DD E5            PUSH IX
 344+ 50D5 E1               POP HL
 345+ 50D6 C9               RET
 346+ 50D7              ; *******************************************************************************************************
 347+ 50D7               ENDIF
 348+ 50D7
 349+ 50D7               IF (0 == 1)
 350+ 50D7 ~            ; *******************************************************************************************************
 351+ 50D7 ~            ; same as ANIMITEMPAT but for DEFUSR approach
 352+ 50D7 ~            ; input IX=pointer to input array, real data from +2
 353+ 50D7 ~            ; +02 = ID
 354+ 50D7 ~            ; +04 = ticks
 355+ 50D7 ~            ; +06 = pattern
 356+ 50D7 ~            ; +08 = color
 357+ 50D7 ~            ANIMITEMPAT_DEFUSR:
 358+ 50D7 ~                ; check if out of bounds
 359+ 50D7 ~                LD C,(IX+2)
 360+ 50D7 ~                INC C
 361+ 50D7 ~                LD A,(ANIMITEMNUM)
 362+ 50D7 ~                CP C
 363+ 50D7 ~                RET C ; out of bounds, prevent memory corruption
 364+ 50D7 ~                LD A,C
 365+ 50D7 ~                DEC A
 366+ 50D7 ~                CALL GETnthANIMITEM
 367+ 50D7 ~                LD (HL),0 ; type=0
 368+ 50D7 ~                INC HL
 369+ 50D7 ~                LD A,(IX+4) ; ticks low
 370+ 50D7 ~                LD (HL),A
 371+ 50D7 ~                INC HL
 372+ 50D7 ~                LD A,(IX+5) ; ticks high
 373+ 50D7 ~                LD (HL),A
 374+ 50D7 ~                INC HL
 375+ 50D7 ~                LD A,(IX+6) ; pattern
 376+ 50D7 ~                LD (HL),A
 377+ 50D7 ~                INC HL
 378+ 50D7 ~                LD A,(IX+8) ; color
 379+ 50D7 ~                LD (HL),A
 380+ 50D7 ~                RET
 381+ 50D7 ~            ; *******************************************************************************************************
 382+ 50D7               ENDIF
 383+ 50D7
 384+ 50D7               IF (1 == 1)
 385+ 50D7              ; *******************************************************************************************************
 386+ 50D7              ; function to handle CALL ANIMITEMPTR basic extension
 387+ 50D7              ; ANIMITEMPTR ( BYTE id,
 388+ 50D7              ;               INT ticks,
 389+ 50D7              ;               INT pointer,
 390+ 50D7              ; fills animation item data, returns an error if ID out of bounds
 391+ 50D7              ANIMITEMPTR_CMD:
 392+ 50D7                  ; opening (
 393+ 50D7 CD 67 66     	CALL CHKCHAR
 394+ 50DA 28           	DB '('
 395+ 50DB              	; get id
 396+ 50DB DD 21 1C 52  	LD IX, GETBYT
 397+ 50DF CD 59 01     	CALL CALBAS
 398+ 50E2 F5               PUSH AF
 399+ 50E3                  ; check if out of bounds
 400+ 50E3 3C               INC A
 401+ 50E4 4F               LD C,A
 402+ 50E5 3A 5A 4F         LD A,(ANIMITEMNUM)
 403+ 50E8 B9               CP C
 404+ 50E9 DA 7F 66         JP C,SUBSCRIPT_OUT_OF_RANGE
 405+ 50EC              	; comma
 406+ 50EC CD 67 66     	CALL CHKCHAR
 407+ 50EF 2C           	DB ','
 408+ 50F0              	; get ticks
 409+ 50F0 DD 21 2F 54  	LD IX, FRMQNT
 410+ 50F4 CD 59 01     	CALL CALBAS
 411+ 50F7 7A               LD A,D
 412+ 50F8 B3               OR E
 413+ 50F9 CA 83 66         JP Z,OVERFLOW
 414+ 50FC D5           	PUSH DE
 415+ 50FD              	; comma
 416+ 50FD CD 67 66     	CALL CHKCHAR
 417+ 5100 2C           	DB ','
 418+ 5101              	; get pointer
 419+ 5101 DD 21 2F 54  	LD IX, FRMQNT
 420+ 5105 CD 59 01     	CALL CALBAS
 421+ 5108 D5           	PUSH DE
 422+ 5109              	; ending )
 423+ 5109 CD 67 66     	CALL CHKCHAR
 424+ 510C 29           	DB ')'
 425+ 510D              .ENTRY:
 426+ 510D E5               PUSH HL
 427+ 510E DD E1            POP IX
 428+ 5110 D9               EXX
 429+ 5111 D1               POP DE ; pointer
 430+ 5112 E1               POP HL ; ticks
 431+ 5113 D9               EXX
 432+ 5114 F1               POP AF
 433+ 5115 CD 6F 4F         CALL GETnthANIMITEM
 434+ 5118 E5               PUSH HL
 435+ 5119 FD E1            POP IY
 436+ 511B D9               EXX
 437+ 511C FD 36 00 01      LD (IY),1 ; type=1
 438+ 5120 FD 75 01         LD (IY+1),L
 439+ 5123 FD 74 02         LD (IY+2),H
 440+ 5126 FD 73 03         LD (IY+3),E
 441+ 5129 FD 72 04         LD (IY+4),D
 442+ 512C
 443+ 512C DD E5            PUSH IX
 444+ 512E E1               POP HL
 445+ 512F C9               RET
 446+ 5130              ; *******************************************************************************************************
 447+ 5130               ENDIF
 448+ 5130
 449+ 5130               IF (0 == 1)
 450+ 5130 ~            ; *******************************************************************************************************
 451+ 5130 ~            ; same as ANIMITEMPTR but for DEFUSR approach
 452+ 5130 ~            ; input IX=pointer to input array, real data from +2
 453+ 5130 ~            ; +02 = ID
 454+ 5130 ~            ; +04 = ticks
 455+ 5130 ~            ; +06 = pointer
 456+ 5130 ~            ANIMITEMPTR_DEFUSR:
 457+ 5130 ~                ; check if out of bounds
 458+ 5130 ~                LD C,(IX+2)
 459+ 5130 ~                INC C
 460+ 5130 ~                LD A,(ANIMITEMNUM)
 461+ 5130 ~                CP C
 462+ 5130 ~                RET C ; out of bounds, prevent memory corruption
 463+ 5130 ~                LD A,C
 464+ 5130 ~                DEC A
 465+ 5130 ~                CALL GETnthANIMITEM
 466+ 5130 ~                LD (HL),1 ; type=1
 467+ 5130 ~                INC HL
 468+ 5130 ~                LD A,(IX+4) ; ticks low
 469+ 5130 ~                LD (HL),A
 470+ 5130 ~                INC HL
 471+ 5130 ~                LD A,(IX+5) ; ticks high
 472+ 5130 ~                LD (HL),A
 473+ 5130 ~                INC HL
 474+ 5130 ~                LD A,(IX+6) ; pointer low
 475+ 5130 ~                LD (HL),A
 476+ 5130 ~                INC HL
 477+ 5130 ~                LD A,(IX+7) ; pointer high
 478+ 5130 ~                LD (HL),A
 479+ 5130 ~                RET
 480+ 5130 ~            ; *******************************************************************************************************
 481+ 5130               ENDIF
 482+ 5130
 483+ 5130               IF (0 == 1)
 484+ 5130 ~            ; *******************************************************************************************************
 485+ 5130 ~            ; same as MAXANIMDEFS but for DEFUSR approach
 486+ 5130 ~            ; input IX=pointer to input array, real data from +2
 487+ 5130 ~            ; +2 = number
 488+ 5130 ~            MAXANIMDEFS_DEFUSR:
 489+ 5130 ~                LD A,(IX+2)
 490+ 5130 ~                JR MAXANIMDEFS.COMMON
 491+ 5130 ~            ; *******************************************************************************************************
 492+ 5130               ENDIF
 493+ 5130
 494+ 5130              ; *******************************************************************************************************
 495+ 5130              ; function to handle CALL MAXANIMDEFS basic extension
 496+ 5130              ; MAXANIMDEFS (BYTE number)
 497+ 5130              ; sets new number and moves memory buffers as needed
 498+ 5130              MAXANIMDEFS:
 499+ 5130               IF (1 == 1)
 500+ 5130              	; opening (
 501+ 5130 CD 67 66     	CALL CHKCHAR
 502+ 5133 28           	DB '('
 503+ 5134              	; get value
 504+ 5134 DD 21 1C 52  	LD IX, GETBYT
 505+ 5138 CD 59 01     	CALL CALBAS
 506+ 513B F5               PUSH AF
 507+ 513C              	; ending )
 508+ 513C CD 67 66     	CALL CHKCHAR
 509+ 513F 29           	DB ')'
 510+ 5140 F1               POP AF
 511+ 5141               ENDIF
 512+ 5141              .COMMON:
 513+ 5141 F3               DI
 514+ 5142              	; save position
 515+ 5142 E5           	PUSH HL
 516+ 5143              .ENTRY:
 517+ 5143 47               LD B,A
 518+ 5144 3A 5D 4F         LD A,(ANIMDEFNUM)
 519+ 5147 90               SUB B
 520+ 5148 CA E2 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 521+ 514B FD 21 61 4F      LD IY,ANIMSPRPTR
 522+ 514F FA 5B 51         JP M, .INCREASE
 523+ 5152                  ; new value is lower than previous one
 524+ 5152 CD 66 51         CALL .SIZEDIFF
 525+ 5155 CD 1F 50         CALL MAXANIMITEMS.DECREASE_COMMON
 526+ 5158 C3 D0 4F         JP MAXANIMITEMS.E1
 527+ 515B              .INCREASE:
 528+ 515B ED 44            NEG
 529+ 515D CD 66 51         CALL .SIZEDIFF
 530+ 5160 CD 4B 50         CALL MAXANIMITEMS.INCREASE_COMMON
 531+ 5163 C3 F4 4F         JP MAXANIMITEMS.E2
 532+ 5166              .SIZEDIFF:
 533+ 5166 26 00            LD H,0
 534+ 5168 6F               LD L,A
 535+ 5169 CD 53 65         CALL HLx16
 536+ 516C 78               LD A,B
 537+ 516D 32 5D 4F         LD (ANIMDEFNUM),A
 538+ 5170 44               LD B,H
 539+ 5171 4D               LD C,L
 540+ 5172 C9               RET ; BC=size difference in bytes
 541+ 5173              ; *******************************************************************************************************
 542+ 5173
 543+ 5173               IF (1 == 1)
 544+ 5173              ; *******************************************************************************************************
 545+ 5173              ; function to handle CALL ANIMDEF basic extension
 546+ 5173              ; ANIMITEMPAT ( BYTE id,
 547+ 5173              ;               BYTE size,
 548+ 5173              ;               INT[] list )
 549+ 5173              ; fills animation definition data, returns an error if out of bounds, or invalid type
 550+ 5173              ANIMDEF:
 551+ 5173                  ; opening (
 552+ 5173 CD 67 66     	CALL CHKCHAR
 553+ 5176 28           	DB '('
 554+ 5177              	; get id
 555+ 5177 DD 21 1C 52  	LD IX, GETBYT
 556+ 517B CD 59 01     	CALL CALBAS
 557+ 517E F5               PUSH AF
 558+ 517F                  ; check if out of bounds
 559+ 517F 3C               INC A
 560+ 5180 4F               LD C,A
 561+ 5181 3A 5D 4F         LD A,(ANIMDEFNUM)
 562+ 5184 B9               CP C
 563+ 5185 DA 7F 66         JP C,SUBSCRIPT_OUT_OF_RANGE
 564+ 5188              	; comma
 565+ 5188 CD 67 66     	CALL CHKCHAR
 566+ 518B 2C           	DB ','
 567+ 518C              	; get size
 568+ 518C DD 21 1C 52  	LD IX, GETBYT
 569+ 5190 CD 59 01     	CALL CALBAS
 570+ 5193 FE 10            CP 16
 571+ 5195 D2 83 66         JP NC, OVERFLOW
 572+ 5198 B7               OR A
 573+ 5199 CA 83 66         JP Z, OVERFLOW
 574+ 519C F5           	PUSH AF
 575+ 519D              	; comma
 576+ 519D CD 67 66     	CALL CHKCHAR
 577+ 51A0 2C           	DB ','
 578+ 51A1              	; get pointer to a list of animation items in integer array format
 579+ 51A1                  ; get array pointer
 580+ 51A1 D1               POP DE
 581+ 51A2 D5               PUSH DE
 582+ 51A3 3E 02            LD A,2
 583+ 51A5 06 01            LD B,1
 584+ 51A7 CD C0 66         CALL GET_BASIC_ARRAY_DATA_POINTER
 585+ 51AA C5               PUSH BC
 586+ 51AB              	; ending )
 587+ 51AB CD 67 66     	CALL CHKCHAR
 588+ 51AE 29           	DB ')'
 589+ 51AF              .ENTRY:
 590+ 51AF E5               PUSH HL
 591+ 51B0 DD E1            POP IX
 592+ 51B2 D1               POP DE ; pointer to INT array
 593+ 51B3 C1               POP BC ; B=item number
 594+ 51B4 F1               POP AF ; id
 595+ 51B5 D5               PUSH DE
 596+ 51B6 CD 78 4F         CALL GETnthANIMDEF
 597+ 51B9 D1               POP DE
 598+ 51BA 70               LD (HL),B
 599+ 51BB              .L1:
 600+ 51BB 23               INC HL
 601+ 51BC 1A               LD A,(DE)
 602+ 51BD 13          > INC DE
 602+ 51BE 13          > INC DE
 603+ 51BF 77               LD (HL),A
 604+ 51C0 10 F9            DJNZ .L1
 605+ 51C2 DD E5            PUSH IX
 606+ 51C4 E1               POP HL
 607+ 51C5 C9               RET
 608+ 51C6              ; *******************************************************************************************************
 609+ 51C6               ENDIF
 610+ 51C6
 611+ 51C6               IF (0 == 1)
 612+ 51C6 ~            ; *******************************************************************************************************
 613+ 51C6 ~            ; same as ANIMDEF but for DEFUSR approach
 614+ 51C6 ~            ; input IX=pointer to input array, real data from +2
 615+ 51C6 ~            ; +02 = ID
 616+ 51C6 ~            ; +04 = list size
 617+ 51C6 ~            ; +06 = list pointer
 618+ 51C6 ~            ANIMDEF_DEFUSR:
 619+ 51C6 ~                ; check if out of bounds
 620+ 51C6 ~                LD C,(IX+2)
 621+ 51C6 ~                INC C
 622+ 51C6 ~                LD A,(ANIMDEFNUM)
 623+ 51C6 ~                CP C
 624+ 51C6 ~                RET C ; invalid id
 625+ 51C6 ~            	; get size
 626+ 51C6 ~                LD A,(IX+4)
 627+ 51C6 ~                CP 16
 628+ 51C6 ~                RET NC ; overflow
 629+ 51C6 ~                OR A
 630+ 51C6 ~                RET Z ; ID=0, invalid
 631+ 51C6 ~                LD B,A
 632+ 51C6 ~                LD A,C
 633+ 51C6 ~                DEC A
 634+ 51C6 ~                CALL GETnthANIMDEF
 635+ 51C6 ~                LD (HL),B
 636+ 51C6 ~                LD E,(IX+6)
 637+ 51C6 ~                LD D,(IX+7)
 638+ 51C6 ~            .L1:
 639+ 51C6 ~                INC HL
 640+ 51C6 ~                LD A,(DE)
 641+ 51C6 ~                .2 INC DE
 642+ 51C6 ~                LD (HL),A
 643+ 51C6 ~                DJNZ .L1
 644+ 51C6 ~                RET
 645+ 51C6 ~            ; *******************************************************************************************************
 646+ 51C6               ENDIF
 647+ 51C6
 648+ 51C6               IF (0 == 1)
 649+ 51C6 ~            ; *******************************************************************************************************
 650+ 51C6 ~            ; same as MAXANIMSPRS but for DEFUSR approach
 651+ 51C6 ~            ; input IX=pointer to input array, real data from +2
 652+ 51C6 ~            ; +2 = number
 653+ 51C6 ~            MAXANIMSPRS_DEFUSR:
 654+ 51C6 ~                LD A,(IX+2)
 655+ 51C6 ~                JR MAXANIMSPRS.COMMON
 656+ 51C6 ~            ; *******************************************************************************************************
 657+ 51C6               ENDIF
 658+ 51C6
 659+ 51C6              ; *******************************************************************************************************
 660+ 51C6              ; function to handle CALL MAXANIMSPRS basic extension
 661+ 51C6              ; MAXANIMSPRS (BYTE number)
 662+ 51C6              ; sets new number and moves memory buffers as needed
 663+ 51C6              MAXANIMSPRS:
 664+ 51C6               IF (1 == 1)
 665+ 51C6              	; opening (
 666+ 51C6 CD 67 66     	CALL CHKCHAR
 667+ 51C9 28           	DB '('
 668+ 51CA              	; get value
 669+ 51CA DD 21 1C 52  	LD IX, GETBYT
 670+ 51CE CD 59 01     	CALL CALBAS
 671+ 51D1 F5               PUSH AF
 672+ 51D2              	; ending )
 673+ 51D2 CD 67 66     	CALL CHKCHAR
 674+ 51D5 29           	DB ')'
 675+ 51D6 F1               POP AF
 676+ 51D7               ENDIF
 677+ 51D7              .COMMON:
 678+ 51D7 F3               DI
 679+ 51D8              	; save position
 680+ 51D8 E5           	PUSH HL
 681+ 51D9              .ENTRY:
 682+ 51D9 47               LD B,A
 683+ 51DA 3A 60 4F         LD A,(ANIMSPRNUM)
 684+ 51DD 90               SUB B
 685+ 51DE CA E2 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 686+ 51E1 FD 21 64 4F      LD IY,AUTOSGAMPTR
 687+ 51E5 FA F1 51         JP M, .INCREASE
 688+ 51E8                  ; new value is lower than previous one
 689+ 51E8 CD 12 52         CALL .SIZEDIFF
 690+ 51EB CD 1F 50         CALL MAXANIMITEMS.DECREASE_COMMON
 691+ 51EE C3 D9 4F         JP MAXANIMITEMS.E3
 692+ 51F1              .INCREASE:
 693+ 51F1 ED 44            NEG
 694+ 51F3 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 695+ 51F4 CD 12 52         CALL .SIZEDIFF
 696+ 51F7 CD 4B 50         CALL MAXANIMITEMS.INCREASE_COMMON
 697+ 51FA AF               XOR A
 698+ 51FB ED 42            SBC HL,BC ; location of new stuff
 699+ 51FD F1               POP AF
 700+ 51FE C5               PUSH BC
 701+ 51FF 47               LD B,A
 702+ 5200 11 08 00         LD DE,8
 703+ 5203 E5               PUSH HL
 704+ 5204 DD E1            POP IX
 705+ 5206              .L1:
 706+ 5206 DD 36 06 00      LD (IX+6),0 ; active flag
 707+ 520A DD 19            ADD IX,DE
 708+ 520C 10 F8            DJNZ .L1
 709+ 520E C1               POP BC
 710+ 520F C3 FB 4F         JP MAXANIMITEMS.E4
 711+ 5212              .SIZEDIFF:
 712+ 5212 26 00            LD H,0
 713+ 5214 6F               LD L,A
 714+ 5215 CD 54 65         CALL HLx8
 715+ 5218 78               LD A,B
 716+ 5219 32 60 4F         LD (ANIMSPRNUM),A
 717+ 521C 44               LD B,H
 718+ 521D 4D               LD C,L
 719+ 521E C9               RET ; BC=size difference in bytes
 720+ 521F              ; *******************************************************************************************************
 721+ 521F
 722+ 521F               IF (1 == 1)
 723+ 521F              ; *******************************************************************************************************
 724+ 521F              ; function to handle CALL ANIMSPRITE basic extension
 725+ 521F              ; ANIMSPRITE ( BYTE id,
 726+ 521F              ;              BYTE sprite_number,
 727+ 521F              ;              BYTE animation_definition_id,
 728+ 521F              ;              BYTE cyclic_flag )
 729+ 521F              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 730+ 521F              ANIMSPRITE:
 731+ 521F                  ; opening (
 732+ 521F CD 67 66     	CALL CHKCHAR
 733+ 5222 28           	DB '('
 734+ 5223              	; get sprite animation id
 735+ 5223 DD 21 1C 52  	LD IX, GETBYT
 736+ 5227 CD 59 01     	CALL CALBAS
 737+ 522A F5               PUSH AF
 738+ 522B 3C               INC A
 739+ 522C 4F               LD C,A
 740+ 522D 3A 60 4F         LD A,(ANIMSPRNUM)
 741+ 5230 B9               CP C
 742+ 5231 DA 7F 66         JP C,SUBSCRIPT_OUT_OF_RANGE
 743+ 5234              	; comma
 744+ 5234 CD 67 66     	CALL CHKCHAR
 745+ 5237 2C           	DB ','
 746+ 5238              	; get sprite number
 747+ 5238 DD 21 1C 52  	LD IX, GETBYT
 748+ 523C CD 59 01     	CALL CALBAS
 749+ 523F F5               PUSH AF
 750+ 5240                  ; check if out of bounds
 751+ 5240 FE 20            CP 32
 752+ 5242 D2 7F 66         JP NC, SUBSCRIPT_OUT_OF_RANGE
 753+ 5245              	; comma
 754+ 5245 CD 67 66     	CALL CHKCHAR
 755+ 5248 2C           	DB ','
 756+ 5249              	; get animation definition id
 757+ 5249 DD 21 1C 52  	LD IX, GETBYT
 758+ 524D CD 59 01     	CALL CALBAS
 759+ 5250 F5               PUSH AF
 760+ 5251 3C               INC A
 761+ 5252 4F               LD C,A
 762+ 5253 3A 5D 4F         LD A,(ANIMDEFNUM)
 763+ 5256 B9               CP C
 764+ 5257 DA 7F 66         JP C,SUBSCRIPT_OUT_OF_RANGE
 765+ 525A              	; comma
 766+ 525A CD 67 66     	CALL CHKCHAR
 767+ 525D 2C           	DB ','
 768+ 525E              	; get cyclic flag
 769+ 525E DD 21 1C 52  	LD IX, GETBYT
 770+ 5262 CD 59 01         CALL CALBAS
 771+ 5265 F5           	PUSH AF
 772+ 5266              	; ending )
 773+ 5266 CD 67 66     	CALL CHKCHAR
 774+ 5269 29           	DB ')'
 775+ 526A              .ENTRY:
 776+ 526A E5               PUSH HL
 777+ 526B DD E1            POP IX
 778+ 526D D9               EXX
 779+ 526E D1               POP DE ; cyclic
 780+ 526F C1               POP BC ; animation definition id
 781+ 5270 E1               POP HL ; sprite number
 782+ 5271 D9               EXX
 783+ 5272 F1               POP AF ; sprite animation id
 784+ 5273 CD 84 4F         CALL GETnthSPRANIM
 785+ 5276 E5               PUSH HL
 786+ 5277 FD E1            POP IY
 787+ 5279 D9               EXX
 788+ 527A FD 74 00         LD (IY),H
 789+ 527D FD 70 04         LD (IY+4),B
 790+ 5280 FD 72 05         LD (IY+5),D
 791+ 5283                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 792+ 5283                  ; following will do preparation for ANIMSTEP situation
 793+ 5283                  ; current item set to above limit and timer to 1
 794+ 5283                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 795+ 5283 FD 36 03 FF      LD (IY+3),255
 796+ 5287 FD 36 01 01      LD (IY+1),1
 797+ 528B FD 36 02 00      LD (IY+2),0
 798+ 528F                  ; mark as sprite animation
 799+ 528F FD 36 07 00      LD (IY+7),0
 800+ 5293 DD E5            PUSH IX
 801+ 5295 E1               POP HL
 802+ 5296 C9               RET
 803+ 5297              ; *******************************************************************************************************
 804+ 5297               ENDIF
 805+ 5297
 806+ 5297               IF (0 == 1)
 807+ 5297 ~            ; *******************************************************************************************************
 808+ 5297 ~            ; same as ANIMSPRITE but for DEFUSR approach
 809+ 5297 ~            ; input IX=pointer to input array, real data from +2
 810+ 5297 ~            ; +02 = ID
 811+ 5297 ~            ; +04 = sprite number
 812+ 5297 ~            ; +06 = animation definition id
 813+ 5297 ~            ; +08 = cyclic flag
 814+ 5297 ~            ANIMSPRITE_DEFUSR:
 815+ 5297 ~                LD C,(IX+2)
 816+ 5297 ~                INC C
 817+ 5297 ~                LD A,(ANIMSPRNUM)
 818+ 5297 ~                CP C
 819+ 5297 ~                RET C ; invalid id
 820+ 5297 ~            	; get sprite number
 821+ 5297 ~                LD A,(IX+4)
 822+ 5297 ~                CP 32
 823+ 5297 ~                RET NC ; invalid sprite id
 824+ 5297 ~                LD B,(IX+6)
 825+ 5297 ~                INC B
 826+ 5297 ~                LD A,(ANIMDEFNUM)
 827+ 5297 ~                CP B
 828+ 5297 ~                RET C ; invalid animation definition id
 829+ 5297 ~                LD A,C
 830+ 5297 ~                DEC A
 831+ 5297 ~                CALL GETnthSPRANIM
 832+ 5297 ~                LD A,(IX+4)
 833+ 5297 ~                LD (HL),A ; +0
 834+ 5297 ~                INC HL
 835+ 5297 ~                LD (HL),1 ; +1
 836+ 5297 ~                INC HL
 837+ 5297 ~                LD (HL),0 ; +2
 838+ 5297 ~                INC HL
 839+ 5297 ~                LD (HL),255 ; +3
 840+ 5297 ~                INC HL
 841+ 5297 ~                DEC B
 842+ 5297 ~                LD (HL),B ; +4
 843+ 5297 ~                INC HL
 844+ 5297 ~                LD A,(IX+8) ; +5
 845+ 5297 ~                LD (HL),A
 846+ 5297 ~                INC HL
 847+ 5297 ~                INC HL
 848+ 5297 ~                LD (HL),0 ; +7
 849+ 5297 ~                RET
 850+ 5297 ~            ; *******************************************************************************************************
 851+ 5297               ENDIF
 852+ 5297
 853+ 5297
 854+ 5297               IF (1 == 1)
 855+ 5297              ; *******************************************************************************************************
 856+ 5297              ; function to handle CALL ANIMCHAR basic extension
 857+ 5297              ; ANIMCHAR ( BYTE id,
 858+ 5297              ;            INT character number 0-767,
 859+ 5297              ;            BYTE animation_definition_id,
 860+ 5297              ;            BYTE cyclic_flag )
 861+ 5297              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 862+ 5297              ANIMCHAR:
 863+ 5297                  ; opening (
 864+ 5297 CD 67 66     	CALL CHKCHAR
 865+ 529A 28           	DB '('
 866+ 529B              	; get sprite animation id
 867+ 529B DD 21 1C 52  	LD IX, GETBYT
 868+ 529F CD 59 01     	CALL CALBAS
 869+ 52A2 F5               PUSH AF
 870+ 52A3 3C               INC A
 871+ 52A4 4F               LD C,A
 872+ 52A5 3A 60 4F         LD A,(ANIMSPRNUM)
 873+ 52A8 B9               CP C
 874+ 52A9 DA 7F 66         JP C,SUBSCRIPT_OUT_OF_RANGE
 875+ 52AC              	; comma
 876+ 52AC CD 67 66     	CALL CHKCHAR
 877+ 52AF 2C           	DB ','
 878+ 52B0              	; get character number
 879+ 52B0 DD 21 2F 54  	LD IX, FRMQNT
 880+ 52B4 CD 59 01     	CALL CALBAS
 881+ 52B7 D5               PUSH DE
 882+ 52B8                  ; check if out of bounds
 883+ 52B8 7A               LD A,D
 884+ 52B9 FE 03            CP 3
 885+ 52BB D2 7F 66         JP NC, SUBSCRIPT_OUT_OF_RANGE
 886+ 52BE              	; comma
 887+ 52BE CD 67 66     	CALL CHKCHAR
 888+ 52C1 2C           	DB ','
 889+ 52C2              	; get animation definition id
 890+ 52C2 DD 21 1C 52  	LD IX, GETBYT
 891+ 52C6 CD 59 01     	CALL CALBAS
 892+ 52C9 F5               PUSH AF
 893+ 52CA 3C               INC A
 894+ 52CB 4F               LD C,A
 895+ 52CC 3A 5D 4F         LD A,(ANIMDEFNUM)
 896+ 52CF B9               CP C
 897+ 52D0 DA 7F 66         JP C,SUBSCRIPT_OUT_OF_RANGE
 898+ 52D3              	; comma
 899+ 52D3 CD 67 66     	CALL CHKCHAR
 900+ 52D6 2C           	DB ','
 901+ 52D7              	; get cyclic flag
 902+ 52D7 DD 21 1C 52  	LD IX, GETBYT
 903+ 52DB CD 59 01         CALL CALBAS
 904+ 52DE F5           	PUSH AF
 905+ 52DF              	; ending )
 906+ 52DF CD 67 66     	CALL CHKCHAR
 907+ 52E2 29           	DB ')'
 908+ 52E3              .ENTRY:
 909+ 52E3 E5               PUSH HL
 910+ 52E4 DD E1            POP IX
 911+ 52E6 D9               EXX
 912+ 52E7 D1               POP DE ; cyclic
 913+ 52E8 C1               POP BC ; animation definition id
 914+ 52E9 E1               POP HL ; character number
 915+ 52EA D9               EXX
 916+ 52EB F1               POP AF ; sprite animation id
 917+ 52EC CD 84 4F         CALL GETnthSPRANIM
 918+ 52EF E5               PUSH HL
 919+ 52F0 FD E1            POP IY
 920+ 52F2 D9               EXX
 921+ 52F3 FD 75 00         LD (IY),L
 922+ 52F6 24               INC H ; save character bank+1
 923+ 52F7 FD 74 07         LD (IY+7),H
 924+ 52FA FD 70 04         LD (IY+4),B
 925+ 52FD FD 72 05         LD (IY+5),D
 926+ 5300                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 927+ 5300                  ; following will do preparation for ANIMSTEP situation
 928+ 5300                  ; current item set to above limit and timer to 1
 929+ 5300                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 930+ 5300 FD 36 03 FF      LD (IY+3),255
 931+ 5304 FD 36 01 01      LD (IY+1),1
 932+ 5308 FD 36 02 00      LD (IY+2),0
 933+ 530C DD E5            PUSH IX
 934+ 530E E1               POP HL
 935+ 530F C9               RET
 936+ 5310              ; *******************************************************************************************************
 937+ 5310               ENDIF
 938+ 5310
 939+ 5310               IF (0 == 1)
 940+ 5310 ~            ; *******************************************************************************************************
 941+ 5310 ~            ; same as ANIMCHAR but for DEFUSR approach
 942+ 5310 ~            ; input IX=pointer to input array, real data from +2
 943+ 5310 ~            ; +02 = ID
 944+ 5310 ~            ; +04 = character number
 945+ 5310 ~            ; +06 = animation definition id
 946+ 5310 ~            ; +08 = cyclic flag
 947+ 5310 ~            ANIMCHAR_DEFUSR:
 948+ 5310 ~                LD C,(IX+2)
 949+ 5310 ~                INC C
 950+ 5310 ~                LD A,(ANIMSPRNUM)
 951+ 5310 ~                CP C
 952+ 5310 ~                RET C ; invalid id
 953+ 5310 ~            	; get sprite number
 954+ 5310 ~                LD A,(IX+5)
 955+ 5310 ~                CP 3
 956+ 5310 ~                RET NC ; invalid character (>767)
 957+ 5310 ~                LD B,(IX+6)
 958+ 5310 ~                INC B
 959+ 5310 ~                LD A,(ANIMDEFNUM)
 960+ 5310 ~                CP B
 961+ 5310 ~                RET C ; invalid animation definition id
 962+ 5310 ~                LD A,C
 963+ 5310 ~                DEC A
 964+ 5310 ~                CALL GETnthSPRANIM
 965+ 5310 ~                LD A,(IX+4)
 966+ 5310 ~                LD (HL),A ; +0
 967+ 5310 ~                INC HL
 968+ 5310 ~                LD (HL),1 ; +1
 969+ 5310 ~                INC HL
 970+ 5310 ~                LD (HL),0 ; +2
 971+ 5310 ~                INC HL
 972+ 5310 ~                LD (HL),255 ; +3
 973+ 5310 ~                INC HL
 974+ 5310 ~                DEC B
 975+ 5310 ~                LD (HL),B ; +4
 976+ 5310 ~                INC HL
 977+ 5310 ~                LD A,(IX+8) ; +5
 978+ 5310 ~                LD (HL),A
 979+ 5310 ~                INC HL
 980+ 5310 ~                INC HL
 981+ 5310 ~                LD A,(IX+5)
 982+ 5310 ~                INC A
 983+ 5310 ~                LD (HL),A ; +7
 984+ 5310 ~                RET
 985+ 5310 ~            ; *******************************************************************************************************
 986+ 5310               ENDIF
 987+ 5310
 988+ 5310               IF (0 == 1)
 989+ 5310 ~            ; *******************************************************************************************************
 990+ 5310 ~            ; same as MAXAUTOSGAMS but for DEFUSR approach
 991+ 5310 ~            ; input IX=pointer to input array, real data from +2
 992+ 5310 ~            ; +2 = number
 993+ 5310 ~            MAXAUTOSGAMS_DEFUSR:
 994+ 5310 ~                LD A,(IX+2)
 995+ 5310 ~                JR MAXAUTOSGAMS.COMMON
 996+ 5310 ~            ; *******************************************************************************************************
 997+ 5310               ENDIF
 998+ 5310
 999+ 5310              ; *******************************************************************************************************
1000+ 5310              ; function to handle CALL MAXAUTOSGAMS basic extension
1001+ 5310              ; MAXAUTOSGAMS (BYTE number)
1002+ 5310              ; sets new number and moves memory buffers as needed
1003+ 5310              MAXAUTOSGAMS:
1004+ 5310               IF (1 == 1)
1005+ 5310              	; opening (
1006+ 5310 CD 67 66     	CALL CHKCHAR
1007+ 5313 28           	DB '('
1008+ 5314              	; get value
1009+ 5314 DD 21 1C 52  	LD IX, GETBYT
1010+ 5318 CD 59 01     	CALL CALBAS
1011+ 531B F5               PUSH AF
1012+ 531C              	; ending )
1013+ 531C CD 67 66     	CALL CHKCHAR
1014+ 531F 29           	DB ')'
1015+ 5320 F1               POP AF
1016+ 5321               ENDIF
1017+ 5321              .COMMON:
1018+ 5321 F3               DI
1019+ 5322              	; save position
1020+ 5322 E5           	PUSH HL
1021+ 5323              .ENTRY:
1022+ 5323 47               LD B,A
1023+ 5324 3A 63 4F         LD A,(AUTOSGAMNUM)
1024+ 5327 90               SUB B
1025+ 5328 CA E2 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
1026+ 532B FD 21 10 40      LD IY,FREEMEMPTR
1027+ 532F FA 3B 53         JP M, .INCREASE
1028+ 5332                  ; new value is lower than previous one
1029+ 5332 CD 5C 53         CALL .SIZEDIFF
1030+ 5335 CD 1F 50         CALL MAXANIMITEMS.DECREASE_COMMON
1031+ 5338 C3 E2 4F         JP MAXANIMITEMS.EXIT
1032+ 533B              .INCREASE:
1033+ 533B ED 44            NEG
1034+ 533D F5               PUSH AF; save difference for later to set active flag to 0 of new entires
1035+ 533E CD 5C 53         CALL .SIZEDIFF
1036+ 5341 CD 4B 50         CALL MAXANIMITEMS.INCREASE_COMMON
1037+ 5344 AF               XOR A
1038+ 5345 ED 42            SBC HL,BC ; location of new stuff
1039+ 5347 F1               POP AF
1040+ 5348 C5               PUSH BC
1041+ 5349 47               LD B,A
1042+ 534A 11 18 00         LD DE,24
1043+ 534D E5               PUSH HL
1044+ 534E DD E1            POP IX
1045+ 5350              .L1:
1046+ 5350 DD 36 13 00      LD (IX+19),0 ; active flag
1047+ 5354 DD 19            ADD IX,DE
1048+ 5356 10 F8            DJNZ .L1
1049+ 5358 C1               POP BC
1050+ 5359 C3 E2 4F         JP MAXANIMITEMS.EXIT
1051+ 535C              .SIZEDIFF:
1052+ 535C 26 00            LD H,0
1053+ 535E 6F               LD L,A
1054+ 535F CD 54 65         CALL HLx8
1055+ 5362 54               LD D,H
1056+ 5363 5D               LD E,L
1057+ 5364 29               ADD HL,HL
1058+ 5365 19               ADD HL,DE
1059+ 5366 78               LD A,B
1060+ 5367 32 63 4F         LD (AUTOSGAMNUM),A
1061+ 536A 44               LD B,H
1062+ 536B 4D               LD C,L
1063+ 536C C9               RET ; BC=size difference in bytes
1064+ 536D              ; *******************************************************************************************************
1065+ 536D
1066+ 536D               IF (1 == 1)
1067+ 536D              ; *******************************************************************************************************
1068+ 536D              ; function to handle CALL AUTOSGAMDEF basic extension
1069+ 536D              ; AUTOSGAMDEF ( BYTE id,
1070+ 536D              ;               INT VARIABLE x, INT VARIABLE y,
1071+ 536D              ;               INT minimum, INT maximum, INT delta,
1072+ 536D              ;               INT direction =0 horizontal,
1073+ 536D              ;               INT ticks,
1074+ 536D              ;               BYTE sprite_group_count,
1075+ 536D              ;               INT[2][sprite_group_count] VARIABLE sprite_group,
1076+ 536D              ;               BYTE item_number,
1077+ 536D              ;               INT[] VARIABLE sprite_animations_negative_direction,
1078+ 536D              ;               INT[] VARIABLE sprite_animations_positive_direction
1079+ 536D              AUTOSGAMDEF:
1080+ 536D                  ; opening (
1081+ 536D CD 67 66     	CALL CHKCHAR
1082+ 5370 28           	DB '('
1083+ 5371              	; get sprite animation id
1084+ 5371 DD 21 1C 52  	LD IX, GETBYT
1085+ 5375 CD 59 01     	CALL CALBAS
1086+ 5378 F5               PUSH AF
1087+ 5379 3C               INC A
1088+ 537A 4F               LD C,A
1089+ 537B 3A 63 4F         LD A,(AUTOSGAMNUM)
1090+ 537E B9               CP C
1091+ 537F DA 7F 66         JP C,SUBSCRIPT_OUT_OF_RANGE
1092+ 5382 F1               POP AF
1093+ 5383 E5               PUSH HL
1094+ 5384 CD 90 4F         CALL GETnthAUTOSGAM
1095+ 5387 22 3E 63         LD (BLIT_TMP),HL ; for later
1096+ 538A E1               POP HL
1097+ 538B              	; comma
1098+ 538B CD 67 66     	CALL CHKCHAR
1099+ 538E 2C           	DB ','
1100+ 538F              	; get address of the X coordinate variable
1101+ 538F DD 21 A4 5E  	LD IX, PTRGET
1102+ 5393 CD 59 01     	CALL CALBAS
1103+ 5396 DD 2A 3E 63  	LD IX,(BLIT_TMP)
1104+ 539A DD 73 00         LD (IX+0),E
1105+ 539D DD 72 01         LD (IX+1),D
1106+ 53A0              	; comma
1107+ 53A0 CD 67 66     	CALL CHKCHAR
1108+ 53A3 2C           	DB ','
1109+ 53A4              	; get address of the Y coordinate variable
1110+ 53A4 DD 21 A4 5E  	LD IX, PTRGET
1111+ 53A8 CD 59 01     	CALL CALBAS
1112+ 53AB DD 2A 3E 63  	LD IX,(BLIT_TMP)
1113+ 53AF DD 73 02         LD (IX+2),E
1114+ 53B2 DD 72 03         LD (IX+3),D
1115+ 53B5              	; comma
1116+ 53B5 CD 67 66     	CALL CHKCHAR
1117+ 53B8 2C           	DB ','
1118+ 53B9              	; get minimum value
1119+ 53B9 DD 21 2F 54  	LD IX, FRMQNT
1120+ 53BD CD 59 01     	CALL CALBAS
1121+ 53C0 DD 2A 3E 63  	LD IX,(BLIT_TMP)
1122+ 53C4 DD 73 04         LD (IX+4),E
1123+ 53C7 DD 72 05         LD (IX+5),D
1124+ 53CA              	; comma
1125+ 53CA CD 67 66     	CALL CHKCHAR
1126+ 53CD 2C           	DB ','
1127+ 53CE              	; get maximum value
1128+ 53CE DD 21 2F 54  	LD IX, FRMQNT
1129+ 53D2 CD 59 01     	CALL CALBAS
1130+ 53D5 DD 2A 3E 63  	LD IX,(BLIT_TMP)
1131+ 53D9 DD 73 06         LD (IX+6),E
1132+ 53DC DD 72 07         LD (IX+7),D
1133+ 53DF              	; comma
1134+ 53DF CD 67 66     	CALL CHKCHAR
1135+ 53E2 2C           	DB ','
1136+ 53E3              	; get delta value
1137+ 53E3 DD 21 2F 54  	LD IX, FRMQNT
1138+ 53E7 CD 59 01     	CALL CALBAS
1139+ 53EA DD 2A 3E 63  	LD IX,(BLIT_TMP)
1140+ 53EE DD 73 08         LD (IX+8),E
1141+ 53F1 DD 72 09         LD (IX+9),D
1142+ 53F4              	; comma
1143+ 53F4 CD 67 66     	CALL CHKCHAR
1144+ 53F7 2C           	DB ','
1145+ 53F8              	; get direction value
1146+ 53F8 DD 21 2F 54  	LD IX, FRMQNT
1147+ 53FC CD 59 01     	CALL CALBAS
1148+ 53FF DD 2A 3E 63  	LD IX,(BLIT_TMP)
1149+ 5403 DD 73 0A         LD (IX+10),E
1150+ 5406              	; comma
1151+ 5406 CD 67 66     	CALL CHKCHAR
1152+ 5409 2C           	DB ','
1153+ 540A              	; get ticks value
1154+ 540A DD 21 2F 54  	LD IX, FRMQNT
1155+ 540E CD 59 01     	CALL CALBAS
1156+ 5411 DD 2A 3E 63  	LD IX,(BLIT_TMP)
1157+ 5415 DD 73 14         LD (IX+20),E
1158+ 5418 DD 72 15         LD (IX+21),D
1159+ 541B              	; comma
1160+ 541B CD 67 66     	CALL CHKCHAR
1161+ 541E 2C           	DB ','
1162+ 541F              	; get sprite group count
1163+ 541F DD 21 1C 52  	LD IX, GETBYT
1164+ 5423 CD 59 01     	CALL CALBAS
1165+ 5426 B7               OR A
1166+ 5427 CA 7F 66         JP Z,SUBSCRIPT_OUT_OF_RANGE
1167+ 542A DD 2A 3E 63  	LD IX,(BLIT_TMP)
1168+ 542E DD 77 0B         LD (IX+11),A
1169+ 5431              	; comma
1170+ 5431 CD 67 66     	CALL CHKCHAR
1171+ 5434 2C           	DB ','
1172+ 5435              	; get sprite group definition array data pointer
1173+ 5435 DD 2A 3E 63  	LD IX,(BLIT_TMP)
1174+ 5439 DD 5E 0B         LD E,(IX+11)
1175+ 543C 16 03        	LD D,3
1176+ 543E 3E 02        	LD A,2
1177+ 5440 47           	LD B,A
1178+ 5441 CD C0 66     	CALL GET_BASIC_ARRAY_DATA_POINTER
1179+ 5444 DD 2A 3E 63  	LD IX,(BLIT_TMP)
1180+ 5448 DD 71 0C     	LD (IX+12),C
1181+ 544B DD 70 0D         LD (IX+13),B
1182+ 544E              	; comma
1183+ 544E CD 67 66     	CALL CHKCHAR
1184+ 5451 2C           	DB ','
1185+ 5452              	; get sprite animation array size
1186+ 5452 DD 21 1C 52  	LD IX,GETBYT
1187+ 5456 CD 59 01     	CALL CALBAS
1188+ 5459 DD 2A 3E 63  	LD IX,(BLIT_TMP)
1189+ 545D DD 77 0E         LD (IX+14),A
1190+ 5460 B7               OR A
1191+ 5461 CA 7F 66         JP Z,SUBSCRIPT_OUT_OF_RANGE
1192+ 5464              	; comma
1193+ 5464 CD 67 66     	CALL CHKCHAR
1194+ 5467 2C           	DB ','
1195+ 5468                  ; get array pointer for negative direction
1196+ 5468 DD 2A 3E 63  	LD IX,(BLIT_TMP)
1197+ 546C DD 56 0E         LD D,(IX+14)
1198+ 546F 3E 02            LD A,2
1199+ 5471 06 01            LD B,1
1200+ 5473 CD C0 66         CALL GET_BASIC_ARRAY_DATA_POINTER
1201+ 5476 DD 2A 3E 63  	LD IX,(BLIT_TMP)
1202+ 547A DD 71 0F         LD (IX+15),C
1203+ 547D DD 70 10         LD (IX+16),B
1204+ 5480              	; comma
1205+ 5480 CD 67 66     	CALL CHKCHAR
1206+ 5483 2C           	DB ','
1207+ 5484                  ; get array pointer for positive direction
1208+ 5484 DD 2A 3E 63  	LD IX,(BLIT_TMP)
1209+ 5488 DD 56 0E         LD D,(IX+14)
1210+ 548B 3E 02            LD A,2
1211+ 548D 06 01            LD B,1
1212+ 548F CD C0 66         CALL GET_BASIC_ARRAY_DATA_POINTER
1213+ 5492 DD 2A 3E 63  	LD IX,(BLIT_TMP)
1214+ 5496 DD 71 11         LD (IX+17),C
1215+ 5499 DD 70 12         LD (IX+18),B
1216+ 549C              	; ending )
1217+ 549C CD 67 66     	CALL CHKCHAR
1218+ 549F 29           	DB ')'
1219+ 54A0 C9               RET
1220+ 54A1              ; *******************************************************************************************************
1221+ 54A1               ENDIF
1222+ 54A1
1223+ 54A1               IF (0 == 1)
1224+ 54A1 ~            ; *******************************************************************************************************
1225+ 54A1 ~            ; same as AUTOSGAMDEF but for DEFUSR approach
1226+ 54A1 ~            ; input IX=pointer to input array, real data from +2
1227+ 54A1 ~            ; +02 = ID
1228+ 54A1 ~            ; +04 = pointer to X variable
1229+ 54A1 ~            ; +06 = pointer to Y variable
1230+ 54A1 ~            ; +08 = minimum
1231+ 54A1 ~            ; +10 = maximum
1232+ 54A1 ~            ; +12 = delta
1233+ 54A1 ~            ; +14 = direction
1234+ 54A1 ~            ; +16 = ticks
1235+ 54A1 ~            ; +18 = sprite group count
1236+ 54A1 ~            ; +20 = sprite group array pointer
1237+ 54A1 ~            ; +22 = item number
1238+ 54A1 ~            ; +24 = sprite animations negative direction array pointer
1239+ 54A1 ~            ; +26 = sprite animations positive direction array pointer
1240+ 54A1 ~            AUTOSGAMDEF_DEFUSR:
1241+ 54A1 ~                LD C,(IX+2)
1242+ 54A1 ~                INC C
1243+ 54A1 ~                LD A,(AUTOSGAMNUM)
1244+ 54A1 ~                CP C
1245+ 54A1 ~                RET C ; invalid id
1246+ 54A1 ~                LD A,C
1247+ 54A1 ~                DEC A
1248+ 54A1 ~                CALL GETnthAUTOSGAM
1249+ 54A1 ~                PUSH HL
1250+ 54A1 ~                POP IY
1251+ 54A1 ~                ; X variable
1252+ 54A1 ~                LD A,(IX+4)
1253+ 54A1 ~                LD (IY+0),A
1254+ 54A1 ~                LD A,(IX+5)
1255+ 54A1 ~                LD (IY+1),A
1256+ 54A1 ~            	; Y variable
1257+ 54A1 ~                LD A,(IX+6)
1258+ 54A1 ~                LD (IY+2),A
1259+ 54A1 ~                LD A,(IX+7)
1260+ 54A1 ~                LD (IY+3),A
1261+ 54A1 ~            	; get minimum value
1262+ 54A1 ~                LD A,(IX+8)
1263+ 54A1 ~                LD (IY+4),A
1264+ 54A1 ~                LD A,(IX+9)
1265+ 54A1 ~                LD (IY+5),A
1266+ 54A1 ~            	; get maximum value
1267+ 54A1 ~                LD A,(IX+10)
1268+ 54A1 ~                LD (IY+6),A
1269+ 54A1 ~                LD A,(IX+11)
1270+ 54A1 ~                LD (IY+7),A
1271+ 54A1 ~            	; get delta value
1272+ 54A1 ~                LD A,(IX+12)
1273+ 54A1 ~                LD (IY+8),A
1274+ 54A1 ~                LD A,(IX+13)
1275+ 54A1 ~                LD (IY+9),A
1276+ 54A1 ~            	; get direction value
1277+ 54A1 ~                LD A,(IX+14)
1278+ 54A1 ~                LD (IY+10),A
1279+ 54A1 ~            	; get ticks value
1280+ 54A1 ~                LD A,(IX+16)
1281+ 54A1 ~                LD (IY+20),A
1282+ 54A1 ~                LD A,(IX+17)
1283+ 54A1 ~                LD (IY+21),A
1284+ 54A1 ~            	; get sprite group count
1285+ 54A1 ~                LD A,(IX+18)
1286+ 54A1 ~                LD (IY+11),A
1287+ 54A1 ~            	; get sprite group definition array data pointer
1288+ 54A1 ~                LD A,(IX+20)
1289+ 54A1 ~                LD (IY+12),A
1290+ 54A1 ~                LD A,(IX+21)
1291+ 54A1 ~                LD (IY+13),A
1292+ 54A1 ~            	; get sprite animation array size
1293+ 54A1 ~                LD A,(IX+22)
1294+ 54A1 ~                LD (IY+14),A
1295+ 54A1 ~                ; get array pointer for negative direction
1296+ 54A1 ~                LD A,(IX+24)
1297+ 54A1 ~                LD (IY+15),A
1298+ 54A1 ~                LD A,(IX+25)
1299+ 54A1 ~                LD (IY+16),A
1300+ 54A1 ~                ; get array pointer for positive direction
1301+ 54A1 ~                LD A,(IX+26)
1302+ 54A1 ~                LD (IY+17),A
1303+ 54A1 ~                LD A,(IX+27)
1304+ 54A1 ~                LD (IY+18),A
1305+ 54A1 ~                RET
1306+ 54A1 ~            ; *******************************************************************************************************
1307+ 54A1               ENDIF
1308+ 54A1
1309+ 54A1               IF (1 == 1)
1310+ 54A1              ; *******************************************************************************************************
1311+ 54A1              ; function to handle CALL AUTOSGAMSTART basic extension
1312+ 54A1              ; AUTOSGAMSTART ( BYTE id )
1313+ 54A1              AUTOSGAMSTART:
1314+ 54A1 3E 01            LD A,1
1315+ 54A3              .COMMON:
1316+ 54A3 32 CF 54         LD (.SETVALUE+3),A
1317+ 54A6                  ; opening (
1318+ 54A6 CD 67 66     	CALL CHKCHAR
1319+ 54A9 28           	DB '('
1320+ 54AA              	; get sprite animation id
1321+ 54AA DD 21 1C 52  	LD IX, GETBYT
1322+ 54AE CD 59 01     	CALL CALBAS
1323+ 54B1 F5               PUSH AF
1324+ 54B2 3C               INC A
1325+ 54B3 4F               LD C,A
1326+ 54B4 3A 63 4F         LD A,(AUTOSGAMNUM)
1327+ 54B7 B9               CP C
1328+ 54B8 DA 7F 66         JP C,SUBSCRIPT_OUT_OF_RANGE
1329+ 54BB F1               POP AF
1330+ 54BC E5               PUSH HL
1331+ 54BD CD 90 4F         CALL GETnthAUTOSGAM
1332+ 54C0 E5               PUSH HL
1333+ 54C1 DD E1            POP IX
1334+ 54C3 E1               POP HL
1335+ 54C4 DD E5            PUSH IX
1336+ 54C6              	; ending )
1337+ 54C6 CD 67 66     	CALL CHKCHAR
1338+ 54C9 29           	DB ')'
1339+ 54CA
1340+ 54CA                  ; so syntax is fine
1341+ 54CA DD E1            POP IX
1342+ 54CC              .SETVALUE:
1343+ 54CC DD 36 13 01      LD (IX+19),1 ; active flag
1344+ 54D0                  ; set initial timer
1345+ 54D0 DD 7E 14         LD A,(IX+20)
1346+ 54D3 DD 77 16         LD (IX+22),A
1347+ 54D6 DD 7E 15         LD A,(IX+21)
1348+ 54D9 DD 77 17         LD (IX+23),A
1349+ 54DC C9               RET
1350+ 54DD              ; *******************************************************************************************************
1351+ 54DD
1352+ 54DD              ; *******************************************************************************************************
1353+ 54DD              ; function to handle CALL AUTOSGAMSTOP basic extension
1354+ 54DD              ; AUTOSGAMSTOP ( BYTE id )
1355+ 54DD              AUTOSGAMSTOP:
1356+ 54DD AF               XOR A
1357+ 54DE 18 C3            JR AUTOSGAMSTART.COMMON
1358+ 54E0              ; *******************************************************************************************************
1359+ 54E0               ENDIF
1360+ 54E0
1361+ 54E0               IF (0 == 1)
1362+ 54E0 ~            ; *******************************************************************************************************
1363+ 54E0 ~            ; function to handle CALL AUTOSGAMSTART basic extension in DEFUSR mode
1364+ 54E0 ~            ; input IX=pointer to input array, real data from +2
1365+ 54E0 ~            ; +2 = source address
1366+ 54E0 ~            AUTOSGAMSTART_DEFUSR:
1367+ 54E0 ~                LD A,1
1368+ 54E0 ~            .COMMON:
1369+ 54E0 ~                LD (.SETVALUE+3),A
1370+ 54E0 ~                LD C,(IX+2)
1371+ 54E0 ~                INC C
1372+ 54E0 ~                LD A,(AUTOSGAMNUM)
1373+ 54E0 ~                CP C
1374+ 54E0 ~                RET C ; invalid id
1375+ 54E0 ~                LD A,C
1376+ 54E0 ~                DEC A
1377+ 54E0 ~                CALL GETnthAUTOSGAM
1378+ 54E0 ~                PUSH HL
1379+ 54E0 ~                POP IX
1380+ 54E0 ~            .SETVALUE:
1381+ 54E0 ~                LD (IX+19),1 ; active flag
1382+ 54E0 ~                ; set initial timer
1383+ 54E0 ~                LD A,(IX+20)
1384+ 54E0 ~                LD (IX+22),A
1385+ 54E0 ~                LD A,(IX+21)
1386+ 54E0 ~                LD (IX+23),A
1387+ 54E0 ~                RET
1388+ 54E0 ~            ; *******************************************************************************************************
1389+ 54E0 ~
1390+ 54E0 ~            ; *******************************************************************************************************
1391+ 54E0 ~            ; function to handle CALL AUTOSGAMSTOP basic extension in DEFUSR mode
1392+ 54E0 ~            ; input IX=pointer to input array, real data from +2
1393+ 54E0 ~            ; +2 = source address
1394+ 54E0 ~            AUTOSGAMSTOP_DEFUSR:
1395+ 54E0 ~                XOR A
1396+ 54E0 ~                JR AUTOSGAMSTART_DEFUSR.COMMON
1397+ 54E0 ~            ; *******************************************************************************************************
1398+ 54E0               ENDIF
1399+ 54E0
1400+ 54E0               IF (1 == 1)
1401+ 54E0              ; *******************************************************************************************************
1402+ 54E0              ; function to handle CALL ANIMSTEP basic extension
1403+ 54E0              ; two forms
1404+ 54E0              ; ANIMSTEP ( BYTE id )
1405+ 54E0              ; or
1406+ 54E0              ; ANIMSTEP ( BYTE item_number,
1407+ 54E0              ;            INT[] sprite_animations )
1408+ 54E0              ANIMSTEP:
1409+ 54E0 11 5F 55         LD DE,ANIMSTARTSTOP_COMMON.STEP
1410+ 54E3 18 08            JR ANIMSTARTSTOP_COMMON
1411+ 54E5              ; *******************************************************************************************************
1412+ 54E5              ; *******************************************************************************************************
1413+ 54E5              ; function to handle CALL ANIMSTART basic extension
1414+ 54E5              ; two forms
1415+ 54E5              ; ANIMSTART ( BYTE id )
1416+ 54E5              ; or
1417+ 54E5              ; ANIMSTART ( BYTE item_number,
1418+ 54E5              ;             INT[] sprite_animations )
1419+ 54E5              ; sets active flag to 1
1420+ 54E5              ANIMSTART:
1421+ 54E5 11 4D 55         LD DE,ANIMSTARTSTOP_COMMON.START
1422+ 54E8 18 03            JR ANIMSTARTSTOP_COMMON
1423+ 54EA              ; *******************************************************************************************************
1424+ 54EA              ; *******************************************************************************************************
1425+ 54EA              ; function to handle CALL ANIMSTOP basic extension
1426+ 54EA              ; two forms
1427+ 54EA              ; ANIMSTOP ( BYTE id )
1428+ 54EA              ; or
1429+ 54EA              ; ANIMSTOP ( BYTE item_number,
1430+ 54EA              ;            INT[] sprite_animations )
1431+ 54EA              ; sets active flag to 0
1432+ 54EA              ANIMSTOP:
1433+ 54EA 11 5A 55         LD DE,ANIMSTARTSTOP_COMMON.STOP
1434+ 54ED              ; *******************************************************************************************************
1435+ 54ED              ANIMSTARTSTOP_COMMON:
1436+ 54ED ED 53 4B 55      LD (ANIMSTARTSTOP_COMMON.FN+1),DE
1437+ 54F1                  ; opening (
1438+ 54F1 CD 67 66     	CALL CHKCHAR
1439+ 54F4 28           	DB '('
1440+ 54F5              	; get sprite animation id or array size
1441+ 54F5 DD 21 1C 52  	LD IX,GETBYT
1442+ 54F9 CD 59 01     	CALL CALBAS
1443+ 54FC F5               PUSH AF
1444+ 54FD                  ; check if comma present
1445+ 54FD CD 71 66         CALL GETPREVCHAR
1446+ 5500 23               INC HL
1447+ 5501 FE 2C            CP ','
1448+ 5503 28 0E            JR Z,.L1
1449+ 5505 FE 29            CP ')'
1450+ 5507 C2 8B 66         JP NZ,SYNTAX_ERROR
1451+ 550A                  ; ok so single argument variant
1452+ 550A F1               POP AF
1453+ 550B E5               PUSH HL
1454+ 550C F3               DI
1455+ 550D CD 39 55         CALL .SETVALUE
1456+ 5510 FB               EI
1457+ 5511 E1               POP HL
1458+ 5512 C9               RET
1459+ 5513              .L1:
1460+ 5513                  ; get array pointer
1461+ 5513 D1               POP DE
1462+ 5514 D5               PUSH DE
1463+ 5515 3E 02            LD A,2
1464+ 5517 06 01            LD B,1
1465+ 5519 CD C0 66         CALL GET_BASIC_ARRAY_DATA_POINTER
1466+ 551C C5               PUSH BC
1467+ 551D              	; ending )
1468+ 551D CD 67 66     	CALL CHKCHAR
1469+ 5520 29           	DB ')'
1470+ 5521 D1               POP DE ; array pointer
1471+ 5522 C1               POP BC ; number of items
1472+ 5523 78               LD A,B
1473+ 5524 B7               OR A
1474+ 5525 CA 7F 66         JP Z,SUBSCRIPT_OUT_OF_RANGE
1475+ 5528 E5               PUSH HL
1476+ 5529 F3               DI
1477+ 552A              .L2:
1478+ 552A C5               PUSH BC
1479+ 552B 1A               LD A,(DE)
1480+ 552C 13          > INC DE
1480+ 552D 13          > INC DE
1481+ 552E D5               PUSH DE
1482+ 552F CD 39 55         CALL .SETVALUE
1483+ 5532 D1               POP DE
1484+ 5533 C1               POP BC
1485+ 5534 10 F4            DJNZ .L2
1486+ 5536 FB               EI
1487+ 5537 E1               POP HL
1488+ 5538 C9               RET
1489+ 5539
1490+ 5539              .SETVALUE:
1491+ 5539 47               LD B,A
1492+ 553A 3C               INC A
1493+ 553B 4F               LD C,A
1494+ 553C 3A 60 4F         LD A,(ANIMSPRNUM)
1495+ 553F B9               CP C
1496+ 5540 DA 7F 66         JP C,SUBSCRIPT_OUT_OF_RANGE
1497+ 5543 78               LD A,B
1498+ 5544 CD 84 4F         CALL GETnthSPRANIM
1499+ 5547 E5               PUSH HL
1500+ 5548 DD E1            POP IX
1501+ 554A              .FN:
1502+ 554A C3 00 00         JP 0
1503+ 554D              .START:
1504+ 554D DD 36 06 01      LD (IX+6),1 ; active flag
1505+ 5551 DD 36 03 00      LD (IX+3),0 ; current item
1506+ 5555 06 00            LD B,0 ; setup timer
1507+ 5557 C3 F0 55         JP SETUP_ANIM_STEP
1508+ 555A              .STOP:
1509+ 555A DD 36 06 00      LD (IX+6),0 ; active flag
1510+ 555E C9               RET
1511+ 555F              .STEP:
1512+ 555F 06 00            LD B,0
1513+ 5561 C3 94 55         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1514+ 5564              ; *******************************************************************************************************
1515+ 5564               ENDIF
1516+ 5564
1517+ 5564              ; *******************************************************************************************************
1518+ 5564              ; helper function to locate single animation and execute operation
1519+ 5564              ; needs to have jump set to a correct function
1520+ 5564              ; used by SGAM helper routines so always needed
1521+ 5564              ; input A=animation item
1522+ 5564              ANIM_SETVALUE:
1523+ 5564 47               LD B,A
1524+ 5565 3C               INC A
1525+ 5566 4F               LD C,A
1526+ 5567 3A 60 4F         LD A,(ANIMSPRNUM)
1527+ 556A B9               CP C
1528+ 556B D8               RET C ; out of range, so do nothing
1529+ 556C 78               LD A,B
1530+ 556D CD 84 4F         CALL GETnthSPRANIM
1531+ 5570 E5               PUSH HL
1532+ 5571 DD E1            POP IX
1533+ 5573              .FN:
1534+ 5573 C3 00 00         JP 0
1535+ 5576              ; *******************************************************************************************************
1536+ 5576
1537+ 5576               IF (0 == 1)
1538+ 5576 ~            ; *******************************************************************************************************
1539+ 5576 ~            ; helper function to set values of multiple animations
1540+ 5576 ~            ; needs to have jump set to a correct function
1541+ 5576 ~            ; input B=number of animation item
1542+ 5576 ~            ; input DE=animation item array
1543+ 5576 ~            ANIM_LIST_SETVALUE:
1544+ 5576 ~                DI
1545+ 5576 ~                PUSH BC
1546+ 5576 ~                LD A,(DE)
1547+ 5576 ~                .2 INC DE
1548+ 5576 ~                PUSH DE
1549+ 5576 ~                CALL ANIM_SETVALUE
1550+ 5576 ~                POP DE
1551+ 5576 ~                POP BC
1552+ 5576 ~                DJNZ ANIM_LIST_SETVALUE
1553+ 5576 ~                EI
1554+ 5576 ~                RET
1555+ 5576 ~            ; *******************************************************************************************************
1556+ 5576 ~
1557+ 5576 ~            ; *******************************************************************************************************
1558+ 5576 ~            ; function to handle single item ANIMSTEP in DEFUSR mode
1559+ 5576 ~            ; input IX=pointer to input array, real data from +2
1560+ 5576 ~            ; +2 = animation id
1561+ 5576 ~            ANIMSTEP_SINGLE_DEFUSR:
1562+ 5576 ~                LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1563+ 5576 ~            .L1:
1564+ 5576 ~                LD (ANIM_SETVALUE.FN+1),HL
1565+ 5576 ~                LD A,(IX+2)
1566+ 5576 ~                JR ANIM_SETVALUE
1567+ 5576 ~            .STEP:
1568+ 5576 ~                LD B,0
1569+ 5576 ~                JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1570+ 5576 ~            ; *******************************************************************************************************
1571+ 5576 ~
1572+ 5576 ~            ; *******************************************************************************************************
1573+ 5576 ~            ; function to handle multi item ANIMSTEP in DEFUSR mode
1574+ 5576 ~            ; input IX=pointer to input array, real data from +2
1575+ 5576 ~            ; +2 = list size
1576+ 5576 ~            ; +4 = array pointer holding items
1577+ 5576 ~            ANIMSTEP_MULTI_DEFUSR:
1578+ 5576 ~                LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1579+ 5576 ~            .L1:
1580+ 5576 ~                LD (ANIM_SETVALUE.FN+1),HL
1581+ 5576 ~                LD B,(IX+2)
1582+ 5576 ~                LD E,(IX+4)
1583+ 5576 ~                LD D,(IX+5)
1584+ 5576 ~                JR ANIM_LIST_SETVALUE
1585+ 5576 ~            ; *******************************************************************************************************
1586+ 5576 ~
1587+ 5576 ~            ; *******************************************************************************************************
1588+ 5576 ~            ; function to handle single item ANIMSTART in DEFUSR mode
1589+ 5576 ~            ; input IX=pointer to input array, real data from +2
1590+ 5576 ~            ; +2 = animation id
1591+ 5576 ~            ANIMSTART_SINGLE_DEFUSR:
1592+ 5576 ~                LD HL,ANIMSTART_SINGLE_DEFUSR.START
1593+ 5576 ~                JR ANIMSTEP_SINGLE_DEFUSR.L1
1594+ 5576 ~            .START:
1595+ 5576 ~                LD (IX+6),1 ; active flag
1596+ 5576 ~                LD (IX+3),0 ; current item
1597+ 5576 ~                LD B,0 ; setup timer
1598+ 5576 ~                JP SETUP_ANIM_STEP
1599+ 5576 ~            ; *******************************************************************************************************
1600+ 5576 ~
1601+ 5576 ~            ; *******************************************************************************************************
1602+ 5576 ~            ; function to handle multi item ANIMSTART in DEFUSR mode
1603+ 5576 ~            ; input IX=pointer to input array, real data from +2
1604+ 5576 ~            ; +2 = list size
1605+ 5576 ~            ; +4 = array pointer holding items
1606+ 5576 ~            ANIMSTART_MULTI_DEFUSR:
1607+ 5576 ~                LD HL,ANIMSTART_SINGLE_DEFUSR.START
1608+ 5576 ~                JR ANIMSTEP_MULTI_DEFUSR.L1
1609+ 5576 ~            ; *******************************************************************************************************
1610+ 5576 ~
1611+ 5576 ~            ; *******************************************************************************************************
1612+ 5576 ~            ; function to handle single item ANIMSTOP in DEFUSR mode
1613+ 5576 ~            ; input IX=pointer to input array, real data from +2
1614+ 5576 ~            ; +2 = animation id
1615+ 5576 ~            ANIMSTOP_SINGLE_DEFUSR:
1616+ 5576 ~                LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1617+ 5576 ~                JR ANIMSTEP_SINGLE_DEFUSR.L1
1618+ 5576 ~            .STOP:
1619+ 5576 ~                LD (IX+6),0 ; active flag
1620+ 5576 ~                RET
1621+ 5576 ~            ; *******************************************************************************************************
1622+ 5576 ~
1623+ 5576 ~            ; *******************************************************************************************************
1624+ 5576 ~            ; function to handle multi item ANIMSTOP in DEFUSR mode
1625+ 5576 ~            ; input IX=pointer to input array, real data from +2
1626+ 5576 ~            ; +2 = list size
1627+ 5576 ~            ; +4 = array pointer holding items
1628+ 5576 ~            ANIMSTOP_MULTI_DEFUSR:
1629+ 5576 ~                LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1630+ 5576 ~                JR ANIMSTEP_MULTI_DEFUSR.L1
1631+ 5576 ~            ; *******************************************************************************************************
1632+ 5576               ENDIF
1633+ 5576
1634+ 5576              ; *******************************************************************************************************
1635+ 5576              ; function processes animations during vblank period
1636+ 5576              PROCESS_ANIMATIONS:
1637+ 5576 3A 60 4F         LD A,(ANIMSPRNUM)
1638+ 5579 B7               OR A
1639+ 557A C8               RET Z; no animations defined
1640+ 557B 47               LD B,A
1641+ 557C DD 2A 61 4F      LD IX,(ANIMSPRPTR)
1642+ 5580              .L1:
1643+ 5580 C5               PUSH BC
1644+ 5581 06 00            LD B,0 ; normal mode, change on timer expiry only
1645+ 5583 CD 8F 55         CALL PROCESS_SINGLE_ANIMATION
1646+ 5586 11 08 00         LD DE,8
1647+ 5589 DD 19            ADD IX,DE
1648+ 558B C1               POP BC
1649+ 558C 10 F2            DJNZ .L1
1650+ 558E C9               RET
1651+ 558F              ; *******************************************************************************************************
1652+ 558F
1653+ 558F              ; *******************************************************************************************************
1654+ 558F              ; processes single sprite animation
1655+ 558F              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
1656+ 558F              ; on timer expiry goes to next animation item
1657+ 558F              ; input IX=sprite animation pointer
1658+ 558F              ; input B=1 force mode, activate animation action regardless of expired timer
1659+ 558F              PROCESS_SINGLE_ANIMATION:
1660+ 558F DD 7E 06         LD A,(IX+6); active
1661+ 5592 B7               OR A
1662+ 5593 C8               RET Z ; inactive animation
1663+ 5594              .INACTIVE_TOO:
1664+ 5594 DD 6E 01         LD L,(IX+1)
1665+ 5597 DD 66 02         LD H,(IX+2) ; HL=end time
1666+ 559A 2B               DEC HL
1667+ 559B DD 75 01         LD (IX+1),L
1668+ 559E DD 74 02         LD (IX+2),H
1669+ 55A1 7D               LD A,L
1670+ 55A2 B4               OR H
1671+ 55A3 28 06            JR Z,.STEP
1672+ 55A5 05               DEC B
1673+ 55A6 04               INC B
1674+ 55A7 C8               RET Z ; not forced mode, return
1675+ 55A8 C3 F0 55         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
1676+ 55AB              .STEP:
1677+ 55AB 06 00            LD B,0; setup timer
1678+ 55AD DD 34 03         INC (IX+3) ; current animation item
1679+ 55B0 C3 F0 55         JP SETUP_ANIM_STEP
1680+ 55B3              ; *******************************************************************************************************
1681+ 55B3
1682+ 55B3              ; *******************************************************************************************************
1683+ 55B3              ; function will setup sprite animation after current item change
1684+ 55B3              ; input A=current animation definition
1685+ 55B3              ; input IX=pointer to sprite animation
1686+ 55B3              ; input B=1 skip timer setup
1687+ 55B3              ; output IY=pointer to animation item
1688+ 55B3              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
1689+ 55B3              ; basically sets new end time for current animation
1690+ 55B3              INIT_CURRENT_ANIMATION:
1691+ 55B3 CD 78 4F         CALL GETnthANIMDEF
1692+ 55B6 DD 7E 03         LD A,(IX+3) ; current animation item
1693+ 55B9 BE               CP (HL) ; number of animation items in the animation definition
1694+ 55BA 38 0A            JR C,.L3 ; last item not reached
1695+ 55BC                  ; last item reached
1696+ 55BC DD 7E 05         LD A,(IX+5) ; cyclic flag
1697+ 55BF B7               OR A
1698+ 55C0 28 2C            JR Z,.ERROR ; non-cyclic animation
1699+ 55C2                  ; cyclic animation, restart
1700+ 55C2 DD 36 03 00      LD (IX+3),0; current item
1701+ 55C6              .L3:
1702+ 55C6                  ; HL = animation definition
1703+ 55C6 23               INC HL ; skip animation definition size field
1704+ 55C7 16 00            LD D,0
1705+ 55C9 DD 5E 03         LD E,(IX+3); current item
1706+ 55CC 19               ADD HL,DE
1707+ 55CD 4E               LD C,(HL) ; current animation item
1708+ 55CE 0C               INC C
1709+ 55CF 3A 5A 4F         LD A,(ANIMITEMNUM)
1710+ 55D2 B9               CP C
1711+ 55D3 38 19            JR C,.ERROR ; invalid animation item, stop animation
1712+ 55D5 0D               DEC C
1713+ 55D6 79               LD A,C
1714+ 55D7 CD 6F 4F         CALL GETnthANIMITEM
1715+ 55DA E5               PUSH HL
1716+ 55DB FD E1            POP IY ; IY=animation item
1717+ 55DD 05               DEC B
1718+ 55DE 28 0C            JR Z,.EXIT
1719+ 55E0 FD 5E 01         LD E,(IY+1)
1720+ 55E3 FD 56 02         LD D,(IY+2) ; duration
1721+ 55E6 DD 73 01         LD (IX+1),E
1722+ 55E9 DD 72 02         LD (IX+2),D
1723+ 55EC              .EXIT:
1724+ 55EC AF               XOR A
1725+ 55ED C9               RET
1726+ 55EE              .ERROR:
1727+ 55EE 37               SCF
1728+ 55EF C9               RET
1729+ 55F0              ; *******************************************************************************************************
1730+ 55F0
1731+ 55F0              ; *******************************************************************************************************
1732+ 55F0              ; function will display currect item and set up expiry time
1733+ 55F0              ; it will also stop the animation if expired
1734+ 55F0              ; sets sprite update flag if any changes in sprite data made
1735+ 55F0              ; input IX=current sprite animation
1736+ 55F0              ; input B=1 skip timer setup
1737+ 55F0              SETUP_ANIM_STEP:
1738+ 55F0 DD 4E 04         LD C,(IX+4) ; animation definition ID
1739+ 55F3 0C               INC C
1740+ 55F4 3A 5D 4F         LD A,(ANIMDEFNUM)
1741+ 55F7 B9               CP C
1742+ 55F8 30 05            JR NC,.L2
1743+ 55FA                  ; given animation item is outside of bounds, deactivate animation
1744+ 55FA              .STOPANIM:
1745+ 55FA DD 36 06 00      LD (IX+6),0
1746+ 55FE C9               RET
1747+ 55FF              .L2:
1748+ 55FF 0D               DEC C
1749+ 5600 79               LD A,C
1750+ 5601 CD B3 55         CALL INIT_CURRENT_ANIMATION
1751+ 5604 38 F4            JR C, .STOPANIM
1752+ 5606 FD 7E 00         LD A,(IY) ; type of animation item
1753+ 5609 B7               OR A
1754+ 560A 28 44            JR Z,.L4 ; change pattern and/or color
1755+ 560C              .PAT:
1756+ 560C                  ; change pattern definition
1757+ 560C                  ; check if sprite or character
1758+ 560C DD 7E 07         LD A,(IX+7)
1759+ 560F B7               OR A
1760+ 5610 20 58            JR NZ,.CHAR
1761+ 5612 DD 7E 00         LD A,(IX) ; sprite number
1762+ 5615 CD 89 4D         CALL GETnthSPRATTR
1763+ 5618 23          > INC HL ; skip y and x
1763+ 5619 23          > INC HL
1763+ 561A 23          > INC HL
1763+ 561B 23          > INC HL
1764+ 561C 7E               LD A,(HL); current pattern
1765+ 561D 26 00            LD H,0
1766+ 561F 6F               LD L,A
1767+ 5620 3A E0 F3         LD A,(REG1SAV)
1768+ 5623 E6 02            AND 2
1769+ 5625 20 07            JR NZ,.L6
1770+ 5627                  ; 8x8 sprite
1771+ 5627 CD 54 65         CALL HLx8
1772+ 562A 06 08            LD B,8
1773+ 562C 18 05            JR .L5
1774+ 562E              .L6:
1775+ 562E CD 52 65         CALL HLx32
1776+ 5631 06 20            LD B,32
1777+ 5633              .L5:
1778+ 5633 3A AF FC         LD A,(SCRMOD)
1779+ 5636 3D               DEC A
1780+ 5637 20 06            JR NZ,.L10
1781+ 5639 ED 5B C5 F3      LD DE,(T32PAT)
1782+ 563D 18 04            JR .L7
1783+ 563F              .L10:
1784+ 563F ED 5B CF F3      LD DE,(GRPPAT)
1785+ 5643              .L7:
1786+ 5643 19               ADD HL,DE
1787+ 5644 CD 35 65         CALL SETWRT_LOCAL_WRITE
1788+ 5647 FD 6E 03         LD L,(IY+3)
1789+ 564A FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
1790+ 564D C3 4A 65         JP BBYTECOPY
1791+ 5650              .L4:
1792+ 5650                  ; change pattern and color in sprite attributes table
1793+ 5650 DD 7E 00         LD A,(IX) ; sprite number
1794+ 5653 CD 89 4D         CALL GETnthSPRATTR
1795+ 5656 23          > INC HL ; skip y and x
1795+ 5657 23          > INC HL
1795+ 5658 23          > INC HL
1795+ 5659 23          > INC HL
1796+ 565A FD 7E 03         LD A,(IY+3) ; new pattern
1797+ 565D 77               LD (HL),A
1798+ 565E 23          > INC HL
1798+ 565F 23          > INC HL
1799+ 5660 FD 7E 04         LD A,(IY+4) ; new color
1800+ 5663 77               LD (HL),A
1801+ 5664 2A 80 4D         LD HL,(SPRATR_UPDATE_FLAG)
1802+ 5667 36 01            LD (HL),1
1803+ 5669 C9               RET
1804+ 566A              .CHAR:
1805+ 566A DD 6E 00         LD L,(IX)
1806+ 566D 3D               DEC A
1807+ 566E 67               LD H,A
1808+ 566F CD 54 65         CALL HLx8
1809+ 5672 3A AF FC         LD A,(SCRMOD)
1810+ 5675 3D               DEC A
1811+ 5676 20 06            JR NZ,.L8
1812+ 5678 ED 5B C1 F3      LD DE,(T32CGP)
1813+ 567C 18 04            JR .L9
1814+ 567E              .L8:
1815+ 567E ED 5B CB F3      LD DE,(GRPCGP)
1816+ 5682              .L9:
1817+ 5682 06 08            LD B,8
1818+ 5684 18 BD            JR .L7
1819+ 5686              ; *******************************************************************************************************
1820+ 5686
# file closed: asm\ANIMATION.asm
 137  5686               INCLUDE "SGAM.asm"
# file opened: asm\SGAM.asm
   1+ 5686              ; Sprite Group Animate and Move
   2+ 5686
   3+ 5686              ; *******************************************************************************************************
   4+ 5686              ; shared function to process a list of animations
   5+ 5686              ; input B=list size
   6+ 5686              ; input DE=list pointer
   7+ 5686              SGAM_PROCESS_ANIM_LIST:
   8+ 5686 21 99 56         LD HL,.STEP
   9+ 5689 22 74 55         LD (ANIM_SETVALUE.FN+1),HL
  10+ 568C              .L1:
  11+ 568C C5               PUSH BC
  12+ 568D 1A               LD A,(DE)
  13+ 568E 13          > INC DE
  13+ 568F 13          > INC DE
  14+ 5690 D5               PUSH DE
  15+ 5691 CD 64 55         CALL ANIM_SETVALUE
  16+ 5694 D1               POP DE
  17+ 5695 C1               POP BC
  18+ 5696 10 F4            DJNZ .L1
  19+ 5698 C9           	RET
  20+ 5699              .STEP:
  21+ 5699 06 01            LD B,1
  22+ 569B C3 94 55         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
  23+ 569E              ; *******************************************************************************************************
  24+ 569E
  25+ 569E               IF (1 == 1)
  26+ 569E              ; *******************************************************************************************************
  27+ 569E              ; function to handle CALL SGAM basic extension
  28+ 569E              ; sets position of a group of sprites as described in SPRGRPMOV
  29+ 569E              ; and manually animate a list of animations
  30+ 569E              ; _SGAM ( INT x,
  31+ 569E              ;	      INT y,
  32+ 569E              ;		  BYTE count,
  33+ 569E              ;		  INT[2][count] data_ptr,
  34+ 569E              ;         BYTE item_number,
  35+ 569E              ;         INT[] sprite_animations )
  36+ 569E              ; will put ram in page 0 also, page 1 is already there
  37+ 569E              SGAM:
  38+ 569E 3A 7F 4D     	LD A, (SPRATR_INIT_STATUS)
  39+ 56A1 B7           	OR A
  40+ 56A2 CA 87 66     	JP Z,ILLEGAL_FUNCTION
  41+ 56A5              	; opening (
  42+ 56A5 CD 67 66     	CALL CHKCHAR
  43+ 56A8 28           	DB '('
  44+ 56A9              	; get x
  45+ 56A9 DD 21 2F 54  	LD IX, FRMQNT
  46+ 56AD CD 59 01     	CALL CALBAS
  47+ 56B0 ED 53 42 63  	LD (BLIT_STRUCT),DE
  48+ 56B4              	; comma
  49+ 56B4 CD 67 66     	CALL CHKCHAR
  50+ 56B7 2C           	DB ','
  51+ 56B8              	; get y
  52+ 56B8 DD 21 2F 54  	LD IX, FRMQNT
  53+ 56BC CD 59 01     	CALL CALBAS
  54+ 56BF ED 53 44 63  	LD (BLIT_STRUCT+2),DE
  55+ 56C3              	; comma
  56+ 56C3 CD 67 66     	CALL CHKCHAR
  57+ 56C6 2C           	DB ','
  58+ 56C7              	; get count
  59+ 56C7 DD 21 1C 52  	LD IX, GETBYT
  60+ 56CB CD 59 01     	CALL CALBAS
  61+ 56CE B7               OR A
  62+ 56CF CA 7F 66         JP Z,SUBSCRIPT_OUT_OF_RANGE
  63+ 56D2 32 46 63     	LD (BLIT_STRUCT+4),A
  64+ 56D5              	; comma
  65+ 56D5 CD 67 66     	CALL CHKCHAR
  66+ 56D8 2C           	DB ','
  67+ 56D9              	; get sprite group definition array data pointer
  68+ 56D9 3A 46 63         LD A,(BLIT_STRUCT+4)
  69+ 56DC 5F           	LD E,A
  70+ 56DD 16 03        	LD D,3
  71+ 56DF 3E 02        	LD A,2
  72+ 56E1 47           	LD B,A
  73+ 56E2 CD C0 66     	CALL GET_BASIC_ARRAY_DATA_POINTER
  74+ 56E5 ED 43 47 63  	LD (BLIT_STRUCT+5),BC
  75+ 56E9              	; comma
  76+ 56E9 CD 67 66     	CALL CHKCHAR
  77+ 56EC 2C           	DB ','
  78+ 56ED              	; get sprite animation array size
  79+ 56ED DD 21 1C 52  	LD IX,GETBYT
  80+ 56F1 CD 59 01     	CALL CALBAS
  81+ 56F4 32 49 63         LD (BLIT_STRUCT+7),A
  82+ 56F7 B7               OR A
  83+ 56F8 CA 7F 66         JP Z,SUBSCRIPT_OUT_OF_RANGE
  84+ 56FB              	; comma
  85+ 56FB CD 67 66     	CALL CHKCHAR
  86+ 56FE 2C           	DB ','
  87+ 56FF                  ; get array pointer
  88+ 56FF 3A 49 63         LD A,(BLIT_STRUCT+7)
  89+ 5702 57               LD D,A
  90+ 5703 3E 02            LD A,2
  91+ 5705 06 01            LD B,1
  92+ 5707 CD C0 66         CALL GET_BASIC_ARRAY_DATA_POINTER
  93+ 570A ED 43 4A 63      LD (BLIT_STRUCT+8),BC
  94+ 570E              	; ending )
  95+ 570E CD 67 66     	CALL CHKCHAR
  96+ 5711 29           	DB ')'
  97+ 5712              .ENTRY:
  98+ 5712 E5               PUSH HL
  99+ 5713
 100+ 5713              	; enable page 0
 101+ 5713 FD 21 1A 57  	LD IY, .RET
 102+ 5717 C3 18 66     	JP ENABLE_PAGE0
 103+ 571A              .RET:
 104+ 571A D9               EXX
 105+ 571B ED 5B 42 63      LD DE,(BLIT_STRUCT) ; initial x
 106+ 571F ED 4B 44 63      LD BC,(BLIT_STRUCT+2) ; initial y
 107+ 5723 D9               EXX
 108+ 5724 2A 47 63         LD HL,(BLIT_STRUCT+5) ; pointer to data
 109+ 5727 3A 46 63         LD A,(BLIT_STRUCT+4) ; number of entries
 110+ 572A 47               LD B,A
 111+ 572B CD DD 4E         CALL SPR_UPDATE_LOC
 112+ 572E
 113+ 572E 3A 49 63         LD A,(BLIT_STRUCT+7) ; anim number
 114+ 5731 47               LD B,A
 115+ 5732 ED 5B 4A 63      LD DE,(BLIT_STRUCT+8) ; anim list
 116+ 5736 CD 86 56     	CALL SGAM_PROCESS_ANIM_LIST
 117+ 5739
 118+ 5739 D1               POP DE
 119+ 573A C1               POP BC
 120+ 573B CD 8F 65         CALL RESTORE_PAGE_INFO
 121+ 573E FB               EI
 122+ 573F E1               POP HL
 123+ 5740 C9               RET
 124+ 5741              ; *******************************************************************************************************
 125+ 5741               ENDIF
 126+ 5741
 127+ 5741               IF (0 == 1)
 128+ 5741 ~            ; *******************************************************************************************************
 129+ 5741 ~            ; same as SGAM but for DEFUSR approach
 130+ 5741 ~            ; input IX=pointer to input array, real data from +2
 131+ 5741 ~            ; +02 = X
 132+ 5741 ~            ; +04 = Y
 133+ 5741 ~            ; +06 = count
 134+ 5741 ~            ; +08 = data pointer
 135+ 5741 ~            ; +10 = anim number
 136+ 5741 ~            ; +12 = sprite animations
 137+ 5741 ~            SGAM_DEFUSR:
 138+ 5741 ~            	; enable page 0
 139+ 5741 ~            	LD IY, .RET
 140+ 5741 ~            	JP ENABLE_PAGE0
 141+ 5741 ~            .RET:
 142+ 5741 ~            	EI
 143+ 5741 ~                EXX
 144+ 5741 ~            	LD E,(IX+2)
 145+ 5741 ~            	LD D,(IX+3) ; initial x
 146+ 5741 ~            	LD C,(IX+4)
 147+ 5741 ~            	LD B,(IX+5) ; initial y
 148+ 5741 ~                EXX
 149+ 5741 ~            	LD L,(IX+8)
 150+ 5741 ~            	LD H,(IX+9) ; pointer to data
 151+ 5741 ~                LD B,(IX+6) ; count
 152+ 5741 ~            	PUSH IX
 153+ 5741 ~                CALL SPR_UPDATE_LOC
 154+ 5741 ~            	POP IX
 155+ 5741 ~                LD B,(IX+10) ; anim number
 156+ 5741 ~            	LD E,(IX+12)
 157+ 5741 ~            	LD D,(IX+13)
 158+ 5741 ~            	CALL SGAM_PROCESS_ANIM_LIST
 159+ 5741 ~
 160+ 5741 ~                POP DE
 161+ 5741 ~                POP BC
 162+ 5741 ~                JP RESTORE_PAGE_INFO
 163+ 5741 ~            ; *******************************************************************************************************
 164+ 5741               ENDIF
 165+ 5741
 166+ 5741              ; *******************************************************************************************************
 167+ 5741              ; handles automatic move and animate sprite groups during interrupt
 168+ 5741              PROCESS_AUTOSGAMS:
 169+ 5741 3A 63 4F     	LD A,(AUTOSGAMNUM)
 170+ 5744 B7           	OR A
 171+ 5745 C8           	RET Z
 172+ 5746 47           	LD B,A
 173+ 5747 DD 2A 64 4F  	LD IX,(AUTOSGAMPTR)
 174+ 574B              .L1:
 175+ 574B C5           	PUSH BC
 176+ 574C DD 7E 13     	LD A,(IX+19) ; active flag
 177+ 574F B7           	OR A
 178+ 5750 28 28        	JR Z,.LOOPEND
 179+ 5752              	; active, check timer
 180+ 5752 DD 6E 16     	LD L,(IX+22)
 181+ 5755 DD 66 17     	LD H,(IX+23) ; timer
 182+ 5758 2B           	DEC HL
 183+ 5759 7C           	LD A,H
 184+ 575A B5           	OR L
 185+ 575B 28 08        	JR Z,.L2
 186+ 575D              	; not expired
 187+ 575D DD 75 16     	LD (IX+22),L
 188+ 5760 DD 74 17     	LD (IX+23),H
 189+ 5763 18 15        	JR .LOOPEND
 190+ 5765              .L2:
 191+ 5765              	; expired, process
 192+ 5765
 193+ 5765                  ; set initial timer
 194+ 5765 DD 7E 14         LD A,(IX+20)
 195+ 5768 DD 77 16         LD (IX+22),A
 196+ 576B DD 7E 15         LD A,(IX+21)
 197+ 576E DD 77 17         LD (IX+23),A
 198+ 5771
 199+ 5771 CD 83 57     	CALL .MOVE
 200+ 5774 CD EE 57     	CALL .UPDATELOC
 201+ 5777 CD 13 58     	CALL .PROCESS_ANIM_LIST
 202+ 577A
 203+ 577A              .LOOPEND:
 204+ 577A 11 18 00     	LD DE,24
 205+ 577D DD 19        	ADD IX,DE
 206+ 577F C1           	POP BC
 207+ 5780 10 C9        	DJNZ .L1
 208+ 5782 C9           	RET
 209+ 5783
 210+ 5783              .MOVE:
 211+ 5783              	; process movement
 212+ 5783 DD 7E 0A     	LD A,(IX+10) ; direction
 213+ 5786 B7           	OR A
 214+ 5787 28 08        	JR Z, .MOVE_L1
 215+ 5789              	; vertical
 216+ 5789 DD 6E 02     	LD L,(IX+2)
 217+ 578C DD 66 03     	LD H,(IX+3) ; vertical variable pointer
 218+ 578F 18 06        	JR .MOVE_L2
 219+ 5791              .MOVE_L1:
 220+ 5791              	; horizontal
 221+ 5791 DD 6E 00     	LD L,(IX+0)
 222+ 5794 DD 66 01     	LD H,(IX+1) ; horizontal variable pointer
 223+ 5797              .MOVE_L2:
 224+ 5797 E5           	PUSH HL
 225+ 5798 FD E1        	POP IY
 226+ 579A FD 6E 00     	LD L,(IY+0)
 227+ 579D FD 66 01     	LD H,(IY+1)
 228+ 57A0 DD 5E 08     	LD E,(IX+8)
 229+ 57A3 DD 56 09     	LD D,(IX+9) ; delta value
 230+ 57A6 19           	ADD HL,DE
 231+ 57A7 E5           	PUSH HL
 232+ 57A8 DD 5E 04     	LD E,(IX+4)
 233+ 57AB DD 56 05     	LD D,(IX+5) ; minimum value
 234+ 57AE A7           	AND A
 235+ 57AF ED 52        	SBC HL,DE
 236+ 57B1 FA CB 57     	JP M,.MOVE_L3 ; below minimum
 237+ 57B4 E1           	POP HL
 238+ 57B5 E5           	PUSH HL
 239+ 57B6 DD 5E 06     	LD E,(IX+6)
 240+ 57B9 DD 56 07     	LD D,(IX+7) ; maximum value
 241+ 57BC EB           	EX DE,HL
 242+ 57BD A7           	AND A
 243+ 57BE ED 52        	SBC HL,DE
 244+ 57C0 FA D3 57     	JP M,.MOVE_L4 ; above maximum
 245+ 57C3 E1           	POP HL
 246+ 57C4              	; within bounds
 247+ 57C4              .MOVE_L5:
 248+ 57C4 FD 75 00     	LD (IY+0),L
 249+ 57C7 FD 74 01     	LD (IY+1),H
 250+ 57CA C9           	RET
 251+ 57CB              .MOVE_L3:
 252+ 57CB E1           	POP HL
 253+ 57CC CD DF 57     	CALL .INVERSE_DELTA
 254+ 57CF 6B           	LD L,E
 255+ 57D0 62           	LD H,D
 256+ 57D1 18 F1        	JR .MOVE_L5
 257+ 57D3              .MOVE_L4:
 258+ 57D3 E1           	POP HL
 259+ 57D4 CD DF 57     	CALL .INVERSE_DELTA
 260+ 57D7 DD 6E 06     	LD L,(IX+6)
 261+ 57DA DD 66 07     	LD H,(IX+7) ; maximum
 262+ 57DD 18 E5        	JR .MOVE_L5
 263+ 57DF              .INVERSE_DELTA:
 264+ 57DF AF           	XOR A
 265+ 57E0 DD 96 08     	SUB (IX+8)
 266+ 57E3 DD 77 08     	LD (IX+8),A
 267+ 57E6 9F           	SBC A,A
 268+ 57E7 DD 96 09     	SUB (IX+9)
 269+ 57EA DD 77 09     	LD (IX+9),A
 270+ 57ED C9           	RET
 271+ 57EE
 272+ 57EE              .UPDATELOC:
 273+ 57EE DD E5        	PUSH IX
 274+ 57F0 D9           	EXX
 275+ 57F1 DD 6E 00     	LD L,(IX+0)
 276+ 57F4 DD 66 01     	LD H,(IX+1)
 277+ 57F7 5E           	LD E,(HL)
 278+ 57F8 23           	INC HL
 279+ 57F9 56           	LD D,(HL)
 280+ 57FA DD 6E 02     	LD L,(IX+2)
 281+ 57FD DD 66 03     	LD H,(IX+3)
 282+ 5800 4E           	LD C,(HL)
 283+ 5801 23           	INC HL
 284+ 5802 46           	LD B,(HL)
 285+ 5803 D9           	EXX
 286+ 5804 DD 6E 0C     	LD L,(IX+12)
 287+ 5807 DD 66 0D     	LD H,(IX+13) ; pointer to sprite group data
 288+ 580A DD 46 0B     	LD B,(IX+11) ; sprite group size
 289+ 580D CD DD 4E     	CALL SPR_UPDATE_LOC
 290+ 5810 DD E1        	POP IX
 291+ 5812 C9           	RET
 292+ 5813
 293+ 5813              .PROCESS_ANIM_LIST:
 294+ 5813 DD E5        	PUSH IX
 295+ 5815 DD 46 0E         LD B,(IX+14) ; anim list size
 296+ 5818 DD CB 09 7E  	BIT 7,(IX+9)
 297+ 581C 28 08        	JR Z,.PROCESS_ANIM_LIST_L1
 298+ 581E              	; negative direction
 299+ 581E DD 5E 0F     	LD E,(IX+15)
 300+ 5821 DD 56 10     	LD D,(IX+16)
 301+ 5824 18 06        	JR .PROCESS_ANIM_LIST_L2
 302+ 5826              .PROCESS_ANIM_LIST_L1:
 303+ 5826              	; positive direction
 304+ 5826 DD 5E 11     	LD E,(IX+17)
 305+ 5829 DD 56 12     	LD D,(IX+18)
 306+ 582C              .PROCESS_ANIM_LIST_L2:
 307+ 582C CD 86 56     	CALL SGAM_PROCESS_ANIM_LIST
 308+ 582F DD E1        	POP IX
 309+ 5831 C9           	RET
 310+ 5832              ; *******************************************************************************************************
 311+ 5832
# file closed: asm\SGAM.asm
 138  5832               ENDIF
 139  5832
 140  5832               IF (RAM_CMDS == 1)
 141  5832               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
   1+ 5832               IF (1 == 1)
   2+ 5832              ; *******************************************************************************************************
   3+ 5832              ; function to handle CALL MEMCPY basic extension
   4+ 5832              ; _MEMCPY ( INT source,
   5+ 5832              ;			INT destination,
   6+ 5832              ;			INT count,
   7+ 5832              ; will put ram in page 0 also, page 1 is already there
   8+ 5832              MEMCPY:
   9+ 5832              	; opening (
  10+ 5832 CD 67 66     	CALL CHKCHAR
  11+ 5835 28           	DB '('
  12+ 5836              	; get source address
  13+ 5836 DD 21 2F 54  	LD IX, FRMQNT
  14+ 583A CD 59 01     	CALL CALBAS
  15+ 583D D5           	PUSH DE
  16+ 583E              	; comma
  17+ 583E CD 67 66     	CALL CHKCHAR
  18+ 5841 2C           	DB ','
  19+ 5842              	; get destination address
  20+ 5842 DD 21 2F 54  	LD IX, FRMQNT
  21+ 5846 CD 59 01     	CALL CALBAS
  22+ 5849 D5           	PUSH DE
  23+ 584A              	; comma
  24+ 584A CD 67 66     	CALL CHKCHAR
  25+ 584D 2C           	DB ','
  26+ 584E              	; get length
  27+ 584E DD 21 2F 54  	LD IX, FRMQNT
  28+ 5852 CD 59 01     	CALL CALBAS
  29+ 5855 D5           	PUSH DE
  30+ 5856              	; ending )
  31+ 5856 CD 67 66     	CALL CHKCHAR
  32+ 5859 29           	DB ')'
  33+ 585A
  34+ 585A              	; save position
  35+ 585A E5           	PUSH HL
  36+ 585B DD E1        	POP IX
  37+ 585D
  38+ 585D C1           	POP BC ; count
  39+ 585E D1           	POP DE ; destination
  40+ 585F E1           	POP HL ; source
  41+ 5860 D9           	EXX
  42+ 5861              	; enable page 0
  43+ 5861 FD 21 68 58  	LD IY, .RET
  44+ 5865 C3 18 66     	JP ENABLE_PAGE0
  45+ 5868              .RET:
  46+ 5868 FB           	EI
  47+ 5869 D9           	EXX
  48+ 586A ED B0        	LDIR
  49+ 586C D1               POP DE
  50+ 586D C1               POP BC
  51+ 586E CD 8F 65         CALL RESTORE_PAGE_INFO
  52+ 5871 DD E5        	PUSH IX
  53+ 5873 E1           	POP HL
  54+ 5874 C9           	RET
  55+ 5875              ; *******************************************************************************************************
  56+ 5875               ENDIF
  57+ 5875
  58+ 5875               IF (0 == 1)
  59+ 5875 ~            ; *******************************************************************************************************
  60+ 5875 ~            ; same as MEMCPY but for DEFUSR approach
  61+ 5875 ~            ; input IX=pointer to input array, real data from +2
  62+ 5875 ~            ; +2 = source address
  63+ 5875 ~            ; +4 = destination address
  64+ 5875 ~            ; +6 = lenght
  65+ 5875 ~            MEMCPY_DEFUSR:
  66+ 5875 ~            	; enable page 0
  67+ 5875 ~            	LD IY, .RET
  68+ 5875 ~            	JP ENABLE_PAGE0
  69+ 5875 ~            .RET:
  70+ 5875 ~            	EI
  71+ 5875 ~            	LD L,(IX+2)
  72+ 5875 ~            	LD H,(IX+3)
  73+ 5875 ~            	LD E,(IX+4)
  74+ 5875 ~            	LD D,(IX+5)
  75+ 5875 ~            	LD C,(IX+6)
  76+ 5875 ~            	LD B,(IX+7)
  77+ 5875 ~            	LDIR
  78+ 5875 ~                POP DE
  79+ 5875 ~                POP BC
  80+ 5875 ~                JP RESTORE_PAGE_INFO
  81+ 5875 ~            ; *******************************************************************************************************
  82+ 5875               ENDIF
  83+ 5875
  84+ 5875               IF (1 == 1)
  85+ 5875              ; *******************************************************************************************************
  86+ 5875              ; function to handle CALL FILRAM basic extension
  87+ 5875              ; FILRAM ( INT start address,
  88+ 5875              ;		   INT count,
  89+ 5875              ;		   BYTE value )
  90+ 5875              ; will put ram in page 0 also, page 1 is already there
  91+ 5875              FILRAM:
  92+ 5875              	; opening (
  93+ 5875 CD 67 66     	CALL CHKCHAR
  94+ 5878 28           	DB '('
  95+ 5879              	; get start address
  96+ 5879 DD 21 2F 54  	LD IX, FRMQNT
  97+ 587D CD 59 01     	CALL CALBAS
  98+ 5880 D5           	PUSH DE
  99+ 5881              	; comma
 100+ 5881 CD 67 66     	CALL CHKCHAR
 101+ 5884 2C           	DB ','
 102+ 5885              	; get count
 103+ 5885 DD 21 2F 54  	LD IX, FRMQNT
 104+ 5889 CD 59 01     	CALL CALBAS
 105+ 588C D5           	PUSH DE
 106+ 588D              	; comma
 107+ 588D CD 67 66     	CALL CHKCHAR
 108+ 5890 2C           	DB ','
 109+ 5891              	; get value
 110+ 5891 DD 21 1C 52  	LD IX, GETBYT
 111+ 5895 CD 59 01     	CALL CALBAS
 112+ 5898 F5           	PUSH AF
 113+ 5899              	; ending )
 114+ 5899 CD 67 66     	CALL CHKCHAR
 115+ 589C 29           	DB ')'
 116+ 589D
 117+ 589D              	; save position
 118+ 589D E5           	PUSH HL
 119+ 589E DD E1        	POP IX
 120+ 58A0
 121+ 58A0 D1           	POP DE ; actually AF
 122+ 58A1 C1           	POP BC ; count
 123+ 58A2 E1           	POP HL ; start address
 124+ 58A3 78           	LD A, B
 125+ 58A4 B1           	OR C
 126+ 58A5 28 12        	JR Z, .EXIT ; 0 bytes to fill, skip
 127+ 58A7 D9           	EXX
 128+ 58A8              	; enable page 0
 129+ 58A8 FD 21 AF 58  	LD IY, .RET
 130+ 58AC C3 18 66     	JP ENABLE_PAGE0
 131+ 58AF              .RET:
 132+ 58AF FB           	EI
 133+ 58B0 D9           	EXX
 134+ 58B1 CD BD 58     	CALL FILVRM_FILLVALUE
 135+ 58B4 D1               POP DE
 136+ 58B5 C1               POP BC
 137+ 58B6 CD 8F 65         CALL RESTORE_PAGE_INFO
 138+ 58B9              .EXIT:
 139+ 58B9 DD E5        	PUSH IX
 140+ 58BB E1           	POP HL
 141+ 58BC C9           	RET
 142+ 58BD              ; *******************************************************************************************************
 143+ 58BD               ENDIF
 144+ 58BD
 145+ 58BD               IF (0 == 1)
 146+ 58BD ~            ; *******************************************************************************************************
 147+ 58BD ~            ; same as FILVRM but for DEFUSR approach
 148+ 58BD ~            ; input IX=pointer to input array, real data from +2
 149+ 58BD ~            ; +2 = start address
 150+ 58BD ~            ; +4 = count
 151+ 58BD ~            ; +6 = value
 152+ 58BD ~            FILRAM_DEFUSR:
 153+ 58BD ~            	; enable page 0
 154+ 58BD ~            	LD IY, .RET
 155+ 58BD ~            	JP ENABLE_PAGE0
 156+ 58BD ~            .RET:
 157+ 58BD ~            	EI
 158+ 58BD ~            	LD L,(IX+2)
 159+ 58BD ~            	LD H,(IX+3)
 160+ 58BD ~            	LD C,(IX+4)
 161+ 58BD ~            	LD B,(IX+5)
 162+ 58BD ~            	LD A,B
 163+ 58BD ~            	OR C
 164+ 58BD ~            	JR Z,.EXIT
 165+ 58BD ~            	LD D,(IX+6)
 166+ 58BD ~            	CALL FILVRM_FILLVALUE
 167+ 58BD ~            .EXIT:
 168+ 58BD ~                POP DE
 169+ 58BD ~                POP BC
 170+ 58BD ~                JP RESTORE_PAGE_INFO
 171+ 58BD ~            ; *******************************************************************************************************
 172+ 58BD               ENDIF
 173+ 58BD
 174+ 58BD              ; *******************************************************************************************************
 175+ 58BD              ; common function to fill RAM
 176+ 58BD              FILVRM_FILLVALUE:
 177+ 58BD 72               LD (HL), D
 178+ 58BE 54               LD D, H
 179+ 58BF 5D               LD E, L
 180+ 58C0 13               INC DE
 181+ 58C1 0B               DEC BC
 182+ 58C2 78           	LD A,B
 183+ 58C3 B1           	OR C
 184+ 58C4 C8           	RET Z ; if count was 1
 185+ 58C5 ED B0            LDIR
 186+ 58C7 C9               RET
 187+ 58C8              ; *******************************************************************************************************
# file closed: asm\MEMORY.asm
 142  58C8               ENDIF
 143  58C8
 144  58C8               IF (SOUND_CMDS == 1)
 145  58C8               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
   1+ 58C8              MUSIC_INIT_STATUS:
   2+ 58C8 00            DB 0
   3+ 58C9              SFX_INIT_STATUS:
   4+ 58C9 00            DB 0
   5+ 58CA              SOUND_ENABLED:
   6+ 58CA 00            DB 0
   7+ 58CB
   8+ 58CB               IF (1 == 1)
   9+ 58CB              ; *******************************************************************************************************
  10+ 58CB              ; function to handle CALL SNDPLYINIT basic extension
  11+ 58CB              ; initializes sound player
  12+ 58CB              ; _SNDPLYINIT ( INT music_offset,
  13+ 58CB              ;				INT sfx_offset, can be -1 if no SFX
  14+ 58CB              ; will put ram in page 0 also, page 1 is already there
  15+ 58CB              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
  16+ 58CB              SNDPLYINIT:
  17+ 58CB              	; opening (
  18+ 58CB CD 67 66     	CALL CHKCHAR
  19+ 58CE 28           	DB '('
  20+ 58CF              	; get music address
  21+ 58CF DD 21 2F 54  	LD IX, FRMQNT
  22+ 58D3 CD 59 01     	CALL CALBAS
  23+ 58D6 D5           	PUSH DE
  24+ 58D7              	; comma
  25+ 58D7 CD 67 66     	CALL CHKCHAR
  26+ 58DA 2C           	DB ','
  27+ 58DB              	; get sfx address
  28+ 58DB DD 21 2F 54  	LD IX, FRMQNT
  29+ 58DF CD 59 01     	CALL CALBAS
  30+ 58E2 D5           	PUSH DE
  31+ 58E3              	; ending )
  32+ 58E3 CD 67 66     	CALL CHKCHAR
  33+ 58E6 29           	DB ')'
  34+ 58E7
  35+ 58E7                  ; save position in BASIC text
  36+ 58E7 44           	LD B, H
  37+ 58E8 4D           	LD C, L
  38+ 58E9
  39+ 58E9              	; pop LDIR parameters and store away for later
  40+ 58E9 D1           	POP DE ; sfx address
  41+ 58EA E1           	POP HL ; music address
  42+ 58EB C5           	PUSH BC ; basic text location
  43+ 58EC D9           	EXX
  44+ 58ED FD 21 F4 58  	LD IY, .RET
  45+ 58F1 C3 18 66     	JP ENABLE_PAGE0
  46+ 58F4              .RET:
  47+ 58F4 D9           	EXX
  48+ 58F5
  49+ 58F5 D5           	PUSH DE
  50+ 58F6 AF           	XOR A
  51+ 58F7              	; HL = music location
  52+ 58F7 CD 65 41     	CALL PLY_AKG_INIT
  53+ 58FA 3E 01        	LD A, 1
  54+ 58FC 32 C8 58     	LD (MUSIC_INIT_STATUS), A
  55+ 58FF
  56+ 58FF E1           	POP HL ; SFX
  57+ 5900              	; check if SFX address -1
  58+ 5900 23           	INC HL
  59+ 5901 7D           	LD A, L
  60+ 5902 B4           	OR H
  61+ 5903 28 09        	JR Z,.L1
  62+ 5905 2B           	DEC HL
  63+ 5906 CD 20 40     	CALL PLY_AKG_INITSOUNDEFFECTS
  64+ 5909 3E 01        	LD A, 1
  65+ 590B 32 C9 58     	LD (SFX_INIT_STATUS), A
  66+ 590E              .L1:
  67+ 590E D1               POP DE
  68+ 590F C1               POP BC
  69+ 5910 CD 8F 65         CALL RESTORE_PAGE_INFO
  70+ 5913
  71+ 5913 E1           	POP HL
  72+ 5914 C9           	RET
  73+ 5915              ; *******************************************************************************************************
  74+ 5915               ENDIF
  75+ 5915
  76+ 5915               IF (0 == 1)
  77+ 5915 ~            ; *******************************************************************************************************
  78+ 5915 ~            ; same as SNDPLYINI but for DEFUSR approach
  79+ 5915 ~            ; input IX=pointer to input array, real data from +2
  80+ 5915 ~            ; +2 = music address
  81+ 5915 ~            ; +4 = sfx address
  82+ 5915 ~            SNDPLYINI_DEFUSR:
  83+ 5915 ~            	LD IY, .RET
  84+ 5915 ~            	JP ENABLE_PAGE0
  85+ 5915 ~            .RET:
  86+ 5915 ~            	XOR A
  87+ 5915 ~            	LD L,(IX+2)
  88+ 5915 ~            	LD H,(IX+3)
  89+ 5915 ~            	PUSH IX
  90+ 5915 ~            	CALL PLY_AKG_INIT
  91+ 5915 ~            	POP IX
  92+ 5915 ~            	LD A, 1
  93+ 5915 ~            	LD (MUSIC_INIT_STATUS), A
  94+ 5915 ~
  95+ 5915 ~            	LD L,(IX+4)
  96+ 5915 ~            	LD H,(IX+5)
  97+ 5915 ~            	; check if SFX address -1
  98+ 5915 ~            	INC HL
  99+ 5915 ~            	LD A, L
 100+ 5915 ~            	OR H
 101+ 5915 ~            	JR Z,.L1
 102+ 5915 ~            	DEC HL
 103+ 5915 ~            	CALL PLY_AKG_INITSOUNDEFFECTS
 104+ 5915 ~            	LD A, 1
 105+ 5915 ~            	LD (SFX_INIT_STATUS), A
 106+ 5915 ~            .L1:
 107+ 5915 ~                POP DE
 108+ 5915 ~                POP BC
 109+ 5915 ~                JP RESTORE_PAGE_INFO
 110+ 5915 ~            ; *******************************************************************************************************
 111+ 5915               ENDIF
 112+ 5915
 113+ 5915              ; *******************************************************************************************************
 114+ 5915              ; function to handle CALL SNDPLYON basic extension
 115+ 5915              ; enables sound player
 116+ 5915              ; _SNDPLYON
 117+ 5915              ; sets SOUND_ENABLED variable to 1 if init call was done
 118+ 5915              ; if not throws out of data error
 119+ 5915              SNDPLYON_DEFUSR:
 120+ 5915              SNDPLYON:
 121+ 5915 3A C8 58     	LD A, (MUSIC_INIT_STATUS)
 122+ 5918 B7           	OR A
 123+ 5919 20 05        	JR NZ, .L1
 124+ 591B              	; player not initialized, throw error
 125+ 591B 1E 04        	LD E, 04 ; Out of DATA
 126+ 591D C3 8D 66     	JP THROW_ERROR
 127+ 5920              .L1:
 128+ 5920 32 CA 58     	LD (SOUND_ENABLED), A
 129+ 5923              	; disable key click
 130+ 5923 AF           	XOR A
 131+ 5924 32 DB F3     	LD (CLIKSW), A
 132+ 5927 C9           	RET
 133+ 5928              ; *******************************************************************************************************
 134+ 5928
 135+ 5928              ; *******************************************************************************************************
 136+ 5928              ; function to handle CALL SNDPLYOFF basic extension
 137+ 5928              ; disables sound player
 138+ 5928              ; _SNDPLYOFF
 139+ 5928              ; sets SOUND_ENABLED variable to 0
 140+ 5928              ; calls AKG to stop music and SFX on all channels if initialized
 141+ 5928              SNDPLYOFF_DEFUSR:
 142+ 5928              SNDPLYOFF:
 143+ 5928 3A CA 58     	LD A, (SOUND_ENABLED)
 144+ 592B B7           	OR A
 145+ 592C C8           	RET Z ; already stopped
 146+ 592D AF           	XOR A
 147+ 592E 32 CA 58     	LD (SOUND_ENABLED), A
 148+ 5931 E5           	PUSH HL
 149+ 5932 CD 24 42     	CALL PLY_AKG_STOP
 150+ 5935 3A C9 58     	LD A, (SFX_INIT_STATUS)
 151+ 5938 B7           	OR A
 152+ 5939 28 0E        	JR Z, .EXIT ; SFX not in use
 153+ 593B AF           	XOR A
 154+ 593C CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 155+ 593F 3E 01        	LD A, 1
 156+ 5941 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 157+ 5944 3E 02        	LD A, 2
 158+ 5946 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 159+ 5949              .EXIT:
 160+ 5949 E1           	POP HL
 161+ 594A C9           	RET
 162+ 594B              ; *******************************************************************************************************
 163+ 594B
 164+ 594B               IF (1 == 1)
 165+ 594B              ; *******************************************************************************************************
 166+ 594B              ; function to handle CALL SNDSFX basic extension
 167+ 594B              ; plays a sound effect
 168+ 594B              ; _SNDSFX ( BYTE sfx_number, >0
 169+ 594B              ;			BYTE channel, = 0,1 or 2
 170+ 594B              ;			BYTE inverted_volume = 0-16, 0 being full volume
 171+ 594B              ; will put ram in page 0 also, page 1 is already there
 172+ 594B              ; if sound off throws illegal function call
 173+ 594B              ; if sfx not initialized, throws out of data
 174+ 594B              SNDSFX:
 175+ 594B              	; opening (
 176+ 594B CD 67 66     	CALL CHKCHAR
 177+ 594E 28           	DB '('
 178+ 594F              	; get sfx_number
 179+ 594F DD 21 1C 52  	LD IX, GETBYT
 180+ 5953 CD 59 01     	CALL CALBAS
 181+ 5956 D5           	PUSH DE
 182+ 5957              	; comma
 183+ 5957 CD 67 66     	CALL CHKCHAR
 184+ 595A 2C           	DB ','
 185+ 595B              	; get sfx address
 186+ 595B DD 21 1C 52  	LD IX, GETBYT
 187+ 595F CD 59 01     	CALL CALBAS
 188+ 5962 D5           	PUSH DE
 189+ 5963              	; comma
 190+ 5963 CD 67 66     	CALL CHKCHAR
 191+ 5966 2C           	DB ','
 192+ 5967              	; get inverted volume
 193+ 5967 DD 21 1C 52  	LD IX, GETBYT
 194+ 596B CD 59 01     	CALL CALBAS
 195+ 596E D5           	PUSH DE
 196+ 596F              	; ending )
 197+ 596F CD 67 66     	CALL CHKCHAR
 198+ 5972 29           	DB ')'
 199+ 5973
 200+ 5973 3A CA 58     	LD A, (SOUND_ENABLED)
 201+ 5976 B7           	OR A
 202+ 5977 20 05        	JR NZ, .L1
 203+ 5979              	; sound disabled, throw illegal function call
 204+ 5979 1E 05        	LD E, 5
 205+ 597B C3 8D 66     	JP THROW_ERROR
 206+ 597E              .L1:
 207+ 597E 3A C9 58     	LD A, (SFX_INIT_STATUS)
 208+ 5981 B7           	OR A
 209+ 5982 20 05        	JR NZ, .L2
 210+ 5984              	; sfx data not initialized, throw out of data
 211+ 5984 1E 04        	LD E, 4
 212+ 5986 C3 8D 66     	JP THROW_ERROR
 213+ 5989              .L2:
 214+ 5989              	; pop  parameters and store away for later
 215+ 5989 D1           	POP DE ; inverted volume
 216+ 598A 43           	LD B, E
 217+ 598B D1           	POP DE ; channel
 218+ 598C 4B           	LD C, E
 219+ 598D D1           	POP DE
 220+ 598E 7B           	LD A, E
 221+ 598F 08           	EX AF, AF'
 222+ 5990 E5           	PUSH HL ; basic text location
 223+ 5991 D9           	EXX
 224+ 5992 FD 21 99 59  	LD IY, .RET
 225+ 5996 C3 18 66     	JP ENABLE_PAGE0
 226+ 5999              .RET:
 227+ 5999 D9           	EXX
 228+ 599A 08           	EX AF, AF'
 229+ 599B CD 24 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
 230+ 599E
 231+ 599E D1               POP DE
 232+ 599F C1               POP BC
 233+ 59A0 CD 8F 65         CALL RESTORE_PAGE_INFO
 234+ 59A3
 235+ 59A3 E1           	POP HL
 236+ 59A4 C9           	RET
 237+ 59A5              ; *******************************************************************************************************
 238+ 59A5               ENDIF
 239+ 59A5
 240+ 59A5               IF (0 == 1)
 241+ 59A5 ~            ; *******************************************************************************************************
 242+ 59A5 ~            ; same as SNDSFX but for DEFUSR approach
 243+ 59A5 ~            ; input IX=pointer to input array, real data from +2
 244+ 59A5 ~            ; +2 = SFX number
 245+ 59A5 ~            ; +4 = channel
 246+ 59A5 ~            ; +6 = volume
 247+ 59A5 ~            SNDSFX_DEFUSR:
 248+ 59A5 ~            	LD A, (SOUND_ENABLED)
 249+ 59A5 ~            	OR A
 250+ 59A5 ~            	RET Z ; sound disabled, just exit
 251+ 59A5 ~            	LD A, (SFX_INIT_STATUS)
 252+ 59A5 ~            	OR A
 253+ 59A5 ~            	RET Z ; sfx data not initialized, just exit
 254+ 59A5 ~            	LD IY, .RET
 255+ 59A5 ~            	JP ENABLE_PAGE0
 256+ 59A5 ~            .RET:
 257+ 59A5 ~            	EI
 258+ 59A5 ~            	LD A,(IX+2) ; SFX number
 259+ 59A5 ~            	LD C,(IX+4) ; channel
 260+ 59A5 ~            	LD B,(IX+6) ; volume
 261+ 59A5 ~            	CALL PLY_AKG_PLAYSOUNDEFFECT
 262+ 59A5 ~                POP DE
 263+ 59A5 ~                POP BC
 264+ 59A5 ~                JP RESTORE_PAGE_INFO
 265+ 59A5 ~            ; *******************************************************************************************************
 266+ 59A5               ENDIF
# file closed: asm\SOUND.asm
 146  59A5               ENDIF
 147  59A5
 148  59A5               IF (VRAM_CMDS == 1)
 149  59A5               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
   1+ 59A5               IF (1 == 1)
   2+ 59A5              ; *******************************************************************************************************
   3+ 59A5              ; function to handle CALL FILVRM basic extension
   4+ 59A5              ; FILVRM ( INT offset,
   5+ 59A5              ;		   INT count,
   6+ 59A5              ;		   BYTE value,
   7+ 59A5              ;		   BYTE wait_vsync) >0 = true
   8+ 59A5              ; wait_vsync will issue HALT before copying
   9+ 59A5              FILVRM:
  10+ 59A5              	; opening (
  11+ 59A5 CD 67 66     	CALL CHKCHAR
  12+ 59A8 28           	DB '('
  13+ 59A9              	; get offset address
  14+ 59A9 DD 21 2F 54  	LD IX, FRMQNT
  15+ 59AD CD 59 01     	CALL CALBAS
  16+ 59B0 D5           	PUSH DE
  17+ 59B1              	; comma
  18+ 59B1 CD 67 66     	CALL CHKCHAR
  19+ 59B4 2C           	DB ','
  20+ 59B5              	; get count
  21+ 59B5 DD 21 2F 54  	LD IX, FRMQNT
  22+ 59B9 CD 59 01     	CALL CALBAS
  23+ 59BC D5           	PUSH DE
  24+ 59BD              	; comma
  25+ 59BD CD 67 66     	CALL CHKCHAR
  26+ 59C0 2C           	DB ','
  27+ 59C1              	; get value
  28+ 59C1 DD 21 1C 52  	LD IX, GETBYT
  29+ 59C5 CD 59 01     	CALL CALBAS
  30+ 59C8 F5           	PUSH AF
  31+ 59C9              	; comma
  32+ 59C9 CD 67 66     	CALL CHKCHAR
  33+ 59CC 2C           	DB ','
  34+ 59CD              	; get vsync wait
  35+ 59CD DD 21 1C 52  	LD IX, GETBYT
  36+ 59D1 CD 59 01     	CALL CALBAS
  37+ 59D4 F5           	PUSH AF
  38+ 59D5              	; ending )
  39+ 59D5 CD 67 66     	CALL CHKCHAR
  40+ 59D8 29           	DB ')'
  41+ 59D9
  42+ 59D9              	; save position
  43+ 59D9 E5           	PUSH HL
  44+ 59DA DD E1        	POP IX
  45+ 59DC
  46+ 59DC              	; syntax ok
  47+ 59DC              	; wait for vsync if needed
  48+ 59DC F1           	POP AF
  49+ 59DD B7           	OR A
  50+ 59DE 28 01        	JR Z, .L1
  51+ 59E0 76           	HALT
  52+ 59E1
  53+ 59E1              .L1:
  54+ 59E1 3E 01        	LD A,1
  55+ 59E3 32 53 63     	LD (VRAM_UPDATE_IN_PROGRESS),A
  56+ 59E6 F1               POP AF ; value
  57+ 59E7 C1               POP BC ; count
  58+ 59E8 E1               POP HL ; offset
  59+ 59E9 CD 56 00         CALL BIOS_FILVRM
  60+ 59EC AF           	XOR A
  61+ 59ED 32 53 63     	LD (VRAM_UPDATE_IN_PROGRESS),A
  62+ 59F0
  63+ 59F0              .L3:
  64+ 59F0 DD E5        	PUSH IX
  65+ 59F2 E1           	POP HL
  66+ 59F3 C9           	RET
  67+ 59F4              ; *******************************************************************************************************
  68+ 59F4               ENDIF
  69+ 59F4
  70+ 59F4               IF (0 == 1)
  71+ 59F4 ~            ; *******************************************************************************************************
  72+ 59F4 ~            ; same as FILVRM but for DEFUSR approach
  73+ 59F4 ~            ; input IX=pointer to input array, real data from +2
  74+ 59F4 ~            ; +2 = offset
  75+ 59F4 ~            ; +4 = count
  76+ 59F4 ~            ; +6 = value
  77+ 59F4 ~            ; +8 = halt flag
  78+ 59F4 ~            FILVRM_DEFUSR:
  79+ 59F4 ~            	LD A,(IX+8)
  80+ 59F4 ~            	OR A
  81+ 59F4 ~            	JR Z,.L0
  82+ 59F4 ~            	HALT
  83+ 59F4 ~            .L0:
  84+ 59F4 ~            	LD A,1
  85+ 59F4 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  86+ 59F4 ~            	LD L,(IX+2)
  87+ 59F4 ~            	LD H,(IX+3)
  88+ 59F4 ~            	LD C,(IX+4)
  89+ 59F4 ~            	LD B,(IX+5)
  90+ 59F4 ~            	LD A,(IX+6)
  91+ 59F4 ~            	CALL BIOS_FILVRM
  92+ 59F4 ~            	XOR A
  93+ 59F4 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  94+ 59F4 ~            	RET
  95+ 59F4 ~            ; *******************************************************************************************************
  96+ 59F4               ENDIF
  97+ 59F4
  98+ 59F4               IF (1 == 1)
  99+ 59F4              ; *******************************************************************************************************
 100+ 59F4              ; function to handle CALL MEMVRM basic extension
 101+ 59F4              ; copies from RAM to VRAM
 102+ 59F4              ; if flag != 0 it will issue HALT before copying
 103+ 59F4              ; if bit 1 of flag set and sprite system initialized it will set sprite update flag
 104+ 59F4              ; _MEMVRM ( INT source,
 105+ 59F4              ;			INT destination,
 106+ 59F4              ;			INT count,
 107+ 59F4              ;			BYTE flag)
 108+ 59F4              ; will put ram in page 0 also, page 1 is already there
 109+ 59F4              MEMVRM:
 110+ 59F4              	; opening (
 111+ 59F4 CD 67 66     	CALL CHKCHAR
 112+ 59F7 28           	DB '('
 113+ 59F8              	; get source address
 114+ 59F8 DD 21 2F 54  	LD IX, FRMQNT
 115+ 59FC CD 59 01     	CALL CALBAS
 116+ 59FF D5           	PUSH DE
 117+ 5A00              	; comma
 118+ 5A00 CD 67 66     	CALL CHKCHAR
 119+ 5A03 2C           	DB ','
 120+ 5A04              	; get destination address
 121+ 5A04 DD 21 2F 54  	LD IX, FRMQNT
 122+ 5A08 CD 59 01     	CALL CALBAS
 123+ 5A0B D5           	PUSH DE
 124+ 5A0C              	; comma
 125+ 5A0C CD 67 66     	CALL CHKCHAR
 126+ 5A0F 2C           	DB ','
 127+ 5A10              	; get length
 128+ 5A10 DD 21 2F 54  	LD IX, FRMQNT
 129+ 5A14 CD 59 01     	CALL CALBAS
 130+ 5A17 D5           	PUSH DE
 131+ 5A18              	; comma
 132+ 5A18 CD 67 66     	CALL CHKCHAR
 133+ 5A1B 2C           	DB ','
 134+ 5A1C              	; get vsync wait
 135+ 5A1C DD 21 1C 52  	LD IX, GETBYT
 136+ 5A20 CD 59 01     	CALL CALBAS
 137+ 5A23 F5           	PUSH AF
 138+ 5A24              	; ending )
 139+ 5A24 CD 67 66     	CALL CHKCHAR
 140+ 5A27 29           	DB ')'
 141+ 5A28
 142+ 5A28                  ; save position in BASIC text
 143+ 5A28 E5           	PUSH HL
 144+ 5A29 DD E1        	POP IX
 145+ 5A2B
 146+ 5A2B F1           	POP AF ; wait vsync
 147+ 5A2C B7           	OR A
 148+ 5A2D 28 0F        	JR Z, .L1
 149+ 5A2F              	; check for special case to set sprite update flag
 150+ 5A2F              	IF (SPRITE_CMDS == 1)
 151+ 5A2F E6 02        		AND 2
 152+ 5A31 28 0A        		JR Z,.L2
 153+ 5A33 3A 7F 4D     		LD A, (SPRATR_INIT_STATUS)
 154+ 5A36 B7           		OR A
 155+ 5A37 28 04        		JR Z,.L2
 156+ 5A39 2A 80 4D     		LD HL,(SPRATR_UPDATE_FLAG)
 157+ 5A3C 77           		LD (HL),A
 158+ 5A3D              	ENDIF
 159+ 5A3D              .L2:
 160+ 5A3D 76           	HALT
 161+ 5A3E              .L1:
 162+ 5A3E              	; pop LDIR parameters and store away for later
 163+ 5A3E C1           	POP BC ; count
 164+ 5A3F D1           	POP DE ; vram destination
 165+ 5A40 E1           	POP HL ; ram source
 166+ 5A41 D9           	EXX
 167+ 5A42 FD 21 49 5A   	LD IY, .RET
 168+ 5A46 C3 18 66     	JP ENABLE_PAGE0
 169+ 5A49              .RET:
 170+ 5A49 FB           	EI
 171+ 5A4A D9           	EXX
 172+ 5A4B CD 57 5A     	CALL VRAM_LDIRVM
 173+ 5A4E D1               POP DE
 174+ 5A4F C1               POP BC
 175+ 5A50 CD 8F 65         CALL RESTORE_PAGE_INFO
 176+ 5A53 DD E5        	PUSH IX
 177+ 5A55 E1           	POP HL
 178+ 5A56 C9           	RET
 179+ 5A57              ; *******************************************************************************************************
 180+ 5A57               ENDIF
 181+ 5A57
 182+ 5A57               IF (0 == 1)
 183+ 5A57 ~            ; *******************************************************************************************************
 184+ 5A57 ~            ; same as MEMVRM but for DEFUSR approach
 185+ 5A57 ~            ; input IX=pointer to input array, real data from +2
 186+ 5A57 ~            ; +2 = source address
 187+ 5A57 ~            ; +4 = destination address
 188+ 5A57 ~            ; +6 = lenght
 189+ 5A57 ~            ; +8 = flag
 190+ 5A57 ~            MEMVRM_DEFUSR:
 191+ 5A57 ~            	LD A,(IX+8)
 192+ 5A57 ~            	OR A
 193+ 5A57 ~            	JR Z,.L0
 194+ 5A57 ~            	IF (SPRITE_CMDS == 1)
 195+ 5A57 ~            		AND 2
 196+ 5A57 ~            		JR Z,.L2
 197+ 5A57 ~            		LD A, (SPRATR_INIT_STATUS)
 198+ 5A57 ~            		OR A
 199+ 5A57 ~            		JR Z,.L2
 200+ 5A57 ~            		LD HL,(SPRATR_UPDATE_FLAG)
 201+ 5A57 ~            		LD (HL),A
 202+ 5A57 ~            	ENDIF
 203+ 5A57 ~            .L2:
 204+ 5A57 ~            	HALT
 205+ 5A57 ~            .L0:
 206+ 5A57 ~            	; enable page 0
 207+ 5A57 ~            	LD IY, .RET
 208+ 5A57 ~            	JP ENABLE_PAGE0
 209+ 5A57 ~            .RET:
 210+ 5A57 ~            	EI
 211+ 5A57 ~            	LD L,(IX+2)
 212+ 5A57 ~            	LD H,(IX+3)
 213+ 5A57 ~            	LD E,(IX+4)
 214+ 5A57 ~            	LD D,(IX+5)
 215+ 5A57 ~            	LD C,(IX+6)
 216+ 5A57 ~            	LD B,(IX+7)
 217+ 5A57 ~            	CALL VRAM_LDIRVM
 218+ 5A57 ~                POP DE
 219+ 5A57 ~                POP BC
 220+ 5A57 ~                JP RESTORE_PAGE_INFO
 221+ 5A57 ~            ; *******************************************************************************************************
 222+ 5A57               ENDIF
 223+ 5A57
 224+ 5A57              ; *******************************************************************************************************
 225+ 5A57              ; common code to copy from memory to VRAM
 226+ 5A57              ; input HL=RAM source
 227+ 5A57              ; input DE=VRAM destination
 228+ 5A57              ; BC=count
 229+ 5A57              VRAM_LDIRVM:
 230+ 5A57 3E 01        	LD A,1
 231+ 5A59 32 53 63     	LD (VRAM_UPDATE_IN_PROGRESS),A
 232+ 5A5C EB           	EX DE, HL
 233+ 5A5D F3           	DI
 234+ 5A5E CD 35 65     	CALL SETWRT_LOCAL_WRITE
 235+ 5A61 FB           	EI
 236+ 5A62 EB           	EX DE, HL
 237+ 5A63 78           	LD A, B
 238+ 5A64 B7           	OR A
 239+ 5A65 28 0D        	JR Z, .L3
 240+ 5A67 C5           	PUSH BC
 241+ 5A68 0E 98        	LD C, #98
 242+ 5A6A              .L2:
 243+ 5A6A 50           	LD D, B
 244+ 5A6B 06 00        	LD B, 0
 245+ 5A6D CD 4C 65     	CALL BBYTECOPY_NO_C
 246+ 5A70 42           	LD B, D
 247+ 5A71 10 F7        	DJNZ .L2
 248+ 5A73 C1           	POP BC
 249+ 5A74              .L3:
 250+ 5A74 79           	LD A, C
 251+ 5A75 B7           	OR A
 252+ 5A76 28 04        	JR Z,.L4
 253+ 5A78 41           	LD B, C
 254+ 5A79 CD 4A 65     	CALL BBYTECOPY
 255+ 5A7C              .L4:
 256+ 5A7C AF           	XOR A
 257+ 5A7D 32 53 63     	LD (VRAM_UPDATE_IN_PROGRESS),A
 258+ 5A80 C9           	RET
 259+ 5A81              ; *******************************************************************************************************
 260+ 5A81
 261+ 5A81               IF (1 == 1)
 262+ 5A81              ; *******************************************************************************************************
 263+ 5A81              ; function to handle CALL VRMMEM basic extension
 264+ 5A81              ; copies from VRAM to RAM
 265+ 5A81              ; _VRMMEM ( INT source,
 266+ 5A81              ;			INT destination,
 267+ 5A81              ;			INT count
 268+ 5A81              ; will put ram in page 0 also, page 1 is already there
 269+ 5A81              VRMMEM:
 270+ 5A81              	; opening (
 271+ 5A81 CD 67 66     	CALL CHKCHAR
 272+ 5A84 28           	DB '('
 273+ 5A85              	; get source address
 274+ 5A85 DD 21 2F 54  	LD IX, FRMQNT
 275+ 5A89 CD 59 01     	CALL CALBAS
 276+ 5A8C D5           	PUSH DE
 277+ 5A8D              	; comma
 278+ 5A8D CD 67 66     	CALL CHKCHAR
 279+ 5A90 2C           	DB ','
 280+ 5A91              	; get destination address
 281+ 5A91 DD 21 2F 54  	LD IX, FRMQNT
 282+ 5A95 CD 59 01     	CALL CALBAS
 283+ 5A98 D5           	PUSH DE
 284+ 5A99              	; comma
 285+ 5A99 CD 67 66     	CALL CHKCHAR
 286+ 5A9C 2C           	DB ','
 287+ 5A9D              	; get length
 288+ 5A9D DD 21 2F 54  	LD IX, FRMQNT
 289+ 5AA1 CD 59 01     	CALL CALBAS
 290+ 5AA4 D5           	PUSH DE
 291+ 5AA5              	; ending )
 292+ 5AA5 CD 67 66     	CALL CHKCHAR
 293+ 5AA8 29           	DB ')'
 294+ 5AA9
 295+ 5AA9                  ; save position in BASIC text
 296+ 5AA9 E5           	PUSH HL
 297+ 5AAA DD E1        	POP IX
 298+ 5AAC
 299+ 5AAC C1           	POP BC ; count
 300+ 5AAD D1           	POP DE ; destination
 301+ 5AAE E1           	POP HL ; source
 302+ 5AAF D9           	EXX
 303+ 5AB0 FD 21 B7 5A  	LD IY, .RET
 304+ 5AB4 C3 18 66     	JP ENABLE_PAGE0
 305+ 5AB7              .RET:
 306+ 5AB7 FB           	EI
 307+ 5AB8 D9           	EXX
 308+ 5AB9 CD C5 5A     	CALL VRAM_LDIRMV
 309+ 5ABC D1               POP DE
 310+ 5ABD C1               POP BC
 311+ 5ABE CD 8F 65         CALL RESTORE_PAGE_INFO
 312+ 5AC1 DD E5        	PUSH IX
 313+ 5AC3 E1           	POP HL
 314+ 5AC4 C9           	RET
 315+ 5AC5              ; *******************************************************************************************************
 316+ 5AC5               ENDIF
 317+ 5AC5
 318+ 5AC5               IF (0 == 1)
 319+ 5AC5 ~            ; *******************************************************************************************************
 320+ 5AC5 ~            ; same as VRMMEM but for DEFUSR approach
 321+ 5AC5 ~            ; input IX=pointer to input array, real data from +2
 322+ 5AC5 ~            ; +2 = source address
 323+ 5AC5 ~            ; +4 = destination address
 324+ 5AC5 ~            ; +6 = count
 325+ 5AC5 ~            VRMMEM_DEFUSR:
 326+ 5AC5 ~            	; enable page 0
 327+ 5AC5 ~            	LD IY, .RET
 328+ 5AC5 ~            	JP ENABLE_PAGE0
 329+ 5AC5 ~            .RET:
 330+ 5AC5 ~            	EI
 331+ 5AC5 ~            	LD L,(IX+2)
 332+ 5AC5 ~            	LD H,(IX+3)
 333+ 5AC5 ~            	LD E,(IX+4)
 334+ 5AC5 ~            	LD D,(IX+5)
 335+ 5AC5 ~            	LD C,(IX+6)
 336+ 5AC5 ~            	LD B,(IX+7)
 337+ 5AC5 ~            	CALL VRAM_LDIRMV
 338+ 5AC5 ~                POP DE
 339+ 5AC5 ~                POP BC
 340+ 5AC5 ~                JP RESTORE_PAGE_INFO
 341+ 5AC5 ~            ; *******************************************************************************************************
 342+ 5AC5               ENDIF
 343+ 5AC5
 344+ 5AC5              ; *******************************************************************************************************
 345+ 5AC5              ; common code to copy from VRAM to RAM
 346+ 5AC5              ; input HL=VRAM source
 347+ 5AC5              ; input DE=RAM destination
 348+ 5AC5              ; BC=count
 349+ 5AC5              VRAM_LDIRMV:
 350+ 5AC5 3E 01        	LD A,1
 351+ 5AC7 32 53 63     	LD (VRAM_UPDATE_IN_PROGRESS),A
 352+ 5ACA 7D           	LD	A, L
 353+ 5ACB F3           	DI
 354+ 5ACC CD 40 65     	CALL SETWRT_LOCAL_READ
 355+ 5ACF FB           	EI
 356+ 5AD0 00           	NOP
 357+ 5AD1 00           	NOP
 358+ 5AD2 00           	NOP ; too fast VDP access per openMSX
 359+ 5AD3              .L4:
 360+ 5AD3 DB 98            IN A, (#98)
 361+ 5AD5 12           	LD (DE), A
 362+ 5AD6 13               INC DE
 363+ 5AD7 0B               DEC BC
 364+ 5AD8 79               LD A, C
 365+ 5AD9 B0               OR B
 366+ 5ADA 20 F7            JR NZ, .L4
 367+ 5ADC AF           	XOR A
 368+ 5ADD 32 53 63     	LD (VRAM_UPDATE_IN_PROGRESS),A
 369+ 5AE0 C9               RET
 370+ 5AE1              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
 150  5AE1               ENDIF
 151  5AE1
 152  5AE1               IF (GENCAL_CMD == 1)
 153  5AE1               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
   1+ 5AE1               IF (0 == 1)
   2+ 5AE1 ~            ; *******************************************************************************************************
   3+ 5AE1 ~            ; same as GENCAL but for DEFUSR approach
   4+ 5AE1 ~            ; input IX=pointer to input array, real data from +2
   5+ 5AE1 ~            ; +2 = function address to call
   6+ 5AE1 ~            ; +4 = register list array pointer
   7+ 5AE1 ~            GENCAL_DEFUSR:
   8+ 5AE1 ~                LD L,(IX+2)
   9+ 5AE1 ~                LD H,(IX+3)
  10+ 5AE1 ~                PUSH HL
  11+ 5AE1 ~                LD L,(IX+4)
  12+ 5AE1 ~                LD H,(IX+5)
  13+ 5AE1 ~                PUSH HL
  14+ 5AE1 ~                JR GENCAL.COMMON
  15+ 5AE1 ~            ; *******************************************************************************************************
  16+ 5AE1               ENDIF
  17+ 5AE1
  18+ 5AE1              ; *******************************************************************************************************
  19+ 5AE1              ; function to handle CALL GENCAL basic extension
  20+ 5AE1              ; GENCAL ( INT fn_addr, = address of the function to call
  21+ 5AE1              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
  22+ 5AE1              ; output values of registers will also be stored at reg_list_ptr
  23+ 5AE1              GENCAL:
  24+ 5AE1               IF (1 == 1)
  25+ 5AE1              	; opening (
  26+ 5AE1 CD 67 66     	CALL CHKCHAR
  27+ 5AE4 28           	DB '('
  28+ 5AE5              	; get function address
  29+ 5AE5 DD 21 2F 54  	LD IX, FRMQNT
  30+ 5AE9 CD 59 01     	CALL CALBAS
  31+ 5AEC D5           	PUSH DE
  32+ 5AED              	; comma
  33+ 5AED CD 67 66     	CALL CHKCHAR
  34+ 5AF0 2C           	DB ','
  35+ 5AF1              	; get pointer to register list
  36+ 5AF1 3E 02            LD A,2
  37+ 5AF3 06 01            LD B,1
  38+ 5AF5 11 00 05         LD DE,#0500
  39+ 5AF8 CD C0 66         CALL GET_BASIC_ARRAY_DATA_POINTER
  40+ 5AFB C5           	PUSH BC
  41+ 5AFC              	; ending )
  42+ 5AFC CD 67 66     	CALL CHKCHAR
  43+ 5AFF 29           	DB ')'
  44+ 5B00               ENDIF
  45+ 5B00              .COMMON:
  46+ 5B00              	; save BASIC token position
  47+ 5B00 E5           	PUSH HL
  48+ 5B01 D9               EXX
  49+ 5B02 E1           	POP HL ; HL'=next basic token
  50+ 5B03 D9               EXX
  51+ 5B04
  52+ 5B04 E1               POP HL ; get pointer to register values
  53+ 5B05 F3           	DI
  54+ 5B06 ED 73 42 63      LD (BLIT_STRUCT), SP
  55+ 5B0A F9               LD SP, HL
  56+ 5B0B F1               POP AF
  57+ 5B0C C1               POP BC
  58+ 5B0D D1               POP DE
  59+ 5B0E E1               POP HL
  60+ 5B0F DD E1            POP IX
  61+ 5B11 FD E1            POP IY
  62+ 5B13 D9               EXX
  63+ 5B14 ED 73 44 63      LD (BLIT_STRUCT+2), SP
  64+ 5B18 ED 7B 42 63      LD SP, (BLIT_STRUCT)
  65+ 5B1C FB               EI
  66+ 5B1D D1               POP DE ; get function to call
  67+ 5B1E E5               PUSH HL
  68+ 5B1F CD 3A 5B         CALL .EXXDECALL
  69+ 5B22 F3               DI
  70+ 5B23 ED 73 42 63      LD (BLIT_STRUCT), SP
  71+ 5B27 ED 7B 44 63      LD SP, (BLIT_STRUCT+2)
  72+ 5B2B FD E5            PUSH IY
  73+ 5B2D DD E5            PUSH IX
  74+ 5B2F E5               PUSH HL
  75+ 5B30 D5               PUSH DE
  76+ 5B31 C5               PUSH BC
  77+ 5B32 F5               PUSH AF
  78+ 5B33 ED 7B 42 63      LD SP, (BLIT_STRUCT)
  79+ 5B37 FB               EI
  80+ 5B38 E1               POP HL
  81+ 5B39 C9           	RET
  82+ 5B3A
  83+ 5B3A              .EXXDECALL:
  84+ 5B3A D5               PUSH DE
  85+ 5B3B D9               EXX
  86+ 5B3C C9               RET
  87+ 5B3D              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
 154  5B3D               ENDIF
 155  5B3D
 156  5B3D               IF (BOX_CMDS == 1)
 157  5B3D               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
   1+ 5B3D              ; *******************************************************************************************************
   2+ 5B3D              ; generic function to implement rectangle data copy
   3+ 5B3D              ; should be modified to call appropriate function for memory or vram
   4+ 5B3D              ; input IX=pointer to following structure
   5+ 5B3D              ; +00 source data pointer
   6+ 5B3D              ; +02 num bytes in a row
   7+ 5B3D              ; +04 number of rows
   8+ 5B3D              ; +06 source add-to value till next row
   9+ 5B3D              ; +08 destination address
  10+ 5B3D              ; +10 destination add-to value till next row
  11+ 5B3D              ; modifies AF, BC, DE, HL
  12+ 5B3D              RECTANGLE_COPY:
  13+ 5B3D DD 6E 00     	LD L, (IX+0)
  14+ 5B40 DD 66 01     	LD H, (IX+1) ; source address
  15+ 5B43 DD 5E 08     	LD E, (IX+8)
  16+ 5B46 DD 56 09     	LD D, (IX+9) ; destination
  17+ 5B49 DD 46 04     	LD B, (IX+4) ; row number
  18+ 5B4C              .L1:
  19+ 5B4C C5           	PUSH BC
  20+ 5B4D E5           		PUSH HL
  21+ 5B4E D5           			PUSH DE
  22+ 5B4F DD 4E 02     				LD C, (IX+2)
  23+ 5B52 DD 46 03     				LD B, (IX+3) ; num bytes in a row
  24+ 5B55              .CALL1:
  25+ 5B55 CD 00 00     				CALL 0 ; set destination address from DE
  26+ 5B58              .CALL2:
  27+ 5B58 CD 00 00     				CALL 0 ; copy data fn
  28+ 5B5B E1           			POP HL
  29+ 5B5C DD 4E 0A     			LD C, (IX+10)
  30+ 5B5F DD 46 0B     			LD B, (IX+11) ; destination add-to
  31+ 5B62 09           			ADD HL, BC
  32+ 5B63 EB           			EX DE, HL
  33+ 5B64 E1           		POP HL
  34+ 5B65 DD 4E 06     		LD C, (IX+6)
  35+ 5B68 DD 46 07     		LD B, (IX+7) ; src add-to
  36+ 5B6B 09           		ADD HL, BC
  37+ 5B6C C1           	POP BC
  38+ 5B6D 10 DD        	DJNZ .L1
  39+ 5B6F C9           	RET
  40+ 5B70              ; *******************************************************************************************************
  41+ 5B70
  42+ 5B70               IF (1 == 1)
  43+ 5B70              ; *******************************************************************************************************
  44+ 5B70              ; function to handle CALL BOXMEMCPY basic extension
  45+ 5B70              ; copies data with window like boundaries within ram
  46+ 5B70              ; BOXMEMCPY ( INT source data pointer,
  47+ 5B70              ;			  INT source number of bytes in a row,
  48+ 5B70              ;			  INT number of rows,
  49+ 5B70              ;			  INT source add-to value till next row,
  50+ 5B70              ; 			  INT destination pointer,
  51+ 5B70              ;			  INT destination add-to value till next row )
  52+ 5B70              ; request_data_ptr described in RECTANGLE_COPY
  53+ 5B70              ; will put ram in page 0 also, page 1 is already there
  54+ 5B70              BOXMEMCPY:
  55+ 5B70 11 7A 5B     	LD DE,BOXMEMCPY_COMMON
  56+ 5B73 ED 53 F2 5B  	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
  57+ 5B77 C3 8D 5B     	JP BOX_EXTENSION_PARAMS_COMMON
  58+ 5B7A               ENDIF
  59+ 5B7A
  60+ 5B7A               IF (0 == 1)
  61+ 5B7A ~            ; *******************************************************************************************************
  62+ 5B7A ~            ; same as BOXMEMCPY but for DEFUSR approach
  63+ 5B7A ~            ; input IX=pointer to input array, real data from +2
  64+ 5B7A ~            ; +02 = source data pointer
  65+ 5B7A ~            ; +04 = source number of bytes in a row
  66+ 5B7A ~            ; +06 = number of rows
  67+ 5B7A ~            ; +08 = source add-to value till next row
  68+ 5B7A ~            ; +10 = destination pointer
  69+ 5B7A ~            ; +12 = destination add-to value till next row
  70+ 5B7A ~            BOXMEMCPY_DEFUSR:
  71+ 5B7A ~            	LD HL,BOXMEMCPY_COMMON
  72+ 5B7A ~            	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
  73+ 5B7A ~            	INC IX
  74+ 5B7A ~            	INC IX
  75+ 5B7A ~            	JP BOXCOMMON_DEFUSR
  76+ 5B7A               ENDIF
  77+ 5B7A
  78+ 5B7A              BOXMEMCPY_COMMON:
  79+ 5B7A FB           	EI
  80+ 5B7B              	; set RAM functions to call
  81+ 5B7B 21 00 00     	LD HL, 0
  82+ 5B7E 22 55 5B     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
  83+ 5B81 22 57 5B     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
  84+ 5B84 21 ED B0     	LD HL, #B0ED ; LDIR
  85+ 5B87 22 59 5B     	LD (RECTANGLE_COPY.CALL1+4), HL
  86+ 5B8A C3 F7 5B     	JP BOXCOMMON_DEFUSR.CALL
  87+ 5B8D              ; *******************************************************************************************************
  88+ 5B8D
  89+ 5B8D               IF (1 == 1)
  90+ 5B8D              ; *******************************************************************************************************
  91+ 5B8D              ; common parts of BOX commands to load parameters
  92+ 5B8D              BOX_EXTENSION_PARAMS_COMMON:
  93+ 5B8D              	; opening (
  94+ 5B8D CD 67 66     	CALL CHKCHAR
  95+ 5B90 28           	DB '('
  96+ 5B91              	; get source data pointer
  97+ 5B91 DD 21 2F 54  	LD IX, FRMQNT
  98+ 5B95 CD 59 01     	CALL CALBAS
  99+ 5B98 ED 53 42 63  	LD (BLIT_STRUCT+0), DE
 100+ 5B9C              	; comma
 101+ 5B9C CD 67 66     	CALL CHKCHAR
 102+ 5B9F 2C           	DB ','
 103+ 5BA0              	; source number of bytes in a row
 104+ 5BA0 DD 21 2F 54  	LD IX, FRMQNT
 105+ 5BA4 CD 59 01     	CALL CALBAS
 106+ 5BA7 ED 53 44 63  	LD (BLIT_STRUCT+2), DE
 107+ 5BAB              	; comma
 108+ 5BAB CD 67 66     	CALL CHKCHAR
 109+ 5BAE 2C           	DB ','
 110+ 5BAF              	; number of rows
 111+ 5BAF DD 21 2F 54  	LD IX, FRMQNT
 112+ 5BB3 CD 59 01     	CALL CALBAS
 113+ 5BB6 ED 53 46 63  	LD (BLIT_STRUCT+4), DE
 114+ 5BBA              	; comma
 115+ 5BBA CD 67 66     	CALL CHKCHAR
 116+ 5BBD 2C           	DB ','
 117+ 5BBE              	; source add-to value till next row
 118+ 5BBE DD 21 2F 54  	LD IX, FRMQNT
 119+ 5BC2 CD 59 01     	CALL CALBAS
 120+ 5BC5 ED 53 48 63  	LD (BLIT_STRUCT+6), DE
 121+ 5BC9              	; comma
 122+ 5BC9 CD 67 66     	CALL CHKCHAR
 123+ 5BCC 2C           	DB ','
 124+ 5BCD              	; destination pointer
 125+ 5BCD DD 21 2F 54  	LD IX, FRMQNT
 126+ 5BD1 CD 59 01     	CALL CALBAS
 127+ 5BD4 ED 53 4A 63  	LD (BLIT_STRUCT+8), DE
 128+ 5BD8              	; comma
 129+ 5BD8 CD 67 66     	CALL CHKCHAR
 130+ 5BDB 2C           	DB ','
 131+ 5BDC              	; destination add-to value till next row
 132+ 5BDC DD 21 2F 54  	LD IX, FRMQNT
 133+ 5BE0 CD 59 01     	CALL CALBAS
 134+ 5BE3 ED 53 4C 63  	LD (BLIT_STRUCT+10), DE
 135+ 5BE7              	; ending )
 136+ 5BE7 CD 67 66     	CALL CHKCHAR
 137+ 5BEA 29           	DB ')'
 138+ 5BEB DD 21 42 63  	LD IX,BLIT_STRUCT
 139+ 5BEF               ENDIF
 140+ 5BEF              BOXCOMMON_DEFUSR:
 141+ 5BEF E5           	PUSH HL ; save position in BASIC buffer
 142+ 5BF0              .ADDR:
 143+ 5BF0 FD 21 00 00  	LD IY, 0 ; modified by code
 144+ 5BF4 C3 18 66     	JP ENABLE_PAGE0
 145+ 5BF7              .CALL:
 146+ 5BF7 CD 3D 5B     	CALL RECTANGLE_COPY
 147+ 5BFA AF           	XOR A
 148+ 5BFB 32 53 63     	LD (VRAM_UPDATE_IN_PROGRESS),A
 149+ 5BFE
 150+ 5BFE D1               POP DE
 151+ 5BFF C1               POP BC
 152+ 5C00 CD 8F 65         CALL RESTORE_PAGE_INFO
 153+ 5C03
 154+ 5C03 E1           	POP HL
 155+ 5C04 C9           	RET
 156+ 5C05              ; *******************************************************************************************************
 157+ 5C05
 158+ 5C05               IF (1 == 1)
 159+ 5C05              ; *******************************************************************************************************
 160+ 5C05              ; function to handle CALL BOXMEMVRM basic extension
 161+ 5C05              ; copies data with window like boundaries from ram to Vram
 162+ 5C05              ; BOXMEMVRM ( INT source data pointer,
 163+ 5C05              ;			  INT source number of bytes in a row,
 164+ 5C05              ;			  INT number of rows,
 165+ 5C05              ;			  INT source add-to value till next row,
 166+ 5C05              ; 			  INT destination pointer,
 167+ 5C05              ;			  INT destination add-to value till next row )
 168+ 5C05              ; request_data_ptr described in RECTANGLE_COPY
 169+ 5C05              ; will put ram in page 0 also, page 1 is already there
 170+ 5C05              BOXMEMVRM:
 171+ 5C05 11 0F 5C     	LD DE,BOXMEMVRM_COMMON
 172+ 5C08 ED 53 F2 5B  	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
 173+ 5C0C C3 8D 5B     	JP BOX_EXTENSION_PARAMS_COMMON
 174+ 5C0F               ENDIF
 175+ 5C0F
 176+ 5C0F               IF (0 == 1)
 177+ 5C0F ~            ; *******************************************************************************************************
 178+ 5C0F ~            ; same as BOXMEMVRM but for DEFUSR approach
 179+ 5C0F ~            ; input IX=pointer to input array, real data from +2
 180+ 5C0F ~            ; +02 = source data pointer
 181+ 5C0F ~            ; +04 = source number of bytes in a row
 182+ 5C0F ~            ; +06 = number of rows
 183+ 5C0F ~            ; +08 = source add-to value till next row
 184+ 5C0F ~            ; +10 = destination pointer
 185+ 5C0F ~            ; +12 = destination add-to value till next row
 186+ 5C0F ~            BOXMEMVRM_DEFUSR:
 187+ 5C0F ~            	LD HL,BOXMEMVRM_COMMON
 188+ 5C0F ~            	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
 189+ 5C0F ~            	INC IX
 190+ 5C0F ~            	INC IX
 191+ 5C0F ~            	JP BOXCOMMON_DEFUSR
 192+ 5C0F               ENDIF
 193+ 5C0F
 194+ 5C0F              BOXMEMVRM_COMMON:
 195+ 5C0F FB           	EI
 196+ 5C10              	; set RAM functions to call
 197+ 5C10 21 2A 5C     	LD HL, .SETDEST
 198+ 5C13 22 56 5B     	LD (RECTANGLE_COPY.CALL1+1), HL
 199+ 5C16 21 32 5C     	LD HL, .COPYDATA
 200+ 5C19 22 59 5B     	LD (RECTANGLE_COPY.CALL2+1), HL
 201+ 5C1C 3E CD        	LD A, #CD ; CALL
 202+ 5C1E 32 55 5B     	LD (RECTANGLE_COPY.CALL1), A
 203+ 5C21 32 58 5B     	LD (RECTANGLE_COPY.CALL2), A
 204+ 5C24              	;LD A,1
 205+ 5C24 32 53 63     	LD (VRAM_UPDATE_IN_PROGRESS),A
 206+ 5C27 C3 F7 5B     	JP BOXCOMMON_DEFUSR.CALL
 207+ 5C2A              .SETDEST:
 208+ 5C2A EB           	EX DE, HL
 209+ 5C2B F3           	DI
 210+ 5C2C CD 35 65     	CALL SETWRT_LOCAL_WRITE
 211+ 5C2F FB           	EI
 212+ 5C30 EB           	EX DE, HL
 213+ 5C31 C9           	RET
 214+ 5C32              .COPYDATA:
 215+ 5C32 41           	LD B, C
 216+ 5C33 C3 4A 65     	JP BBYTECOPY
 217+ 5C36              ; *******************************************************************************************************
# file closed: asm\BOX.asm
 158  5C36               ENDIF
 159  5C36
 160  5C36               IF (BLIT_CMDS == 1)
 161  5C36               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
   1+ 5C36              ; *******************************************************************************************************
   2+ 5C36              ; function rotates mask and data of several characters and applies to background data
   3+ 5C36              ; this handles x-shift from 0 to 4
   4+ 5C36              ; contains self-modifying code that is set-up from external function
   5+ 5C36              ; input HL=pointer to mask data
   6+ 5C36              ; input HL'=pointer to character data
   7+ 5C36              ; input DE=output buffer containing background data
   8+ 5C36              ; input BC=DE+8
   9+ 5C36              ; input A=number of characters to process
  10+ 5C36              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  11+ 5C36              SHIFT04:
  12+ 5C36 08           	EX AF, AF'
  13+ 5C37 7E           	LD A, (HL) ; get mask
  14+ 5C38 D9           	EXX
  15+ 5C39 57           	LD D, A
  16+ 5C3A 1E FF        	LD E, #FF
  17+ 5C3C 37           	SCF
  18+ 5C3D              .M1:
  19+ 5C3D 18 FE        	JR .M1 ; this is self-modifying part
  20+ 5C3F CB 1A        	RR D
  21+ 5C41 CB 1B        	RR E
  22+ 5C43 CB 1A        	RR D
  23+ 5C45 CB 1B        	RR E
  24+ 5C47 CB 1A        	RR D
  25+ 5C49 CB 1B        	RR E
  26+ 5C4B CB 1A        	RR D
  27+ 5C4D CB 1B        	RR E
  28+ 5C4F
  29+ 5C4F 46           	LD B, (HL) ; get data
  30+ 5C50 0E 00        	LD C, 0
  31+ 5C52              .M2:
  32+ 5C52 18 FE        	JR .M2 ; also self-modifying part
  33+ 5C54 CB 38        	SRL B
  34+ 5C56 CB 19        	RR C
  35+ 5C58 CB 38        	SRL B
  36+ 5C5A CB 19        	RR C
  37+ 5C5C CB 38        	SRL B
  38+ 5C5E CB 19        	RR C
  39+ 5C60 CB 38        	SRL B
  40+ 5C62 CB 19        	RR C
  41+ 5C64
  42+ 5C64 D9           	EXX
  43+ 5C65 1A           	LD A, (DE) ; background
  44+ 5C66 D9           	EXX
  45+ 5C67 A2           	AND D
  46+ 5C68 B0           	OR B
  47+ 5C69 D9           	EXX
  48+ 5C6A 12           	LD (DE), A
  49+ 5C6B
  50+ 5C6B 0A           	LD A, (BC)
  51+ 5C6C D9           	EXX
  52+ 5C6D A3           	AND E
  53+ 5C6E B1           	OR C
  54+ 5C6F 23           	INC HL
  55+ 5C70 D9           	EXX
  56+ 5C71 02           	LD (BC), A
  57+ 5C72
  58+ 5C72 23           	INC HL
  59+ 5C73 13           	INC DE
  60+ 5C74 03           	INC BC
  61+ 5C75
  62+ 5C75 08           	EX AF, AF'
  63+ 5C76 3D           	DEC A
  64+ 5C77 C2 36 5C     	JP NZ, SHIFT04
  65+ 5C7A C9           	RET
  66+ 5C7B              ; *******************************************************************************************************
  67+ 5C7B
  68+ 5C7B              ; *******************************************************************************************************
  69+ 5C7B              ; function rotates mask and data of several characters and applies to background data
  70+ 5C7B              ; this handles x-shift from 5 to 8
  71+ 5C7B              ; contains self-modifying code that is set-up from external function
  72+ 5C7B              ; input HL=pointer to mask data
  73+ 5C7B              ; input HL'=pointer to character data
  74+ 5C7B              ; input DE=output buffer containing background data
  75+ 5C7B              ; input BC=DE+8
  76+ 5C7B              ; input A=number of characters to process
  77+ 5C7B              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  78+ 5C7B              SHIFT58:
  79+ 5C7B 08           	EX AF, AF'
  80+ 5C7C 7E           	LD A, (HL) ; get mask
  81+ 5C7D D9           	EXX
  82+ 5C7E 57           	LD D, A
  83+ 5C7F 1E FF        	LD E, #FF
  84+ 5C81 37           	SCF
  85+ 5C82              .M1:
  86+ 5C82 18 FE        	JR .M1 ; this is self-modifying part
  87+ 5C84 CB 12        	RL D
  88+ 5C86 CB 13        	RL E
  89+ 5C88 CB 12        	RL D
  90+ 5C8A CB 13        	RL E
  91+ 5C8C CB 12        	RL D
  92+ 5C8E CB 13        	RL E
  93+ 5C90
  94+ 5C90 46           	LD B, (HL)
  95+ 5C91 0E 00        	LD C, 0
  96+ 5C93              .M2:
  97+ 5C93 18 FE        	JR .M2 ; also self-modifying part
  98+ 5C95 CB 20        	SLA B
  99+ 5C97 CB 11        	RL C
 100+ 5C99 CB 20        	SLA B
 101+ 5C9B CB 11        	RL C
 102+ 5C9D CB 20        	SLA B
 103+ 5C9F CB 11        	RL C
 104+ 5CA1
 105+ 5CA1 D9           	EXX
 106+ 5CA2 1A           	LD A, (DE) ; background
 107+ 5CA3 D9           	EXX
 108+ 5CA4 A3           	AND E
 109+ 5CA5 B1           	OR C
 110+ 5CA6 D9           	EXX
 111+ 5CA7 12           	LD (DE), A
 112+ 5CA8
 113+ 5CA8 0A           	LD A, (BC)
 114+ 5CA9 D9           	EXX
 115+ 5CAA A2           	AND D
 116+ 5CAB B0           	OR B
 117+ 5CAC 23           	INC HL
 118+ 5CAD D9           	EXX
 119+ 5CAE 02           	LD (BC), A
 120+ 5CAF
 121+ 5CAF 23           	INC HL
 122+ 5CB0 13           	INC DE
 123+ 5CB1 03           	INC BC
 124+ 5CB2
 125+ 5CB2 08           	EX AF, AF'
 126+ 5CB3 3D           	DEC A
 127+ 5CB4 C2 7B 5C     	JP NZ, SHIFT58
 128+ 5CB7 C9           	RET
 129+ 5CB8              ; *******************************************************************************************************
 130+ 5CB8
 131+ 5CB8              ; *******************************************************************************************************
 132+ 5CB8              ; routine that shifts one row of characters
 133+ 5CB8              ; contains self-modifying code that is set-up from external function
 134+ 5CB8              ; input HL=pointer to mask data
 135+ 5CB8              ; input HL'=pointer to character data
 136+ 5CB8              ; input DE=output buffer containing background data
 137+ 5CB8              ; input A=number of characters to process
 138+ 5CB8              ; input IX=pointer to structure describing input data
 139+ 5CB8              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 140+ 5CB8              SHIFT_ROW:
 141+ 5CB8 F5           	PUSH AF
 142+ 5CB9 ED 53 3E 63  		LD (BLIT_TMP1), DE
 143+ 5CBD E5           		PUSH HL
 144+ 5CBE CD 01 5D     			CALL .ADDYSHIFT
 145+ 5CC1 E1           		POP HL
 146+ 5CC2 ED 53 40 63  		LD (BLIT_TMP2), DE ; DE+vertical shift
 147+ 5CC6              .L1:
 148+ 5CC6 3E 08        		LD A, 8
 149+ 5CC8 DD 96 02     		SUB (IX+2) ; y shift
 150+ 5CCB              .CALL1:
 151+ 5CCB CD 00 00     		CALL 0
 152+ 5CCE DD 7E 02     		LD A, (IX+2); y shift
 153+ 5CD1 B7           		OR A
 154+ 5CD2 28 26        		JR Z, .DONE
 155+ 5CD4 ED 5B 3E 63  		LD DE, (BLIT_TMP1)
 156+ 5CD8 E5           		PUSH HL
 157+ 5CD9 CD 0F 5D     			CALL .DETONEXTROW
 158+ 5CDC E1           		POP HL
 159+ 5CDD              .CALL2:
 160+ 5CDD CD 00 00     		CALL 0
 161+ 5CE0 ED 5B 3E 63  		LD DE, (BLIT_TMP1)
 162+ 5CE4 E5           		PUSH HL
 163+ 5CE5 CD 09 5D     			CALL .ADD8
 164+ 5CE8 E1           		POP HL
 165+ 5CE9 ED 53 3E 63  		LD (BLIT_TMP1), DE
 166+ 5CED ED 5B 40 63  		LD DE, (BLIT_TMP2)
 167+ 5CF1 E5           		PUSH HL
 168+ 5CF2 CD 09 5D     			CALL .ADD8
 169+ 5CF5 E1           		POP HL
 170+ 5CF6 ED 53 40 63  		LD (BLIT_TMP2), DE ; DE+vertical shift
 171+ 5CFA              .DONE:
 172+ 5CFA F1           	POP AF
 173+ 5CFB 3D           	DEC A
 174+ 5CFC C8           	RET Z
 175+ 5CFD F5           	PUSH AF
 176+ 5CFE C3 C6 5C     	JP .L1
 177+ 5D01              .ADDYSHIFT:
 178+ 5D01 EB           	EX DE, HL
 179+ 5D02 16 00        	LD D, 0
 180+ 5D04 DD 5E 02     	LD E, (IX+2); y shift
 181+ 5D07 18 0C        	JR .MOVDEBC
 182+ 5D09              .ADD8:
 183+ 5D09 21 08 00     	LD HL, 8
 184+ 5D0C C3 15 5D     	JP .MOVDEBC
 185+ 5D0F              .DETONEXTROW:
 186+ 5D0F DD 6E 06     	LD L, (IX+6)
 187+ 5D12 DD 66 07     	LD H, (IX+7) ; bkg add to value
 188+ 5D15              .MOVDEBC:
 189+ 5D15 19           	ADD HL, DE
 190+ 5D16 54           	LD D, H
 191+ 5D17 5D           	LD E, L
 192+ 5D18 01 08 00     	LD BC, 8
 193+ 5D1B 09           	ADD HL, BC
 194+ 5D1C 44           	LD B, H
 195+ 5D1D 4D           	LD C, L
 196+ 5D1E C9           	RET
 197+ 5D1F              ; *******************************************************************************************************
 198+ 5D1F
 199+ 5D1F              ; *******************************************************************************************************
 200+ 5D1F              ; function rotates mask and character data and applies it to background
 201+ 5D1F              ; input IX=pointer to structure describing input data
 202+ 5D1F              ; +0  DW horizontal shift count 0-7 (low byte used)
 203+ 5D1F              ; +2  DW vertical shift count 0-7 (low byte used)
 204+ 5D1F              ; +4  DW background data start;
 205+ 5D1F              ; +6  DW background add to value to next row of background data
 206+ 5D1F              ; +8  DW mask data start;
 207+ 5D1F              ; +10  DW character data start;
 208+ 5D1F              ; +12 DW character&mask add to value to next row of data
 209+ 5D1F              ; +14 DW columns (low byte used)
 210+ 5D1F              ; +16 DW rows (low byte used)
 211+ 5D1F              SHIFT_MERGE_CHARACTER:
 212+ 5D1F DD 7E 00     	LD A, (IX) ; shift
 213+ 5D22 FE 05        	CP 5
 214+ 5D24 38 25        	JR C, .RIGHT
 215+ 5D26              	; shifts 5-7, use rotate towards left 1-3
 216+ 5D26 21 7B 5C     	LD HL, SHIFT58
 217+ 5D29 22 CC 5C     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 218+ 5D2C 22 DE 5C     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 219+ 5D2F D6 05        	SUB 5
 220+ 5D31 28 0D        	JR Z, .L1
 221+ 5D33 87           	ADD A, A
 222+ 5D34 87           	ADD A, A
 223+ 5D35 67           	LD H, A
 224+ 5D36 2E 18        	LD L, #18 ; JR opcode
 225+ 5D38 22 82 5C     	LD (SHIFT58.M1), HL
 226+ 5D3B 22 93 5C     	LD (SHIFT58.M2), HL
 227+ 5D3E 18 32        	JR .DO
 228+ 5D40              .L1:
 229+ 5D40 21 00 00     	LD HL, 0 ; 2xNOP opcode
 230+ 5D43 22 82 5C     	LD (SHIFT58.M1), HL
 231+ 5D46 22 93 5C     	LD (SHIFT58.M2), HL
 232+ 5D49 18 27        	JR .DO
 233+ 5D4B              .RIGHT:
 234+ 5D4B              	; shifts 0-4, rotate towards right
 235+ 5D4B 21 36 5C     	LD HL, SHIFT04
 236+ 5D4E 22 CC 5C     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 237+ 5D51 22 DE 5C     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 238+ 5D54 FE 04        	CP 4
 239+ 5D56 28 11        	JR Z, .R1
 240+ 5D58 D6 04        	SUB 4
 241+ 5D5A ED 44        	NEG
 242+ 5D5C 87           	ADD A, A
 243+ 5D5D 87           	ADD A, A
 244+ 5D5E 67           	LD H, A
 245+ 5D5F 2E 18        	LD L, #18 ; JR opcode
 246+ 5D61 22 3D 5C     	LD (SHIFT04.M1), HL
 247+ 5D64 22 52 5C     	LD (SHIFT04.M2), HL
 248+ 5D67 18 09        	JR .DO
 249+ 5D69              .R1:
 250+ 5D69 21 00 00     	LD HL, 0 ; 2xNOP opcode
 251+ 5D6C 22 3D 5C     	LD (SHIFT04.M1), HL
 252+ 5D6F 22 52 5C     	LD (SHIFT04.M2), HL
 253+ 5D72              .DO:
 254+ 5D72 DD 46 10     	LD B, (IX+16) ; rows
 255+ 5D75 DD 6E 08     	LD L, (IX+8)
 256+ 5D78 DD 66 09     	LD H, (IX+9) ; mask data
 257+ 5D7B DD 5E 04     	LD E, (IX+4)
 258+ 5D7E DD 56 05     	LD D, (IX+5) ; background data
 259+ 5D81 D9           	EXX
 260+ 5D82 DD 6E 0A     	LD L, (IX+10)
 261+ 5D85 DD 66 0B     	LD H, (IX+11) ; character data
 262+ 5D88 D9           	EXX
 263+ 5D89              .LOOP:
 264+ 5D89 C5           	PUSH BC
 265+ 5D8A E5           		PUSH HL
 266+ 5D8B D5           			PUSH DE
 267+ 5D8C D9           				EXX
 268+ 5D8D E5           				PUSH HL
 269+ 5D8E D9           					EXX
 270+ 5D8F DD 7E 0E     					LD A, (IX+14) ; columns
 271+ 5D92              .CALL:
 272+ 5D92 CD B8 5C     					CALL SHIFT_ROW
 273+ 5D95 E1           				POP HL
 274+ 5D96 DD 5E 0C     				LD E, (IX+12)
 275+ 5D99 DD 56 0D     				LD D, (IX+13) ; char data to next row
 276+ 5D9C 19           				ADD HL, DE
 277+ 5D9D D9           				EXX
 278+ 5D9E E1           			POP HL
 279+ 5D9F DD 5E 06     			LD E, (IX+6)
 280+ 5DA2 DD 56 07     			LD D, (IX+7) ; background to next row
 281+ 5DA5 19           			ADD HL, DE
 282+ 5DA6 EB           			EX DE, HL
 283+ 5DA7 E1           		POP HL
 284+ 5DA8 DD 4E 0C     		LD C, (IX+12)
 285+ 5DAB DD 46 0D     		LD B, (IX+13) ; char data to next row
 286+ 5DAE 09           		ADD HL, BC
 287+ 5DAF C1           	POP BC
 288+ 5DB0 10 D7        	DJNZ .LOOP
 289+ 5DB2 C9           	RET
 290+ 5DB3              ; *******************************************************************************************************
 291+ 5DB3
 292+ 5DB3              ; *******************************************************************************************************
 293+ 5DB3              ; helper function DE \ 8
 294+ 5DB3              DEdiv8:
 295+ 5DB3 7B           	LD A,E
 296+ 5DB4 CB 2A        	SRA D
 297+ 5DB6 CB 1F            RR  A
 298+ 5DB8 CB 2A            SRA D
 299+ 5DBA CB 1F            RR  A
 300+ 5DBC CB 2A            SRA D
 301+ 5DBE CB 1F            RR  A
 302+ 5DC0 C9           	RET
 303+ 5DC1              ; *******************************************************************************************************
 304+ 5DC1
 305+ 5DC1               IF (0 == 1)
 306+ 5DC1 ~            ; *******************************************************************************************************
 307+ 5DC1 ~            ; function to handle BLIT basic extension through DEFUSR call in RAW format
 308+ 5DC1 ~            ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 309+ 5DC1 ~            ; +2  DW horizontal shift count 0-7 (low byte used)
 310+ 5DC1 ~            ; +4  DW vertical shift count 0-7 (low byte used)
 311+ 5DC1 ~            ; +6  DW background data start;
 312+ 5DC1 ~            ; +8  DW background add to value to next row of background data
 313+ 5DC1 ~            ; +10  DW mask data start;
 314+ 5DC1 ~            ; +12  DW character data start;
 315+ 5DC1 ~            ; +14 DW character&mask add to value to next row of data
 316+ 5DC1 ~            ; +16 DW columns (low byte used)
 317+ 5DC1 ~            ; +18 DW rows (low byte used)
 318+ 5DC1 ~            ; will put ram in page 0 also, page 1 is already there
 319+ 5DC1 ~            ;BLIT_DEFUSR:
 320+ 5DC1 ~            ;	DI
 321+ 5DC1 ~            ;	LD IY, .RET
 322+ 5DC1 ~            ;	JP ENABLE_PAGE0
 323+ 5DC1 ~            ;.RET:
 324+ 5DC1 ~            ;	EI
 325+ 5DC1 ~            ;	INC IX
 326+ 5DC1 ~            ;	INC IX
 327+ 5DC1 ~            ;	CALL SHIFT_MERGE_CHARACTER
 328+ 5DC1 ~            ;
 329+ 5DC1 ~            ;   POP DE
 330+ 5DC1 ~            ;    POP BC
 331+ 5DC1 ~            ;    JP RESTORE_PAGE_INFO
 332+ 5DC1 ~            ; *******************************************************************************************************
 333+ 5DC1 ~
 334+ 5DC1 ~            ; *******************************************************************************************************
 335+ 5DC1 ~            ; function to handle CALL BLIT basic extension in DEFUSR form
 336+ 5DC1 ~            ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 337+ 5DC1 ~            ; +02 x
 338+ 5DC1 ~            ; +04 y
 339+ 5DC1 ~            ; +06 char_data_pointer
 340+ 5DC1 ~            ; +08 mask_data_pointer
 341+ 5DC1 ~            ; +10 width
 342+ 5DC1 ~            ; +12 height
 343+ 5DC1 ~            ; +14 background_pointer
 344+ 5DC1 ~            ; +16 background_width
 345+ 5DC1 ~            ; BLIT ( INT x,
 346+ 5DC1 ~            ;		 INT y,
 347+ 5DC1 ~            ;		 INT char_data_pointer,
 348+ 5DC1 ~            ;		 INT mask_data_pointer,
 349+ 5DC1 ~            ;		 INT width (in characters),
 350+ 5DC1 ~            ;		 INT height (in characters),
 351+ 5DC1 ~            ;		 INT background_pointer (top left),
 352+ 5DC1 ~            ;		 INT background_width (in characters),
 353+ 5DC1 ~            BLIT_DEFUSR:
 354+ 5DC1 ~            	LD E,(IX+2)
 355+ 5DC1 ~            	LD D,(IX+3)
 356+ 5DC1 ~            	LD A,E
 357+ 5DC1 ~            	AND 7
 358+ 5DC1 ~            	LD (BLIT_STRUCT+0),A
 359+ 5DC1 ~            	CALL DEdiv8
 360+ 5DC1 ~            	LD (BLIT_TMP+0),A
 361+ 5DC1 ~            	LD E,(IX+4)
 362+ 5DC1 ~            	LD D,(IX+5)
 363+ 5DC1 ~            	LD A,E
 364+ 5DC1 ~            	AND 7
 365+ 5DC1 ~            	LD (BLIT_STRUCT+2),A
 366+ 5DC1 ~            	CALL DEdiv8
 367+ 5DC1 ~            	LD (BLIT_TMP+1),A
 368+ 5DC1 ~            	LD L,(IX+6)
 369+ 5DC1 ~            	LD H,(IX+7)
 370+ 5DC1 ~            	LD (BLIT_STRUCT+10),HL
 371+ 5DC1 ~            	LD L,(IX+8)
 372+ 5DC1 ~            	LD H,(IX+9)
 373+ 5DC1 ~            	LD (BLIT_STRUCT+8),HL
 374+ 5DC1 ~            	LD A,(IX+10)
 375+ 5DC1 ~            	LD (BLIT_STRUCT+14),A
 376+ 5DC1 ~            	LD A,(IX+12)
 377+ 5DC1 ~            	LD (BLIT_STRUCT+16),A
 378+ 5DC1 ~            	LD L,(IX+14)
 379+ 5DC1 ~            	LD H,(IX+15)
 380+ 5DC1 ~            	LD (BLIT_STRUCT+4),HL
 381+ 5DC1 ~            	;LD A,(IX+16)
 382+ 5DC1 ~            	;LD (BLIT_TMP+2),A
 383+ 5DC1 ~
 384+ 5DC1 ~            	; calculate char&mask add to value
 385+ 5DC1 ~            	LD H,0
 386+ 5DC1 ~            	LD A,(BLIT_STRUCT+14)
 387+ 5DC1 ~            	LD L,A
 388+ 5DC1 ~            	CALL HLx8
 389+ 5DC1 ~            	LD (BLIT_STRUCT+12),HL
 390+ 5DC1 ~            	; calculate background add to value
 391+ 5DC1 ~            	LD H,0
 392+ 5DC1 ~            	LD L,(IX+16)
 393+ 5DC1 ~            	CALL HLx8
 394+ 5DC1 ~            	LD (BLIT_STRUCT+6),HL
 395+ 5DC1 ~            	; calculate pointer to background location
 396+ 5DC1 ~            	LD HL,0
 397+ 5DC1 ~            	LD A,(BLIT_TMP+1)
 398+ 5DC1 ~            	OR A
 399+ 5DC1 ~            	JR Z, .L1
 400+ 5DC1 ~            	LD B,A
 401+ 5DC1 ~            	LD DE,(BLIT_STRUCT+6)
 402+ 5DC1 ~            .L0:
 403+ 5DC1 ~            	ADD HL, DE
 404+ 5DC1 ~            	DJNZ .L0
 405+ 5DC1 ~            .L1:
 406+ 5DC1 ~            	EX DE,HL
 407+ 5DC1 ~            	LD H,0
 408+ 5DC1 ~            	LD A,(BLIT_TMP+0)
 409+ 5DC1 ~            	LD L,A
 410+ 5DC1 ~            	CALL HLx8
 411+ 5DC1 ~            	ADD HL,DE
 412+ 5DC1 ~            	LD DE,(BLIT_STRUCT+4)
 413+ 5DC1 ~            	ADD HL,DE
 414+ 5DC1 ~            	LD (BLIT_STRUCT+4),HL
 415+ 5DC1 ~
 416+ 5DC1 ~            	LD IY, .RET
 417+ 5DC1 ~            	JP ENABLE_PAGE0
 418+ 5DC1 ~            .RET:
 419+ 5DC1 ~            	EI
 420+ 5DC1 ~            	LD IX, BLIT_STRUCT
 421+ 5DC1 ~            	CALL SHIFT_MERGE_CHARACTER
 422+ 5DC1 ~
 423+ 5DC1 ~                POP DE
 424+ 5DC1 ~                POP BC
 425+ 5DC1 ~                JP RESTORE_PAGE_INFO
 426+ 5DC1 ~            ; *******************************************************************************************************
 427+ 5DC1               ENDIF
 428+ 5DC1
 429+ 5DC1               IF (1 == 1)
 430+ 5DC1              ; *******************************************************************************************************
 431+ 5DC1              ; function to handle CALL BLIT basic extension
 432+ 5DC1              ; rotates 1-bit character drawing horizontally with mask and character data and
 433+ 5DC1              ; fuses with background data and applies vertical shift too
 434+ 5DC1              ; in form without pointers
 435+ 5DC1              ; BLIT ( INT x,
 436+ 5DC1              ;		 INT y,
 437+ 5DC1              ;		 INT char_data_pointer,
 438+ 5DC1              ;		 INT mask_data_pointer,
 439+ 5DC1              ;		 INT width (in characters),
 440+ 5DC1              ;		 INT height (in characters),
 441+ 5DC1              ;		 INT background_pointer (top left),
 442+ 5DC1              ;		 INT background_width (in characters),
 443+ 5DC1              ; will put ram in page 0 also, page 1 is already there
 444+ 5DC1              BLIT:
 445+ 5DC1              	; opening (
 446+ 5DC1 CD 67 66     	CALL CHKCHAR
 447+ 5DC4 28           	DB '('
 448+ 5DC5              	; get x coordinate
 449+ 5DC5 DD 21 2F 54  	LD IX, FRMQNT
 450+ 5DC9 CD 59 01     	CALL CALBAS
 451+ 5DCC 7B           	LD A, E
 452+ 5DCD E6 07        	AND 7
 453+ 5DCF 32 42 63     	LD (BLIT_STRUCT+0), A
 454+ 5DD2 CD B3 5D     	CALL DEdiv8
 455+ 5DD5 32 3E 63     	LD (BLIT_TMP+0),A
 456+ 5DD8              	; comma
 457+ 5DD8 CD 67 66     	CALL CHKCHAR
 458+ 5DDB 2C           	DB ','
 459+ 5DDC              	; get y coordinate
 460+ 5DDC DD 21 2F 54  	LD IX, FRMQNT
 461+ 5DE0 CD 59 01     	CALL CALBAS
 462+ 5DE3 7B           	LD A, E
 463+ 5DE4 E6 07        	AND 7
 464+ 5DE6 32 44 63     	LD (BLIT_STRUCT+2), A
 465+ 5DE9 CD B3 5D     	CALL DEdiv8
 466+ 5DEC 32 3F 63     	LD (BLIT_TMP+1),A
 467+ 5DEF              	; comma
 468+ 5DEF CD 67 66     	CALL CHKCHAR
 469+ 5DF2 2C           	DB ','
 470+ 5DF3              	; get char data pointer
 471+ 5DF3 DD 21 2F 54  	LD IX, FRMQNT
 472+ 5DF7 CD 59 01     	CALL CALBAS
 473+ 5DFA ED 53 4C 63  	LD (BLIT_STRUCT+10), DE
 474+ 5DFE              	; comma
 475+ 5DFE CD 67 66     	CALL CHKCHAR
 476+ 5E01 2C           	DB ','
 477+ 5E02              	; get mask data pointer
 478+ 5E02 DD 21 2F 54  	LD IX, FRMQNT
 479+ 5E06 CD 59 01     	CALL CALBAS
 480+ 5E09 ED 53 4A 63  	LD (BLIT_STRUCT+8), DE
 481+ 5E0D              	; comma
 482+ 5E0D CD 67 66     	CALL CHKCHAR
 483+ 5E10 2C           	DB ','
 484+ 5E11              	; get width
 485+ 5E11 DD 21 2F 54  	LD IX, FRMQNT
 486+ 5E15 CD 59 01     	CALL CALBAS
 487+ 5E18 7B           	LD A, E
 488+ 5E19 32 50 63     	LD (BLIT_STRUCT+14), A
 489+ 5E1C              	; comma
 490+ 5E1C CD 67 66     	CALL CHKCHAR
 491+ 5E1F 2C           	DB ','
 492+ 5E20              	; get height
 493+ 5E20 DD 21 2F 54  	LD IX, FRMQNT
 494+ 5E24 CD 59 01     	CALL CALBAS
 495+ 5E27 7B           	LD A, E
 496+ 5E28 32 52 63     	LD (BLIT_STRUCT+16), A
 497+ 5E2B              	; comma
 498+ 5E2B CD 67 66     	CALL CHKCHAR
 499+ 5E2E 2C           	DB ','
 500+ 5E2F              	; get background pointer
 501+ 5E2F DD 21 2F 54  	LD IX, FRMQNT
 502+ 5E33 CD 59 01     	CALL CALBAS
 503+ 5E36 ED 53 46 63  	LD (BLIT_STRUCT+4), DE
 504+ 5E3A              	; comma
 505+ 5E3A CD 67 66     	CALL CHKCHAR
 506+ 5E3D 2C           	DB ','
 507+ 5E3E              	; get background width
 508+ 5E3E DD 21 2F 54  	LD IX, FRMQNT
 509+ 5E42 CD 59 01     	CALL CALBAS
 510+ 5E45 7B           	LD A, E
 511+ 5E46 32 40 63     	LD (BLIT_TMP+2), A
 512+ 5E49              	; ending )
 513+ 5E49 CD 67 66     	CALL CHKCHAR
 514+ 5E4C 29           	DB ')'
 515+ 5E4D
 516+ 5E4D E5           	PUSH HL ; save position in BASIC buffer
 517+ 5E4E
 518+ 5E4E              	; calculate char&mask add to value
 519+ 5E4E 26 00        	LD H, 0
 520+ 5E50 3A 50 63     	LD A, (BLIT_STRUCT+14)
 521+ 5E53 6F           	LD L, A
 522+ 5E54 CD 54 65     	CALL HLx8
 523+ 5E57 22 4E 63     	LD (BLIT_STRUCT+12), HL
 524+ 5E5A              	; calculate background add to value
 525+ 5E5A 26 00        	LD H, 0
 526+ 5E5C 3A 40 63     	LD A, (BLIT_TMP+2)
 527+ 5E5F 6F           	LD L, A
 528+ 5E60 CD 54 65     	CALL HLx8
 529+ 5E63 22 48 63     	LD (BLIT_STRUCT+6), HL
 530+ 5E66              	; calculate pointer to background location
 531+ 5E66 21 00 00     	LD HL, 0
 532+ 5E69 3A 3F 63     	LD A,(BLIT_TMP+1)
 533+ 5E6C B7           	OR A
 534+ 5E6D 28 08        	JR Z, .L1
 535+ 5E6F 47           	LD B,A
 536+ 5E70 ED 5B 48 63  	LD DE,(BLIT_STRUCT+6)
 537+ 5E74              .L0:
 538+ 5E74 19           	ADD HL, DE
 539+ 5E75 10 FD        	DJNZ .L0
 540+ 5E77              .L1:
 541+ 5E77 EB           	EX DE,HL
 542+ 5E78 26 00        	LD H,0
 543+ 5E7A 3A 3E 63     	LD A,(BLIT_TMP+0)
 544+ 5E7D 6F           	LD L,A
 545+ 5E7E CD 54 65     	CALL HLx8
 546+ 5E81 19           	ADD HL,DE
 547+ 5E82 ED 5B 46 63  	LD DE,(BLIT_STRUCT+4)
 548+ 5E86 19           	ADD HL,DE
 549+ 5E87 22 46 63     	LD (BLIT_STRUCT+4),HL
 550+ 5E8A
 551+ 5E8A FD 21 91 5E  	LD IY, .RET
 552+ 5E8E C3 18 66     	JP ENABLE_PAGE0
 553+ 5E91              .RET:
 554+ 5E91 FB           	EI
 555+ 5E92 DD 21 42 63  	LD IX, BLIT_STRUCT
 556+ 5E96 CD 1F 5D     	CALL SHIFT_MERGE_CHARACTER
 557+ 5E99
 558+ 5E99 D1               POP DE
 559+ 5E9A C1               POP BC
 560+ 5E9B CD 8F 65         CALL RESTORE_PAGE_INFO
 561+ 5E9E
 562+ 5E9E E1           	POP HL
 563+ 5E9F C9           	RET
 564+ 5EA0              ; *******************************************************************************************************
 565+ 5EA0               ENDIF
# file closed: asm\BLIT.asm
 162  5EA0               ENDIF
 163  5EA0
 164  5EA0               IF (TILE_CMDS == 1)
 165  5EA0               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
   1+ 5EA0              ; *******************************************************************************************************
   2+ 5EA0              ; generic function to implement tiling
   3+ 5EA0              ; should be modified to call appropriate function for memory or vram
   4+ 5EA0              ; input IX=pointer to following structure
   5+ 5EA0              ; +00 tile_data_ptr
   6+ 5EA0              ; +02 tile_rows
   7+ 5EA0              ; +04 tile_columns
   8+ 5EA0              ; +06 destination_address
   9+ 5EA0              ; +08 dest_to_next_row_add_to_value
  10+ 5EA0              ; +10 num_horizontal_tiles
  11+ 5EA0              ; +12 num_vertical_tiles
  12+ 5EA0              ; modifies AF, BC, DE, HL
  13+ 5EA0              TILE:
  14+ 5EA0 DD 6E 06     	LD L, (IX+6)
  15+ 5EA3 DD 66 07     	LD H, (IX+7) ; destination address
  16+ 5EA6 22 3E 63     	LD (TILETMP1), HL
  17+ 5EA9 DD 46 0C     	LD B, (IX+12) ; vertical tile number
  18+ 5EAC              .L1:
  19+ 5EAC C5           	PUSH BC
  20+ 5EAD DD 6E 00     		LD L, (IX+0)
  21+ 5EB0 DD 66 01     		LD H, (IX+1) ; tile address
  22+ 5EB3 22 40 63     		LD (TILETMP2), HL
  23+ 5EB6 DD 46 02     		LD B, (IX+2) ; tile rows
  24+ 5EB9              .L2:
  25+ 5EB9 C5           		PUSH BC
  26+ 5EBA CD 00 00     .CALL1:		CALL 0
  27+ 5EBD DD 46 0A     			LD B, (IX+10) ; horizontal tile num
  28+ 5EC0              .L3:
  29+ 5EC0 C5           			PUSH BC
  30+ 5EC1 2A 40 63     				LD HL, (TILETMP2)
  31+ 5EC4 DD 46 04     				LD B, (IX+4) ; tile columns
  32+ 5EC7              .L4:
  33+ 5EC7 C5           				PUSH BC
  34+ 5EC8              .CALL2:
  35+ 5EC8 CD 00 00     					CALL 0
  36+ 5ECB C1           				POP BC
  37+ 5ECC 10 F9        				DJNZ .L4
  38+ 5ECE C1           			POP BC
  39+ 5ECF 10 EF        			DJNZ .L3
  40+ 5ED1 22 40 63     			LD (TILETMP2), HL
  41+ 5ED4 2A 3E 63     			LD HL, (TILETMP1)
  42+ 5ED7 DD 5E 08     			LD E, (IX+8)
  43+ 5EDA DD 56 09     			LD D, (IX+9) ; add to value for dest next row
  44+ 5EDD 19           			ADD HL, DE
  45+ 5EDE 22 3E 63     			LD (TILETMP1), HL
  46+ 5EE1 C1           		POP BC
  47+ 5EE2 10 D5        		DJNZ .L2
  48+ 5EE4 C1           	POP BC
  49+ 5EE5 10 C5        	DJNZ .L1
  50+ 5EE7 C9           	RET
  51+ 5EE8              ; *******************************************************************************************************
  52+ 5EE8
  53+ 5EE8               IF (0 == 1)
  54+ 5EE8 ~            ; *******************************************************************************************************
  55+ 5EE8 ~            ; same as TILERAM but for DEFUSR approach
  56+ 5EE8 ~            ; input IX=pointer to input array, real data from +2
  57+ 5EE8 ~            ; +02 = tile data pointer
  58+ 5EE8 ~            ; +04 = tile columns
  59+ 5EE8 ~            ; +06 = tile rows
  60+ 5EE8 ~            ; +08 = destination pointer
  61+ 5EE8 ~            ; +10 = destination columns
  62+ 5EE8 ~            ; +12 = destination rows
  63+ 5EE8 ~            ; +14 = destination begin column
  64+ 5EE8 ~            ; +16 = destination begin row
  65+ 5EE8 ~            ; +18 = number of tiles horizontally
  66+ 5EE8 ~            ; +20 = number of tiles vertically
  67+ 5EE8 ~            ; *******************************************************************************************************
  68+ 5EE8 ~            TILERAM_DEFUSR:
  69+ 5EE8 ~            	; tile data pointer
  70+ 5EE8 ~            	LD L,(IX+2)
  71+ 5EE8 ~            	LD H,(IX+3)
  72+ 5EE8 ~            	LD (BLIT_STRUCT+0),HL
  73+ 5EE8 ~            	; tile columns
  74+ 5EE8 ~            	LD L,(IX+4)
  75+ 5EE8 ~            	LD H,(IX+5)
  76+ 5EE8 ~            	LD (BLIT_STRUCT+4),HL
  77+ 5EE8 ~            	; tile rows
  78+ 5EE8 ~            	LD L,(IX+6)
  79+ 5EE8 ~            	LD H,(IX+7)
  80+ 5EE8 ~            	LD (BLIT_STRUCT+2),HL
  81+ 5EE8 ~            	; destintion pointer
  82+ 5EE8 ~            	LD L,(IX+8)
  83+ 5EE8 ~            	LD H,(IX+9)
  84+ 5EE8 ~            	LD (BLIT_STRUCT+6),HL
  85+ 5EE8 ~            	; destination columns
  86+ 5EE8 ~            	LD A,(IX+10)
  87+ 5EE8 ~            	LD (BLIT_TMP+0),A
  88+ 5EE8 ~            	; destination rows
  89+ 5EE8 ~            	LD A,(IX+12)
  90+ 5EE8 ~            	LD (BLIT_TMP+1),A
  91+ 5EE8 ~            	; destination begin column
  92+ 5EE8 ~            	LD A,(IX+14)
  93+ 5EE8 ~            	LD (BLIT_TMP+2),A
  94+ 5EE8 ~            	; destination begin row
  95+ 5EE8 ~            	LD A,(IX+16)
  96+ 5EE8 ~            	LD (BLIT_TMP+3),A
  97+ 5EE8 ~            	; number of tiles horizontally
  98+ 5EE8 ~            	LD L,(IX+18)
  99+ 5EE8 ~            	LD H,(IX+19)
 100+ 5EE8 ~            	LD (BLIT_STRUCT+10),HL
 101+ 5EE8 ~            	; number of tiles vertically
 102+ 5EE8 ~            	LD L,(IX+20)
 103+ 5EE8 ~            	LD H,(IX+21)
 104+ 5EE8 ~            	LD (BLIT_STRUCT+12),HL
 105+ 5EE8 ~             IF (BASIC_EXTENSION == 1) ; otherwise we just continue with code below
 106+ 5EE8 ~            	JP TILERAM.COMMON
 107+ 5EE8 ~             ENDIF
 108+ 5EE8               ENDIF
 109+ 5EE8
 110+ 5EE8              ; *******************************************************************************************************
 111+ 5EE8              ; function to handle CALL TILERAM basic extension
 112+ 5EE8              ; fills memory with tiles
 113+ 5EE8              ; TILERAM ( INT tile_data_pointer,
 114+ 5EE8              ;			INT tile_columns,
 115+ 5EE8              ;			INT tile_rows,
 116+ 5EE8              ;			INT destination_pointer,
 117+ 5EE8              ;			INT destination_columns,
 118+ 5EE8              ;			INT destination_rows,
 119+ 5EE8              ;			INT destination_begin_column,
 120+ 5EE8              ;			INT destination_begin_row,
 121+ 5EE8              ;			INT number_of_tiles_horizontally,
 122+ 5EE8              ;			INT	number_of_tiles_vertically )
 123+ 5EE8              ; will put ram in page 0 also, page 1 is already there
 124+ 5EE8              TILERAM:
 125+ 5EE8               IF (1 == 1)
 126+ 5EE8              	; opening (
 127+ 5EE8 CD 67 66     	CALL CHKCHAR
 128+ 5EEB 28           	DB '('
 129+ 5EEC              	; get tile data pointer coordinate
 130+ 5EEC DD 21 2F 54  	LD IX, FRMQNT
 131+ 5EF0 CD 59 01     	CALL CALBAS
 132+ 5EF3 ED 53 42 63  	LD (BLIT_STRUCT+0), DE
 133+ 5EF7              	; comma
 134+ 5EF7 CD 67 66     	CALL CHKCHAR
 135+ 5EFA 2C           	DB ','
 136+ 5EFB              	; get tile columns
 137+ 5EFB DD 21 2F 54  	LD IX, FRMQNT
 138+ 5EFF CD 59 01     	CALL CALBAS
 139+ 5F02 ED 53 46 63  	LD (BLIT_STRUCT+4), DE
 140+ 5F06              	; comma
 141+ 5F06 CD 67 66     	CALL CHKCHAR
 142+ 5F09 2C           	DB ','
 143+ 5F0A              	; get tile columns
 144+ 5F0A DD 21 2F 54  	LD IX, FRMQNT
 145+ 5F0E CD 59 01     	CALL CALBAS
 146+ 5F11 ED 53 44 63  	LD (BLIT_STRUCT+2), DE
 147+ 5F15              	; comma
 148+ 5F15 CD 67 66     	CALL CHKCHAR
 149+ 5F18 2C           	DB ','
 150+ 5F19              	; get destintion pointer
 151+ 5F19 DD 21 2F 54  	LD IX, FRMQNT
 152+ 5F1D CD 59 01     	CALL CALBAS
 153+ 5F20 ED 53 48 63  	LD (BLIT_STRUCT+6), DE
 154+ 5F24              	; comma
 155+ 5F24 CD 67 66     	CALL CHKCHAR
 156+ 5F27 2C           	DB ','
 157+ 5F28              	; get destination columns
 158+ 5F28 DD 21 2F 54  	LD IX, FRMQNT
 159+ 5F2C CD 59 01     	CALL CALBAS
 160+ 5F2F 7B           	LD A, E
 161+ 5F30 32 3E 63     	LD (BLIT_TMP+0), A
 162+ 5F33              	; comma
 163+ 5F33 CD 67 66     	CALL CHKCHAR
 164+ 5F36 2C           	DB ','
 165+ 5F37              	; get destination rows
 166+ 5F37 DD 21 2F 54  	LD IX, FRMQNT
 167+ 5F3B CD 59 01     	CALL CALBAS
 168+ 5F3E 7B           	LD A, E
 169+ 5F3F 32 3F 63     	LD (BLIT_TMP+1), A
 170+ 5F42              	; comma
 171+ 5F42 CD 67 66     	CALL CHKCHAR
 172+ 5F45 2C           	DB ','
 173+ 5F46              	; get destination begin column
 174+ 5F46 DD 21 2F 54  	LD IX, FRMQNT
 175+ 5F4A CD 59 01     	CALL CALBAS
 176+ 5F4D 7B           	LD A, E
 177+ 5F4E 32 40 63     	LD (BLIT_TMP+2), A
 178+ 5F51              	; comma
 179+ 5F51 CD 67 66     	CALL CHKCHAR
 180+ 5F54 2C           	DB ','
 181+ 5F55              	; get destination begin row
 182+ 5F55 DD 21 2F 54  	LD IX, FRMQNT
 183+ 5F59 CD 59 01     	CALL CALBAS
 184+ 5F5C 7B           	LD A, E
 185+ 5F5D 32 41 63     	LD (BLIT_TMP+3), A
 186+ 5F60              	; comma
 187+ 5F60 CD 67 66     	CALL CHKCHAR
 188+ 5F63 2C           	DB ','
 189+ 5F64              	; get number of tiles horizontally
 190+ 5F64 DD 21 2F 54  	LD IX, FRMQNT
 191+ 5F68 CD 59 01     	CALL CALBAS
 192+ 5F6B ED 53 4C 63  	LD (BLIT_STRUCT+10), DE
 193+ 5F6F              	; comma
 194+ 5F6F CD 67 66     	CALL CHKCHAR
 195+ 5F72 2C           	DB ','
 196+ 5F73              	; get number of tiles vertically
 197+ 5F73 DD 21 2F 54  	LD IX, FRMQNT
 198+ 5F77 CD 59 01     	CALL CALBAS
 199+ 5F7A ED 53 4E 63  	LD (BLIT_STRUCT+12), DE
 200+ 5F7E              	; ending )
 201+ 5F7E CD 67 66     	CALL CHKCHAR
 202+ 5F81 29           	DB ')'
 203+ 5F82               ENDIF
 204+ 5F82              .COMMON:
 205+ 5F82 E5           	PUSH HL ; save position in BASIC buffer
 206+ 5F83
 207+ 5F83              	; calculate destination add to value
 208+ 5F83 26 00        	LD H, 0
 209+ 5F85 3A 3E 63     	LD A, (BLIT_TMP+0)
 210+ 5F88 6F           	LD L, A
 211+ 5F89 CD 54 65     	CALL HLx8
 212+ 5F8C 22 4A 63     	LD (BLIT_STRUCT+8), HL
 213+ 5F8F              	; calculate pointer to background location
 214+ 5F8F 21 00 00     	LD HL, 0
 215+ 5F92 3A 41 63     	LD A,(BLIT_TMP+3)
 216+ 5F95 B7           	OR A
 217+ 5F96 28 08        	JR Z, .L1
 218+ 5F98 47           	LD B,A
 219+ 5F99 ED 5B 4A 63  	LD DE,(BLIT_STRUCT+8)
 220+ 5F9D              .L0:
 221+ 5F9D 19           	ADD HL, DE
 222+ 5F9E 10 FD        	DJNZ .L0
 223+ 5FA0              .L1:
 224+ 5FA0 EB           	EX DE,HL
 225+ 5FA1 26 00        	LD H,0
 226+ 5FA3 3A 40 63     	LD A,(BLIT_TMP+2)
 227+ 5FA6 6F           	LD L,A
 228+ 5FA7 CD 54 65     	CALL HLx8
 229+ 5FAA 19           	ADD HL,DE
 230+ 5FAB ED 5B 48 63  	LD DE,(BLIT_STRUCT+6)
 231+ 5FAF 19           	ADD HL,DE
 232+ 5FB0 22 48 63     	LD (BLIT_STRUCT+6),HL
 233+ 5FB3 FD 21 BA 5F  	LD IY, .RET
 234+ 5FB7 C3 18 66     	JP ENABLE_PAGE0
 235+ 5FBA              .RET:
 236+ 5FBA FB           	EI
 237+ 5FBB              	; set RAM functions to call
 238+ 5FBB 21 D5 5F     	LD HL, .TILECOPY
 239+ 5FBE 22 C9 5E     	LD (TILE.CALL2+1), HL
 240+ 5FC1 21 E6 5F     	LD HL, .SETDESTROW
 241+ 5FC4 22 BB 5E     	LD (TILE.CALL1+1), HL
 242+ 5FC7 DD 21 42 63  	LD IX,BLIT_STRUCT
 243+ 5FCB CD A0 5E     	CALL TILE
 244+ 5FCE
 245+ 5FCE D1               POP DE
 246+ 5FCF C1               POP BC
 247+ 5FD0 CD 8F 65         CALL RESTORE_PAGE_INFO
 248+ 5FD3
 249+ 5FD3 E1           	POP HL
 250+ 5FD4 C9           	RET
 251+ 5FD5              .TILECOPY:
 252+ 5FD5 ED A0       > LDI
 252+ 5FD7 ED A0       > LDI
 252+ 5FD9 ED A0       > LDI
 252+ 5FDB ED A0       > LDI
 252+ 5FDD ED A0       > LDI
 252+ 5FDF ED A0       > LDI
 252+ 5FE1 ED A0       > LDI
 252+ 5FE3 ED A0       > LDI
 253+ 5FE5 C9           	RET
 254+ 5FE6              .SETDESTROW:
 255+ 5FE6 ED 5B 3E 63  	LD DE, (TILETMP1)
 256+ 5FEA C9           	RET
 257+ 5FEB              ; *******************************************************************************************************
 258+ 5FEB
 259+ 5FEB               IF (0 == 1)
 260+ 5FEB ~            ; *******************************************************************************************************
 261+ 5FEB ~            ; same as TILEVRM but for DEFUSR approach
 262+ 5FEB ~            ; input IX=pointer to input array, real data from +2
 263+ 5FEB ~            ; +02 = tile data pointer
 264+ 5FEB ~            ; +04 = tile columns
 265+ 5FEB ~            ; +06 = tile rows
 266+ 5FEB ~            ; +08 = destination begin column
 267+ 5FEB ~            ; +10 = destination begin row
 268+ 5FEB ~            ; +12 = number of tiles horizontally
 269+ 5FEB ~            ; +14 = number of tiles vertically
 270+ 5FEB ~            ; *******************************************************************************************************
 271+ 5FEB ~            TILEVRM_DEFUSR:
 272+ 5FEB ~            	; tile data pointer
 273+ 5FEB ~            	LD L,(IX+2)
 274+ 5FEB ~            	LD H,(IX+3)
 275+ 5FEB ~            	LD (BLIT_STRUCT+0),HL
 276+ 5FEB ~            	; tile columns
 277+ 5FEB ~            	LD L,(IX+4)
 278+ 5FEB ~            	LD H,(IX+5)
 279+ 5FEB ~            	LD (BLIT_STRUCT+4),HL
 280+ 5FEB ~            	; tile rows
 281+ 5FEB ~            	LD L,(IX+6)
 282+ 5FEB ~            	LD H,(IX+7)
 283+ 5FEB ~            	LD (BLIT_STRUCT+2),HL
 284+ 5FEB ~            	; destination begin column
 285+ 5FEB ~            	LD A,(IX+8)
 286+ 5FEB ~            	LD (BLIT_TMP+2),A
 287+ 5FEB ~            	; destination begin row
 288+ 5FEB ~            	LD A,(IX+10)
 289+ 5FEB ~            	LD (BLIT_TMP+3),A
 290+ 5FEB ~            	; number of tiles horizontally
 291+ 5FEB ~            	LD L,(IX+12)
 292+ 5FEB ~            	LD H,(IX+13)
 293+ 5FEB ~            	LD (BLIT_STRUCT+10),HL
 294+ 5FEB ~            	; number of tiles vertically
 295+ 5FEB ~            	LD L,(IX+14)
 296+ 5FEB ~            	LD H,(IX+15)
 297+ 5FEB ~            	LD (BLIT_STRUCT+12),HL
 298+ 5FEB ~             IF (BASIC_EXTENSION == 1) ; otherwise we just continue with code below
 299+ 5FEB ~            	JP TILEVRM.COMMON
 300+ 5FEB ~             ENDIF
 301+ 5FEB               ENDIF
 302+ 5FEB
 303+ 5FEB              ; *******************************************************************************************************
 304+ 5FEB              ; function to handle CALL TILEVRM basic extension
 305+ 5FEB              ; fills vram with tiles
 306+ 5FEB              ; TILEVRM ( INT tile_data_pointer,
 307+ 5FEB              ;			INT tile_columns,
 308+ 5FEB              ;			INT tile_rows,
 309+ 5FEB              ;			INT destination_begin_column,
 310+ 5FEB              ;			INT destination_begin_row,
 311+ 5FEB              ;			INT number_of_tiles_horizontally,
 312+ 5FEB              ;			INT	number_of_tiles_vertically )
 313+ 5FEB              ; will put ram in page 0 also, page 1 is already there
 314+ 5FEB              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
 315+ 5FEB              TILEVRM:
 316+ 5FEB               IF (1 == 1)
 317+ 5FEB              	; opening (
 318+ 5FEB CD 67 66     	CALL CHKCHAR
 319+ 5FEE 28           	DB '('
 320+ 5FEF              	; get tile data pointer coordinate
 321+ 5FEF DD 21 2F 54  	LD IX, FRMQNT
 322+ 5FF3 CD 59 01     	CALL CALBAS
 323+ 5FF6 ED 53 42 63  	LD (BLIT_STRUCT+0), DE
 324+ 5FFA              	; comma
 325+ 5FFA CD 67 66     	CALL CHKCHAR
 326+ 5FFD 2C           	DB ','
 327+ 5FFE              	; get tile columns
 328+ 5FFE DD 21 2F 54  	LD IX, FRMQNT
 329+ 6002 CD 59 01     	CALL CALBAS
 330+ 6005 ED 53 46 63  	LD (BLIT_STRUCT+4), DE
 331+ 6009              	; comma
 332+ 6009 CD 67 66     	CALL CHKCHAR
 333+ 600C 2C           	DB ','
 334+ 600D              	; get tile columns
 335+ 600D DD 21 2F 54  	LD IX, FRMQNT
 336+ 6011 CD 59 01     	CALL CALBAS
 337+ 6014 ED 53 44 63  	LD (BLIT_STRUCT+2), DE
 338+ 6018              	; comma
 339+ 6018 CD 67 66     	CALL CHKCHAR
 340+ 601B 2C           	DB ','
 341+ 601C              	; get destination begin column
 342+ 601C DD 21 2F 54  	LD IX, FRMQNT
 343+ 6020 CD 59 01     	CALL CALBAS
 344+ 6023 7B           	LD A, E
 345+ 6024 32 40 63     	LD (BLIT_TMP+2), A
 346+ 6027              	; comma
 347+ 6027 CD 67 66     	CALL CHKCHAR
 348+ 602A 2C           	DB ','
 349+ 602B              	; get destination begin row
 350+ 602B DD 21 2F 54  	LD IX, FRMQNT
 351+ 602F CD 59 01     	CALL CALBAS
 352+ 6032 7B           	LD A, E
 353+ 6033 32 41 63     	LD (BLIT_TMP+3), A
 354+ 6036              	; comma
 355+ 6036 CD 67 66     	CALL CHKCHAR
 356+ 6039 2C           	DB ','
 357+ 603A              	; get number of tiles horizontally
 358+ 603A DD 21 2F 54  	LD IX, FRMQNT
 359+ 603E CD 59 01     	CALL CALBAS
 360+ 6041 ED 53 4C 63  	LD (BLIT_STRUCT+10), DE
 361+ 6045              	; comma
 362+ 6045 CD 67 66     	CALL CHKCHAR
 363+ 6048 2C           	DB ','
 364+ 6049              	; get number of tiles vertically
 365+ 6049 DD 21 2F 54  	LD IX, FRMQNT
 366+ 604D CD 59 01     	CALL CALBAS
 367+ 6050 ED 53 4E 63  	LD (BLIT_STRUCT+12), DE
 368+ 6054              	; ending )
 369+ 6054 CD 67 66     	CALL CHKCHAR
 370+ 6057 29           	DB ')'
 371+ 6058               ENDIF
 372+ 6058
 373+ 6058              .COMMON:
 374+ 6058 E5           	PUSH HL ; save position in BASIC buffer
 375+ 6059
 376+ 6059              	; calculate destination add to value
 377+ 6059 21 00 01     	LD HL, 256
 378+ 605C 22 4A 63     	LD (BLIT_STRUCT+8), HL
 379+ 605F              	; calculate pointer to background location
 380+ 605F 3A 41 63     	LD A,(BLIT_TMP+3)
 381+ 6062 67           	LD H,A
 382+ 6063 2E 00        	LD L,0
 383+ 6065 EB           	EX DE,HL
 384+ 6066 26 00        	LD H,0
 385+ 6068 3A 40 63     	LD A,(BLIT_TMP+2)
 386+ 606B 6F           	LD L,A
 387+ 606C CD 54 65     	CALL HLx8
 388+ 606F 19           	ADD HL,DE
 389+ 6070 ED 5B CB F3  	LD DE,(GRPCGP)
 390+ 6074 19           	ADD HL,DE
 391+ 6075 22 48 63     	LD (BLIT_STRUCT+6),HL
 392+ 6078 FD 21 7F 60  	LD IY, .RET
 393+ 607C C3 18 66     	JP ENABLE_PAGE0
 394+ 607F              .RET:
 395+ 607F FB           	EI
 396+ 6080              	; set RAM functions to call
 397+ 6080 21 9A 60     	LD HL, .TILECOPY
 398+ 6083 22 C9 5E     	LD (TILE.CALL2+1), HL
 399+ 6086 21 A0 60     	LD HL, .SETDESTROW
 400+ 6089 22 BB 5E     	LD (TILE.CALL1+1), HL
 401+ 608C DD 21 42 63  	LD IX,BLIT_STRUCT
 402+ 6090 CD A0 5E     	CALL TILE
 403+ 6093
 404+ 6093 D1               POP DE
 405+ 6094 C1               POP BC
 406+ 6095 CD 8F 65         CALL RESTORE_PAGE_INFO
 407+ 6098
 408+ 6098 E1           	POP HL
 409+ 6099 C9           	RET
 410+ 609A              .TILECOPY:
 411+ 609A 01 98 08     	LD BC, #0898
 412+ 609D C3 4C 65     	JP BBYTECOPY_NO_C
 413+ 60A0              .SETDESTROW:
 414+ 60A0 2A 3E 63     	LD HL, (TILETMP1)
 415+ 60A3 F3           	DI
 416+ 60A4 CD 35 65     	CALL SETWRT_LOCAL_WRITE
 417+ 60A7 FB           	EI
 418+ 60A8 C9           	RET
 419+ 60A9              ; *******************************************************************************************************
 420+ 60A9
# file closed: asm\TILE.asm
 166  60A9               ENDIF
 167  60A9
 168  60A9               IF (COLL_CMD == 1)
 169  60A9               INCLUDE "COLLISION.asm"
# file opened: asm\COLLISION.asm
   1+ 60A9              ; generic collision checking routines
   2+ 60A9              ; in BASIC we use rectangle structure array DIM R%(7,n) of the format
   3+ 60A9              ; R%(0,n) is active flag, <>0 active / 0 skipped in checks
   4+ 60A9              ; R%(1,n) is either upper left x coordinate or sprite id (0-31) depending on R(7,n)
   5+ 60A9              ; R%(2,n) is either upper left y coordinate or unused depending on R(7,n)
   6+ 60A9              ; R%(3,n) x offset where rectangle begins
   7+ 60A9              ; R%(4,n) y offset where rectangle begins
   8+ 60A9              ; R%(5,n) is width
   9+ 60A9              ; R%(6,n) is height
  10+ 60A9              ; R%(7,0) is type, 0=generic where R%(1,0) contains x coordinate
  11+ 60A9              ;                  <>0 sprite where R%(1,0) contains sprite id
  12+ 60A9              ; for type sprite, upper left coordinates are taken from sprite attribute array
  13+ 60A9
  14+ 60A9              ; ************************************************************************************************
  15+ 60A9              ; quick test if HL<=DE<=HL+BC
  16+ 60A9              ; input BC=width, DE=x, HL=min
  17+ 60A9              ; if not true flag C set
  18+ 60A9              ; modifies AF
  19+ 60A9              GENERIC_INNER_CHECK:
  20+ 60A9 E5               PUSH HL
  21+ 60AA D5               PUSH DE
  22+ 60AB EB               EX DE,HL
  23+ 60AC A7               AND A
  24+ 60AD ED 52            SBC HL, DE
  25+ 60AF FA BD 60         JP M, .GENERIC_INNER_CHECK_NOT
  26+ 60B2 A7               AND A
  27+ 60B3 ED 42            SBC HL, BC
  28+ 60B5 28 03            JR Z, .L2
  29+ 60B7 F2 BD 60         JP P, .GENERIC_INNER_CHECK_NOT
  30+ 60BA              .L2:
  31+ 60BA A7               AND A
  32+ 60BB 18 01            JR .EXIT
  33+ 60BD              .GENERIC_INNER_CHECK_NOT:
  34+ 60BD 37               SCF
  35+ 60BE              .EXIT:
  36+ 60BE D1               POP DE
  37+ 60BF E1               POP HL
  38+ 60C0 C9               RET
  39+ 60C1              ; ************************************************************************************************
  40+ 60C1
  41+ 60C1              ; ************************************************************************************************
  42+ 60C1              ; function to check if rectangles are overlapping
  43+ 60C1              ; input IX=IY=pointer to struct
  44+ 60C1              ;  +00 active flag
  45+ 60C1              ;  +02 x coordinate
  46+ 60C1              ;  +04 y coordinate
  47+ 60C1              ;  +06 x offset where rectangle begins
  48+ 60C1              ;  +08 y offset where rectangle begins
  49+ 60C1              ;  +10 width
  50+ 60C1              ;  +12 height
  51+ 60C1              ; where IY is used to read +2 and +4, and IX to read +6, +8, +10 and +12
  52+ 60C1              ; this is a hack to allow location being taken from sprite attributes table
  53+ 60C1              ; input BLIT_STRUCT data
  54+ 60C1              ;  +00 x coordinate
  55+ 60C1              ;  +02 y coordinate
  56+ 60C1              ;  +04 width
  57+ 60C1              ;  +06 height
  58+ 60C1              ; returns CF=1 if not overlapping, CF=0 if overlapping
  59+ 60C1              RECTANGLE_OVERLAP_CHECK:
  60+ 60C1                  ; first check which rectangle is higher
  61+ 60C1 DD 6E 0C         LD L,(IX+12)
  62+ 60C4 DD 66 0D         LD H,(IX+13)
  63+ 60C7 ED 5B 48 63      LD DE,(BLIT_STRUCT+6)
  64+ 60CB A7               AND A
  65+ 60CC ED 52            SBC HL,DE
  66+ 60CE FD 6E 04         LD L,(IY+4)
  67+ 60D1 FD 66 05         LD H,(IY+5)
  68+ 60D4 DD 5E 08         LD E,(IX+8)
  69+ 60D7 DD 56 09         LD D,(IX+9)
  70+ 60DA FA FA 60         JP M,.L1
  71+ 60DD                  ; equally high or IX defined one higher
  72+ 60DD                  ; check upper boundary
  73+ 60DD 19               ADD HL,DE
  74+ 60DE ED 5B 44 63      LD DE,(BLIT_STRUCT+2)
  75+ 60E2 DD 4E 0C         LD C,(IX+12)
  76+ 60E5 DD 46 0D         LD B,(IX+13)
  77+ 60E8 CD A9 60         CALL GENERIC_INNER_CHECK
  78+ 60EB 30 29            JR NC,.INSIDE
  79+ 60ED                  ; check lower boundary
  80+ 60ED E5               PUSH HL
  81+ 60EE 2A 48 63         LD HL,(BLIT_STRUCT+6)
  82+ 60F1 19               ADD HL,DE
  83+ 60F2 EB               EX DE,HL
  84+ 60F3 E1               POP HL
  85+ 60F4 CD A9 60         CALL GENERIC_INNER_CHECK
  86+ 60F7 30 1D            JR NC,.INSIDE
  87+ 60F9 C9               RET ; not overlapping
  88+ 60FA              .L1:
  89+ 60FA                  ; rectangle defined in BLIT_STRUCT is higher
  90+ 60FA 19               ADD HL,DE
  91+ 60FB EB               EX DE,HL
  92+ 60FC 2A 44 63         LD HL,(BLIT_STRUCT+2)
  93+ 60FF ED 4B 48 63      LD BC,(BLIT_STRUCT+6)
  94+ 6103 CD A9 60         CALL GENERIC_INNER_CHECK
  95+ 6106 30 0E            JR NC,.INSIDE
  96+ 6108 E5               PUSH HL
  97+ 6109 DD 6E 0C         LD L,(IX+12)
  98+ 610C DD 66 0D         LD H,(IX+13)
  99+ 610F 19               ADD HL,DE
 100+ 6110 EB               EX DE,HL
 101+ 6111 E1               POP HL
 102+ 6112 CD A9 60         CALL GENERIC_INNER_CHECK
 103+ 6115 D8               RET C
 104+ 6116              .INSIDE:
 105+ 6116                  ; check x coordinate
 106+ 6116                  ; first check which rectangle is wider
 107+ 6116 DD 6E 0A         LD L,(IX+10)
 108+ 6119 DD 66 0B         LD H,(IX+11)
 109+ 611C ED 5B 46 63      LD DE,(BLIT_STRUCT+4)
 110+ 6120 A7               AND A
 111+ 6121 ED 52            SBC HL,DE
 112+ 6123 FD 6E 02         LD L,(IY+2)
 113+ 6126 FD 66 03         LD H,(IY+3)
 114+ 6129 DD 5E 06         LD E,(IX+6)
 115+ 612C DD 56 07         LD D,(IX+7)
 116+ 612F FA 4B 61         JP M,.L2
 117+ 6132                  ; equally wide or IX defined one wider
 118+ 6132                  ; check left boundary
 119+ 6132 19               ADD HL,DE
 120+ 6133 ED 5B 42 63      LD DE,(BLIT_STRUCT+0)
 121+ 6137 DD 4E 0A         LD C,(IX+10)
 122+ 613A DD 46 0B         LD B,(IX+11)
 123+ 613D CD A9 60         CALL GENERIC_INNER_CHECK
 124+ 6140 D0               RET NC ; overlap
 125+ 6141                  ; check right boundary
 126+ 6141 E5               PUSH HL
 127+ 6142 2A 46 63         LD HL,(BLIT_STRUCT+4)
 128+ 6145 19               ADD HL,DE
 129+ 6146 EB               EX DE,HL
 130+ 6147 E1               POP HL
 131+ 6148 C3 A9 60         JP GENERIC_INNER_CHECK ; CF and result set by fn call
 132+ 614B              .L2:
 133+ 614B                  ; rectangle defined in BLIT_STRUCT is higher
 134+ 614B 19               ADD HL,DE
 135+ 614C EB               EX DE,HL
 136+ 614D 2A 42 63         LD HL,(BLIT_STRUCT+0)
 137+ 6150 ED 4B 46 63      LD BC,(BLIT_STRUCT+4)
 138+ 6154 CD A9 60         CALL GENERIC_INNER_CHECK
 139+ 6157 D0               RET NC ; overlap
 140+ 6158 E5               PUSH HL
 141+ 6159 DD 6E 0A         LD L,(IX+10)
 142+ 615C DD 66 0B         LD H,(IX+11)
 143+ 615F 19               ADD HL,DE
 144+ 6160 EB               EX DE,HL
 145+ 6161 E1               POP HL
 146+ 6162 C3 A9 60         JP GENERIC_INNER_CHECK
 147+ 6165              ; ************************************************************************************************
 148+ 6165
 149+ 6165              ; ************************************************************************************************
 150+ 6165              ; function tries to find rectangle overlap and returns an index if found
 151+ 6165              ; input BLIT_STRUCT data
 152+ 6165              ;  +00 x coordinate
 153+ 6165              ;  +02 y coordinate
 154+ 6165              ;  +04 width
 155+ 6165              ;  +06 height
 156+ 6165              ;  +08 number of items in a list, described under RECTANGLE_OVERLAP_CHECK
 157+ 6165              ;  +09 pointer to first element of R%(7,n)
 158+ 6165              ;  +11 pointer to INT result variable
 159+ 6165              ; returns CF=1 if not overlapping
 160+ 6165              ; returns A=list index and CF=0 if overlapping
 161+ 6165              FIND_OVERLAP:
 162+ 6165 3A 4A 63         LD A,(BLIT_STRUCT+8)
 163+ 6168 47               LD B,A
 164+ 6169 DD 2A 4B 63      LD IX,(BLIT_STRUCT+9)
 165+ 616D              .L1:
 166+ 616D C5               PUSH BC
 167+ 616E                  ; check active flag
 168+ 616E DD 7E 00         LD A,(IX)
 169+ 6171 DD B6 01         OR (IX+1)
 170+ 6174 28 18            JR Z,.NEXT
 171+ 6176                  ; check type
 172+ 6176 DD 7E 0E         LD A,(IX+14)
 173+ 6179 DD B6 0F         OR (IX+15)
 174+ 617C 20 1A            JR NZ,.L2
 175+ 617E DD E5            PUSH IX
 176+ 6180 FD E1            POP IY
 177+ 6182              .L3:
 178+ 6182 CD C1 60         CALL RECTANGLE_OVERLAP_CHECK
 179+ 6185 38 07            JR C,.NEXT
 180+ 6187                  ; found
 181+ 6187 C1               POP BC
 182+ 6188 3A 4A 63         LD A,(BLIT_STRUCT+8)
 183+ 618B 90               SUB B
 184+ 618C A7               AND A
 185+ 618D C9               RET
 186+ 618E              .NEXT:
 187+ 618E 11 10 00         LD DE,16
 188+ 6191 DD 19            ADD IX,DE
 189+ 6193 C1               POP BC
 190+ 6194 10 D7            DJNZ .L1
 191+ 6196 37               SCF
 192+ 6197 C9               RET
 193+ 6198              .L2:
 194+ 6198                  ; sprite, need to build a temporary data struct since x and y values are inversed
 195+ 6198                  ; at BLIT_STRUCT+13
 196+ 6198 DD 7E 02         LD A,(IX+2) ; sprite ID
 197+ 619B CD 89 4D         CALL GETnthSPRATTR
 198+ 619E FD 21 4D 63      LD IY,BLIT_STRUCT+11
 199+ 61A2 7E               LD A,(HL)
 200+ 61A3 FD 77 04         LD (IY+4),A
 201+ 61A6 23               INC HL
 202+ 61A7 7E               LD A,(HL)
 203+ 61A8 FD 77 05         LD (IY+5),A
 204+ 61AB 23               INC HL
 205+ 61AC 7E               LD A,(HL)
 206+ 61AD FD 77 02         LD (IY+2),A
 207+ 61B0 23               INC HL
 208+ 61B1 7E               LD A,(HL)
 209+ 61B2 FD 77 03         LD (IY+3),A
 210+ 61B5 18 CB            JR .L3
 211+ 61B7              ; ************************************************************************************************
 212+ 61B7
 213+ 61B7               IF (1 == 1)
 214+ 61B7              ; ************************************************************************************************
 215+ 61B7              ; function to handle CALL COLL basic extension
 216+ 61B7              ; checks for collision between player and other rectangles
 217+ 61B7              ; COLL ( INT result variable,
 218+ 61B7              ;	     INT player x value,
 219+ 61B7              ;	     INT player y value,
 220+ 61B7              ;	     INT player width,
 221+ 61B7              ;	     INT player height,
 222+ 61B7              ;	     INT number of items in a list,
 223+ 61B7              ;		 INT[6][n] rectangle struct )
 224+ 61B7              ; will fill result variable with index or -1 if no collision
 225+ 61B7              ; rectangle struct described under RECTANGLE_OVERLAP_CHECK
 226+ 61B7              COLL:
 227+ 61B7              	; opening (
 228+ 61B7 CD 67 66     	CALL CHKCHAR
 229+ 61BA 28           	DB '('
 230+ 61BB              	; get address of result variable
 231+ 61BB DD 21 A4 5E  	LD IX, PTRGET
 232+ 61BF CD 59 01     	CALL CALBAS
 233+ 61C2 ED 53 4D 63  	LD (BLIT_STRUCT+11),DE
 234+ 61C6              	; comma
 235+ 61C6 CD 67 66     	CALL CHKCHAR
 236+ 61C9 2C           	DB ','
 237+ 61CA              	; get x
 238+ 61CA DD 21 2F 54  	LD IX, FRMQNT
 239+ 61CE CD 59 01     	CALL CALBAS
 240+ 61D1 ED 53 42 63  	LD (BLIT_STRUCT+0),DE
 241+ 61D5              	; comma
 242+ 61D5 CD 67 66     	CALL CHKCHAR
 243+ 61D8 2C           	DB ','
 244+ 61D9              	; get y
 245+ 61D9 DD 21 2F 54  	LD IX, FRMQNT
 246+ 61DD CD 59 01     	CALL CALBAS
 247+ 61E0 ED 53 44 63  	LD (BLIT_STRUCT+2),DE
 248+ 61E4              	; comma
 249+ 61E4 CD 67 66     	CALL CHKCHAR
 250+ 61E7 2C           	DB ','
 251+ 61E8              	; get width
 252+ 61E8 DD 21 2F 54  	LD IX, FRMQNT
 253+ 61EC CD 59 01     	CALL CALBAS
 254+ 61EF ED 53 46 63  	LD (BLIT_STRUCT+4),DE
 255+ 61F3              	; comma
 256+ 61F3 CD 67 66     	CALL CHKCHAR
 257+ 61F6 2C           	DB ','
 258+ 61F7              	; get height
 259+ 61F7 DD 21 2F 54  	LD IX, FRMQNT
 260+ 61FB CD 59 01     	CALL CALBAS
 261+ 61FE ED 53 48 63  	LD (BLIT_STRUCT+6),DE
 262+ 6202              	; comma
 263+ 6202 CD 67 66     	CALL CHKCHAR
 264+ 6205 2C           	DB ','
 265+ 6206              	; get number of items in a list
 266+ 6206 DD 21 1C 52  	LD IX, GETBYT
 267+ 620A CD 59 01     	CALL CALBAS
 268+ 620D 32 4A 63     	LD (BLIT_STRUCT+8),A
 269+ 6210              	; comma
 270+ 6210 CD 67 66     	CALL CHKCHAR
 271+ 6213 2C           	DB ','
 272+ 6214              	; get address of rectangle structure array DIM R%(7,n)
 273+ 6214 3A 4A 63     	LD A,(BLIT_STRUCT+8)
 274+ 6217 5F               LD E,A
 275+ 6218 3E 02            LD A,2
 276+ 621A 47           	LD B,A
 277+ 621B 16 07        	LD D,7
 278+ 621D CD C0 66     	CALL GET_BASIC_ARRAY_DATA_POINTER
 279+ 6220 ED 43 4B 63  	LD (BLIT_STRUCT+9),BC
 280+ 6224              	; ending )
 281+ 6224 CD 67 66     	CALL CHKCHAR
 282+ 6227 29           	DB ')'
 283+ 6228
 284+ 6228 E5               PUSH HL
 285+ 6229 CD 65 61         CALL FIND_OVERLAP
 286+ 622C 2A 4D 63         LD HL,(BLIT_STRUCT+11)
 287+ 622F 38 06            JR C,.NOTFOUND
 288+ 6231 77               LD (HL),A
 289+ 6232 23               INC HL
 290+ 6233 36 00            LD (HL),0
 291+ 6235 E1               POP HL
 292+ 6236 C9               RET
 293+ 6237              .NOTFOUND:
 294+ 6237 36 FF            LD (HL),#FF
 295+ 6239 23               INC HL
 296+ 623A 36 FF            LD (HL),#FF
 297+ 623C E1               POP HL
 298+ 623D C9               RET
 299+ 623E              ; ************************************************************************************************
 300+ 623E               ENDIF
 301+ 623E
 302+ 623E               IF (0 == 1)
 303+ 623E ~            ; *******************************************************************************************************
 304+ 623E ~            ; same as COLL but for DEFUSR approach
 305+ 623E ~            ; input IX=pointer to input array, real data from +2
 306+ 623E ~            ; +02 = pointer to result variable
 307+ 623E ~            ; +04 = player X
 308+ 623E ~            ; +06 = player Y
 309+ 623E ~            ; +08 = player width
 310+ 623E ~            ; +10 = player height
 311+ 623E ~            ; +12 = number of list items
 312+ 623E ~            ; +14 = pointer to list of collidable objects
 313+ 623E ~            COLL_DEFUSR:
 314+ 623E ~                PUSH IX
 315+ 623E ~                POP HL
 316+ 623E ~                .4 INC HL ; skip over to player x
 317+ 623E ~                LD DE,BLIT_STRUCT
 318+ 623E ~                LD BC,9
 319+ 623E ~                LDIR ; copy over x,y,w,h,list item number
 320+ 623E ~                LD A,(IX+14)
 321+ 623E ~                LD (BLIT_STRUCT+9),A
 322+ 623E ~                LD A,(IX+15)
 323+ 623E ~                LD (BLIT_STRUCT+10),A ; address to collidable objects array
 324+ 623E ~                LD A,(IX+2)
 325+ 623E ~                LD (BLIT_STRUCT+11),A
 326+ 623E ~                LD A,(IX+3)
 327+ 623E ~                LD (BLIT_STRUCT+12),A ; address to results variable
 328+ 623E ~                PUSH IX
 329+ 623E ~                CALL FIND_OVERLAP
 330+ 623E ~                POP IX
 331+ 623E ~                LD L,(IX+2)
 332+ 623E ~                LD H,(IX+3)
 333+ 623E ~                JR C,.NOTFOUND
 334+ 623E ~                LD (HL),A
 335+ 623E ~                INC HL
 336+ 623E ~                LD (HL),0
 337+ 623E ~                RET
 338+ 623E ~            .NOTFOUND:
 339+ 623E ~                LD (HL),#FF
 340+ 623E ~                INC HL
 341+ 623E ~                LD (HL),#FF
 342+ 623E ~                RET
 343+ 623E ~            ; *******************************************************************************************************
 344+ 623E               ENDIF
 345+ 623E
# file closed: asm\COLLISION.asm
 170  623E               ENDIF
 171  623E
 172  623E               IF (DECOMP_CMDS == 1)
 173  623E               INCLUDE "decomp.asm"
# file opened: asm\decomp.asm
   1+ 623E              ; -----------------------------------------------------------------------------
   2+ 623E              ; ZX0 decoder by Einar Saukas & Urusergi
   3+ 623E              ; "Standard" version (68 bytes only)
   4+ 623E              ; -----------------------------------------------------------------------------
   5+ 623E              ; Parameters:
   6+ 623E              ;   HL: source address (compressed data)
   7+ 623E              ;   DE: destination address (decompressing)
   8+ 623E              ; -----------------------------------------------------------------------------
   9+ 623E
  10+ 623E              dzx0_standard:
  11+ 623E 01 FF FF             ld      bc, $ffff               ; preserve default offset 1
  12+ 6241 C5                   push    bc
  13+ 6242 03                   inc     bc
  14+ 6243 3E 80                ld      a, $80
  15+ 6245              dzx0s_literals:
  16+ 6245 CD 75 62             call    dzx0s_elias             ; obtain length
  17+ 6248              dzx0_ldir_1:
  18+ 6248 ED B0                ldir                            ; copy literals
  19+ 624A 00                   nop                             ; placeholder for call
  20+ 624B 87                   add     a, a                    ; copy from last offset or new offset?
  21+ 624C 38 0E                jr      c, dzx0s_new_offset
  22+ 624E CD 75 62             call    dzx0s_elias             ; obtain length
  23+ 6251              dzx0s_copy:
  24+ 6251 E3                   ex      (sp), hl                ; preserve source, restore offset
  25+ 6252 E5                   push    hl                      ; preserve offset
  26+ 6253 19                   add     hl, de                  ; calculate destination - offset
  27+ 6254              dzx0_ldir_2:
  28+ 6254 ED B0                ldir                            ; copy from offset
  29+ 6256 00                   nop                             ; placeholder for call
  30+ 6257 E1                   pop     hl                      ; restore offset
  31+ 6258 E3                   ex      (sp), hl                ; preserve offset, restore source
  32+ 6259 87                   add     a, a                    ; copy from literals or new offset?
  33+ 625A 30 E9                jr      nc, dzx0s_literals
  34+ 625C              dzx0s_new_offset:
  35+ 625C C1                   pop     bc                      ; discard last offset
  36+ 625D 0E FE                ld      c, $fe                  ; prepare negative offset
  37+ 625F CD 76 62             call    dzx0s_elias_loop        ; obtain offset MSB
  38+ 6262 0C                   inc     c
  39+ 6263 C8                   ret     z                       ; check end marker
  40+ 6264 41                   ld      b, c
  41+ 6265 4E                   ld      c, (hl)                 ; obtain offset LSB
  42+ 6266 23                   inc     hl
  43+ 6267 CB 18                rr      b                       ; last offset bit becomes first length bit
  44+ 6269 CB 19                rr      c
  45+ 626B C5                   push    bc                      ; preserve new offset
  46+ 626C 01 01 00             ld      bc, 1                   ; obtain length
  47+ 626F D4 7D 62             call    nc, dzx0s_elias_backtrack
  48+ 6272 03                   inc     bc
  49+ 6273 18 DC                jr      dzx0s_copy
  50+ 6275              dzx0s_elias:
  51+ 6275 0C                   inc     c                       ; interlaced Elias gamma coding
  52+ 6276              dzx0s_elias_loop:
  53+ 6276 87                   add     a, a
  54+ 6277 20 03                jr      nz, dzx0s_elias_skip
  55+ 6279 7E                   ld      a, (hl)                 ; load another group of 8 bits
  56+ 627A 23                   inc     hl
  57+ 627B 17                   rla
  58+ 627C              dzx0s_elias_skip:
  59+ 627C D8                   ret     c
  60+ 627D              dzx0s_elias_backtrack:
  61+ 627D 87                   add     a, a
  62+ 627E CB 11                rl      c
  63+ 6280 CB 10                rl      b
  64+ 6282 18 F2                jr      dzx0s_elias_loop
  65+ 6284              ; -----------------------------------------------------------------------------
  66+ 6284
  67+ 6284              ; *******************************************************************************************************
  68+ 6284              ; helper function for VRAM unpack to save AF prior to calling copy to VRAM fn
  69+ 6284              ; also simulates register states as if LDIR was called
  70+ 6284              LDIR_TO_VRAM:
  71+ 6284 F5                   PUSH AF ; save AF used by algorithm
  72+ 6285 D5                   PUSH DE
  73+ 6286 C5                   PUSH BC
  74+ 6287 CD 57 5A             CALL VRAM_LDIRVM
  75+ 628A C1                   POP BC
  76+ 628B EB                   EX DE,HL
  77+ 628C E1                   POP HL
  78+ 628D 09                   ADD HL,BC
  79+ 628E EB                   EX DE,HL
  80+ 628F 01 00 00             LD BC,0
  81+ 6292 F1                   POP AF
  82+ 6293 C9                   RET
  83+ 6294              ; *******************************************************************************************************
  84+ 6294
  85+ 6294              ; *******************************************************************************************************
  86+ 6294              ; helper function to get a byte from VRAM address at HL and place it at DE also in VRAM
  87+ 6294              VPOKE_VPEEK:
  88+ 6294 F3                   DI
  89+ 6295 CD 40 65             CALL SETWRT_LOCAL_READ
  90+ 6298 E3                   EX (SP),HL
  91+ 6299 E3                   EX (SP),HL
  92+ 629A DB 98                IN A,(#98)
  93+ 629C                      ;IN A,(#98) ; WHY IS THIS NEEDED ?
  94+ 629C F5                   PUSH AF
  95+ 629D EB                   EX DE,HL
  96+ 629E CD 35 65             CALL SETWRT_LOCAL_WRITE
  97+ 62A1 E3                   EX (SP),HL
  98+ 62A2 E3                   EX (SP),HL
  99+ 62A3 EB                   EX DE,HL
 100+ 62A4 F1                   POP AF
 101+ 62A5 D3 98                OUT (#98),A
 102+ 62A7 FB                   EI
 103+ 62A8 C9                   RET
 104+ 62A9              ; *******************************************************************************************************
 105+ 62A9
 106+ 62A9              ; *******************************************************************************************************
 107+ 62A9              ; helper fn VRAM variant of LDIR
 108+ 62A9              ; input HL = source, DE = destination, BC = count
 109+ 62A9              VRAM_LDIR:
 110+ 62A9 F5                   PUSH AF
 111+ 62AA              _L0:
 112+ 62AA CD 94 62             CALL VPOKE_VPEEK
 113+ 62AD 23                   INC HL
 114+ 62AE 13                   INC DE
 115+ 62AF 0B                   DEC BC
 116+ 62B0 78                   LD A, B
 117+ 62B1 B1                   OR C
 118+ 62B2 20 F6                JR NZ, _L0
 119+ 62B4 F1                   POP AF
 120+ 62B5 C9                   RET
 121+ 62B6              ; *******************************************************************************************************
 122+ 62B6
 123+ 62B6               IF (1 == 1)
 124+ 62B6              ; *******************************************************************************************************
 125+ 62B6              ; function to handle CALL VUNPACK basic extension
 126+ 62B6              ; _VUNPACK ( INT source,
 127+ 62B6              ;			 INT destination )
 128+ 62B6              ; will put ram in page 0 also, page 1 is already there
 129+ 62B6              ; *******************************************************************************************************
 130+ 62B6              VUNPACK:
 131+ 62B6 3E CD            LD A, #CD ; CALL
 132+ 62B8 32 48 62         LD (dzx0_ldir_1), A
 133+ 62BB 32 54 62         LD (dzx0_ldir_2), A
 134+ 62BE 11 84 62         LD DE, LDIR_TO_VRAM
 135+ 62C1 ED 53 49 62      LD (dzx0_ldir_1 + 1), DE
 136+ 62C5 11 A9 62         LD DE, VRAM_LDIR
 137+ 62C8 ED 53 55 62      LD (dzx0_ldir_2 + 1), DE
 138+ 62CC 18 12            JR UNPACK_COMMON
 139+ 62CE              ; function to handle CALL UNPACK basic extension
 140+ 62CE              ; _UNPACK ( INT source,
 141+ 62CE              ;			INT destination )
 142+ 62CE              ; will put ram in page 0 also, page 1 is already there
 143+ 62CE              UNPACK:
 144+ 62CE 11 ED B0         LD DE, #B0ED ; LDIR
 145+ 62D1 ED 53 48 62      LD (dzx0_ldir_1), DE
 146+ 62D5 ED 53 54 62      LD (dzx0_ldir_2), DE
 147+ 62D9 AF               XOR A ; NOP
 148+ 62DA 32 4A 62         LD (dzx0_ldir_1 + 2), A
 149+ 62DD 32 56 62         LD (dzx0_ldir_2 + 2), A
 150+ 62E0              UNPACK_COMMON:
 151+ 62E0              	; opening (
 152+ 62E0 CD 67 66     	CALL CHKCHAR
 153+ 62E3 28           	DB '('
 154+ 62E4              	; get source address
 155+ 62E4 DD 21 2F 54  	LD IX, FRMQNT
 156+ 62E8 CD 59 01     	CALL CALBAS
 157+ 62EB D5           	PUSH DE
 158+ 62EC              	; comma
 159+ 62EC CD 67 66     	CALL CHKCHAR
 160+ 62EF 2C           	DB ','
 161+ 62F0              	; get destination address
 162+ 62F0 DD 21 2F 54  	LD IX, FRMQNT
 163+ 62F4 CD 59 01     	CALL CALBAS
 164+ 62F7 D5           	PUSH DE
 165+ 62F8              	; ending )
 166+ 62F8 CD 67 66     	CALL CHKCHAR
 167+ 62FB 29           	DB ')'
 168+ 62FC
 169+ 62FC              	; save position
 170+ 62FC E5           	PUSH HL
 171+ 62FD DD E1        	POP IX
 172+ 62FF
 173+ 62FF D1           	POP DE ; destination
 174+ 6300 E1           	POP HL ; source
 175+ 6301 D9           	EXX
 176+ 6302              	; enable page 0
 177+ 6302 FD 21 09 63  	LD IY, .RET
 178+ 6306 C3 18 66     	JP ENABLE_PAGE0
 179+ 6309              .RET:
 180+ 6309 FB           	EI
 181+ 630A D9           	EXX
 182+ 630B CD 3E 62     	CALL dzx0_standard
 183+ 630E D1                   POP DE
 184+ 630F C1                   POP BC
 185+ 6310 CD 8F 65             CALL RESTORE_PAGE_INFO
 186+ 6313 DD E5        	PUSH IX
 187+ 6315 E1           	POP HL
 188+ 6316 C9           	RET
 189+ 6317              ; *******************************************************************************************************
 190+ 6317               ENDIF
 191+ 6317
 192+ 6317               IF (0 == 1)
 193+ 6317 ~            ; *******************************************************************************************************
 194+ 6317 ~            ; same as VUNPACK but for DEFUSR approach
 195+ 6317 ~            ; input IX=pointer to input array, real data from +2
 196+ 6317 ~            ; +2 = source address
 197+ 6317 ~            ; +4 = destination address
 198+ 6317 ~            ; *******************************************************************************************************
 199+ 6317 ~            VUNPACK_DEFUSR:
 200+ 6317 ~                LD A, #CD ; CALL
 201+ 6317 ~                LD (dzx0_ldir_1), A
 202+ 6317 ~                LD (dzx0_ldir_2), A
 203+ 6317 ~                LD HL, LDIR_TO_VRAM
 204+ 6317 ~                LD (dzx0_ldir_1 + 1), HL
 205+ 6317 ~                LD HL, VRAM_LDIR
 206+ 6317 ~                LD (dzx0_ldir_2 + 1), HL
 207+ 6317 ~                JR UNPACK_DEFUSR_COMMON
 208+ 6317 ~            ; same as UNPACK but for DEFUSR approach
 209+ 6317 ~            ; input IX=pointer to input array, real data from +2
 210+ 6317 ~            ; +2 = source address
 211+ 6317 ~            ; +4 = destination address
 212+ 6317 ~            UNPACK_DEFUSR:
 213+ 6317 ~                LD HL, #B0ED ; LDIR
 214+ 6317 ~                LD (dzx0_ldir_1), HL
 215+ 6317 ~                LD (dzx0_ldir_2), HL
 216+ 6317 ~                XOR A ; NOP
 217+ 6317 ~                LD (dzx0_ldir_1 + 2), A
 218+ 6317 ~                LD (dzx0_ldir_2 + 2), A
 219+ 6317 ~            UNPACK_DEFUSR_COMMON:
 220+ 6317 ~            	; enable page 0
 221+ 6317 ~            	LD IY, .RET
 222+ 6317 ~            	JP ENABLE_PAGE0
 223+ 6317 ~            .RET:
 224+ 6317 ~            	EI
 225+ 6317 ~            	LD L,(IX+2)
 226+ 6317 ~            	LD H,(IX+3)
 227+ 6317 ~            	LD E,(IX+4)
 228+ 6317 ~            	LD D,(IX+5)
 229+ 6317 ~            	CALL dzx0_standard
 230+ 6317 ~                POP DE
 231+ 6317 ~                POP BC
 232+ 6317 ~                JP RESTORE_PAGE_INFO
 233+ 6317 ~            ; *******************************************************************************************************
 234+ 6317               ENDIF
# file closed: asm\decomp.asm
 174  6317               ENDIF
 175  6317
 176  6317               IF (DLOAD_CMD == 1)
 177  6317               INCLUDE "DLOAD.asm"
# file opened: asm\DLOAD.asm
   1+ 6317              ; *******************************************************************************************************
   2+ 6317              ; function processes file name
   3+ 6317              ; filenames supported are D:FILENAME.EXT, FILENAME.EXT, D:FILENAME, FILENAME
   4+ 6317              ; FCB 0 will be populated with drive info 0=default or 1-8 for drives A-H
   5+ 6317              ; FCB 0 will be populated with file name
   6+ 6317              ; input HL=pointer to expression
   7+ 6317              ; input B=length
   8+ 6317              ; returns CF=1 if bad filename
   9+ 6317              DLOAD_PROCESS_FILENAME:
  10+ 6317                  ; check for zero size
  11+ 6317 78               LD A,B
  12+ 6318 B7               OR A
asm\DLOAD.asm(13): error: Label not found: DLOAD_PROCESS_FILENAME.BADFILENAME
asm\DLOAD.asm(13): error: [JR] Target out of range (-25371)
  13+ 6319 28 00            JR Z, .BADFILENAME
  14+ 631B                  ; check if more than 2 letters
  15+ 631B FE 03            CP 3
  16+ 631D 38 1F            JR C, .PROCESS_FILENAME
  17+ 631F                  ; check for : at proper place
  18+ 631F 5E               LD E, (HL)
  19+ 6320 23               INC HL
  20+ 6321 7E               LD A, (HL)
  21+ 6322 FE 3A            CP ':'
  22+ 6324 20 14            JR NZ, .L1
  23+ 6326                  ; so we have : , check for letters A-H
  24+ 6326 7B               LD A,E
  25+ 6327 CD B7 66         CALL UPPER
  26+ 632A D6 41            SUB 'A'
  27+ 632C FE 09            CP 9
asm\DLOAD.asm(28): error: Label not found: DLOAD_PROCESS_FILENAME.BADFILENAME
asm\DLOAD.asm(28): error: [JR] Target out of range (-25392)
  28+ 632E 30 00            JR NC, .BADFILENAME
  29+ 6330 23               INC HL
  30+ 6331 05               DEC B ; consume two characters
  31+ 6332 05               DEC B
  32+ 6333              .L2:
  33+ 6333 ED 5B 3D F2      LD DE, (FCB0)
  34+ 6337 12               LD (DE), A
  35+ 6338 18 04            JR .PROCESS_FILENAME
  36+ 633A              .L1:
  37+ 633A                  ; no drive specified
  38+ 633A AF               XOR A
  39+ 633B 2B               DEC HL
  40+ 633C 18 F5            JR .L2
  41+ 633E              .PROCESS_FILENAME:
  42+ 633E                  ; HL is pointing to rest of the name
  43+ 633E
# file closed: asm\DLOAD.asm
 178  633E               ENDIF
 179  633E
 180  633E               IF (0 == 1)
 181  633E ~             INCLUDE "DEFUSR.asm"
 182  633E               ENDIF
 183  633E
 184  633E              ; temp variables for BLIT, TILE functions
 185  633E               IF (BLIT_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS + COLL_CMD > 0)
 186  633E              BLIT_TMP:
 187  633E              TILETMP1:
 188  633E              BLIT_TMP1:
 189  633E 00 00         DW 0
 190  6340              TILETMP2:
 191  6340              BLIT_TMP2:
 192  6340 00 00         DW 0
 193  6342              BLIT_STRUCT:
 194  6342 00 00 00...   DS 17
 195  6346               ENDIF
 196  6353
 197  6353               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 198  6353              VRAM_UPDATE_IN_PROGRESS:
 199  6353 00            DB 0
 200  6354               ENDIF
 201  6354
 202  6354              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 203  6354              ; per starting letter, if no commands with this letter, NULL value
 204  6354              CMDS:
 205  6354 9D 64        	DW CMDS_A ; always present due to ARTINFO
 206  6356               IF (BLIT_CMDS + BOX_CMDS > 0) && (1 == 1)
 207  6356 5A 64            DW CMDS_B ; B
 208  6358               ELSE
 209  6358 ~            	DW 0
 210  6358               ENDIF
 211  6358               IF (COLL_CMD == 1) && (1 == 1)
 212  6358 8D 64        	DW CMDS_C ;
 213  635A               ELSE
 214  635A ~                DW 0 ; C
 215  635A               ENDIF
 216  635A 00 00            DW 0 ; D
 217  635C 00 00            DW 0 ; E
 218  635E               IF (VRAM_CMDS + RAM_CMDS > 0) && (1 == 1)
 219  635E D4 63            DW CMDS_F; F
 220  6360               ELSE
 221  6360 ~            	DW 0
 222  6360               ENDIF
 223  6360               IF (GENCAL_CMD > 0) && (1 == 1)
 224  6360 E6 63            DW CMDS_G; G
 225  6362               ELSE
 226  6362 ~            	DW 0
 227  6362               ENDIF
 228  6362 00 00            DW 0 ; H
 229  6364 00 00            DW 0 ; I
 230  6366 00 00            DW 0 ; J
 231  6368 00 00            DW 0 ; K
 232  636A 00 00            DW 0 ; L
 233  636C               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0) && (1 == 1)
 234  636C 88 63            DW CMDS_M ; M
 235  636E               ELSE
 236  636E ~            	DW 0
 237  636E               ENDIF
 238  636E 00 00            DW 0 ; N
 239  6370 00 00            DW 0 ; O
 240  6372 00 00            DW 0 ; P
 241  6374 00 00            DW 0 ; Q
 242  6376 00 00            DW 0 ; R
 243  6378               IF (SOUND_CMDS + SPRITE_CMDS > 0) && (1 == 1)
 244  6378 02 64            DW CMDS_S ; S
 245  637A               ELSE
 246  637A ~            	DW 0
 247  637A               ENDIF
 248  637A               IF (TILE_CMDS > 0) && (1 == 1)
 249  637A 79 64            DW CMDS_T ; T
 250  637C               ELSE
 251  637C ~            	DW 0
 252  637C               ENDIF
 253  637C               IF (DECOMP_CMDS > 0) && (1 == 1)
 254  637C 94 64            DW CMDS_U ; U
 255  637E               ELSE
 256  637E ~            	DW 0
 257  637E               ENDIF
 258  637E               IF ((VRAM_CMDS > 0) || (VRAM_CMDS + DECOMP_CMDS > 1)) && (1 == 1)
 259  637E EF 63            DW CMDS_V ; V
 260  6380               ELSE
 261  6380 ~            	DW 0
 262  6380               ENDIF
 263  6380 00 00            DW 0 ; W
 264  6382 00 00            DW 0 ; X
 265  6384 00 00            DW 0 ; Y
 266  6386 00 00            DW 0 ; Z
 267  6388
 268  6388               IF (1 == 1)
 269  6388               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 270  6388              CMDS_M:
 271  6388               IF (VRAM_CMDS == 1)
 272  6388 4D 45 4D 56      DB "MEMVRM", 0
 272  638C 52 4D 00
 273  638F F4 59            DW MEMVRM
 274  6391               ENDIF
 275  6391               IF (RAM_CMDS == 1)
 276  6391 4D 45 4D 43  	DB "MEMCPY", 0
 276  6395 50 59 00
 277  6398 32 58        	DW MEMCPY
 278  639A               ENDIF
 279  639A               IF (ANIM_CMDS == 1)
 280  639A 4D 41 58 41  	DB "MAXANIMITEMS",0
 280  639E 4E 49 4D 49
 280  63A2 54 45 4D 53
 280  63A6 00
 281  63A7 A0 4F        	DW MAXANIMITEMS
 282  63A9 4D 41 58 41  	DB "MAXANIMDEFS",0
 282  63AD 4E 49 4D 44
 282  63B1 45 46 53 00
 283  63B5 30 51        	DW MAXANIMDEFS
 284  63B7 4D 41 58 41  	DB "MAXANIMSPRS",0
 284  63BB 4E 49 4D 53
 284  63BF 50 52 53 00
 285  63C3 C6 51        	DW MAXANIMSPRS
 286  63C5 4D 41 58 41     DB "MAXAUTOSGAMS",0
 286  63C9 55 54 4F 53
 286  63CD 47 41 4D 53
 286  63D1 00
 287  63D2 10 53           DW MAXAUTOSGAMS
 288  63D4               ENDIF
 289  63D4               ENDIF
 290  63D4
 291  63D4               IF (VRAM_CMDS + RAM_CMDS > 0)
 292  63D4              CMDS_F:
 293  63D4               IF (VRAM_CMDS == 1)
 294  63D4 46 49 4C 56      DB "FILVRM", 0
 294  63D8 52 4D 00
 295  63DB A5 59            DW FILVRM
 296  63DD               ENDIF
 297  63DD               IF (RAM_CMDS == 1)
 298  63DD 46 49 4C 52      DB "FILRAM", 0
 298  63E1 41 4D 00
 299  63E4 75 58            DW FILRAM
 300  63E6               ENDIF
 301  63E6               ENDIF
 302  63E6
 303  63E6               IF (GENCAL_CMD > 0)
 304  63E6              CMDS_G:
 305  63E6               IF (GENCAL_CMD == 1)
 306  63E6 47 45 4E 43      DB "GENCAL", 0
 306  63EA 41 4C 00
 307  63ED E1 5A            DW GENCAL
 308  63EF               ENDIF
 309  63EF               ENDIF
 310  63EF
 311  63EF               IF (VRAM_CMDS > 0)
 312  63EF              CMDS_V:
 313  63EF               IF (VRAM_CMDS == 1)
 314  63EF 56 52 4D 4D  	DB "VRMMEM", 0
 314  63F3 45 4D 00
 315  63F6 81 5A        	DW VRMMEM
 316  63F8               ENDIF
 317  63F8               IF (DECOMP_CMDS == 1)
 318  63F8 56 55 4E 50  	DB "VUNPACK", 0
 318  63FC 41 43 4B 00
 319  6400 B6 62        	DW VUNPACK
 320  6402               ENDIF
 321  6402               ENDIF
 322  6402
 323  6402               IF (SOUND_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 324  6402              CMDS_S:
 325  6402               IF (SPRITE_CMDS + ANIM_CMDS > 0)
 326  6402 53 47 41 4D      DB "SGAM",0
 326  6406 00
 327  6407 9E 56            DW SGAM
 328  6409               ENDIF
 329  6409               IF (SPRITE_CMDS == 1)
 330  6409 53 50 52 47  	DB "SPRGRPMOV", 0
 330  640D 52 50 4D 4F
 330  6411 56 00
 331  6413 F8 4E        	DW SPRGRPMOV
 332  6415               ENDIF
 333  6415               IF (SOUND_CMDS == 1)
 334  6415 53 4E 44 53  	DB "SNDSFX", 0
 334  6419 46 58 00
 335  641C 4B 59        	DW SNDSFX
 336  641E 53 4E 44 50  	DB "SNDPLYON", 0
 336  6422 4C 59 4F 4E
 336  6426 00
 337  6427 15 59        	DW SNDPLYON
 338  6429 53 4E 44 50  	DB "SNDPLYOFF", 0
 338  642D 4C 59 4F 46
 338  6431 46 00
 339  6433 28 59        	DW SNDPLYOFF
 340  6435 53 4E 44 50  	DB "SNDPLYINI", 0
 340  6439 4C 59 49 4E
 340  643D 49 00
 341  643F CB 58        	DW SNDPLYINIT
 342  6441               ENDIF
 343  6441               IF (SPRITE_CMDS == 1)
 344  6441 53 50 52 45  	DB "SPRENABLE", 0
 344  6445 4E 41 42 4C
 344  6449 45 00
 345  644B 6E 4E        	DW SPRENABLE
 346  644D 53 50 52 44  	DB "SPRDISABLE", 0
 346  6451 49 53 41 42
 346  6455 4C 45 00
 347  6458 B5 4E        	DW SPRDISABLE
 348  645A               ENDIF
 349  645A               ENDIF
 350  645A
 351  645A               IF (BLIT_CMDS + BOX_CMDS > 0)
 352  645A              CMDS_B:
 353  645A               IF (BLIT_CMDS == 1)
 354  645A 42 4C 49 54  	DB "BLIT", 0
 354  645E 00
 355  645F C1 5D        	DW BLIT
 356  6461               ENDIF
 357  6461               IF (BOX_CMDS == 1)
 358  6461 42 4F 58 4D  	DB "BOXMEMCPY", 0
 358  6465 45 4D 43 50
 358  6469 59 00
 359  646B 70 5B        	DW BOXMEMCPY
 360  646D 42 4F 58 4D  	DB "BOXMEMVRM", 0
 360  6471 45 4D 56 52
 360  6475 4D 00
 361  6477 05 5C        	DW BOXMEMVRM
 362  6479               ENDIF
 363  6479               ENDIF
 364  6479
 365  6479               IF (TILE_CMDS > 0)
 366  6479              CMDS_T:
 367  6479               IF (TILE_CMDS == 1)
 368  6479 54 49 4C 45  	DB "TILERAM", 0
 368  647D 52 41 4D 00
 369  6481 E8 5E        	DW TILERAM
 370  6483 54 49 4C 45  	DB "TILEVRM", 0
 370  6487 56 52 4D 00
 371  648B EB 5F        	DW TILEVRM
 372  648D               ENDIF
 373  648D               ENDIF
 374  648D
 375  648D               IF (COLL_CMD > 0)
 376  648D              CMDS_C:
 377  648D               IF (COLL_CMD == 1)
 378  648D 43 4F 4C 4C      DB "COLL", 0
 378  6491 00
 379  6492 B7 61            DW COLL
 380  6494               ENDIF
 381  6494               ENDIF
 382  6494
 383  6494               IF (DECOMP_CMDS > 0)
 384  6494              CMDS_U:
 385  6494               IF (DECOMP_CMDS == 1)
 386  6494 55 4E 50 41      DB "UNPACK", 0
 386  6498 43 4B 00
 387  649B CE 62            DW UNPACK
 388  649D               ENDIF
 389  649D               ENDIF
 390  649D
 391  649D              CMDS_A:
 392  649D               IF (ANIM_CMDS == 1)
 393  649D 41 4E 49 4D     DB "ANIMSTEP",0
 393  64A1 53 54 45 50
 393  64A5 00
 394  64A6 E0 54           DW ANIMSTEP
 395  64A8 41 4E 49 4D  	DB "ANIMSTART",0
 395  64AC 53 54 41 52
 395  64B0 54 00
 396  64B2 E5 54        	DW ANIMSTART
 397  64B4 41 4E 49 4D  	DB "ANIMSTOP",0
 397  64B8 53 54 4F 50
 397  64BC 00
 398  64BD EA 54        	DW ANIMSTOP
 399  64BF 41 4E 49 4D  	DB "ANIMITEMPAT",0
 399  64C3 49 54 45 4D
 399  64C7 50 41 54 00
 400  64CB 71 50        	DW ANIMITEMPAT
 401  64CD 41 4E 49 4D  	DB "ANIMITEMPTR",0
 401  64D1 49 54 45 4D
 401  64D5 50 54 52 00
 402  64D9 D7 50        	DW ANIMITEMPTR_CMD
 403  64DB 41 4E 49 4D  	DB "ANIMDEF",0
 403  64DF 44 45 46 00
 404  64E3 73 51        	DW ANIMDEF
 405  64E5 41 4E 49 4D  	DB "ANIMSPRITE",0
 405  64E9 53 50 52 49
 405  64ED 54 45 00
 406  64F0 1F 52        	DW ANIMSPRITE
 407  64F2 41 4E 49 4D     DB "ANIMCHAR",0
 407  64F6 43 48 41 52
 407  64FA 00
 408  64FB 97 52           DW ANIMCHAR
 409  64FD 41 55 54 4F     DB "AUTOSGAMDEF",0
 409  6501 53 47 41 4D
 409  6505 44 45 46 00
 410  6509 6D 53           DW AUTOSGAMDEF
 411  650B 41 55 54 4F     DB "AUTOSGAMSTART",0
 411  650F 53 47 41 4D
 411  6513 53 54 41 52
 411  6517 54 00
 412  6519 A1 54           DW AUTOSGAMSTART
 413  651B 41 55 54 4F     DB "AUTOSGAMSTOP",0
 413  651F 53 47 41 4D
 413  6523 53 54 4F 50
 413  6527 00
 414  6528 DD 54           DW AUTOSGAMSTOP
 415  652A               ENDIF
 416  652A 41 52 54 49     DB "ARTINFO",0
 416  652E 4E 46 4F 00
 417  6532 F5 66           DW ARTINFO
 418  6534 00           	DB 0
 419  6535               ELSE // if not BASIC extension
 420  6535 ~            CMDS_A:
 421  6535 ~               DB "ARTINFO",0
 422  6535 ~               DW ARTINFO
 423  6535 ~            	DB 0
 424  6535               ENDIF
 425  6535
 426  6535               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 427  6535              ; ****************************************************************************************************
 428  6535              ; function sets VRAM address for writing
 429  6535              ; input HL=address
 430  6535              ; modifies AF
 431  6535              SETWRT_LOCAL_WRITE:
 432  6535 7D           	LD	A,L
 433  6536 D3 99        	OUT (#99),A
 434  6538 7C           	LD	A,H
 435  6539 E6 3F        	AND #3F
 436  653B F6 40        	OR	#40
 437  653D D3 99        	OUT (#99),A
 438  653F C9           	RET
 439  6540              ; ****************************************************************************************************
 440  6540
 441  6540              ; ****************************************************************************************************
 442  6540              ; function sets VRAM address for reading
 443  6540              ; input HL=address
 444  6540              ; modifies AF
 445  6540              SETWRT_LOCAL_READ:
 446  6540 7D           	LD	A,L
 447  6541 D3 99        	OUT (#99),A
 448  6543 7C           	LD	A,H
 449  6544 E6 3F        	AND #3F
 450  6546 00              NOP
 451  6547 D3 99        	OUT (#99),A
 452  6549 C9           	RET
 453  654A              ; ****************************************************************************************************
 454  654A               ENDIF
 455  654A
 456  654A               IF (VRAM_CMDS + TILE_CMDS > 0)
 457  654A              ; ****************************************************************************************************
 458  654A              ; function copies data from RAM to VRAM
 459  654A              ; input HL=address in RAM
 460  654A              ; input B=count
 461  654A              ; modifies AF, BC, HL
 462  654A              BBYTECOPY:
 463  654A 0E 98        	LD C,#98
 464  654C              BBYTECOPY_NO_C:
 465  654C ED A3        	OUTI
 466  654E C2 4C 65     	JP	NZ, BBYTECOPY_NO_C
 467  6551 C9           	RET
 468  6552              ; ****************************************************************************************************
 469  6552               ENDIF
 470  6552
 471  6552              ; ****************************************************************************************************
 472  6552              ; function multiplies HL by 32
 473  6552              HLx32:
 474  6552 29           	ADD HL,HL
 475  6553              ; ****************************************************************************************************
 476  6553              ; function multiplies HL by 16
 477  6553              HLx16:
 478  6553 29           	ADD HL,HL
 479  6554              ; ****************************************************************************************************
 480  6554              ; function multiplies HL by 8
 481  6554              HLx8:
 482  6554 29          > ADD HL, HL
 482  6555 29          > ADD HL, HL
 482  6556 29          > ADD HL, HL
 483  6557 C9           	RET
 484  6558              ; ****************************************************************************************************
 485  6558
 486  6558              ; ****************************************************************************************************
 487  6558              ; function gets slot and subslot data for specific page
 488  6558              ; input A=page (0, 1 or 2)
 489  6558              ; output B = 0A8H register value
 490  6558              ; output D = 0 is no subslots, 1 if yes
 491  6558              ; output C = 0A8H value when page 3 slot equals to requested page slot
 492  6558              ; output E = subslot value if present
 493  6558              ; modifies AF, BC, DE, HL
 494  6558              GET_PAGE_INFO:
 495  6558 6F               LD L, A
 496  6559 C6 C1            ADD A, low (EXPTBL)
 497  655B 32 65 65         LD (GET_PAGE_INFO_L1+1), A
 498  655E DB A8            IN A, (0A8H)
 499  6560 47               LD B, A
 500  6561 E6 3F            AND 03FH
 501  6563 4F               LD C, A
 502  6564              GET_PAGE_INFO_L1:
 503  6564 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 504  6567 E6 80            AND 080H
 505  6569 28 1B            JR Z, GET_PAGE_INFO_L2
 506  656B                  ; expanded
 507  656B 2D               DEC L
 508  656C FA 8B 65         JP M, GET_PAGE_INFO_L3
 509  656F 2D               DEC L
 510  6570 FA 89 65         JP M, GET_PAGE_INFO_L4
 511  6573                  ; page 2
 512  6573 07               RLCA
 513  6574 07               RLCA
 514  6575              GET_PAGE_INFO_L5:
 515  6575 E6 C0            AND 0C0H
 516  6577 B1               OR C
 517  6578 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 518  657A 4F               LD C, A
 519  657B 3A FF FF         LD A, (0FFFFH)
 520  657E 2F               CPL
 521  657F 5F               LD E, A
 522  6580 16 01            LD D, 1
 523  6582 78               LD A, B ; return stack
 524  6583 D3 A8            OUT (0A8H), A
 525  6585 C9               RET
 526  6586              GET_PAGE_INFO_L2:
 527  6586                  ; not expanded
 528  6586 16 00            LD D, 0
 529  6588 C9               RET
 530  6589              GET_PAGE_INFO_L4:
 531  6589                  ; page 1
 532  6589 0F               RRCA
 533  658A 0F               RRCA
 534  658B              GET_PAGE_INFO_L3:
 535  658B                  ; page 0
 536  658B 0F               RRCA
 537  658C 0F               RRCA
 538  658D 18 E6            JR GET_PAGE_INFO_L5
 539  658F              ; ****************************************************************************************************
 540  658F
 541  658F              ; ****************************************************************************************************
 542  658F              ; function returns original slot and subslot info
 543  658F              ; input B = 0A8H register value
 544  658F              ; input D = 0 is no subslots, 1 if yes
 545  658F              ; input C = 0A8H value when page 3 slot equals to requested page slot
 546  658F              ; input E = subslot value if present
 547  658F              ; modifies AF, disables interrupts
 548  658F              RESTORE_PAGE_INFO:
 549  658F F3              DI
 550  6590 7A              LD A, D
 551  6591 B7              OR A
 552  6592 28 07           JR Z, RESTORE_PAGE_INFO_L1
 553  6594 79              LD A, C
 554  6595 D3 A8           OUT (0A8H), A
 555  6597 7B              LD A, E
 556  6598 32 FF FF        LD (0FFFFH), A
 557  659B              RESTORE_PAGE_INFO_L1:
 558  659B 78              LD A, B
 559  659C D3 A8           OUT (0A8H), A
 560  659E              NOACTION_DEFUSR: ; just a safe RET for use when DEFUSR table has an empty entry
 561  659E C9              RET
 562  659F              ; ****************************************************************************************************
 563  659F
 564  659F              ; *******************************************************************************************************
 565  659F              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 566  659F              ; INPUT:  A = SLOT ID: EXXXSSPP
 567  659F              ; E = EXPANDED FLAG
 568  659F              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 569  659F              ; PP = PRIMARY SLOT NUMBER
 570  659F              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 571  659F              ; CHANGES: AF, BC, DE
 572  659F
 573  659F              LOCAL_ENASLT:
 574  659F CD BF 65         CALL L0353
 575  65A2 FA AC 65         JP M, L0340
 576  65A5 DB A8            IN A, (0A8H)
 577  65A7 A1               AND C
 578  65A8 B0               OR B
 579  65A9 D3 A8            OUT (0A8H), A
 580  65AB C9               RET
 581  65AC              L0340:
 582  65AC E5               PUSH HL
 583  65AD CD E4 65         CALL L0378
 584  65B0 4F               LD C, A
 585  65B1 06 00            LD B, 0
 586  65B3 7D               LD A, L
 587  65B4 A4               AND H
 588  65B5 B2               OR D
 589  65B6 21 C5 FC         LD HL, 0FCC5H
 590  65B9 09               ADD HL, BC
 591  65BA 77               LD (HL), A
 592  65BB E1               POP HL
 593  65BC 79               LD A, C
 594  65BD 18 E0            JR LOCAL_ENASLT
 595  65BF              L0353:
 596  65BF F3               DI
 597  65C0 F5               PUSH AF
 598  65C1 7C               LD A, H
 599  65C2 07               RLCA
 600  65C3 07               RLCA
 601  65C4 E6 03            AND 3
 602  65C6 5F               LD E, A
 603  65C7 3E C0            LD A, 0C0H
 604  65C9              L035D:
 605  65C9 07               RLCA
 606  65CA 07               RLCA
 607  65CB 1D               DEC E
 608  65CC F2 C9 65         JP P, L035D
 609  65CF 5F               LD E, A
 610  65D0 2F               CPL
 611  65D1 4F               LD C, A
 612  65D2 F1               POP AF
 613  65D3 F5               PUSH AF
 614  65D4 E6 03            AND 3
 615  65D6 3C               INC A
 616  65D7 47               LD B, A
 617  65D8 3E AB            LD A, 0ABH
 618  65DA              L036E:
 619  65DA C6 55            ADD A, 055H
 620  65DC 10 FC            DJNZ L036E
 621  65DE 57               LD D, A
 622  65DF A3               AND E
 623  65E0 47               LD B, A
 624  65E1 F1               POP AF
 625  65E2 A7               AND A
 626  65E3 C9               RET
 627  65E4              L0378:
 628  65E4 F5               PUSH AF
 629  65E5 7A               LD A, D
 630  65E6 E6 C0            AND 0C0H
 631  65E8 4F               LD C, A
 632  65E9 F1               POP AF
 633  65EA F5               PUSH AF
 634  65EB 57               LD D, A
 635  65EC DB A8            IN A, (0A8H)
 636  65EE 47               LD B, A
 637  65EF E6 3F            AND 03FH
 638  65F1 B1               OR C
 639  65F2 D3 A8            OUT (0A8H), A
 640  65F4 7A               LD A, D
 641  65F5 0F               RRCA
 642  65F6 0F               RRCA
 643  65F7 E6 03            AND 3
 644  65F9 57               LD D, A
 645  65FA 3E AB            LD A, 0ABH
 646  65FC              L0390:
 647  65FC C6 55            ADD A, 055H
 648  65FE 15               DEC D
 649  65FF F2 FC 65         JP P, L0390
 650  6602 A3               AND E
 651  6603 57               LD D, A
 652  6604 7B               LD A, E
 653  6605 2F               CPL
 654  6606 67               LD H, A
 655  6607 3A FF FF         LD A, (0FFFFH)
 656  660A 2F               CPL
 657  660B 6F               LD L, A
 658  660C A4               AND H
 659  660D B2               OR D
 660  660E 32 FF FF         LD (0FFFFH), A
 661  6611 78               LD A, B
 662  6612 D3 A8            OUT (0A8H), A
 663  6614 F1               POP AF
 664  6615 E6 03            AND 3
 665  6617 C9               RET
 666  6618              ; *******************************************************************************************************
 667  6618
 668  6618              ; *******************************************************************************************************
 669  6618              ; some common code to activate page 0 and place values needed to restore original page on stack
 670  6618              ; input IY=return address
 671  6618              ENABLE_PAGE0:
 672  6618 F3              DI
 673  6619 AF              XOR A
 674  661A CD 58 65        CALL GET_PAGE_INFO
 675  661D C5              PUSH BC
 676  661E D5              PUSH DE
 677  661F 3A 41 F3        LD A, (RAMAD0)
 678  6622 26 00           LD H, 0
 679  6624 CD 9F 65        CALL LOCAL_ENASLT
 680  6627 FD E9        	JP (IY)
 681  6629              ; *******************************************************************************************************
 682  6629
 683  6629              ; General BASIC CALL-instruction handler
 684  6629              CALLHAND:
 685  6629 FB              EI
 686  662A E5           	PUSH HL
 687  662B 21 54 63     	LD	HL, CMDS ; pointer table based on starting letter
 688  662E 3A 89 FD        LD A, (PROCNM)
 689  6631 D6 41           SUB 'A'
 690  6633 87              ADD A, A
 691  6634 16 00           LD D, 0
 692  6636 5F              LD E, A
 693  6637 19              ADD HL, DE
 694  6638 5E              LD E, (HL)
 695  6639 23              INC HL
 696  663A 56              LD D, (HL)
 697  663B 7A              LD A, D
 698  663C B3              OR E
 699  663D 28 23           JR Z, .CMDNOTRECOGNIZED
 700  663F EB              EX DE, HL
 701  6640              .CHKCMD:
 702  6640 11 89 FD     	LD	DE, PROCNM
 703  6643              .LOOP:
 704  6643 1A              LD	A,(DE)
 705  6644 BE           	CP	(HL)
 706  6645 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 707  6647 13           	INC	DE
 708  6648 23           	INC	HL
 709  6649 A7           	AND	A
 710  664A 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 711  664C 5E           	LD	E,(HL)
 712  664D 23           	INC	HL
 713  664E 56           	LD	D,(HL)
 714  664F E1           	POP	HL		; routine address
 715  6650 CD 71 66     	CALL	GETPREVCHAR
 716  6653 CD 65 66     	CALL	.CALLDE		; Call routine
 717  6656 A7           	AND	A
 718  6657 C9           	RET
 719  6658
 720  6658              .TONEXTCMD:
 721  6658 0E FF        	LD	C,0FFH
 722  665A AF           	XOR	A
 723  665B ED B1        	CPIR			; Skip to end of instruction name
 724  665D 23           	INC	HL
 725  665E 23           	INC	HL		; Skip address
 726  665F BE           	CP	(HL)
 727  6660 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 728  6662              .CMDNOTRECOGNIZED:
 729  6662 E1           	POP	HL
 730  6663 37              SCF
 731  6664 C9           	RET
 732  6665
 733  6665              .CALLDE:
 734  6665 D5           	PUSH	DE
 735  6666 C9           	RET
 736  6667
 737  6667              ;---------------------------
 738  6667
 739  6667              CHKCHAR:
 740  6667 CD 71 66     	CALL	GETPREVCHAR	; Get previous basic char
 741  666A E3           	EX	(SP),HL
 742  666B BE           	CP	(HL) 	        ; Check if good char
 743  666C 20 1D        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 744  666E 23           	INC	HL
 745  666F E3           	EX	(SP),HL
 746  6670 23           	INC	HL		; Get next basic char
 747  6671
 748  6671              GETPREVCHAR:
 749  6671 2B           	DEC HL
 750  6672 DD 21 66 46  	LD	IX,CHRGTR
 751  6676 CD 59 01     	CALL CALBAS
 752  6679 FB              EI
 753  667A C9              RET
 754  667B
 755  667B
 756  667B              TYPE_MISMATCH:
 757  667B 1E 0D           LD E, 13 ; Type mismatch
 758  667D 18 0E           JR THROW_ERROR
 759  667F              SUBSCRIPT_OUT_OF_RANGE:
 760  667F 1E 09           LD E,9 ; subscript out of range
 761  6681 18 0A        	JR THROW_ERROR
 762  6683              OVERFLOW:
 763  6683 1E 06        	LD E,6
 764  6685 18 06        	JR THROW_ERROR
 765  6687              ILLEGAL_FUNCTION:
 766  6687 1E 05           LD E, 5 ; illegal function call
 767  6689 18 02           JR THROW_ERROR
 768  668B              SYNTAX_ERROR:
 769  668B 1E 02           LD E, 2 ; Syntax error
 770  668D              THROW_ERROR:
 771  668D DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 772  6691 C3 59 01     	JP	CALBAS
 773  6694
 774  6694              ;---------------------------
 775  6694
 776  6694               IF (1 == 1)
 777  6694
 778  6694               IF (DLOAD_CMD == 1)
 779  6694              ; *******************************************************************************************************
 780  6694              ; helper function to return string pointer and length
 781  6694              ; returns HL = String Address
 782  6694              ; returns B  = Lenght
 783  6694              ; modifies BC, DE, HL
 784  6694              GETSTRPNT:
 785  6694 2A F8 F7        LD      HL,(USR)
 786  6697 46              LD      B,(HL)
 787  6698 23              INC     HL
 788  6699 5E              LD      E,(HL)
 789  669A 23              INC     HL
 790  669B 56              LD      D,(HL)
 791  669C EB              EX      DE,HL
 792  669D C9              RET
 793  669E              ; *******************************************************************************************************
 794  669E
 795  669E              ; *******************************************************************************************************
 796  669E              ; helper function to get string parameter
 797  669E              ; throws error if incorrect type
 798  669E              ; input HL=basic text
 799  669E              EVALTXTPARAM:
 800  669E DD 21 64 4C  	LD	IX,FRMEVL
 801  66A2 CD 59 01     	CALL CALBAS		; Evaluate expression
 802  66A5 3A 63 F6        LD A,(VALTYP)
 803  66A8 FE 03           CP 3               ; Text type?
 804  66AA C2 7B 66        JP NZ,TYPE_MISMATCH
 805  66AD E5              PUSH HL
 806  66AE DD 21 D0 67     LD	IX,FRESTR         ; Free the temporary string
 807  66B2 CD 59 01        CALL CALBAS
 808  66B5 E1              POP HL
 809  66B6 C9              RET
 810  66B7              ; *******************************************************************************************************
 811  66B7
 812  66B7              ; *******************************************************************************************************
 813  66B7              ; helper function to make an uppercase letter
 814  66B7              ; input A=character
 815  66B7              ; output A=uppercase version of input
 816  66B7              UPPER:
 817  66B7 FE 61           CP "a"
 818  66B9 D8              RET C
 819  66BA FE 7B           CP "z"+1
 820  66BC D0              RET NC
 821  66BD E6 5F           AND 5FH
 822  66BF C9              RET
 823  66C0
 824  66C0               ENDIF
 825  66C0
 826  66C0              ; *******************************************************************************************************
 827  66C0              ; helper function to get pointer to BASIC array data
 828  66C0              ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
 829  66C0              ; input B=dimensions (1 or 2)
 830  66C0              ; input D=minimal first dimension
 831  66C0              ; input E=minimal second dimension, if applicable
 832  66C0              ; returns BC=pointer to first data element
 833  66C0              ; throws BASIC error if invalid type
 834  66C0              GET_BASIC_ARRAY_DATA_POINTER:
 835  66C0 D5           	PUSH DE
 836  66C1 C5           	PUSH BC
 837  66C2 F5           	PUSH AF
 838  66C3 3E 01           LD A,1
 839  66C5 32 A5 F6        LD (SUBFLG),A ; search for arrays only
 840  66C8 DD 21 A4 5E  	LD IX, PTRGET
 841  66CC CD 59 01     	CALL CALBAS
 842  66CF AF              XOR A
 843  66D0 32 A5 F6        LD (SUBFLG),A ; if not reset will cause syntax errors
 844  66D3 3A 63 F6     	LD A,(VALTYP)
 845  66D6 D1           	POP DE ; required type
 846  66D7 BA           	CP D
 847  66D8 C2 7B 66     	JP NZ,TYPE_MISMATCH
 848  66DB 0A           	LD A,(BC)
 849  66DC 03           	INC BC
 850  66DD D1           	POP DE ; required number of dimensions
 851  66DE BA           	CP D
 852  66DF C2 7B 66     	JP NZ,TYPE_MISMATCH
 853  66E2 D1           	POP DE ; required minimal array dimensions
 854  66E3 3D           	DEC A
 855  66E4 28 07        	JR Z,.ONE_DIMENSION
 856  66E6              	; 2-dimension array
 857  66E6 0A           	LD A,(BC)
 858  66E7 03          > INC BC
 858  66E8 03          > INC BC
 859  66E9 BB           	CP E
 860  66EA DA 7F 66     	JP C,SUBSCRIPT_OUT_OF_RANGE
 861  66ED              .ONE_DIMENSION:
 862  66ED 0A           	LD A,(BC)
 863  66EE 03          > INC BC
 863  66EF 03          > INC BC
 864  66F0 BA           	CP D
 865  66F1 DA 7F 66     	JP C,SUBSCRIPT_OUT_OF_RANGE
 866  66F4 C9           	RET
 867  66F5              ; *******************************************************************************************************
 868  66F5               ENDIF
 869  66F5
 870  66F5              ; *******************************************************************************************************
 871  66F5              ; function to handle CALL ARTINFO basic extension
 872  66F5              ; returns info about the extension
 873  66F5              ; _ARTINFO ( INT variable version,
 874  66F5              ;			    INT variable build_flags,
 875  66F5              ;			    INT variable free_memory_ptr )
 876  66F5              ; this function is always available and can be used to test if the extension is active
 877  66F5              ARTINFO:
 878  66F5              	; opening (
 879  66F5 CD 67 66     	CALL CHKCHAR
 880  66F8 28           	DB '('
 881  66F9              	; get address of version variable
 882  66F9 DD 21 A4 5E  	LD IX, PTRGET
 883  66FD CD 59 01     	CALL CALBAS
 884  6700 3A 12 40     	LD A,(VERSION)
 885  6703 12              LD (DE),A
 886  6704 13              INC DE
 887  6705 3A 13 40        LD A,(VERSION+1)
 888  6708 12              LD (DE),A
 889  6709              	; comma
 890  6709 CD 67 66     	CALL CHKCHAR
 891  670C 2C           	DB ','
 892  670D              	; get address of build flags variable
 893  670D DD 21 A4 5E  	LD IX, PTRGET
 894  6711 CD 59 01     	CALL CALBAS
 895  6714 E5              PUSH HL
 896  6715 21 FF 17        LD HL,SOUND_CMDS+2*RAM_CMDS+4*VRAM_CMDS+8*BLIT_CMDS+16*SPRITE_CMDS+32*GENCAL_CMD+64*TILE_CMDS+128*BOX_CMDS+256*ANIM_CMDS+512*COLL_CMD+1024*1+2048*0+4096*DECOMP_CMDS
 897  6718 EB              EX DE,HL
 898  6719 73              LD (HL),E
 899  671A 23              INC HL
 900  671B 72              LD (HL),D
 901  671C E1              POP HL
 902  671D              	; comma
 903  671D CD 67 66     	CALL CHKCHAR
 904  6720 2C           	DB ','
 905  6721              	; get address of free memory variable
 906  6721 DD 21 A4 5E  	LD IX, PTRGET
 907  6725 CD 59 01     	CALL CALBAS
 908  6728 3A 10 40     	LD A,(FREEMEMPTR)
 909  672B 12              LD (DE),A
 910  672C 13              INC DE
 911  672D 3A 11 40        LD A,(FREEMEMPTR+1)
 912  6730 12              LD (DE),A
 913  6731              	; ending )
 914  6731 CD 67 66     	CALL CHKCHAR
 915  6734 29           	DB ')'
 916  6735 C9           	RET
 917  6736              ; *******************************************************************************************************
 918  6736
 919  6736              EXT_END:
 920  6736
# file closed: asm\main.asm
