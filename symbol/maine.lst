# file opened: asm\main.asm
   1  0000               ORG 04000h
   2  4000
   3  4000              ; control variables to include/exclude parts of code
   4  4000              SOUND_CMDS	 	EQU 1
   5  4000              RAM_CMDS 		EQU 1
   6  4000              VRAM_CMDS 		EQU 1
   7  4000              BLIT_CMDS		EQU 1
   8  4000              SPRITE_CMDS 	EQU 1
   9  4000              GENCAL_CMD		EQU 1
  10  4000              TILE_CMDS		EQU 1
  11  4000              BOX_CMDS		   EQU 1
  12  4000              ANIM_CMDS		EQU 1
  13  4000              COLL_CMD       EQU 1
  14  4000              DECOMP_CMDS    EQU 1
  15  4000              DLOAD_CMD      EQU 1
  16  4000
  17  4000              ; what to compile, provided in sjasmplus command line
  18  4000              ;BASIC_EXTENSION   EQU 1
  19  4000              ;DEFUSR_EXTENSION  EQU 0
  20  4000
  21  4000              CHPUT   EQU    #A2
  22  4000              CALBAS  EQU		#159
  23  4000              ERRHAND EQU    #406F
  24  4000              FRMEVL  EQU    #4C64
  25  4000              FRESTR  EQU		#67D0
  26  4000              ; FRMQNT = formula quantificator
  27  4000              ; input HL=pointer to current program expression
  28  4000              ; output HL=next address
  29  4000              ; output DE=integer datum
  30  4000              FRMQNT	EQU		#542F
  31  4000              ; GETBYT = get byte parameter
  32  4000              ; input HL=pointer to current program expression
  33  4000              ; output HL=next address
  34  4000              ; output A=E=byte read
  35  4000              GETBYT		EQU	#521C
  36  4000              CHRGTR  	   EQU   #4666
  37  4000              PTRGET		EQU 	#5EA4
  38  4000              SUBFLG		EQU	#F6A5
  39  4000              SYNCHR		EQU	#558C
  40  4000              VALTYP  	   EQU   #F663
  41  4000              DAC         EQU   #F7F6
  42  4000              USR     	   EQU   #F7F8
  43  4000              PROCNM		EQU	#FD89
  44  4000              BIOS_FILVRM EQU   #0056
  45  4000              CLIKSW		EQU	#F3DB
  46  4000
  47  4000              RAMAD0	   EQU	#F341	; Main-RAM Slot (00000h~03FFFh)
  48  4000              RAMAD1	   EQU	#F342	; Main-RAM Slot (04000h~07FFFh)
  49  4000              RAMAD2	   EQU	#F343	; Main-RAM Slot (08000h~0BFFFh)
  50  4000              RAMAD3	   EQU	#F344	; Main-RAM Slot (0C000h~0FFFFh)
  51  4000              EXPTBL	   EQU   #FCC1
  52  4000              SCRMOD	   EQU   #FCAF ; current screen mode
  53  4000              REG1SAV     EQU   #F3E0 ; VDP(1)
  54  4000              JIFFY	      EQU   #FC9E
  55  4000              GRPPAT	   EQU   #F3CF ; SCREEN 2 sprite generator table address
  56  4000              GRPCGP		EQU	#F3CB ; SCREEN 2 pattern generator table address
  57  4000              GRPATR      EQU   #F3CD ; SCREEN 2 sprite attribute table address
  58  4000              T32PAT	   EQU   #F3C5 ; SCREEN 1 sprite generator table address
  59  4000              T32CGP      EQU   #F3C1 ; SCREEN 1 pattern ganarator table address
  60  4000              T32ATR      EQU   #F3C3 ; SCREEN 1 sprite attribute table address
  61  4000
  62  4000              FCB0        EQU   #F353 ; location of FCB 0
  63  4000              BDOS        EQU   #F37D ; disk functions
  64  4000              NULBUF      EQU   #F862 ; disk buffer of 256 bytes address
  65  4000
  66  4000              ; BASIC error codes
  67  4000              ;01 NEXT without FOR
  68  4000              ;02 Syntax error
  69  4000              ;03 RETURN without GOSUB
  70  4000              ;04 Out of DATA
  71  4000              ;05 Illegal function call
  72  4000              ;06 Overflow
  73  4000              ;07 Out of memory
  74  4000              ;08 Undefined line number
  75  4000              ;09 Subscript out of range
  76  4000              ;10 Redimensioned array
  77  4000              ;11 Division by zero
  78  4000              ;12 Illegal direct
  79  4000              ;13 Type mismatch
  80  4000              ;14 Out of string space
  81  4000              ;15 String too long
  82  4000              ;16 String formula too complex
  83  4000              ;17 Can't CONTINUE
  84  4000              ;18 Undefined user function
  85  4000              ;19 Device I/O error
  86  4000              ;20 Verify error
  87  4000              ;21 No RESUME
  88  4000              ;22 RESUME without error
  89  4000              ;23 Unprintable error
  90  4000              ;24 Missing operand
  91  4000              ;25 Line buffer overflow
  92  4000              ;50 FIELD overflow
  93  4000              ;51 Internal error
  94  4000              ;52 Bad file number
  95  4000              ;53 File not found
  96  4000              ;54 File already open
  97  4000              ;55 Input past end
  98  4000              ;56 Bad file name
  99  4000              ;57 Direct statement in file
 100  4000              ;58 Sequential I/O only
 101  4000              ;59 File not OPEN
 102  4000
 103  4000
 104  4000               ; simulate cartridge with BASIC extension
 105  4000 41 42 00 00   DW 04241H, 0, CALLHAND, 0, 0, 0, 0, 0
 105  4004 53 67 00 00
 105  4008 00 00 00 00
 105  400C 00 00 00 00
 106  4010
 107  4010              ; this location #4010 stores last location used by basic extension
 108  4010              ; free memory after that point
 109  4010              FREEMEMPTR:
 110  4010 6C 68         DW EXT_END
 111  4012
 112  4012              ; this location #4012 stores extension version in DAA format
 113  4012              ; first byte is major version and second minor
 114  4012              VERSION:
 115  4012 00 93         DB #00, #93
 116  4014
 117  4014              ; this location #4014 contains a jump to entry point for DEFUSR approach
 118  4014              ; if excluded it contains 3xRET so that sound player can be at aspecific spot
 119  4014               IF (0 == 1)
 120  4014 ~               JP DEFUSR_ENTRY
 121  4014               ELSE
 122  4014 C9          > RET
 122  4015 C9          > RET
 122  4016 C9          > RET
 123  4017               ENDIF
 124  4017
 125  4017              ; binary included AKG player compiled at #4017
 126  4017               IF (SOUND_CMDS == 1)
 127  4017              	INCBIN "bin/AKG.bin"
 128  4CF3              	INCLUDE "symbol/AKG.sym"
# file opened: ./symbol/AKG.sym
   1+ 4CF3              MAIN_PLAYER_START EQU 04017H
   2+ 4CF3              PLY_AKG_START EQU 04017H
   3+ 4CF3              PLY_AKG_INITSOUNDEFFECTSDISARKGENERATEEXTERNALLABEL EQU 04020H
   4+ 4CF3              PLY_AKG_INITSOUNDEFFECTS EQU 04020H
   5+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTDISARKGENERATEEXTERNALLABEL EQU 04024H
   6+ 4CF3              PLY_AKG_PLAYSOUNDEFFECT EQU 04024H
   7+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_0 EQU 04025H
   8+ 4CF3              PLY_AKG_PTSOUNDEFFECTTABLE EQU 04025H
   9+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNELDISARKGENERATEEXTERNALLABEL EQU 0404CH
  10+ 4CF3              PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL EQU 0404CH
  11+ 4CF3              PLY_AKG_PLAYSOUNDEFFECTSSTREAM EQU 0405AH
  12+ 4CF3              PLY_AKG_PSES_PLAY EQU 04093H
  13+ 4CF3              PLY_AKG_PSES_READFIRSTBYTE EQU 0409CH
  14+ 4CF3              PLY_AKG_PSES_S_ENDORLOOP EQU 040B4H
  15+ 4CF3              PLY_AKG_PSES_S_LOOP EQU 040BFH
  16+ 4CF3              PLY_AKG_PSES_SAVEPOINTERANDEXIT EQU 040C5H
  17+ 4CF3              PLY_AKG_PSES_NOTREACHED EQU 040D8H
  18+ 4CF3              PLY_AKG_PSES_HARDWAREONLY EQU 040DCH
  19+ 4CF3              PLY_AKG_PSES_SOFTWAREORSOFTWAREANDHARDWARE EQU 040E3H
  20+ 4CF3              PLY_AKG_PSES_SOFTWAREANDHARDWARE EQU 040F5H
  21+ 4CF3              PLY_AKG_PSES_SHARED_READRETRIGHARDWAREENVPERIODNOISE EQU 040FFH
  22+ 4CF3              PLY_AKG_PSES_H_AFTERRETRIG EQU 04109H
  23+ 4CF3              PLY_AKG_PSES_READNOISEIFNEEDEDANDOPENORCLOSENOISECHANNEL EQU 0411DH
  24+ 4CF3              PLY_AKG_PSES_READNOISEANDOPENNOISECHANNEL_OPENNOISE EQU 04122H
  25+ 4CF3              PLY_AKG_PSES_READHARDWAREPERIOD EQU 0412AH
  26+ 4CF3              PLY_AKG_PSES_READSOFTWAREPERIOD EQU 04135H
  27+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_FILTER4BITS EQU 04141H
  28+ 4CF3              PLY_AKG_PSES_MANAGEVOLUMEFROMA_HARD EQU 04143H
  29+ 4CF3              PLY_AKG_PSES_MVFA_NOOVERFLOW EQU 04149H
  30+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTDATA EQU 0414DH
  31+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_1 EQU 0414DH
  32+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_1 EQU 0414FH
  33+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_2 EQU 0414FH
  34+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTINVERTEDVOLUME EQU 0414FH
  35+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTCURRENTSTEP EQU 04150H
  36+ 4CF3              PLY_AKG_CHANNEL1_SOUNDEFFECTSPEED EQU 04151H
  37+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_2 EQU 04155H
  38+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_3 EQU 04155H
  39+ 4CF3              PLY_AKG_CHANNEL2_SOUNDEFFECTDATA EQU 04155H
  40+ 4CF3              PLY_AKG_CHANNEL3_SOUNDEFFECTDATA EQU 0415DH
  41+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_3 EQU 04165H
  42+ 4CF3              PLY_AKG_INITDISARKGENERATEEXTERNALLABEL EQU 04165H
  43+ 4CF3              PLY_AKG_INIT EQU 04165H
  44+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_4 EQU 04165H
  45+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_5 EQU 04193H
  46+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_6 EQU 041A7H
  47+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_7 EQU 041B9H
  48+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_8 EQU 041D8H
  49+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL_LOOP EQU 041E5H
  50+ 4CF3              PLY_AKG_INIT_READWORDSANDFILL EQU 041EBH
  51+ 4CF3              PLY_AKG_INITTABLE0 EQU 041EEH
  52+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_9 EQU 041EEH
  53+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_9 EQU 04208H
  54+ 4CF3              PLY_AKG_INITTABLE0_END EQU 04208H
  55+ 4CF3              PLY_AKG_INITTABLE1 EQU 04208H
  56+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_10 EQU 04208H
  57+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_10 EQU 0420CH
  58+ 4CF3              PLY_AKG_INITTABLE1_END EQU 0420CH
  59+ 4CF3              PLY_AKG_INITTABLEORA EQU 0420CH
  60+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_11 EQU 0420CH
  61+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_11 EQU 04224H
  62+ 4CF3              PLY_AKG_INITTABLEORA_END EQU 04224H
  63+ 4CF3              PLY_AKG_STOPDISARKGENERATEEXTERNALLABEL EQU 04224H
  64+ 4CF3              PLY_AKG_STOP EQU 04224H
  65+ 4CF3              PLY_AKG_PLAYDISARKGENERATEEXTERNALLABEL EQU 04236H
  66+ 4CF3              PLY_AKG_PLAY EQU 04236H
  67+ 4CF3              PLY_AKG_TICKDECREASINGCOUNTER EQU 0423EH
  68+ 4CF3              PLY_AKG_PATTERNDECREASINGHEIGHT EQU 04244H
  69+ 4CF3              PLY_AKG_READLINKER EQU 04249H
  70+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_12 EQU 04249H
  71+ 4CF3              PLY_AKG_READLINKER_PTLINKER EQU 04249H
  72+ 4CF3              PLY_AKG_READLINKER_NOLOOP EQU 04254H
  73+ 4CF3              PLY_AKG_SETCURRENTLINEBEFOREREADLINE EQU 0428DH
  74+ 4CF3              PLY_AKG_READLINE EQU 04290H
  75+ 4CF3              PLY_AKG_SPEEDTRACK_WAITCOUNTER EQU 04290H
  76+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_13 EQU 04296H
  77+ 4CF3              PLY_AKG_SPEEDTRACK_PTTRACK EQU 04296H
  78+ 4CF3              PLY_AKG_SPEEDTRACK_NORMALVALUE EQU 042A3H
  79+ 4CF3              PLY_AKG_SPEEDTRACK_STOREPOINTERANDWAITCOUNTER EQU 042A7H
  80+ 4CF3              PLY_AKG_SPEEDTRACK_MUSTWAIT EQU 042AAH
  81+ 4CF3              PLY_AKG_SPEEDTRACK_END EQU 042ADH
  82+ 4CF3              PLY_AKG_EVENTTRACK_WAITCOUNTER EQU 042ADH
  83+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_14 EQU 042B3H
  84+ 4CF3              PLY_AKG_EVENTTRACK_PTTRACK EQU 042B3H
  85+ 4CF3              PLY_AKG_EVENTTRACK_NORMALVALUE EQU 042C0H
  86+ 4CF3              PLY_AKG_EVENTTRACK_STOREPOINTERANDWAITCOUNTER EQU 042C4H
  87+ 4CF3              PLY_AKG_EVENTTRACK_MUSTWAIT EQU 042C7H
  88+ 4CF3              PLY_AKG_EVENTTRACK_END EQU 042CAH
  89+ 4CF3              PLY_AKG_CHANNEL1_WAITCOUNTER EQU 042CAH
  90+ 4CF3              PLY_AKG_CHANNEL1_READTRACK EQU 042D6H
  91+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_15 EQU 042D6H
  92+ 4CF3              PLY_AKG_CHANNEL1_PTTRACK EQU 042D6H
  93+ 4CF3              PLY_AKG_CHANNEL1_SMALLWAIT EQU 042F1H
  94+ 4CF3              PLY_AKG_CHANNEL1_WAIT EQU 042FCH
  95+ 4CF3              PLY_AKG_CHANNEL1_SAMEINSTRUMENT EQU 04303H
  96+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_16 EQU 04303H
  97+ 4CF3              PLY_AKG_CHANNEL1_PTBASEINSTRUMENT EQU 04303H
  98+ 4CF3              PLY_AKG_CHANNEL1_NOTE EQU 0430CH
  99+ 4CF3              PLY_AKG_BASENOTEINDEX EQU 0430CH
 100+ 4CF3              PLY_AKG_CHANNEL1_AFTERNOTEKNOWN EQU 0430EH
 101+ 4CF3              PLY_AKG_CHANNEL1_TRANSPOSITION EQU 0430EH
 102+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_17 EQU 0431EH
 103+ 4CF3              PLY_AKG_INSTRUMENTSTABLE EQU 0431EH
 104+ 4CF3              PLY_AKG_CHANNEL1_AFTERINSTRUMENT EQU 04330H
 105+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTORIGINALSPEED EQU 04340H
 106+ 4CF3              PLY_AKG_CHANNEL1_BEFOREEND_STORECELLPOINTER EQU 04368H
 107+ 4CF3              PLY_AKG_CHANNEL1_READCELLEND EQU 0436BH
 108+ 4CF3              PLY_AKG_CHANNEL2_WAITCOUNTER EQU 0436BH
 109+ 4CF3              PLY_AKG_CHANNEL2_READTRACK EQU 04377H
 110+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_18 EQU 04377H
 111+ 4CF3              PLY_AKG_CHANNEL2_PTTRACK EQU 04377H
 112+ 4CF3              PLY_AKG_CHANNEL2_SMALLWAIT EQU 04392H
 113+ 4CF3              PLY_AKG_CHANNEL2_WAIT EQU 0439DH
 114+ 4CF3              PLY_AKG_CHANNEL2_SAMEINSTRUMENT EQU 043A4H
 115+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_19 EQU 043A4H
 116+ 4CF3              PLY_AKG_CHANNEL2_PTBASEINSTRUMENT EQU 043A4H
 117+ 4CF3              PLY_AKG_CHANNEL2_NOTE EQU 043ADH
 118+ 4CF3              PLY_AKG_CHANNEL2_AFTERNOTEKNOWN EQU 043B2H
 119+ 4CF3              PLY_AKG_CHANNEL2_TRANSPOSITION EQU 043B2H
 120+ 4CF3              PLY_AKG_CHANNEL2_AFTERINSTRUMENT EQU 043D4H
 121+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTORIGINALSPEED EQU 043E4H
 122+ 4CF3              PLY_AKG_CHANNEL2_BEFOREEND_STORECELLPOINTER EQU 0440CH
 123+ 4CF3              PLY_AKG_CHANNEL2_READCELLEND EQU 0440FH
 124+ 4CF3              PLY_AKG_CHANNEL3_WAITCOUNTER EQU 0440FH
 125+ 4CF3              PLY_AKG_CHANNEL3_READTRACK EQU 0441BH
 126+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_20 EQU 0441BH
 127+ 4CF3              PLY_AKG_CHANNEL3_PTTRACK EQU 0441BH
 128+ 4CF3              PLY_AKG_CHANNEL3_SMALLWAIT EQU 04436H
 129+ 4CF3              PLY_AKG_CHANNEL3_WAIT EQU 04441H
 130+ 4CF3              PLY_AKG_CHANNEL3_SAMEINSTRUMENT EQU 04448H
 131+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_21 EQU 04448H
 132+ 4CF3              PLY_AKG_CHANNEL3_PTBASEINSTRUMENT EQU 04448H
 133+ 4CF3              PLY_AKG_CHANNEL3_NOTE EQU 04451H
 134+ 4CF3              PLY_AKG_CHANNEL3_AFTERNOTEKNOWN EQU 04456H
 135+ 4CF3              PLY_AKG_CHANNEL3_TRANSPOSITION EQU 04456H
 136+ 4CF3              PLY_AKG_CHANNEL3_AFTERINSTRUMENT EQU 04478H
 137+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTORIGINALSPEED EQU 04488H
 138+ 4CF3              PLY_AKG_CHANNEL3_BEFOREEND_STORECELLPOINTER EQU 044B0H
 139+ 4CF3              PLY_AKG_CHANNEL3_READCELLEND EQU 044B3H
 140+ 4CF3              PLY_AKG_CURRENTSPEED EQU 044B3H
 141+ 4CF3              PLY_AKG_SETSPEEDBEFOREPLAYSTREAMS EQU 044B5H
 142+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_22 EQU 044B8H
 143+ 4CF3              PLY_AKG_CHANNEL1_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 044B8H
 144+ 4CF3              PLY_AKG_CHANNEL1_ISVOLUMESLIDE EQU 044BBH
 145+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_23 EQU 044BEH
 146+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDEVALUE EQU 044BEH
 147+ 4CF3              PLY_AKG_CHANNEL1_VOLUMENOTOVERFLOW EQU 044CAH
 148+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESETAGAIN EQU 044D1H
 149+ 4CF3              PLY_AKG_CHANNEL1_VOLUMESLIDE_END EQU 044D4H
 150+ 4CF3              PLY_AKG_CHANNEL1_ISARPEGGIOTABLE EQU 044DAH
 151+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_24 EQU 044DDH
 152+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE EQU 044DDH
 153+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_AFTERLOOPTEST EQU 044EBH
 154+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLECURRENTSTEP EQU 044F0H
 155+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 044FBH
 156+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLE_END EQU 044FEH
 157+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_25 EQU 044FEH
 158+ 4CF3              PLY_AKG_CHANNEL1_ISPITCHTABLE EQU 04501H
 159+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_26 EQU 04504H
 160+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE EQU 04504H
 161+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLECURRENTSTEP EQU 0450DH
 162+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_BEFOREEND_SAVESTEP EQU 04517H
 163+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLE_END EQU 0451AH
 164+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_27 EQU 0451AH
 165+ 4CF3              PLY_AKG_CHANNEL1_PITCH EQU 0451AH
 166+ 4CF3              PLY_AKG_CHANNEL1_ISPITCH EQU 0451DH
 167+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_28 EQU 04522H
 168+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACK EQU 04522H
 169+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKADDORSBC_16BITS EQU 04526H
 170+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALCOUNTER EQU 04528H
 171+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKDECIMALINSTR EQU 0452AH
 172+ 4CF3              PLY_AKG_CHANNEL1_PITCHTRACKINTEGERADDORSUB EQU 04531H
 173+ 4CF3              PLY_AKG_CHANNEL1_PITCHNOCARRY EQU 04532H
 174+ 4CF3              PLY_AKG_CHANNEL1_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04535H
 175+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDIRECTION EQU 04535H
 176+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_29 EQU 04551H
 177+ 4CF3              PLY_AKG_CHANNEL1_GLIDETOREACH EQU 04551H
 178+ 4CF3              PLY_AKG_CHANNEL1_GLIDEDOWNCHECK EQU 0455EH
 179+ 4CF3              PLY_AKG_CHANNEL1_GLIDEOVER EQU 04562H
 180+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_30 EQU 04572H
 181+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLESPEED EQU 04572H
 182+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOBASESPEED EQU 04573H
 183+ 4CF3              PLY_AKG_CHANNEL1_ARPEGGIOTABLEBASE EQU 04574H
 184+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_30 EQU 04576H
 185+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_31 EQU 04576H
 186+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLESPEED EQU 04576H
 187+ 4CF3              PLY_AKG_CHANNEL1_PITCHBASESPEED EQU 04577H
 188+ 4CF3              PLY_AKG_CHANNEL1_PITCHTABLEBASE EQU 04578H
 189+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_31 EQU 0457AH
 190+ 4CF3              PLY_AKG_CHANNEL1_AFTERARPEGGIOPITCHVARIABLES EQU 0457AH
 191+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_BEFOREEND EQU 0457AH
 192+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_32 EQU 0457AH
 193+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_SAVEHL EQU 0457AH
 194+ 4CF3              PLY_AKG_CHANNEL1_GLIDE_END EQU 0457DH
 195+ 4CF3              PLY_AKG_CHANNEL1_PITCH_END EQU 0457FH
 196+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_33 EQU 04587H
 197+ 4CF3              PLY_AKG_CHANNEL2_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04587H
 198+ 4CF3              PLY_AKG_CHANNEL2_ISVOLUMESLIDE EQU 0458AH
 199+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_34 EQU 0458DH
 200+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDEVALUE EQU 0458DH
 201+ 4CF3              PLY_AKG_CHANNEL2_VOLUMENOTOVERFLOW EQU 04599H
 202+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESETAGAIN EQU 045A0H
 203+ 4CF3              PLY_AKG_CHANNEL2_VOLUMESLIDE_END EQU 045A3H
 204+ 4CF3              PLY_AKG_CHANNEL2_ISARPEGGIOTABLE EQU 045A9H
 205+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_35 EQU 045ACH
 206+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE EQU 045ACH
 207+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_AFTERLOOPTEST EQU 045BAH
 208+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLECURRENTSTEP EQU 045BFH
 209+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 045CAH
 210+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLE_END EQU 045CDH
 211+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_36 EQU 045CDH
 212+ 4CF3              PLY_AKG_CHANNEL2_ISPITCHTABLE EQU 045D0H
 213+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_37 EQU 045D3H
 214+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE EQU 045D3H
 215+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLECURRENTSTEP EQU 045DCH
 216+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_BEFOREEND_SAVESTEP EQU 045E6H
 217+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLE_END EQU 045E9H
 218+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_38 EQU 045E9H
 219+ 4CF3              PLY_AKG_CHANNEL2_PITCH EQU 045E9H
 220+ 4CF3              PLY_AKG_CHANNEL2_ISPITCH EQU 045ECH
 221+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_39 EQU 045F1H
 222+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACK EQU 045F1H
 223+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKADDORSBC_16BITS EQU 045F5H
 224+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALCOUNTER EQU 045F7H
 225+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKDECIMALINSTR EQU 045F9H
 226+ 4CF3              PLY_AKG_CHANNEL2_PITCHTRACKINTEGERADDORSUB EQU 04600H
 227+ 4CF3              PLY_AKG_CHANNEL2_PITCHNOCARRY EQU 04601H
 228+ 4CF3              PLY_AKG_CHANNEL2_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 04604H
 229+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDIRECTION EQU 04604H
 230+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_40 EQU 04620H
 231+ 4CF3              PLY_AKG_CHANNEL2_GLIDETOREACH EQU 04620H
 232+ 4CF3              PLY_AKG_CHANNEL2_GLIDEDOWNCHECK EQU 0462DH
 233+ 4CF3              PLY_AKG_CHANNEL2_GLIDEOVER EQU 04631H
 234+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_41 EQU 04641H
 235+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLESPEED EQU 04641H
 236+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOBASESPEED EQU 04642H
 237+ 4CF3              PLY_AKG_CHANNEL2_ARPEGGIOTABLEBASE EQU 04643H
 238+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_41 EQU 04645H
 239+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_42 EQU 04645H
 240+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLESPEED EQU 04645H
 241+ 4CF3              PLY_AKG_CHANNEL2_PITCHBASESPEED EQU 04646H
 242+ 4CF3              PLY_AKG_CHANNEL2_PITCHTABLEBASE EQU 04647H
 243+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_42 EQU 04649H
 244+ 4CF3              PLY_AKG_CHANNEL2_AFTERARPEGGIOPITCHVARIABLES EQU 04649H
 245+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_BEFOREEND EQU 04649H
 246+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_43 EQU 04649H
 247+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_SAVEHL EQU 04649H
 248+ 4CF3              PLY_AKG_CHANNEL2_GLIDE_END EQU 0464CH
 249+ 4CF3              PLY_AKG_CHANNEL2_PITCH_END EQU 0464EH
 250+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_44 EQU 04656H
 251+ 4CF3              PLY_AKG_CHANNEL3_INVERTEDVOLUMEINTEGERANDDECIMAL EQU 04656H
 252+ 4CF3              PLY_AKG_CHANNEL3_ISVOLUMESLIDE EQU 04659H
 253+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_45 EQU 0465CH
 254+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDEVALUE EQU 0465CH
 255+ 4CF3              PLY_AKG_CHANNEL3_VOLUMENOTOVERFLOW EQU 04668H
 256+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESETAGAIN EQU 0466FH
 257+ 4CF3              PLY_AKG_CHANNEL3_VOLUMESLIDE_END EQU 04672H
 258+ 4CF3              PLY_AKG_CHANNEL3_ISARPEGGIOTABLE EQU 04678H
 259+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_46 EQU 0467BH
 260+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE EQU 0467BH
 261+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_AFTERLOOPTEST EQU 04689H
 262+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLECURRENTSTEP EQU 0468EH
 263+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_BEFOREEND_SAVESTEP EQU 04699H
 264+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLE_END EQU 0469CH
 265+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_47 EQU 0469CH
 266+ 4CF3              PLY_AKG_CHANNEL3_ISPITCHTABLE EQU 0469FH
 267+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_48 EQU 046A2H
 268+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE EQU 046A2H
 269+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLECURRENTSTEP EQU 046ABH
 270+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_BEFOREEND_SAVESTEP EQU 046B5H
 271+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLE_END EQU 046B8H
 272+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_49 EQU 046B8H
 273+ 4CF3              PLY_AKG_CHANNEL3_PITCH EQU 046B8H
 274+ 4CF3              PLY_AKG_CHANNEL3_ISPITCH EQU 046BBH
 275+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_50 EQU 046C0H
 276+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACK EQU 046C0H
 277+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKADDORSBC_16BITS EQU 046C4H
 278+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALCOUNTER EQU 046C6H
 279+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKDECIMALINSTR EQU 046C8H
 280+ 4CF3              PLY_AKG_CHANNEL3_PITCHTRACKINTEGERADDORSUB EQU 046CFH
 281+ 4CF3              PLY_AKG_CHANNEL3_PITCHNOCARRY EQU 046D0H
 282+ 4CF3              PLY_AKG_CHANNEL3_SOUNDSTREAM_RELATIVEMODIFIERADDRESS EQU 046D3H
 283+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDIRECTION EQU 046D3H
 284+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_51 EQU 046EFH
 285+ 4CF3              PLY_AKG_CHANNEL3_GLIDETOREACH EQU 046EFH
 286+ 4CF3              PLY_AKG_CHANNEL3_GLIDEDOWNCHECK EQU 046FCH
 287+ 4CF3              PLY_AKG_CHANNEL3_GLIDEOVER EQU 04700H
 288+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_52 EQU 04710H
 289+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLESPEED EQU 04710H
 290+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOBASESPEED EQU 04711H
 291+ 4CF3              PLY_AKG_CHANNEL3_ARPEGGIOTABLEBASE EQU 04712H
 292+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_52 EQU 04714H
 293+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_53 EQU 04714H
 294+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLESPEED EQU 04714H
 295+ 4CF3              PLY_AKG_CHANNEL3_PITCHBASESPEED EQU 04715H
 296+ 4CF3              PLY_AKG_CHANNEL3_PITCHTABLEBASE EQU 04716H
 297+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_53 EQU 04718H
 298+ 4CF3              PLY_AKG_CHANNEL3_AFTERARPEGGIOPITCHVARIABLES EQU 04718H
 299+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_BEFOREEND EQU 04718H
 300+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_54 EQU 04718H
 301+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_SAVEHL EQU 04718H
 302+ 4CF3              PLY_AKG_CHANNEL3_GLIDE_END EQU 0471BH
 303+ 4CF3              PLY_AKG_CHANNEL3_PITCH_END EQU 0471DH
 304+ 4CF3              PLY_AKG_CHANNEL1_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04729H
 305+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_55 EQU 04729H
 306+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTPITCH EQU 04729H
 307+ 4CF3              PLY_AKG_CHANNEL1_TRACKNOTE EQU 0472CH
 308+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTARPNOTE EQU 0472EH
 309+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSTEP EQU 04734H
 310+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_56 EQU 04737H
 311+ 4CF3              PLY_AKG_CHANNEL1_PTINSTRUMENT EQU 04737H
 312+ 4CF3              PLY_AKG_CHANNEL1_GENERATEDCURRENTINVERTEDVOLUME EQU 0473AH
 313+ 4CF3              PLY_AKG_CHANNEL1_INSTRUMENTSPEED EQU 04743H
 314+ 4CF3              PLY_AKG_CHANNEL1_SETINSTRUMENTSTEP EQU 0474BH
 315+ 4CF3              PLY_AKG_CHANNEL2_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04758H
 316+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_57 EQU 04758H
 317+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTPITCH EQU 04758H
 318+ 4CF3              PLY_AKG_CHANNEL2_TRACKNOTE EQU 0475BH
 319+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTARPNOTE EQU 0475DH
 320+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSTEP EQU 04763H
 321+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_58 EQU 04766H
 322+ 4CF3              PLY_AKG_CHANNEL2_PTINSTRUMENT EQU 04766H
 323+ 4CF3              PLY_AKG_CHANNEL2_GENERATEDCURRENTINVERTEDVOLUME EQU 04769H
 324+ 4CF3              PLY_AKG_CHANNEL2_INSTRUMENTSPEED EQU 04772H
 325+ 4CF3              PLY_AKG_CHANNEL2_SETINSTRUMENTSTEP EQU 0477AH
 326+ 4CF3              PLY_AKG_CHANNEL3_PLAYINSTRUMENT_RELATIVEMODIFIERADDRESS EQU 04788H
 327+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_59 EQU 04788H
 328+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTPITCH EQU 04788H
 329+ 4CF3              PLY_AKG_CHANNEL3_TRACKNOTE EQU 0478BH
 330+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTARPNOTE EQU 0478DH
 331+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSTEP EQU 04793H
 332+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_60 EQU 04796H
 333+ 4CF3              PLY_AKG_CHANNEL3_PTINSTRUMENT EQU 04796H
 334+ 4CF3              PLY_AKG_CHANNEL3_GENERATEDCURRENTINVERTEDVOLUME EQU 04799H
 335+ 4CF3              PLY_AKG_CHANNEL3_INSTRUMENTSPEED EQU 047A2H
 336+ 4CF3              PLY_AKG_CHANNEL3_SETINSTRUMENTSTEP EQU 047AAH
 337+ 4CF3              PLY_AKG_SENDPSGREGISTERS EQU 047B9H
 338+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_61 EQU 047C1H
 339+ 4CF3              PLY_AKG_PSGREG01_INSTR EQU 047C1H
 340+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_62 EQU 047D1H
 341+ 4CF3              PLY_AKG_PSGREG23_INSTR EQU 047D1H
 342+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_63 EQU 047E2H
 343+ 4CF3              PLY_AKG_PSGREG45_INSTR EQU 047E2H
 344+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_64 EQU 047F3H
 345+ 4CF3              PLY_AKG_PSGREG6_8_INSTR EQU 047F3H
 346+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_65 EQU 04804H
 347+ 4CF3              PLY_AKG_PSGREG9_10_INSTR EQU 04804H
 348+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_66 EQU 04815H
 349+ 4CF3              PLY_AKG_PSGHARDWAREPERIOD_INSTR EQU 04815H
 350+ 4CF3              PLY_AKG_PSGREG13_OLDVALUE EQU 0482AH
 351+ 4CF3              PLY_AKG_RETRIG EQU 0482CH
 352+ 4CF3              PLY_AKG_PSGREG13_INSTR EQU 0482EH
 353+ 4CF3              PLY_AKG_PSGREG13_END EQU 0483DH
 354+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_67 EQU 0483DH
 355+ 4CF3              PLY_AKG_SAVESP EQU 0483DH
 356+ 4CF3              PLY_AKG_CHANNEL1_MAYBEEFFECTS EQU 04841H
 357+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTS EQU 04849H
 358+ 4CF3              PLY_AKG_CHANNEL1_READEFFECTSEND EQU 04856H
 359+ 4CF3              PLY_AKG_CHANNEL2_MAYBEEFFECTS EQU 04856H
 360+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTS EQU 0485EH
 361+ 4CF3              PLY_AKG_CHANNEL2_READEFFECTSEND EQU 0486BH
 362+ 4CF3              PLY_AKG_CHANNEL3_MAYBEEFFECTS EQU 0486BH
 363+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTS EQU 04873H
 364+ 4CF3              PLY_AKG_CHANNEL3_READEFFECTSEND EQU 0487EH
 365+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS EQU 0487EH
 366+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_68 EQU 0488DH
 367+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS1 EQU 0488DH
 368+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTADDRESSKNOWN EQU 04894H
 369+ 4CF3              PLY_AKG_CHANNEL_RE_EFFECTRETURN EQU 048A4H
 370+ 4CF3              PLY_AKG_CHANNEL_RE_READNEXTEFFECTINBLOCK EQU 048A4H
 371+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_69 EQU 048ABH
 372+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_ENDJUMP EQU 048ABH
 373+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_RELATIVEADDRESS EQU 048AEH
 374+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_70 EQU 048B7H
 375+ 4CF3              PLY_AKG_CHANNEL_READEFFECTS_EFFECTBLOCKS2 EQU 048B7H
 376+ 4CF3              PLY_AKG_READINSTRUMENTCELL EQU 048BDH
 377+ 4CF3              PLY_AKG_NOSOFTNOHARD EQU 048CAH
 378+ 4CF3              PLY_AKG_NSNH_NONOISE EQU 048DFH
 379+ 4CF3              PLY_AKG_SOFT EQU 048E2H
 380+ 4CF3              PLY_AKG_SOFTONLY_HARDONLY_TESTSIMPLE_COMMON EQU 048E9H
 381+ 4CF3              PLY_AKG_S_NOTSIMPLE EQU 048F1H
 382+ 4CF3              PLY_AKG_S_AFTERSIMPLETEST EQU 048F4H
 383+ 4CF3              PLY_AKG_HARDTOSOFT EQU 04901H
 384+ 4CF3              PLY_AKG_HS_JUMPRATIO EQU 0490CH
 385+ 4CF3              PLY_AKG_SH_NOSOFTWAREPITCHSHIFT EQU 04939H
 386+ 4CF3              PLY_AKG_ENDWITHOUTLOOP EQU 0493BH
 387+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_71 EQU 0493BH
 388+ 4CF3              PLY_AKG_EMPTYINSTRUMENTDATAPT EQU 0493BH
 389+ 4CF3              PLY_AKG_STH_OR_ENDWITHOUTLOOP EQU 04943H
 390+ 4CF3              PLY_AKG_SH_JUMPRATIO EQU 04950H
 391+ 4CF3              PLY_AKG_SH_JUMPRATIOEND EQU 04971H
 392+ 4CF3              PLY_AKG_SH_NOHARDWAREPITCHSHIFT EQU 04980H
 393+ 4CF3              PLY_AKG_S_OR_H_OR_SAH_OR_ENDWITHLOOP EQU 04986H
 394+ 4CF3              PLY_AKG_H_OR_ENDWITHLOOP EQU 049A0H
 395+ 4CF3              PLY_AKG_H_RETRIGEND EQU 049B2H
 396+ 4CF3              PLY_AKG_H_AFTERRETRIG EQU 049B3H
 397+ 4CF3              PLY_AKG_ENDWITHLOOP EQU 049C5H
 398+ 4CF3              PLY_AKG_S_OR_H_CHECKIFSIMPLEFIRST_CALCULATEPERIOD EQU 049CCH
 399+ 4CF3              PLY_AKG_S_OR_H_NEXTBYTE EQU 049E2H
 400+ 4CF3              PLY_AKG_S_OR_H_AFTERARPEGGIO EQU 049F0H
 401+ 4CF3              PLY_AKG_S_OR_H_AFTERPITCH EQU 04A00H
 402+ 4CF3              PLY_AKG_S_OR_H_FORCEDPERIOD EQU 04A0EH
 403+ 4CF3              PLY_AKG_STOH_HTOS_SANDH_COMMON EQU 04A1DH
 404+ 4CF3              PLY_AKG_SHOHS_RETRIGEND EQU 04A2CH
 405+ 4CF3              PLY_AKG_SHOHS_AFTERRETRIG EQU 04A2DH
 406+ 4CF3              PLY_AKG_SHOHS_AFTERNOISE EQU 04A3FH
 407+ 4CF3              PLY_AKG_EFFECTTABLE EQU 04A4DH
 408+ 4CF3              PLY_AKG_DISARKPOINTERREGIONSTART_72 EQU 04A4DH
 409+ 4CF3              PLY_AKG_DISARKPOINTERREGIONEND_72 EQU 04A71H
 410+ 4CF3              PLY_AKG_EFFECT_RESETFULLVOLUME EQU 04A71H
 411+ 4CF3              PLY_AKG_EFFECT_RESET EQU 04A74H
 412+ 4CF3              PLY_AKG_EFFECT_RESETVOLUME_AFTERREADING EQU 04A76H
 413+ 4CF3              PLY_AKG_EFFECT_VOLUME EQU 04A91H
 414+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLE EQU 04A9DH
 415+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_73 EQU 04AA3H
 416+ 4CF3              PLY_AKG_ARPEGGIOSTABLE EQU 04AA3H
 417+ 4CF3              PLY_AKG_EFFECT_ARPEGGIOTABLESTOP EQU 04ACAH
 418+ 4CF3              PLY_AKG_EFFECT_PITCHTABLE EQU 04AD1H
 419+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_74 EQU 04AD7H
 420+ 4CF3              PLY_AKG_PITCHESTABLE EQU 04AD7H
 421+ 4CF3              PLY_AKG_EFFECT_PITCHTABLESTOP EQU 04AFEH
 422+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDE EQU 04B05H
 423+ 4CF3              PLY_AKG_EFFECT_VOLUMESLIDESTOP EQU 04B16H
 424+ 4CF3              PLY_AKG_EFFECT_PITCHDOWN EQU 04B1DH
 425+ 4CF3              PLY_AKG_EFFECT_PITCHUPDOWN_COMMON EQU 04B2DH
 426+ 4CF3              PLY_AKG_EFFECT_PITCHUP EQU 04B42H
 427+ 4CF3              PLY_AKG_EFFECT_PITCHSTOP EQU 04B54H
 428+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTE EQU 04B5BH
 429+ 4CF3              PLY_AKG_DISARKFORCENONREFERENCEDURING3_75 EQU 04B85H
 430+ 4CF3              PLY_AKG_EFFECT_GLIDEWITHNOTESAVEDE EQU 04B85H
 431+ 4CF3              PLY_AKG_EFFECT_GLIDE_READSPEED EQU 04B9EH
 432+ 4CF3              PLY_AKG_EFFECT_GLIDESPEED EQU 04B9EH
 433+ 4CF3              PLY_AKG_EFFECT_GLIDE_PITCHDOWN EQU 04BB0H
 434+ 4CF3              PLY_AKG_EFFECT_LEGATO EQU 04BC6H
 435+ 4CF3              PLY_AKG_EFFECT_FORCEINSTRUMENTSPEED EQU 04BDAH
 436+ 4CF3              PLY_AKG_EFFECT_FORCEARPEGGIOSPEED EQU 04BE2H
 437+ 4CF3              PLY_AKG_EFFECT_FORCEPITCHSPEED EQU 04BEAH
 438+ 4CF3              PLY_AKG_DISARKBYTEREGIONSTART_76 EQU 04BF2H
 439+ 4CF3              PLY_AKG_EVENT EQU 04BF2H
 440+ 4CF3              PLY_AKG_DISARKBYTEREGIONEND_76 EQU 04BF3H
 441+ 4CF3              PLY_AKG_PERIODTABLE EQU 04BF3H
 442+ 4CF3              PLY_AKG_DISARKWORDREGIONSTART_77 EQU 04BF3H
 443+ 4CF3              PLY_AKG_DISARKWORDREGIONEND_77 EQU 04CF3H
 444+ 4CF3              PLY_AKG_PERIODTABLE_END EQU 04CF3H
 445+ 4CF3              PLY_AKG_END EQU 04CF3H
 446+ 4CF3              MAIN_PLAYER_END EQU 04CF3H
 447+ 4CF3              TESTEREND EQU 04CF3H
 448+ 4CF3
# file closed: ./symbol/AKG.sym
 129  4CF3               ENDIF
 130  4CF3
 131  4CF3               INCLUDE "VBLANK.asm"
# file opened: asm\VBLANK.asm
   1+ 4CF3              ORIG.HTIMI:
   2+ 4CF3 00 00 00 00  	DB 0, 0, 0, 0, 0
   2+ 4CF7 00
   3+ 4CF8               EXPORT ORIG.HTIMI
   4+ 4CF8
   5+ 4CF8              ; *******************************************************************************************************
   6+ 4CF8              ; interrupt handler when page 0 enabled
   7+ 4CF8              ; we are here only if one of the extended basic commands have paged in page 0
   8+ 4CF8              ; which means we arrived from BASIC so page 2 is already good
   9+ 4CF8              VBLANK:
  10+ 4CF8              	EXPORT VBLANK
  11+ 4CF8
  12+ 4CF8 F5               PUSH AF
  13+ 4CF9              	; is VDP originator ?
  14+ 4CF9 DB 99        	IN	A, (099H)
  15+ 4CFB A7           	AND	A
  16+ 4CFC F2 2A 4D     	JP P, .EXIT
  17+ 4CFF
  18+ 4CFF               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  19+ 4CFF C5               PUSH BC
  20+ 4D00 D5               PUSH DE
  21+ 4D01 E5               PUSH HL
  22+ 4D02 08               EX AF, AF'
  23+ 4D03 D9               EXX
  24+ 4D04 F5               PUSH AF
  25+ 4D05 C5               PUSH BC
  26+ 4D06 D5               PUSH DE
  27+ 4D07 E5               PUSH HL
  28+ 4D08 DD E5            PUSH IX
  29+ 4D0A FD E5            PUSH IY
  30+ 4D0C
  31+ 4D0C               IF (SPRITE_CMDS == 1)
  32+ 4D0C CD 64 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  33+ 4D0F               ENDIF
  34+ 4D0F
  35+ 4D0F               IF (SOUND_CMDS == 1)
  36+ 4D0F 3A C4 58     	LD A, (SOUND_ENABLED)
  37+ 4D12 B7           	OR A
  38+ 4D13 C4 36 42     	CALL NZ,PLY_AKG_PLAY
  39+ 4D16               ENDIF
  40+ 4D16
  41+ 4D16                  ; increase JIFFY
  42+ 4D16 2A 9E FC         LD HL,(JIFFY)
  43+ 4D19 23               INC HL
  44+ 4D1A 22 9E FC         LD (JIFFY),HL
  45+ 4D1D
  46+ 4D1D FD E1            POP IY
  47+ 4D1F DD E1            POP IX
  48+ 4D21 E1               POP HL
  49+ 4D22 D1               POP DE
  50+ 4D23 C1               POP BC
  51+ 4D24 F1               POP AF
  52+ 4D25 08               EX AF, AF'
  53+ 4D26 D9               EXX
  54+ 4D27 E1               POP HL
  55+ 4D28 D1               POP DE
  56+ 4D29 C1               POP BC
  57+ 4D2A               ENDIF
  58+ 4D2A
  59+ 4D2A              .EXIT:
  60+ 4D2A F1           	POP AF
  61+ 4D2B FB           	EI
  62+ 4D2C ED 4D        	RETI
  63+ 4D2E              ; *******************************************************************************************************
  64+ 4D2E
  65+ 4D2E              ; *******************************************************************************************************
  66+ 4D2E              ; H.TIMI function
  67+ 4D2E              ; we can end up here from anywhere so page in both page 0 and 2
  68+ 4D2E              MBGE_HTIMI:
  69+ 4D2E               EXPORT MBGE_HTIMI
  70+ 4D2E
  71+ 4D2E               IF (SOUND_CMDS + SPRITE_CMDS > 0)
  72+ 4D2E
  73+ 4D2E F5           	PUSH AF
  74+ 4D2F
  75+ 4D2F              	; enable page 2
  76+ 4D2F 3E 02            LD A, 2
  77+ 4D31 CD 82 66         CALL GET_PAGE_INFO
  78+ 4D34 C5               PUSH BC
  79+ 4D35 D5               PUSH DE
  80+ 4D36 3A 43 F3         LD A, (RAMAD2)
  81+ 4D39 26 80            LD H, 080H
  82+ 4D3B CD C9 66         CALL LOCAL_ENASLT
  83+ 4D3E              	; enable page 0
  84+ 4D3E AF               XOR A
  85+ 4D3F CD 82 66         CALL GET_PAGE_INFO
  86+ 4D42 C5               PUSH BC
  87+ 4D43 D5               PUSH DE
  88+ 4D44 3A 41 F3         LD A, (RAMAD0)
  89+ 4D47 26 00            LD H, 0
  90+ 4D49 CD C9 66         CALL LOCAL_ENASLT
  91+ 4D4C
  92+ 4D4C               IF (SPRITE_CMDS == 1)
  93+ 4D4C CD 64 4D     	CALL PROCESS_SPRITES_AND_ANIMATIONS
  94+ 4D4F               ENDIF
  95+ 4D4F
  96+ 4D4F               IF (SOUND_CMDS == 1)
  97+ 4D4F 3A C4 58     	LD A, (SOUND_ENABLED)
  98+ 4D52 B7           	OR A
  99+ 4D53 C4 36 42     	CALL NZ,PLY_AKG_PLAY
 100+ 4D56               ENDIF
 101+ 4D56
 102+ 4D56              	; restore page 0
 103+ 4D56 D1               POP DE
 104+ 4D57 C1               POP BC
 105+ 4D58 CD B9 66         CALL RESTORE_PAGE_INFO
 106+ 4D5B              	; restore page 2
 107+ 4D5B D1               POP DE
 108+ 4D5C C1               POP BC
 109+ 4D5D CD B9 66         CALL RESTORE_PAGE_INFO
 110+ 4D60
 111+ 4D60 F1           	POP AF
 112+ 4D61               ENDIF
 113+ 4D61 C3 F3 4C     	JP ORIG.HTIMI
 114+ 4D64              ; *******************************************************************************************************
 115+ 4D64
 116+ 4D64              ; *******************************************************************************************************
 117+ 4D64              ; function checks if the sprite system is initialized and what screen mode we are running
 118+ 4D64              ; also checks if some VRAM modifying command is running
 119+ 4D64              ; when that checks out calls sprite updates and animation processing
 120+ 4D64              ; if in an unsupported mode disables sprite handling
 121+ 4D64              PROCESS_SPRITES_AND_ANIMATIONS:
 122+ 4D64              	; check if initialized
 123+ 4D64 3A 86 4D     	LD A, (SPRATR_INIT_STATUS)
 124+ 4D67 B7           	OR A
 125+ 4D68 C8           	RET Z
 126+ 4D69              	; check screen mode
 127+ 4D69 3A AF FC     	LD A, (SCRMOD)
 128+ 4D6C 3D           	DEC A
 129+ 4D6D 28 08        	JR Z, .L0 ; screen 1
 130+ 4D6F 3D           	DEC A
 131+ 4D70 28 05            JR Z, .L0 ; screen 2
 132+ 4D72              	; unsupported screen mode, disable
 133+ 4D72 AF               XOR A
 134+ 4D73 32 86 4D         LD (SPRATR_INIT_STATUS),A
 135+ 4D76 C9               RET
 136+ 4D77              .L0:
 137+ 4D77                  ; check if anyone else is working with VRAM
 138+ 4D77 3A 6B 64         LD A,(VRAM_UPDATE_IN_PROGRESS)
 139+ 4D7A B7               OR A
 140+ 4D7B C0               RET NZ
 141+ 4D7C
 142+ 4D7C CD 9C 4D         CALL SPRATR_UPDATE
 143+ 4D7F
 144+ 4D7F               IF (ANIM_CMDS == 1)
 145+ 4D7F CD 7D 55         CALL PROCESS_ANIMATIONS
 146+ 4D82 CD 48 57         CALL PROCESS_AUTOSGAMS
 147+ 4D85               ENDIF
 148+ 4D85 C9               RET
 149+ 4D86              ; *******************************************************************************************************
# file closed: asm\VBLANK.asm
 132  4D86
 133  4D86               IF (SPRITE_CMDS == 1)
 134  4D86               INCLUDE "SPRITES.asm"
# file opened: asm\SPRITES.asm
   1+ 4D86              ; commands and variables related to sprites
   2+ 4D86
   3+ 4D86              SPRATR_INIT_STATUS:
   4+ 4D86 00            DB 0
   5+ 4D87              SPRATR_UPDATE_FLAG:
   6+ 4D87 00 00         DW 0
   7+ 4D89              SPRATR_DATA:
   8+ 4D89 00 00         DW 0
   9+ 4D8B              SPRFLICKER_ENABLED:
  10+ 4D8B 00            DB 0
  11+ 4D8C              ; to support sprite flicker
  12+ 4D8C              FLICKER:
  13+ 4D8C 00            DB 0
  14+ 4D8D              NUM_SPRITES_HANDLED:
  15+ 4D8D 20            DB 32
  16+ 4D8E
  17+ 4D8E              ; to temporarily store stack pointer
  18+ 4D8E              TMPSP:
  19+ 4D8E 00 00         DW 0
  20+ 4D90
  21+ 4D90              ; *******************************************************************************************************
  22+ 4D90              ; helper function gets pointer to n-th entry in sprite attributes
  23+ 4D90              ; changes HL,DE
  24+ 4D90              GETnthSPRATTR:
  25+ 4D90 26 00            LD H,0
  26+ 4D92 6F               LD L,A
  27+ 4D93 CD 7E 66         CALL HLx8
  28+ 4D96 ED 5B 89 4D      LD DE,(SPRATR_DATA)
  29+ 4D9A 19               ADD HL,DE
  30+ 4D9B C9               RET
  31+ 4D9C              ; *******************************************************************************************************
  32+ 4D9C
  33+ 4D9C              ; *******************************************************************************************************
  34+ 4D9C              ; function updates sprite attribute table in VRAM based on buffer of the form with rotating for flicker
  35+ 4D9C              ; struct {
  36+ 4D9C              ; DW y
  37+ 4D9C              ; DW x
  38+ 4D9C              ; DW pattern (0-63)
  39+ 4D9C              ; DW color
  40+ 4D9C              ; } [32]
  41+ 4D9C              ; will hide sprites whose location is outside of visible area
  42+ 4D9C              ; triggered by value in (SPRATR_UPDATE_FLAG) != 0 and after being done resets it to 0
  43+ 4D9C              ; modifies AF, AF', BC, DE, HL, IX
  44+ 4D9C              SPRATR_UPDATE:
  45+ 4D9C              	; check if update requested
  46+ 4D9C 2A 87 4D     	LD HL, (SPRATR_UPDATE_FLAG)
  47+ 4D9F 7E           	LD A, (HL)
  48+ 4DA0 B7           	OR A
  49+ 4DA1 C8           	RET Z
  50+ 4DA2
  51+ 4DA2 DD 21 8D 4D  	LD IX,NUM_SPRITES_HANDLED
  52+ 4DA6 DD 46 00     	LD B, (IX) ; sprite number
  53+ 4DA9 0E 98        	LD C, #98 ; register for vdp data output
  54+ 4DAB              	; set VDP address
  55+ 4DAB 3A AF FC         LD A,(SCRMOD)
  56+ 4DAE 3D               DEC A
  57+ 4DAF 20 05            JR NZ,.L4
  58+ 4DB1 2A C3 F3         LD HL, (T32ATR)
  59+ 4DB4 18 03            JR .L5
  60+ 4DB6              .L4:
  61+ 4DB6 2A CD F3         LD HL, (GRPATR)
  62+ 4DB9              .L5:
  63+ 4DB9 3A 8B 4D     	LD A, (SPRFLICKER_ENABLED)
  64+ 4DBC B7           	OR A
  65+ 4DBD 28 03        	JR Z, .L3
  66+ 4DBF 3A 8C 4D     	LD A, (FLICKER)
  67+ 4DC2              .L3:
  68+ 4DC2 5F           	LD E, A
  69+ 4DC3 08           	EX AF, AF'
  70+ 4DC4 7B           	LD A, E
  71+ 4DC5 87           	ADD A, A
  72+ 4DC6 87           	ADD A, A
  73+ 4DC7 16 00        	LD D, 0
  74+ 4DC9 5F           	LD E, A
  75+ 4DCA 19           	ADD HL, DE
  76+ 4DCB CD 5F 66     	CALL SETWRT_LOCAL_WRITE
  77+ 4DCE ED 73 8E 4D  	LD (TMPSP), SP
  78+ 4DD2 ED 7B 89 4D  	LD SP, (SPRATR_DATA)
  79+ 4DD6
  80+ 4DD6              .LOOP:
  81+ 4DD6 E1           	POP HL
  82+ 4DD7 24           	INC H
  83+ 4DD8 28 0D        	JR Z, .L1 ; negative number between -256 and -1
  84+ 4DDA 25           	DEC H
  85+ 4DDB 20 15        	JR NZ, .OUT3 ; sprite vertically can't be visible
  86+ 4DDD 7D           	LD A, L
  87+ 4DDE FE C0        	CP 192
  88+ 4DE0 30 10        	JR NC, .OUT3
  89+ 4DE2 3D           	DEC A ; due to VDP rule that top of screen is -1
  90+ 4DE3 57           	LD D, A
  91+ 4DE4 C3 0B 4E     	JP .X
  92+ 4DE7              .L1:
  93+ 4DE7 7D           	LD A, L
  94+ 4DE8 C6 10        	ADD 16
  95+ 4DEA FA F2 4D     	JP M, .OUT3 ; below -16
  96+ 4DED 2D           	DEC L ; due to VDP rule that top of screen is -1
  97+ 4DEE 55           	LD D, L
  98+ 4DEF C3 0B 4E     	JP .X
  99+ 4DF2              .OUT3:
 100+ 4DF2 E1           	POP HL ; skip x value
 101+ 4DF3              .OUT2:
 102+ 4DF3 E1           	POP HL ; skip pattern
 103+ 4DF4 E1           	POP HL ; skip color
 104+ 4DF5 3E D1        	LD A, #D1
 105+ 4DF7 ED 79        	OUT (C), A ; sprite hidden
 106+ 4DF9 00          > NOP
 106+ 4DFA 00          > NOP
 106+ 4DFB 00          > NOP
 107+ 4DFC ED 79        	OUT (C), A ; value unimportant
 108+ 4DFE 00          > NOP
 108+ 4DFF 00          > NOP
 108+ 4E00 00          > NOP
 109+ 4E01 ED 79        	OUT (C), A ; value unimportant
 110+ 4E03 00          > NOP
 110+ 4E04 00          > NOP
 110+ 4E05 00          > NOP
 111+ 4E06 ED 79        	OUT (C), A ; value unimportant
 112+ 4E08 C3 36 4E     	JP .NEXT
 113+ 4E0B              .X:
 114+ 4E0B E1           	POP HL
 115+ 4E0C 24           	INC H
 116+ 4E0D 28 08        	JR Z, .L2
 117+ 4E0F 25           	DEC H
 118+ 4E10 20 E1        	JR NZ, .OUT2
 119+ 4E12 1E 00        	LD E, 0 ; EC bit
 120+ 4E14 C3 20 4E     	JP .XY
 121+ 4E17              .L2:
 122+ 4E17 7D           	LD A, L
 123+ 4E18 C6 20        	ADD 32
 124+ 4E1A FA F3 4D     	JP M, .OUT2
 125+ 4E1D 6F           	LD L, A
 126+ 4E1E 1E 80        	LD E, #80
 127+ 4E20              .XY:
 128+ 4E20 ED 51        	OUT (C), D
 129+ 4E22 3A E0 F3     	LD A, (REG1SAV)
 130+ 4E25 E6 02        	AND 2
 131+ 4E27 ED 69        	OUT (C), L
 132+ 4E29 E1           	POP HL ; pattern
 133+ 4E2A 7D           	LD A, L
 134+ 4E2B 28 02        	JR Z, .SMALLSPRITES
 135+ 4E2D 87           	ADD A, A
 136+ 4E2E 87           	ADD A, A ; needs to go at 4x
 137+ 4E2F              .SMALLSPRITES:
 138+ 4E2F D3 98        	OUT (#98), A
 139+ 4E31 E1           	POP HL ; color
 140+ 4E32 7D           	LD A, L
 141+ 4E33 B3           	OR E
 142+ 4E34 D3 98        	OUT (#98), A
 143+ 4E36              .NEXT:
 144+ 4E36 08           	EX AF, AF'
 145+ 4E37 3C           	INC A ; increase current sprite
 146+ 4E38 DD BE 00     	CP (IX) ; compare to maximum handled
 147+ 4E3B C2 5B 4E     	JP NZ, .NEXT2 ; continue if not over
 148+ 4E3E AF           	XOR A ; back to zero
 149+ 4E3F 08           	EX AF, AF'
 150+ 4E40 3A AF FC         LD A,(SCRMOD)
 151+ 4E43 3D               DEC A
 152+ 4E44 20 05            JR NZ,.L6
 153+ 4E46 2A C3 F3         LD HL, (T32ATR)
 154+ 4E49 18 03            JR .L7
 155+ 4E4B              .L6:
 156+ 4E4B 2A CD F3         LD HL, (GRPATR)
 157+ 4E4E              .L7:
 158+ 4E4E              	; CALL SETWRT_LOCAL not allowed as SP modified
 159+ 4E4E 7D           	LD	A, L
 160+ 4E4F D3 99        	OUT	(099H), A
 161+ 4E51 7C           	LD	A, H
 162+ 4E52 E6 3F        	AND	03FH
 163+ 4E54 F6 40        	OR	040H
 164+ 4E56 D3 99        	OUT	(099H), A
 165+ 4E58 C3 5C 4E     	JP .NEXT3
 166+ 4E5B              .NEXT2:
 167+ 4E5B 08           	EX AF, AF'
 168+ 4E5C              .NEXT3:
 169+ 4E5C 05           	DEC B
 170+ 4E5D C2 D6 4D     	JP NZ, .LOOP
 171+ 4E60 08           	EX AF, AF'
 172+ 4E61 3C           	INC A ; increase flicker to start at the next one on next vblank
 173+ 4E62 DD BE 00     	CP (IX)
 174+ 4E65 20 01        	JR NZ,.L8
 175+ 4E67 AF           	XOR A
 176+ 4E68              .L8:
 177+ 4E68 32 8C 4D     	LD (FLICKER), A
 178+ 4E6B
 179+ 4E6B ED 7B 8E 4D  	LD SP, (TMPSP)
 180+ 4E6F 2A 87 4D     	LD HL, (SPRATR_UPDATE_FLAG)
 181+ 4E72 36 00        	LD (HL), 0 ; zero out update flag
 182+ 4E74 C9           	RET
 183+ 4E75              ; *******************************************************************************************************
 184+ 4E75
 185+ 4E75               IF (1 == 1)
 186+ 4E75              ; *******************************************************************************************************
 187+ 4E75              ; function to handle CALL SPRENABLE basic extension
 188+ 4E75              ; initializes sprites handler
 189+ 4E75              ; _SPRENABLE ( INT[3][31] variable sprites_attributes,
 190+ 4E75              ;			   INT variable update_variable,
 191+ 4E75              ;			   BYTE sprite_flicker_enabled,
 192+ 4E75              ;			   BYTE num_sprites_handled )
 193+ 4E75              ; sets variables SPRATR_INIT_STATUS, SPRATR_UPDATE_FLAG, SPRATR_DATA, SPRFLICKER_ENABLED and NUM_SPRITES_HANDLED
 194+ 4E75              SPRENABLE:
 195+ 4E75              	; opening (
 196+ 4E75 CD 91 67     	CALL CHKCHAR
 197+ 4E78 28           	DB '('
 198+ 4E79              	; get address of sprite attribute table DIM SA%(3,31)
 199+ 4E79 3E 02        	LD A,2
 200+ 4E7B 06 02        	LD B,2
 201+ 4E7D 11 20 04     	LD DE,#0420
 202+ 4E80 CD F6 67     	CALL GET_BASIC_ARRAY_DATA_POINTER
 203+ 4E83 ED 43 89 4D  	LD (SPRATR_DATA), BC
 204+ 4E87              	; comma
 205+ 4E87 CD 91 67     	CALL CHKCHAR
 206+ 4E8A 2C           	DB ','
 207+ 4E8B              	; get address of sprite update flag
 208+ 4E8B DD 21 A4 5E  	LD IX, PTRGET
 209+ 4E8F CD 59 01     	CALL CALBAS
 210+ 4E92 ED 53 87 4D  	LD (SPRATR_UPDATE_FLAG), DE
 211+ 4E96              	; comma
 212+ 4E96 CD 91 67     	CALL CHKCHAR
 213+ 4E99 2C           	DB ','
 214+ 4E9A              	; get flicker enabled flag
 215+ 4E9A DD 21 1C 52  	LD IX, GETBYT
 216+ 4E9E CD 59 01     	CALL CALBAS
 217+ 4EA1 32 8B 4D     	LD (SPRFLICKER_ENABLED), A
 218+ 4EA4              	; comma
 219+ 4EA4 CD 91 67     	CALL CHKCHAR
 220+ 4EA7 2C           	DB ','
 221+ 4EA8              	; get number of handled sprites
 222+ 4EA8 DD 21 1C 52  	LD IX, GETBYT
 223+ 4EAC CD 59 01     	CALL CALBAS
 224+ 4EAF 32 8D 4D     	LD (NUM_SPRITES_HANDLED),A
 225+ 4EB2              	; ending )
 226+ 4EB2 CD 91 67     	CALL CHKCHAR
 227+ 4EB5 29           	DB ')'
 228+ 4EB6              .L0:
 229+ 4EB6 3E 01        	LD A, 1
 230+ 4EB8 32 86 4D     	LD (SPRATR_INIT_STATUS), A
 231+ 4EBB C9           	RET
 232+ 4EBC              ; *******************************************************************************************************
 233+ 4EBC               ENDIF
 234+ 4EBC
 235+ 4EBC               IF (0 == 1)
 236+ 4EBC ~            ; same as SPRENABLE but for DEFUSR approach
 237+ 4EBC ~            ; input IX=pointer to input array, real data from +2
 238+ 4EBC ~            ; +2 = pointer to sprite attributes array data
 239+ 4EBC ~            ; +4 = pointer to sprite update variable
 240+ 4EBC ~            ; +6 = flicker flag
 241+ 4EBC ~            ; +8 = number of sprites to handle
 242+ 4EBC ~            SPRENABLE_DEFUSR:
 243+ 4EBC ~            	LD L,(IX+2)
 244+ 4EBC ~            	LD H,(IX+3)
 245+ 4EBC ~            	LD (SPRATR_DATA),HL
 246+ 4EBC ~            	LD L,(IX+4)
 247+ 4EBC ~            	LD H,(IX+5)
 248+ 4EBC ~            	LD (SPRATR_UPDATE_FLAG),HL
 249+ 4EBC ~            	LD A,(IX+6)
 250+ 4EBC ~            	LD (SPRFLICKER_ENABLED),A
 251+ 4EBC ~            	LD A,(IX+8)
 252+ 4EBC ~            	LD (NUM_SPRITES_HANDLED),A
 253+ 4EBC ~            	LD A, 1
 254+ 4EBC ~            	LD (SPRATR_INIT_STATUS), A
 255+ 4EBC ~            	XOR A ; success
 256+ 4EBC ~            	RET
 257+ 4EBC               ENDIF
 258+ 4EBC
 259+ 4EBC               IF (0 + 1 > 0)
 260+ 4EBC              ; *******************************************************************************************************
 261+ 4EBC              ; function to handle CALL SPRDISABLE basic extension
 262+ 4EBC              ; disables sprites handling
 263+ 4EBC              ; _SPRDISABLE
 264+ 4EBC              ; resets variable SPRATR_INIT_STATUS
 265+ 4EBC              SPRDISABLE:
 266+ 4EBC              SPRDISABLE_DEFUSR:
 267+ 4EBC AF           	XOR A
 268+ 4EBD 32 86 4D     	LD (SPRATR_INIT_STATUS), A
 269+ 4EC0 C9           	RET
 270+ 4EC1              ; *******************************************************************************************************
 271+ 4EC1               ENDIF
 272+ 4EC1
 273+ 4EC1              ; *******************************************************************************************************
 274+ 4EC1              ; function to handle CALL SPRSET basic extension
 275+ 4EC1              ; sets position, and optionally pattern and color of sprite
 276+ 4EC1              ; _SPRSET ( BYTE sprite_num , valid 0-31
 277+ 4EC1              ;			INT x,
 278+ 4EC1              ;			INT y,
 279+ 4EC1              ;			INT pattern, valid 0-63, otherwise ignored
 280+ 4EC1              ;			INT color, valid 0-15, otherwise ignored
 281+ 4EC1              ;SPRSET:
 282+ 4EC1              ;	LD A, (SPRATR_INIT_STATUS)
 283+ 4EC1              ;	OR A
 284+ 4EC1              ;	JR NZ, .L1
 285+ 4EC1              ;	LD E, 5 ; illegal function call
 286+ 4EC1              ;	JP THROW_ERROR
 287+ 4EC1              ;.L1:
 288+ 4EC1              ;	; opening (
 289+ 4EC1              ;	CALL CHKCHAR
 290+ 4EC1              ;	DB '('
 291+ 4EC1              ;	; get sprite number
 292+ 4EC1              ;	LD IX, GETBYT
 293+ 4EC1              ;	CALL CALBAS
 294+ 4EC1              ;	PUSH AF
 295+ 4EC1              ;	; comma
 296+ 4EC1              ;	CALL CHKCHAR
 297+ 4EC1              ;	DB ','
 298+ 4EC1              ;	; get x
 299+ 4EC1              ;	LD IX, FRMQNT
 300+ 4EC1              ;	CALL CALBAS
 301+ 4EC1              ;	PUSH DE
 302+ 4EC1              ;	; comma
 303+ 4EC1              ;	CALL CHKCHAR
 304+ 4EC1              ;	DB ','
 305+ 4EC1              ;	; get y
 306+ 4EC1              ;	LD IX, FRMQNT
 307+ 4EC1              ;	CALL CALBAS
 308+ 4EC1              ;	PUSH DE
 309+ 4EC1              ;	; comma
 310+ 4EC1              ;	CALL CHKCHAR
 311+ 4EC1              ;	DB ','
 312+ 4EC1              ;	; get pattern
 313+ 4EC1              ;	LD IX, FRMQNT
 314+ 4EC1              ;	CALL CALBAS
 315+ 4EC1              ;	PUSH DE
 316+ 4EC1              ;	; comma
 317+ 4EC1              ;	CALL CHKCHAR
 318+ 4EC1              ;	DB ','
 319+ 4EC1              ;	; get color
 320+ 4EC1              ;	LD IX, FRMQNT
 321+ 4EC1              ;	CALL CALBAS
 322+ 4EC1              ;	PUSH DE
 323+ 4EC1              ;	; ending )
 324+ 4EC1              ;	CALL CHKCHAR
 325+ 4EC1              ;	DB ')'
 326+ 4EC1              ;
 327+ 4EC1              ;   ; save position in BASIC text
 328+ 4EC1              ;	PUSH HL
 329+ 4EC1              ;	POP IX
 330+ 4EC1              ;
 331+ 4EC1              ;	POP BC ; color
 332+ 4EC1              ;	POP DE ; pattern
 333+ 4EC1              ;	EXX
 334+ 4EC1              ;	POP BC ; y
 335+ 4EC1              ;	POP DE ; x
 336+ 4EC1              ;	POP AF ; sprite number
 337+ 4EC1              ;	CP 32
 338+ 4EC1              ;	JR C, .L2
 339+ 4EC1              ;	LD E, 5 ; illegal function call
 340+ 4EC1              ;	JP THROW_ERROR
 341+ 4EC1              ;.L2:
 342+ 4EC1              ;	; find location in sprite attributes table
 343+ 4EC1              ;	PUSH DE
 344+ 4EC1              ;	CALL GETnthSPRATTR
 345+ 4EC1              ;	POP DE
 346+ 4EC1              ;	DI
 347+ 4EC1              ;	; set y
 348+ 4EC1              ;	LD (HL), C
 349+ 4EC1              ;	INC HL
 350+ 4EC1              ;	LD (HL), B
 351+ 4EC1              ;	INC HL
 352+ 4EC1              ;	; set x
 353+ 4EC1              ;	LD (HL), E
 354+ 4EC1              ;	INC HL
 355+ 4EC1              ;	LD (HL), D
 356+ 4EC1              ;	INC HL
 357+ 4EC1              ;	PUSH HL
 358+ 4EC1              ;	EXX
 359+ 4EC1              ;	POP HL
 360+ 4EC1              ;	; check if 0<=pattern<64
 361+ 4EC1              ;	LD A, D
 362+ 4EC1              ;	OR A
 363+ 4EC1              ;	JR NZ, .L3
 364+ 4EC1              ;	LD A, E
 365+ 4EC1              ;	CP 64
 366+ 4EC1              ;	JR NC, .L3
 367+ 4EC1              ;	; set pattern
 368+ 4EC1              ;	;ADD A, A
 369+ 4EC1              ;	;ADD A, A
 370+ 4EC1              ;	;ADD A, A
 371+ 4EC1              ;	LD (HL), A
 372+ 4EC1              ;	INC HL
 373+ 4EC1              ;	LD (HL), D
 374+ 4EC1              ;	INC HL
 375+ 4EC1              ;	JR .L4
 376+ 4EC1              ;.L3:
 377+ 4EC1              ;	; skip pattern
 378+ 4EC1              ;	.2 INC HL
 379+ 4EC1              ;.L4:
 380+ 4EC1              ;	; check if 0<=color<16
 381+ 4EC1              ;	LD A, B
 382+ 4EC1              ;	OR A
 383+ 4EC1              ;	JR NZ, .L5
 384+ 4EC1              ;	LD A, C
 385+ 4EC1              ;	CP 16
 386+ 4EC1              ;	JR NC, .L5
 387+ 4EC1              ;	; set color
 388+ 4EC1              ;	LD (HL), C
 389+ 4EC1              ;	INC HL
 390+ 4EC1              ;	LD (HL), B
 391+ 4EC1              ;
 392+ 4EC1              ;.L5:
 393+ 4EC1              ;	EI
 394+ 4EC1              ;	PUSH IX
 395+ 4EC1              ;	POP HL
 396+ 4EC1              ;	RET
 397+ 4EC1              ; *******************************************************************************************************
 398+ 4EC1
 399+ 4EC1              ; *******************************************************************************************************
 400+ 4EC1              ; function sets sprite location based on initial coordinates and offset provided
 401+ 4EC1              ; input A=sprite number in SPRATR_DATA , 0-31
 402+ 4EC1              ; input DE=initial x
 403+ 4EC1              ; input BC=initial y
 404+ 4EC1              ; input IY=location where delta y,x are located
 405+ 4EC1              ; modifies AF, HL, IX
 406+ 4EC1              SPRSET_DELTA_POS:
 407+ 4EC1 D5           	PUSH DE
 408+ 4EC2 CD 90 4D     	CALL GETnthSPRATTR
 409+ 4EC5 E5           	PUSH HL
 410+ 4EC6 DD E1        	POP IX
 411+ 4EC8 D1           	POP DE
 412+ 4EC9              	; IX=sprite's y location
 413+ 4EC9 FD 6E 00     	LD L, (IY)
 414+ 4ECC FD 66 01     	LD H, (IY+1)
 415+ 4ECF 09           	ADD HL, BC
 416+ 4ED0 DD 75 00     	LD (IX), L
 417+ 4ED3 DD 74 01     	LD (IX+1), H
 418+ 4ED6 FD 6E 02     	LD L, (IY+2)
 419+ 4ED9 FD 66 03     	LD H, (IY+3)
 420+ 4EDC 19           	ADD HL, DE
 421+ 4EDD DD 75 02     	LD (IX+2), L
 422+ 4EE0 DD 74 03     	LD (IX+3), H
 423+ 4EE3 C9           	RET
 424+ 4EE4              ; *******************************************************************************************************
 425+ 4EE4
 426+ 4EE4              ; *******************************************************************************************************
 427+ 4EE4              ; helper function to set new locations for a set of sprites
 428+ 4EE4              ; input B=number of sprites
 429+ 4EE4              ; HL=pointer to list of sprites and offsets
 430+ 4EE4              SPR_UPDATE_LOC:
 431+ 4EE4 3E 01        	LD A,1
 432+ 4EE6 32 6B 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 433+ 4EE9 7E           	LD A, (HL)
 434+ 4EEA 23           	INC HL
 435+ 4EEB 23           	INC HL
 436+ 4EEC E5           	PUSH HL
 437+ 4EED FD E1        	POP IY
 438+ 4EEF D9           	EXX
 439+ 4EF0 CD C1 4E     	CALL SPRSET_DELTA_POS
 440+ 4EF3 D9           	EXX
 441+ 4EF4 23          > INC HL
 441+ 4EF5 23          > INC HL
 441+ 4EF6 23          > INC HL
 441+ 4EF7 23          > INC HL
 442+ 4EF8 10 EA        	DJNZ SPR_UPDATE_LOC
 443+ 4EFA AF           	XOR A
 444+ 4EFB 32 6B 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 445+ 4EFE C9           	RET
 446+ 4EFF              ; *******************************************************************************************************
 447+ 4EFF
 448+ 4EFF               IF (1 == 1)
 449+ 4EFF              ; *******************************************************************************************************
 450+ 4EFF              ; function to handle CALL SPRGRPMOV basic extension
 451+ 4EFF              ; sets position of a group of sprites described with
 452+ 4EFF              ; { int sprite_num, int delta_y, int delta_x } [count]
 453+ 4EFF              ; _SPRGRPMOV ( INT x,
 454+ 4EFF              ;			   INT y,
 455+ 4EFF              ;			   BYTE count,
 456+ 4EFF              ;			   INT[2][count] data_ptr
 457+ 4EFF              SPRGRPMOV:
 458+ 4EFF 3A 86 4D     	LD A, (SPRATR_INIT_STATUS)
 459+ 4F02 B7           	OR A
 460+ 4F03 CA BD 67     	JP Z,ILLEGAL_FUNCTION
 461+ 4F06              	; opening (
 462+ 4F06 CD 91 67     	CALL CHKCHAR
 463+ 4F09 28           	DB '('
 464+ 4F0A              	; get x
 465+ 4F0A DD 21 2F 54  	LD IX, FRMQNT
 466+ 4F0E CD 59 01     	CALL CALBAS
 467+ 4F11 ED 53 5A 64  	LD (TMP_STRUCT),DE
 468+ 4F15              	; comma
 469+ 4F15 CD 91 67     	CALL CHKCHAR
 470+ 4F18 2C           	DB ','
 471+ 4F19              	; get y
 472+ 4F19 DD 21 2F 54  	LD IX, FRMQNT
 473+ 4F1D CD 59 01     	CALL CALBAS
 474+ 4F20 ED 53 5C 64  	LD (TMP_STRUCT+2),DE
 475+ 4F24              	; comma
 476+ 4F24 CD 91 67     	CALL CHKCHAR
 477+ 4F27 2C           	DB ','
 478+ 4F28              	; get count
 479+ 4F28 DD 21 1C 52  	LD IX, GETBYT
 480+ 4F2C CD 59 01     	CALL CALBAS
 481+ 4F2F 32 5E 64     	LD (TMP_STRUCT+4),A
 482+ 4F32              	; comma
 483+ 4F32 CD 91 67     	CALL CHKCHAR
 484+ 4F35 2C           	DB ','
 485+ 4F36              	; get sprite group definition array data pointer
 486+ 4F36 3A 5E 64     	LD A,(TMP_STRUCT+4)
 487+ 4F39 5F           	LD E,A
 488+ 4F3A 16 03        	LD D,3
 489+ 4F3C 3E 02        	LD A,2
 490+ 4F3E 47           	LD B,A
 491+ 4F3F CD F6 67     	CALL GET_BASIC_ARRAY_DATA_POINTER
 492+ 4F42 ED 43 5F 64  	LD (TMP_STRUCT+5),BC
 493+ 4F46              	; ending )
 494+ 4F46 CD 91 67     	CALL CHKCHAR
 495+ 4F49 29           	DB ')'
 496+ 4F4A
 497+ 4F4A E5           	PUSH HL
 498+ 4F4B
 499+ 4F4B D9               EXX
 500+ 4F4C ED 5B 5A 64      LD DE,(TMP_STRUCT) ; initial x
 501+ 4F50 ED 4B 5C 64      LD BC,(TMP_STRUCT+2) ; initial y
 502+ 4F54 D9               EXX
 503+ 4F55 2A 5F 64         LD HL,(TMP_STRUCT+5) ; pointer to data
 504+ 4F58 3A 5E 64         LD A,(TMP_STRUCT+4) ; number of entries
 505+ 4F5B 47               LD B,A
 506+ 4F5C CD E4 4E     	CALL SPR_UPDATE_LOC
 507+ 4F5F
 508+ 4F5F E1           	POP HL
 509+ 4F60 C9           	RET
 510+ 4F61              ; *******************************************************************************************************
 511+ 4F61               ENDIF
 512+ 4F61
 513+ 4F61               IF (0 == 1)
 514+ 4F61 ~            ; *******************************************************************************************************
 515+ 4F61 ~            ; same as SPRGRPMOV but for DEFUSR approach
 516+ 4F61 ~            ; input IX=pointer to input array, real data from +2
 517+ 4F61 ~            ; +2 = X
 518+ 4F61 ~            ; +4 = Y
 519+ 4F61 ~            ; +6 = count
 520+ 4F61 ~            ; +8 = data pointer
 521+ 4F61 ~            SPRGRPMOV_DEFUSR:
 522+ 4F61 ~                EXX
 523+ 4F61 ~            	LD E,(IX+2)
 524+ 4F61 ~            	LD D,(IX+3) ; initial x
 525+ 4F61 ~            	LD C,(IX+4)
 526+ 4F61 ~            	LD B,(IX+5) ; initial y
 527+ 4F61 ~                EXX
 528+ 4F61 ~            	LD L,(IX+8)
 529+ 4F61 ~            	LD H,(IX+9) ; pointer to data
 530+ 4F61 ~                LD B,(IX+6) ; count
 531+ 4F61 ~                JP SPR_UPDATE_LOC
 532+ 4F61 ~            ; *******************************************************************************************************
 533+ 4F61               ENDIF
# file closed: asm\SPRITES.asm
 135  4F61               ENDIF
 136  4F61
 137  4F61               IF (ANIM_CMDS == 1)
 138  4F61               INCLUDE "ANIMATION.asm"
# file opened: asm\ANIMATION.asm
   1+ 4F61              ; sprite animation routines
   2+ 4F61
   3+ 4F61              ; number of animation items and pointer
   4+ 4F61              ANIMITEMNUM:
   5+ 4F61 00            DB 0
   6+ 4F62              ANIMITEMPTR:
   7+ 4F62 6C 68         DW EXT_END
   8+ 4F64              ; number of animation definitions and pointer
   9+ 4F64              ANIMDEFNUM:
  10+ 4F64 00            DB 0
  11+ 4F65              ANIMDEFPTR:
  12+ 4F65 6C 68         DW EXT_END
  13+ 4F67              ; number of links between sprite and animation definitions
  14+ 4F67              ANIMSPRNUM:
  15+ 4F67 00            DB 0
  16+ 4F68              ANIMSPRPTR:
  17+ 4F68 6C 68         DW EXT_END
  18+ 4F6A              ; number of automatic sprite group move and animate structures
  19+ 4F6A              AUTOSGAMNUM:
  20+ 4F6A 00            DB 0
  21+ 4F6B              AUTOSGAMPTR:
  22+ 4F6B 6C 68         DW EXT_END
  23+ 4F6D
  24+ 4F6D              ; ANIMATION ITEM
  25+ 4F6D              ; byte type = [0 - pattern and color change
  26+ 4F6D              ;              1 - pattern definition change ]
  27+ 4F6D              ; word ticks - number of ticks to hold this state
  28+ 4F6D              ; for type = 0
  29+ 4F6D              ;   byte pattern;
  30+ 4F6D              ;   byte color;
  31+ 4F6D              ; for type = 1
  32+ 4F6D              ;   work data_pointer;
  33+ 4F6D              ; total size = 5b
  34+ 4F6D
  35+ 4F6D              ; ANIMATION DEFINITION
  36+ 4F6D              ; byte number of items 1-15
  37+ 4F6D              ; byte[15] anim_item;
  38+ 4F6D              ; total size = 16b
  39+ 4F6D
  40+ 4F6D              ; SPRITE/CHAR ANIMATION
  41+ 4F6D              ; +00 byte sprite/char number;
  42+ 4F6D              ; +01 word time;
  43+ 4F6D              ; +03 byte current item;
  44+ 4F6D              ; +04 byte animation definition;
  45+ 4F6D              ; +05 byte cyclic;
  46+ 4F6D              ; +06 byte active;
  47+ 4F6D              ; +07 byte 0=sprite, 1-3 character bank
  48+ 4F6D              ; total size = 8b
  49+ 4F6D
  50+ 4F6D              ; AUTOMATIC SPRITE GROUP MOVE AND ANIMATE structure
  51+ 4F6D              ; +00 pointer to X variable
  52+ 4F6D              ; +02 pointer to Y variable
  53+ 4F6D              ; +04 minimum value
  54+ 4F6D              ; +06 maximal value
  55+ 4F6D              ; +08 delta value
  56+ 4F6D              ; +10 direction 0=horizontal, <>0 = vertical
  57+ 4F6D              ; +11 sprite group size
  58+ 4F6D              ; +12 sprite group pointer
  59+ 4F6D              ; +14 animation list size
  60+ 4F6D              ; +15 animation list pointer for negative delta values
  61+ 4F6D              ; +17 animation list pointer for positive delta values
  62+ 4F6D              ; +19 active flag
  63+ 4F6D              ; +20 ticks for movement
  64+ 4F6D              ; +22 timer
  65+ 4F6D              ; total = 24b
  66+ 4F6D
  67+ 4F6D              ; *******************************************************************************************************
  68+ 4F6D              ; helper function HL=A*5
  69+ 4F6D              ; changes HL,DE
  70+ 4F6D              Ax5:
  71+ 4F6D 26 00            LD H,0
  72+ 4F6F 6F               LD L,A
  73+ 4F70 54               LD D,H
  74+ 4F71 5D               LD E,L
  75+ 4F72 29               ADD HL,HL
  76+ 4F73 29               ADD HL,HL
  77+ 4F74 19               ADD HL,DE
  78+ 4F75 C9               RET
  79+ 4F76              ; *******************************************************************************************************
  80+ 4F76
  81+ 4F76              ; *******************************************************************************************************
  82+ 4F76              ; helper function gets pointer to n-th animation item
  83+ 4F76              ; changes HL,DE
  84+ 4F76              GETnthANIMITEM:
  85+ 4F76 CD 6D 4F         CALL Ax5
  86+ 4F79 ED 5B 62 4F      LD DE,(ANIMITEMPTR)
  87+ 4F7D 19               ADD HL,DE
  88+ 4F7E C9               RET
  89+ 4F7F              ; *******************************************************************************************************
  90+ 4F7F
  91+ 4F7F              ; *******************************************************************************************************
  92+ 4F7F              ; helper function gets pointer to n-th entry in animation definition
  93+ 4F7F              ; changes HL,DE
  94+ 4F7F              GETnthANIMDEF:
  95+ 4F7F 26 00            LD H,0
  96+ 4F81 6F               LD L,A
  97+ 4F82 CD 7D 66         CALL HLx16
  98+ 4F85 ED 5B 65 4F      LD DE,(ANIMDEFPTR)
  99+ 4F89 19               ADD HL,DE
 100+ 4F8A C9               RET
 101+ 4F8B              ; *******************************************************************************************************
 102+ 4F8B
 103+ 4F8B              ; *******************************************************************************************************
 104+ 4F8B              ; helper function gets pointer to n-th entry in sprite animation
 105+ 4F8B              ; changes HL,DE
 106+ 4F8B              GETnthSPRANIM:
 107+ 4F8B 26 00            LD H,0
 108+ 4F8D 6F               LD L,A
 109+ 4F8E CD 7E 66         CALL HLx8
 110+ 4F91 ED 5B 68 4F      LD DE,(ANIMSPRPTR)
 111+ 4F95 19               ADD HL,DE
 112+ 4F96 C9               RET
 113+ 4F97              ; *******************************************************************************************************
 114+ 4F97
 115+ 4F97              ; *******************************************************************************************************
 116+ 4F97              ; helper function gets pointer to n-th entry in autosgam table
 117+ 4F97              ; changes HL,DE
 118+ 4F97              GETnthAUTOSGAM:
 119+ 4F97 26 00            LD H,0
 120+ 4F99 6F               LD L,A
 121+ 4F9A CD 7E 66         CALL HLx8
 122+ 4F9D 54               LD D,H
 123+ 4F9E 5D               LD E,L
 124+ 4F9F 29               ADD HL,HL
 125+ 4FA0 19               ADD HL,DE
 126+ 4FA1 ED 5B 6B 4F      LD DE,(AUTOSGAMPTR)
 127+ 4FA5 19               ADD HL,DE
 128+ 4FA6 C9               RET
 129+ 4FA7              ; *******************************************************************************************************
 130+ 4FA7
 131+ 4FA7               IF (0 == 1)
 132+ 4FA7 ~            ; *******************************************************************************************************
 133+ 4FA7 ~            ; same as MAXIANIMITEMS but for DEFUSR approach
 134+ 4FA7 ~            ; input IX=pointer to input array, real data from +2
 135+ 4FA7 ~            ; +2 = number
 136+ 4FA7 ~            MAXANIMITEMS_DEFUSR:
 137+ 4FA7 ~                LD A,(IX+2)
 138+ 4FA7 ~                CALL MAXANIMITEMS.COMMON
 139+ 4FA7 ~                XOR A ; success
 140+ 4FA7 ~                RET
 141+ 4FA7 ~            ; *******************************************************************************************************
 142+ 4FA7               ENDIF
 143+ 4FA7
 144+ 4FA7              ; *******************************************************************************************************
 145+ 4FA7              ; function to handle CALL MAXANIMITEMS basic extension
 146+ 4FA7              ; MAXANIMITEMS (BYTE number)
 147+ 4FA7              ; sets new number and moves memory buffers as needed
 148+ 4FA7              MAXANIMITEMS:
 149+ 4FA7               IF (1 == 1)
 150+ 4FA7              	; opening (
 151+ 4FA7 CD 91 67     	CALL CHKCHAR
 152+ 4FAA 28           	DB '('
 153+ 4FAB              	; get value
 154+ 4FAB DD 21 1C 52  	LD IX, GETBYT
 155+ 4FAF CD 59 01     	CALL CALBAS
 156+ 4FB2 F5               PUSH AF
 157+ 4FB3              	; ending )
 158+ 4FB3 CD 91 67     	CALL CHKCHAR
 159+ 4FB6 29           	DB ')'
 160+ 4FB7 F1               POP AF
 161+ 4FB8               ENDIF
 162+ 4FB8              .COMMON: ; entry for DEFUSR part, A=number
 163+ 4FB8 F3               DI
 164+ 4FB9              	; save position
 165+ 4FB9 E5           	PUSH HL
 166+ 4FBA              .ENTRY:
 167+ 4FBA 47               LD B,A
 168+ 4FBB 3A 61 4F         LD A,(ANIMITEMNUM)
 169+ 4FBE 90               SUB B
 170+ 4FBF 28 28            JR Z, .EXIT; same value as before
 171+ 4FC1 FD 21 65 4F      LD IY,ANIMDEFPTR
 172+ 4FC5 FA EC 4F         JP M, .INCREASE
 173+ 4FC8                  ; new value is lower than previous one
 174+ 4FC8 CD 0B 50         CALL .SIZEDIFF
 175+ 4FCB CD 26 50         CALL .DECREASE_COMMON
 176+ 4FCE 2A 68 4F         LD HL,(ANIMSPRPTR)
 177+ 4FD1 AF               XOR A
 178+ 4FD2 ED 42            SBC HL,BC
 179+ 4FD4 22 68 4F         LD (ANIMSPRPTR),HL
 180+ 4FD7              .E1:
 181+ 4FD7 2A 6B 4F         LD HL,(AUTOSGAMPTR)
 182+ 4FDA AF               XOR A
 183+ 4FDB ED 42            SBC HL,BC
 184+ 4FDD 22 6B 4F         LD (AUTOSGAMPTR),HL
 185+ 4FE0              .E3:
 186+ 4FE0 2A 10 40         LD HL,(FREEMEMPTR)
 187+ 4FE3 AF               XOR A
 188+ 4FE4 ED 42            SBC HL,BC
 189+ 4FE6 22 10 40         LD (FREEMEMPTR),HL
 190+ 4FE9              .EXIT:
 191+ 4FE9 FB               EI
 192+ 4FEA E1           	POP HL
 193+ 4FEB C9           	RET
 194+ 4FEC              .INCREASE:
 195+ 4FEC ED 44            NEG
 196+ 4FEE CD 0B 50         CALL .SIZEDIFF
 197+ 4FF1 CD 52 50         CALL .INCREASE_COMMON
 198+ 4FF4 2A 68 4F         LD HL,(ANIMSPRPTR)
 199+ 4FF7 09               ADD HL,BC
 200+ 4FF8 22 68 4F         LD (ANIMSPRPTR),HL
 201+ 4FFB              .E2:
 202+ 4FFB 2A 6B 4F         LD HL,(AUTOSGAMPTR)
 203+ 4FFE 09               ADD HL,BC
 204+ 4FFF 22 6B 4F         LD (AUTOSGAMPTR),HL
 205+ 5002              .E4:
 206+ 5002 2A 10 40         LD HL,(FREEMEMPTR)
 207+ 5005 09               ADD HL,BC
 208+ 5006 22 10 40         LD (FREEMEMPTR),HL
 209+ 5009 18 DE            JR .EXIT
 210+ 500B              .SIZEDIFF:
 211+ 500B CD 6D 4F         CALL Ax5
 212+ 500E 78               LD A,B
 213+ 500F 32 61 4F         LD (ANIMITEMNUM),A
 214+ 5012 44               LD B,H
 215+ 5013 4D               LD C,L
 216+ 5014 C9               RET ; BC=size difference in bytes
 217+ 5015              .SIZETOMOVE:
 218+ 5015 D5               PUSH DE
 219+ 5016 2A 10 40         LD HL,(FREEMEMPTR)
 220+ 5019 FD 5E 00         LD E,(IY)
 221+ 501C FD 56 01         LD D,(IY+1)
 222+ 501F AF               XOR A
 223+ 5020 ED 52            SBC HL,DE
 224+ 5022 44               LD B,H
 225+ 5023 4D               LD C,L
 226+ 5024 D1               POP DE
 227+ 5025 C9               RET
 228+ 5026              .DECREASE_COMMON:
 229+ 5026 FD 6E 00         LD L,(IY)
 230+ 5029 FD 66 01         LD H,(IY+1)
 231+ 502C AF               XOR A
 232+ 502D ED 42            SBC HL,BC
 233+ 502F EB               EX DE,HL
 234+ 5030 C5               PUSH BC
 235+ 5031 CD 15 50         CALL .SIZETOMOVE
 236+ 5034 F3               DI
 237+ 5035 78               LD A,B
 238+ 5036 B1               OR C
 239+ 5037 28 08            JR Z,.L1
 240+ 5039 FD 6E 00         LD L,(IY)
 241+ 503C FD 66 01         LD H,(IY+1)
 242+ 503F ED B0            LDIR
 243+ 5041              .L1:
 244+ 5041 C1               POP BC
 245+ 5042 FD 6E 00         LD L,(IY)
 246+ 5045 FD 66 01         LD H,(IY+1)
 247+ 5048 AF               XOR A
 248+ 5049 ED 42            SBC HL,BC
 249+ 504B FD 75 00         LD (IY),L
 250+ 504E FD 74 01         LD (IY+1),H
 251+ 5051 C9               RET
 252+ 5052              .INCREASE_COMMON:
 253+ 5052 2A 10 40         LD HL,(FREEMEMPTR)
 254+ 5055 2B               DEC HL
 255+ 5056 AF               XOR A
 256+ 5057 ED 42            SBC HL,BC
 257+ 5059 EB               EX DE,HL
 258+ 505A C5               PUSH BC
 259+ 505B CD 15 50         CALL .SIZETOMOVE
 260+ 505E F3               DI
 261+ 505F 78               LD A,B
 262+ 5060 B1               OR C
 263+ 5061 28 06            JR Z,.L2
 264+ 5063 2A 10 40         LD HL,(FREEMEMPTR)
 265+ 5066 2B               DEC HL
 266+ 5067 ED B8            LDDR
 267+ 5069              .L2:
 268+ 5069 C1               POP BC
 269+ 506A FD 6E 00         LD L,(IY)
 270+ 506D FD 66 01         LD H,(IY+1)
 271+ 5070 09               ADD HL,BC
 272+ 5071 FD 75 00         LD (IY),L
 273+ 5074 FD 74 01         LD (IY+1),H
 274+ 5077 C9               RET
 275+ 5078              ; *******************************************************************************************************
 276+ 5078
 277+ 5078               IF (1 == 1)
 278+ 5078              ; *******************************************************************************************************
 279+ 5078              ; function to handle CALL ANIMITEMPAT basic extension
 280+ 5078              ; ANIMITEMPAT ( BYTE id,
 281+ 5078              ;               INT ticks >0,
 282+ 5078              ;               BYTE pattern,
 283+ 5078              ;               BYTE color )
 284+ 5078              ; fills animation item data, returns an error if ID out of bounds
 285+ 5078              ANIMITEMPAT:
 286+ 5078                  ; opening (
 287+ 5078 CD 91 67     	CALL CHKCHAR
 288+ 507B 28           	DB '('
 289+ 507C              	; get id
 290+ 507C DD 21 1C 52  	LD IX, GETBYT
 291+ 5080 CD 59 01     	CALL CALBAS
 292+ 5083 F5               PUSH AF
 293+ 5084                  ; check if out of bounds
 294+ 5084 3C               INC A
 295+ 5085 4F               LD C,A
 296+ 5086 3A 61 4F         LD A,(ANIMITEMNUM)
 297+ 5089 B9               CP C
 298+ 508A DA B5 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 299+ 508D              	; comma
 300+ 508D CD 91 67     	CALL CHKCHAR
 301+ 5090 2C           	DB ','
 302+ 5091              	; get ticks
 303+ 5091 DD 21 2F 54  	LD IX, FRMQNT
 304+ 5095 CD 59 01     	CALL CALBAS
 305+ 5098 7A               LD A,D
 306+ 5099 B3               OR E
 307+ 509A CA B9 67         JP Z, OVERFLOW
 308+ 509D D5           	PUSH DE
 309+ 509E              	; comma
 310+ 509E CD 91 67     	CALL CHKCHAR
 311+ 50A1 2C           	DB ','
 312+ 50A2              	; get pattern
 313+ 50A2 DD 21 1C 52  	LD IX, GETBYT
 314+ 50A6 CD 59 01     	CALL CALBAS
 315+ 50A9 F5               PUSH AF
 316+ 50AA              	; comma
 317+ 50AA CD 91 67     	CALL CHKCHAR
 318+ 50AD 2C           	DB ','
 319+ 50AE              	; get color
 320+ 50AE DD 21 1C 52  	LD IX, GETBYT
 321+ 50B2 CD 59 01     	CALL CALBAS
 322+ 50B5 F5               PUSH AF
 323+ 50B6              	; ending )
 324+ 50B6 CD 91 67     	CALL CHKCHAR
 325+ 50B9 29           	DB ')'
 326+ 50BA              .ENTRY:
 327+ 50BA E5               PUSH HL
 328+ 50BB DD E1            POP IX
 329+ 50BD D9               EXX
 330+ 50BE C1               POP BC ; color
 331+ 50BF D1               POP DE ; pattern
 332+ 50C0 E1               POP HL ; ticks
 333+ 50C1 D9               EXX
 334+ 50C2 F1               POP AF
 335+ 50C3 CD 76 4F         CALL GETnthANIMITEM
 336+ 50C6 E5               PUSH HL
 337+ 50C7 FD E1            POP IY
 338+ 50C9 D9               EXX
 339+ 50CA FD 36 00 00      LD (IY),0 ; type=0
 340+ 50CE FD 75 01         LD (IY+1),L
 341+ 50D1 FD 74 02         LD (IY+2),H
 342+ 50D4 FD 72 03         LD (IY+3),D
 343+ 50D7 FD 70 04         LD (IY+4),B
 344+ 50DA
 345+ 50DA DD E5            PUSH IX
 346+ 50DC E1               POP HL
 347+ 50DD C9               RET
 348+ 50DE              ; *******************************************************************************************************
 349+ 50DE               ENDIF
 350+ 50DE
 351+ 50DE               IF (0 == 1)
 352+ 50DE ~            ; *******************************************************************************************************
 353+ 50DE ~            ; same as ANIMITEMPAT but for DEFUSR approach
 354+ 50DE ~            ; input IX=pointer to input array, real data from +2
 355+ 50DE ~            ; +02 = ID
 356+ 50DE ~            ; +04 = ticks
 357+ 50DE ~            ; +06 = pattern
 358+ 50DE ~            ; +08 = color
 359+ 50DE ~            ANIMITEMPAT_DEFUSR:
 360+ 50DE ~                ; check if out of bounds
 361+ 50DE ~                LD C,(IX+2)
 362+ 50DE ~                INC C
 363+ 50DE ~                LD A,(ANIMITEMNUM)
 364+ 50DE ~                CP C
 365+ 50DE ~                JR C,.ERR ; out of bounds, prevent memory corruption
 366+ 50DE ~                LD A,C
 367+ 50DE ~                DEC A
 368+ 50DE ~                CALL GETnthANIMITEM
 369+ 50DE ~                LD (HL),0 ; type=0
 370+ 50DE ~                INC HL
 371+ 50DE ~                LD A,(IX+4) ; ticks low
 372+ 50DE ~                LD (HL),A
 373+ 50DE ~                INC HL
 374+ 50DE ~                LD A,(IX+5) ; ticks high
 375+ 50DE ~                LD (HL),A
 376+ 50DE ~                INC HL
 377+ 50DE ~                LD A,(IX+6) ; pattern
 378+ 50DE ~                LD (HL),A
 379+ 50DE ~                INC HL
 380+ 50DE ~                LD A,(IX+8) ; color
 381+ 50DE ~                LD (HL),A
 382+ 50DE ~                XOR A ; success
 383+ 50DE ~                RET
 384+ 50DE ~            .ERR:
 385+ 50DE ~                LD A,1
 386+ 50DE ~                RET
 387+ 50DE ~            ; *******************************************************************************************************
 388+ 50DE               ENDIF
 389+ 50DE
 390+ 50DE               IF (1 == 1)
 391+ 50DE              ; *******************************************************************************************************
 392+ 50DE              ; function to handle CALL ANIMITEMPTR basic extension
 393+ 50DE              ; ANIMITEMPTR ( BYTE id,
 394+ 50DE              ;               INT ticks,
 395+ 50DE              ;               INT pointer,
 396+ 50DE              ; fills animation item data, returns an error if ID out of bounds
 397+ 50DE              ANIMITEMPTR_CMD:
 398+ 50DE                  ; opening (
 399+ 50DE CD 91 67     	CALL CHKCHAR
 400+ 50E1 28           	DB '('
 401+ 50E2              	; get id
 402+ 50E2 DD 21 1C 52  	LD IX, GETBYT
 403+ 50E6 CD 59 01     	CALL CALBAS
 404+ 50E9 F5               PUSH AF
 405+ 50EA                  ; check if out of bounds
 406+ 50EA 3C               INC A
 407+ 50EB 4F               LD C,A
 408+ 50EC 3A 61 4F         LD A,(ANIMITEMNUM)
 409+ 50EF B9               CP C
 410+ 50F0 DA B5 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 411+ 50F3              	; comma
 412+ 50F3 CD 91 67     	CALL CHKCHAR
 413+ 50F6 2C           	DB ','
 414+ 50F7              	; get ticks
 415+ 50F7 DD 21 2F 54  	LD IX, FRMQNT
 416+ 50FB CD 59 01     	CALL CALBAS
 417+ 50FE 7A               LD A,D
 418+ 50FF B3               OR E
 419+ 5100 CA B9 67         JP Z,OVERFLOW
 420+ 5103 D5           	PUSH DE
 421+ 5104              	; comma
 422+ 5104 CD 91 67     	CALL CHKCHAR
 423+ 5107 2C           	DB ','
 424+ 5108              	; get pointer
 425+ 5108 DD 21 2F 54  	LD IX, FRMQNT
 426+ 510C CD 59 01     	CALL CALBAS
 427+ 510F D5           	PUSH DE
 428+ 5110              	; ending )
 429+ 5110 CD 91 67     	CALL CHKCHAR
 430+ 5113 29           	DB ')'
 431+ 5114              .ENTRY:
 432+ 5114 E5               PUSH HL
 433+ 5115 DD E1            POP IX
 434+ 5117 D9               EXX
 435+ 5118 D1               POP DE ; pointer
 436+ 5119 E1               POP HL ; ticks
 437+ 511A D9               EXX
 438+ 511B F1               POP AF
 439+ 511C CD 76 4F         CALL GETnthANIMITEM
 440+ 511F E5               PUSH HL
 441+ 5120 FD E1            POP IY
 442+ 5122 D9               EXX
 443+ 5123 FD 36 00 01      LD (IY),1 ; type=1
 444+ 5127 FD 75 01         LD (IY+1),L
 445+ 512A FD 74 02         LD (IY+2),H
 446+ 512D FD 73 03         LD (IY+3),E
 447+ 5130 FD 72 04         LD (IY+4),D
 448+ 5133
 449+ 5133 DD E5            PUSH IX
 450+ 5135 E1               POP HL
 451+ 5136 C9               RET
 452+ 5137              ; *******************************************************************************************************
 453+ 5137               ENDIF
 454+ 5137
 455+ 5137               IF (0 == 1)
 456+ 5137 ~            ; *******************************************************************************************************
 457+ 5137 ~            ; same as ANIMITEMPTR but for DEFUSR approach
 458+ 5137 ~            ; input IX=pointer to input array, real data from +2
 459+ 5137 ~            ; +02 = ID
 460+ 5137 ~            ; +04 = ticks
 461+ 5137 ~            ; +06 = pointer
 462+ 5137 ~            ANIMITEMPTR_DEFUSR:
 463+ 5137 ~                ; check if out of bounds
 464+ 5137 ~                LD C,(IX+2)
 465+ 5137 ~                INC C
 466+ 5137 ~                LD A,(ANIMITEMNUM)
 467+ 5137 ~                CP C
 468+ 5137 ~                JR C,.ERR ; out of bounds, prevent memory corruption
 469+ 5137 ~                LD A,C
 470+ 5137 ~                DEC A
 471+ 5137 ~                CALL GETnthANIMITEM
 472+ 5137 ~                LD (HL),1 ; type=1
 473+ 5137 ~                INC HL
 474+ 5137 ~                LD A,(IX+4) ; ticks low
 475+ 5137 ~                LD (HL),A
 476+ 5137 ~                INC HL
 477+ 5137 ~                LD A,(IX+5) ; ticks high
 478+ 5137 ~                LD (HL),A
 479+ 5137 ~                INC HL
 480+ 5137 ~                LD A,(IX+6) ; pointer low
 481+ 5137 ~                LD (HL),A
 482+ 5137 ~                INC HL
 483+ 5137 ~                LD A,(IX+7) ; pointer high
 484+ 5137 ~                LD (HL),A
 485+ 5137 ~                XOR A ; success
 486+ 5137 ~                RET
 487+ 5137 ~            .ERR:
 488+ 5137 ~                LD A,1
 489+ 5137 ~                RET
 490+ 5137 ~            ; *******************************************************************************************************
 491+ 5137               ENDIF
 492+ 5137
 493+ 5137               IF (0 == 1)
 494+ 5137 ~            ; *******************************************************************************************************
 495+ 5137 ~            ; same as MAXANIMDEFS but for DEFUSR approach
 496+ 5137 ~            ; input IX=pointer to input array, real data from +2
 497+ 5137 ~            ; +2 = number
 498+ 5137 ~            MAXANIMDEFS_DEFUSR:
 499+ 5137 ~                LD A,(IX+2)
 500+ 5137 ~                CALL MAXANIMDEFS.COMMON
 501+ 5137 ~                XOR A ; success
 502+ 5137 ~                RET
 503+ 5137 ~            ; *******************************************************************************************************
 504+ 5137               ENDIF
 505+ 5137
 506+ 5137              ; *******************************************************************************************************
 507+ 5137              ; function to handle CALL MAXANIMDEFS basic extension
 508+ 5137              ; MAXANIMDEFS (BYTE number)
 509+ 5137              ; sets new number and moves memory buffers as needed
 510+ 5137              MAXANIMDEFS:
 511+ 5137               IF (1 == 1)
 512+ 5137              	; opening (
 513+ 5137 CD 91 67     	CALL CHKCHAR
 514+ 513A 28           	DB '('
 515+ 513B              	; get value
 516+ 513B DD 21 1C 52  	LD IX, GETBYT
 517+ 513F CD 59 01     	CALL CALBAS
 518+ 5142 F5               PUSH AF
 519+ 5143              	; ending )
 520+ 5143 CD 91 67     	CALL CHKCHAR
 521+ 5146 29           	DB ')'
 522+ 5147 F1               POP AF
 523+ 5148               ENDIF
 524+ 5148              .COMMON:
 525+ 5148 F3               DI
 526+ 5149              	; save position
 527+ 5149 E5           	PUSH HL
 528+ 514A              .ENTRY:
 529+ 514A 47               LD B,A
 530+ 514B 3A 64 4F         LD A,(ANIMDEFNUM)
 531+ 514E 90               SUB B
 532+ 514F CA E9 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 533+ 5152 FD 21 68 4F      LD IY,ANIMSPRPTR
 534+ 5156 FA 62 51         JP M, .INCREASE
 535+ 5159                  ; new value is lower than previous one
 536+ 5159 CD 6D 51         CALL .SIZEDIFF
 537+ 515C CD 26 50         CALL MAXANIMITEMS.DECREASE_COMMON
 538+ 515F C3 D7 4F         JP MAXANIMITEMS.E1
 539+ 5162              .INCREASE:
 540+ 5162 ED 44            NEG
 541+ 5164 CD 6D 51         CALL .SIZEDIFF
 542+ 5167 CD 52 50         CALL MAXANIMITEMS.INCREASE_COMMON
 543+ 516A C3 FB 4F         JP MAXANIMITEMS.E2
 544+ 516D              .SIZEDIFF:
 545+ 516D 26 00            LD H,0
 546+ 516F 6F               LD L,A
 547+ 5170 CD 7D 66         CALL HLx16
 548+ 5173 78               LD A,B
 549+ 5174 32 64 4F         LD (ANIMDEFNUM),A
 550+ 5177 44               LD B,H
 551+ 5178 4D               LD C,L
 552+ 5179 C9               RET ; BC=size difference in bytes
 553+ 517A              ; *******************************************************************************************************
 554+ 517A
 555+ 517A               IF (1 == 1)
 556+ 517A              ; *******************************************************************************************************
 557+ 517A              ; function to handle CALL ANIMDEF basic extension
 558+ 517A              ; ANIMITEMPAT ( BYTE id,
 559+ 517A              ;               BYTE size,
 560+ 517A              ;               INT[] list )
 561+ 517A              ; fills animation definition data, returns an error if out of bounds, or invalid type
 562+ 517A              ANIMDEF:
 563+ 517A                  ; opening (
 564+ 517A CD 91 67     	CALL CHKCHAR
 565+ 517D 28           	DB '('
 566+ 517E              	; get id
 567+ 517E DD 21 1C 52  	LD IX, GETBYT
 568+ 5182 CD 59 01     	CALL CALBAS
 569+ 5185 F5               PUSH AF
 570+ 5186                  ; check if out of bounds
 571+ 5186 3C               INC A
 572+ 5187 4F               LD C,A
 573+ 5188 3A 64 4F         LD A,(ANIMDEFNUM)
 574+ 518B B9               CP C
 575+ 518C DA B5 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 576+ 518F              	; comma
 577+ 518F CD 91 67     	CALL CHKCHAR
 578+ 5192 2C           	DB ','
 579+ 5193              	; get size
 580+ 5193 DD 21 1C 52  	LD IX, GETBYT
 581+ 5197 CD 59 01     	CALL CALBAS
 582+ 519A FE 10            CP 16
 583+ 519C D2 B9 67         JP NC, OVERFLOW
 584+ 519F B7               OR A
 585+ 51A0 CA B9 67         JP Z, OVERFLOW
 586+ 51A3 F5           	PUSH AF
 587+ 51A4              	; comma
 588+ 51A4 CD 91 67     	CALL CHKCHAR
 589+ 51A7 2C           	DB ','
 590+ 51A8              	; get pointer to a list of animation items in integer array format
 591+ 51A8                  ; get array pointer
 592+ 51A8 D1               POP DE
 593+ 51A9 D5               PUSH DE
 594+ 51AA 3E 02            LD A,2
 595+ 51AC 06 01            LD B,1
 596+ 51AE CD F6 67         CALL GET_BASIC_ARRAY_DATA_POINTER
 597+ 51B1 C5               PUSH BC
 598+ 51B2              	; ending )
 599+ 51B2 CD 91 67     	CALL CHKCHAR
 600+ 51B5 29           	DB ')'
 601+ 51B6              .ENTRY:
 602+ 51B6 E5               PUSH HL
 603+ 51B7 DD E1            POP IX
 604+ 51B9 D1               POP DE ; pointer to INT array
 605+ 51BA C1               POP BC ; B=item number
 606+ 51BB F1               POP AF ; id
 607+ 51BC D5               PUSH DE
 608+ 51BD CD 7F 4F         CALL GETnthANIMDEF
 609+ 51C0 D1               POP DE
 610+ 51C1 70               LD (HL),B
 611+ 51C2              .L1:
 612+ 51C2 23               INC HL
 613+ 51C3 1A               LD A,(DE)
 614+ 51C4 13          > INC DE
 614+ 51C5 13          > INC DE
 615+ 51C6 77               LD (HL),A
 616+ 51C7 10 F9            DJNZ .L1
 617+ 51C9 DD E5            PUSH IX
 618+ 51CB E1               POP HL
 619+ 51CC C9               RET
 620+ 51CD              ; *******************************************************************************************************
 621+ 51CD               ENDIF
 622+ 51CD
 623+ 51CD               IF (0 == 1)
 624+ 51CD ~            ; *******************************************************************************************************
 625+ 51CD ~            ; same as ANIMDEF but for DEFUSR approach
 626+ 51CD ~            ; input IX=pointer to input array, real data from +2
 627+ 51CD ~            ; +02 = ID
 628+ 51CD ~            ; +04 = list size
 629+ 51CD ~            ; +06 = list pointer
 630+ 51CD ~            ANIMDEF_DEFUSR:
 631+ 51CD ~                ; check if out of bounds
 632+ 51CD ~                LD C,(IX+2)
 633+ 51CD ~                INC C
 634+ 51CD ~                LD A,(ANIMDEFNUM)
 635+ 51CD ~                CP C
 636+ 51CD ~                JR C,.ERR ; invalid id
 637+ 51CD ~            	; get size
 638+ 51CD ~                LD A,(IX+4)
 639+ 51CD ~                CP 16
 640+ 51CD ~                RET NC ; overflow
 641+ 51CD ~                OR A
 642+ 51CD ~                RET Z ; ID=0, invalid
 643+ 51CD ~                LD B,A
 644+ 51CD ~                LD A,C
 645+ 51CD ~                DEC A
 646+ 51CD ~                CALL GETnthANIMDEF
 647+ 51CD ~                LD (HL),B
 648+ 51CD ~                LD E,(IX+6)
 649+ 51CD ~                LD D,(IX+7)
 650+ 51CD ~            .L1:
 651+ 51CD ~                INC HL
 652+ 51CD ~                LD A,(DE)
 653+ 51CD ~                .2 INC DE
 654+ 51CD ~                LD (HL),A
 655+ 51CD ~                DJNZ .L1
 656+ 51CD ~                XOR A ; success
 657+ 51CD ~                RET
 658+ 51CD ~            .ERR:
 659+ 51CD ~                LD A,1
 660+ 51CD ~                RET
 661+ 51CD ~            ; *******************************************************************************************************
 662+ 51CD               ENDIF
 663+ 51CD
 664+ 51CD               IF (0 == 1)
 665+ 51CD ~            ; *******************************************************************************************************
 666+ 51CD ~            ; same as MAXANIMSPRS but for DEFUSR approach
 667+ 51CD ~            ; input IX=pointer to input array, real data from +2
 668+ 51CD ~            ; +2 = number
 669+ 51CD ~            MAXANIMSPRS_DEFUSR:
 670+ 51CD ~                LD A,(IX+2)
 671+ 51CD ~                CALL MAXANIMSPRS.COMMON
 672+ 51CD ~                XOR A ; success
 673+ 51CD ~                RET
 674+ 51CD ~            ; *******************************************************************************************************
 675+ 51CD               ENDIF
 676+ 51CD
 677+ 51CD              ; *******************************************************************************************************
 678+ 51CD              ; function to handle CALL MAXANIMSPRS basic extension
 679+ 51CD              ; MAXANIMSPRS (BYTE number)
 680+ 51CD              ; sets new number and moves memory buffers as needed
 681+ 51CD              MAXANIMSPRS:
 682+ 51CD               IF (1 == 1)
 683+ 51CD              	; opening (
 684+ 51CD CD 91 67     	CALL CHKCHAR
 685+ 51D0 28           	DB '('
 686+ 51D1              	; get value
 687+ 51D1 DD 21 1C 52  	LD IX, GETBYT
 688+ 51D5 CD 59 01     	CALL CALBAS
 689+ 51D8 F5               PUSH AF
 690+ 51D9              	; ending )
 691+ 51D9 CD 91 67     	CALL CHKCHAR
 692+ 51DC 29           	DB ')'
 693+ 51DD F1               POP AF
 694+ 51DE               ENDIF
 695+ 51DE              .COMMON:
 696+ 51DE F3               DI
 697+ 51DF              	; save position
 698+ 51DF E5           	PUSH HL
 699+ 51E0              .ENTRY:
 700+ 51E0 47               LD B,A
 701+ 51E1 3A 67 4F         LD A,(ANIMSPRNUM)
 702+ 51E4 90               SUB B
 703+ 51E5 CA E9 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
 704+ 51E8 FD 21 6B 4F      LD IY,AUTOSGAMPTR
 705+ 51EC FA F8 51         JP M, .INCREASE
 706+ 51EF                  ; new value is lower than previous one
 707+ 51EF CD 19 52         CALL .SIZEDIFF
 708+ 51F2 CD 26 50         CALL MAXANIMITEMS.DECREASE_COMMON
 709+ 51F5 C3 E0 4F         JP MAXANIMITEMS.E3
 710+ 51F8              .INCREASE:
 711+ 51F8 ED 44            NEG
 712+ 51FA F5               PUSH AF; save difference for later to set active flag to 0 of new entires
 713+ 51FB CD 19 52         CALL .SIZEDIFF
 714+ 51FE CD 52 50         CALL MAXANIMITEMS.INCREASE_COMMON
 715+ 5201 AF               XOR A
 716+ 5202 ED 42            SBC HL,BC ; location of new stuff
 717+ 5204 F1               POP AF
 718+ 5205 C5               PUSH BC
 719+ 5206 47               LD B,A
 720+ 5207 11 08 00         LD DE,8
 721+ 520A E5               PUSH HL
 722+ 520B DD E1            POP IX
 723+ 520D              .L1:
 724+ 520D DD 36 06 00      LD (IX+6),0 ; active flag
 725+ 5211 DD 19            ADD IX,DE
 726+ 5213 10 F8            DJNZ .L1
 727+ 5215 C1               POP BC
 728+ 5216 C3 02 50         JP MAXANIMITEMS.E4
 729+ 5219              .SIZEDIFF:
 730+ 5219 26 00            LD H,0
 731+ 521B 6F               LD L,A
 732+ 521C CD 7E 66         CALL HLx8
 733+ 521F 78               LD A,B
 734+ 5220 32 67 4F         LD (ANIMSPRNUM),A
 735+ 5223 44               LD B,H
 736+ 5224 4D               LD C,L
 737+ 5225 C9               RET ; BC=size difference in bytes
 738+ 5226              ; *******************************************************************************************************
 739+ 5226
 740+ 5226               IF (1 == 1)
 741+ 5226              ; *******************************************************************************************************
 742+ 5226              ; function to handle CALL ANIMSPRITE basic extension
 743+ 5226              ; ANIMSPRITE ( BYTE id,
 744+ 5226              ;              BYTE sprite_number,
 745+ 5226              ;              BYTE animation_definition_id,
 746+ 5226              ;              BYTE cyclic_flag )
 747+ 5226              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 748+ 5226              ANIMSPRITE:
 749+ 5226                  ; opening (
 750+ 5226 CD 91 67     	CALL CHKCHAR
 751+ 5229 28           	DB '('
 752+ 522A              	; get sprite animation id
 753+ 522A DD 21 1C 52  	LD IX, GETBYT
 754+ 522E CD 59 01     	CALL CALBAS
 755+ 5231 F5               PUSH AF
 756+ 5232 3C               INC A
 757+ 5233 4F               LD C,A
 758+ 5234 3A 67 4F         LD A,(ANIMSPRNUM)
 759+ 5237 B9               CP C
 760+ 5238 DA B5 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 761+ 523B              	; comma
 762+ 523B CD 91 67     	CALL CHKCHAR
 763+ 523E 2C           	DB ','
 764+ 523F              	; get sprite number
 765+ 523F DD 21 1C 52  	LD IX, GETBYT
 766+ 5243 CD 59 01     	CALL CALBAS
 767+ 5246 F5               PUSH AF
 768+ 5247                  ; check if out of bounds
 769+ 5247 FE 20            CP 32
 770+ 5249 D2 B5 67         JP NC, SUBSCRIPT_OUT_OF_RANGE
 771+ 524C              	; comma
 772+ 524C CD 91 67     	CALL CHKCHAR
 773+ 524F 2C           	DB ','
 774+ 5250              	; get animation definition id
 775+ 5250 DD 21 1C 52  	LD IX, GETBYT
 776+ 5254 CD 59 01     	CALL CALBAS
 777+ 5257 F5               PUSH AF
 778+ 5258 3C               INC A
 779+ 5259 4F               LD C,A
 780+ 525A 3A 64 4F         LD A,(ANIMDEFNUM)
 781+ 525D B9               CP C
 782+ 525E DA B5 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 783+ 5261              	; comma
 784+ 5261 CD 91 67     	CALL CHKCHAR
 785+ 5264 2C           	DB ','
 786+ 5265              	; get cyclic flag
 787+ 5265 DD 21 1C 52  	LD IX, GETBYT
 788+ 5269 CD 59 01         CALL CALBAS
 789+ 526C F5           	PUSH AF
 790+ 526D              	; ending )
 791+ 526D CD 91 67     	CALL CHKCHAR
 792+ 5270 29           	DB ')'
 793+ 5271              .ENTRY:
 794+ 5271 E5               PUSH HL
 795+ 5272 DD E1            POP IX
 796+ 5274 D9               EXX
 797+ 5275 D1               POP DE ; cyclic
 798+ 5276 C1               POP BC ; animation definition id
 799+ 5277 E1               POP HL ; sprite number
 800+ 5278 D9               EXX
 801+ 5279 F1               POP AF ; sprite animation id
 802+ 527A CD 8B 4F         CALL GETnthSPRANIM
 803+ 527D E5               PUSH HL
 804+ 527E FD E1            POP IY
 805+ 5280 D9               EXX
 806+ 5281 FD 74 00         LD (IY),H
 807+ 5284 FD 70 04         LD (IY+4),B
 808+ 5287 FD 72 05         LD (IY+5),D
 809+ 528A                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 810+ 528A                  ; following will do preparation for ANIMSTEP situation
 811+ 528A                  ; current item set to above limit and timer to 1
 812+ 528A                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 813+ 528A FD 36 03 FF      LD (IY+3),255
 814+ 528E FD 36 01 01      LD (IY+1),1
 815+ 5292 FD 36 02 00      LD (IY+2),0
 816+ 5296                  ; mark as sprite animation
 817+ 5296 FD 36 07 00      LD (IY+7),0
 818+ 529A DD E5            PUSH IX
 819+ 529C E1               POP HL
 820+ 529D C9               RET
 821+ 529E              ; *******************************************************************************************************
 822+ 529E               ENDIF
 823+ 529E
 824+ 529E               IF (0 == 1)
 825+ 529E ~            ; *******************************************************************************************************
 826+ 529E ~            ; same as ANIMSPRITE but for DEFUSR approach
 827+ 529E ~            ; input IX=pointer to input array, real data from +2
 828+ 529E ~            ; +02 = ID
 829+ 529E ~            ; +04 = sprite number
 830+ 529E ~            ; +06 = animation definition id
 831+ 529E ~            ; +08 = cyclic flag
 832+ 529E ~            ANIMSPRITE_DEFUSR:
 833+ 529E ~                LD C,(IX+2)
 834+ 529E ~                INC C
 835+ 529E ~                LD A,(ANIMSPRNUM)
 836+ 529E ~                CP C
 837+ 529E ~                JR C,.ERR ; invalid id
 838+ 529E ~            	; get sprite number
 839+ 529E ~                LD A,(IX+4)
 840+ 529E ~                CP 32
 841+ 529E ~                JR NC,.ERR ; invalid sprite id
 842+ 529E ~                LD B,(IX+6)
 843+ 529E ~                INC B
 844+ 529E ~                LD A,(ANIMDEFNUM)
 845+ 529E ~                CP B
 846+ 529E ~                JR C,.ERR ; invalid animation definition id
 847+ 529E ~                LD A,C
 848+ 529E ~                DEC A
 849+ 529E ~                CALL GETnthSPRANIM
 850+ 529E ~                LD A,(IX+4)
 851+ 529E ~                LD (HL),A ; +0
 852+ 529E ~                INC HL
 853+ 529E ~                LD (HL),1 ; +1
 854+ 529E ~                INC HL
 855+ 529E ~                LD (HL),0 ; +2
 856+ 529E ~                INC HL
 857+ 529E ~                LD (HL),255 ; +3
 858+ 529E ~                INC HL
 859+ 529E ~                DEC B
 860+ 529E ~                LD (HL),B ; +4
 861+ 529E ~                INC HL
 862+ 529E ~                LD A,(IX+8) ; +5
 863+ 529E ~                LD (HL),A
 864+ 529E ~                INC HL
 865+ 529E ~                INC HL
 866+ 529E ~                LD (HL),0 ; +7
 867+ 529E ~                XOR A ; success
 868+ 529E ~                RET
 869+ 529E ~            .ERR:
 870+ 529E ~                LD A,1
 871+ 529E ~                RET
 872+ 529E ~            ; *******************************************************************************************************
 873+ 529E               ENDIF
 874+ 529E
 875+ 529E
 876+ 529E               IF (1 == 1)
 877+ 529E              ; *******************************************************************************************************
 878+ 529E              ; function to handle CALL ANIMCHAR basic extension
 879+ 529E              ; ANIMCHAR ( BYTE id,
 880+ 529E              ;            INT character number 0-767,
 881+ 529E              ;            BYTE animation_definition_id,
 882+ 529E              ;            BYTE cyclic_flag )
 883+ 529E              ; fills sprite animation data, returns an error if out of bounds, or invalid type
 884+ 529E              ANIMCHAR:
 885+ 529E                  ; opening (
 886+ 529E CD 91 67     	CALL CHKCHAR
 887+ 52A1 28           	DB '('
 888+ 52A2              	; get sprite animation id
 889+ 52A2 DD 21 1C 52  	LD IX, GETBYT
 890+ 52A6 CD 59 01     	CALL CALBAS
 891+ 52A9 F5               PUSH AF
 892+ 52AA 3C               INC A
 893+ 52AB 4F               LD C,A
 894+ 52AC 3A 67 4F         LD A,(ANIMSPRNUM)
 895+ 52AF B9               CP C
 896+ 52B0 DA B5 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 897+ 52B3              	; comma
 898+ 52B3 CD 91 67     	CALL CHKCHAR
 899+ 52B6 2C           	DB ','
 900+ 52B7              	; get character number
 901+ 52B7 DD 21 2F 54  	LD IX, FRMQNT
 902+ 52BB CD 59 01     	CALL CALBAS
 903+ 52BE D5               PUSH DE
 904+ 52BF                  ; check if out of bounds
 905+ 52BF 7A               LD A,D
 906+ 52C0 FE 03            CP 3
 907+ 52C2 D2 B5 67         JP NC, SUBSCRIPT_OUT_OF_RANGE
 908+ 52C5              	; comma
 909+ 52C5 CD 91 67     	CALL CHKCHAR
 910+ 52C8 2C           	DB ','
 911+ 52C9              	; get animation definition id
 912+ 52C9 DD 21 1C 52  	LD IX, GETBYT
 913+ 52CD CD 59 01     	CALL CALBAS
 914+ 52D0 F5               PUSH AF
 915+ 52D1 3C               INC A
 916+ 52D2 4F               LD C,A
 917+ 52D3 3A 64 4F         LD A,(ANIMDEFNUM)
 918+ 52D6 B9               CP C
 919+ 52D7 DA B5 67         JP C,SUBSCRIPT_OUT_OF_RANGE
 920+ 52DA              	; comma
 921+ 52DA CD 91 67     	CALL CHKCHAR
 922+ 52DD 2C           	DB ','
 923+ 52DE              	; get cyclic flag
 924+ 52DE DD 21 1C 52  	LD IX, GETBYT
 925+ 52E2 CD 59 01         CALL CALBAS
 926+ 52E5 F5           	PUSH AF
 927+ 52E6              	; ending )
 928+ 52E6 CD 91 67     	CALL CHKCHAR
 929+ 52E9 29           	DB ')'
 930+ 52EA              .ENTRY:
 931+ 52EA E5               PUSH HL
 932+ 52EB DD E1            POP IX
 933+ 52ED D9               EXX
 934+ 52EE D1               POP DE ; cyclic
 935+ 52EF C1               POP BC ; animation definition id
 936+ 52F0 E1               POP HL ; character number
 937+ 52F1 D9               EXX
 938+ 52F2 F1               POP AF ; sprite animation id
 939+ 52F3 CD 8B 4F         CALL GETnthSPRANIM
 940+ 52F6 E5               PUSH HL
 941+ 52F7 FD E1            POP IY
 942+ 52F9 D9               EXX
 943+ 52FA FD 75 00         LD (IY),L
 944+ 52FD 24               INC H ; save character bank+1
 945+ 52FE FD 74 07         LD (IY+7),H
 946+ 5301 FD 70 04         LD (IY+4),B
 947+ 5304 FD 72 05         LD (IY+5),D
 948+ 5307                  ;LD (IY+6),0 -- not needed as set in MAXANIMSPRS
 949+ 5307                  ; following will do preparation for ANIMSTEP situation
 950+ 5307                  ; current item set to above limit and timer to 1
 951+ 5307                  ; any call to ANIMSTEP will switch and setup to first item for cyclic
 952+ 5307 FD 36 03 FF      LD (IY+3),255
 953+ 530B FD 36 01 01      LD (IY+1),1
 954+ 530F FD 36 02 00      LD (IY+2),0
 955+ 5313 DD E5            PUSH IX
 956+ 5315 E1               POP HL
 957+ 5316 C9               RET
 958+ 5317              ; *******************************************************************************************************
 959+ 5317               ENDIF
 960+ 5317
 961+ 5317               IF (0 == 1)
 962+ 5317 ~            ; *******************************************************************************************************
 963+ 5317 ~            ; same as ANIMCHAR but for DEFUSR approach
 964+ 5317 ~            ; input IX=pointer to input array, real data from +2
 965+ 5317 ~            ; +02 = ID
 966+ 5317 ~            ; +04 = character number
 967+ 5317 ~            ; +06 = animation definition id
 968+ 5317 ~            ; +08 = cyclic flag
 969+ 5317 ~            ANIMCHAR_DEFUSR:
 970+ 5317 ~                LD C,(IX+2)
 971+ 5317 ~                INC C
 972+ 5317 ~                LD A,(ANIMSPRNUM)
 973+ 5317 ~                CP C
 974+ 5317 ~                JR C,.ERR ; invalid id
 975+ 5317 ~            	; get sprite number
 976+ 5317 ~                LD A,(IX+5)
 977+ 5317 ~                CP 3
 978+ 5317 ~                JR NC,.ERR ; invalid character (>767)
 979+ 5317 ~                LD B,(IX+6)
 980+ 5317 ~                INC B
 981+ 5317 ~                LD A,(ANIMDEFNUM)
 982+ 5317 ~                CP B
 983+ 5317 ~                JR C,.ERR ; invalid animation definition id
 984+ 5317 ~                LD A,C
 985+ 5317 ~                DEC A
 986+ 5317 ~                CALL GETnthSPRANIM
 987+ 5317 ~                LD A,(IX+4)
 988+ 5317 ~                LD (HL),A ; +0
 989+ 5317 ~                INC HL
 990+ 5317 ~                LD (HL),1 ; +1
 991+ 5317 ~                INC HL
 992+ 5317 ~                LD (HL),0 ; +2
 993+ 5317 ~                INC HL
 994+ 5317 ~                LD (HL),255 ; +3
 995+ 5317 ~                INC HL
 996+ 5317 ~                DEC B
 997+ 5317 ~                LD (HL),B ; +4
 998+ 5317 ~                INC HL
 999+ 5317 ~                LD A,(IX+8) ; +5
1000+ 5317 ~                LD (HL),A
1001+ 5317 ~                INC HL
1002+ 5317 ~                INC HL
1003+ 5317 ~                LD A,(IX+5)
1004+ 5317 ~                INC A
1005+ 5317 ~                LD (HL),A ; +7
1006+ 5317 ~                XOR A ; success
1007+ 5317 ~                RET
1008+ 5317 ~            .ERR:
1009+ 5317 ~                LD A,1
1010+ 5317 ~                RET
1011+ 5317 ~            ; *******************************************************************************************************
1012+ 5317               ENDIF
1013+ 5317
1014+ 5317               IF (0 == 1)
1015+ 5317 ~            ; *******************************************************************************************************
1016+ 5317 ~            ; same as MAXAUTOSGAMS but for DEFUSR approach
1017+ 5317 ~            ; input IX=pointer to input array, real data from +2
1018+ 5317 ~            ; +2 = number
1019+ 5317 ~            MAXAUTOSGAMS_DEFUSR:
1020+ 5317 ~                LD A,(IX+2)
1021+ 5317 ~                CALL MAXAUTOSGAMS.COMMON
1022+ 5317 ~                XOR A ; success
1023+ 5317 ~                RET
1024+ 5317 ~            ; *******************************************************************************************************
1025+ 5317               ENDIF
1026+ 5317
1027+ 5317              ; *******************************************************************************************************
1028+ 5317              ; function to handle CALL MAXAUTOSGAMS basic extension
1029+ 5317              ; MAXAUTOSGAMS (BYTE number)
1030+ 5317              ; sets new number and moves memory buffers as needed
1031+ 5317              MAXAUTOSGAMS:
1032+ 5317               IF (1 == 1)
1033+ 5317              	; opening (
1034+ 5317 CD 91 67     	CALL CHKCHAR
1035+ 531A 28           	DB '('
1036+ 531B              	; get value
1037+ 531B DD 21 1C 52  	LD IX, GETBYT
1038+ 531F CD 59 01     	CALL CALBAS
1039+ 5322 F5               PUSH AF
1040+ 5323              	; ending )
1041+ 5323 CD 91 67     	CALL CHKCHAR
1042+ 5326 29           	DB ')'
1043+ 5327 F1               POP AF
1044+ 5328               ENDIF
1045+ 5328              .COMMON:
1046+ 5328 F3               DI
1047+ 5329              	; save position
1048+ 5329 E5           	PUSH HL
1049+ 532A              .ENTRY:
1050+ 532A 47               LD B,A
1051+ 532B 3A 6A 4F         LD A,(AUTOSGAMNUM)
1052+ 532E 90               SUB B
1053+ 532F CA E9 4F         JP Z, MAXANIMITEMS.EXIT; same value as before
1054+ 5332 FD 21 10 40      LD IY,FREEMEMPTR
1055+ 5336 FA 42 53         JP M, .INCREASE
1056+ 5339                  ; new value is lower than previous one
1057+ 5339 CD 63 53         CALL .SIZEDIFF
1058+ 533C CD 26 50         CALL MAXANIMITEMS.DECREASE_COMMON
1059+ 533F C3 E9 4F         JP MAXANIMITEMS.EXIT
1060+ 5342              .INCREASE:
1061+ 5342 ED 44            NEG
1062+ 5344 F5               PUSH AF; save difference for later to set active flag to 0 of new entires
1063+ 5345 CD 63 53         CALL .SIZEDIFF
1064+ 5348 CD 52 50         CALL MAXANIMITEMS.INCREASE_COMMON
1065+ 534B AF               XOR A
1066+ 534C ED 42            SBC HL,BC ; location of new stuff
1067+ 534E F1               POP AF
1068+ 534F C5               PUSH BC
1069+ 5350 47               LD B,A
1070+ 5351 11 18 00         LD DE,24
1071+ 5354 E5               PUSH HL
1072+ 5355 DD E1            POP IX
1073+ 5357              .L1:
1074+ 5357 DD 36 13 00      LD (IX+19),0 ; active flag
1075+ 535B DD 19            ADD IX,DE
1076+ 535D 10 F8            DJNZ .L1
1077+ 535F C1               POP BC
1078+ 5360 C3 E9 4F         JP MAXANIMITEMS.EXIT
1079+ 5363              .SIZEDIFF:
1080+ 5363 26 00            LD H,0
1081+ 5365 6F               LD L,A
1082+ 5366 CD 7E 66         CALL HLx8
1083+ 5369 54               LD D,H
1084+ 536A 5D               LD E,L
1085+ 536B 29               ADD HL,HL
1086+ 536C 19               ADD HL,DE
1087+ 536D 78               LD A,B
1088+ 536E 32 6A 4F         LD (AUTOSGAMNUM),A
1089+ 5371 44               LD B,H
1090+ 5372 4D               LD C,L
1091+ 5373 C9               RET ; BC=size difference in bytes
1092+ 5374              ; *******************************************************************************************************
1093+ 5374
1094+ 5374               IF (1 == 1)
1095+ 5374              ; *******************************************************************************************************
1096+ 5374              ; function to handle CALL AUTOSGAMDEF basic extension
1097+ 5374              ; AUTOSGAMDEF ( BYTE id,
1098+ 5374              ;               INT VARIABLE x, INT VARIABLE y,
1099+ 5374              ;               INT minimum, INT maximum, INT delta,
1100+ 5374              ;               INT direction =0 horizontal,
1101+ 5374              ;               INT ticks,
1102+ 5374              ;               BYTE sprite_group_count,
1103+ 5374              ;               INT[2][sprite_group_count] VARIABLE sprite_group,
1104+ 5374              ;               BYTE item_number,
1105+ 5374              ;               INT[] VARIABLE sprite_animations_negative_direction,
1106+ 5374              ;               INT[] VARIABLE sprite_animations_positive_direction
1107+ 5374              AUTOSGAMDEF:
1108+ 5374                  ; opening (
1109+ 5374 CD 91 67     	CALL CHKCHAR
1110+ 5377 28           	DB '('
1111+ 5378              	; get sprite animation id
1112+ 5378 DD 21 1C 52  	LD IX, GETBYT
1113+ 537C CD 59 01     	CALL CALBAS
1114+ 537F F5               PUSH AF
1115+ 5380 3C               INC A
1116+ 5381 4F               LD C,A
1117+ 5382 3A 6A 4F         LD A,(AUTOSGAMNUM)
1118+ 5385 B9               CP C
1119+ 5386 DA B5 67         JP C,SUBSCRIPT_OUT_OF_RANGE
1120+ 5389 F1               POP AF
1121+ 538A E5               PUSH HL
1122+ 538B CD 97 4F         CALL GETnthAUTOSGAM
1123+ 538E 22 56 64         LD (BLIT_TMP),HL ; for later
1124+ 5391 E1               POP HL
1125+ 5392              	; comma
1126+ 5392 CD 91 67     	CALL CHKCHAR
1127+ 5395 2C           	DB ','
1128+ 5396              	; get address of the X coordinate variable
1129+ 5396 DD 21 A4 5E  	LD IX, PTRGET
1130+ 539A CD 59 01     	CALL CALBAS
1131+ 539D DD 2A 56 64  	LD IX,(BLIT_TMP)
1132+ 53A1 DD 73 00         LD (IX+0),E
1133+ 53A4 DD 72 01         LD (IX+1),D
1134+ 53A7              	; comma
1135+ 53A7 CD 91 67     	CALL CHKCHAR
1136+ 53AA 2C           	DB ','
1137+ 53AB              	; get address of the Y coordinate variable
1138+ 53AB DD 21 A4 5E  	LD IX, PTRGET
1139+ 53AF CD 59 01     	CALL CALBAS
1140+ 53B2 DD 2A 56 64  	LD IX,(BLIT_TMP)
1141+ 53B6 DD 73 02         LD (IX+2),E
1142+ 53B9 DD 72 03         LD (IX+3),D
1143+ 53BC              	; comma
1144+ 53BC CD 91 67     	CALL CHKCHAR
1145+ 53BF 2C           	DB ','
1146+ 53C0              	; get minimum value
1147+ 53C0 DD 21 2F 54  	LD IX, FRMQNT
1148+ 53C4 CD 59 01     	CALL CALBAS
1149+ 53C7 DD 2A 56 64  	LD IX,(BLIT_TMP)
1150+ 53CB DD 73 04         LD (IX+4),E
1151+ 53CE DD 72 05         LD (IX+5),D
1152+ 53D1              	; comma
1153+ 53D1 CD 91 67     	CALL CHKCHAR
1154+ 53D4 2C           	DB ','
1155+ 53D5              	; get maximum value
1156+ 53D5 DD 21 2F 54  	LD IX, FRMQNT
1157+ 53D9 CD 59 01     	CALL CALBAS
1158+ 53DC DD 2A 56 64  	LD IX,(BLIT_TMP)
1159+ 53E0 DD 73 06         LD (IX+6),E
1160+ 53E3 DD 72 07         LD (IX+7),D
1161+ 53E6              	; comma
1162+ 53E6 CD 91 67     	CALL CHKCHAR
1163+ 53E9 2C           	DB ','
1164+ 53EA              	; get delta value
1165+ 53EA DD 21 2F 54  	LD IX, FRMQNT
1166+ 53EE CD 59 01     	CALL CALBAS
1167+ 53F1 DD 2A 56 64  	LD IX,(BLIT_TMP)
1168+ 53F5 DD 73 08         LD (IX+8),E
1169+ 53F8 DD 72 09         LD (IX+9),D
1170+ 53FB              	; comma
1171+ 53FB CD 91 67     	CALL CHKCHAR
1172+ 53FE 2C           	DB ','
1173+ 53FF              	; get direction value
1174+ 53FF DD 21 2F 54  	LD IX, FRMQNT
1175+ 5403 CD 59 01     	CALL CALBAS
1176+ 5406 DD 2A 56 64  	LD IX,(BLIT_TMP)
1177+ 540A DD 73 0A         LD (IX+10),E
1178+ 540D              	; comma
1179+ 540D CD 91 67     	CALL CHKCHAR
1180+ 5410 2C           	DB ','
1181+ 5411              	; get ticks value
1182+ 5411 DD 21 2F 54  	LD IX, FRMQNT
1183+ 5415 CD 59 01     	CALL CALBAS
1184+ 5418 DD 2A 56 64  	LD IX,(BLIT_TMP)
1185+ 541C DD 73 14         LD (IX+20),E
1186+ 541F DD 72 15         LD (IX+21),D
1187+ 5422              	; comma
1188+ 5422 CD 91 67     	CALL CHKCHAR
1189+ 5425 2C           	DB ','
1190+ 5426              	; get sprite group count
1191+ 5426 DD 21 1C 52  	LD IX, GETBYT
1192+ 542A CD 59 01     	CALL CALBAS
1193+ 542D B7               OR A
1194+ 542E CA B5 67         JP Z,SUBSCRIPT_OUT_OF_RANGE
1195+ 5431 DD 2A 56 64  	LD IX,(BLIT_TMP)
1196+ 5435 DD 77 0B         LD (IX+11),A
1197+ 5438              	; comma
1198+ 5438 CD 91 67     	CALL CHKCHAR
1199+ 543B 2C           	DB ','
1200+ 543C              	; get sprite group definition array data pointer
1201+ 543C DD 2A 56 64  	LD IX,(BLIT_TMP)
1202+ 5440 DD 5E 0B         LD E,(IX+11)
1203+ 5443 16 03        	LD D,3
1204+ 5445 3E 02        	LD A,2
1205+ 5447 47           	LD B,A
1206+ 5448 CD F6 67     	CALL GET_BASIC_ARRAY_DATA_POINTER
1207+ 544B DD 2A 56 64  	LD IX,(BLIT_TMP)
1208+ 544F DD 71 0C     	LD (IX+12),C
1209+ 5452 DD 70 0D         LD (IX+13),B
1210+ 5455              	; comma
1211+ 5455 CD 91 67     	CALL CHKCHAR
1212+ 5458 2C           	DB ','
1213+ 5459              	; get sprite animation array size
1214+ 5459 DD 21 1C 52  	LD IX,GETBYT
1215+ 545D CD 59 01     	CALL CALBAS
1216+ 5460 DD 2A 56 64  	LD IX,(BLIT_TMP)
1217+ 5464 DD 77 0E         LD (IX+14),A
1218+ 5467 B7               OR A
1219+ 5468 CA B5 67         JP Z,SUBSCRIPT_OUT_OF_RANGE
1220+ 546B              	; comma
1221+ 546B CD 91 67     	CALL CHKCHAR
1222+ 546E 2C           	DB ','
1223+ 546F                  ; get array pointer for negative direction
1224+ 546F DD 2A 56 64  	LD IX,(BLIT_TMP)
1225+ 5473 DD 56 0E         LD D,(IX+14)
1226+ 5476 3E 02            LD A,2
1227+ 5478 06 01            LD B,1
1228+ 547A CD F6 67         CALL GET_BASIC_ARRAY_DATA_POINTER
1229+ 547D DD 2A 56 64  	LD IX,(BLIT_TMP)
1230+ 5481 DD 71 0F         LD (IX+15),C
1231+ 5484 DD 70 10         LD (IX+16),B
1232+ 5487              	; comma
1233+ 5487 CD 91 67     	CALL CHKCHAR
1234+ 548A 2C           	DB ','
1235+ 548B                  ; get array pointer for positive direction
1236+ 548B DD 2A 56 64  	LD IX,(BLIT_TMP)
1237+ 548F DD 56 0E         LD D,(IX+14)
1238+ 5492 3E 02            LD A,2
1239+ 5494 06 01            LD B,1
1240+ 5496 CD F6 67         CALL GET_BASIC_ARRAY_DATA_POINTER
1241+ 5499 DD 2A 56 64  	LD IX,(BLIT_TMP)
1242+ 549D DD 71 11         LD (IX+17),C
1243+ 54A0 DD 70 12         LD (IX+18),B
1244+ 54A3              	; ending )
1245+ 54A3 CD 91 67     	CALL CHKCHAR
1246+ 54A6 29           	DB ')'
1247+ 54A7 C9               RET
1248+ 54A8              ; *******************************************************************************************************
1249+ 54A8               ENDIF
1250+ 54A8
1251+ 54A8               IF (0 == 1)
1252+ 54A8 ~            ; *******************************************************************************************************
1253+ 54A8 ~            ; same as AUTOSGAMDEF but for DEFUSR approach
1254+ 54A8 ~            ; input IX=pointer to input array, real data from +2
1255+ 54A8 ~            ; +02 = ID
1256+ 54A8 ~            ; +04 = pointer to X variable
1257+ 54A8 ~            ; +06 = pointer to Y variable
1258+ 54A8 ~            ; +08 = minimum
1259+ 54A8 ~            ; +10 = maximum
1260+ 54A8 ~            ; +12 = delta
1261+ 54A8 ~            ; +14 = direction
1262+ 54A8 ~            ; +16 = ticks
1263+ 54A8 ~            ; +18 = sprite group count
1264+ 54A8 ~            ; +20 = sprite group array pointer
1265+ 54A8 ~            ; +22 = item number
1266+ 54A8 ~            ; +24 = sprite animations negative direction array pointer
1267+ 54A8 ~            ; +26 = sprite animations positive direction array pointer
1268+ 54A8 ~            AUTOSGAMDEF_DEFUSR:
1269+ 54A8 ~                LD C,(IX+2)
1270+ 54A8 ~                INC C
1271+ 54A8 ~                LD A,(AUTOSGAMNUM)
1272+ 54A8 ~                CP C
1273+ 54A8 ~                JP C,.ERR ; invalid id
1274+ 54A8 ~                LD A,C
1275+ 54A8 ~                DEC A
1276+ 54A8 ~                CALL GETnthAUTOSGAM
1277+ 54A8 ~                PUSH HL
1278+ 54A8 ~                POP IY
1279+ 54A8 ~                ; X variable
1280+ 54A8 ~                LD A,(IX+4)
1281+ 54A8 ~                LD (IY+0),A
1282+ 54A8 ~                LD A,(IX+5)
1283+ 54A8 ~                LD (IY+1),A
1284+ 54A8 ~            	; Y variable
1285+ 54A8 ~                LD A,(IX+6)
1286+ 54A8 ~                LD (IY+2),A
1287+ 54A8 ~                LD A,(IX+7)
1288+ 54A8 ~                LD (IY+3),A
1289+ 54A8 ~            	; get minimum value
1290+ 54A8 ~                LD A,(IX+8)
1291+ 54A8 ~                LD (IY+4),A
1292+ 54A8 ~                LD A,(IX+9)
1293+ 54A8 ~                LD (IY+5),A
1294+ 54A8 ~            	; get maximum value
1295+ 54A8 ~                LD A,(IX+10)
1296+ 54A8 ~                LD (IY+6),A
1297+ 54A8 ~                LD A,(IX+11)
1298+ 54A8 ~                LD (IY+7),A
1299+ 54A8 ~            	; get delta value
1300+ 54A8 ~                LD A,(IX+12)
1301+ 54A8 ~                LD (IY+8),A
1302+ 54A8 ~                LD A,(IX+13)
1303+ 54A8 ~                LD (IY+9),A
1304+ 54A8 ~            	; get direction value
1305+ 54A8 ~                LD A,(IX+14)
1306+ 54A8 ~                LD (IY+10),A
1307+ 54A8 ~            	; get ticks value
1308+ 54A8 ~                LD A,(IX+16)
1309+ 54A8 ~                LD (IY+20),A
1310+ 54A8 ~                LD A,(IX+17)
1311+ 54A8 ~                LD (IY+21),A
1312+ 54A8 ~            	; get sprite group count
1313+ 54A8 ~                LD A,(IX+18)
1314+ 54A8 ~                LD (IY+11),A
1315+ 54A8 ~            	; get sprite group definition array data pointer
1316+ 54A8 ~                LD A,(IX+20)
1317+ 54A8 ~                LD (IY+12),A
1318+ 54A8 ~                LD A,(IX+21)
1319+ 54A8 ~                LD (IY+13),A
1320+ 54A8 ~            	; get sprite animation array size
1321+ 54A8 ~                LD A,(IX+22)
1322+ 54A8 ~                LD (IY+14),A
1323+ 54A8 ~                ; get array pointer for negative direction
1324+ 54A8 ~                LD A,(IX+24)
1325+ 54A8 ~                LD (IY+15),A
1326+ 54A8 ~                LD A,(IX+25)
1327+ 54A8 ~                LD (IY+16),A
1328+ 54A8 ~                ; get array pointer for positive direction
1329+ 54A8 ~                LD A,(IX+26)
1330+ 54A8 ~                LD (IY+17),A
1331+ 54A8 ~                LD A,(IX+27)
1332+ 54A8 ~                LD (IY+18),A
1333+ 54A8 ~                XOR A ; success
1334+ 54A8 ~                RET
1335+ 54A8 ~            .ERR:
1336+ 54A8 ~                LD A,1
1337+ 54A8 ~                RET
1338+ 54A8 ~            ; *******************************************************************************************************
1339+ 54A8               ENDIF
1340+ 54A8
1341+ 54A8               IF (1 == 1)
1342+ 54A8              ; *******************************************************************************************************
1343+ 54A8              ; function to handle CALL AUTOSGAMSTART basic extension
1344+ 54A8              ; AUTOSGAMSTART ( BYTE id )
1345+ 54A8              AUTOSGAMSTART:
1346+ 54A8 3E 01            LD A,1
1347+ 54AA              .COMMON:
1348+ 54AA 32 D6 54         LD (.SETVALUE+3),A
1349+ 54AD                  ; opening (
1350+ 54AD CD 91 67     	CALL CHKCHAR
1351+ 54B0 28           	DB '('
1352+ 54B1              	; get sprite animation id
1353+ 54B1 DD 21 1C 52  	LD IX, GETBYT
1354+ 54B5 CD 59 01     	CALL CALBAS
1355+ 54B8 F5               PUSH AF
1356+ 54B9 3C               INC A
1357+ 54BA 4F               LD C,A
1358+ 54BB 3A 6A 4F         LD A,(AUTOSGAMNUM)
1359+ 54BE B9               CP C
1360+ 54BF DA B5 67         JP C,SUBSCRIPT_OUT_OF_RANGE
1361+ 54C2 F1               POP AF
1362+ 54C3 E5               PUSH HL
1363+ 54C4 CD 97 4F         CALL GETnthAUTOSGAM
1364+ 54C7 E5               PUSH HL
1365+ 54C8 DD E1            POP IX
1366+ 54CA E1               POP HL
1367+ 54CB DD E5            PUSH IX
1368+ 54CD              	; ending )
1369+ 54CD CD 91 67     	CALL CHKCHAR
1370+ 54D0 29           	DB ')'
1371+ 54D1
1372+ 54D1                  ; so syntax is fine
1373+ 54D1 DD E1            POP IX
1374+ 54D3              .SETVALUE:
1375+ 54D3 DD 36 13 01      LD (IX+19),1 ; active flag
1376+ 54D7                  ; set initial timer
1377+ 54D7 DD 7E 14         LD A,(IX+20)
1378+ 54DA DD 77 16         LD (IX+22),A
1379+ 54DD DD 7E 15         LD A,(IX+21)
1380+ 54E0 DD 77 17         LD (IX+23),A
1381+ 54E3 C9               RET
1382+ 54E4              ; *******************************************************************************************************
1383+ 54E4
1384+ 54E4              ; *******************************************************************************************************
1385+ 54E4              ; function to handle CALL AUTOSGAMSTOP basic extension
1386+ 54E4              ; AUTOSGAMSTOP ( BYTE id )
1387+ 54E4              AUTOSGAMSTOP:
1388+ 54E4 AF               XOR A
1389+ 54E5 18 C3            JR AUTOSGAMSTART.COMMON
1390+ 54E7              ; *******************************************************************************************************
1391+ 54E7               ENDIF
1392+ 54E7
1393+ 54E7               IF (0 == 1)
1394+ 54E7 ~            ; *******************************************************************************************************
1395+ 54E7 ~            ; function to handle CALL AUTOSGAMSTART basic extension in DEFUSR mode
1396+ 54E7 ~            ; input IX=pointer to input array, real data from +2
1397+ 54E7 ~            ; +2 = source address
1398+ 54E7 ~            AUTOSGAMSTART_DEFUSR:
1399+ 54E7 ~                LD A,1
1400+ 54E7 ~            .COMMON:
1401+ 54E7 ~                LD (.SETVALUE+3),A
1402+ 54E7 ~                LD C,(IX+2)
1403+ 54E7 ~                INC C
1404+ 54E7 ~                LD A,(AUTOSGAMNUM)
1405+ 54E7 ~                CP C
1406+ 54E7 ~                JR C,.ERR ; invalid id
1407+ 54E7 ~                LD A,C
1408+ 54E7 ~                DEC A
1409+ 54E7 ~                CALL GETnthAUTOSGAM
1410+ 54E7 ~                PUSH HL
1411+ 54E7 ~                POP IX
1412+ 54E7 ~            .SETVALUE:
1413+ 54E7 ~                LD (IX+19),1 ; active flag
1414+ 54E7 ~                ; set initial timer
1415+ 54E7 ~                LD A,(IX+20)
1416+ 54E7 ~                LD (IX+22),A
1417+ 54E7 ~                LD A,(IX+21)
1418+ 54E7 ~                LD (IX+23),A
1419+ 54E7 ~                XOR A ; success
1420+ 54E7 ~                RET
1421+ 54E7 ~            .ERR:
1422+ 54E7 ~                LD A,1
1423+ 54E7 ~                RET
1424+ 54E7 ~            ; *******************************************************************************************************
1425+ 54E7 ~
1426+ 54E7 ~            ; *******************************************************************************************************
1427+ 54E7 ~            ; function to handle CALL AUTOSGAMSTOP basic extension in DEFUSR mode
1428+ 54E7 ~            ; input IX=pointer to input array, real data from +2
1429+ 54E7 ~            ; +2 = source address
1430+ 54E7 ~            AUTOSGAMSTOP_DEFUSR:
1431+ 54E7 ~                XOR A
1432+ 54E7 ~                JR AUTOSGAMSTART_DEFUSR.COMMON
1433+ 54E7 ~            ; *******************************************************************************************************
1434+ 54E7               ENDIF
1435+ 54E7
1436+ 54E7               IF (1 == 1)
1437+ 54E7              ; *******************************************************************************************************
1438+ 54E7              ; function to handle CALL ANIMSTEP basic extension
1439+ 54E7              ; two forms
1440+ 54E7              ; ANIMSTEP ( BYTE id )
1441+ 54E7              ; or
1442+ 54E7              ; ANIMSTEP ( BYTE item_number,
1443+ 54E7              ;            INT[] sprite_animations )
1444+ 54E7              ANIMSTEP:
1445+ 54E7 11 66 55         LD DE,ANIMSTARTSTOP_COMMON.STEP
1446+ 54EA 18 08            JR ANIMSTARTSTOP_COMMON
1447+ 54EC              ; *******************************************************************************************************
1448+ 54EC              ; *******************************************************************************************************
1449+ 54EC              ; function to handle CALL ANIMSTART basic extension
1450+ 54EC              ; two forms
1451+ 54EC              ; ANIMSTART ( BYTE id )
1452+ 54EC              ; or
1453+ 54EC              ; ANIMSTART ( BYTE item_number,
1454+ 54EC              ;             INT[] sprite_animations )
1455+ 54EC              ; sets active flag to 1
1456+ 54EC              ANIMSTART:
1457+ 54EC 11 54 55         LD DE,ANIMSTARTSTOP_COMMON.START
1458+ 54EF 18 03            JR ANIMSTARTSTOP_COMMON
1459+ 54F1              ; *******************************************************************************************************
1460+ 54F1              ; *******************************************************************************************************
1461+ 54F1              ; function to handle CALL ANIMSTOP basic extension
1462+ 54F1              ; two forms
1463+ 54F1              ; ANIMSTOP ( BYTE id )
1464+ 54F1              ; or
1465+ 54F1              ; ANIMSTOP ( BYTE item_number,
1466+ 54F1              ;            INT[] sprite_animations )
1467+ 54F1              ; sets active flag to 0
1468+ 54F1              ANIMSTOP:
1469+ 54F1 11 61 55         LD DE,ANIMSTARTSTOP_COMMON.STOP
1470+ 54F4              ; *******************************************************************************************************
1471+ 54F4              ANIMSTARTSTOP_COMMON:
1472+ 54F4 ED 53 52 55      LD (ANIMSTARTSTOP_COMMON.FN+1),DE
1473+ 54F8                  ; opening (
1474+ 54F8 CD 91 67     	CALL CHKCHAR
1475+ 54FB 28           	DB '('
1476+ 54FC              	; get sprite animation id or array size
1477+ 54FC DD 21 1C 52  	LD IX,GETBYT
1478+ 5500 CD 59 01     	CALL CALBAS
1479+ 5503 F5               PUSH AF
1480+ 5504                  ; check if comma present
1481+ 5504 CD 9B 67         CALL GETPREVCHAR
1482+ 5507 23               INC HL
1483+ 5508 FE 2C            CP ','
1484+ 550A 28 0E            JR Z,.L1
1485+ 550C FE 29            CP ')'
1486+ 550E C2 C1 67         JP NZ,SYNTAX_ERROR
1487+ 5511                  ; ok so single argument variant
1488+ 5511 F1               POP AF
1489+ 5512 E5               PUSH HL
1490+ 5513 F3               DI
1491+ 5514 CD 40 55         CALL .SETVALUE
1492+ 5517 FB               EI
1493+ 5518 E1               POP HL
1494+ 5519 C9               RET
1495+ 551A              .L1:
1496+ 551A                  ; get array pointer
1497+ 551A D1               POP DE
1498+ 551B D5               PUSH DE
1499+ 551C 3E 02            LD A,2
1500+ 551E 06 01            LD B,1
1501+ 5520 CD F6 67         CALL GET_BASIC_ARRAY_DATA_POINTER
1502+ 5523 C5               PUSH BC
1503+ 5524              	; ending )
1504+ 5524 CD 91 67     	CALL CHKCHAR
1505+ 5527 29           	DB ')'
1506+ 5528 D1               POP DE ; array pointer
1507+ 5529 C1               POP BC ; number of items
1508+ 552A 78               LD A,B
1509+ 552B B7               OR A
1510+ 552C CA B5 67         JP Z,SUBSCRIPT_OUT_OF_RANGE
1511+ 552F E5               PUSH HL
1512+ 5530 F3               DI
1513+ 5531              .L2:
1514+ 5531 C5               PUSH BC
1515+ 5532 1A               LD A,(DE)
1516+ 5533 13          > INC DE
1516+ 5534 13          > INC DE
1517+ 5535 D5               PUSH DE
1518+ 5536 CD 40 55         CALL .SETVALUE
1519+ 5539 D1               POP DE
1520+ 553A C1               POP BC
1521+ 553B 10 F4            DJNZ .L2
1522+ 553D FB               EI
1523+ 553E E1               POP HL
1524+ 553F C9               RET
1525+ 5540
1526+ 5540              .SETVALUE:
1527+ 5540 47               LD B,A
1528+ 5541 3C               INC A
1529+ 5542 4F               LD C,A
1530+ 5543 3A 67 4F         LD A,(ANIMSPRNUM)
1531+ 5546 B9               CP C
1532+ 5547 DA B5 67         JP C,SUBSCRIPT_OUT_OF_RANGE
1533+ 554A 78               LD A,B
1534+ 554B CD 8B 4F         CALL GETnthSPRANIM
1535+ 554E E5               PUSH HL
1536+ 554F DD E1            POP IX
1537+ 5551              .FN:
1538+ 5551 C3 00 00         JP 0
1539+ 5554              .START:
1540+ 5554 DD 36 06 01      LD (IX+6),1 ; active flag
1541+ 5558 DD 36 03 00      LD (IX+3),0 ; current item
1542+ 555C 06 00            LD B,0 ; setup timer
1543+ 555E C3 F7 55         JP SETUP_ANIM_STEP
1544+ 5561              .STOP:
1545+ 5561 DD 36 06 00      LD (IX+6),0 ; active flag
1546+ 5565 C9               RET
1547+ 5566              .STEP:
1548+ 5566 06 00            LD B,0
1549+ 5568 C3 9B 55         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1550+ 556B              ; *******************************************************************************************************
1551+ 556B               ENDIF
1552+ 556B
1553+ 556B              ; *******************************************************************************************************
1554+ 556B              ; helper function to locate single animation and execute operation
1555+ 556B              ; needs to have jump set to a correct function
1556+ 556B              ; used by SGAM helper routines so always needed
1557+ 556B              ; input A=animation item
1558+ 556B              ANIM_SETVALUE:
1559+ 556B 47               LD B,A
1560+ 556C 3C               INC A
1561+ 556D 4F               LD C,A
1562+ 556E 3A 67 4F         LD A,(ANIMSPRNUM)
1563+ 5571 B9               CP C
1564+ 5572 D8               RET C ; out of range, so do nothing
1565+ 5573 78               LD A,B
1566+ 5574 CD 8B 4F         CALL GETnthSPRANIM
1567+ 5577 E5               PUSH HL
1568+ 5578 DD E1            POP IX
1569+ 557A              .FN:
1570+ 557A C3 00 00         JP 0
1571+ 557D              ; *******************************************************************************************************
1572+ 557D
1573+ 557D               IF (0 == 1)
1574+ 557D ~            ; *******************************************************************************************************
1575+ 557D ~            ; helper function to set values of multiple animations
1576+ 557D ~            ; needs to have jump set to a correct function
1577+ 557D ~            ; input B=number of animation item
1578+ 557D ~            ; input DE=animation item array
1579+ 557D ~            ANIM_LIST_SETVALUE:
1580+ 557D ~                DI
1581+ 557D ~                PUSH BC
1582+ 557D ~                LD A,(DE)
1583+ 557D ~                .2 INC DE
1584+ 557D ~                PUSH DE
1585+ 557D ~                CALL ANIM_SETVALUE
1586+ 557D ~                POP DE
1587+ 557D ~                POP BC
1588+ 557D ~                DJNZ ANIM_LIST_SETVALUE
1589+ 557D ~                EI
1590+ 557D ~                RET
1591+ 557D ~            ; *******************************************************************************************************
1592+ 557D ~
1593+ 557D ~            ; *******************************************************************************************************
1594+ 557D ~            ; function to handle single item ANIMSTEP in DEFUSR mode
1595+ 557D ~            ; input IX=pointer to input array, real data from +2
1596+ 557D ~            ; +2 = animation id
1597+ 557D ~            ANIMSTEP_SINGLE_DEFUSR:
1598+ 557D ~                LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1599+ 557D ~            .L1:
1600+ 557D ~                LD (ANIM_SETVALUE.FN+1),HL
1601+ 557D ~                LD A,(IX+2)
1602+ 557D ~                JR ANIM_SETVALUE
1603+ 557D ~            .STEP:
1604+ 557D ~                LD B,0
1605+ 557D ~                JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
1606+ 557D ~            ; *******************************************************************************************************
1607+ 557D ~
1608+ 557D ~            ; *******************************************************************************************************
1609+ 557D ~            ; function to handle multi item ANIMSTEP in DEFUSR mode
1610+ 557D ~            ; input IX=pointer to input array, real data from +2
1611+ 557D ~            ; +2 = list size
1612+ 557D ~            ; +4 = array pointer holding items
1613+ 557D ~            ANIMSTEP_MULTI_DEFUSR:
1614+ 557D ~                LD HL,ANIMSTEP_SINGLE_DEFUSR.STEP
1615+ 557D ~            .L1:
1616+ 557D ~                LD (ANIM_SETVALUE.FN+1),HL
1617+ 557D ~                LD B,(IX+2)
1618+ 557D ~                LD E,(IX+4)
1619+ 557D ~                LD D,(IX+5)
1620+ 557D ~                JR ANIM_LIST_SETVALUE
1621+ 557D ~            ; *******************************************************************************************************
1622+ 557D ~
1623+ 557D ~            ; *******************************************************************************************************
1624+ 557D ~            ; function to handle single item ANIMSTART in DEFUSR mode
1625+ 557D ~            ; input IX=pointer to input array, real data from +2
1626+ 557D ~            ; +2 = animation id
1627+ 557D ~            ANIMSTART_SINGLE_DEFUSR:
1628+ 557D ~                LD HL,ANIMSTART_SINGLE_DEFUSR.START
1629+ 557D ~                JR ANIMSTEP_SINGLE_DEFUSR.L1
1630+ 557D ~            .START:
1631+ 557D ~                LD (IX+6),1 ; active flag
1632+ 557D ~                LD (IX+3),0 ; current item
1633+ 557D ~                LD B,0 ; setup timer
1634+ 557D ~                JP SETUP_ANIM_STEP
1635+ 557D ~            ; *******************************************************************************************************
1636+ 557D ~
1637+ 557D ~            ; *******************************************************************************************************
1638+ 557D ~            ; function to handle multi item ANIMSTART in DEFUSR mode
1639+ 557D ~            ; input IX=pointer to input array, real data from +2
1640+ 557D ~            ; +2 = list size
1641+ 557D ~            ; +4 = array pointer holding items
1642+ 557D ~            ANIMSTART_MULTI_DEFUSR:
1643+ 557D ~                LD HL,ANIMSTART_SINGLE_DEFUSR.START
1644+ 557D ~                JR ANIMSTEP_MULTI_DEFUSR.L1
1645+ 557D ~            ; *******************************************************************************************************
1646+ 557D ~
1647+ 557D ~            ; *******************************************************************************************************
1648+ 557D ~            ; function to handle single item ANIMSTOP in DEFUSR mode
1649+ 557D ~            ; input IX=pointer to input array, real data from +2
1650+ 557D ~            ; +2 = animation id
1651+ 557D ~            ANIMSTOP_SINGLE_DEFUSR:
1652+ 557D ~                LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1653+ 557D ~                JR ANIMSTEP_SINGLE_DEFUSR.L1
1654+ 557D ~            .STOP:
1655+ 557D ~                LD (IX+6),0 ; active flag
1656+ 557D ~                RET
1657+ 557D ~            ; *******************************************************************************************************
1658+ 557D ~
1659+ 557D ~            ; *******************************************************************************************************
1660+ 557D ~            ; function to handle multi item ANIMSTOP in DEFUSR mode
1661+ 557D ~            ; input IX=pointer to input array, real data from +2
1662+ 557D ~            ; +2 = list size
1663+ 557D ~            ; +4 = array pointer holding items
1664+ 557D ~            ANIMSTOP_MULTI_DEFUSR:
1665+ 557D ~                LD HL,ANIMSTOP_SINGLE_DEFUSR.STOP
1666+ 557D ~                JR ANIMSTEP_MULTI_DEFUSR.L1
1667+ 557D ~            ; *******************************************************************************************************
1668+ 557D               ENDIF
1669+ 557D
1670+ 557D              ; *******************************************************************************************************
1671+ 557D              ; function processes animations during vblank period
1672+ 557D              PROCESS_ANIMATIONS:
1673+ 557D 3A 67 4F         LD A,(ANIMSPRNUM)
1674+ 5580 B7               OR A
1675+ 5581 C8               RET Z; no animations defined
1676+ 5582 47               LD B,A
1677+ 5583 DD 2A 68 4F      LD IX,(ANIMSPRPTR)
1678+ 5587              .L1:
1679+ 5587 C5               PUSH BC
1680+ 5588 06 00            LD B,0 ; normal mode, change on timer expiry only
1681+ 558A CD 96 55         CALL PROCESS_SINGLE_ANIMATION
1682+ 558D 11 08 00         LD DE,8
1683+ 5590 DD 19            ADD IX,DE
1684+ 5592 C1               POP BC
1685+ 5593 10 F2            DJNZ .L1
1686+ 5595 C9               RET
1687+ 5596              ; *******************************************************************************************************
1688+ 5596
1689+ 5596              ; *******************************************************************************************************
1690+ 5596              ; processes single sprite animation
1691+ 5596              ; skips inactive ones, but this can be skipped by calling .INACTIVE_TOO entry point
1692+ 5596              ; on timer expiry goes to next animation item
1693+ 5596              ; input IX=sprite animation pointer
1694+ 5596              ; input B=1 force mode, activate animation action regardless of expired timer
1695+ 5596              PROCESS_SINGLE_ANIMATION:
1696+ 5596 DD 7E 06         LD A,(IX+6); active
1697+ 5599 B7               OR A
1698+ 559A C8               RET Z ; inactive animation
1699+ 559B              .INACTIVE_TOO:
1700+ 559B DD 6E 01         LD L,(IX+1)
1701+ 559E DD 66 02         LD H,(IX+2) ; HL=end time
1702+ 55A1 2B               DEC HL
1703+ 55A2 DD 75 01         LD (IX+1),L
1704+ 55A5 DD 74 02         LD (IX+2),H
1705+ 55A8 7D               LD A,L
1706+ 55A9 B4               OR H
1707+ 55AA 28 06            JR Z,.STEP
1708+ 55AC 05               DEC B
1709+ 55AD 04               INC B
1710+ 55AE C8               RET Z ; not forced mode, return
1711+ 55AF C3 F7 55         JP SETUP_ANIM_STEP; call function with flag to skip timer setup
1712+ 55B2              .STEP:
1713+ 55B2 06 00            LD B,0; setup timer
1714+ 55B4 DD 34 03         INC (IX+3) ; current animation item
1715+ 55B7 C3 F7 55         JP SETUP_ANIM_STEP
1716+ 55BA              ; *******************************************************************************************************
1717+ 55BA
1718+ 55BA              ; *******************************************************************************************************
1719+ 55BA              ; function will setup sprite animation after current item change
1720+ 55BA              ; input A=current animation definition
1721+ 55BA              ; input IX=pointer to sprite animation
1722+ 55BA              ; input B=1 skip timer setup
1723+ 55BA              ; output IY=pointer to animation item
1724+ 55BA              ; CF=1 error or non-cyclic animation ended, in both cases set active flag to 0
1725+ 55BA              ; basically sets new end time for current animation
1726+ 55BA              INIT_CURRENT_ANIMATION:
1727+ 55BA CD 7F 4F         CALL GETnthANIMDEF
1728+ 55BD DD 7E 03         LD A,(IX+3) ; current animation item
1729+ 55C0 BE               CP (HL) ; number of animation items in the animation definition
1730+ 55C1 38 0A            JR C,.L3 ; last item not reached
1731+ 55C3                  ; last item reached
1732+ 55C3 DD 7E 05         LD A,(IX+5) ; cyclic flag
1733+ 55C6 B7               OR A
1734+ 55C7 28 2C            JR Z,.ERROR ; non-cyclic animation
1735+ 55C9                  ; cyclic animation, restart
1736+ 55C9 DD 36 03 00      LD (IX+3),0; current item
1737+ 55CD              .L3:
1738+ 55CD                  ; HL = animation definition
1739+ 55CD 23               INC HL ; skip animation definition size field
1740+ 55CE 16 00            LD D,0
1741+ 55D0 DD 5E 03         LD E,(IX+3); current item
1742+ 55D3 19               ADD HL,DE
1743+ 55D4 4E               LD C,(HL) ; current animation item
1744+ 55D5 0C               INC C
1745+ 55D6 3A 61 4F         LD A,(ANIMITEMNUM)
1746+ 55D9 B9               CP C
1747+ 55DA 38 19            JR C,.ERROR ; invalid animation item, stop animation
1748+ 55DC 0D               DEC C
1749+ 55DD 79               LD A,C
1750+ 55DE CD 76 4F         CALL GETnthANIMITEM
1751+ 55E1 E5               PUSH HL
1752+ 55E2 FD E1            POP IY ; IY=animation item
1753+ 55E4 05               DEC B
1754+ 55E5 28 0C            JR Z,.EXIT
1755+ 55E7 FD 5E 01         LD E,(IY+1)
1756+ 55EA FD 56 02         LD D,(IY+2) ; duration
1757+ 55ED DD 73 01         LD (IX+1),E
1758+ 55F0 DD 72 02         LD (IX+2),D
1759+ 55F3              .EXIT:
1760+ 55F3 AF               XOR A
1761+ 55F4 C9               RET
1762+ 55F5              .ERROR:
1763+ 55F5 37               SCF
1764+ 55F6 C9               RET
1765+ 55F7              ; *******************************************************************************************************
1766+ 55F7
1767+ 55F7              ; *******************************************************************************************************
1768+ 55F7              ; function will display currect item and set up expiry time
1769+ 55F7              ; it will also stop the animation if expired
1770+ 55F7              ; sets sprite update flag if any changes in sprite data made
1771+ 55F7              ; input IX=current sprite animation
1772+ 55F7              ; input B=1 skip timer setup
1773+ 55F7              SETUP_ANIM_STEP:
1774+ 55F7 DD 4E 04         LD C,(IX+4) ; animation definition ID
1775+ 55FA 0C               INC C
1776+ 55FB 3A 64 4F         LD A,(ANIMDEFNUM)
1777+ 55FE B9               CP C
1778+ 55FF 30 05            JR NC,.L2
1779+ 5601                  ; given animation item is outside of bounds, deactivate animation
1780+ 5601              .STOPANIM:
1781+ 5601 DD 36 06 00      LD (IX+6),0
1782+ 5605 C9               RET
1783+ 5606              .L2:
1784+ 5606 0D               DEC C
1785+ 5607 79               LD A,C
1786+ 5608 CD BA 55         CALL INIT_CURRENT_ANIMATION
1787+ 560B 38 F4            JR C, .STOPANIM
1788+ 560D FD 7E 00         LD A,(IY) ; type of animation item
1789+ 5610 B7               OR A
1790+ 5611 28 44            JR Z,.L4 ; change pattern and/or color
1791+ 5613              .PAT:
1792+ 5613                  ; change pattern definition
1793+ 5613                  ; check if sprite or character
1794+ 5613 DD 7E 07         LD A,(IX+7)
1795+ 5616 B7               OR A
1796+ 5617 20 58            JR NZ,.CHAR
1797+ 5619 DD 7E 00         LD A,(IX) ; sprite number
1798+ 561C CD 90 4D         CALL GETnthSPRATTR
1799+ 561F 23          > INC HL ; skip y and x
1799+ 5620 23          > INC HL
1799+ 5621 23          > INC HL
1799+ 5622 23          > INC HL
1800+ 5623 7E               LD A,(HL); current pattern
1801+ 5624 26 00            LD H,0
1802+ 5626 6F               LD L,A
1803+ 5627 3A E0 F3         LD A,(REG1SAV)
1804+ 562A E6 02            AND 2
1805+ 562C 20 07            JR NZ,.L6
1806+ 562E                  ; 8x8 sprite
1807+ 562E CD 7E 66         CALL HLx8
1808+ 5631 06 08            LD B,8
1809+ 5633 18 05            JR .L5
1810+ 5635              .L6:
1811+ 5635 CD 7C 66         CALL HLx32
1812+ 5638 06 20            LD B,32
1813+ 563A              .L5:
1814+ 563A 3A AF FC         LD A,(SCRMOD)
1815+ 563D 3D               DEC A
1816+ 563E 20 06            JR NZ,.L10
1817+ 5640 ED 5B C5 F3      LD DE,(T32PAT)
1818+ 5644 18 04            JR .L7
1819+ 5646              .L10:
1820+ 5646 ED 5B CF F3      LD DE,(GRPPAT)
1821+ 564A              .L7:
1822+ 564A 19               ADD HL,DE
1823+ 564B CD 5F 66         CALL SETWRT_LOCAL_WRITE
1824+ 564E FD 6E 03         LD L,(IY+3)
1825+ 5651 FD 66 04         LD H,(IY+4) ; pointer to sprite pattern data
1826+ 5654 C3 74 66         JP BBYTECOPY
1827+ 5657              .L4:
1828+ 5657                  ; change pattern and color in sprite attributes table
1829+ 5657 DD 7E 00         LD A,(IX) ; sprite number
1830+ 565A CD 90 4D         CALL GETnthSPRATTR
1831+ 565D 23          > INC HL ; skip y and x
1831+ 565E 23          > INC HL
1831+ 565F 23          > INC HL
1831+ 5660 23          > INC HL
1832+ 5661 FD 7E 03         LD A,(IY+3) ; new pattern
1833+ 5664 77               LD (HL),A
1834+ 5665 23          > INC HL
1834+ 5666 23          > INC HL
1835+ 5667 FD 7E 04         LD A,(IY+4) ; new color
1836+ 566A 77               LD (HL),A
1837+ 566B 2A 87 4D         LD HL,(SPRATR_UPDATE_FLAG)
1838+ 566E 36 01            LD (HL),1
1839+ 5670 C9               RET
1840+ 5671              .CHAR:
1841+ 5671 DD 6E 00         LD L,(IX)
1842+ 5674 3D               DEC A
1843+ 5675 67               LD H,A
1844+ 5676 CD 7E 66         CALL HLx8
1845+ 5679 3A AF FC         LD A,(SCRMOD)
1846+ 567C 3D               DEC A
1847+ 567D 20 06            JR NZ,.L8
1848+ 567F ED 5B C1 F3      LD DE,(T32CGP)
1849+ 5683 18 04            JR .L9
1850+ 5685              .L8:
1851+ 5685 ED 5B CB F3      LD DE,(GRPCGP)
1852+ 5689              .L9:
1853+ 5689 06 08            LD B,8
1854+ 568B 18 BD            JR .L7
1855+ 568D              ; *******************************************************************************************************
1856+ 568D
# file closed: asm\ANIMATION.asm
 139  568D               INCLUDE "SGAM.asm"
# file opened: asm\SGAM.asm
   1+ 568D              ; Sprite Group Animate and Move
   2+ 568D
   3+ 568D              ; *******************************************************************************************************
   4+ 568D              ; shared function to process a list of animations
   5+ 568D              ; input B=list size
   6+ 568D              ; input DE=list pointer
   7+ 568D              SGAM_PROCESS_ANIM_LIST:
   8+ 568D 21 A0 56         LD HL,.STEP
   9+ 5690 22 7B 55         LD (ANIM_SETVALUE.FN+1),HL
  10+ 5693              .L1:
  11+ 5693 C5               PUSH BC
  12+ 5694 1A               LD A,(DE)
  13+ 5695 13          > INC DE
  13+ 5696 13          > INC DE
  14+ 5697 D5               PUSH DE
  15+ 5698 CD 6B 55         CALL ANIM_SETVALUE
  16+ 569B D1               POP DE
  17+ 569C C1               POP BC
  18+ 569D 10 F4            DJNZ .L1
  19+ 569F C9           	RET
  20+ 56A0              .STEP:
  21+ 56A0 06 01            LD B,1
  22+ 56A2 C3 9B 55         JP PROCESS_SINGLE_ANIMATION.INACTIVE_TOO
  23+ 56A5              ; *******************************************************************************************************
  24+ 56A5
  25+ 56A5               IF (1 == 1)
  26+ 56A5              ; *******************************************************************************************************
  27+ 56A5              ; function to handle CALL SGAM basic extension
  28+ 56A5              ; sets position of a group of sprites as described in SPRGRPMOV
  29+ 56A5              ; and manually animate a list of animations
  30+ 56A5              ; _SGAM ( INT x,
  31+ 56A5              ;	      INT y,
  32+ 56A5              ;		  BYTE count,
  33+ 56A5              ;		  INT[2][count] data_ptr,
  34+ 56A5              ;         BYTE item_number,
  35+ 56A5              ;         INT[] sprite_animations )
  36+ 56A5              ; will put ram in page 0 also, page 1 is already there
  37+ 56A5              SGAM:
  38+ 56A5 3A 86 4D     	LD A, (SPRATR_INIT_STATUS)
  39+ 56A8 B7           	OR A
  40+ 56A9 CA BD 67     	JP Z,ILLEGAL_FUNCTION
  41+ 56AC              	; opening (
  42+ 56AC CD 91 67     	CALL CHKCHAR
  43+ 56AF 28           	DB '('
  44+ 56B0              	; get x
  45+ 56B0 DD 21 2F 54  	LD IX, FRMQNT
  46+ 56B4 CD 59 01     	CALL CALBAS
  47+ 56B7 ED 53 5A 64  	LD (TMP_STRUCT),DE
  48+ 56BB              	; comma
  49+ 56BB CD 91 67     	CALL CHKCHAR
  50+ 56BE 2C           	DB ','
  51+ 56BF              	; get y
  52+ 56BF DD 21 2F 54  	LD IX, FRMQNT
  53+ 56C3 CD 59 01     	CALL CALBAS
  54+ 56C6 ED 53 5C 64  	LD (TMP_STRUCT+2),DE
  55+ 56CA              	; comma
  56+ 56CA CD 91 67     	CALL CHKCHAR
  57+ 56CD 2C           	DB ','
  58+ 56CE              	; get count
  59+ 56CE DD 21 1C 52  	LD IX, GETBYT
  60+ 56D2 CD 59 01     	CALL CALBAS
  61+ 56D5 B7               OR A
  62+ 56D6 CA B5 67         JP Z,SUBSCRIPT_OUT_OF_RANGE
  63+ 56D9 32 5E 64     	LD (TMP_STRUCT+4),A
  64+ 56DC              	; comma
  65+ 56DC CD 91 67     	CALL CHKCHAR
  66+ 56DF 2C           	DB ','
  67+ 56E0              	; get sprite group definition array data pointer
  68+ 56E0 3A 5E 64         LD A,(TMP_STRUCT+4)
  69+ 56E3 5F           	LD E,A
  70+ 56E4 16 03        	LD D,3
  71+ 56E6 3E 02        	LD A,2
  72+ 56E8 47           	LD B,A
  73+ 56E9 CD F6 67     	CALL GET_BASIC_ARRAY_DATA_POINTER
  74+ 56EC ED 43 5F 64  	LD (TMP_STRUCT+5),BC
  75+ 56F0              	; comma
  76+ 56F0 CD 91 67     	CALL CHKCHAR
  77+ 56F3 2C           	DB ','
  78+ 56F4              	; get sprite animation array size
  79+ 56F4 DD 21 1C 52  	LD IX,GETBYT
  80+ 56F8 CD 59 01     	CALL CALBAS
  81+ 56FB 32 61 64         LD (TMP_STRUCT+7),A
  82+ 56FE B7               OR A
  83+ 56FF CA B5 67         JP Z,SUBSCRIPT_OUT_OF_RANGE
  84+ 5702              	; comma
  85+ 5702 CD 91 67     	CALL CHKCHAR
  86+ 5705 2C           	DB ','
  87+ 5706                  ; get array pointer
  88+ 5706 3A 61 64         LD A,(TMP_STRUCT+7)
  89+ 5709 57               LD D,A
  90+ 570A 3E 02            LD A,2
  91+ 570C 06 01            LD B,1
  92+ 570E CD F6 67         CALL GET_BASIC_ARRAY_DATA_POINTER
  93+ 5711 ED 43 62 64      LD (TMP_STRUCT+8),BC
  94+ 5715              	; ending )
  95+ 5715 CD 91 67     	CALL CHKCHAR
  96+ 5718 29           	DB ')'
  97+ 5719              .ENTRY:
  98+ 5719 E5               PUSH HL
  99+ 571A
 100+ 571A              	; enable page 0
 101+ 571A FD 21 21 57  	LD IY, .RET
 102+ 571E C3 42 67     	JP ENABLE_PAGE0
 103+ 5721              .RET:
 104+ 5721 D9               EXX
 105+ 5722 ED 5B 5A 64      LD DE,(TMP_STRUCT) ; initial x
 106+ 5726 ED 4B 5C 64      LD BC,(TMP_STRUCT+2) ; initial y
 107+ 572A D9               EXX
 108+ 572B 2A 5F 64         LD HL,(TMP_STRUCT+5) ; pointer to data
 109+ 572E 3A 5E 64         LD A,(TMP_STRUCT+4) ; number of entries
 110+ 5731 47               LD B,A
 111+ 5732 CD E4 4E         CALL SPR_UPDATE_LOC
 112+ 5735
 113+ 5735 3A 61 64         LD A,(TMP_STRUCT+7) ; anim number
 114+ 5738 47               LD B,A
 115+ 5739 ED 5B 62 64      LD DE,(TMP_STRUCT+8) ; anim list
 116+ 573D CD 8D 56     	CALL SGAM_PROCESS_ANIM_LIST
 117+ 5740 D1               POP DE
 118+ 5741 C1               POP BC
 119+ 5742 CD B9 66         CALL RESTORE_PAGE_INFO
 120+ 5745 AF           	XOR A
 121+ 5746 E1           	POP HL
 122+ 5747 C9           	RET
 123+ 5748              ; *******************************************************************************************************
 124+ 5748               ENDIF
 125+ 5748
 126+ 5748               IF (0 == 1)
 127+ 5748 ~            ; *******************************************************************************************************
 128+ 5748 ~            ; same as SGAM but for DEFUSR approach
 129+ 5748 ~            ; input IX=pointer to input array, real data from +2
 130+ 5748 ~            ; +02 = X
 131+ 5748 ~            ; +04 = Y
 132+ 5748 ~            ; +06 = count
 133+ 5748 ~            ; +08 = data pointer
 134+ 5748 ~            ; +10 = anim number
 135+ 5748 ~            ; +12 = sprite animations
 136+ 5748 ~            SGAM_DEFUSR:
 137+ 5748 ~            	; enable page 0
 138+ 5748 ~            	LD IY, .RET
 139+ 5748 ~            	JP ENABLE_PAGE0
 140+ 5748 ~            .RET:
 141+ 5748 ~            	EI
 142+ 5748 ~                EXX
 143+ 5748 ~            	LD E,(IX+2)
 144+ 5748 ~            	LD D,(IX+3) ; initial x
 145+ 5748 ~            	LD C,(IX+4)
 146+ 5748 ~            	LD B,(IX+5) ; initial y
 147+ 5748 ~                EXX
 148+ 5748 ~            	LD L,(IX+8)
 149+ 5748 ~            	LD H,(IX+9) ; pointer to data
 150+ 5748 ~                LD B,(IX+6) ; count
 151+ 5748 ~            	PUSH IX
 152+ 5748 ~                CALL SPR_UPDATE_LOC
 153+ 5748 ~            	POP IX
 154+ 5748 ~                LD B,(IX+10) ; anim number
 155+ 5748 ~            	LD E,(IX+12)
 156+ 5748 ~            	LD D,(IX+13)
 157+ 5748 ~            	CALL SGAM_PROCESS_ANIM_LIST
 158+ 5748 ~            	JP COMMON_EXIT_CODE
 159+ 5748 ~            ; *******************************************************************************************************
 160+ 5748               ENDIF
 161+ 5748
 162+ 5748              ; *******************************************************************************************************
 163+ 5748              ; handles automatic move and animate sprite groups during interrupt
 164+ 5748              PROCESS_AUTOSGAMS:
 165+ 5748 3A 6A 4F     	LD A,(AUTOSGAMNUM)
 166+ 574B B7           	OR A
 167+ 574C C8           	RET Z
 168+ 574D 47           	LD B,A
 169+ 574E DD 2A 6B 4F  	LD IX,(AUTOSGAMPTR)
 170+ 5752              .L1:
 171+ 5752 C5           	PUSH BC
 172+ 5753 DD 7E 13     	LD A,(IX+19) ; active flag
 173+ 5756 B7           	OR A
 174+ 5757 28 28        	JR Z,.LOOPEND
 175+ 5759              	; active, check timer
 176+ 5759 DD 6E 16     	LD L,(IX+22)
 177+ 575C DD 66 17     	LD H,(IX+23) ; timer
 178+ 575F 2B           	DEC HL
 179+ 5760 7C           	LD A,H
 180+ 5761 B5           	OR L
 181+ 5762 28 08        	JR Z,.L2
 182+ 5764              	; not expired
 183+ 5764 DD 75 16     	LD (IX+22),L
 184+ 5767 DD 74 17     	LD (IX+23),H
 185+ 576A 18 15        	JR .LOOPEND
 186+ 576C              .L2:
 187+ 576C              	; expired, process
 188+ 576C
 189+ 576C                  ; set initial timer
 190+ 576C DD 7E 14         LD A,(IX+20)
 191+ 576F DD 77 16         LD (IX+22),A
 192+ 5772 DD 7E 15         LD A,(IX+21)
 193+ 5775 DD 77 17         LD (IX+23),A
 194+ 5778
 195+ 5778 CD 8A 57     	CALL .MOVE
 196+ 577B CD F5 57     	CALL .UPDATELOC
 197+ 577E CD 1A 58     	CALL .PROCESS_ANIM_LIST
 198+ 5781
 199+ 5781              .LOOPEND:
 200+ 5781 11 18 00     	LD DE,24
 201+ 5784 DD 19        	ADD IX,DE
 202+ 5786 C1           	POP BC
 203+ 5787 10 C9        	DJNZ .L1
 204+ 5789 C9           	RET
 205+ 578A
 206+ 578A              .MOVE:
 207+ 578A              	; process movement
 208+ 578A DD 7E 0A     	LD A,(IX+10) ; direction
 209+ 578D B7           	OR A
 210+ 578E 28 08        	JR Z, .MOVE_L1
 211+ 5790              	; vertical
 212+ 5790 DD 6E 02     	LD L,(IX+2)
 213+ 5793 DD 66 03     	LD H,(IX+3) ; vertical variable pointer
 214+ 5796 18 06        	JR .MOVE_L2
 215+ 5798              .MOVE_L1:
 216+ 5798              	; horizontal
 217+ 5798 DD 6E 00     	LD L,(IX+0)
 218+ 579B DD 66 01     	LD H,(IX+1) ; horizontal variable pointer
 219+ 579E              .MOVE_L2:
 220+ 579E E5           	PUSH HL
 221+ 579F FD E1        	POP IY
 222+ 57A1 FD 6E 00     	LD L,(IY+0)
 223+ 57A4 FD 66 01     	LD H,(IY+1)
 224+ 57A7 DD 5E 08     	LD E,(IX+8)
 225+ 57AA DD 56 09     	LD D,(IX+9) ; delta value
 226+ 57AD 19           	ADD HL,DE
 227+ 57AE E5           	PUSH HL
 228+ 57AF DD 5E 04     	LD E,(IX+4)
 229+ 57B2 DD 56 05     	LD D,(IX+5) ; minimum value
 230+ 57B5 A7           	AND A
 231+ 57B6 ED 52        	SBC HL,DE
 232+ 57B8 FA D2 57     	JP M,.MOVE_L3 ; below minimum
 233+ 57BB E1           	POP HL
 234+ 57BC E5           	PUSH HL
 235+ 57BD DD 5E 06     	LD E,(IX+6)
 236+ 57C0 DD 56 07     	LD D,(IX+7) ; maximum value
 237+ 57C3 EB           	EX DE,HL
 238+ 57C4 A7           	AND A
 239+ 57C5 ED 52        	SBC HL,DE
 240+ 57C7 FA DA 57     	JP M,.MOVE_L4 ; above maximum
 241+ 57CA E1           	POP HL
 242+ 57CB              	; within bounds
 243+ 57CB              .MOVE_L5:
 244+ 57CB FD 75 00     	LD (IY+0),L
 245+ 57CE FD 74 01     	LD (IY+1),H
 246+ 57D1 C9           	RET
 247+ 57D2              .MOVE_L3:
 248+ 57D2 E1           	POP HL
 249+ 57D3 CD E6 57     	CALL .INVERSE_DELTA
 250+ 57D6 6B           	LD L,E
 251+ 57D7 62           	LD H,D
 252+ 57D8 18 F1        	JR .MOVE_L5
 253+ 57DA              .MOVE_L4:
 254+ 57DA E1           	POP HL
 255+ 57DB CD E6 57     	CALL .INVERSE_DELTA
 256+ 57DE DD 6E 06     	LD L,(IX+6)
 257+ 57E1 DD 66 07     	LD H,(IX+7) ; maximum
 258+ 57E4 18 E5        	JR .MOVE_L5
 259+ 57E6              .INVERSE_DELTA:
 260+ 57E6 AF           	XOR A
 261+ 57E7 DD 96 08     	SUB (IX+8)
 262+ 57EA DD 77 08     	LD (IX+8),A
 263+ 57ED 9F           	SBC A,A
 264+ 57EE DD 96 09     	SUB (IX+9)
 265+ 57F1 DD 77 09     	LD (IX+9),A
 266+ 57F4 C9           	RET
 267+ 57F5
 268+ 57F5              .UPDATELOC:
 269+ 57F5 DD E5        	PUSH IX
 270+ 57F7 D9           	EXX
 271+ 57F8 DD 6E 00     	LD L,(IX+0)
 272+ 57FB DD 66 01     	LD H,(IX+1)
 273+ 57FE 5E           	LD E,(HL)
 274+ 57FF 23           	INC HL
 275+ 5800 56           	LD D,(HL)
 276+ 5801 DD 6E 02     	LD L,(IX+2)
 277+ 5804 DD 66 03     	LD H,(IX+3)
 278+ 5807 4E           	LD C,(HL)
 279+ 5808 23           	INC HL
 280+ 5809 46           	LD B,(HL)
 281+ 580A D9           	EXX
 282+ 580B DD 6E 0C     	LD L,(IX+12)
 283+ 580E DD 66 0D     	LD H,(IX+13) ; pointer to sprite group data
 284+ 5811 DD 46 0B     	LD B,(IX+11) ; sprite group size
 285+ 5814 CD E4 4E     	CALL SPR_UPDATE_LOC
 286+ 5817 DD E1        	POP IX
 287+ 5819 C9           	RET
 288+ 581A
 289+ 581A              .PROCESS_ANIM_LIST:
 290+ 581A DD E5        	PUSH IX
 291+ 581C DD 46 0E         LD B,(IX+14) ; anim list size
 292+ 581F DD CB 09 7E  	BIT 7,(IX+9)
 293+ 5823 28 08        	JR Z,.PROCESS_ANIM_LIST_L1
 294+ 5825              	; negative direction
 295+ 5825 DD 5E 0F     	LD E,(IX+15)
 296+ 5828 DD 56 10     	LD D,(IX+16)
 297+ 582B 18 06        	JR .PROCESS_ANIM_LIST_L2
 298+ 582D              .PROCESS_ANIM_LIST_L1:
 299+ 582D              	; positive direction
 300+ 582D DD 5E 11     	LD E,(IX+17)
 301+ 5830 DD 56 12     	LD D,(IX+18)
 302+ 5833              .PROCESS_ANIM_LIST_L2:
 303+ 5833 CD 8D 56     	CALL SGAM_PROCESS_ANIM_LIST
 304+ 5836 DD E1        	POP IX
 305+ 5838 C9           	RET
 306+ 5839              ; *******************************************************************************************************
 307+ 5839
# file closed: asm\SGAM.asm
 140  5839               ENDIF
 141  5839
 142  5839               IF (RAM_CMDS == 1)
 143  5839               INCLUDE "MEMORY.asm"
# file opened: asm\MEMORY.asm
   1+ 5839               IF (1 == 1)
   2+ 5839              ; *******************************************************************************************************
   3+ 5839              ; function to handle CALL MEMCPY basic extension
   4+ 5839              ; _MEMCPY ( INT source,
   5+ 5839              ;			INT destination,
   6+ 5839              ;			INT count,
   7+ 5839              ; will put ram in page 0 also, page 1 is already there
   8+ 5839              MEMCPY:
   9+ 5839              	; opening (
  10+ 5839 CD 91 67     	CALL CHKCHAR
  11+ 583C 28           	DB '('
  12+ 583D              	; get source address
  13+ 583D DD 21 2F 54  	LD IX, FRMQNT
  14+ 5841 CD 59 01     	CALL CALBAS
  15+ 5844 D5           	PUSH DE
  16+ 5845              	; comma
  17+ 5845 CD 91 67     	CALL CHKCHAR
  18+ 5848 2C           	DB ','
  19+ 5849              	; get destination address
  20+ 5849 DD 21 2F 54  	LD IX, FRMQNT
  21+ 584D CD 59 01     	CALL CALBAS
  22+ 5850 D5           	PUSH DE
  23+ 5851              	; comma
  24+ 5851 CD 91 67     	CALL CHKCHAR
  25+ 5854 2C           	DB ','
  26+ 5855              	; get length
  27+ 5855 DD 21 2F 54  	LD IX, FRMQNT
  28+ 5859 CD 59 01     	CALL CALBAS
  29+ 585C D5           	PUSH DE
  30+ 585D              	; ending )
  31+ 585D CD 91 67     	CALL CHKCHAR
  32+ 5860 29           	DB ')'
  33+ 5861
  34+ 5861              	; save position
  35+ 5861 E5           	PUSH HL
  36+ 5862 DD E1        	POP IX
  37+ 5864
  38+ 5864 C1           	POP BC ; count
  39+ 5865 D1           	POP DE ; destination
  40+ 5866 E1           	POP HL ; source
  41+ 5867 D9           	EXX
  42+ 5868              	; enable page 0
  43+ 5868 FD 21 6F 58  	LD IY, .RET
  44+ 586C C3 42 67     	JP ENABLE_PAGE0
  45+ 586F              .RET:
  46+ 586F FB           	EI
  47+ 5870 D9           	EXX
  48+ 5871 ED B0        	LDIR
  49+ 5873 C3 55 66     	JP COMMON_EXIT_CODE_IX
  50+ 5876              ; *******************************************************************************************************
  51+ 5876               ENDIF
  52+ 5876
  53+ 5876               IF (0 == 1)
  54+ 5876 ~            ; *******************************************************************************************************
  55+ 5876 ~            ; same as MEMCPY but for DEFUSR approach
  56+ 5876 ~            ; input IX=pointer to input array, real data from +2
  57+ 5876 ~            ; +2 = source address
  58+ 5876 ~            ; +4 = destination address
  59+ 5876 ~            ; +6 = lenght
  60+ 5876 ~            MEMCPY_DEFUSR:
  61+ 5876 ~            	; enable page 0
  62+ 5876 ~            	LD IY, .RET
  63+ 5876 ~            	JP ENABLE_PAGE0
  64+ 5876 ~            .RET:
  65+ 5876 ~            	EI
  66+ 5876 ~            	LD L,(IX+2)
  67+ 5876 ~            	LD H,(IX+3)
  68+ 5876 ~            	LD E,(IX+4)
  69+ 5876 ~            	LD D,(IX+5)
  70+ 5876 ~            	LD C,(IX+6)
  71+ 5876 ~            	LD B,(IX+7)
  72+ 5876 ~            	LDIR
  73+ 5876 ~                JP COMMON_EXIT_CODE
  74+ 5876 ~            ; *******************************************************************************************************
  75+ 5876               ENDIF
  76+ 5876
  77+ 5876               IF (1 == 1)
  78+ 5876              ; *******************************************************************************************************
  79+ 5876              ; function to handle CALL FILRAM basic extension
  80+ 5876              ; FILRAM ( INT start address,
  81+ 5876              ;		   INT count,
  82+ 5876              ;		   BYTE value )
  83+ 5876              ; will put ram in page 0 also, page 1 is already there
  84+ 5876              FILRAM:
  85+ 5876              	; opening (
  86+ 5876 CD 91 67     	CALL CHKCHAR
  87+ 5879 28           	DB '('
  88+ 587A              	; get start address
  89+ 587A DD 21 2F 54  	LD IX, FRMQNT
  90+ 587E CD 59 01     	CALL CALBAS
  91+ 5881 D5           	PUSH DE
  92+ 5882              	; comma
  93+ 5882 CD 91 67     	CALL CHKCHAR
  94+ 5885 2C           	DB ','
  95+ 5886              	; get count
  96+ 5886 DD 21 2F 54  	LD IX, FRMQNT
  97+ 588A CD 59 01     	CALL CALBAS
  98+ 588D D5           	PUSH DE
  99+ 588E              	; comma
 100+ 588E CD 91 67     	CALL CHKCHAR
 101+ 5891 2C           	DB ','
 102+ 5892              	; get value
 103+ 5892 DD 21 1C 52  	LD IX, GETBYT
 104+ 5896 CD 59 01     	CALL CALBAS
 105+ 5899 F5           	PUSH AF
 106+ 589A              	; ending )
 107+ 589A CD 91 67     	CALL CHKCHAR
 108+ 589D 29           	DB ')'
 109+ 589E
 110+ 589E              	; save position
 111+ 589E E5           	PUSH HL
 112+ 589F DD E1        	POP IX
 113+ 58A1
 114+ 58A1 D1           	POP DE ; actually AF
 115+ 58A2 C1           	POP BC ; count
 116+ 58A3 E1           	POP HL ; start address
 117+ 58A4 D9           	EXX
 118+ 58A5              	; enable page 0
 119+ 58A5 FD 21 AC 58  	LD IY, .RET
 120+ 58A9 C3 42 67     	JP ENABLE_PAGE0
 121+ 58AC              .RET:
 122+ 58AC FB           	EI
 123+ 58AD D9           	EXX
 124+ 58AE CD B4 58     	CALL FILVRM_FILLVALUE
 125+ 58B1 C3 55 66     	JP COMMON_EXIT_CODE_IX
 126+ 58B4              ; *******************************************************************************************************
 127+ 58B4               ENDIF
 128+ 58B4
 129+ 58B4               IF (0 == 1)
 130+ 58B4 ~            ; *******************************************************************************************************
 131+ 58B4 ~            ; same as FILVRM but for DEFUSR approach
 132+ 58B4 ~            ; input IX=pointer to input array, real data from +2
 133+ 58B4 ~            ; +2 = start address
 134+ 58B4 ~            ; +4 = count
 135+ 58B4 ~            ; +6 = value
 136+ 58B4 ~            FILRAM_DEFUSR:
 137+ 58B4 ~            	; enable page 0
 138+ 58B4 ~            	LD IY, .RET
 139+ 58B4 ~            	JP ENABLE_PAGE0
 140+ 58B4 ~            .RET:
 141+ 58B4 ~            	EI
 142+ 58B4 ~            	LD L,(IX+2)
 143+ 58B4 ~            	LD H,(IX+3)
 144+ 58B4 ~            	LD C,(IX+4)
 145+ 58B4 ~            	LD B,(IX+5)
 146+ 58B4 ~            	LD D,(IX+6)
 147+ 58B4 ~            	CALL FILVRM_FILLVALUE
 148+ 58B4 ~                JP COMMON_EXIT_CODE
 149+ 58B4 ~            ; *******************************************************************************************************
 150+ 58B4               ENDIF
 151+ 58B4
 152+ 58B4              ; *******************************************************************************************************
 153+ 58B4              ; common function to fill RAM
 154+ 58B4              FILVRM_FILLVALUE:
 155+ 58B4 78           	LD A,B
 156+ 58B5 B1           	OR C
 157+ 58B6 C8           	RET Z ; zero size
 158+ 58B7 72               LD (HL), D
 159+ 58B8 54               LD D, H
 160+ 58B9 5D               LD E, L
 161+ 58BA 13               INC DE
 162+ 58BB 0B               DEC BC
 163+ 58BC 78           	LD A,B
 164+ 58BD B1           	OR C
 165+ 58BE C8           	RET Z ; if count was 1
 166+ 58BF ED B0            LDIR
 167+ 58C1 C9               RET
 168+ 58C2              ; *******************************************************************************************************
# file closed: asm\MEMORY.asm
 144  58C2               ENDIF
 145  58C2
 146  58C2               IF (SOUND_CMDS == 1)
 147  58C2               INCLUDE "SOUND.asm"
# file opened: asm\SOUND.asm
   1+ 58C2              MUSIC_INIT_STATUS:
   2+ 58C2 00            DB 0
   3+ 58C3              SFX_INIT_STATUS:
   4+ 58C3 00            DB 0
   5+ 58C4              SOUND_ENABLED:
   6+ 58C4 00            DB 0
   7+ 58C5
   8+ 58C5               IF (1 == 1)
   9+ 58C5              ; *******************************************************************************************************
  10+ 58C5              ; function to handle CALL SNDPLYINIT basic extension
  11+ 58C5              ; initializes sound player
  12+ 58C5              ; _SNDPLYINIT ( INT music_offset,
  13+ 58C5              ;				INT sfx_offset, can be -1 if no SFX
  14+ 58C5              ; will put ram in page 0 also, page 1 is already there
  15+ 58C5              ; sets variables MUSIC_INIT_STATUS and SFX_INIT_STATUS
  16+ 58C5              SNDPLYINIT:
  17+ 58C5              	; opening (
  18+ 58C5 CD 91 67     	CALL CHKCHAR
  19+ 58C8 28           	DB '('
  20+ 58C9              	; get music address
  21+ 58C9 DD 21 2F 54  	LD IX, FRMQNT
  22+ 58CD CD 59 01     	CALL CALBAS
  23+ 58D0 D5           	PUSH DE
  24+ 58D1              	; comma
  25+ 58D1 CD 91 67     	CALL CHKCHAR
  26+ 58D4 2C           	DB ','
  27+ 58D5              	; get sfx address
  28+ 58D5 DD 21 2F 54  	LD IX, FRMQNT
  29+ 58D9 CD 59 01     	CALL CALBAS
  30+ 58DC D5           	PUSH DE
  31+ 58DD              	; ending )
  32+ 58DD CD 91 67     	CALL CHKCHAR
  33+ 58E0 29           	DB ')'
  34+ 58E1
  35+ 58E1                  ; save position in BASIC text
  36+ 58E1 44           	LD B, H
  37+ 58E2 4D           	LD C, L
  38+ 58E3
  39+ 58E3              	; pop LDIR parameters and store away for later
  40+ 58E3 D1           	POP DE ; sfx address
  41+ 58E4 E1           	POP HL ; music address
  42+ 58E5 C5           	PUSH BC ; basic text location
  43+ 58E6 D9           	EXX
  44+ 58E7 FD 21 EE 58  	LD IY, .RET
  45+ 58EB C3 42 67     	JP ENABLE_PAGE0
  46+ 58EE              .RET:
  47+ 58EE D9           	EXX
  48+ 58EF
  49+ 58EF D5           	PUSH DE
  50+ 58F0 AF           	XOR A
  51+ 58F1              	; HL = music location
  52+ 58F1 CD 65 41     	CALL PLY_AKG_INIT
  53+ 58F4 3E 01        	LD A, 1
  54+ 58F6 32 C2 58     	LD (MUSIC_INIT_STATUS), A
  55+ 58F9
  56+ 58F9 E1           	POP HL ; SFX
  57+ 58FA              	; check if SFX address -1
  58+ 58FA 23           	INC HL
  59+ 58FB 7D           	LD A, L
  60+ 58FC B4           	OR H
  61+ 58FD 28 09        	JR Z,.L1
  62+ 58FF 2B           	DEC HL
  63+ 5900 CD 20 40     	CALL PLY_AKG_INITSOUNDEFFECTS
  64+ 5903 3E 01        	LD A, 1
  65+ 5905 32 C3 58     	LD (SFX_INIT_STATUS), A
  66+ 5908              .L1:
  67+ 5908 D1               POP DE
  68+ 5909 C1               POP BC
  69+ 590A CD B9 66         CALL RESTORE_PAGE_INFO
  70+ 590D AF           	XOR A
  71+ 590E E1           	POP HL
  72+ 590F C9           	RET
  73+ 5910              ; *******************************************************************************************************
  74+ 5910               ENDIF
  75+ 5910
  76+ 5910               IF (0 == 1)
  77+ 5910 ~            ; *******************************************************************************************************
  78+ 5910 ~            ; same as SNDPLYINI but for DEFUSR approach
  79+ 5910 ~            ; input IX=pointer to input array, real data from +2
  80+ 5910 ~            ; +2 = music address
  81+ 5910 ~            ; +4 = sfx address
  82+ 5910 ~            SNDPLYINI_DEFUSR:
  83+ 5910 ~            	LD IY, .RET
  84+ 5910 ~            	JP ENABLE_PAGE0
  85+ 5910 ~            .RET:
  86+ 5910 ~            	XOR A
  87+ 5910 ~            	LD L,(IX+2)
  88+ 5910 ~            	LD H,(IX+3)
  89+ 5910 ~            	PUSH IX
  90+ 5910 ~            	CALL PLY_AKG_INIT
  91+ 5910 ~            	POP IX
  92+ 5910 ~            	LD A, 1
  93+ 5910 ~            	LD (MUSIC_INIT_STATUS), A
  94+ 5910 ~
  95+ 5910 ~            	LD L,(IX+4)
  96+ 5910 ~            	LD H,(IX+5)
  97+ 5910 ~            	; check if SFX address -1
  98+ 5910 ~            	INC HL
  99+ 5910 ~            	LD A, L
 100+ 5910 ~            	OR H
 101+ 5910 ~            	JR Z,.L1
 102+ 5910 ~            	DEC HL
 103+ 5910 ~            	CALL PLY_AKG_INITSOUNDEFFECTS
 104+ 5910 ~            	LD A, 1
 105+ 5910 ~            	LD (SFX_INIT_STATUS), A
 106+ 5910 ~            .L1:
 107+ 5910 ~            	JP COMMON_EXIT_CODE
 108+ 5910 ~            ; *******************************************************************************************************
 109+ 5910               ENDIF
 110+ 5910
 111+ 5910              ; *******************************************************************************************************
 112+ 5910              ; function to handle CALL SNDPLYON basic extension
 113+ 5910              ; enables sound player
 114+ 5910              ; _SNDPLYON
 115+ 5910              ; sets SOUND_ENABLED variable to 1 if init call was done
 116+ 5910              ; if not throws out of data error
 117+ 5910              SNDPLYON_DEFUSR:
 118+ 5910              SNDPLYON:
 119+ 5910 3A C2 58     	LD A, (MUSIC_INIT_STATUS)
 120+ 5913 B7           	OR A
 121+ 5914               IF (1 == 1)
 122+ 5914 CA AD 67     	JP Z, OUT_OF_DATA ; player not initialized, throw error
 123+ 5917               ENDIF
 124+ 5917               IF (0 == 1)
 125+ 5917 ~            	JR Z,.ERR
 126+ 5917               ENDIF
 127+ 5917              .L1:
 128+ 5917 32 C4 58     	LD (SOUND_ENABLED), A
 129+ 591A              	; disable key click
 130+ 591A AF           	XOR A
 131+ 591B 32 DB F3     	LD (CLIKSW), A
 132+ 591E C9           	RET
 133+ 591F              .ERR:
 134+ 591F 3E 01        	LD A,1
 135+ 5921 C9           	RET
 136+ 5922              ; *******************************************************************************************************
 137+ 5922
 138+ 5922              ; *******************************************************************************************************
 139+ 5922              ; function to handle CALL SNDPLYOFF basic extension
 140+ 5922              ; disables sound player
 141+ 5922              ; _SNDPLYOFF
 142+ 5922              ; sets SOUND_ENABLED variable to 0
 143+ 5922              ; calls AKG to stop music and SFX on all channels if initialized
 144+ 5922              SNDPLYOFF_DEFUSR:
 145+ 5922              SNDPLYOFF:
 146+ 5922 3A C4 58     	LD A, (SOUND_ENABLED)
 147+ 5925 B7           	OR A
 148+ 5926 C8           	RET Z ; already stopped
 149+ 5927 AF           	XOR A
 150+ 5928 32 C4 58     	LD (SOUND_ENABLED), A
 151+ 592B E5           	PUSH HL
 152+ 592C CD 24 42     	CALL PLY_AKG_STOP
 153+ 592F 3A C3 58     	LD A, (SFX_INIT_STATUS)
 154+ 5932 B7           	OR A
 155+ 5933 28 0E        	JR Z, .EXIT ; SFX not in use
 156+ 5935 AF           	XOR A
 157+ 5936 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 158+ 5939 3E 01        	LD A, 1
 159+ 593B CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 160+ 593E 3E 02        	LD A, 2
 161+ 5940 CD 4C 40     	CALL PLY_AKG_STOPSOUNDEFFECTFROMCHANNEL
 162+ 5943              .EXIT:
 163+ 5943 E1           	POP HL
 164+ 5944 AF           	XOR A ; success
 165+ 5945 C9           	RET
 166+ 5946              ; *******************************************************************************************************
 167+ 5946
 168+ 5946               IF (1 == 1)
 169+ 5946              ; *******************************************************************************************************
 170+ 5946              ; function to handle CALL SNDSFX basic extension
 171+ 5946              ; plays a sound effect
 172+ 5946              ; _SNDSFX ( BYTE sfx_number, >0
 173+ 5946              ;			BYTE channel, = 0,1 or 2
 174+ 5946              ;			BYTE inverted_volume = 0-16, 0 being full volume
 175+ 5946              ; will put ram in page 0 also, page 1 is already there
 176+ 5946              ; if sound off throws illegal function call
 177+ 5946              ; if sfx not initialized, throws out of data
 178+ 5946              SNDSFX:
 179+ 5946              	; opening (
 180+ 5946 CD 91 67     	CALL CHKCHAR
 181+ 5949 28           	DB '('
 182+ 594A              	; get sfx_number
 183+ 594A DD 21 1C 52  	LD IX, GETBYT
 184+ 594E CD 59 01     	CALL CALBAS
 185+ 5951 D5           	PUSH DE
 186+ 5952              	; comma
 187+ 5952 CD 91 67     	CALL CHKCHAR
 188+ 5955 2C           	DB ','
 189+ 5956              	; get sfx address
 190+ 5956 DD 21 1C 52  	LD IX, GETBYT
 191+ 595A CD 59 01     	CALL CALBAS
 192+ 595D D5           	PUSH DE
 193+ 595E              	; comma
 194+ 595E CD 91 67     	CALL CHKCHAR
 195+ 5961 2C           	DB ','
 196+ 5962              	; get inverted volume
 197+ 5962 DD 21 1C 52  	LD IX, GETBYT
 198+ 5966 CD 59 01     	CALL CALBAS
 199+ 5969 D5           	PUSH DE
 200+ 596A              	; ending )
 201+ 596A CD 91 67     	CALL CHKCHAR
 202+ 596D 29           	DB ')'
 203+ 596E
 204+ 596E 3A C4 58     	LD A, (SOUND_ENABLED)
 205+ 5971 B7           	OR A
 206+ 5972 20 05        	JR NZ, .L1
 207+ 5974              	; sound disabled, throw illegal function call
 208+ 5974 1E 05        	LD E, 5
 209+ 5976 C3 C3 67     	JP THROW_ERROR
 210+ 5979              .L1:
 211+ 5979 3A C3 58     	LD A, (SFX_INIT_STATUS)
 212+ 597C B7           	OR A
 213+ 597D 20 05        	JR NZ, .L2
 214+ 597F              	; sfx data not initialized, throw out of data
 215+ 597F 1E 04        	LD E, 4
 216+ 5981 C3 C3 67     	JP THROW_ERROR
 217+ 5984              .L2:
 218+ 5984              	; pop  parameters and store away for later
 219+ 5984 D1           	POP DE ; inverted volume
 220+ 5985 43           	LD B, E
 221+ 5986 D1           	POP DE ; channel
 222+ 5987 4B           	LD C, E
 223+ 5988 D1           	POP DE
 224+ 5989 7B           	LD A, E
 225+ 598A 08           	EX AF, AF'
 226+ 598B E5           	PUSH HL ; basic text location
 227+ 598C D9           	EXX
 228+ 598D FD 21 94 59  	LD IY, .RET
 229+ 5991 C3 42 67     	JP ENABLE_PAGE0
 230+ 5994              .RET:
 231+ 5994 D9           	EXX
 232+ 5995 08           	EX AF, AF'
 233+ 5996 CD 24 40     	CALL PLY_AKG_PLAYSOUNDEFFECT
 234+ 5999
 235+ 5999 D1               POP DE
 236+ 599A C1               POP BC
 237+ 599B CD B9 66         CALL RESTORE_PAGE_INFO
 238+ 599E AF           	XOR A
 239+ 599F E1           	POP HL
 240+ 59A0 C9           	RET
 241+ 59A1              ; *******************************************************************************************************
 242+ 59A1               ENDIF
 243+ 59A1
 244+ 59A1               IF (0 == 1)
 245+ 59A1 ~            ; *******************************************************************************************************
 246+ 59A1 ~            ; same as SNDSFX but for DEFUSR approach
 247+ 59A1 ~            ; input IX=pointer to input array, real data from +2
 248+ 59A1 ~            ; +2 = SFX number
 249+ 59A1 ~            ; +4 = channel
 250+ 59A1 ~            ; +6 = volume
 251+ 59A1 ~            SNDSFX_DEFUSR:
 252+ 59A1 ~            	LD A, (SOUND_ENABLED)
 253+ 59A1 ~            	OR A
 254+ 59A1 ~            	RET Z ; sound disabled, just exit
 255+ 59A1 ~            	LD A, (SFX_INIT_STATUS)
 256+ 59A1 ~            	OR A
 257+ 59A1 ~            	RET Z ; sfx data not initialized, just exit
 258+ 59A1 ~            	LD IY, .RET
 259+ 59A1 ~            	JP ENABLE_PAGE0
 260+ 59A1 ~            .RET:
 261+ 59A1 ~            	EI
 262+ 59A1 ~            	LD A,(IX+2) ; SFX number
 263+ 59A1 ~            	LD C,(IX+4) ; channel
 264+ 59A1 ~            	LD B,(IX+6) ; volume
 265+ 59A1 ~            	CALL PLY_AKG_PLAYSOUNDEFFECT
 266+ 59A1 ~            	JP COMMON_EXIT_CODE
 267+ 59A1 ~            ; *******************************************************************************************************
 268+ 59A1               ENDIF
# file closed: asm\SOUND.asm
 148  59A1               ENDIF
 149  59A1
 150  59A1               IF (VRAM_CMDS == 1)
 151  59A1               INCLUDE "VRAM.asm"
# file opened: asm\VRAM.asm
   1+ 59A1               IF (1 == 1)
   2+ 59A1              ; *******************************************************************************************************
   3+ 59A1              ; function to handle CALL FILVRM basic extension
   4+ 59A1              ; FILVRM ( INT offset,
   5+ 59A1              ;		   INT count,
   6+ 59A1              ;		   BYTE value,
   7+ 59A1              ;		   BYTE wait_vsync) >0 = true
   8+ 59A1              ; wait_vsync will issue HALT before copying
   9+ 59A1              FILVRM:
  10+ 59A1              	; opening (
  11+ 59A1 CD 91 67     	CALL CHKCHAR
  12+ 59A4 28           	DB '('
  13+ 59A5              	; get offset address
  14+ 59A5 DD 21 2F 54  	LD IX, FRMQNT
  15+ 59A9 CD 59 01     	CALL CALBAS
  16+ 59AC D5           	PUSH DE
  17+ 59AD              	; comma
  18+ 59AD CD 91 67     	CALL CHKCHAR
  19+ 59B0 2C           	DB ','
  20+ 59B1              	; get count
  21+ 59B1 DD 21 2F 54  	LD IX, FRMQNT
  22+ 59B5 CD 59 01     	CALL CALBAS
  23+ 59B8 D5           	PUSH DE
  24+ 59B9              	; comma
  25+ 59B9 CD 91 67     	CALL CHKCHAR
  26+ 59BC 2C           	DB ','
  27+ 59BD              	; get value
  28+ 59BD DD 21 1C 52  	LD IX, GETBYT
  29+ 59C1 CD 59 01     	CALL CALBAS
  30+ 59C4 F5           	PUSH AF
  31+ 59C5              	; comma
  32+ 59C5 CD 91 67     	CALL CHKCHAR
  33+ 59C8 2C           	DB ','
  34+ 59C9              	; get vsync wait
  35+ 59C9 DD 21 1C 52  	LD IX, GETBYT
  36+ 59CD CD 59 01     	CALL CALBAS
  37+ 59D0 F5           	PUSH AF
  38+ 59D1              	; ending )
  39+ 59D1 CD 91 67     	CALL CHKCHAR
  40+ 59D4 29           	DB ')'
  41+ 59D5
  42+ 59D5              	; save position
  43+ 59D5 E5           	PUSH HL
  44+ 59D6 DD E1        	POP IX
  45+ 59D8
  46+ 59D8              	; syntax ok
  47+ 59D8              	; wait for vsync if needed
  48+ 59D8 F1           	POP AF
  49+ 59D9 B7           	OR A
  50+ 59DA 28 01        	JR Z, .L1
  51+ 59DC 76           	HALT
  52+ 59DD
  53+ 59DD              .L1:
  54+ 59DD 3E 01        	LD A,1
  55+ 59DF 32 6B 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
  56+ 59E2 F1               POP AF ; value
  57+ 59E3 C1               POP BC ; count
  58+ 59E4 E1               POP HL ; offset
  59+ 59E5 CD 56 00         CALL BIOS_FILVRM
  60+ 59E8 AF           	XOR A
  61+ 59E9 32 6B 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
  62+ 59EC
  63+ 59EC              .L3:
  64+ 59EC DD E5        	PUSH IX
  65+ 59EE E1           	POP HL
  66+ 59EF C9           	RET
  67+ 59F0              ; *******************************************************************************************************
  68+ 59F0               ENDIF
  69+ 59F0
  70+ 59F0               IF (0 == 1)
  71+ 59F0 ~            ; *******************************************************************************************************
  72+ 59F0 ~            ; same as FILVRM but for DEFUSR approach
  73+ 59F0 ~            ; input IX=pointer to input array, real data from +2
  74+ 59F0 ~            ; +2 = offset
  75+ 59F0 ~            ; +4 = count
  76+ 59F0 ~            ; +6 = value
  77+ 59F0 ~            ; +8 = halt flag
  78+ 59F0 ~            FILVRM_DEFUSR:
  79+ 59F0 ~            	LD A,(IX+8)
  80+ 59F0 ~            	OR A
  81+ 59F0 ~            	JR Z,.L0
  82+ 59F0 ~            	HALT
  83+ 59F0 ~            .L0:
  84+ 59F0 ~            	LD A,1
  85+ 59F0 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  86+ 59F0 ~            	LD L,(IX+2)
  87+ 59F0 ~            	LD H,(IX+3)
  88+ 59F0 ~            	LD C,(IX+4)
  89+ 59F0 ~            	LD B,(IX+5)
  90+ 59F0 ~            	LD A,(IX+6)
  91+ 59F0 ~            	CALL BIOS_FILVRM
  92+ 59F0 ~            	XOR A
  93+ 59F0 ~            	LD (VRAM_UPDATE_IN_PROGRESS),A
  94+ 59F0 ~            	RET
  95+ 59F0 ~            ; *******************************************************************************************************
  96+ 59F0               ENDIF
  97+ 59F0
  98+ 59F0               IF (1 == 1)
  99+ 59F0              ; *******************************************************************************************************
 100+ 59F0              ; function to handle CALL MEMVRM basic extension
 101+ 59F0              ; copies from RAM to VRAM
 102+ 59F0              ; if flag != 0 it will issue HALT before copying
 103+ 59F0              ; if bit 1 of flag set and sprite system initialized it will set sprite update flag
 104+ 59F0              ; _MEMVRM ( INT source,
 105+ 59F0              ;			INT destination,
 106+ 59F0              ;			INT count,
 107+ 59F0              ;			BYTE flag)
 108+ 59F0              ; will put ram in page 0 also, page 1 is already there
 109+ 59F0              MEMVRM:
 110+ 59F0              	; opening (
 111+ 59F0 CD 91 67     	CALL CHKCHAR
 112+ 59F3 28           	DB '('
 113+ 59F4              	; get source address
 114+ 59F4 DD 21 2F 54  	LD IX, FRMQNT
 115+ 59F8 CD 59 01     	CALL CALBAS
 116+ 59FB D5           	PUSH DE
 117+ 59FC              	; comma
 118+ 59FC CD 91 67     	CALL CHKCHAR
 119+ 59FF 2C           	DB ','
 120+ 5A00              	; get destination address
 121+ 5A00 DD 21 2F 54  	LD IX, FRMQNT
 122+ 5A04 CD 59 01     	CALL CALBAS
 123+ 5A07 D5           	PUSH DE
 124+ 5A08              	; comma
 125+ 5A08 CD 91 67     	CALL CHKCHAR
 126+ 5A0B 2C           	DB ','
 127+ 5A0C              	; get length
 128+ 5A0C DD 21 2F 54  	LD IX, FRMQNT
 129+ 5A10 CD 59 01     	CALL CALBAS
 130+ 5A13 D5           	PUSH DE
 131+ 5A14              	; comma
 132+ 5A14 CD 91 67     	CALL CHKCHAR
 133+ 5A17 2C           	DB ','
 134+ 5A18              	; get vsync wait
 135+ 5A18 DD 21 1C 52  	LD IX, GETBYT
 136+ 5A1C CD 59 01     	CALL CALBAS
 137+ 5A1F F5           	PUSH AF
 138+ 5A20              	; ending )
 139+ 5A20 CD 91 67     	CALL CHKCHAR
 140+ 5A23 29           	DB ')'
 141+ 5A24
 142+ 5A24                  ; save position in BASIC text
 143+ 5A24 E5           	PUSH HL
 144+ 5A25 DD E1        	POP IX
 145+ 5A27
 146+ 5A27 F1           	POP AF ; wait vsync
 147+ 5A28 B7           	OR A
 148+ 5A29 28 0F        	JR Z, .L1
 149+ 5A2B              	; check for special case to set sprite update flag
 150+ 5A2B              	IF (SPRITE_CMDS == 1)
 151+ 5A2B E6 02        		AND 2
 152+ 5A2D 28 0A        		JR Z,.L2
 153+ 5A2F 3A 86 4D     		LD A, (SPRATR_INIT_STATUS)
 154+ 5A32 B7           		OR A
 155+ 5A33 28 04        		JR Z,.L2
 156+ 5A35 2A 87 4D     		LD HL,(SPRATR_UPDATE_FLAG)
 157+ 5A38 77           		LD (HL),A
 158+ 5A39              	ENDIF
 159+ 5A39              .L2:
 160+ 5A39 76           	HALT
 161+ 5A3A              .L1:
 162+ 5A3A              	; pop LDIR parameters and store away for later
 163+ 5A3A C1           	POP BC ; count
 164+ 5A3B D1           	POP DE ; vram destination
 165+ 5A3C E1           	POP HL ; ram source
 166+ 5A3D D9           	EXX
 167+ 5A3E FD 21 45 5A   	LD IY, .RET
 168+ 5A42 C3 42 67     	JP ENABLE_PAGE0
 169+ 5A45              .RET:
 170+ 5A45 FB           	EI
 171+ 5A46 D9           	EXX
 172+ 5A47 CD 4D 5A     	CALL VRAM_LDIRVM
 173+ 5A4A C3 55 66     	JP COMMON_EXIT_CODE_IX
 174+ 5A4D              ; *******************************************************************************************************
 175+ 5A4D               ENDIF
 176+ 5A4D
 177+ 5A4D               IF (0 == 1)
 178+ 5A4D ~            ; *******************************************************************************************************
 179+ 5A4D ~            ; same as MEMVRM but for DEFUSR approach
 180+ 5A4D ~            ; input IX=pointer to input array, real data from +2
 181+ 5A4D ~            ; +2 = source address
 182+ 5A4D ~            ; +4 = destination address
 183+ 5A4D ~            ; +6 = lenght
 184+ 5A4D ~            ; +8 = flag
 185+ 5A4D ~            MEMVRM_DEFUSR:
 186+ 5A4D ~            	LD A,(IX+8)
 187+ 5A4D ~            	OR A
 188+ 5A4D ~            	JR Z,.L0
 189+ 5A4D ~            	IF (SPRITE_CMDS == 1)
 190+ 5A4D ~            		AND 2
 191+ 5A4D ~            		JR Z,.L2
 192+ 5A4D ~            		LD A, (SPRATR_INIT_STATUS)
 193+ 5A4D ~            		OR A
 194+ 5A4D ~            		JR Z,.L2
 195+ 5A4D ~            		LD HL,(SPRATR_UPDATE_FLAG)
 196+ 5A4D ~            		LD (HL),A
 197+ 5A4D ~            	ENDIF
 198+ 5A4D ~            .L2:
 199+ 5A4D ~            	HALT
 200+ 5A4D ~            .L0:
 201+ 5A4D ~            	; enable page 0
 202+ 5A4D ~            	LD IY, .RET
 203+ 5A4D ~            	JP ENABLE_PAGE0
 204+ 5A4D ~            .RET:
 205+ 5A4D ~            	EI
 206+ 5A4D ~            	LD L,(IX+2)
 207+ 5A4D ~            	LD H,(IX+3)
 208+ 5A4D ~            	LD E,(IX+4)
 209+ 5A4D ~            	LD D,(IX+5)
 210+ 5A4D ~            	LD C,(IX+6)
 211+ 5A4D ~            	LD B,(IX+7)
 212+ 5A4D ~            	CALL VRAM_LDIRVM
 213+ 5A4D ~                JP COMMON_EXIT_CODE
 214+ 5A4D ~            ; *******************************************************************************************************
 215+ 5A4D               ENDIF
 216+ 5A4D
 217+ 5A4D              ; *******************************************************************************************************
 218+ 5A4D              ; common code to copy from memory to VRAM
 219+ 5A4D              ; input HL=RAM source
 220+ 5A4D              ; input DE=VRAM destination
 221+ 5A4D              ; BC=count
 222+ 5A4D              VRAM_LDIRVM:
 223+ 5A4D 3E 01        	LD A,1
 224+ 5A4F 32 6B 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 225+ 5A52 EB           	EX DE, HL
 226+ 5A53 F3           	DI
 227+ 5A54 CD 5F 66     	CALL SETWRT_LOCAL_WRITE
 228+ 5A57 FB           	EI
 229+ 5A58 EB           	EX DE, HL
 230+ 5A59 78           	LD A, B
 231+ 5A5A B7           	OR A
 232+ 5A5B 28 0D        	JR Z, .L3
 233+ 5A5D C5           	PUSH BC
 234+ 5A5E 0E 98        	LD C, #98
 235+ 5A60              .L2:
 236+ 5A60 50           	LD D, B
 237+ 5A61 06 00        	LD B, 0
 238+ 5A63 CD 76 66     	CALL BBYTECOPY_NO_C
 239+ 5A66 42           	LD B, D
 240+ 5A67 10 F7        	DJNZ .L2
 241+ 5A69 C1           	POP BC
 242+ 5A6A              .L3:
 243+ 5A6A 79           	LD A, C
 244+ 5A6B B7           	OR A
 245+ 5A6C 28 04        	JR Z,.L4
 246+ 5A6E 41           	LD B, C
 247+ 5A6F CD 74 66     	CALL BBYTECOPY
 248+ 5A72              .L4:
 249+ 5A72 AF           	XOR A
 250+ 5A73 32 6B 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 251+ 5A76 C9           	RET
 252+ 5A77              ; *******************************************************************************************************
 253+ 5A77
 254+ 5A77               IF (1 == 1)
 255+ 5A77              ; *******************************************************************************************************
 256+ 5A77              ; function to handle CALL VRMMEM basic extension
 257+ 5A77              ; copies from VRAM to RAM
 258+ 5A77              ; _VRMMEM ( INT source,
 259+ 5A77              ;			INT destination,
 260+ 5A77              ;			INT count
 261+ 5A77              ; will put ram in page 0 also, page 1 is already there
 262+ 5A77              VRMMEM:
 263+ 5A77              	; opening (
 264+ 5A77 CD 91 67     	CALL CHKCHAR
 265+ 5A7A 28           	DB '('
 266+ 5A7B              	; get source address
 267+ 5A7B DD 21 2F 54  	LD IX, FRMQNT
 268+ 5A7F CD 59 01     	CALL CALBAS
 269+ 5A82 D5           	PUSH DE
 270+ 5A83              	; comma
 271+ 5A83 CD 91 67     	CALL CHKCHAR
 272+ 5A86 2C           	DB ','
 273+ 5A87              	; get destination address
 274+ 5A87 DD 21 2F 54  	LD IX, FRMQNT
 275+ 5A8B CD 59 01     	CALL CALBAS
 276+ 5A8E D5           	PUSH DE
 277+ 5A8F              	; comma
 278+ 5A8F CD 91 67     	CALL CHKCHAR
 279+ 5A92 2C           	DB ','
 280+ 5A93              	; get length
 281+ 5A93 DD 21 2F 54  	LD IX, FRMQNT
 282+ 5A97 CD 59 01     	CALL CALBAS
 283+ 5A9A D5           	PUSH DE
 284+ 5A9B              	; ending )
 285+ 5A9B CD 91 67     	CALL CHKCHAR
 286+ 5A9E 29           	DB ')'
 287+ 5A9F
 288+ 5A9F                  ; save position in BASIC text
 289+ 5A9F E5           	PUSH HL
 290+ 5AA0 DD E1        	POP IX
 291+ 5AA2
 292+ 5AA2 C1           	POP BC ; count
 293+ 5AA3 D1           	POP DE ; destination
 294+ 5AA4 E1           	POP HL ; source
 295+ 5AA5 D9           	EXX
 296+ 5AA6 FD 21 AD 5A  	LD IY, .RET
 297+ 5AAA C3 42 67     	JP ENABLE_PAGE0
 298+ 5AAD              .RET:
 299+ 5AAD FB           	EI
 300+ 5AAE D9           	EXX
 301+ 5AAF CD B5 5A     	CALL VRAM_LDIRMV
 302+ 5AB2 C3 55 66     	JP COMMON_EXIT_CODE_IX
 303+ 5AB5              ; *******************************************************************************************************
 304+ 5AB5               ENDIF
 305+ 5AB5
 306+ 5AB5               IF (0 == 1)
 307+ 5AB5 ~            ; *******************************************************************************************************
 308+ 5AB5 ~            ; same as VRMMEM but for DEFUSR approach
 309+ 5AB5 ~            ; input IX=pointer to input array, real data from +2
 310+ 5AB5 ~            ; +2 = source address
 311+ 5AB5 ~            ; +4 = destination address
 312+ 5AB5 ~            ; +6 = count
 313+ 5AB5 ~            VRMMEM_DEFUSR:
 314+ 5AB5 ~            	; enable page 0
 315+ 5AB5 ~            	LD IY, .RET
 316+ 5AB5 ~            	JP ENABLE_PAGE0
 317+ 5AB5 ~            .RET:
 318+ 5AB5 ~            	EI
 319+ 5AB5 ~            	LD L,(IX+2)
 320+ 5AB5 ~            	LD H,(IX+3)
 321+ 5AB5 ~            	LD E,(IX+4)
 322+ 5AB5 ~            	LD D,(IX+5)
 323+ 5AB5 ~            	LD C,(IX+6)
 324+ 5AB5 ~            	LD B,(IX+7)
 325+ 5AB5 ~            	CALL VRAM_LDIRMV
 326+ 5AB5 ~            	JP COMMON_EXIT_CODE
 327+ 5AB5 ~            ; *******************************************************************************************************
 328+ 5AB5               ENDIF
 329+ 5AB5
 330+ 5AB5              ; *******************************************************************************************************
 331+ 5AB5              ; common code to copy from VRAM to RAM
 332+ 5AB5              ; input HL=VRAM source
 333+ 5AB5              ; input DE=RAM destination
 334+ 5AB5              ; BC=count
 335+ 5AB5              VRAM_LDIRMV:
 336+ 5AB5 3E 01        	LD A,1
 337+ 5AB7 32 6B 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 338+ 5ABA 7D           	LD	A, L
 339+ 5ABB F3           	DI
 340+ 5ABC CD 6A 66     	CALL SETWRT_LOCAL_READ
 341+ 5ABF FB           	EI
 342+ 5AC0 00           	NOP
 343+ 5AC1 00           	NOP
 344+ 5AC2 00           	NOP ; too fast VDP access per openMSX
 345+ 5AC3              .L4:
 346+ 5AC3 DB 98            IN A, (#98)
 347+ 5AC5 12           	LD (DE), A
 348+ 5AC6 13               INC DE
 349+ 5AC7 0B               DEC BC
 350+ 5AC8 79               LD A, C
 351+ 5AC9 B0               OR B
 352+ 5ACA 20 F7            JR NZ, .L4
 353+ 5ACC AF           	XOR A
 354+ 5ACD 32 6B 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 355+ 5AD0 C9               RET
 356+ 5AD1              ; *******************************************************************************************************
# file closed: asm\VRAM.asm
 152  5AD1               ENDIF
 153  5AD1
 154  5AD1               IF (GENCAL_CMD == 1)
 155  5AD1               INCLUDE "GENCAL.asm"
# file opened: asm\GENCAL.asm
   1+ 5AD1               IF (0 == 1)
   2+ 5AD1 ~            ; *******************************************************************************************************
   3+ 5AD1 ~            ; same as GENCAL but for DEFUSR approach
   4+ 5AD1 ~            ; input IX=pointer to input array, real data from +2
   5+ 5AD1 ~            ; +2 = function address to call
   6+ 5AD1 ~            ; +4 = register list array pointer
   7+ 5AD1 ~            GENCAL_DEFUSR:
   8+ 5AD1 ~                LD L,(IX+2)
   9+ 5AD1 ~                LD H,(IX+3)
  10+ 5AD1 ~                PUSH HL
  11+ 5AD1 ~                LD L,(IX+4)
  12+ 5AD1 ~                LD H,(IX+5)
  13+ 5AD1 ~                PUSH HL
  14+ 5AD1 ~                JR GENCAL.COMMON
  15+ 5AD1 ~            ; *******************************************************************************************************
  16+ 5AD1               ENDIF
  17+ 5AD1
  18+ 5AD1              ; *******************************************************************************************************
  19+ 5AD1              ; function to handle CALL GENCAL basic extension
  20+ 5AD1              ; GENCAL ( INT fn_addr, = address of the function to call
  21+ 5AD1              ;		   INT[] reg_list_ptr, = array holding register values (AF,BC,DE,HL,IX,IY)
  22+ 5AD1              ; output values of registers will also be stored at reg_list_ptr
  23+ 5AD1              GENCAL:
  24+ 5AD1               IF (1 == 1)
  25+ 5AD1              	; opening (
  26+ 5AD1 CD 91 67     	CALL CHKCHAR
  27+ 5AD4 28           	DB '('
  28+ 5AD5              	; get function address
  29+ 5AD5 DD 21 2F 54  	LD IX, FRMQNT
  30+ 5AD9 CD 59 01     	CALL CALBAS
  31+ 5ADC D5           	PUSH DE
  32+ 5ADD              	; comma
  33+ 5ADD CD 91 67     	CALL CHKCHAR
  34+ 5AE0 2C           	DB ','
  35+ 5AE1              	; get pointer to register list
  36+ 5AE1 3E 02            LD A,2
  37+ 5AE3 06 01            LD B,1
  38+ 5AE5 11 00 05         LD DE,#0500
  39+ 5AE8 CD F6 67         CALL GET_BASIC_ARRAY_DATA_POINTER
  40+ 5AEB C5           	PUSH BC
  41+ 5AEC              	; ending )
  42+ 5AEC CD 91 67     	CALL CHKCHAR
  43+ 5AEF 29           	DB ')'
  44+ 5AF0               ENDIF
  45+ 5AF0              .COMMON:
  46+ 5AF0              	; save BASIC token position
  47+ 5AF0 E5           	PUSH HL
  48+ 5AF1 D9               EXX
  49+ 5AF2 E1           	POP HL ; HL'=next basic token
  50+ 5AF3 D9               EXX
  51+ 5AF4
  52+ 5AF4 E1               POP HL ; get pointer to register values
  53+ 5AF5 F3           	DI
  54+ 5AF6 ED 73 5A 64      LD (TMP_STRUCT), SP
  55+ 5AFA F9               LD SP, HL
  56+ 5AFB F1               POP AF
  57+ 5AFC C1               POP BC
  58+ 5AFD D1               POP DE
  59+ 5AFE E1               POP HL
  60+ 5AFF DD E1            POP IX
  61+ 5B01 FD E1            POP IY
  62+ 5B03 D9               EXX
  63+ 5B04 ED 73 5C 64      LD (TMP_STRUCT+2), SP
  64+ 5B08 ED 7B 5A 64      LD SP, (TMP_STRUCT)
  65+ 5B0C FB               EI
  66+ 5B0D D1               POP DE ; get function to call
  67+ 5B0E E5               PUSH HL
  68+ 5B0F CD 2B 5B         CALL .EXXDECALL
  69+ 5B12 F3               DI
  70+ 5B13 ED 73 5A 64      LD (TMP_STRUCT), SP
  71+ 5B17 ED 7B 5C 64      LD SP, (TMP_STRUCT+2)
  72+ 5B1B FD E5            PUSH IY
  73+ 5B1D DD E5            PUSH IX
  74+ 5B1F E5               PUSH HL
  75+ 5B20 D5               PUSH DE
  76+ 5B21 C5               PUSH BC
  77+ 5B22 F5               PUSH AF
  78+ 5B23 ED 7B 5A 64      LD SP, (TMP_STRUCT)
  79+ 5B27 FB               EI
  80+ 5B28 E1               POP HL
  81+ 5B29 AF               XOR A ; success
  82+ 5B2A C9           	RET
  83+ 5B2B
  84+ 5B2B              .EXXDECALL:
  85+ 5B2B D5               PUSH DE
  86+ 5B2C D9               EXX
  87+ 5B2D C9               RET
  88+ 5B2E              ; *******************************************************************************************************
# file closed: asm\GENCAL.asm
 156  5B2E               ENDIF
 157  5B2E
 158  5B2E               IF (BOX_CMDS == 1)
 159  5B2E               INCLUDE "BOX.asm"
# file opened: asm\BOX.asm
   1+ 5B2E              ; *******************************************************************************************************
   2+ 5B2E              ; generic function to implement rectangle data copy
   3+ 5B2E              ; should be modified to call appropriate function for memory or vram
   4+ 5B2E              ; input IX=pointer to following structure
   5+ 5B2E              ; +00 source data pointer
   6+ 5B2E              ; +02 num bytes in a row
   7+ 5B2E              ; +04 number of rows
   8+ 5B2E              ; +06 source add-to value till next row
   9+ 5B2E              ; +08 destination address
  10+ 5B2E              ; +10 destination add-to value till next row
  11+ 5B2E              ; modifies AF, BC, DE, HL
  12+ 5B2E              RECTANGLE_COPY:
  13+ 5B2E DD 6E 00     	LD L, (IX+0)
  14+ 5B31 DD 66 01     	LD H, (IX+1) ; source address
  15+ 5B34 DD 5E 08     	LD E, (IX+8)
  16+ 5B37 DD 56 09     	LD D, (IX+9) ; destination
  17+ 5B3A DD 46 04     	LD B, (IX+4) ; row number
  18+ 5B3D              .L1:
  19+ 5B3D C5           	PUSH BC
  20+ 5B3E E5           		PUSH HL
  21+ 5B3F D5           			PUSH DE
  22+ 5B40 DD 4E 02     				LD C, (IX+2)
  23+ 5B43 DD 46 03     				LD B, (IX+3) ; num bytes in a row
  24+ 5B46              .CALL1:
  25+ 5B46 CD 00 00     				CALL 0 ; set destination address from DE
  26+ 5B49              .CALL2:
  27+ 5B49 CD 00 00     				CALL 0 ; copy data fn
  28+ 5B4C E1           			POP HL
  29+ 5B4D DD 4E 0A     			LD C, (IX+10)
  30+ 5B50 DD 46 0B     			LD B, (IX+11) ; destination add-to
  31+ 5B53 09           			ADD HL, BC
  32+ 5B54 EB           			EX DE, HL
  33+ 5B55 E1           		POP HL
  34+ 5B56 DD 4E 06     		LD C, (IX+6)
  35+ 5B59 DD 46 07     		LD B, (IX+7) ; src add-to
  36+ 5B5C 09           		ADD HL, BC
  37+ 5B5D C1           	POP BC
  38+ 5B5E 10 DD        	DJNZ .L1
  39+ 5B60 C9           	RET
  40+ 5B61              ; *******************************************************************************************************
  41+ 5B61
  42+ 5B61               IF (1 == 1)
  43+ 5B61              ; *******************************************************************************************************
  44+ 5B61              ; function to handle CALL BOXMEMCPY basic extension
  45+ 5B61              ; copies data with window like boundaries within ram
  46+ 5B61              ; BOXMEMCPY ( INT source data pointer,
  47+ 5B61              ;			  INT source number of bytes in a row,
  48+ 5B61              ;			  INT number of rows,
  49+ 5B61              ;			  INT source add-to value till next row,
  50+ 5B61              ; 			  INT destination pointer,
  51+ 5B61              ;			  INT destination add-to value till next row )
  52+ 5B61              ; request_data_ptr described in RECTANGLE_COPY
  53+ 5B61              ; will put ram in page 0 also, page 1 is already there
  54+ 5B61              BOXMEMCPY:
  55+ 5B61 11 6B 5B     	LD DE,BOXMEMCPY_COMMON
  56+ 5B64 ED 53 E3 5B  	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
  57+ 5B68 C3 7E 5B     	JP BOX_EXTENSION_PARAMS_COMMON
  58+ 5B6B               ENDIF
  59+ 5B6B
  60+ 5B6B               IF (0 == 1)
  61+ 5B6B ~            ; *******************************************************************************************************
  62+ 5B6B ~            ; same as BOXMEMCPY but for DEFUSR approach
  63+ 5B6B ~            ; input IX=pointer to input array, real data from +2
  64+ 5B6B ~            ; +02 = source data pointer
  65+ 5B6B ~            ; +04 = source number of bytes in a row
  66+ 5B6B ~            ; +06 = number of rows
  67+ 5B6B ~            ; +08 = source add-to value till next row
  68+ 5B6B ~            ; +10 = destination pointer
  69+ 5B6B ~            ; +12 = destination add-to value till next row
  70+ 5B6B ~            BOXMEMCPY_DEFUSR:
  71+ 5B6B ~            	LD HL,BOXMEMCPY_COMMON
  72+ 5B6B ~            	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
  73+ 5B6B ~            	INC IX
  74+ 5B6B ~            	INC IX
  75+ 5B6B ~            	JP BOXCOMMON_DEFUSR
  76+ 5B6B               ENDIF
  77+ 5B6B
  78+ 5B6B              BOXMEMCPY_COMMON:
  79+ 5B6B FB           	EI
  80+ 5B6C              	; set RAM functions to call
  81+ 5B6C 21 00 00     	LD HL, 0
  82+ 5B6F 22 46 5B     	LD (RECTANGLE_COPY.CALL1), HL ; NOP NOP
  83+ 5B72 22 48 5B     	LD (RECTANGLE_COPY.CALL1+2), HL ; NOP NOP
  84+ 5B75 21 ED B0     	LD HL, #B0ED ; LDIR
  85+ 5B78 22 4A 5B     	LD (RECTANGLE_COPY.CALL1+4), HL
  86+ 5B7B C3 E8 5B     	JP BOXCOMMON_DEFUSR.CALL
  87+ 5B7E              ; *******************************************************************************************************
  88+ 5B7E
  89+ 5B7E               IF (1 == 1)
  90+ 5B7E              ; *******************************************************************************************************
  91+ 5B7E              ; common parts of BOX commands to load parameters
  92+ 5B7E              BOX_EXTENSION_PARAMS_COMMON:
  93+ 5B7E              	; opening (
  94+ 5B7E CD 91 67     	CALL CHKCHAR
  95+ 5B81 28           	DB '('
  96+ 5B82              	; get source data pointer
  97+ 5B82 DD 21 2F 54  	LD IX, FRMQNT
  98+ 5B86 CD 59 01     	CALL CALBAS
  99+ 5B89 ED 53 5A 64  	LD (TMP_STRUCT+0), DE
 100+ 5B8D              	; comma
 101+ 5B8D CD 91 67     	CALL CHKCHAR
 102+ 5B90 2C           	DB ','
 103+ 5B91              	; source number of bytes in a row
 104+ 5B91 DD 21 2F 54  	LD IX, FRMQNT
 105+ 5B95 CD 59 01     	CALL CALBAS
 106+ 5B98 ED 53 5C 64  	LD (TMP_STRUCT+2), DE
 107+ 5B9C              	; comma
 108+ 5B9C CD 91 67     	CALL CHKCHAR
 109+ 5B9F 2C           	DB ','
 110+ 5BA0              	; number of rows
 111+ 5BA0 DD 21 2F 54  	LD IX, FRMQNT
 112+ 5BA4 CD 59 01     	CALL CALBAS
 113+ 5BA7 ED 53 5E 64  	LD (TMP_STRUCT+4), DE
 114+ 5BAB              	; comma
 115+ 5BAB CD 91 67     	CALL CHKCHAR
 116+ 5BAE 2C           	DB ','
 117+ 5BAF              	; source add-to value till next row
 118+ 5BAF DD 21 2F 54  	LD IX, FRMQNT
 119+ 5BB3 CD 59 01     	CALL CALBAS
 120+ 5BB6 ED 53 60 64  	LD (TMP_STRUCT+6), DE
 121+ 5BBA              	; comma
 122+ 5BBA CD 91 67     	CALL CHKCHAR
 123+ 5BBD 2C           	DB ','
 124+ 5BBE              	; destination pointer
 125+ 5BBE DD 21 2F 54  	LD IX, FRMQNT
 126+ 5BC2 CD 59 01     	CALL CALBAS
 127+ 5BC5 ED 53 62 64  	LD (TMP_STRUCT+8), DE
 128+ 5BC9              	; comma
 129+ 5BC9 CD 91 67     	CALL CHKCHAR
 130+ 5BCC 2C           	DB ','
 131+ 5BCD              	; destination add-to value till next row
 132+ 5BCD DD 21 2F 54  	LD IX, FRMQNT
 133+ 5BD1 CD 59 01     	CALL CALBAS
 134+ 5BD4 ED 53 64 64  	LD (TMP_STRUCT+10), DE
 135+ 5BD8              	; ending )
 136+ 5BD8 CD 91 67     	CALL CHKCHAR
 137+ 5BDB 29           	DB ')'
 138+ 5BDC DD 21 5A 64  	LD IX,TMP_STRUCT
 139+ 5BE0               ENDIF
 140+ 5BE0              BOXCOMMON_DEFUSR:
 141+ 5BE0 E5           	PUSH HL ; save position in BASIC buffer
 142+ 5BE1              .ADDR:
 143+ 5BE1 FD 21 00 00  	LD IY, 0 ; modified by code
 144+ 5BE5 C3 42 67     	JP ENABLE_PAGE0
 145+ 5BE8              .CALL:
 146+ 5BE8 CD 2E 5B     	CALL RECTANGLE_COPY
 147+ 5BEB D1           	POP DE
 148+ 5BEC C1           	POP BC
 149+ 5BED CD B9 66     	CALL RESTORE_PAGE_INFO
 150+ 5BF0 E1           	POP HL
 151+ 5BF1 AF           	XOR A ; success
 152+ 5BF2 32 6B 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 153+ 5BF5 C9           	RET
 154+ 5BF6              ; *******************************************************************************************************
 155+ 5BF6
 156+ 5BF6               IF (1 == 1)
 157+ 5BF6              ; *******************************************************************************************************
 158+ 5BF6              ; function to handle CALL BOXMEMVRM basic extension
 159+ 5BF6              ; copies data with window like boundaries from ram to Vram
 160+ 5BF6              ; BOXMEMVRM ( INT source data pointer,
 161+ 5BF6              ;			  INT source number of bytes in a row,
 162+ 5BF6              ;			  INT number of rows,
 163+ 5BF6              ;			  INT source add-to value till next row,
 164+ 5BF6              ; 			  INT destination pointer,
 165+ 5BF6              ;			  INT destination add-to value till next row )
 166+ 5BF6              ; request_data_ptr described in RECTANGLE_COPY
 167+ 5BF6              ; will put ram in page 0 also, page 1 is already there
 168+ 5BF6              BOXMEMVRM:
 169+ 5BF6 11 00 5C     	LD DE,BOXMEMVRM_COMMON
 170+ 5BF9 ED 53 E3 5B  	LD (BOXCOMMON_DEFUSR.ADDR+2), DE
 171+ 5BFD C3 7E 5B     	JP BOX_EXTENSION_PARAMS_COMMON
 172+ 5C00               ENDIF
 173+ 5C00
 174+ 5C00               IF (0 == 1)
 175+ 5C00 ~            ; *******************************************************************************************************
 176+ 5C00 ~            ; same as BOXMEMVRM but for DEFUSR approach
 177+ 5C00 ~            ; input IX=pointer to input array, real data from +2
 178+ 5C00 ~            ; +02 = source data pointer
 179+ 5C00 ~            ; +04 = source number of bytes in a row
 180+ 5C00 ~            ; +06 = number of rows
 181+ 5C00 ~            ; +08 = source add-to value till next row
 182+ 5C00 ~            ; +10 = destination pointer
 183+ 5C00 ~            ; +12 = destination add-to value till next row
 184+ 5C00 ~            BOXMEMVRM_DEFUSR:
 185+ 5C00 ~            	LD HL,BOXMEMVRM_COMMON
 186+ 5C00 ~            	LD (BOXCOMMON_DEFUSR.ADDR+2),HL
 187+ 5C00 ~            	INC IX
 188+ 5C00 ~            	INC IX
 189+ 5C00 ~            	JP BOXCOMMON_DEFUSR
 190+ 5C00               ENDIF
 191+ 5C00
 192+ 5C00              BOXMEMVRM_COMMON:
 193+ 5C00 FB           	EI
 194+ 5C01              	; set RAM functions to call
 195+ 5C01 21 1B 5C     	LD HL, .SETDEST
 196+ 5C04 22 47 5B     	LD (RECTANGLE_COPY.CALL1+1), HL
 197+ 5C07 21 23 5C     	LD HL, .COPYDATA
 198+ 5C0A 22 4A 5B     	LD (RECTANGLE_COPY.CALL2+1), HL
 199+ 5C0D 3E CD        	LD A, #CD ; CALL
 200+ 5C0F 32 46 5B     	LD (RECTANGLE_COPY.CALL1), A
 201+ 5C12 32 49 5B     	LD (RECTANGLE_COPY.CALL2), A
 202+ 5C15              	;LD A,1
 203+ 5C15 32 6B 64     	LD (VRAM_UPDATE_IN_PROGRESS),A
 204+ 5C18 C3 E8 5B     	JP BOXCOMMON_DEFUSR.CALL
 205+ 5C1B              .SETDEST:
 206+ 5C1B EB           	EX DE, HL
 207+ 5C1C F3           	DI
 208+ 5C1D CD 5F 66     	CALL SETWRT_LOCAL_WRITE
 209+ 5C20 FB           	EI
 210+ 5C21 EB           	EX DE, HL
 211+ 5C22 C9           	RET
 212+ 5C23              .COPYDATA:
 213+ 5C23 41           	LD B, C
 214+ 5C24 C3 74 66     	JP BBYTECOPY
 215+ 5C27              ; *******************************************************************************************************
# file closed: asm\BOX.asm
 160  5C27               ENDIF
 161  5C27
 162  5C27               IF (BLIT_CMDS == 1)
 163  5C27               INCLUDE "BLIT.asm"
# file opened: asm\BLIT.asm
   1+ 5C27              ; *******************************************************************************************************
   2+ 5C27              ; function rotates mask and data of several characters and applies to background data
   3+ 5C27              ; this handles x-shift from 0 to 4
   4+ 5C27              ; contains self-modifying code that is set-up from external function
   5+ 5C27              ; input HL=pointer to mask data
   6+ 5C27              ; input HL'=pointer to character data
   7+ 5C27              ; input DE=output buffer containing background data
   8+ 5C27              ; input BC=DE+8
   9+ 5C27              ; input A=number of characters to process
  10+ 5C27              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  11+ 5C27              SHIFT04:
  12+ 5C27 08           	EX AF, AF'
  13+ 5C28 7E           	LD A, (HL) ; get mask
  14+ 5C29 D9           	EXX
  15+ 5C2A 57           	LD D, A
  16+ 5C2B 1E FF        	LD E, #FF
  17+ 5C2D 37           	SCF
  18+ 5C2E              .M1:
  19+ 5C2E 18 FE        	JR .M1 ; this is self-modifying part
  20+ 5C30 CB 1A        	RR D
  21+ 5C32 CB 1B        	RR E
  22+ 5C34 CB 1A        	RR D
  23+ 5C36 CB 1B        	RR E
  24+ 5C38 CB 1A        	RR D
  25+ 5C3A CB 1B        	RR E
  26+ 5C3C CB 1A        	RR D
  27+ 5C3E CB 1B        	RR E
  28+ 5C40
  29+ 5C40 46           	LD B, (HL) ; get data
  30+ 5C41 0E 00        	LD C, 0
  31+ 5C43              .M2:
  32+ 5C43 18 FE        	JR .M2 ; also self-modifying part
  33+ 5C45 CB 38        	SRL B
  34+ 5C47 CB 19        	RR C
  35+ 5C49 CB 38        	SRL B
  36+ 5C4B CB 19        	RR C
  37+ 5C4D CB 38        	SRL B
  38+ 5C4F CB 19        	RR C
  39+ 5C51 CB 38        	SRL B
  40+ 5C53 CB 19        	RR C
  41+ 5C55
  42+ 5C55 D9           	EXX
  43+ 5C56 1A           	LD A, (DE) ; background
  44+ 5C57 D9           	EXX
  45+ 5C58 A2           	AND D
  46+ 5C59 B0           	OR B
  47+ 5C5A D9           	EXX
  48+ 5C5B 12           	LD (DE), A
  49+ 5C5C
  50+ 5C5C 0A           	LD A, (BC)
  51+ 5C5D D9           	EXX
  52+ 5C5E A3           	AND E
  53+ 5C5F B1           	OR C
  54+ 5C60 23           	INC HL
  55+ 5C61 D9           	EXX
  56+ 5C62 02           	LD (BC), A
  57+ 5C63
  58+ 5C63 23           	INC HL
  59+ 5C64 13           	INC DE
  60+ 5C65 03           	INC BC
  61+ 5C66
  62+ 5C66 08           	EX AF, AF'
  63+ 5C67 3D           	DEC A
  64+ 5C68 C2 27 5C     	JP NZ, SHIFT04
  65+ 5C6B C9           	RET
  66+ 5C6C              ; *******************************************************************************************************
  67+ 5C6C
  68+ 5C6C              ; *******************************************************************************************************
  69+ 5C6C              ; function rotates mask and data of several characters and applies to background data
  70+ 5C6C              ; this handles x-shift from 5 to 8
  71+ 5C6C              ; contains self-modifying code that is set-up from external function
  72+ 5C6C              ; input HL=pointer to mask data
  73+ 5C6C              ; input HL'=pointer to character data
  74+ 5C6C              ; input DE=output buffer containing background data
  75+ 5C6C              ; input BC=DE+8
  76+ 5C6C              ; input A=number of characters to process
  77+ 5C6C              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
  78+ 5C6C              SHIFT58:
  79+ 5C6C 08           	EX AF, AF'
  80+ 5C6D 7E           	LD A, (HL) ; get mask
  81+ 5C6E D9           	EXX
  82+ 5C6F 57           	LD D, A
  83+ 5C70 1E FF        	LD E, #FF
  84+ 5C72 37           	SCF
  85+ 5C73              .M1:
  86+ 5C73 18 FE        	JR .M1 ; this is self-modifying part
  87+ 5C75 CB 12        	RL D
  88+ 5C77 CB 13        	RL E
  89+ 5C79 CB 12        	RL D
  90+ 5C7B CB 13        	RL E
  91+ 5C7D CB 12        	RL D
  92+ 5C7F CB 13        	RL E
  93+ 5C81
  94+ 5C81 46           	LD B, (HL)
  95+ 5C82 0E 00        	LD C, 0
  96+ 5C84              .M2:
  97+ 5C84 18 FE        	JR .M2 ; also self-modifying part
  98+ 5C86 CB 20        	SLA B
  99+ 5C88 CB 11        	RL C
 100+ 5C8A CB 20        	SLA B
 101+ 5C8C CB 11        	RL C
 102+ 5C8E CB 20        	SLA B
 103+ 5C90 CB 11        	RL C
 104+ 5C92
 105+ 5C92 D9           	EXX
 106+ 5C93 1A           	LD A, (DE) ; background
 107+ 5C94 D9           	EXX
 108+ 5C95 A3           	AND E
 109+ 5C96 B1           	OR C
 110+ 5C97 D9           	EXX
 111+ 5C98 12           	LD (DE), A
 112+ 5C99
 113+ 5C99 0A           	LD A, (BC)
 114+ 5C9A D9           	EXX
 115+ 5C9B A2           	AND D
 116+ 5C9C B0           	OR B
 117+ 5C9D 23           	INC HL
 118+ 5C9E D9           	EXX
 119+ 5C9F 02           	LD (BC), A
 120+ 5CA0
 121+ 5CA0 23           	INC HL
 122+ 5CA1 13           	INC DE
 123+ 5CA2 03           	INC BC
 124+ 5CA3
 125+ 5CA3 08           	EX AF, AF'
 126+ 5CA4 3D           	DEC A
 127+ 5CA5 C2 6C 5C     	JP NZ, SHIFT58
 128+ 5CA8 C9           	RET
 129+ 5CA9              ; *******************************************************************************************************
 130+ 5CA9
 131+ 5CA9              ; *******************************************************************************************************
 132+ 5CA9              ; routine that shifts one row of characters
 133+ 5CA9              ; contains self-modifying code that is set-up from external function
 134+ 5CA9              ; input HL=pointer to mask data
 135+ 5CA9              ; input HL'=pointer to character data
 136+ 5CA9              ; input DE=output buffer containing background data
 137+ 5CA9              ; input A=number of characters to process
 138+ 5CA9              ; input IX=pointer to structure describing input data
 139+ 5CA9              ; modifies AF, AF', HL, HL', DE, DE', BC, BC'
 140+ 5CA9              SHIFT_ROW:
 141+ 5CA9 F5           	PUSH AF
 142+ 5CAA ED 53 56 64  		LD (BLIT_TMP1), DE
 143+ 5CAE E5           		PUSH HL
 144+ 5CAF CD F2 5C     			CALL .ADDYSHIFT
 145+ 5CB2 E1           		POP HL
 146+ 5CB3 ED 53 58 64  		LD (BLIT_TMP2), DE ; DE+vertical shift
 147+ 5CB7              .L1:
 148+ 5CB7 3E 08        		LD A, 8
 149+ 5CB9 DD 96 02     		SUB (IX+2) ; y shift
 150+ 5CBC              .CALL1:
 151+ 5CBC CD 00 00     		CALL 0
 152+ 5CBF DD 7E 02     		LD A, (IX+2); y shift
 153+ 5CC2 B7           		OR A
 154+ 5CC3 28 26        		JR Z, .DONE
 155+ 5CC5 ED 5B 56 64  		LD DE, (BLIT_TMP1)
 156+ 5CC9 E5           		PUSH HL
 157+ 5CCA CD 00 5D     			CALL .DETONEXTROW
 158+ 5CCD E1           		POP HL
 159+ 5CCE              .CALL2:
 160+ 5CCE CD 00 00     		CALL 0
 161+ 5CD1 ED 5B 56 64  		LD DE, (BLIT_TMP1)
 162+ 5CD5 E5           		PUSH HL
 163+ 5CD6 CD FA 5C     			CALL .ADD8
 164+ 5CD9 E1           		POP HL
 165+ 5CDA ED 53 56 64  		LD (BLIT_TMP1), DE
 166+ 5CDE ED 5B 58 64  		LD DE, (BLIT_TMP2)
 167+ 5CE2 E5           		PUSH HL
 168+ 5CE3 CD FA 5C     			CALL .ADD8
 169+ 5CE6 E1           		POP HL
 170+ 5CE7 ED 53 58 64  		LD (BLIT_TMP2), DE ; DE+vertical shift
 171+ 5CEB              .DONE:
 172+ 5CEB F1           	POP AF
 173+ 5CEC 3D           	DEC A
 174+ 5CED C8           	RET Z
 175+ 5CEE F5           	PUSH AF
 176+ 5CEF C3 B7 5C     	JP .L1
 177+ 5CF2              .ADDYSHIFT:
 178+ 5CF2 EB           	EX DE, HL
 179+ 5CF3 16 00        	LD D, 0
 180+ 5CF5 DD 5E 02     	LD E, (IX+2); y shift
 181+ 5CF8 18 0C        	JR .MOVDEBC
 182+ 5CFA              .ADD8:
 183+ 5CFA 21 08 00     	LD HL, 8
 184+ 5CFD C3 06 5D     	JP .MOVDEBC
 185+ 5D00              .DETONEXTROW:
 186+ 5D00 DD 6E 06     	LD L, (IX+6)
 187+ 5D03 DD 66 07     	LD H, (IX+7) ; bkg add to value
 188+ 5D06              .MOVDEBC:
 189+ 5D06 19           	ADD HL, DE
 190+ 5D07 54           	LD D, H
 191+ 5D08 5D           	LD E, L
 192+ 5D09 01 08 00     	LD BC, 8
 193+ 5D0C 09           	ADD HL, BC
 194+ 5D0D 44           	LD B, H
 195+ 5D0E 4D           	LD C, L
 196+ 5D0F C9           	RET
 197+ 5D10              ; *******************************************************************************************************
 198+ 5D10
 199+ 5D10              ; *******************************************************************************************************
 200+ 5D10              ; function rotates mask and character data and applies it to background
 201+ 5D10              ; input IX=pointer to structure describing input data
 202+ 5D10              ; +0  DW horizontal shift count 0-7 (low byte used)
 203+ 5D10              ; +2  DW vertical shift count 0-7 (low byte used)
 204+ 5D10              ; +4  DW background data start;
 205+ 5D10              ; +6  DW background add to value to next row of background data
 206+ 5D10              ; +8  DW mask data start;
 207+ 5D10              ; +10  DW character data start;
 208+ 5D10              ; +12 DW character&mask add to value to next row of data
 209+ 5D10              ; +14 DW columns (low byte used)
 210+ 5D10              ; +16 DW rows (low byte used)
 211+ 5D10              SHIFT_MERGE_CHARACTER:
 212+ 5D10 DD 7E 00     	LD A, (IX) ; shift
 213+ 5D13 FE 05        	CP 5
 214+ 5D15 38 25        	JR C, .RIGHT
 215+ 5D17              	; shifts 5-7, use rotate towards left 1-3
 216+ 5D17 21 6C 5C     	LD HL, SHIFT58
 217+ 5D1A 22 BD 5C     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 218+ 5D1D 22 CF 5C     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 219+ 5D20 D6 05        	SUB 5
 220+ 5D22 28 0D        	JR Z, .L1
 221+ 5D24 87           	ADD A, A
 222+ 5D25 87           	ADD A, A
 223+ 5D26 67           	LD H, A
 224+ 5D27 2E 18        	LD L, #18 ; JR opcode
 225+ 5D29 22 73 5C     	LD (SHIFT58.M1), HL
 226+ 5D2C 22 84 5C     	LD (SHIFT58.M2), HL
 227+ 5D2F 18 32        	JR .DO
 228+ 5D31              .L1:
 229+ 5D31 21 00 00     	LD HL, 0 ; 2xNOP opcode
 230+ 5D34 22 73 5C     	LD (SHIFT58.M1), HL
 231+ 5D37 22 84 5C     	LD (SHIFT58.M2), HL
 232+ 5D3A 18 27        	JR .DO
 233+ 5D3C              .RIGHT:
 234+ 5D3C              	; shifts 0-4, rotate towards right
 235+ 5D3C 21 27 5C     	LD HL, SHIFT04
 236+ 5D3F 22 BD 5C     	LD (SHIFT_ROW.CALL1+1), HL ; modify fn used
 237+ 5D42 22 CF 5C     	LD (SHIFT_ROW.CALL2+1), HL ; modify fn used
 238+ 5D45 FE 04        	CP 4
 239+ 5D47 28 11        	JR Z, .R1
 240+ 5D49 D6 04        	SUB 4
 241+ 5D4B ED 44        	NEG
 242+ 5D4D 87           	ADD A, A
 243+ 5D4E 87           	ADD A, A
 244+ 5D4F 67           	LD H, A
 245+ 5D50 2E 18        	LD L, #18 ; JR opcode
 246+ 5D52 22 2E 5C     	LD (SHIFT04.M1), HL
 247+ 5D55 22 43 5C     	LD (SHIFT04.M2), HL
 248+ 5D58 18 09        	JR .DO
 249+ 5D5A              .R1:
 250+ 5D5A 21 00 00     	LD HL, 0 ; 2xNOP opcode
 251+ 5D5D 22 2E 5C     	LD (SHIFT04.M1), HL
 252+ 5D60 22 43 5C     	LD (SHIFT04.M2), HL
 253+ 5D63              .DO:
 254+ 5D63 DD 46 10     	LD B, (IX+16) ; rows
 255+ 5D66 DD 6E 08     	LD L, (IX+8)
 256+ 5D69 DD 66 09     	LD H, (IX+9) ; mask data
 257+ 5D6C DD 5E 04     	LD E, (IX+4)
 258+ 5D6F DD 56 05     	LD D, (IX+5) ; background data
 259+ 5D72 D9           	EXX
 260+ 5D73 DD 6E 0A     	LD L, (IX+10)
 261+ 5D76 DD 66 0B     	LD H, (IX+11) ; character data
 262+ 5D79 D9           	EXX
 263+ 5D7A              .LOOP:
 264+ 5D7A C5           	PUSH BC
 265+ 5D7B E5           		PUSH HL
 266+ 5D7C D5           			PUSH DE
 267+ 5D7D D9           				EXX
 268+ 5D7E E5           				PUSH HL
 269+ 5D7F D9           					EXX
 270+ 5D80 DD 7E 0E     					LD A, (IX+14) ; columns
 271+ 5D83              .CALL:
 272+ 5D83 CD A9 5C     					CALL SHIFT_ROW
 273+ 5D86 E1           				POP HL
 274+ 5D87 DD 5E 0C     				LD E, (IX+12)
 275+ 5D8A DD 56 0D     				LD D, (IX+13) ; char data to next row
 276+ 5D8D 19           				ADD HL, DE
 277+ 5D8E D9           				EXX
 278+ 5D8F E1           			POP HL
 279+ 5D90 DD 5E 06     			LD E, (IX+6)
 280+ 5D93 DD 56 07     			LD D, (IX+7) ; background to next row
 281+ 5D96 19           			ADD HL, DE
 282+ 5D97 EB           			EX DE, HL
 283+ 5D98 E1           		POP HL
 284+ 5D99 DD 4E 0C     		LD C, (IX+12)
 285+ 5D9C DD 46 0D     		LD B, (IX+13) ; char data to next row
 286+ 5D9F 09           		ADD HL, BC
 287+ 5DA0 C1           	POP BC
 288+ 5DA1 10 D7        	DJNZ .LOOP
 289+ 5DA3 C9           	RET
 290+ 5DA4              ; *******************************************************************************************************
 291+ 5DA4
 292+ 5DA4              ; *******************************************************************************************************
 293+ 5DA4              ; helper function DE \ 8
 294+ 5DA4              DEdiv8:
 295+ 5DA4 7B           	LD A,E
 296+ 5DA5 CB 2A        	SRA D
 297+ 5DA7 CB 1F            RR  A
 298+ 5DA9 CB 2A            SRA D
 299+ 5DAB CB 1F            RR  A
 300+ 5DAD CB 2A            SRA D
 301+ 5DAF CB 1F            RR  A
 302+ 5DB1 C9           	RET
 303+ 5DB2              ; *******************************************************************************************************
 304+ 5DB2
 305+ 5DB2               IF (0 == 1)
 306+ 5DB2 ~            ; *******************************************************************************************************
 307+ 5DB2 ~            ; function to handle BLIT basic extension through DEFUSR call in RAW format
 308+ 5DB2 ~            ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 309+ 5DB2 ~            ; +2  DW horizontal shift count 0-7 (low byte used)
 310+ 5DB2 ~            ; +4  DW vertical shift count 0-7 (low byte used)
 311+ 5DB2 ~            ; +6  DW background data start;
 312+ 5DB2 ~            ; +8  DW background add to value to next row of background data
 313+ 5DB2 ~            ; +10  DW mask data start;
 314+ 5DB2 ~            ; +12  DW character data start;
 315+ 5DB2 ~            ; +14 DW character&mask add to value to next row of data
 316+ 5DB2 ~            ; +16 DW columns (low byte used)
 317+ 5DB2 ~            ; +18 DW rows (low byte used)
 318+ 5DB2 ~            ; will put ram in page 0 also, page 1 is already there
 319+ 5DB2 ~            ;BLIT_DEFUSR:
 320+ 5DB2 ~            ;	DI
 321+ 5DB2 ~            ;	LD IY, .RET
 322+ 5DB2 ~            ;	JP ENABLE_PAGE0
 323+ 5DB2 ~            ;.RET:
 324+ 5DB2 ~            ;	EI
 325+ 5DB2 ~            ;	INC IX
 326+ 5DB2 ~            ;	INC IX
 327+ 5DB2 ~            ;	CALL SHIFT_MERGE_CHARACTER
 328+ 5DB2 ~            ;
 329+ 5DB2 ~            ;   POP DE
 330+ 5DB2 ~            ;    POP BC
 331+ 5DB2 ~            ;    JP RESTORE_PAGE_INFO
 332+ 5DB2 ~            ; *******************************************************************************************************
 333+ 5DB2 ~
 334+ 5DB2 ~            ; *******************************************************************************************************
 335+ 5DB2 ~            ; function to handle CALL BLIT basic extension in DEFUSR form
 336+ 5DB2 ~            ; input IX=pointer to data described in SHIFT_MERGE_CHARACTER but starts from +2
 337+ 5DB2 ~            ; +02 x
 338+ 5DB2 ~            ; +04 y
 339+ 5DB2 ~            ; +06 char_data_pointer
 340+ 5DB2 ~            ; +08 mask_data_pointer
 341+ 5DB2 ~            ; +10 width
 342+ 5DB2 ~            ; +12 height
 343+ 5DB2 ~            ; +14 background_pointer
 344+ 5DB2 ~            ; +16 background_width
 345+ 5DB2 ~            ; BLIT ( INT x,
 346+ 5DB2 ~            ;		 INT y,
 347+ 5DB2 ~            ;		 INT char_data_pointer,
 348+ 5DB2 ~            ;		 INT mask_data_pointer,
 349+ 5DB2 ~            ;		 INT width (in characters),
 350+ 5DB2 ~            ;		 INT height (in characters),
 351+ 5DB2 ~            ;		 INT background_pointer (top left),
 352+ 5DB2 ~            ;		 INT background_width (in characters),
 353+ 5DB2 ~            BLIT_DEFUSR:
 354+ 5DB2 ~            	LD E,(IX+2)
 355+ 5DB2 ~            	LD D,(IX+3)
 356+ 5DB2 ~            	LD A,E
 357+ 5DB2 ~            	AND 7
 358+ 5DB2 ~            	LD (TMP_STRUCT+0),A
 359+ 5DB2 ~            	CALL DEdiv8
 360+ 5DB2 ~            	LD (BLIT_TMP+0),A
 361+ 5DB2 ~            	LD E,(IX+4)
 362+ 5DB2 ~            	LD D,(IX+5)
 363+ 5DB2 ~            	LD A,E
 364+ 5DB2 ~            	AND 7
 365+ 5DB2 ~            	LD (TMP_STRUCT+2),A
 366+ 5DB2 ~            	CALL DEdiv8
 367+ 5DB2 ~            	LD (BLIT_TMP+1),A
 368+ 5DB2 ~            	LD L,(IX+6)
 369+ 5DB2 ~            	LD H,(IX+7)
 370+ 5DB2 ~            	LD (TMP_STRUCT+10),HL
 371+ 5DB2 ~            	LD L,(IX+8)
 372+ 5DB2 ~            	LD H,(IX+9)
 373+ 5DB2 ~            	LD (TMP_STRUCT+8),HL
 374+ 5DB2 ~            	LD A,(IX+10)
 375+ 5DB2 ~            	LD (TMP_STRUCT+14),A
 376+ 5DB2 ~            	LD A,(IX+12)
 377+ 5DB2 ~            	LD (TMP_STRUCT+16),A
 378+ 5DB2 ~            	LD L,(IX+14)
 379+ 5DB2 ~            	LD H,(IX+15)
 380+ 5DB2 ~            	LD (TMP_STRUCT+4),HL
 381+ 5DB2 ~            	;LD A,(IX+16)
 382+ 5DB2 ~            	;LD (BLIT_TMP+2),A
 383+ 5DB2 ~
 384+ 5DB2 ~            	; calculate char&mask add to value
 385+ 5DB2 ~            	LD H,0
 386+ 5DB2 ~            	LD A,(TMP_STRUCT+14)
 387+ 5DB2 ~            	LD L,A
 388+ 5DB2 ~            	CALL HLx8
 389+ 5DB2 ~            	LD (TMP_STRUCT+12),HL
 390+ 5DB2 ~            	; calculate background add to value
 391+ 5DB2 ~            	LD H,0
 392+ 5DB2 ~            	LD L,(IX+16)
 393+ 5DB2 ~            	CALL HLx8
 394+ 5DB2 ~            	LD (TMP_STRUCT+6),HL
 395+ 5DB2 ~            	; calculate pointer to background location
 396+ 5DB2 ~            	LD HL,0
 397+ 5DB2 ~            	LD A,(BLIT_TMP+1)
 398+ 5DB2 ~            	OR A
 399+ 5DB2 ~            	JR Z, .L1
 400+ 5DB2 ~            	LD B,A
 401+ 5DB2 ~            	LD DE,(TMP_STRUCT+6)
 402+ 5DB2 ~            .L0:
 403+ 5DB2 ~            	ADD HL, DE
 404+ 5DB2 ~            	DJNZ .L0
 405+ 5DB2 ~            .L1:
 406+ 5DB2 ~            	EX DE,HL
 407+ 5DB2 ~            	LD H,0
 408+ 5DB2 ~            	LD A,(BLIT_TMP+0)
 409+ 5DB2 ~            	LD L,A
 410+ 5DB2 ~            	CALL HLx8
 411+ 5DB2 ~            	ADD HL,DE
 412+ 5DB2 ~            	LD DE,(TMP_STRUCT+4)
 413+ 5DB2 ~            	ADD HL,DE
 414+ 5DB2 ~            	LD (TMP_STRUCT+4),HL
 415+ 5DB2 ~
 416+ 5DB2 ~            	LD IY, .RET
 417+ 5DB2 ~            	JP ENABLE_PAGE0
 418+ 5DB2 ~            .RET:
 419+ 5DB2 ~            	EI
 420+ 5DB2 ~            	LD IX, TMP_STRUCT
 421+ 5DB2 ~            	CALL SHIFT_MERGE_CHARACTER
 422+ 5DB2 ~                JP COMMON_EXIT_CODE
 423+ 5DB2 ~            ; *******************************************************************************************************
 424+ 5DB2               ENDIF
 425+ 5DB2
 426+ 5DB2               IF (1 == 1)
 427+ 5DB2              ; *******************************************************************************************************
 428+ 5DB2              ; function to handle CALL BLIT basic extension
 429+ 5DB2              ; rotates 1-bit character drawing horizontally with mask and character data and
 430+ 5DB2              ; fuses with background data and applies vertical shift too
 431+ 5DB2              ; in form without pointers
 432+ 5DB2              ; BLIT ( INT x,
 433+ 5DB2              ;		 INT y,
 434+ 5DB2              ;		 INT char_data_pointer,
 435+ 5DB2              ;		 INT mask_data_pointer,
 436+ 5DB2              ;		 INT width (in characters),
 437+ 5DB2              ;		 INT height (in characters),
 438+ 5DB2              ;		 INT background_pointer (top left),
 439+ 5DB2              ;		 INT background_width (in characters),
 440+ 5DB2              ; will put ram in page 0 also, page 1 is already there
 441+ 5DB2              BLIT:
 442+ 5DB2              	; opening (
 443+ 5DB2 CD 91 67     	CALL CHKCHAR
 444+ 5DB5 28           	DB '('
 445+ 5DB6              	; get x coordinate
 446+ 5DB6 DD 21 2F 54  	LD IX, FRMQNT
 447+ 5DBA CD 59 01     	CALL CALBAS
 448+ 5DBD 7B           	LD A, E
 449+ 5DBE E6 07        	AND 7
 450+ 5DC0 32 5A 64     	LD (TMP_STRUCT+0), A
 451+ 5DC3 CD A4 5D     	CALL DEdiv8
 452+ 5DC6 32 56 64     	LD (BLIT_TMP+0),A
 453+ 5DC9              	; comma
 454+ 5DC9 CD 91 67     	CALL CHKCHAR
 455+ 5DCC 2C           	DB ','
 456+ 5DCD              	; get y coordinate
 457+ 5DCD DD 21 2F 54  	LD IX, FRMQNT
 458+ 5DD1 CD 59 01     	CALL CALBAS
 459+ 5DD4 7B           	LD A, E
 460+ 5DD5 E6 07        	AND 7
 461+ 5DD7 32 5C 64     	LD (TMP_STRUCT+2), A
 462+ 5DDA CD A4 5D     	CALL DEdiv8
 463+ 5DDD 32 57 64     	LD (BLIT_TMP+1),A
 464+ 5DE0              	; comma
 465+ 5DE0 CD 91 67     	CALL CHKCHAR
 466+ 5DE3 2C           	DB ','
 467+ 5DE4              	; get char data pointer
 468+ 5DE4 DD 21 2F 54  	LD IX, FRMQNT
 469+ 5DE8 CD 59 01     	CALL CALBAS
 470+ 5DEB ED 53 64 64  	LD (TMP_STRUCT+10), DE
 471+ 5DEF              	; comma
 472+ 5DEF CD 91 67     	CALL CHKCHAR
 473+ 5DF2 2C           	DB ','
 474+ 5DF3              	; get mask data pointer
 475+ 5DF3 DD 21 2F 54  	LD IX, FRMQNT
 476+ 5DF7 CD 59 01     	CALL CALBAS
 477+ 5DFA ED 53 62 64  	LD (TMP_STRUCT+8), DE
 478+ 5DFE              	; comma
 479+ 5DFE CD 91 67     	CALL CHKCHAR
 480+ 5E01 2C           	DB ','
 481+ 5E02              	; get width
 482+ 5E02 DD 21 2F 54  	LD IX, FRMQNT
 483+ 5E06 CD 59 01     	CALL CALBAS
 484+ 5E09 7B           	LD A, E
 485+ 5E0A 32 68 64     	LD (TMP_STRUCT+14), A
 486+ 5E0D              	; comma
 487+ 5E0D CD 91 67     	CALL CHKCHAR
 488+ 5E10 2C           	DB ','
 489+ 5E11              	; get height
 490+ 5E11 DD 21 2F 54  	LD IX, FRMQNT
 491+ 5E15 CD 59 01     	CALL CALBAS
 492+ 5E18 7B           	LD A, E
 493+ 5E19 32 6A 64     	LD (TMP_STRUCT+16), A
 494+ 5E1C              	; comma
 495+ 5E1C CD 91 67     	CALL CHKCHAR
 496+ 5E1F 2C           	DB ','
 497+ 5E20              	; get background pointer
 498+ 5E20 DD 21 2F 54  	LD IX, FRMQNT
 499+ 5E24 CD 59 01     	CALL CALBAS
 500+ 5E27 ED 53 5E 64  	LD (TMP_STRUCT+4), DE
 501+ 5E2B              	; comma
 502+ 5E2B CD 91 67     	CALL CHKCHAR
 503+ 5E2E 2C           	DB ','
 504+ 5E2F              	; get background width
 505+ 5E2F DD 21 2F 54  	LD IX, FRMQNT
 506+ 5E33 CD 59 01     	CALL CALBAS
 507+ 5E36 7B           	LD A, E
 508+ 5E37 32 58 64     	LD (BLIT_TMP+2), A
 509+ 5E3A              	; ending )
 510+ 5E3A CD 91 67     	CALL CHKCHAR
 511+ 5E3D 29           	DB ')'
 512+ 5E3E
 513+ 5E3E E5           	PUSH HL ; save position in BASIC buffer
 514+ 5E3F
 515+ 5E3F              	; calculate char&mask add to value
 516+ 5E3F 26 00        	LD H, 0
 517+ 5E41 3A 68 64     	LD A, (TMP_STRUCT+14)
 518+ 5E44 6F           	LD L, A
 519+ 5E45 CD 7E 66     	CALL HLx8
 520+ 5E48 22 66 64     	LD (TMP_STRUCT+12), HL
 521+ 5E4B              	; calculate background add to value
 522+ 5E4B 26 00        	LD H, 0
 523+ 5E4D 3A 58 64     	LD A, (BLIT_TMP+2)
 524+ 5E50 6F           	LD L, A
 525+ 5E51 CD 7E 66     	CALL HLx8
 526+ 5E54 22 60 64     	LD (TMP_STRUCT+6), HL
 527+ 5E57              	; calculate pointer to background location
 528+ 5E57 21 00 00     	LD HL, 0
 529+ 5E5A 3A 57 64     	LD A,(BLIT_TMP+1)
 530+ 5E5D B7           	OR A
 531+ 5E5E 28 08        	JR Z, .L1
 532+ 5E60 47           	LD B,A
 533+ 5E61 ED 5B 60 64  	LD DE,(TMP_STRUCT+6)
 534+ 5E65              .L0:
 535+ 5E65 19           	ADD HL, DE
 536+ 5E66 10 FD        	DJNZ .L0
 537+ 5E68              .L1:
 538+ 5E68 EB           	EX DE,HL
 539+ 5E69 26 00        	LD H,0
 540+ 5E6B 3A 56 64     	LD A,(BLIT_TMP+0)
 541+ 5E6E 6F           	LD L,A
 542+ 5E6F CD 7E 66     	CALL HLx8
 543+ 5E72 19           	ADD HL,DE
 544+ 5E73 ED 5B 5E 64  	LD DE,(TMP_STRUCT+4)
 545+ 5E77 19           	ADD HL,DE
 546+ 5E78 22 5E 64     	LD (TMP_STRUCT+4),HL
 547+ 5E7B
 548+ 5E7B FD 21 82 5E  	LD IY, .RET
 549+ 5E7F C3 42 67     	JP ENABLE_PAGE0
 550+ 5E82              .RET:
 551+ 5E82 FB           	EI
 552+ 5E83 DD 21 5A 64  	LD IX, TMP_STRUCT
 553+ 5E87 CD 10 5D     	CALL SHIFT_MERGE_CHARACTER
 554+ 5E8A
 555+ 5E8A D1               POP DE
 556+ 5E8B C1               POP BC
 557+ 5E8C CD B9 66         CALL RESTORE_PAGE_INFO
 558+ 5E8F AF           	XOR A
 559+ 5E90 E1           	POP HL
 560+ 5E91 C9           	RET
 561+ 5E92              ; *******************************************************************************************************
 562+ 5E92               ENDIF
# file closed: asm\BLIT.asm
 164  5E92               ENDIF
 165  5E92
 166  5E92               IF (TILE_CMDS == 1)
 167  5E92               INCLUDE "TILE.asm"
# file opened: asm\TILE.asm
   1+ 5E92              ; *******************************************************************************************************
   2+ 5E92              ; generic function to implement tiling
   3+ 5E92              ; should be modified to call appropriate function for memory or vram
   4+ 5E92              ; input IX=pointer to following structure
   5+ 5E92              ; +00 tile_data_ptr
   6+ 5E92              ; +02 tile_rows
   7+ 5E92              ; +04 tile_columns
   8+ 5E92              ; +06 destination_address
   9+ 5E92              ; +08 dest_to_next_row_add_to_value
  10+ 5E92              ; +10 num_horizontal_tiles
  11+ 5E92              ; +12 num_vertical_tiles
  12+ 5E92              ; modifies AF, BC, DE, HL
  13+ 5E92              TILE:
  14+ 5E92 DD 6E 06     	LD L, (IX+6)
  15+ 5E95 DD 66 07     	LD H, (IX+7) ; destination address
  16+ 5E98 22 56 64     	LD (TILETMP1), HL
  17+ 5E9B DD 46 0C     	LD B, (IX+12) ; vertical tile number
  18+ 5E9E              .L1:
  19+ 5E9E C5           	PUSH BC
  20+ 5E9F DD 6E 00     		LD L, (IX+0)
  21+ 5EA2 DD 66 01     		LD H, (IX+1) ; tile address
  22+ 5EA5 22 58 64     		LD (TILETMP2), HL
  23+ 5EA8 DD 46 02     		LD B, (IX+2) ; tile rows
  24+ 5EAB              .L2:
  25+ 5EAB C5           		PUSH BC
  26+ 5EAC CD 00 00     .CALL1:		CALL 0
  27+ 5EAF DD 46 0A     			LD B, (IX+10) ; horizontal tile num
  28+ 5EB2              .L3:
  29+ 5EB2 C5           			PUSH BC
  30+ 5EB3 2A 58 64     				LD HL, (TILETMP2)
  31+ 5EB6 DD 46 04     				LD B, (IX+4) ; tile columns
  32+ 5EB9              .L4:
  33+ 5EB9 C5           				PUSH BC
  34+ 5EBA              .CALL2:
  35+ 5EBA CD 00 00     					CALL 0
  36+ 5EBD C1           				POP BC
  37+ 5EBE 10 F9        				DJNZ .L4
  38+ 5EC0 C1           			POP BC
  39+ 5EC1 10 EF        			DJNZ .L3
  40+ 5EC3 22 58 64     			LD (TILETMP2), HL
  41+ 5EC6 2A 56 64     			LD HL, (TILETMP1)
  42+ 5EC9 DD 5E 08     			LD E, (IX+8)
  43+ 5ECC DD 56 09     			LD D, (IX+9) ; add to value for dest next row
  44+ 5ECF 19           			ADD HL, DE
  45+ 5ED0 22 56 64     			LD (TILETMP1), HL
  46+ 5ED3 C1           		POP BC
  47+ 5ED4 10 D5        		DJNZ .L2
  48+ 5ED6 C1           	POP BC
  49+ 5ED7 10 C5        	DJNZ .L1
  50+ 5ED9 C9           	RET
  51+ 5EDA              ; *******************************************************************************************************
  52+ 5EDA
  53+ 5EDA               IF (0 == 1)
  54+ 5EDA ~            ; *******************************************************************************************************
  55+ 5EDA ~            ; same as TILERAM but for DEFUSR approach
  56+ 5EDA ~            ; input IX=pointer to input array, real data from +2
  57+ 5EDA ~            ; +02 = tile data pointer
  58+ 5EDA ~            ; +04 = tile columns
  59+ 5EDA ~            ; +06 = tile rows
  60+ 5EDA ~            ; +08 = destination pointer
  61+ 5EDA ~            ; +10 = destination columns
  62+ 5EDA ~            ; +12 = destination rows
  63+ 5EDA ~            ; +14 = destination begin column
  64+ 5EDA ~            ; +16 = destination begin row
  65+ 5EDA ~            ; +18 = number of tiles horizontally
  66+ 5EDA ~            ; +20 = number of tiles vertically
  67+ 5EDA ~            ; *******************************************************************************************************
  68+ 5EDA ~            TILERAM_DEFUSR:
  69+ 5EDA ~            	; tile data pointer
  70+ 5EDA ~            	LD L,(IX+2)
  71+ 5EDA ~            	LD H,(IX+3)
  72+ 5EDA ~            	LD (TMP_STRUCT+0),HL
  73+ 5EDA ~            	; tile columns
  74+ 5EDA ~            	LD L,(IX+4)
  75+ 5EDA ~            	LD H,(IX+5)
  76+ 5EDA ~            	LD (TMP_STRUCT+4),HL
  77+ 5EDA ~            	; tile rows
  78+ 5EDA ~            	LD L,(IX+6)
  79+ 5EDA ~            	LD H,(IX+7)
  80+ 5EDA ~            	LD (TMP_STRUCT+2),HL
  81+ 5EDA ~            	; destintion pointer
  82+ 5EDA ~            	LD L,(IX+8)
  83+ 5EDA ~            	LD H,(IX+9)
  84+ 5EDA ~            	LD (TMP_STRUCT+6),HL
  85+ 5EDA ~            	; destination columns
  86+ 5EDA ~            	LD A,(IX+10)
  87+ 5EDA ~            	LD (BLIT_TMP+0),A
  88+ 5EDA ~            	; destination rows
  89+ 5EDA ~            	LD A,(IX+12)
  90+ 5EDA ~            	LD (BLIT_TMP+1),A
  91+ 5EDA ~            	; destination begin column
  92+ 5EDA ~            	LD A,(IX+14)
  93+ 5EDA ~            	LD (BLIT_TMP+2),A
  94+ 5EDA ~            	; destination begin row
  95+ 5EDA ~            	LD A,(IX+16)
  96+ 5EDA ~            	LD (BLIT_TMP+3),A
  97+ 5EDA ~            	; number of tiles horizontally
  98+ 5EDA ~            	LD L,(IX+18)
  99+ 5EDA ~            	LD H,(IX+19)
 100+ 5EDA ~            	LD (TMP_STRUCT+10),HL
 101+ 5EDA ~            	; number of tiles vertically
 102+ 5EDA ~            	LD L,(IX+20)
 103+ 5EDA ~            	LD H,(IX+21)
 104+ 5EDA ~            	LD (TMP_STRUCT+12),HL
 105+ 5EDA ~             IF (BASIC_EXTENSION == 1) ; otherwise we just continue with code below
 106+ 5EDA ~            	JP TILERAM.COMMON
 107+ 5EDA ~             ENDIF
 108+ 5EDA               ENDIF
 109+ 5EDA
 110+ 5EDA              ; *******************************************************************************************************
 111+ 5EDA              ; function to handle CALL TILERAM basic extension
 112+ 5EDA              ; fills memory with tiles
 113+ 5EDA              ; TILERAM ( INT tile_data_pointer,
 114+ 5EDA              ;			INT tile_columns,
 115+ 5EDA              ;			INT tile_rows,
 116+ 5EDA              ;			INT destination_pointer,
 117+ 5EDA              ;			INT destination_columns,
 118+ 5EDA              ;			INT destination_rows,
 119+ 5EDA              ;			INT destination_begin_column,
 120+ 5EDA              ;			INT destination_begin_row,
 121+ 5EDA              ;			INT number_of_tiles_horizontally,
 122+ 5EDA              ;			INT	number_of_tiles_vertically )
 123+ 5EDA              ; will put ram in page 0 also, page 1 is already there
 124+ 5EDA              TILERAM:
 125+ 5EDA               IF (1 == 1)
 126+ 5EDA              	; opening (
 127+ 5EDA CD 91 67     	CALL CHKCHAR
 128+ 5EDD 28           	DB '('
 129+ 5EDE              	; get tile data pointer coordinate
 130+ 5EDE DD 21 2F 54  	LD IX, FRMQNT
 131+ 5EE2 CD 59 01     	CALL CALBAS
 132+ 5EE5 ED 53 5A 64  	LD (TMP_STRUCT+0), DE
 133+ 5EE9              	; comma
 134+ 5EE9 CD 91 67     	CALL CHKCHAR
 135+ 5EEC 2C           	DB ','
 136+ 5EED              	; get tile columns
 137+ 5EED DD 21 2F 54  	LD IX, FRMQNT
 138+ 5EF1 CD 59 01     	CALL CALBAS
 139+ 5EF4 ED 53 5E 64  	LD (TMP_STRUCT+4), DE
 140+ 5EF8              	; comma
 141+ 5EF8 CD 91 67     	CALL CHKCHAR
 142+ 5EFB 2C           	DB ','
 143+ 5EFC              	; get tile columns
 144+ 5EFC DD 21 2F 54  	LD IX, FRMQNT
 145+ 5F00 CD 59 01     	CALL CALBAS
 146+ 5F03 ED 53 5C 64  	LD (TMP_STRUCT+2), DE
 147+ 5F07              	; comma
 148+ 5F07 CD 91 67     	CALL CHKCHAR
 149+ 5F0A 2C           	DB ','
 150+ 5F0B              	; get destintion pointer
 151+ 5F0B DD 21 2F 54  	LD IX, FRMQNT
 152+ 5F0F CD 59 01     	CALL CALBAS
 153+ 5F12 ED 53 60 64  	LD (TMP_STRUCT+6), DE
 154+ 5F16              	; comma
 155+ 5F16 CD 91 67     	CALL CHKCHAR
 156+ 5F19 2C           	DB ','
 157+ 5F1A              	; get destination columns
 158+ 5F1A DD 21 2F 54  	LD IX, FRMQNT
 159+ 5F1E CD 59 01     	CALL CALBAS
 160+ 5F21 7B           	LD A, E
 161+ 5F22 32 56 64     	LD (BLIT_TMP+0), A
 162+ 5F25              	; comma
 163+ 5F25 CD 91 67     	CALL CHKCHAR
 164+ 5F28 2C           	DB ','
 165+ 5F29              	; get destination rows
 166+ 5F29 DD 21 2F 54  	LD IX, FRMQNT
 167+ 5F2D CD 59 01     	CALL CALBAS
 168+ 5F30 7B           	LD A, E
 169+ 5F31 32 57 64     	LD (BLIT_TMP+1), A
 170+ 5F34              	; comma
 171+ 5F34 CD 91 67     	CALL CHKCHAR
 172+ 5F37 2C           	DB ','
 173+ 5F38              	; get destination begin column
 174+ 5F38 DD 21 2F 54  	LD IX, FRMQNT
 175+ 5F3C CD 59 01     	CALL CALBAS
 176+ 5F3F 7B           	LD A, E
 177+ 5F40 32 58 64     	LD (BLIT_TMP+2), A
 178+ 5F43              	; comma
 179+ 5F43 CD 91 67     	CALL CHKCHAR
 180+ 5F46 2C           	DB ','
 181+ 5F47              	; get destination begin row
 182+ 5F47 DD 21 2F 54  	LD IX, FRMQNT
 183+ 5F4B CD 59 01     	CALL CALBAS
 184+ 5F4E 7B           	LD A, E
 185+ 5F4F 32 59 64     	LD (BLIT_TMP+3), A
 186+ 5F52              	; comma
 187+ 5F52 CD 91 67     	CALL CHKCHAR
 188+ 5F55 2C           	DB ','
 189+ 5F56              	; get number of tiles horizontally
 190+ 5F56 DD 21 2F 54  	LD IX, FRMQNT
 191+ 5F5A CD 59 01     	CALL CALBAS
 192+ 5F5D ED 53 64 64  	LD (TMP_STRUCT+10), DE
 193+ 5F61              	; comma
 194+ 5F61 CD 91 67     	CALL CHKCHAR
 195+ 5F64 2C           	DB ','
 196+ 5F65              	; get number of tiles vertically
 197+ 5F65 DD 21 2F 54  	LD IX, FRMQNT
 198+ 5F69 CD 59 01     	CALL CALBAS
 199+ 5F6C ED 53 66 64  	LD (TMP_STRUCT+12), DE
 200+ 5F70              	; ending )
 201+ 5F70 CD 91 67     	CALL CHKCHAR
 202+ 5F73 29           	DB ')'
 203+ 5F74               ENDIF
 204+ 5F74              .COMMON:
 205+ 5F74 E5           	PUSH HL ; save position in BASIC buffer
 206+ 5F75
 207+ 5F75              	; calculate destination add to value
 208+ 5F75 26 00        	LD H, 0
 209+ 5F77 3A 56 64     	LD A, (BLIT_TMP+0)
 210+ 5F7A 6F           	LD L, A
 211+ 5F7B CD 7E 66     	CALL HLx8
 212+ 5F7E 22 62 64     	LD (TMP_STRUCT+8), HL
 213+ 5F81              	; calculate pointer to background location
 214+ 5F81 21 00 00     	LD HL, 0
 215+ 5F84 3A 59 64     	LD A,(BLIT_TMP+3)
 216+ 5F87 B7           	OR A
 217+ 5F88 28 08        	JR Z, .L1
 218+ 5F8A 47           	LD B,A
 219+ 5F8B ED 5B 62 64  	LD DE,(TMP_STRUCT+8)
 220+ 5F8F              .L0:
 221+ 5F8F 19           	ADD HL, DE
 222+ 5F90 10 FD        	DJNZ .L0
 223+ 5F92              .L1:
 224+ 5F92 EB           	EX DE,HL
 225+ 5F93 26 00        	LD H,0
 226+ 5F95 3A 58 64     	LD A,(BLIT_TMP+2)
 227+ 5F98 6F           	LD L,A
 228+ 5F99 CD 7E 66     	CALL HLx8
 229+ 5F9C 19           	ADD HL,DE
 230+ 5F9D ED 5B 60 64  	LD DE,(TMP_STRUCT+6)
 231+ 5FA1 19           	ADD HL,DE
 232+ 5FA2 22 60 64     	LD (TMP_STRUCT+6),HL
 233+ 5FA5 FD 21 AC 5F  	LD IY, .RET
 234+ 5FA9 C3 42 67     	JP ENABLE_PAGE0
 235+ 5FAC              .RET:
 236+ 5FAC FB           	EI
 237+ 5FAD              	; set RAM functions to call
 238+ 5FAD 21 C3 5F     	LD HL, .TILECOPY
 239+ 5FB0 22 BB 5E     	LD (TILE.CALL2+1), HL
 240+ 5FB3 21 D4 5F     	LD HL, .SETDESTROW
 241+ 5FB6 22 AD 5E     	LD (TILE.CALL1+1), HL
 242+ 5FB9 DD 21 5A 64  	LD IX,TMP_STRUCT
 243+ 5FBD CD 92 5E     	CALL TILE
 244+ 5FC0 C3 81 60     	JP TILEVRM.EXIT
 245+ 5FC3              .TILECOPY:
 246+ 5FC3 ED A0       > LDI
 246+ 5FC5 ED A0       > LDI
 246+ 5FC7 ED A0       > LDI
 246+ 5FC9 ED A0       > LDI
 246+ 5FCB ED A0       > LDI
 246+ 5FCD ED A0       > LDI
 246+ 5FCF ED A0       > LDI
 246+ 5FD1 ED A0       > LDI
 247+ 5FD3 C9           	RET
 248+ 5FD4              .SETDESTROW:
 249+ 5FD4 ED 5B 56 64  	LD DE, (TILETMP1)
 250+ 5FD8 C9           	RET
 251+ 5FD9              ; *******************************************************************************************************
 252+ 5FD9
 253+ 5FD9               IF (0 == 1)
 254+ 5FD9 ~            ; *******************************************************************************************************
 255+ 5FD9 ~            ; same as TILEVRM but for DEFUSR approach
 256+ 5FD9 ~            ; input IX=pointer to input array, real data from +2
 257+ 5FD9 ~            ; +02 = tile data pointer
 258+ 5FD9 ~            ; +04 = tile columns
 259+ 5FD9 ~            ; +06 = tile rows
 260+ 5FD9 ~            ; +08 = destination begin column
 261+ 5FD9 ~            ; +10 = destination begin row
 262+ 5FD9 ~            ; +12 = number of tiles horizontally
 263+ 5FD9 ~            ; +14 = number of tiles vertically
 264+ 5FD9 ~            ; *******************************************************************************************************
 265+ 5FD9 ~            TILEVRM_DEFUSR:
 266+ 5FD9 ~            	; tile data pointer
 267+ 5FD9 ~            	LD L,(IX+2)
 268+ 5FD9 ~            	LD H,(IX+3)
 269+ 5FD9 ~            	LD (TMP_STRUCT+0),HL
 270+ 5FD9 ~            	; tile columns
 271+ 5FD9 ~            	LD L,(IX+4)
 272+ 5FD9 ~            	LD H,(IX+5)
 273+ 5FD9 ~            	LD (TMP_STRUCT+4),HL
 274+ 5FD9 ~            	; tile rows
 275+ 5FD9 ~            	LD L,(IX+6)
 276+ 5FD9 ~            	LD H,(IX+7)
 277+ 5FD9 ~            	LD (TMP_STRUCT+2),HL
 278+ 5FD9 ~            	; destination begin column
 279+ 5FD9 ~            	LD A,(IX+8)
 280+ 5FD9 ~            	LD (BLIT_TMP+2),A
 281+ 5FD9 ~            	; destination begin row
 282+ 5FD9 ~            	LD A,(IX+10)
 283+ 5FD9 ~            	LD (BLIT_TMP+3),A
 284+ 5FD9 ~            	; number of tiles horizontally
 285+ 5FD9 ~            	LD L,(IX+12)
 286+ 5FD9 ~            	LD H,(IX+13)
 287+ 5FD9 ~            	LD (TMP_STRUCT+10),HL
 288+ 5FD9 ~            	; number of tiles vertically
 289+ 5FD9 ~            	LD L,(IX+14)
 290+ 5FD9 ~            	LD H,(IX+15)
 291+ 5FD9 ~            	LD (TMP_STRUCT+12),HL
 292+ 5FD9 ~             IF (BASIC_EXTENSION == 1) ; otherwise we just continue with code below
 293+ 5FD9 ~            	JP TILEVRM.COMMON
 294+ 5FD9 ~             ENDIF
 295+ 5FD9               ENDIF
 296+ 5FD9
 297+ 5FD9              ; *******************************************************************************************************
 298+ 5FD9              ; function to handle CALL TILEVRM basic extension
 299+ 5FD9              ; fills vram with tiles
 300+ 5FD9              ; TILEVRM ( INT tile_data_pointer,
 301+ 5FD9              ;			INT tile_columns,
 302+ 5FD9              ;			INT tile_rows,
 303+ 5FD9              ;			INT destination_begin_column,
 304+ 5FD9              ;			INT destination_begin_row,
 305+ 5FD9              ;			INT number_of_tiles_horizontally,
 306+ 5FD9              ;			INT	number_of_tiles_vertically )
 307+ 5FD9              ; will put ram in page 0 also, page 1 is already there
 308+ 5FD9              ; for destination uses address of SCREEN 2 pattern buffer and 32x24 size
 309+ 5FD9              TILEVRM:
 310+ 5FD9               IF (1 == 1)
 311+ 5FD9              	; opening (
 312+ 5FD9 CD 91 67     	CALL CHKCHAR
 313+ 5FDC 28           	DB '('
 314+ 5FDD              	; get tile data pointer coordinate
 315+ 5FDD DD 21 2F 54  	LD IX, FRMQNT
 316+ 5FE1 CD 59 01     	CALL CALBAS
 317+ 5FE4 ED 53 5A 64  	LD (TMP_STRUCT+0), DE
 318+ 5FE8              	; comma
 319+ 5FE8 CD 91 67     	CALL CHKCHAR
 320+ 5FEB 2C           	DB ','
 321+ 5FEC              	; get tile columns
 322+ 5FEC DD 21 2F 54  	LD IX, FRMQNT
 323+ 5FF0 CD 59 01     	CALL CALBAS
 324+ 5FF3 ED 53 5E 64  	LD (TMP_STRUCT+4), DE
 325+ 5FF7              	; comma
 326+ 5FF7 CD 91 67     	CALL CHKCHAR
 327+ 5FFA 2C           	DB ','
 328+ 5FFB              	; get tile columns
 329+ 5FFB DD 21 2F 54  	LD IX, FRMQNT
 330+ 5FFF CD 59 01     	CALL CALBAS
 331+ 6002 ED 53 5C 64  	LD (TMP_STRUCT+2), DE
 332+ 6006              	; comma
 333+ 6006 CD 91 67     	CALL CHKCHAR
 334+ 6009 2C           	DB ','
 335+ 600A              	; get destination begin column
 336+ 600A DD 21 2F 54  	LD IX, FRMQNT
 337+ 600E CD 59 01     	CALL CALBAS
 338+ 6011 7B           	LD A, E
 339+ 6012 32 58 64     	LD (BLIT_TMP+2), A
 340+ 6015              	; comma
 341+ 6015 CD 91 67     	CALL CHKCHAR
 342+ 6018 2C           	DB ','
 343+ 6019              	; get destination begin row
 344+ 6019 DD 21 2F 54  	LD IX, FRMQNT
 345+ 601D CD 59 01     	CALL CALBAS
 346+ 6020 7B           	LD A, E
 347+ 6021 32 59 64     	LD (BLIT_TMP+3), A
 348+ 6024              	; comma
 349+ 6024 CD 91 67     	CALL CHKCHAR
 350+ 6027 2C           	DB ','
 351+ 6028              	; get number of tiles horizontally
 352+ 6028 DD 21 2F 54  	LD IX, FRMQNT
 353+ 602C CD 59 01     	CALL CALBAS
 354+ 602F ED 53 64 64  	LD (TMP_STRUCT+10), DE
 355+ 6033              	; comma
 356+ 6033 CD 91 67     	CALL CHKCHAR
 357+ 6036 2C           	DB ','
 358+ 6037              	; get number of tiles vertically
 359+ 6037 DD 21 2F 54  	LD IX, FRMQNT
 360+ 603B CD 59 01     	CALL CALBAS
 361+ 603E ED 53 66 64  	LD (TMP_STRUCT+12), DE
 362+ 6042              	; ending )
 363+ 6042 CD 91 67     	CALL CHKCHAR
 364+ 6045 29           	DB ')'
 365+ 6046               ENDIF
 366+ 6046
 367+ 6046              .COMMON:
 368+ 6046 E5           	PUSH HL ; save position in BASIC buffer
 369+ 6047
 370+ 6047              	; calculate destination add to value
 371+ 6047 21 00 01     	LD HL, 256
 372+ 604A 22 62 64     	LD (TMP_STRUCT+8), HL
 373+ 604D              	; calculate pointer to background location
 374+ 604D 3A 59 64     	LD A,(BLIT_TMP+3)
 375+ 6050 67           	LD H,A
 376+ 6051 2E 00        	LD L,0
 377+ 6053 EB           	EX DE,HL
 378+ 6054 26 00        	LD H,0
 379+ 6056 3A 58 64     	LD A,(BLIT_TMP+2)
 380+ 6059 6F           	LD L,A
 381+ 605A CD 7E 66     	CALL HLx8
 382+ 605D 19           	ADD HL,DE
 383+ 605E ED 5B CB F3  	LD DE,(GRPCGP)
 384+ 6062 19           	ADD HL,DE
 385+ 6063 22 60 64     	LD (TMP_STRUCT+6),HL
 386+ 6066 FD 21 6D 60  	LD IY, .RET
 387+ 606A C3 42 67     	JP ENABLE_PAGE0
 388+ 606D              .RET:
 389+ 606D FB           	EI
 390+ 606E              	; set RAM functions to call
 391+ 606E 21 89 60     	LD HL, .TILECOPY
 392+ 6071 22 BB 5E     	LD (TILE.CALL2+1), HL
 393+ 6074 21 8F 60     	LD HL, .SETDESTROW
 394+ 6077 22 AD 5E     	LD (TILE.CALL1+1), HL
 395+ 607A DD 21 5A 64  	LD IX,TMP_STRUCT
 396+ 607E CD 92 5E     	CALL TILE
 397+ 6081              .EXIT:
 398+ 6081 D1               POP DE
 399+ 6082 C1               POP BC
 400+ 6083 CD B9 66         CALL RESTORE_PAGE_INFO
 401+ 6086 E1           	POP HL
 402+ 6087 AF           	XOR A ; success
 403+ 6088 C9           	RET
 404+ 6089              .TILECOPY:
 405+ 6089 01 98 08     	LD BC, #0898
 406+ 608C C3 76 66     	JP BBYTECOPY_NO_C
 407+ 608F              .SETDESTROW:
 408+ 608F 2A 56 64     	LD HL, (TILETMP1)
 409+ 6092 F3           	DI
 410+ 6093 CD 5F 66     	CALL SETWRT_LOCAL_WRITE
 411+ 6096 FB           	EI
 412+ 6097 C9           	RET
 413+ 6098              ; *******************************************************************************************************
 414+ 6098
# file closed: asm\TILE.asm
 168  6098               ENDIF
 169  6098
 170  6098               IF (COLL_CMD == 1)
 171  6098               INCLUDE "COLLISION.asm"
# file opened: asm\COLLISION.asm
   1+ 6098              ; generic collision checking routines
   2+ 6098              ; in BASIC we use rectangle structure array DIM R%(7,n) of the format
   3+ 6098              ; R%(0,n) is active flag, <>0 active / 0 skipped in checks
   4+ 6098              ; R%(1,n) is either upper left x coordinate or sprite id (0-31) depending on R(7,n)
   5+ 6098              ; R%(2,n) is either upper left y coordinate or unused depending on R(7,n)
   6+ 6098              ; R%(3,n) x offset where rectangle begins
   7+ 6098              ; R%(4,n) y offset where rectangle begins
   8+ 6098              ; R%(5,n) is width
   9+ 6098              ; R%(6,n) is height
  10+ 6098              ; R%(7,0) is type, 0=generic where R%(1,0) contains x coordinate
  11+ 6098              ;                  <>0 sprite where R%(1,0) contains sprite id
  12+ 6098              ; for type sprite, upper left coordinates are taken from sprite attribute array
  13+ 6098
  14+ 6098              ; ************************************************************************************************
  15+ 6098              ; quick test if HL<=DE<=HL+BC
  16+ 6098              ; input BC=width, DE=x, HL=min
  17+ 6098              ; if not true flag C set
  18+ 6098              ; modifies AF
  19+ 6098              GENERIC_INNER_CHECK:
  20+ 6098 E5               PUSH HL
  21+ 6099 D5               PUSH DE
  22+ 609A EB               EX DE,HL
  23+ 609B A7               AND A
  24+ 609C ED 52            SBC HL, DE
  25+ 609E FA AC 60         JP M, .GENERIC_INNER_CHECK_NOT
  26+ 60A1 A7               AND A
  27+ 60A2 ED 42            SBC HL, BC
  28+ 60A4 28 03            JR Z, .L2
  29+ 60A6 F2 AC 60         JP P, .GENERIC_INNER_CHECK_NOT
  30+ 60A9              .L2:
  31+ 60A9 A7               AND A
  32+ 60AA 18 01            JR .EXIT
  33+ 60AC              .GENERIC_INNER_CHECK_NOT:
  34+ 60AC 37               SCF
  35+ 60AD              .EXIT:
  36+ 60AD D1               POP DE
  37+ 60AE E1               POP HL
  38+ 60AF C9               RET
  39+ 60B0              ; ************************************************************************************************
  40+ 60B0
  41+ 60B0              ; ************************************************************************************************
  42+ 60B0              ; function to check if rectangles are overlapping
  43+ 60B0              ; input IX=IY=pointer to struct
  44+ 60B0              ;  +00 active flag
  45+ 60B0              ;  +02 x coordinate
  46+ 60B0              ;  +04 y coordinate
  47+ 60B0              ;  +06 x offset where rectangle begins
  48+ 60B0              ;  +08 y offset where rectangle begins
  49+ 60B0              ;  +10 width
  50+ 60B0              ;  +12 height
  51+ 60B0              ; where IY is used to read +2 and +4, and IX to read +6, +8, +10 and +12
  52+ 60B0              ; this is a hack to allow location being taken from sprite attributes table
  53+ 60B0              ; input TMP_STRUCT data
  54+ 60B0              ;  +00 x coordinate
  55+ 60B0              ;  +02 y coordinate
  56+ 60B0              ;  +04 width
  57+ 60B0              ;  +06 height
  58+ 60B0              ; returns CF=1 if not overlapping, CF=0 if overlapping
  59+ 60B0              RECTANGLE_OVERLAP_CHECK:
  60+ 60B0                  ; first check which rectangle is higher
  61+ 60B0 DD 6E 0C         LD L,(IX+12)
  62+ 60B3 DD 66 0D         LD H,(IX+13)
  63+ 60B6 ED 5B 60 64      LD DE,(TMP_STRUCT+6)
  64+ 60BA A7               AND A
  65+ 60BB ED 52            SBC HL,DE
  66+ 60BD FD 6E 04         LD L,(IY+4)
  67+ 60C0 FD 66 05         LD H,(IY+5)
  68+ 60C3 DD 5E 08         LD E,(IX+8)
  69+ 60C6 DD 56 09         LD D,(IX+9)
  70+ 60C9 FA E9 60         JP M,.L1
  71+ 60CC                  ; equally high or IX defined one higher
  72+ 60CC                  ; check upper boundary
  73+ 60CC 19               ADD HL,DE
  74+ 60CD ED 5B 5C 64      LD DE,(TMP_STRUCT+2)
  75+ 60D1 DD 4E 0C         LD C,(IX+12)
  76+ 60D4 DD 46 0D         LD B,(IX+13)
  77+ 60D7 CD 98 60         CALL GENERIC_INNER_CHECK
  78+ 60DA 30 29            JR NC,.INSIDE
  79+ 60DC                  ; check lower boundary
  80+ 60DC E5               PUSH HL
  81+ 60DD 2A 60 64         LD HL,(TMP_STRUCT+6)
  82+ 60E0 19               ADD HL,DE
  83+ 60E1 EB               EX DE,HL
  84+ 60E2 E1               POP HL
  85+ 60E3 CD 98 60         CALL GENERIC_INNER_CHECK
  86+ 60E6 30 1D            JR NC,.INSIDE
  87+ 60E8 C9               RET ; not overlapping
  88+ 60E9              .L1:
  89+ 60E9                  ; rectangle defined in TMP_STRUCT is higher
  90+ 60E9 19               ADD HL,DE
  91+ 60EA EB               EX DE,HL
  92+ 60EB 2A 5C 64         LD HL,(TMP_STRUCT+2)
  93+ 60EE ED 4B 60 64      LD BC,(TMP_STRUCT+6)
  94+ 60F2 CD 98 60         CALL GENERIC_INNER_CHECK
  95+ 60F5 30 0E            JR NC,.INSIDE
  96+ 60F7 E5               PUSH HL
  97+ 60F8 DD 6E 0C         LD L,(IX+12)
  98+ 60FB DD 66 0D         LD H,(IX+13)
  99+ 60FE 19               ADD HL,DE
 100+ 60FF EB               EX DE,HL
 101+ 6100 E1               POP HL
 102+ 6101 CD 98 60         CALL GENERIC_INNER_CHECK
 103+ 6104 D8               RET C
 104+ 6105              .INSIDE:
 105+ 6105                  ; check x coordinate
 106+ 6105                  ; first check which rectangle is wider
 107+ 6105 DD 6E 0A         LD L,(IX+10)
 108+ 6108 DD 66 0B         LD H,(IX+11)
 109+ 610B ED 5B 5E 64      LD DE,(TMP_STRUCT+4)
 110+ 610F A7               AND A
 111+ 6110 ED 52            SBC HL,DE
 112+ 6112 FD 6E 02         LD L,(IY+2)
 113+ 6115 FD 66 03         LD H,(IY+3)
 114+ 6118 DD 5E 06         LD E,(IX+6)
 115+ 611B DD 56 07         LD D,(IX+7)
 116+ 611E FA 3A 61         JP M,.L2
 117+ 6121                  ; equally wide or IX defined one wider
 118+ 6121                  ; check left boundary
 119+ 6121 19               ADD HL,DE
 120+ 6122 ED 5B 5A 64      LD DE,(TMP_STRUCT+0)
 121+ 6126 DD 4E 0A         LD C,(IX+10)
 122+ 6129 DD 46 0B         LD B,(IX+11)
 123+ 612C CD 98 60         CALL GENERIC_INNER_CHECK
 124+ 612F D0               RET NC ; overlap
 125+ 6130                  ; check right boundary
 126+ 6130 E5               PUSH HL
 127+ 6131 2A 5E 64         LD HL,(TMP_STRUCT+4)
 128+ 6134 19               ADD HL,DE
 129+ 6135 EB               EX DE,HL
 130+ 6136 E1               POP HL
 131+ 6137 C3 98 60         JP GENERIC_INNER_CHECK ; CF and result set by fn call
 132+ 613A              .L2:
 133+ 613A                  ; rectangle defined in TMP_STRUCT is higher
 134+ 613A 19               ADD HL,DE
 135+ 613B EB               EX DE,HL
 136+ 613C 2A 5A 64         LD HL,(TMP_STRUCT+0)
 137+ 613F ED 4B 5E 64      LD BC,(TMP_STRUCT+4)
 138+ 6143 CD 98 60         CALL GENERIC_INNER_CHECK
 139+ 6146 D0               RET NC ; overlap
 140+ 6147 E5               PUSH HL
 141+ 6148 DD 6E 0A         LD L,(IX+10)
 142+ 614B DD 66 0B         LD H,(IX+11)
 143+ 614E 19               ADD HL,DE
 144+ 614F EB               EX DE,HL
 145+ 6150 E1               POP HL
 146+ 6151 C3 98 60         JP GENERIC_INNER_CHECK
 147+ 6154              ; ************************************************************************************************
 148+ 6154
 149+ 6154              ; ************************************************************************************************
 150+ 6154              ; function tries to find rectangle overlap and returns an index if found
 151+ 6154              ; input TMP_STRUCT data
 152+ 6154              ;  +00 x coordinate
 153+ 6154              ;  +02 y coordinate
 154+ 6154              ;  +04 width
 155+ 6154              ;  +06 height
 156+ 6154              ;  +08 number of items in a list, described under RECTANGLE_OVERLAP_CHECK
 157+ 6154              ;  +09 pointer to first element of R%(7,n)
 158+ 6154              ;  +11 pointer to INT result variable
 159+ 6154              ; returns CF=1 if not overlapping
 160+ 6154              ; returns A=list index and CF=0 if overlapping
 161+ 6154              FIND_OVERLAP:
 162+ 6154 3A 62 64         LD A,(TMP_STRUCT+8)
 163+ 6157 47               LD B,A
 164+ 6158 DD 2A 63 64      LD IX,(TMP_STRUCT+9)
 165+ 615C              .L1:
 166+ 615C C5               PUSH BC
 167+ 615D                  ; check active flag
 168+ 615D DD 7E 00         LD A,(IX)
 169+ 6160 DD B6 01         OR (IX+1)
 170+ 6163 28 18            JR Z,.NEXT
 171+ 6165                  ; check type
 172+ 6165 DD 7E 0E         LD A,(IX+14)
 173+ 6168 DD B6 0F         OR (IX+15)
 174+ 616B 20 1A            JR NZ,.L2
 175+ 616D DD E5            PUSH IX
 176+ 616F FD E1            POP IY
 177+ 6171              .L3:
 178+ 6171 CD B0 60         CALL RECTANGLE_OVERLAP_CHECK
 179+ 6174 38 07            JR C,.NEXT
 180+ 6176                  ; found
 181+ 6176 C1               POP BC
 182+ 6177 3A 62 64         LD A,(TMP_STRUCT+8)
 183+ 617A 90               SUB B
 184+ 617B A7               AND A
 185+ 617C C9               RET
 186+ 617D              .NEXT:
 187+ 617D 11 10 00         LD DE,16
 188+ 6180 DD 19            ADD IX,DE
 189+ 6182 C1               POP BC
 190+ 6183 10 D7            DJNZ .L1
 191+ 6185 37               SCF
 192+ 6186 C9               RET
 193+ 6187              .L2:
 194+ 6187                  ; sprite, need to build a temporary data struct since x and y values are inversed
 195+ 6187                  ; at TMP_STRUCT+13
 196+ 6187 DD 7E 02         LD A,(IX+2) ; sprite ID
 197+ 618A CD 90 4D         CALL GETnthSPRATTR
 198+ 618D FD 21 65 64      LD IY,TMP_STRUCT+11
 199+ 6191 7E               LD A,(HL)
 200+ 6192 FD 77 04         LD (IY+4),A
 201+ 6195 23               INC HL
 202+ 6196 7E               LD A,(HL)
 203+ 6197 FD 77 05         LD (IY+5),A
 204+ 619A 23               INC HL
 205+ 619B 7E               LD A,(HL)
 206+ 619C FD 77 02         LD (IY+2),A
 207+ 619F 23               INC HL
 208+ 61A0 7E               LD A,(HL)
 209+ 61A1 FD 77 03         LD (IY+3),A
 210+ 61A4 18 CB            JR .L3
 211+ 61A6              ; ************************************************************************************************
 212+ 61A6
 213+ 61A6               IF (1 == 1)
 214+ 61A6              ; ************************************************************************************************
 215+ 61A6              ; function to handle CALL COLL basic extension
 216+ 61A6              ; checks for collision between player and other rectangles
 217+ 61A6              ; COLL ( INT result variable,
 218+ 61A6              ;	     INT player x value,
 219+ 61A6              ;	     INT player y value,
 220+ 61A6              ;	     INT player width,
 221+ 61A6              ;	     INT player height,
 222+ 61A6              ;	     INT number of items in a list,
 223+ 61A6              ;		 INT[6][n] rectangle struct )
 224+ 61A6              ; will fill result variable with index or -1 if no collision
 225+ 61A6              ; rectangle struct described under RECTANGLE_OVERLAP_CHECK
 226+ 61A6              COLL:
 227+ 61A6              	; opening (
 228+ 61A6 CD 91 67     	CALL CHKCHAR
 229+ 61A9 28           	DB '('
 230+ 61AA              	; get address of result variable
 231+ 61AA DD 21 A4 5E  	LD IX, PTRGET
 232+ 61AE CD 59 01     	CALL CALBAS
 233+ 61B1 ED 53 65 64  	LD (TMP_STRUCT+11),DE
 234+ 61B5              	; comma
 235+ 61B5 CD 91 67     	CALL CHKCHAR
 236+ 61B8 2C           	DB ','
 237+ 61B9              	; get x
 238+ 61B9 DD 21 2F 54  	LD IX, FRMQNT
 239+ 61BD CD 59 01     	CALL CALBAS
 240+ 61C0 ED 53 5A 64  	LD (TMP_STRUCT+0),DE
 241+ 61C4              	; comma
 242+ 61C4 CD 91 67     	CALL CHKCHAR
 243+ 61C7 2C           	DB ','
 244+ 61C8              	; get y
 245+ 61C8 DD 21 2F 54  	LD IX, FRMQNT
 246+ 61CC CD 59 01     	CALL CALBAS
 247+ 61CF ED 53 5C 64  	LD (TMP_STRUCT+2),DE
 248+ 61D3              	; comma
 249+ 61D3 CD 91 67     	CALL CHKCHAR
 250+ 61D6 2C           	DB ','
 251+ 61D7              	; get width
 252+ 61D7 DD 21 2F 54  	LD IX, FRMQNT
 253+ 61DB CD 59 01     	CALL CALBAS
 254+ 61DE ED 53 5E 64  	LD (TMP_STRUCT+4),DE
 255+ 61E2              	; comma
 256+ 61E2 CD 91 67     	CALL CHKCHAR
 257+ 61E5 2C           	DB ','
 258+ 61E6              	; get height
 259+ 61E6 DD 21 2F 54  	LD IX, FRMQNT
 260+ 61EA CD 59 01     	CALL CALBAS
 261+ 61ED ED 53 60 64  	LD (TMP_STRUCT+6),DE
 262+ 61F1              	; comma
 263+ 61F1 CD 91 67     	CALL CHKCHAR
 264+ 61F4 2C           	DB ','
 265+ 61F5              	; get number of items in a list
 266+ 61F5 DD 21 1C 52  	LD IX, GETBYT
 267+ 61F9 CD 59 01     	CALL CALBAS
 268+ 61FC 32 62 64     	LD (TMP_STRUCT+8),A
 269+ 61FF              	; comma
 270+ 61FF CD 91 67     	CALL CHKCHAR
 271+ 6202 2C           	DB ','
 272+ 6203              	; get address of rectangle structure array DIM R%(7,n)
 273+ 6203 3A 62 64     	LD A,(TMP_STRUCT+8)
 274+ 6206 5F               LD E,A
 275+ 6207 3E 02            LD A,2
 276+ 6209 47           	LD B,A
 277+ 620A 16 07        	LD D,7
 278+ 620C CD F6 67     	CALL GET_BASIC_ARRAY_DATA_POINTER
 279+ 620F ED 43 63 64  	LD (TMP_STRUCT+9),BC
 280+ 6213              	; ending )
 281+ 6213 CD 91 67     	CALL CHKCHAR
 282+ 6216 29           	DB ')'
 283+ 6217
 284+ 6217 E5               PUSH HL
 285+ 6218 CD 54 61         CALL FIND_OVERLAP
 286+ 621B 2A 65 64         LD HL,(TMP_STRUCT+11)
 287+ 621E 38 06            JR C,.NOTFOUND
 288+ 6220 77               LD (HL),A
 289+ 6221 23               INC HL
 290+ 6222 36 00            LD (HL),0
 291+ 6224 E1               POP HL
 292+ 6225 C9               RET
 293+ 6226              .NOTFOUND:
 294+ 6226 36 FF            LD (HL),#FF
 295+ 6228 23               INC HL
 296+ 6229 36 FF            LD (HL),#FF
 297+ 622B E1               POP HL
 298+ 622C C9               RET
 299+ 622D              ; ************************************************************************************************
 300+ 622D               ENDIF
 301+ 622D
 302+ 622D               IF (0 == 1)
 303+ 622D ~            ; *******************************************************************************************************
 304+ 622D ~            ; same as COLL but for DEFUSR approach
 305+ 622D ~            ; input IX=pointer to input array, real data from +2
 306+ 622D ~            ; +02 = pointer to result variable
 307+ 622D ~            ; +04 = player X
 308+ 622D ~            ; +06 = player Y
 309+ 622D ~            ; +08 = player width
 310+ 622D ~            ; +10 = player height
 311+ 622D ~            ; +12 = number of list items
 312+ 622D ~            ; +14 = pointer to list of collidable objects
 313+ 622D ~            COLL_DEFUSR:
 314+ 622D ~                PUSH IX
 315+ 622D ~                POP HL
 316+ 622D ~                .4 INC HL ; skip over to player x
 317+ 622D ~                LD DE,TMP_STRUCT
 318+ 622D ~                LD BC,9
 319+ 622D ~                LDIR ; copy over x,y,w,h,list item number
 320+ 622D ~                LD A,(IX+14)
 321+ 622D ~                LD (TMP_STRUCT+9),A
 322+ 622D ~                LD A,(IX+15)
 323+ 622D ~                LD (TMP_STRUCT+10),A ; address to collidable objects array
 324+ 622D ~                LD A,(IX+2)
 325+ 622D ~                LD (TMP_STRUCT+11),A
 326+ 622D ~                LD A,(IX+3)
 327+ 622D ~                LD (TMP_STRUCT+12),A ; address to results variable
 328+ 622D ~                PUSH IX
 329+ 622D ~                CALL FIND_OVERLAP
 330+ 622D ~                POP IX
 331+ 622D ~                LD L,(IX+2)
 332+ 622D ~                LD H,(IX+3)
 333+ 622D ~                JR C,.NOTFOUND
 334+ 622D ~                LD (HL),A
 335+ 622D ~                INC HL
 336+ 622D ~                LD (HL),0
 337+ 622D ~            .EXIT:
 338+ 622D ~                XOR A ; success
 339+ 622D ~                RET
 340+ 622D ~            .NOTFOUND:
 341+ 622D ~                LD (HL),#FF
 342+ 622D ~                INC HL
 343+ 622D ~                LD (HL),#FF
 344+ 622D ~                JR .EXIT
 345+ 622D ~            ; *******************************************************************************************************
 346+ 622D               ENDIF
 347+ 622D
# file closed: asm\COLLISION.asm
 172  622D               ENDIF
 173  622D
 174  622D               IF (DECOMP_CMDS == 1)
 175  622D               INCLUDE "decomp.asm"
# file opened: asm\decomp.asm
   1+ 622D              ; -----------------------------------------------------------------------------
   2+ 622D              ; ZX0 decoder by Einar Saukas & Urusergi
   3+ 622D              ; "Standard" version (68 bytes only)
   4+ 622D              ; -----------------------------------------------------------------------------
   5+ 622D              ; Parameters:
   6+ 622D              ;   HL: source address (compressed data)
   7+ 622D              ;   DE: destination address (decompressing)
   8+ 622D              ; -----------------------------------------------------------------------------
   9+ 622D
  10+ 622D              dzx0_standard:
  11+ 622D 01 FF FF             ld      bc, $ffff               ; preserve default offset 1
  12+ 6230 C5                   push    bc
  13+ 6231 03                   inc     bc
  14+ 6232 3E 80                ld      a, $80
  15+ 6234              dzx0s_literals:
  16+ 6234 CD 64 62             call    dzx0s_elias             ; obtain length
  17+ 6237              dzx0_ldir_1:
  18+ 6237 ED B0                ldir                            ; copy literals
  19+ 6239 00                   nop                             ; placeholder for call
  20+ 623A 87                   add     a, a                    ; copy from last offset or new offset?
  21+ 623B 38 0E                jr      c, dzx0s_new_offset
  22+ 623D CD 64 62             call    dzx0s_elias             ; obtain length
  23+ 6240              dzx0s_copy:
  24+ 6240 E3                   ex      (sp), hl                ; preserve source, restore offset
  25+ 6241 E5                   push    hl                      ; preserve offset
  26+ 6242 19                   add     hl, de                  ; calculate destination - offset
  27+ 6243              dzx0_ldir_2:
  28+ 6243 ED B0                ldir                            ; copy from offset
  29+ 6245 00                   nop                             ; placeholder for call
  30+ 6246 E1                   pop     hl                      ; restore offset
  31+ 6247 E3                   ex      (sp), hl                ; preserve offset, restore source
  32+ 6248 87                   add     a, a                    ; copy from literals or new offset?
  33+ 6249 30 E9                jr      nc, dzx0s_literals
  34+ 624B              dzx0s_new_offset:
  35+ 624B C1                   pop     bc                      ; discard last offset
  36+ 624C 0E FE                ld      c, $fe                  ; prepare negative offset
  37+ 624E CD 65 62             call    dzx0s_elias_loop        ; obtain offset MSB
  38+ 6251 0C                   inc     c
  39+ 6252 C8                   ret     z                       ; check end marker
  40+ 6253 41                   ld      b, c
  41+ 6254 4E                   ld      c, (hl)                 ; obtain offset LSB
  42+ 6255 23                   inc     hl
  43+ 6256 CB 18                rr      b                       ; last offset bit becomes first length bit
  44+ 6258 CB 19                rr      c
  45+ 625A C5                   push    bc                      ; preserve new offset
  46+ 625B 01 01 00             ld      bc, 1                   ; obtain length
  47+ 625E D4 6C 62             call    nc, dzx0s_elias_backtrack
  48+ 6261 03                   inc     bc
  49+ 6262 18 DC                jr      dzx0s_copy
  50+ 6264              dzx0s_elias:
  51+ 6264 0C                   inc     c                       ; interlaced Elias gamma coding
  52+ 6265              dzx0s_elias_loop:
  53+ 6265 87                   add     a, a
  54+ 6266 20 03                jr      nz, dzx0s_elias_skip
  55+ 6268 7E                   ld      a, (hl)                 ; load another group of 8 bits
  56+ 6269 23                   inc     hl
  57+ 626A 17                   rla
  58+ 626B              dzx0s_elias_skip:
  59+ 626B D8                   ret     c
  60+ 626C              dzx0s_elias_backtrack:
  61+ 626C 87                   add     a, a
  62+ 626D CB 11                rl      c
  63+ 626F CB 10                rl      b
  64+ 6271 18 F2                jr      dzx0s_elias_loop
  65+ 6273              ; -----------------------------------------------------------------------------
  66+ 6273
  67+ 6273              ; *******************************************************************************************************
  68+ 6273              ; helper function for VRAM unpack to save AF prior to calling copy to VRAM fn
  69+ 6273              ; also simulates register states as if LDIR was called
  70+ 6273              LDIR_TO_VRAM:
  71+ 6273 F5                   PUSH AF ; save AF used by algorithm
  72+ 6274 D5                   PUSH DE
  73+ 6275 C5                   PUSH BC
  74+ 6276 CD 4D 5A             CALL VRAM_LDIRVM
  75+ 6279 C1                   POP BC
  76+ 627A EB                   EX DE,HL
  77+ 627B E1                   POP HL
  78+ 627C 09                   ADD HL,BC
  79+ 627D EB                   EX DE,HL
  80+ 627E 01 00 00             LD BC,0
  81+ 6281 F1                   POP AF
  82+ 6282 C9                   RET
  83+ 6283              ; *******************************************************************************************************
  84+ 6283
  85+ 6283              ; *******************************************************************************************************
  86+ 6283              ; helper function to get a byte from VRAM address at HL and place it at DE also in VRAM
  87+ 6283              VPOKE_VPEEK:
  88+ 6283 F3                   DI
  89+ 6284 CD 6A 66             CALL SETWRT_LOCAL_READ
  90+ 6287 E3                   EX (SP),HL
  91+ 6288 E3                   EX (SP),HL
  92+ 6289 DB 98                IN A,(#98)
  93+ 628B                      ;IN A,(#98) ; WHY IS THIS NEEDED ?
  94+ 628B F5                   PUSH AF
  95+ 628C EB                   EX DE,HL
  96+ 628D CD 5F 66             CALL SETWRT_LOCAL_WRITE
  97+ 6290 E3                   EX (SP),HL
  98+ 6291 E3                   EX (SP),HL
  99+ 6292 EB                   EX DE,HL
 100+ 6293 F1                   POP AF
 101+ 6294 D3 98                OUT (#98),A
 102+ 6296 FB                   EI
 103+ 6297 C9                   RET
 104+ 6298              ; *******************************************************************************************************
 105+ 6298
 106+ 6298              ; *******************************************************************************************************
 107+ 6298              ; helper fn VRAM variant of LDIR
 108+ 6298              ; input HL = source, DE = destination, BC = count
 109+ 6298              VRAM_LDIR:
 110+ 6298 F5                   PUSH AF
 111+ 6299              _L0:
 112+ 6299 CD 83 62             CALL VPOKE_VPEEK
 113+ 629C 23                   INC HL
 114+ 629D 13                   INC DE
 115+ 629E 0B                   DEC BC
 116+ 629F 78                   LD A, B
 117+ 62A0 B1                   OR C
 118+ 62A1 20 F6                JR NZ, _L0
 119+ 62A3 F1                   POP AF
 120+ 62A4 C9                   RET
 121+ 62A5              ; *******************************************************************************************************
 122+ 62A5
 123+ 62A5               IF (1 == 1)
 124+ 62A5              ; *******************************************************************************************************
 125+ 62A5              ; function to handle CALL VUNPACK basic extension
 126+ 62A5              ; _VUNPACK ( INT source,
 127+ 62A5              ;			 INT destination )
 128+ 62A5              ; will put ram in page 0 also, page 1 is already there
 129+ 62A5              ; *******************************************************************************************************
 130+ 62A5              VUNPACK:
 131+ 62A5 3E CD            LD A, #CD ; CALL
 132+ 62A7 32 37 62         LD (dzx0_ldir_1), A
 133+ 62AA 32 43 62         LD (dzx0_ldir_2), A
 134+ 62AD 11 73 62         LD DE, LDIR_TO_VRAM
 135+ 62B0 ED 53 38 62      LD (dzx0_ldir_1 + 1), DE
 136+ 62B4 11 98 62         LD DE, VRAM_LDIR
 137+ 62B7 ED 53 44 62      LD (dzx0_ldir_2 + 1), DE
 138+ 62BB 18 12            JR UNPACK_COMMON
 139+ 62BD              ; function to handle CALL UNPACK basic extension
 140+ 62BD              ; _UNPACK ( INT source,
 141+ 62BD              ;			INT destination )
 142+ 62BD              ; will put ram in page 0 also, page 1 is already there
 143+ 62BD              UNPACK:
 144+ 62BD 11 ED B0         LD DE, #B0ED ; LDIR
 145+ 62C0 ED 53 37 62      LD (dzx0_ldir_1), DE
 146+ 62C4 ED 53 43 62      LD (dzx0_ldir_2), DE
 147+ 62C8 AF               XOR A ; NOP
 148+ 62C9 32 39 62         LD (dzx0_ldir_1 + 2), A
 149+ 62CC 32 45 62         LD (dzx0_ldir_2 + 2), A
 150+ 62CF              UNPACK_COMMON:
 151+ 62CF              	; opening (
 152+ 62CF CD 91 67     	CALL CHKCHAR
 153+ 62D2 28           	DB '('
 154+ 62D3              	; get source address
 155+ 62D3 DD 21 2F 54  	LD IX, FRMQNT
 156+ 62D7 CD 59 01     	CALL CALBAS
 157+ 62DA D5           	PUSH DE
 158+ 62DB              	; comma
 159+ 62DB CD 91 67     	CALL CHKCHAR
 160+ 62DE 2C           	DB ','
 161+ 62DF              	; get destination address
 162+ 62DF DD 21 2F 54  	LD IX, FRMQNT
 163+ 62E3 CD 59 01     	CALL CALBAS
 164+ 62E6 D5           	PUSH DE
 165+ 62E7              	; ending )
 166+ 62E7 CD 91 67     	CALL CHKCHAR
 167+ 62EA 29           	DB ')'
 168+ 62EB
 169+ 62EB              	; save position
 170+ 62EB E5           	PUSH HL
 171+ 62EC DD E1        	POP IX
 172+ 62EE
 173+ 62EE D1           	POP DE ; destination
 174+ 62EF E1           	POP HL ; source
 175+ 62F0 D9           	EXX
 176+ 62F1              	; enable page 0
 177+ 62F1 FD 21 F8 62  	LD IY, .RET
 178+ 62F5 C3 42 67     	JP ENABLE_PAGE0
 179+ 62F8              .RET:
 180+ 62F8 FB           	EI
 181+ 62F9 D9           	EXX
 182+ 62FA CD 2D 62     	CALL dzx0_standard
 183+ 62FD C3 55 66             JP COMMON_EXIT_CODE_IX
 184+ 6300              ; *******************************************************************************************************
 185+ 6300               ENDIF
 186+ 6300
 187+ 6300               IF (0 == 1)
 188+ 6300 ~            ; *******************************************************************************************************
 189+ 6300 ~            ; same as VUNPACK but for DEFUSR approach
 190+ 6300 ~            ; input IX=pointer to input array, real data from +2
 191+ 6300 ~            ; +2 = source address
 192+ 6300 ~            ; +4 = destination address
 193+ 6300 ~            ; *******************************************************************************************************
 194+ 6300 ~            VUNPACK_DEFUSR:
 195+ 6300 ~                LD A, #CD ; CALL
 196+ 6300 ~                LD (dzx0_ldir_1), A
 197+ 6300 ~                LD (dzx0_ldir_2), A
 198+ 6300 ~                LD HL, LDIR_TO_VRAM
 199+ 6300 ~                LD (dzx0_ldir_1 + 1), HL
 200+ 6300 ~                LD HL, VRAM_LDIR
 201+ 6300 ~                LD (dzx0_ldir_2 + 1), HL
 202+ 6300 ~                JR UNPACK_DEFUSR_COMMON
 203+ 6300 ~            ; same as UNPACK but for DEFUSR approach
 204+ 6300 ~            ; input IX=pointer to input array, real data from +2
 205+ 6300 ~            ; +2 = source address
 206+ 6300 ~            ; +4 = destination address
 207+ 6300 ~            UNPACK_DEFUSR:
 208+ 6300 ~                LD HL, #B0ED ; LDIR
 209+ 6300 ~                LD (dzx0_ldir_1), HL
 210+ 6300 ~                LD (dzx0_ldir_2), HL
 211+ 6300 ~                XOR A ; NOP
 212+ 6300 ~                LD (dzx0_ldir_1 + 2), A
 213+ 6300 ~                LD (dzx0_ldir_2 + 2), A
 214+ 6300 ~            UNPACK_DEFUSR_COMMON:
 215+ 6300 ~                ; enable page 0
 216+ 6300 ~                LD IY, .RET
 217+ 6300 ~                JP ENABLE_PAGE0
 218+ 6300 ~            .RET:
 219+ 6300 ~                EI
 220+ 6300 ~                LD L,(IX+2)
 221+ 6300 ~                LD H,(IX+3)
 222+ 6300 ~                LD E,(IX+4)
 223+ 6300 ~                LD D,(IX+5)
 224+ 6300 ~                CALL dzx0_standard
 225+ 6300 ~                JP COMMON_EXIT_CODE
 226+ 6300 ~            ; *******************************************************************************************************
 227+ 6300               ENDIF
# file closed: asm\decomp.asm
 176  6300               ENDIF
 177  6300
 178  6300               IF (DLOAD_CMD == 1)
 179  6300               INCLUDE "DLOAD.asm"
# file opened: asm\DLOAD.asm
   1+ 6300              BDOS_SETDTA     EQU #1A
   2+ 6300              BDOS_OPEN       EQU #0F
   3+ 6300              BDOS_CLOSE      EQU #10
   4+ 6300              BDOS_RDBLK      EQU #27
   5+ 6300
   6+ 6300              ; *******************************************************************************************************
   7+ 6300              ; function processes file name
   8+ 6300              ; filenames supported are D:FILENAME.EXT, FILENAME.EXT, D:FILENAME, FILENAME
   9+ 6300              ; FCB 0 will be zeroed out
  10+ 6300              ; FCB 0 will be populated with drive info 0=default or 1-8 for drives A-H
  11+ 6300              ; FCB 0 will be populated with file name
  12+ 6300              ; input HL=pointer to expression
  13+ 6300              ; input B=length
  14+ 6300              ; returns CF=1 if bad filename
  15+ 6300              DLOAD_PROCESS_FILENAME:
  16+ 6300                  ; check for zero size
  17+ 6300 78               LD A,B
  18+ 6301 B7               OR A
  19+ 6302 28 6B            JR Z, .BADFILENAME
  20+ 6304                  ; check for more than 2+8+1+3=14
  21+ 6304 FE 0F            CP 15
  22+ 6306 30 67            JR NC, .BADFILENAME
  23+ 6308                  ; check if more than 2 letters
  24+ 6308 FE 03            CP 3
  25+ 630A 38 1C            JR C, .L7 ; no drive
  26+ 630C                  ; check for : at proper place
  27+ 630C 5E               LD E, (HL)
  28+ 630D 23               INC HL
  29+ 630E 7E               LD A, (HL)
  30+ 630F FE 3A            CP ':'
  31+ 6311 20 14            JR NZ, .L1
  32+ 6313                  ; so we have : , check for letters A-H
  33+ 6313 7B               LD A,E
  34+ 6314 CD CA 67         CALL UPPER
  35+ 6317 D6 41            SUB 'A'
  36+ 6319 FE 09            CP 9
  37+ 631B 30 52            JR NC, .BADFILENAME
  38+ 631D 23               INC HL
  39+ 631E 05               DEC B ; consume two characters
  40+ 631F 05               DEC B
  41+ 6320              .L2:
  42+ 6320 ED 5B 53 F3      LD DE, (FCB0)
  43+ 6324 12               LD (DE), A
  44+ 6325 18 04            JR .PROCESS_FILENAME
  45+ 6327              .L1:
  46+ 6327                  ; no drive specified
  47+ 6327 2B               DEC HL
  48+ 6328              .L7:
  49+ 6328 AF               XOR A
  50+ 6329 18 F5            JR .L2
  51+ 632B              .PROCESS_FILENAME:
  52+ 632B                  ; HL is pointing to rest of the name
  53+ 632B 13               INC DE ; 8-character filename location, needs to be padded with blanks
  54+ 632C 0E 08            LD C,8 ; filename length
  55+ 632E              .L4:
  56+ 632E CD 71 63         CALL .GETCHAR
  57+ 6331 FE 2E            CP '.'
  58+ 6333 28 31            JR Z, .L6 ; if dot, fill rest with blanks
  59+ 6335 12               LD (DE),A
  60+ 6336 13               INC DE
  61+ 6337 0D               DEC C
  62+ 6338 20 F4            JR NZ, .L4
  63+ 633A                  ; so we cleared filename part
  64+ 633A 78               LD A,B ; no more letters. just fill extension with blanks
  65+ 633B B7               OR A
  66+ 633C 28 07            JR Z, .L8
  67+ 633E CD 71 63         CALL .GETCHAR ; here we must have . for a valid name
  68+ 6341 FE 2E            CP '.'
  69+ 6343 20 2A            JR NZ, .BADFILENAME
  70+ 6345              .L8:
  71+ 6345 0E 03            LD C,3
  72+ 6347              .L5:
  73+ 6347 CD 71 63         CALL .GETCHAR
  74+ 634A 12               LD (DE),A
  75+ 634B 13               INC DE
  76+ 634C 0D               DEC C
  77+ 634D 20 F8            JR NZ, .L5
  78+ 634F 78               LD A,B ; nothing must be left in buffer
  79+ 6350 B7               OR A
  80+ 6351 20 1C            JR NZ, .BADFILENAME
  81+ 6353                  ; file name correct, now zero out the rest of FCB 0
  82+ 6353 2A 53 F3         LD HL,(FCB0)
  83+ 6356 11 0C 00         LD DE,12
  84+ 6359 19               ADD HL,DE
  85+ 635A 36 00            LD (HL),0
  86+ 635C 54               LD D,H
  87+ 635D 5D               LD E,L
  88+ 635E 13               INC DE
  89+ 635F 01 18 00         LD BC,37-12-1
  90+ 6362 ED B0            LDIR
  91+ 6364 AF               XOR A ; clear carry flag
  92+ 6365 C9               RET
  93+ 6366              .L6:
  94+ 6366 3E 20            LD A,' '
  95+ 6368              .L9:
  96+ 6368 12               LD (DE),A
  97+ 6369 13               INC DE
  98+ 636A 0D               DEC C
  99+ 636B 20 FB            JR NZ, .L9
 100+ 636D 18 D6            JR .L8
 101+ 636F              .BADFILENAME:
 102+ 636F 37               SCF
 103+ 6370 C9               RET
 104+ 6371              .GETCHAR: ; gets a character, returns blank if we read past input
 105+ 6371 78               LD A,B
 106+ 6372 B7               OR A
 107+ 6373 28 07            JR Z, .BLANK
 108+ 6375 7E               LD A,(HL)
 109+ 6376 CD CA 67         CALL UPPER
 110+ 6379 23               INC HL
 111+ 637A 05               DEC B
 112+ 637B C9               RET
 113+ 637C              .BLANK:
 114+ 637C 3E 20            LD A,' '
 115+ 637E C9               RET
 116+ 637F              ; *******************************************************************************************************
 117+ 637F
 118+ 637F              ; *******************************************************************************************************
 119+ 637F              ; function sets disk buffer from NULBUF
 120+ 637F              ; input none
 121+ 637F              ; returns ZF!=1 on error
 122+ 637F              DLOAD_SETDTA:
 123+ 637F ED 5B 62 F8      LD DE,(NULBUF)
 124+ 6383 0E 1A            LD C, BDOS_SETDTA
 125+ 6385 18 24            JR BDOS_CALL
 126+ 6387              ; *******************************************************************************************************
 127+ 6387
 128+ 6387              ; *******************************************************************************************************
 129+ 6387              ; function opens a file using FCB 0
 130+ 6387              ; input none
 131+ 6387              ; returns ZF!=1 on error
 132+ 6387              DLOAD_OPENFILE:
 133+ 6387 ED 5B 53 F3      LD DE,(FCB0)
 134+ 638B 0E 0F            LD C, BDOS_OPEN
 135+ 638D 18 1C            JR BDOS_CALL
 136+ 638F              ; *******************************************************************************************************
 137+ 638F
 138+ 638F              ; *******************************************************************************************************
 139+ 638F              ; function makes a file seek and sets record size to 1 byte
 140+ 638F              ; input none
 141+ 638F              ; output node
 142+ 638F              DLOAD_SEEK:
 143+ 638F 2A 5A 64         LD HL,(TMP_STRUCT)
 144+ 6392 DD 2A 53 F3      LD IX,(FCB0)
 145+ 6396 DD 75 21         LD (IX+33),L
 146+ 6399 DD 74 22         LD (IX+34),H
 147+ 639C DD 36 0E 01      LD (IX+14),1
 148+ 63A0 DD 36 0F 00      LD (IX+15),0
 149+ 63A4 C9               RET
 150+ 63A5              ; *******************************************************************************************************
 151+ 63A5
 152+ 63A5              ; *******************************************************************************************************
 153+ 63A5              ; function reads a number of bytes from a file using FCB 0 to (NULBUF) buffer
 154+ 63A5              ; input HL=number of bytes to read
 155+ 63A5              ; returns HL=number of bytes read
 156+ 63A5              ; returns ZF!=1 on error
 157+ 63A5              DLOAD_READ:
 158+ 63A5 ED 5B 53 F3      LD DE,(FCB0)
 159+ 63A9 0E 27            LD C,BDOS_RDBLK
 160+ 63AB              BDOS_CALL:
 161+ 63AB CD 7D F3         CALL BDOS
 162+ 63AE B7               OR A
 163+ 63AF C9               RET
 164+ 63B0              ; *******************************************************************************************************
 165+ 63B0
 166+ 63B0              ; *******************************************************************************************************
 167+ 63B0              ; function closes a file FCB 0
 168+ 63B0              ; input none
 169+ 63B0              ; returns ZF!=1 on error
 170+ 63B0              DLOAD_CLOSE:
 171+ 63B0 AF               XOR A
 172+ 63B1 ED 5B 53 F3      LD DE,(FCB0)
 173+ 63B5 0E 10            LD C,BDOS_CLOSE
 174+ 63B7 18 F2            JR BDOS_CALL
 175+ 63B9              ; *******************************************************************************************************
 176+ 63B9
 177+ 63B9              ; *******************************************************************************************************
 178+ 63B9              ; function copies data from (NULBUF) to destination, enables RAM in page 0
 179+ 63B9              ; input BC=number of bytes to copy
 180+ 63B9              ; output none
 181+ 63B9              DLOAD_TRANSFERBLOCK:
 182+ 63B9 D9               EXX ; save BC
 183+ 63BA              	; enable page 0
 184+ 63BA FD 21 C1 63  	LD IY, .RET
 185+ 63BE C3 42 67     	JP ENABLE_PAGE0
 186+ 63C1              .RET:
 187+ 63C1 FB           	EI
 188+ 63C2 D9               EXX
 189+ 63C3 ED 5B 5C 64      LD DE,(TMP_STRUCT+2)
 190+ 63C7 2A 62 F8         LD HL,(NULBUF)
 191+ 63CA ED B0        	LDIR
 192+ 63CC ED 53 5C 64      LD (TMP_STRUCT+2),DE
 193+ 63D0 D1               POP DE
 194+ 63D1 C1               POP BC
 195+ 63D2 C3 B9 66         JP RESTORE_PAGE_INFO
 196+ 63D5              ; *******************************************************************************************************
 197+ 63D5
 198+ 63D5              ; *******************************************************************************************************
 199+ 63D5              ; function opens and loads a file in FCB 0
 200+ 63D5              ; file name needs to be already set in FCB 0
 201+ 63D5              ; input none
 202+ 63D5              ; returns ZF!=1 on error
 203+ 63D5              DLOAD_LOADFILE:
 204+ 63D5 CD 7F 63         CALL DLOAD_SETDTA
 205+ 63D8 CD 87 63         CALL DLOAD_OPENFILE
 206+ 63DB C0               RET NZ
 207+ 63DC CD 8F 63         CALL DLOAD_SEEK
 208+ 63DF ED 4B 5E 64      LD BC,(TMP_STRUCT+4)
 209+ 63E3              .L1:
 210+ 63E3 78               LD A,B
 211+ 63E4 B7               OR A
 212+ 63E5 28 12            JR Z,.REST
 213+ 63E7 05               DEC B
 214+ 63E8 21 00 01         LD HL,256
 215+ 63EB              .L2:
 216+ 63EB C5               PUSH BC
 217+ 63EC E5               PUSH HL
 218+ 63ED CD A5 63         CALL DLOAD_READ
 219+ 63F0 C1               POP BC
 220+ 63F1 20 10            JR NZ,.ERRREAD
 221+ 63F3 CD B9 63         CALL DLOAD_TRANSFERBLOCK
 222+ 63F6 C1               POP BC
 223+ 63F7 18 EA            JR .L1
 224+ 63F9              .REST:
 225+ 63F9 79               LD A,C
 226+ 63FA B7               OR A
 227+ 63FB 28 07            JR Z,.EXIT
 228+ 63FD 26 00            LD H,0
 229+ 63FF 69               LD L,C
 230+ 6400 4C               LD C,H
 231+ 6401 18 E8            JR .L2
 232+ 6403              .ERRREAD:
 233+ 6403 C1               POP BC
 234+ 6404              .EXIT:
 235+ 6404 F5               PUSH AF
 236+ 6405 CD B0 63         CALL DLOAD_CLOSE
 237+ 6408 F1               POP AF
 238+ 6409 C9               RET
 239+ 640A              ; *******************************************************************************************************
 240+ 640A
 241+ 640A               IF (1 == 1)
 242+ 640A
 243+ 640A              ; *******************************************************************************************************
 244+ 640A              ; function to handle CALL DLOAD basic extension
 245+ 640A              ; _DLOAD ( STRING filename,
 246+ 640A              ;		   INT offset,
 247+ 640A              ;		   INT destination,
 248+ 640A              ;          INT size )
 249+ 640A              ; will put ram in page 0 also, page 1 is already there
 250+ 640A              DLOAD:
 251+ 640A              	; opening (
 252+ 640A CD 91 67     	CALL CHKCHAR
 253+ 640D 28           	DB '('
 254+ 640E CD DD 67         CALL EVALTXTPARAM
 255+ 6411 E5               PUSH HL
 256+ 6412 CD D3 67         CALL GETSTRPNT
 257+ 6415 CD 00 63         CALL DLOAD_PROCESS_FILENAME
 258+ 6418 DA A5 67         JP C, BAD_FILENAME
 259+ 641B E1               POP HL
 260+ 641C              	; comma
 261+ 641C CD 91 67     	CALL CHKCHAR
 262+ 641F 2C           	DB ','
 263+ 6420              	; get offset
 264+ 6420 DD 21 2F 54  	LD IX, FRMQNT
 265+ 6424 CD 59 01     	CALL CALBAS
 266+ 6427 ED 53 5A 64  	LD (TMP_STRUCT), DE
 267+ 642B              	; comma
 268+ 642B CD 91 67     	CALL CHKCHAR
 269+ 642E 2C           	DB ','
 270+ 642F              	; get destination
 271+ 642F DD 21 2F 54  	LD IX, FRMQNT
 272+ 6433 CD 59 01     	CALL CALBAS
 273+ 6436 ED 53 5C 64  	LD (TMP_STRUCT+2), DE
 274+ 643A              	; comma
 275+ 643A CD 91 67     	CALL CHKCHAR
 276+ 643D 2C           	DB ','
 277+ 643E              	; get size
 278+ 643E DD 21 2F 54  	LD IX, FRMQNT
 279+ 6442 CD 59 01     	CALL CALBAS
 280+ 6445 ED 53 5E 64  	LD (TMP_STRUCT+4), DE
 281+ 6449              	; ending )
 282+ 6449 CD 91 67     	CALL CHKCHAR
 283+ 644C 29           	DB ')'
 284+ 644D
 285+ 644D E5               PUSH HL
 286+ 644E CD D5 63         CALL DLOAD_LOADFILE
 287+ 6451 C2 A9 67         JP NZ, DISKIOERR
 288+ 6454 E1               POP HL
 289+ 6455 C9               RET
 290+ 6456              ; *******************************************************************************************************
 291+ 6456
 292+ 6456               ENDIF
 293+ 6456
 294+ 6456               IF (0 == 1)
 295+ 6456 ~            ; *******************************************************************************************************
 296+ 6456 ~            ; same as DLOAD but for DEFUSR approach
 297+ 6456 ~            ; input IX=pointer to input array, real data from +2
 298+ 6456 ~            ; +02 = string pointer as provided by MSX-BASIC: length, followed by a pointer to ASCII data
 299+ 6456 ~            ; +04 = offset
 300+ 6456 ~            ; +06 = destination
 301+ 6456 ~            ; +08 = size
 302+ 6456 ~            ; +10 = string type, 0=MSX-BASIC: length+pointer to ASCII data, !=0 X-BASIC: length+ASCII data
 303+ 6456 ~            ; output A=0 on success
 304+ 6456 ~            ; NOTE: this call will fail if called under X-BASIC as strings are handled differently in memory: length followed by ASCII data
 305+ 6456 ~            ; *******************************************************************************************************
 306+ 6456 ~            DLOAD_DEFUSR:
 307+ 6456 ~                LD L,(IX+2)
 308+ 6456 ~                LD H,(IX+3)
 309+ 6456 ~                LD B,(HL) ; string length
 310+ 6456 ~                INC HL
 311+ 6456 ~                LD A,(IX+10)
 312+ 6456 ~                OR A
 313+ 6456 ~                JR NZ,.XBASIC
 314+ 6456 ~                LD E,(HL)
 315+ 6456 ~                INC HL
 316+ 6456 ~                LD D,(HL)
 317+ 6456 ~                EX DE,HL ; pointer to ASCIIZ text
 318+ 6456 ~            .XBASIC:
 319+ 6456 ~                CALL DLOAD_PROCESS_FILENAME
 320+ 6456 ~                JR C,.ERR ; exit on error
 321+ 6456 ~                LD L,(IX+4)
 322+ 6456 ~                LD H,(IX+5)
 323+ 6456 ~                LD (TMP_STRUCT),HL ; offset
 324+ 6456 ~                LD L,(IX+6)
 325+ 6456 ~                LD H,(IX+7)
 326+ 6456 ~                LD (TMP_STRUCT+2),HL ; destination
 327+ 6456 ~                LD L,(IX+8)
 328+ 6456 ~                LD H,(IX+9)
 329+ 6456 ~                LD (TMP_STRUCT+4),HL ; size
 330+ 6456 ~                CALL DLOAD_LOADFILE
 331+ 6456 ~                JR NZ,.ERR
 332+ 6456 ~                XOR A
 333+ 6456 ~                RET
 334+ 6456 ~            .ERR:
 335+ 6456 ~                LD A,1
 336+ 6456 ~                RET
 337+ 6456 ~            ; *******************************************************************************************************
 338+ 6456 ~
 339+ 6456               ENDIF
 340+ 6456
# file closed: asm\DLOAD.asm
 180  6456               ENDIF
 181  6456
 182  6456               IF (0 == 1)
 183  6456 ~             INCLUDE "DEFUSR.asm"
 184  6456               ENDIF
 185  6456
 186  6456              ; temp variables for various fuctions
 187  6456              ; name historically from usage by BLIT, but since then
 188  6456              BLIT_TMP:
 189  6456              TILETMP1:
 190  6456              BLIT_TMP1:
 191  6456 00 00         DW 0
 192  6458              TILETMP2:
 193  6458              BLIT_TMP2:
 194  6458 00 00         DW 0
 195  645A              TMP_STRUCT:
 196  645A 00 00 00...   DS 17
 197  646B
 198  646B               IF (VRAM_CMDS + TILE_CMDS + BOX_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 199  646B              VRAM_UPDATE_IN_PROGRESS:
 200  646B 00            DB 0
 201  646C               ENDIF
 202  646C
 203  646C              ; List of pointers to available instructions (as ASCIIZ) and execute address (as word)
 204  646C              ; per starting letter, if no commands with this letter, NULL value
 205  646C              CMDS:
 206  646C BD 65        	DW CMDS_A ; always present due to ARTINFO
 207  646E               IF (BLIT_CMDS + BOX_CMDS > 0) && (1 == 1)
 208  646E 72 65            DW CMDS_B ; B
 209  6470               ELSE
 210  6470 ~            	DW 0
 211  6470               ENDIF
 212  6470               IF (COLL_CMD == 1) && (1 == 1)
 213  6470 A5 65        	DW CMDS_C ;
 214  6472               ELSE
 215  6472 ~                DW 0 ; C
 216  6472               ENDIF
 217  6472               IF (DLOAD_CMD > 0) && (1 == 1)
 218  6472 B5 65            DW CMDS_D ; D
 219  6474               ELSE
 220  6474 ~            	DW 0
 221  6474               ENDIF
 222  6474 00 00            DW 0 ; E
 223  6476               IF (VRAM_CMDS + RAM_CMDS > 0) && (1 == 1)
 224  6476 EC 64            DW CMDS_F; F
 225  6478               ELSE
 226  6478 ~            	DW 0
 227  6478               ENDIF
 228  6478               IF (GENCAL_CMD > 0) && (1 == 1)
 229  6478 FE 64            DW CMDS_G; G
 230  647A               ELSE
 231  647A ~            	DW 0
 232  647A               ENDIF
 233  647A 00 00            DW 0 ; H
 234  647C 00 00            DW 0 ; I
 235  647E 00 00            DW 0 ; J
 236  6480 00 00            DW 0 ; K
 237  6482 00 00            DW 0 ; L
 238  6484               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0) && (1 == 1)
 239  6484 A0 64            DW CMDS_M ; M
 240  6486               ELSE
 241  6486 ~            	DW 0
 242  6486               ENDIF
 243  6486 00 00            DW 0 ; N
 244  6488 00 00            DW 0 ; O
 245  648A 00 00            DW 0 ; P
 246  648C 00 00            DW 0 ; Q
 247  648E 00 00            DW 0 ; R
 248  6490               IF (SOUND_CMDS + SPRITE_CMDS > 0) && (1 == 1)
 249  6490 1A 65            DW CMDS_S ; S
 250  6492               ELSE
 251  6492 ~            	DW 0
 252  6492               ENDIF
 253  6492               IF (TILE_CMDS > 0) && (1 == 1)
 254  6492 91 65            DW CMDS_T ; T
 255  6494               ELSE
 256  6494 ~            	DW 0
 257  6494               ENDIF
 258  6494               IF (DECOMP_CMDS > 0) && (1 == 1)
 259  6494 AC 65            DW CMDS_U ; U
 260  6496               ELSE
 261  6496 ~            	DW 0
 262  6496               ENDIF
 263  6496               IF ((VRAM_CMDS > 0) || (VRAM_CMDS + DECOMP_CMDS > 1)) && (1 == 1)
 264  6496 07 65            DW CMDS_V ; V
 265  6498               ELSE
 266  6498 ~            	DW 0
 267  6498               ENDIF
 268  6498 00 00            DW 0 ; W
 269  649A 00 00            DW 0 ; X
 270  649C 00 00            DW 0 ; Y
 271  649E 00 00            DW 0 ; Z
 272  64A0
 273  64A0               IF (1 == 1)
 274  64A0               IF (VRAM_CMDS + RAM_CMDS + ANIM_CMDS > 0)
 275  64A0              CMDS_M:
 276  64A0               IF (VRAM_CMDS == 1)
 277  64A0 4D 45 4D 56      DB "MEMVRM", 0
 277  64A4 52 4D 00
 278  64A7 F0 59            DW MEMVRM
 279  64A9               ENDIF
 280  64A9               IF (RAM_CMDS == 1)
 281  64A9 4D 45 4D 43  	DB "MEMCPY", 0
 281  64AD 50 59 00
 282  64B0 39 58        	DW MEMCPY
 283  64B2               ENDIF
 284  64B2               IF (ANIM_CMDS == 1)
 285  64B2 4D 41 58 41  	DB "MAXANIMITEMS",0
 285  64B6 4E 49 4D 49
 285  64BA 54 45 4D 53
 285  64BE 00
 286  64BF A7 4F        	DW MAXANIMITEMS
 287  64C1 4D 41 58 41  	DB "MAXANIMDEFS",0
 287  64C5 4E 49 4D 44
 287  64C9 45 46 53 00
 288  64CD 37 51        	DW MAXANIMDEFS
 289  64CF 4D 41 58 41  	DB "MAXANIMSPRS",0
 289  64D3 4E 49 4D 53
 289  64D7 50 52 53 00
 290  64DB CD 51        	DW MAXANIMSPRS
 291  64DD 4D 41 58 41     DB "MAXAUTOSGAMS",0
 291  64E1 55 54 4F 53
 291  64E5 47 41 4D 53
 291  64E9 00
 292  64EA 17 53           DW MAXAUTOSGAMS
 293  64EC               ENDIF
 294  64EC               ENDIF
 295  64EC
 296  64EC               IF (VRAM_CMDS + RAM_CMDS > 0)
 297  64EC              CMDS_F:
 298  64EC               IF (VRAM_CMDS == 1)
 299  64EC 46 49 4C 56      DB "FILVRM", 0
 299  64F0 52 4D 00
 300  64F3 A1 59            DW FILVRM
 301  64F5               ENDIF
 302  64F5               IF (RAM_CMDS == 1)
 303  64F5 46 49 4C 52      DB "FILRAM", 0
 303  64F9 41 4D 00
 304  64FC 76 58            DW FILRAM
 305  64FE               ENDIF
 306  64FE               ENDIF
 307  64FE
 308  64FE               IF (GENCAL_CMD > 0)
 309  64FE              CMDS_G:
 310  64FE               IF (GENCAL_CMD == 1)
 311  64FE 47 45 4E 43      DB "GENCAL", 0
 311  6502 41 4C 00
 312  6505 D1 5A            DW GENCAL
 313  6507               ENDIF
 314  6507               ENDIF
 315  6507
 316  6507               IF (VRAM_CMDS > 0)
 317  6507              CMDS_V:
 318  6507               IF (VRAM_CMDS == 1)
 319  6507 56 52 4D 4D  	DB "VRMMEM", 0
 319  650B 45 4D 00
 320  650E 77 5A        	DW VRMMEM
 321  6510               ENDIF
 322  6510               IF (DECOMP_CMDS == 1)
 323  6510 56 55 4E 50  	DB "VUNPACK", 0
 323  6514 41 43 4B 00
 324  6518 A5 62        	DW VUNPACK
 325  651A               ENDIF
 326  651A               ENDIF
 327  651A
 328  651A               IF (SOUND_CMDS + SPRITE_CMDS + ANIM_CMDS > 0)
 329  651A              CMDS_S:
 330  651A               IF (SPRITE_CMDS + ANIM_CMDS > 0)
 331  651A 53 47 41 4D      DB "SGAM",0
 331  651E 00
 332  651F A5 56            DW SGAM
 333  6521               ENDIF
 334  6521               IF (SPRITE_CMDS == 1)
 335  6521 53 50 52 47  	DB "SPRGRPMOV", 0
 335  6525 52 50 4D 4F
 335  6529 56 00
 336  652B FF 4E        	DW SPRGRPMOV
 337  652D               ENDIF
 338  652D               IF (SOUND_CMDS == 1)
 339  652D 53 4E 44 53  	DB "SNDSFX", 0
 339  6531 46 58 00
 340  6534 46 59        	DW SNDSFX
 341  6536 53 4E 44 50  	DB "SNDPLYON", 0
 341  653A 4C 59 4F 4E
 341  653E 00
 342  653F 10 59        	DW SNDPLYON
 343  6541 53 4E 44 50  	DB "SNDPLYOFF", 0
 343  6545 4C 59 4F 46
 343  6549 46 00
 344  654B 22 59        	DW SNDPLYOFF
 345  654D 53 4E 44 50  	DB "SNDPLYINI", 0
 345  6551 4C 59 49 4E
 345  6555 49 00
 346  6557 C5 58        	DW SNDPLYINIT
 347  6559               ENDIF
 348  6559               IF (SPRITE_CMDS == 1)
 349  6559 53 50 52 45  	DB "SPRENABLE", 0
 349  655D 4E 41 42 4C
 349  6561 45 00
 350  6563 75 4E        	DW SPRENABLE
 351  6565 53 50 52 44  	DB "SPRDISABLE", 0
 351  6569 49 53 41 42
 351  656D 4C 45 00
 352  6570 BC 4E        	DW SPRDISABLE
 353  6572               ENDIF
 354  6572               ENDIF
 355  6572
 356  6572               IF (BLIT_CMDS + BOX_CMDS > 0)
 357  6572              CMDS_B:
 358  6572               IF (BLIT_CMDS == 1)
 359  6572 42 4C 49 54  	DB "BLIT", 0
 359  6576 00
 360  6577 B2 5D        	DW BLIT
 361  6579               ENDIF
 362  6579               IF (BOX_CMDS == 1)
 363  6579 42 4F 58 4D  	DB "BOXMEMCPY", 0
 363  657D 45 4D 43 50
 363  6581 59 00
 364  6583 61 5B        	DW BOXMEMCPY
 365  6585 42 4F 58 4D  	DB "BOXMEMVRM", 0
 365  6589 45 4D 56 52
 365  658D 4D 00
 366  658F F6 5B        	DW BOXMEMVRM
 367  6591               ENDIF
 368  6591               ENDIF
 369  6591
 370  6591               IF (TILE_CMDS > 0)
 371  6591              CMDS_T:
 372  6591               IF (TILE_CMDS == 1)
 373  6591 54 49 4C 45  	DB "TILERAM", 0
 373  6595 52 41 4D 00
 374  6599 DA 5E        	DW TILERAM
 375  659B 54 49 4C 45  	DB "TILEVRM", 0
 375  659F 56 52 4D 00
 376  65A3 D9 5F        	DW TILEVRM
 377  65A5               ENDIF
 378  65A5               ENDIF
 379  65A5
 380  65A5               IF (COLL_CMD > 0)
 381  65A5              CMDS_C:
 382  65A5               IF (COLL_CMD == 1)
 383  65A5 43 4F 4C 4C      DB "COLL", 0
 383  65A9 00
 384  65AA A6 61            DW COLL
 385  65AC               ENDIF
 386  65AC               ENDIF
 387  65AC
 388  65AC               IF (DECOMP_CMDS > 0)
 389  65AC              CMDS_U:
 390  65AC               IF (DECOMP_CMDS == 1)
 391  65AC 55 4E 50 41      DB "UNPACK", 0
 391  65B0 43 4B 00
 392  65B3 BD 62            DW UNPACK
 393  65B5               ENDIF
 394  65B5               ENDIF
 395  65B5
 396  65B5               IF (DLOAD_CMD > 0)
 397  65B5              CMDS_D:
 398  65B5               IF (DLOAD_CMD == 1)
 399  65B5 44 4C 4F 41      DB "DLOAD", 0
 399  65B9 44 00
 400  65BB 0A 64            DW DLOAD
 401  65BD               ENDIF
 402  65BD               ENDIF
 403  65BD
 404  65BD              CMDS_A:
 405  65BD               IF (ANIM_CMDS == 1)
 406  65BD 41 4E 49 4D     DB "ANIMSTEP",0
 406  65C1 53 54 45 50
 406  65C5 00
 407  65C6 E7 54           DW ANIMSTEP
 408  65C8 41 4E 49 4D  	DB "ANIMSTART",0
 408  65CC 53 54 41 52
 408  65D0 54 00
 409  65D2 EC 54        	DW ANIMSTART
 410  65D4 41 4E 49 4D  	DB "ANIMSTOP",0
 410  65D8 53 54 4F 50
 410  65DC 00
 411  65DD F1 54        	DW ANIMSTOP
 412  65DF 41 4E 49 4D  	DB "ANIMITEMPAT",0
 412  65E3 49 54 45 4D
 412  65E7 50 41 54 00
 413  65EB 78 50        	DW ANIMITEMPAT
 414  65ED 41 4E 49 4D  	DB "ANIMITEMPTR",0
 414  65F1 49 54 45 4D
 414  65F5 50 54 52 00
 415  65F9 DE 50        	DW ANIMITEMPTR_CMD
 416  65FB 41 4E 49 4D  	DB "ANIMDEF",0
 416  65FF 44 45 46 00
 417  6603 7A 51        	DW ANIMDEF
 418  6605 41 4E 49 4D  	DB "ANIMSPRITE",0
 418  6609 53 50 52 49
 418  660D 54 45 00
 419  6610 26 52        	DW ANIMSPRITE
 420  6612 41 4E 49 4D     DB "ANIMCHAR",0
 420  6616 43 48 41 52
 420  661A 00
 421  661B 9E 52           DW ANIMCHAR
 422  661D 41 55 54 4F     DB "AUTOSGAMDEF",0
 422  6621 53 47 41 4D
 422  6625 44 45 46 00
 423  6629 74 53           DW AUTOSGAMDEF
 424  662B 41 55 54 4F     DB "AUTOSGAMSTART",0
 424  662F 53 47 41 4D
 424  6633 53 54 41 52
 424  6637 54 00
 425  6639 A8 54           DW AUTOSGAMSTART
 426  663B 41 55 54 4F     DB "AUTOSGAMSTOP",0
 426  663F 53 47 41 4D
 426  6643 53 54 4F 50
 426  6647 00
 427  6648 E4 54           DW AUTOSGAMSTOP
 428  664A               ENDIF
 429  664A 41 52 54 49     DB "ARTINFO",0
 429  664E 4E 46 4F 00
 430  6652 2B 68           DW ARTINFO
 431  6654 00           	DB 0
 432  6655               ELSE // if not BASIC extension
 433  6655 ~            CMDS_A:
 434  6655 ~               DB "ARTINFO",0
 435  6655 ~               DW ARTINFO
 436  6655 ~            	DB 0
 437  6655               ENDIF
 438  6655
 439  6655              ; ****************************************************************************************************
 440  6655              ; some common exit code
 441  6655              ; returns ROM in page 0
 442  6655              ; sets exit status to 0 in A
 443  6655              COMMON_EXIT_CODE_IX:
 444  6655 DD E5           PUSH IX
 445  6657 E1              POP HL
 446  6658              COMMON_EXIT_CODE:
 447  6658 D1              POP DE
 448  6659 C1              POP BC
 449  665A CD B9 66        CALL RESTORE_PAGE_INFO
 450  665D AF           	XOR A ; success
 451  665E C9           	RET
 452  665F              ; ****************************************************************************************************
 453  665F
 454  665F               IF (VRAM_CMDS + TILE_CMDS + SPRITE_CMDS > 0)
 455  665F              ; ****************************************************************************************************
 456  665F              ; function sets VRAM address for writing
 457  665F              ; input HL=address
 458  665F              ; modifies AF
 459  665F              SETWRT_LOCAL_WRITE:
 460  665F 7D           	LD	A,L
 461  6660 D3 99        	OUT (#99),A
 462  6662 7C           	LD	A,H
 463  6663 E6 3F        	AND #3F
 464  6665 F6 40        	OR	#40
 465  6667 D3 99        	OUT (#99),A
 466  6669 C9           	RET
 467  666A              ; ****************************************************************************************************
 468  666A
 469  666A              ; ****************************************************************************************************
 470  666A              ; function sets VRAM address for reading
 471  666A              ; input HL=address
 472  666A              ; modifies AF
 473  666A              SETWRT_LOCAL_READ:
 474  666A 7D           	LD	A,L
 475  666B D3 99        	OUT (#99),A
 476  666D 7C           	LD	A,H
 477  666E E6 3F        	AND #3F
 478  6670 00              NOP
 479  6671 D3 99        	OUT (#99),A
 480  6673 C9           	RET
 481  6674              ; ****************************************************************************************************
 482  6674               ENDIF
 483  6674
 484  6674               IF (VRAM_CMDS + TILE_CMDS > 0)
 485  6674              ; ****************************************************************************************************
 486  6674              ; function copies data from RAM to VRAM
 487  6674              ; input HL=address in RAM
 488  6674              ; input B=count
 489  6674              ; modifies AF, BC, HL
 490  6674              BBYTECOPY:
 491  6674 0E 98        	LD C,#98
 492  6676              BBYTECOPY_NO_C:
 493  6676 ED A3        	OUTI
 494  6678 C2 76 66     	JP	NZ, BBYTECOPY_NO_C
 495  667B C9           	RET
 496  667C              ; ****************************************************************************************************
 497  667C               ENDIF
 498  667C
 499  667C              ; ****************************************************************************************************
 500  667C              ; function multiplies HL by 32
 501  667C              HLx32:
 502  667C 29           	ADD HL,HL
 503  667D              ; ****************************************************************************************************
 504  667D              ; function multiplies HL by 16
 505  667D              HLx16:
 506  667D 29           	ADD HL,HL
 507  667E              ; ****************************************************************************************************
 508  667E              ; function multiplies HL by 8
 509  667E              HLx8:
 510  667E 29          > ADD HL, HL
 510  667F 29          > ADD HL, HL
 510  6680 29          > ADD HL, HL
 511  6681 C9           	RET
 512  6682              ; ****************************************************************************************************
 513  6682
 514  6682              ; ****************************************************************************************************
 515  6682              ; function gets slot and subslot data for specific page
 516  6682              ; input A=page (0, 1 or 2)
 517  6682              ; output B = 0A8H register value
 518  6682              ; output D = 0 is no subslots, 1 if yes
 519  6682              ; output C = 0A8H value when page 3 slot equals to requested page slot
 520  6682              ; output E = subslot value if present
 521  6682              ; modifies AF, BC, DE, HL
 522  6682              GET_PAGE_INFO:
 523  6682 6F               LD L, A
 524  6683 C6 C1            ADD A, low (EXPTBL)
 525  6685 32 8F 66         LD (GET_PAGE_INFO_L1+1), A
 526  6688 DB A8            IN A, (0A8H)
 527  668A 47               LD B, A
 528  668B E6 3F            AND 03FH
 529  668D 4F               LD C, A
 530  668E              GET_PAGE_INFO_L1:
 531  668E 3A C1 FC         LD A, (EXPTBL) ; modified by code above
 532  6691 E6 80            AND 080H
 533  6693 28 1B            JR Z, GET_PAGE_INFO_L2
 534  6695                  ; expanded
 535  6695 2D               DEC L
 536  6696 FA B5 66         JP M, GET_PAGE_INFO_L3
 537  6699 2D               DEC L
 538  669A FA B3 66         JP M, GET_PAGE_INFO_L4
 539  669D                  ; page 2
 540  669D 07               RLCA
 541  669E 07               RLCA
 542  669F              GET_PAGE_INFO_L5:
 543  669F E6 C0            AND 0C0H
 544  66A1 B1               OR C
 545  66A2 D3 A8            OUT (0A8H), A ; slot 3 = slot of page requested
 546  66A4 4F               LD C, A
 547  66A5 3A FF FF         LD A, (0FFFFH)
 548  66A8 2F               CPL
 549  66A9 5F               LD E, A
 550  66AA 16 01            LD D, 1
 551  66AC 78               LD A, B ; return stack
 552  66AD D3 A8            OUT (0A8H), A
 553  66AF C9               RET
 554  66B0              GET_PAGE_INFO_L2:
 555  66B0                  ; not expanded
 556  66B0 16 00            LD D, 0
 557  66B2 C9               RET
 558  66B3              GET_PAGE_INFO_L4:
 559  66B3                  ; page 1
 560  66B3 0F               RRCA
 561  66B4 0F               RRCA
 562  66B5              GET_PAGE_INFO_L3:
 563  66B5                  ; page 0
 564  66B5 0F               RRCA
 565  66B6 0F               RRCA
 566  66B7 18 E6            JR GET_PAGE_INFO_L5
 567  66B9              ; ****************************************************************************************************
 568  66B9
 569  66B9              ; ****************************************************************************************************
 570  66B9              ; function returns original slot and subslot info
 571  66B9              ; input B = 0A8H register value
 572  66B9              ; input D = 0 is no subslots, 1 if yes
 573  66B9              ; input C = 0A8H value when page 3 slot equals to requested page slot
 574  66B9              ; input E = subslot value if present
 575  66B9              ; modifies AF, disables interrupts
 576  66B9              RESTORE_PAGE_INFO:
 577  66B9 F3              DI
 578  66BA 7A              LD A, D
 579  66BB B7              OR A
 580  66BC 28 07           JR Z, RESTORE_PAGE_INFO_L1
 581  66BE 79              LD A, C
 582  66BF D3 A8           OUT (0A8H), A
 583  66C1 7B              LD A, E
 584  66C2 32 FF FF        LD (0FFFFH), A
 585  66C5              RESTORE_PAGE_INFO_L1:
 586  66C5 78              LD A, B
 587  66C6 D3 A8           OUT (0A8H), A
 588  66C8              NOACTION_DEFUSR: ; just a safe RET for use when DEFUSR table has an empty entry
 589  66C8 C9              RET
 590  66C9              ; ****************************************************************************************************
 591  66C9
 592  66C9              ; *******************************************************************************************************
 593  66C9              ; SELECTS A SLOT IN THE PAGE SPECIFIED BY AN ADDRESS.
 594  66C9              ; INPUT:  A = SLOT ID: EXXXSSPP
 595  66C9              ; E = EXPANDED FLAG
 596  66C9              ; SS = SECONDARY SLOT NUMBER (ONLY IF EXPANDED)
 597  66C9              ; PP = PRIMARY SLOT NUMBER
 598  66C9              ;     HL = ADDRESS INSIDE THE PAGE TO CHANGE
 599  66C9              ; CHANGES: AF, BC, DE
 600  66C9
 601  66C9              LOCAL_ENASLT:
 602  66C9 CD E9 66         CALL L0353
 603  66CC FA D6 66         JP M, L0340
 604  66CF DB A8            IN A, (0A8H)
 605  66D1 A1               AND C
 606  66D2 B0               OR B
 607  66D3 D3 A8            OUT (0A8H), A
 608  66D5 C9               RET
 609  66D6              L0340:
 610  66D6 E5               PUSH HL
 611  66D7 CD 0E 67         CALL L0378
 612  66DA 4F               LD C, A
 613  66DB 06 00            LD B, 0
 614  66DD 7D               LD A, L
 615  66DE A4               AND H
 616  66DF B2               OR D
 617  66E0 21 C5 FC         LD HL, 0FCC5H
 618  66E3 09               ADD HL, BC
 619  66E4 77               LD (HL), A
 620  66E5 E1               POP HL
 621  66E6 79               LD A, C
 622  66E7 18 E0            JR LOCAL_ENASLT
 623  66E9              L0353:
 624  66E9 F3               DI
 625  66EA F5               PUSH AF
 626  66EB 7C               LD A, H
 627  66EC 07               RLCA
 628  66ED 07               RLCA
 629  66EE E6 03            AND 3
 630  66F0 5F               LD E, A
 631  66F1 3E C0            LD A, 0C0H
 632  66F3              L035D:
 633  66F3 07               RLCA
 634  66F4 07               RLCA
 635  66F5 1D               DEC E
 636  66F6 F2 F3 66         JP P, L035D
 637  66F9 5F               LD E, A
 638  66FA 2F               CPL
 639  66FB 4F               LD C, A
 640  66FC F1               POP AF
 641  66FD F5               PUSH AF
 642  66FE E6 03            AND 3
 643  6700 3C               INC A
 644  6701 47               LD B, A
 645  6702 3E AB            LD A, 0ABH
 646  6704              L036E:
 647  6704 C6 55            ADD A, 055H
 648  6706 10 FC            DJNZ L036E
 649  6708 57               LD D, A
 650  6709 A3               AND E
 651  670A 47               LD B, A
 652  670B F1               POP AF
 653  670C A7               AND A
 654  670D C9               RET
 655  670E              L0378:
 656  670E F5               PUSH AF
 657  670F 7A               LD A, D
 658  6710 E6 C0            AND 0C0H
 659  6712 4F               LD C, A
 660  6713 F1               POP AF
 661  6714 F5               PUSH AF
 662  6715 57               LD D, A
 663  6716 DB A8            IN A, (0A8H)
 664  6718 47               LD B, A
 665  6719 E6 3F            AND 03FH
 666  671B B1               OR C
 667  671C D3 A8            OUT (0A8H), A
 668  671E 7A               LD A, D
 669  671F 0F               RRCA
 670  6720 0F               RRCA
 671  6721 E6 03            AND 3
 672  6723 57               LD D, A
 673  6724 3E AB            LD A, 0ABH
 674  6726              L0390:
 675  6726 C6 55            ADD A, 055H
 676  6728 15               DEC D
 677  6729 F2 26 67         JP P, L0390
 678  672C A3               AND E
 679  672D 57               LD D, A
 680  672E 7B               LD A, E
 681  672F 2F               CPL
 682  6730 67               LD H, A
 683  6731 3A FF FF         LD A, (0FFFFH)
 684  6734 2F               CPL
 685  6735 6F               LD L, A
 686  6736 A4               AND H
 687  6737 B2               OR D
 688  6738 32 FF FF         LD (0FFFFH), A
 689  673B 78               LD A, B
 690  673C D3 A8            OUT (0A8H), A
 691  673E F1               POP AF
 692  673F E6 03            AND 3
 693  6741 C9               RET
 694  6742              ; *******************************************************************************************************
 695  6742
 696  6742              ; *******************************************************************************************************
 697  6742              ; some common code to activate page 0 and place values needed to restore original page on stack
 698  6742              ; input IY=return address
 699  6742              ENABLE_PAGE0:
 700  6742 F3              DI
 701  6743 AF              XOR A
 702  6744 CD 82 66        CALL GET_PAGE_INFO
 703  6747 C5              PUSH BC
 704  6748 D5              PUSH DE
 705  6749 3A 41 F3        LD A, (RAMAD0)
 706  674C 26 00           LD H, 0
 707  674E CD C9 66        CALL LOCAL_ENASLT
 708  6751 FD E9        	JP (IY)
 709  6753              ; *******************************************************************************************************
 710  6753
 711  6753              ; General BASIC CALL-instruction handler
 712  6753              CALLHAND:
 713  6753 FB              EI
 714  6754 E5           	PUSH HL
 715  6755 21 6C 64     	LD	HL, CMDS ; pointer table based on starting letter
 716  6758 3A 89 FD        LD A, (PROCNM)
 717  675B D6 41           SUB 'A'
 718  675D 87              ADD A, A
 719  675E 16 00           LD D, 0
 720  6760 5F              LD E, A
 721  6761 19              ADD HL, DE
 722  6762 5E              LD E, (HL)
 723  6763 23              INC HL
 724  6764 56              LD D, (HL)
 725  6765 7A              LD A, D
 726  6766 B3              OR E
 727  6767 28 23           JR Z, .CMDNOTRECOGNIZED
 728  6769 EB              EX DE, HL
 729  676A              .CHKCMD:
 730  676A 11 89 FD     	LD	DE, PROCNM
 731  676D              .LOOP:
 732  676D 1A              LD	A,(DE)
 733  676E BE           	CP	(HL)
 734  676F 20 11        	JR	NZ,.TONEXTCMD	; Not equal
 735  6771 13           	INC	DE
 736  6772 23           	INC	HL
 737  6773 A7           	AND	A
 738  6774 20 F7        	JR	NZ,.LOOP	; No end of instruction name, go checking
 739  6776 5E           	LD	E,(HL)
 740  6777 23           	INC	HL
 741  6778 56           	LD	D,(HL)
 742  6779 E1           	POP	HL		; routine address
 743  677A CD 9B 67     	CALL	GETPREVCHAR
 744  677D CD 8F 67     	CALL	.CALLDE		; Call routine
 745  6780 A7           	AND	A
 746  6781 C9           	RET
 747  6782
 748  6782              .TONEXTCMD:
 749  6782 0E FF        	LD	C,0FFH
 750  6784 AF           	XOR	A
 751  6785 ED B1        	CPIR			; Skip to end of instruction name
 752  6787 23           	INC	HL
 753  6788 23           	INC	HL		; Skip address
 754  6789 BE           	CP	(HL)
 755  678A 20 DE        	JR	NZ,.CHKCMD	; Not end of table, go checking
 756  678C              .CMDNOTRECOGNIZED:
 757  678C E1           	POP	HL
 758  678D 37              SCF
 759  678E C9           	RET
 760  678F
 761  678F              .CALLDE:
 762  678F D5           	PUSH	DE
 763  6790 C9           	RET
 764  6791
 765  6791              ;---------------------------
 766  6791
 767  6791              CHKCHAR:
 768  6791 CD 9B 67     	CALL	GETPREVCHAR	; Get previous basic char
 769  6794 E3           	EX	(SP),HL
 770  6795 BE           	CP	(HL) 	        ; Check if good char
 771  6796 20 29        	JR	NZ,SYNTAX_ERROR	; No, Syntax error
 772  6798 23           	INC	HL
 773  6799 E3           	EX	(SP),HL
 774  679A 23           	INC	HL		; Get next basic char
 775  679B
 776  679B              GETPREVCHAR:
 777  679B 2B           	DEC HL
 778  679C DD 21 66 46  	LD	IX,CHRGTR
 779  67A0 CD 59 01     	CALL CALBAS
 780  67A3 FB              EI
 781  67A4 C9              RET
 782  67A5
 783  67A5               IF (1 == 1)
 784  67A5               IF (DLOAD_CMD == 1)
 785  67A5              BAD_FILENAME:
 786  67A5 1E 38           LD E,56
 787  67A7 18 1A           JR THROW_ERROR
 788  67A9              DISKIOERR:
 789  67A9 1E 45           LD E,69
 790  67AB 18 16           JR THROW_ERROR
 791  67AD               ENDIF
 792  67AD              OUT_OF_DATA:
 793  67AD 1E 04           LD E, 4
 794  67AF 18 12           JR THROW_ERROR
 795  67B1              TYPE_MISMATCH:
 796  67B1 1E 0D           LD E, 13 ; Type mismatch
 797  67B3 18 0E           JR THROW_ERROR
 798  67B5              SUBSCRIPT_OUT_OF_RANGE:
 799  67B5 1E 09           LD E,9 ; subscript out of range
 800  67B7 18 0A        	JR THROW_ERROR
 801  67B9              OVERFLOW:
 802  67B9 1E 06        	LD E,6
 803  67BB 18 06        	JR THROW_ERROR
 804  67BD              ILLEGAL_FUNCTION:
 805  67BD 1E 05           LD E, 5 ; illegal function call
 806  67BF 18 02           JR THROW_ERROR
 807  67C1               ENDIF
 808  67C1              SYNTAX_ERROR:
 809  67C1 1E 02           LD E, 2 ; Syntax error
 810  67C3              THROW_ERROR:
 811  67C3 DD 21 6F 40  	LD	IX,ERRHAND	; Call the Basic error handler
 812  67C7 C3 59 01     	JP	CALBAS
 813  67CA
 814  67CA
 815  67CA              ;---------------------------
 816  67CA
 817  67CA               IF (DLOAD_CMD == 1)
 818  67CA              ; *******************************************************************************************************
 819  67CA              ; helper function to make an uppercase letter
 820  67CA              ; input A=character
 821  67CA              ; output A=uppercase version of input
 822  67CA              UPPER:
 823  67CA FE 61           CP "a"
 824  67CC D8              RET C
 825  67CD FE 7B           CP "z"+1
 826  67CF D0              RET NC
 827  67D0 E6 5F           AND 5FH
 828  67D2 C9              RET
 829  67D3              ; *******************************************************************************************************
 830  67D3               ENDIF
 831  67D3
 832  67D3               IF (1 == 1)
 833  67D3
 834  67D3               IF (DLOAD_CMD == 1)
 835  67D3              ; *******************************************************************************************************
 836  67D3              ; helper function to return string pointer and length
 837  67D3              ; returns HL = String Address
 838  67D3              ; returns B  = Lenght
 839  67D3              ; modifies BC, DE, HL
 840  67D3              GETSTRPNT:
 841  67D3 2A F8 F7        LD      HL,(USR)
 842  67D6 46              LD      B,(HL)
 843  67D7 23              INC     HL
 844  67D8 5E              LD      E,(HL)
 845  67D9 23              INC     HL
 846  67DA 56              LD      D,(HL)
 847  67DB EB              EX      DE,HL
 848  67DC C9              RET
 849  67DD              ; *******************************************************************************************************
 850  67DD
 851  67DD              ; *******************************************************************************************************
 852  67DD              ; helper function to get string parameter
 853  67DD              ; throws error if incorrect type
 854  67DD              ; input HL=basic text
 855  67DD              EVALTXTPARAM:
 856  67DD DD 21 64 4C  	LD	IX,FRMEVL
 857  67E1 CD 59 01     	CALL CALBAS		; Evaluate expression
 858  67E4 3A 63 F6        LD A,(VALTYP)
 859  67E7 FE 03           CP 3               ; Text type?
 860  67E9 C2 B1 67        JP NZ,TYPE_MISMATCH
 861  67EC E5              PUSH HL
 862  67ED DD 21 D0 67     LD	IX,FRESTR         ; Free the temporary string
 863  67F1 CD 59 01        CALL CALBAS
 864  67F4 E1              POP HL
 865  67F5 C9              RET
 866  67F6              ; *******************************************************************************************************
 867  67F6
 868  67F6               ENDIF
 869  67F6
 870  67F6              ; *******************************************************************************************************
 871  67F6              ; helper function to get pointer to BASIC array data
 872  67F6              ; input A=data type (2=INT,4=SINGLE,8=DOUBLE)
 873  67F6              ; input B=dimensions (1 or 2)
 874  67F6              ; input D=minimal first dimension
 875  67F6              ; input E=minimal second dimension, if applicable
 876  67F6              ; returns BC=pointer to first data element
 877  67F6              ; throws BASIC error if invalid type
 878  67F6              GET_BASIC_ARRAY_DATA_POINTER:
 879  67F6 D5           	PUSH DE
 880  67F7 C5           	PUSH BC
 881  67F8 F5           	PUSH AF
 882  67F9 3E 01           LD A,1
 883  67FB 32 A5 F6        LD (SUBFLG),A ; search for arrays only
 884  67FE DD 21 A4 5E  	LD IX, PTRGET
 885  6802 CD 59 01     	CALL CALBAS
 886  6805 AF              XOR A
 887  6806 32 A5 F6        LD (SUBFLG),A ; if not reset will cause syntax errors
 888  6809 3A 63 F6     	LD A,(VALTYP)
 889  680C D1           	POP DE ; required type
 890  680D BA           	CP D
 891  680E C2 B1 67     	JP NZ,TYPE_MISMATCH
 892  6811 0A           	LD A,(BC)
 893  6812 03           	INC BC
 894  6813 D1           	POP DE ; required number of dimensions
 895  6814 BA           	CP D
 896  6815 C2 B1 67     	JP NZ,TYPE_MISMATCH
 897  6818 D1           	POP DE ; required minimal array dimensions
 898  6819 3D           	DEC A
 899  681A 28 07        	JR Z,.ONE_DIMENSION
 900  681C              	; 2-dimension array
 901  681C 0A           	LD A,(BC)
 902  681D 03          > INC BC
 902  681E 03          > INC BC
 903  681F BB           	CP E
 904  6820 DA B5 67     	JP C,SUBSCRIPT_OUT_OF_RANGE
 905  6823              .ONE_DIMENSION:
 906  6823 0A           	LD A,(BC)
 907  6824 03          > INC BC
 907  6825 03          > INC BC
 908  6826 BA           	CP D
 909  6827 DA B5 67     	JP C,SUBSCRIPT_OUT_OF_RANGE
 910  682A C9           	RET
 911  682B              ; *******************************************************************************************************
 912  682B               ENDIF
 913  682B
 914  682B              ; *******************************************************************************************************
 915  682B              ; function to handle CALL ARTINFO basic extension
 916  682B              ; returns info about the extension
 917  682B              ; _ARTINFO ( INT variable version,
 918  682B              ;			    INT variable build_flags,
 919  682B              ;			    INT variable free_memory_ptr )
 920  682B              ; this function is always available and can be used to test if the extension is active
 921  682B              ARTINFO:
 922  682B              	; opening (
 923  682B CD 91 67     	CALL CHKCHAR
 924  682E 28           	DB '('
 925  682F              	; get address of version variable
 926  682F DD 21 A4 5E  	LD IX, PTRGET
 927  6833 CD 59 01     	CALL CALBAS
 928  6836 3A 12 40     	LD A,(VERSION)
 929  6839 12              LD (DE),A
 930  683A 13              INC DE
 931  683B 3A 13 40        LD A,(VERSION+1)
 932  683E 12              LD (DE),A
 933  683F              	; comma
 934  683F CD 91 67     	CALL CHKCHAR
 935  6842 2C           	DB ','
 936  6843              	; get address of build flags variable
 937  6843 DD 21 A4 5E  	LD IX, PTRGET
 938  6847 CD 59 01     	CALL CALBAS
 939  684A E5              PUSH HL
 940  684B 21 FF 37        LD HL,SOUND_CMDS+2*RAM_CMDS+4*VRAM_CMDS+8*BLIT_CMDS+16*SPRITE_CMDS+32*GENCAL_CMD+64*TILE_CMDS+128*BOX_CMDS+256*ANIM_CMDS+512*COLL_CMD+1024*1+2048*0+4096*DECOMP_CMDS+8192*DLOAD_CMD
 941  684E EB              EX DE,HL
 942  684F 73              LD (HL),E
 943  6850 23              INC HL
 944  6851 72              LD (HL),D
 945  6852 E1              POP HL
 946  6853              	; comma
 947  6853 CD 91 67     	CALL CHKCHAR
 948  6856 2C           	DB ','
 949  6857              	; get address of free memory variable
 950  6857 DD 21 A4 5E  	LD IX, PTRGET
 951  685B CD 59 01     	CALL CALBAS
 952  685E 3A 10 40     	LD A,(FREEMEMPTR)
 953  6861 12              LD (DE),A
 954  6862 13              INC DE
 955  6863 3A 11 40        LD A,(FREEMEMPTR+1)
 956  6866 12              LD (DE),A
 957  6867              	; ending )
 958  6867 CD 91 67     	CALL CHKCHAR
 959  686A 29           	DB ')'
 960  686B C9           	RET
 961  686C              ; *******************************************************************************************************
 962  686C
 963  686C              EXT_END:
 964  686C
# file closed: asm\main.asm
